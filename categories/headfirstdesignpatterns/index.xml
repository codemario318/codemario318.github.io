<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>헤드 퍼스트 디자인 패턴 on Mario Blog</title><link>https://codemario318.github.io/categories/headfirstdesignpatterns/</link><description>Recent content in 헤드 퍼스트 디자인 패턴 on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Mon, 02 Oct 2023 14:29:08 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/categories/headfirstdesignpatterns/index.xml" rel="self" type="application/rss+xml"/><item><title>3. 데코레이터 패턴</title><link>https://codemario318.github.io/post/gof/3/</link><pubDate>Mon, 02 Oct 2023 14:29:08 +0900</pubDate><guid>https://codemario318.github.io/post/gof/3/</guid><description>&lt;img src="https://codemario318.github.io/post/gof/3/cover.png" alt="Featured image of post 3. 데코레이터 패턴" />&lt;p>데코레이터 패턴은 객체 작성이라는 형식으로 실행 중에 클래스를 꾸미는 방법이다.&lt;/p>
&lt;p>데코레이터 패턴을 활용하면 기존 클래스 코드를 바꾸지 않고도 객체에 새로운 임무를 추가할 수 있다.&lt;/p>
&lt;h2 id="데코레이터-패턴">데코레이터 패턴&lt;/h2>
&lt;p>데코레이터 패턴은 기존 코드를 건드리지 않고 확장으로 새로운 행동을 추가하는 것이 목적이다. 이를 통해 새로운 기능을 추가할 때 급변하는 주변 환경에 작 적응하는 유연하고 튼튼한 디자인을 만들 수 있다.&lt;/p>
&lt;h3 id="ocpopen-close-principle-살펴보기">OCP(Open-Close Principle) 살펴보기&lt;/h3>
&lt;blockquote>
&lt;p>클래스는 확장에는 열려있어야 하지만 변경에는 닫혀 있어야 한다.&lt;/p>
&lt;/blockquote>
&lt;p>확정에는 열려있고 변경에는 닫혀있다는 것은 모순처럼 보일 수 있으나 코드를 변경하지 않아도 시스템을 확장하게 해 주는 객체지향 기법은 많다.(ex. 옵저버 패턴)&lt;/p>
&lt;p>데코레이터 패턴도 이 중 하나로 확장하려고 코드를 직접 수정하는 일을 방지하는 방법을 제공한다.&lt;/p>
&lt;blockquote>
&lt;p>모든 부분에서 OCP를 준수하는 것은 불가능하다.&lt;br>
OCP를 준수하는 객체지향 디자인을 만들려면 많은 노력이 필요하고, 디자인의 모든 부분을 깔끔하게 정돈할 만큼 여유가 있는 상황도 흔치 않다(굳이 그렇게 할 필요가 없다).&lt;br>
따라서 디자인한 것 중에서 가장 바뀔 가능성이 높은 부분을 중점적으로 살펴보고 OCP를 적용하는 방법이 가장 좋다.&lt;/p>
&lt;/blockquote>
&lt;p>코드에서 확장해야 할 부분을 선택할 때는 세심한 주의가 필요하다.&lt;/p>
&lt;ul>
&lt;li>무조건 OCP를 적용한다면 쓸데없는 일을 하며 시간을 낭비할 수 있다.&lt;/li>
&lt;li>필요 이상으로 복잡하고 이해하기 힘든 코드를 만드렉 될 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="데코레이터-패턴-살펴보기">데코레이터 패턴 살펴보기&lt;/h3>
&lt;p>이후 예시에서 설명할 스타버즈에서 음료 가격과 첨가물 가격을 합해 총 가격을 산출하는 방법은 좋은 방법이 아니었다.&lt;/p>
&lt;ul>
&lt;li>클래스가 매우 많아진다.&lt;/li>
&lt;li>일부 서브클래스에는 적합하지 않은 기능을 추가해야 한다.&lt;/li>
&lt;/ul>
&lt;p>일단 기본 단위에서 시작하여 추가되는 요소들로 최소 단위를 장식(decorate)하는 방법을 고려할 수 있다.&lt;/p>
&lt;ol>
&lt;li>가장 기본이 되는 객체를 가져온다.&lt;/li>
&lt;li>추가되는 요소들로 장식한다.&lt;/li>
&lt;li>최종 결과물을 만들어내는 메소드를 호출한다.
&lt;ul>
&lt;li>추가 요소들의 결과를 만드는 일은 해당 객체에게 위임한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>데코레이터 패턴은 위와 같은 방식을 추가되는 요소 객체로 래핑하는 방식으로 구현한다.&lt;/p>
&lt;ul>
&lt;li>데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다.&lt;/li>
&lt;li>한 객체를 여러개의 데코레이터로 감쌀 수 있다.&lt;/li>
&lt;li>데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체가 들어갈 자리에 데코레이터 객체를 넣어도 상관없다.&lt;/li>
&lt;li>&lt;strong>데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있다.&lt;/strong>&lt;/li>
&lt;li>객체는 언제든 감쌀 수 있으므로 실행 중에 필요한 데코레이터를 마음대로 적용할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="데코레이터-패턴의-정의">데코레이터 패턴의 정의&lt;/h3>
&lt;blockquote>
&lt;p>데코레이터 패턴으로 객체에 추가 요소를 동적으로 더할 수 있다.&lt;br>
데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있다.&lt;/p>
&lt;/blockquote>
&lt;pre class="mermaid">classDiagram
class Component {
methodA()
methodB()
}
class ConcreteComponent {
methodA()
methodB()
}
class Decorator {
Component wrappedObj
methodA()
methodB()
}
class ConcreteDecoratorA {
methodA()
methodB()
newBehavior()
}
class ConcreteDecoratorB {
Object newState
methodA()
methodB()
newBehavior()
}
Component &lt;-- ConcreteComponent
Component &lt;-- Decorator
Component &lt;.. Decorator : 구성 요소
Decorator &lt;-- ConcreteDecoratorA
Decorator &lt;-- ConcreteDecoratorB
&lt;/pre>
&lt;ul>
&lt;li>Component: 각 구성 요소는 직접 쓰일 수 있고 데코레이터에 감싸여 쓰일 수도 있다.&lt;/li>
&lt;li>ConcreteComponent: 새로운 행동을 동적으로 추가한다.&lt;/li>
&lt;li>Decorator: 자신이 장식할 구성 요소와 같은 인터페이스 또는 추상 클래스를 구현한다.
&lt;ul>
&lt;li>각 데코레이터 안에는 Component 객체가 들어있어야 하므로 구성 요소의 레퍼런스를 포함한 인스턴스 변수가 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ConcreteDecorator: 데코레이터가 감싸고 있는 Component 객체용 인스턴스 변수가 있으며 Component의 상태를 확장할 수 있다.
&lt;ul>
&lt;li>데코레이터가 사로운 메소드를 추가할 수도 있으나 일반적으로 새로운 메소드를 추가하는 대신 Component에 원래 있던 메소드를 별도의 작업으로 처리하여 새로운 기능을 추가한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="데코레이터의-상속과-구성">데코레이터의 상속과 구성&lt;/h3>
&lt;p>데코레이터에서는 전략 패턴처럼 구성을 이용하여 행동을 분리하지 않고, 데코레이터로 감싸는 객체의 형식과 같게 구성하여, 상속을 통해 형식을 맞추게 된다.&lt;/p>
&lt;ul>
&lt;li>상속으로 행동을 물려받지 않고, 어떠한 구성 요소를 가지고 데코레이터를 만들 때 새로운 행동을 추가한다.
&lt;ul>
&lt;li>추상 클래스, 인터페이스 등으로 형식을 맞추고 상속을 통해 행동을 구현하도록 하여 구성을 이용하게 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데코레이터를 감싸기 위해 만든 인스턴스 변수에 저장되는 데코레이터에 행동을 구현하여 할당하는 방식으로 구성을 이용한다.&lt;/li>
&lt;li>객체의 구성(인스턴스 변수로 다른 객체를 저장하는 방식)을 이용하고 있으므로, 데코레이터가 다양하게 추가되어도 유연성을 잃지 않을 수 있게 된다.
&lt;ul>
&lt;li>상속만 써야 했다면 행동이 컴파일 시 슈퍼클래스에서 받은 것과 코드로 오버라이드 한 것만 쓸수 있게 정적으로 결정되어 버린다.&lt;/li>
&lt;li>데코레이터가 감싼 데코레이터의 동작을 구현하는 것으로 구성을 활용하면 실행 중에 원하는 데코레이터를 마음대로 조합해서 사용할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="데코레이터의-단점">데코레이터의 단점&lt;/h3>
&lt;p>&lt;strong>java.io 패키지&lt;/strong>&lt;/p>
&lt;p>&lt;code>java.io&lt;/code> 패키지는 파일에서 데이터를 읽어오는 스트림에 기능을 더하는 데코레이터를 사용하는 객체로 구성되어 있어 굉장히 많은 클래스가 있다.&lt;/p>
&lt;p>추상 데코레이터 클래스(추상 구성 요소) 역할을 수행하는 &lt;code>InputStream&lt;/code>을 꾸미는 &lt;code>FilterInputStream&lt;/code>와 &lt;code>FilterInputStream&lt;/code>를 꾸미는 &lt;code>BufferedInputStream&lt;/code>, &lt;code>ZipInputStream&lt;/code> 을 꾸미는 형식으로 계속 확장하는 방식으로 설계되어 있다.&lt;/p>
&lt;pre class="mermaid">flowchart BT
a[InputStream]
aa[FileInputStream]
b[StringBufferInputStream]
c[ByteArrayInputStream]
d[FilterInputStream]
e[PushbackInputStream]
f[BufferedInputStream]
g[DataInputStream]
h[InflatorInputStream]
i[ZipInputStream]
i --> h
e --> d
f --> d
g --> d
h --> d
aa --> a
b --> a
c --> a
d --> a
&lt;/pre>
&lt;p>결과적으로 만들어져 있는 많은 클래스들이 &lt;code>InputSteram&lt;/code>을 감싸 주는 래퍼 클래스로 작동하게 된다.&lt;/p>
&lt;hr>
&lt;ol>
&lt;li>
&lt;p>잡다한 클래스가 너무 많아진다.&lt;/p>
&lt;ul>
&lt;li>데코레이터가 어떤 식으로 작동하는지 이해하면 다른 사람이 구현한 데코레이터 패턴을 활용해도 개발하기 쉽다.
&lt;ul>
&lt;li>잘 모든다면 활용하기 어렵다.&lt;/li>
&lt;li>클래스가 어떤 식으로 구성되어 있는지를 먼저 파악해야 사용하기 쉽다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>특정 형식에 의존하는 코드에 데코레이터 패턴을 적용하면 엉망이 될 수 있다.&lt;/p>
&lt;ul>
&lt;li>데코레이터의 장점인 &lt;strong>데코레이터를 끼워 넣어도 클라이언트는 데코레이터를 사용하고 있다는 사실을 전혀 알 수 없다&lt;/strong>는 장점을 누릴 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>구성 요소를 초기화하는 데 필요한 코드가 훨씬 복잡해진다.&lt;/p>
&lt;ul>
&lt;li>구성 요소 인스턴스만 만든다고 끊나지 않고 많은 데코레이터로 감싸야 하는 경우가 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>구상 구성 요소로 어떤 작업을 처리하는 코드에 데코레이터 패턴을 적용하면 코드가 제대로 작동하지 않고, 반대로 추상 구성 요소로 돌아가는 코드에는 데코레이터 패턴을 적용해야만 제대로된 결과를 얻을 수 있다.&lt;/p>
&lt;ul>
&lt;li>구상 구성 요소로 돌아가는 코드를 만들어야 한다면 데코레이터 패턴 사용을 다시 한번 생각해봐야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>데코레이터 패턴을 쓰면 관리해야 할 객체가 늘어나므로 실수할 가능성도 높아질 수 있다.&lt;/p>
&lt;ul>
&lt;li>실제로는 팩토리나 빌더 같은 다른 패턴으로 데코레이터를 만들고 사용하게된다.&lt;/li>
&lt;li>이러한 패턴을 배운다면 데코레이터로 장식된 구상 구성 요소는 캡슐화가 잘 되므로 실수할 가능성을 줄이게된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="초대형-커피-전문점-스타버즈">초대형 커피 전문점, 스타버즈&lt;/h2>
&lt;h3 id="최초-주문-시스템">최초 주문 시스템&lt;/h3>
&lt;pre class="mermaid">classDiagram
class Beverage {
description
getDescription()
cost()
}
class HouseBlend {
cost()
}
class DarkRoast {
cost()
}
class Decaf {
cost()
}
class Espresso {
cost()
}
Beverage &lt;-- HouseBlend
Beverage &lt;-- DarkRoast
Beverage &lt;-- Decaf
Beverage &lt;-- Espresso
&lt;/pre>
&lt;ul>
&lt;li>Beverage: 음료를 나타내는 추상 클래스
&lt;ul>
&lt;li>매장에서 판매되는 모든 음료는 이 클래스의 서브클라스임&lt;/li>
&lt;li>description: 각 서브클래스에서 설정되는 음료 설명&lt;/li>
&lt;li>cost(): 추상메소드로서 서브클래스에서 구현해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="상속을-이용한-개선">상속을 이용한 개선&lt;/h3>
&lt;p>고객이 커피를 주문할 때 우유나 두유, 모카 등 추가 항목을 얹기도 하므로 그때마다 가격이 올라가야한다.&lt;/p>
&lt;p>각각에 대응하는 서브클래스를 만드는 방법도 있지만, 인스턴스 변수와 슈퍼클래스 상속을 통해 개선될 수 있다.&lt;/p>
&lt;pre class="mermaid">classDiagram
class Beverage {
description
+milk
+soy
+mocha
+whip
getDescription()
cost()
+has...()
+set...()
}
class HouseBlend {
cost()
}
class DarkRoast {
cost()
}
class Decaf {
cost()
}
class Espresso {
cost()
}
Beverage &lt;-- HouseBlend
Beverage &lt;-- DarkRoast
Beverage &lt;-- Decaf
Beverage &lt;-- Espresso
&lt;/pre>
&lt;h3 id="상속을-이용한-개선의-문제점">상속을 이용한 개선의 문제점&lt;/h3>
&lt;p>각각 옵션에 대응하는 서브클래스를 만드는 방법보다는 나은 방법이지만 여전히 문제점은 존재한다.&lt;/p>
&lt;ul>
&lt;li>첨가물 가격이 바뀔 때마다 기존 코드를 수정해야한다.&lt;/li>
&lt;li>첨가물의 종류가 많아지면 새로운 메소드를 추가해야 하고, 슈퍼클래스의 cost() 메소드도 고쳐야한다.&lt;/li>
&lt;li>특정 첨가물이 들어가면 안되는 음료가 추가된다면 막는 작업이 필요하다. 등&lt;/li>
&lt;/ul>
&lt;h3 id="데코레이터-패턴-적용하기">데코레이터 패턴 적용하기&lt;/h3>
&lt;p>다크로스트에 모카, 휘핑 추가를 수행하게 될 경우 아래와 같은 과정을 거쳐야한다.&lt;/p>
&lt;ol>
&lt;li>DarkRoast 객체에서 시작한다.&lt;/li>
&lt;li>Mocha 객체를 만들고 그 객체로 DarkRoast 객체를 감싼다.&lt;/li>
&lt;li>Whip 데코레이터를 만들어 Mocha를 감싼다.&lt;/li>
&lt;li>가격을 계산한다.
&lt;ul>
&lt;li>가장 바깥쪽에 있는 데코레이터인 Whip의 cost()를 호출한다.&lt;/li>
&lt;li>Whip은 장식하고 있는 객체에게 가격 계산을 위임하고, 가격이 구해지면 계산된 가격에 휘핑크림의 가격을 더한 다음 결과값을 리턴한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="berverage-클래스-장식하기">Berverage 클래스 장식하기&lt;/h3>
&lt;pre class="mermaid">classDiagram
class Beverage {
description
getDescription()
cost()
}
class HouseBlend {
cost()
}
class DarkRoast {
cost()
}
class Decaf {
cost()
}
class Espresso {
cost()
}
Beverage &lt;-- HouseBlend
Beverage &lt;-- DarkRoast
Beverage &lt;-- Decaf
Beverage &lt;-- Espresso
class CondimentDecorator {
getDescription()
}
Beverage &lt;-- CondimentDecorator
Beverage &lt;.. CondimentDecorator : 구성 요소
class Milk {
Beverage beverage
cost()
getDescription()
}
class Mocha {
Beverage beverage
cost()
getDescription()
}
class Soy {
Beverage beverage
cost()
getDescription()
}
class Whip {
Beverage beverage
cost()
getDescription()
}
CondimentDecorator &lt;-- Milk
CondimentDecorator &lt;-- Mocha
CondimentDecorator &lt;-- Soy
CondimentDecorator &lt;-- Whip
&lt;/pre>
&lt;h3 id="커피-주문-시스템-코드-만들기">커피 주문 시스템 코드 만들기&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Beverage&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">String&lt;/span> &lt;span class="n">description&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;제목 없음&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">getDescription&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">description&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="nf">cost&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Beverage 객체가 들어갈 자리에 들어갈 수 있어야 하므로 Beverage 클래스를 확장한다.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">CondimentDecorator&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">Beverage&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 데코레이터가 감쌀 음료를 나타내는 Beverage 객체를 지정한다.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 음료를 지정할 때는 데코레이터에서 어떤 음료든 감쌀 수 있도록 슈퍼 클래스 유형을 이용한다.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Beverage&lt;/span> &lt;span class="n">beverage&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">getDescription&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Beverage 객체를 확장하여 기본 음료를 만든다.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Espresso&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">Beverage&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="nf">Espresso&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">description&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;에스프레소&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@java.lang.Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="nf">cost&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mf">1.99&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * CondimentDecorator를 확장하여 데코레이터를 만든다.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Mocha&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">CondimentDecorator&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 감싸고자 하는 음료를 저장하는 데코레이터 인스턴스 변수를 초기화 한다.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * @param beverage
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="nf">Mocha&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Beverage&lt;/span> &lt;span class="n">beverage&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">beverage&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">beverage&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@java.lang.Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">getDescription&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">beverage&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getDescription&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;, 모카&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@java.lang.Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="nf">cost&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">beverage&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">cost&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mf">.20&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="핵심-정리">핵심 정리&lt;/h2>
&lt;ul>
&lt;li>객체지향 원칙
&lt;ul>
&lt;li>+ 클래스는 확장에는 열려있어야 하지만 변경에는 닫혀 있어야 한다(OCP).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객체지향 패턴
&lt;ul>
&lt;li>+ 데코레이터 패턴
&lt;ul>
&lt;li>객체에 추가 요소를 동적으로 더할 수 있다.&lt;/li>
&lt;li>서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ul>
&lt;li>디자인의 유연성 면에서 보면 상속으로 확장하는 일은 별로 좋은 선택은 아니다.&lt;/li>
&lt;li>기존 코드 수정 없이 행동을 확장해야 하는 상황도 있다.&lt;/li>
&lt;li>구성과 위임으로 실행 중에 새로운 행동을 추가할 수 있다.&lt;/li>
&lt;li>상속 대신 데코레이터 패턴으로 행동을 확장할 수 있다.&lt;/li>
&lt;li>데코레이터 패턴은 구상 구성 요소를 감싸 주는 데코레이터를 사용한다.&lt;/li>
&lt;li>데코레이터 클래스의 형식은 그 클래스가 감싸는 클래스 형식을 반영한다.
&lt;ul>
&lt;li>상속이나 인터페이스 구현으로 자신이 감쌀 클래스와 같은 형식을 가진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데코레이터는 자기가 감싸고 있는 구성 요소의 새로운 기능을 더함으로써 행동을 확장한다.&lt;/li>
&lt;li>구성 요소를 감싸는 데코레이터의 개수에는 제한이 없다.&lt;/li>
&lt;li>구성 요소의 클라이언트는 데코레이터의 존재를 알 수 없다.
&lt;ul>
&lt;li>클라이언트가 구성 요소의 구체적인 형식에 의존하는 경우는 예외&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데코레이터 패턴을 사용하면 자잘한 객체가 매우 많이 추가될 수 있다.
&lt;ul>
&lt;li>데코레이터를 너무 많이 사용하면 코드가 필요 이상으로 복잡해진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>2. 옵저버 패턴</title><link>https://codemario318.github.io/post/gof/2/</link><pubDate>Wed, 27 Sep 2023 13:09:08 +0900</pubDate><guid>https://codemario318.github.io/post/gof/2/</guid><description>&lt;img src="https://codemario318.github.io/post/gof/2/cover.png" alt="Featured image of post 2. 옵저버 패턴" />&lt;p>옵저버 패턴은 중요한 일이 일어났을 때 객체에게 새 소식을 알려 줄 수 있는 패턴이다.&lt;/p>
&lt;p>일대 다 관계나 느슨한 결합같은 개념을 통해 구성되며 자주 사용되는 패턴 중 하나이다.&lt;/p>
&lt;h2 id="옵저버-패턴">옵저버 패턴&lt;/h2>
&lt;blockquote>
&lt;p>옵저버 패턴은 주제(Subject), 옵저버(observer)로 구성된다.&lt;/p>
&lt;/blockquote>
&lt;pre class="mermaid">flowchart LR
a((주제 객체))
subgraph 옵저버 객체
b((객체 1))
c((객체 2))
d((객체 3))
end
a-.->b
a-.->c
a-.->d
&lt;/pre>
&lt;p>이 책에서는 옵저버 패턴을 신문 구독을 예시로 들고 있다.&lt;/p>
&lt;ol>
&lt;li>신문사가 신문을 찍어낸다.&lt;/li>
&lt;li>독자가 특정 신문사에 구독 신청을 하면 구독 해지 전까지 새로운 신문이 나올 때마다 배달을 받을 수 있다.&lt;/li>
&lt;li>신문을 보고싶지 않으면 구독 해지 신청을 한다.&lt;/li>
&lt;li>신문사가 망하지 않는 이상 여러 구독자들은 신문을 구독하거나 해지하는 것을 반복한다.&lt;/li>
&lt;/ol>
&lt;h3 id="옵저버-패턴의-정의">옵저버 패턴의 정의&lt;/h3>
&lt;blockquote>
&lt;p>옵저버 패턴은 일련의 객체 사이에서 일대다 관계를 정의하고, 한 객체의 상태가 변경되면 그 객체에 의존하는 모든 객체에 연락이 간다.&lt;/p>
&lt;/blockquote>
&lt;p>옵저버 패턴은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-two-many) 의존성을 정의한다.&lt;/p>
&lt;ul>
&lt;li>옵저버는 주제에 딸려 있으며 주제의 상태가 바뀌면 옵저버에게 정보가 전달된다.&lt;/li>
&lt;li>보통 주제 인터페이스와 옵저버 인터페이스가 들어있는 클래스 디자인으로 구현한다.&lt;/li>
&lt;/ul>
&lt;h3 id="옵저버-패턴의-구조">옵저버 패턴의 구조&lt;/h3>
&lt;pre class="mermaid">classDiagram
direction LR
class Subject {
&lt;&lt; interface >>
registerObserver()
removeObserver()
notifyObservers()
}
class Observer {
&lt;&lt; interface >>
update()
}
class ConcreteSubject {
registerObserver()
removeObserver()
notifyObservers()
getState()
setState()
}
class ConcreteObserver {
update()
}
Subject --> Observer : 옵저버
ConcreteObserver ..> Observer
ConcreteSubject &lt;-- ConcreteObserver : 주제
Subject &lt;.. ConcreteSubject
&lt;/pre>
&lt;ul>
&lt;li>Subject
&lt;ul>
&lt;li>주제를 나타내는 인터페이스로 객체에서 옵저버로 등록하거나 옵저버 목록에서 탈퇴하고 싶을 때 해당 인터페이스의 메소드를 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Observer
&lt;ul>
&lt;li>옵저버가 될 가능성이 있는 객체는 만드시 Observer 인터페이스를 구현해야 한다.&lt;/li>
&lt;li>주제의 상태가 바뀌었을 때 호출되는 &lt;code>update()&lt;/code> 메소드로만 구성된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ConcreteSubject
&lt;ul>
&lt;li>주제 역할을 하는 구상 클래스는 항상 Subject 인터페이스를 구현해야 한다.&lt;/li>
&lt;li>주제 클래스에는 등록 및 해지용 메소드와 상태가 바뀔 때마다 모든 옵저버에게 연락하는 &lt;code>notifyObservers()&lt;/code> 메소드도 구현해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Concreteobserver
&lt;ul>
&lt;li>Observer 인터페이스만 구현한다면 무엇이든 옵저버 클래스가 될 수 있다.&lt;/li>
&lt;li>각 옵저버는 특정 주제에 등록해서 연략 받을 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>출판-구독(publish-Subscribe) 패턴과의 차이점&lt;/p>
&lt;p>출판-구독 패턴은 구독자가 서로 다른 유형의 메시지에 관심을 가질 수 있고, 출판사와 구독자를 더 세세하게 분리할 수 있는 복잡한 패턴이다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="느슨한-결합의-위력">느슨한 결합의 위력&lt;/h3>
&lt;p>느슨한 결합(Loose Coupling)은 객체들이 상호작용할 수는 있지만, 서로 잘 모르는 관계를 의미한다.&lt;/p>
&lt;ul>
&lt;li>느슨한 결합을 활용하면 유연성이 좋아진다.&lt;/li>
&lt;li>옵저버 패턴은 느슨한 결합의 좋은 예시이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>옵저버 패턴의 느슨한 결합&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>주제는 옵저버가 특정 인터페이스(Observer)를 구현한다는 사실만 알고있다.&lt;/li>
&lt;li>옵저버는 언제든지 추가할 수 있다.
&lt;ul>
&lt;li>주제는 Observer 인터페이스를 구현하는 객체의 목록에만 의존하므로 엔제든지 새로운 옵저버를 추가할 수 있다.&lt;/li>
&lt;li>실행 중에 하나의 옵저버를 다른 옵저버로 바꿔도 주제는 계속해서 다른 옵저버에게 데이터를 보낼 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>새로운 형식의 옵저버를 추가할 때도 주제를 변경할 필요가 없다.
&lt;ul>
&lt;li>새로운 옵저버 클래스를 추가할 때 변경 없이 Observer 인터페이스만 구현한다면 어떤 객체에도 연락할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>주제와 옵저버는 서로 독립적으로 재사용 할 수 있다.
&lt;ul>
&lt;li>둘이 서로 단단하게 결합되어 있지 않기 때문에 손쉽게 재사용 할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>주제나 옵저버가 달라져도 서로에게 영향을 미치지는 않는다.
&lt;ul>
&lt;li>느슨하게 결합되어 있으므로 주제나 옵저버 인터페이스를 구현한다는 조건만 만족한다면 어떻게 고쳐도 문제가 생기지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>+디자인 원칙: 상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 한다.&lt;/p>
&lt;p>느슨하게 결합하는 디자인을 사용하면 상호의존성을 최소화 할 수 있기 때문에 변경 사항이 생겨도 무난히 처리할 수 있는 유연한 객체지향 시스템을 구축할 수 있다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="풀-방식">풀 방식&lt;/h3>
&lt;p>기본적인 옵저버 패턴은 주제가 변경되었을 때 옵저버에게 알리는 방식(푸시)으로 처리되었다. 하지만 이러한 방식은 변경 반영이 필요없는 옵저버에게도 알리게 된다.&lt;/p>
&lt;p>이러한 문제가 존재한다면 옵저버가 필요할 때마다 데이터를 끌어오는 풀 방식을 통해 개선될 수 있다.&lt;/p>
&lt;p>값이 변했다는 알림을 옵저버가 받았을 때 주제에 있는 게터 메소드를 호출해서 필요한 값을 당겨오도록 변경한다.&lt;/p>
&lt;p>푸시와 풀은 구현 방법의 문제이지만 시간이 지남에 따라 애플리케이션이 계속 바뀌고 복잡해지므로, 대체로 옵저버가 필요한 데이터를 골라서 가져가도록 만드는 방법이 더 좋다.&lt;/p>
&lt;p>&lt;strong>주제에서 알림 보내기&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">class&lt;/span> &lt;span class="nc">Subject&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">notifyObservers&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Observer&lt;/span> &lt;span class="n">observer&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">observers&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">observer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">update&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>옵저버에서 알림 받기&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;code>Observer&lt;/code> 인터페이스에서 &lt;code>update()&lt;/code> 메소드에 매개변수가 없도록 서명을 바꾼다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">Observer&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">update&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="2">
&lt;li>&lt;code>update()&lt;/code> 메소드의 서명을 바꾸고 &lt;code>Subject&lt;/code> 구상 주제 메소드의 게터로 날씨를 받아오도록 &lt;code>Observer&lt;/code> 구상 클래스를 수정한다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">class&lt;/span> &lt;span class="nc">ExtendObserver&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">Observer&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">update&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">item&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ExtendSubject&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getItem&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">이후&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="err">동작&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="디자인-원칙">디자인 원칙&lt;/h3>
&lt;ul>
&lt;li>달라지는 부분을 찾아내고 달라지지 않는 부분과 분리한다.
&lt;ul>
&lt;li>옵저버 패턴에서 변하는 것은 주제의 상태와 옵저버의 개수, 형식이다.&lt;/li>
&lt;li>옵저버 패턴에서는 주제를 바꾸지 않고도 주제의 상태에 의존하는 객체들을 바꿀 수 있다.&lt;/li>
&lt;li>나중에 바뀔 것을 대비해 두면 편하게 작업할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>구현보다는 인터페이스에 맞춰 프로그래밍한다.
&lt;ul>
&lt;li>주제와 옵저버에서 모두 인터페이스를 사용했다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>상속보다는 구성을 활용한다.
&lt;ul>
&lt;li>옵저버 패턴에서는 구성을 활용해서 옵저버들을 관리한다.&lt;/li>
&lt;li>주제와 옵저버 사이의 관계가 상속이 아닌 구성으로 이루어진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="기상-모니터링-애플리케이션">기상 모니터링 애플리케이션&lt;/h2>
&lt;h3 id="요구-사항-분석">요구 사항 분석&lt;/h3>
&lt;pre class="mermaid">flowchart LR
a((습도 센서))
b((온도 센서))
c((기압 센서))
d([기상 스테이션])
e((WeatherData 객체))
f[[디스플레이 장비]]
a-.->d
b-.->d
c-.->d
d&lt;-.데이터 취득.-e
e-.화면에 표시.->f
&lt;/pre>
&lt;ul>
&lt;li>WatherData 객체를 바탕으로 만들어짐
&lt;ul>
&lt;li>현재 기상 조건(온도, 습도 기압) 추적&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>WatherData 객체를 바탕으로 3개 항목을 화면에 표시함
&lt;ul>
&lt;li>현재 조건, 기상 통계, 간단한 기상 예보&lt;/li>
&lt;li>해당 항목들이 최신 측정치를 수집할 때마다 실시간으로 갱신&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다른 개발자가 직접 날씨 디스플레이를 만덜어 바로 넣을 수 있도록 확장 가능해야 함&lt;/li>
&lt;li>정보가 화면에 표시되는 횟수로 고객에가 요금 부과&lt;/li>
&lt;/ul>
&lt;h3 id="구현-목표">구현 목표&lt;/h3>
&lt;p>디스플레이를 구현하고 새로운 값이 들어올 때마다(&lt;code>measurementsChanged()&lt;/code> 호출 시) &lt;code>WeatherData&lt;/code>에서 디스플레이를 업데이트 해야한다.&lt;/p>
&lt;pre class="mermaid">classDiagram
direction RL
class WeatherData {
getTemperature()
getHumidity()
getPressure()
measurementsChanged()
}
note for WeatherData "기상 관측값 갱신시 measurementsChanged() 호출"
&lt;/pre>
&lt;ul>
&lt;li>&lt;code>WeatherData&lt;/code> 클래스에는 3가지 측정값(온도, 습도 기압)의 게터 메소드가 있다.&lt;/li>
&lt;li>새로운 기상 측정 데이터가 들어올 때마다 &lt;code>measurementsChanged()&lt;/code> 메소드가 호출됨
&lt;ul>
&lt;li>이 메소드가 어떤 식으로 호출되는지 모른다(알 필요도 없다)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가상 데이터를 사용하는 디스플레이 요소 3가지를 구현해야 한다.
&lt;ul>
&lt;li>현재 조건, 기상 통계, 기상 예보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>디스플레이를 업데이트하도록 &lt;code>measurementsChanged()&lt;/code>에 코드를 추가해야 한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>추가 목표&lt;/strong>&lt;/p>
&lt;p>기상 스테이션이 성공하면 디스플레이가 더 늘어날 수도 있고, 디스플레이를 추가할 수 있는 마켓플레이스가 만들어질지도 모른다. 따라서 확장성을 고려한다면 좋을 수 있다.&lt;/p>
&lt;h3 id="가상-스테이션용-코드-추가">가상 스테이션용 코드 추가&lt;/h3>
&lt;p>1차적으로 다음과 같이 구현될 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">WeatherData&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 인스턴스 변수 선언
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">measurementsChanged&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 최신 측정값 가져오기
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getTemperature&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">humidity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getHumidity&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">pressure&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getPressure&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 각 디스플레이 업데이트
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">currentConditionsDisplay&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">update&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">humidity&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">pressure&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statisticsDisplay&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">update&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">humidity&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">pressure&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">forecastDisplay&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">update&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">humidity&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">pressure&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 기타 메소드
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="원칙으로-추가-코드-살펴보기">원칙으로 추가 코드 살펴보기&lt;/h3>
&lt;ul>
&lt;li>구체적인 구현(Bad)
&lt;ul>
&lt;li>각 디스플레이를 업데이트 하는 로직이 구체적인 구현에 맞춰져 있으므로 프로그램을 고치지 않고는 다른 디스플레이를 추가, 제거할 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>캡슐화 부재(Bad)
&lt;ul>
&lt;li>디스플에이를 업데이트 하는 로직은 바뀔 수 있는 부분으로 캡슐화가 필요함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>공통된 인터페이스(Good)
&lt;ul>
&lt;li>&lt;code>{객체}.update&lt;/code> 메소드를 호출하는 것으로 업데이트를 하는 공통적인 인테페이스를 구성했음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="기상-스테이션-설계하기">기상 스테이션 설계하기&lt;/h3>
&lt;pre class="mermaid">classDiagram
direction LR
class Subject {
&lt;&lt; interface >>
registerObserver()
removeObserver()
notifyObservers()
}
class Observer {
&lt;&lt; interface >>
update()
}
class DisplayElement {
&lt;&lt; interface >>
display()
}
class WeatherData {
registerObserver()
removeObserver()
notifyObservers()
getTemperature()
getHumidity()
getPressure()
measurementsChanged()
}
class CurrentConditionsDisplay {
update()
display()
}
class StatisticsDisplay {
update()
display()
}
class ThirdPartyDisplay {
update()
display()
}
class ForecastDisplay {
update()
display()
}
Subject --> Observer : 옵저버
WeatherData ..> Subject
CurrentConditionsDisplay --> WeatherData : 주제
CurrentConditionsDisplay ..> Observer
StatisticsDisplay ..> DisplayElement
StatisticsDisplay ..> Observer
ThirdPartyDisplay ..> DisplayElement
ThirdPartyDisplay ..> Observer
ForecastDisplay ..> DisplayElement
ForecastDisplay ..> Observer
&lt;/pre>
&lt;ul>
&lt;li>Subject: 주제 인터페이스&lt;/li>
&lt;li>Observer: 옵저버 인터페이스, 주제에서 옵저버에게 갱신된 정보를 전달하는 방법 제공&lt;/li>
&lt;li>DisplayElement: 모든 디스플레이 요소의 구현 인터페이스&lt;/li>
&lt;li>WeatherData: Subject 인터페이스를 구현할 기상 정보&lt;/li>
&lt;li>CurrentConditionsDisplay: WatherData 객체로부터 얻은 현재 측정값을 보여줄 옵저버 이면서 디스플레이 요소&lt;/li>
&lt;li>StatisticsDisplay: 측정치의 통계치를 표시할 옵저버 이면서 디스플레이 요소&lt;/li>
&lt;li>ForecastDisplay: 측정치를 바탕으로 기상 예보를 화면에 보여줄 디스플레이 요소&lt;/li>
&lt;li>ThirdPartyDisplay: 새롭게 구현될 디스플레이 요소&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h2 id="디자인-도구상자-안에-들어가야-할-도구들">디자인 도구상자 안에 들어가야 할 도구들&lt;/h2>
&lt;ul>
&lt;li>객체지향 기초
&lt;ul>
&lt;li>추상화&lt;/li>
&lt;li>캡슐화&lt;/li>
&lt;li>다형성&lt;/li>
&lt;li>상속&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객체지향 원칙
&lt;ul>
&lt;li>바뀌는 부분은 캡슐화힌다.&lt;/li>
&lt;li>상속보다는 구성을 활용한다.&lt;/li>
&lt;li>구현보다는 인터페이스에 맞춰 프로그래밍한다.&lt;/li>
&lt;li>+ 상호작용을 하는 객체 사이에는 가능하면 느슨한 결합을 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객체지향 패턴
&lt;ul>
&lt;li>전략패턴&lt;/li>
&lt;li>+ 옵저버 패턴
&lt;ul>
&lt;li>한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="핵심-정리">핵심 정리&lt;/h2>
&lt;ul>
&lt;li>옵저버 패턴은 객체들 사이에 일대다 관계를 정의한다.&lt;/li>
&lt;li>주제는 동일한 인터페이스를 써서 옵저버에게 연락한다.&lt;/li>
&lt;li>Observer 인터페이스를 구현하기만 하면 어떤 구상 클래스의 옵저버라도 패턴에 참여할 수 있다.&lt;/li>
&lt;li>주제는 옵저버들이 Observer 인터페이스를 구현한다는 것을 제외하면 옵저버에 관해 전혀 모른다.(느슨한 결합)&lt;/li>
&lt;li>옵저버 패턴을 사용하면 주제가 데이터를 보내거나(푸시) 옵저버가 데이터를 가져올(풀) 수 있다.
&lt;ul>
&lt;li>일반적으로 풀 방식을 옳은 방식으로 간주함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>옵저버 패턴은 여러 개의 주제와 메시지 유형이 있는 복잡한 상황에서 사용하는 출판-구독 패턴과 친척이다.&lt;/li>
&lt;li>옵저버 패턴은 자주 쓰이는 패턴으로 모델-뷰-컨트롤러(MVC)를 배울 때 다시 볼 수 있을것이다.&lt;/li>
&lt;li>GUI 프레임 워크들이 옵저버 패턴을 많이 사용한다.&lt;/li>
&lt;li>RxJava, 자바빈, RMI 외 코코아, 스위프트, JS 같은 다른 언어의 프레임워크에서도 옵저버 패턴을 많이 사용한다.&lt;/li>
&lt;/ul></description></item><item><title>1. 디자인 패턴 소개와 전략 패턴</title><link>https://codemario318.github.io/post/gof/1/</link><pubDate>Wed, 20 Sep 2023 15:25:08 +0900</pubDate><guid>https://codemario318.github.io/post/gof/1/</guid><description>&lt;img src="https://codemario318.github.io/post/gof/1/cover.png" alt="Featured image of post 1. 디자인 패턴 소개와 전략 패턴" />&lt;h2 id="디자인-패턴-만나기">디자인 패턴 만나기&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>누군가가 이미 우리의 문제를 해결해 놓았다.&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>디자인 패턴은 다른 개발자가 똑같은 문제를 경험하고 해결하면서 익혔던 지혜와 교훈이 담겨있다.&lt;/p>
&lt;p>디자인 패턴은 코드가 아닌 경험을 재사용 하는 것과 같다.&lt;/p>
&lt;h3 id="디자인-원칙">디자인 원칙&lt;/h3>
&lt;p>&lt;strong>애플리케이션에서 달리지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>달라지는 부분을 찾아 나머지 코드에 영향을 주지 않도록 캡슐화 한다.&lt;/li>
&lt;li>이로 인해 코드를 변경하는 과정에서 의도치 않게 발생하는 일을 줄이며 시스템의 유연성을 향상시킬 수 있다.&lt;/li>
&lt;/ul>
&lt;p>코드에 새로운 요구 사항이 있을 때마다 바뀌는 부분이 있다면 분리해야한다.&lt;/p>
&lt;p>이 디자인 원칙은 다음과 같이 해석할수도 있다.&lt;/p>
&lt;blockquote>
&lt;p>바뀌는 부분은 따로 뽑아 캡슐화한다. 그러면 나중에 바뀌지 않는 부분에는 영향을 미치치 않고 그 부분만 고치거나 확장할 수 있다.&lt;/p>
&lt;/blockquote>
&lt;p>이 개념은 매우 간단하지만 다른 모든 디자인 패턴의 기반을 이루는 원칙이다.&lt;/p>
&lt;p>모든 패턴은 &lt;strong>시스템의 일부분을 다른 부분과 독립적으로 변화시킬 수 있는 방법&lt;/strong>을 제공한다.&lt;/p>
&lt;h3 id="패턴과-전문-용어">패턴과 전문 용어&lt;/h3>
&lt;p>패턴으로 소통하면 일상어로 구구절절 말할 때보다 훨씬 효율적인 의사소통을 할 수 있다.&lt;/p>
&lt;p>디자인 패턴은 개발자 사이에서 서로 모두 이해할 수 있는 용어를 제공한다.&lt;/p>
&lt;p>용어를 이애하고 나면 다른 개발자와 더 쉽게 대화할 수 있고, 패턴을 아직 모르는 사람들에게는 패턴을 배우고 싶은 생각이 들도록 자극을 수 있다.&lt;/p>
&lt;p>또한 자질구레한 객체 수준에서의 생각이 아닌, 패턴 수준에서 생각할 수 있기에 아키텍처를 생각하는 수준도 끌어올릴 수 있다.&lt;/p>
&lt;ul>
&lt;li>패턴으로 의사소통하면 패턴 이름과 그 패턴에 담겨있는 모든 내용, 특성, 제약조건 등을 함께 이야기 할 수 있다.
&lt;ul>
&lt;li>전략 패턴을 사용했다는 말은, 대상의 동작을 쉽게 확장하거나 변경할 수 있는 클래스들의 집합으로 캡슐화 했다는 내용을 간략하게 설명할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>패턴을 사용하면 간단한 단어로 많은 얘기를 할 수 있다.
&lt;ul>
&lt;li>뭔가를 설명할 때 패턴을 사용하면 생각하고 있는 디자인을 다른 개발자가 빠르고 정확하게 파악할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>패턴 수준에서 이야기하면 디자인에 더 오랫동안 집중할 수 있다.
&lt;ul>
&lt;li>패턴을 사용하여 객체와 클래스를 구현하는 것과 관련된 자질구레한 내용에 시간을 버릴 필요가 없어 디자인 수준에서 초점을 맞출 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>전문 용어를 사용하면 개발팀의 능력을 극대화 할 수 있다.
&lt;ul>
&lt;li>디자인 패턴 용어를 모든 팀원이 잘 알고 있다면 오해의 소지가 줄어 작업을 빠르게 진행할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>전문 용어는 신입 개발자에게 훌륭한 자극제가 될 수 있다.
&lt;ul>
&lt;li>선배가 디자인 패턴을 사용하면 디자인 패턴을 배울 동기가 부여될 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="디자인-패턴-사용법">디자인 패턴 사용법&lt;/h3>
&lt;p>라이브러리와 프레임워크는 개발 모델 전반에 걸쳐서 많은 영향을 미친다. 하지만 라이브러리와 프레임워크를 사용한다는 것이 이해하기 쉽고, 관리하기 쉬운 유연한 방법으로 애플리케이션의 구조를 만드는 데 도움을 주지는 못한다.&lt;/p>
&lt;blockquote>
&lt;p>디자인 패턴은 라이브러리보다 더 높은 단계에 속한다.&lt;br>
디자인 패턴은 클래스와 객체를 구성해서 어떤 문제를 해결하는 방법을 제공하는데, 그런 디자인을 특정 애플리케이션에 맞게 적용하는 일은 개발자의 몫이다.&lt;/p>
&lt;/blockquote>
&lt;p>디자인 패턴은 라이브러리나 프레임워크가 도와주지 못하는 부분을 해결하는데 도움을 줄 수 있다.&lt;/p>
&lt;ul>
&lt;li>패턴을 완전히 익혀 두면 어떤 코드가 유연성 없이 엉망으로 꼬여있는 스파게티 코드라는 사실을 금방 깨닳을 수 있다.&lt;/li>
&lt;li>코드를 수정할 때 패턴을 적용하여 코드를 개선할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="객체지향-디자인-원칙과-디자인-패턴">객체지향 디자인 원칙과 디자인 패턴&lt;/h3>
&lt;p>캡슐화, 추상화, 상속, 다형성을 잘 알고 있고 활용할 수 있다고 하더라도 유연하고, 재사용이 용이하고, 관리하기 쉬운 시스템을 쉽게 만들기는 어려운 일이다.&lt;/p>
&lt;p>디자인 패턴은 간단하지만은 않은 객체지향 시스템 구축 방법들을 모아서 정의한 말그대로 패턴이다.&lt;/p>
&lt;p>따라서 디자인 패턴을 잘 알고 있다면, 비교적 적은 수고로 제대로 작동하는 디자인을 만들 수 있게된다.&lt;/p>
&lt;blockquote>
&lt;p>디자인은 예술이다.&lt;br>
장점이 있으면 단점도 있지만, 많은 사람이 오랜 시간 동안 고민해서 찾아낸 디자인 패턴을 잘 따른다면 훨씬 좋은 디자인을 만들 수 있다.&lt;/p>
&lt;/blockquote>
&lt;p>또한 패턴의 밑바탕에는 객체지향 패턴이 있으므로 원칙을 알고 있다면 문제에 딱 맞는 패턴을 찾을 수 없을 때에 적절한 디자인을 만드는데 도움을 줄 수 있다.&lt;/p>
&lt;h3 id="디자인-도구상자-안에-들어가야-할-도구들">디자인 도구상자 안에 들어가야 할 도구들&lt;/h3>
&lt;ol>
&lt;li>객체지향 기초
&lt;ul>
&lt;li>추상화&lt;/li>
&lt;li>캡슐화&lt;/li>
&lt;li>다형성&lt;/li>
&lt;li>상속&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객체지향 원칙
&lt;ul>
&lt;li>바뀌는 부분은 캡슐화 한다.&lt;/li>
&lt;li>상속보다는 구성을 활용한다.&lt;/li>
&lt;li>구현보다는 인터페이스에 맞춰서 프로그래밍한다. 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객체지향 패턴
&lt;ul>
&lt;li>전략패턴 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="시나리오">시나리오&lt;/h2>
&lt;p>시스템을 처음 디자인 할때 표준 객체지향 기법을 사용하여 슈퍼클래스를 만든 다음, 그 클래스를 확장하여 서로 다른 종류의 클래스를 만들었다.&lt;/p>
&lt;p>이후 새로운 기능을 요구하는 상황이 발생하여 슈퍼클래스에 해당 기능을 수행하는 메소드를 추가하였으나, 슈퍼클래스를 상속받는 모든 클래스들이 메소드가 적용됨에 따라 해당 기능이 필요없는 모든 클래스에서 해당 기능이 적용되 결국 오류를 만들게 되었다.&lt;/p>
&lt;p>이에 따라 해당 기능이 필요없는 서브 클래스의 추가된 슈퍼클래스의 메소드를 오버라이드하여 사용할 수 없게 막았다.&lt;/p>
&lt;p>하지만 이런 상황으로 인해 서브클래스에서 중복이 많이 발생할 수 있었고, 지속적으로 새로운 기능을 추가하기로 함에 따라 특정한 기능을 묶어 인터페이스를 설계하였다.&lt;/p>
&lt;h3 id="문제">문제&lt;/h3>
&lt;p>서브클래스에 새로운 기능을 추가할 때 모든 서브클래스에 필요한 기능이 아니므로 상속으로 처리하는 것은 올바른 방법이 아니다.&lt;/p>
&lt;ul>
&lt;li>서브클래스에서 인터페이스를 구현하여 일부 문제점은 해결할 수 있지만, 코드를 재사용하지 않으므로 코드 관리에 커다란 문제가 생긴다.&lt;/li>
&lt;li>서브클래스에 필요한 모든 기능들에 대해서 인터페이스를 만드는 방식도 서브클래스마다 구현이 필요하므로 좋은 해결방법이 아니다.&lt;/li>
&lt;/ul>
&lt;p>이러한 문제는 디자인 패턴의 적용으로 해결할 수 있다.&lt;/p>
&lt;h3 id="문제를-명확하게-파악하기">문제를 명확하게 파악하기&lt;/h3>
&lt;p>위 시나리오에서 새로운 기능 추가를 위해 상속을 활용하는 것은 모든 서브클래스에서 한 가지 기능만 사용하도록 하는 방법이기 때문에 최선의 해결책이 아니다.&lt;/p>
&lt;p>또한 인테페이스를 사용하는 방법은 괜찮아 보이지만, 인터페이스에는 구현된 코드가 없으므로 코드를 재사용할 수 없다는 문제점이 있다.&lt;/p>
&lt;ul>
&lt;li>한가지 행동을 바꿀때마다 그 행동이 정의되어 있는 서로 다른 서브 클래스를 전부 찾아서 코드를 일일이 고쳐야한다.&lt;/li>
&lt;li>그 과정으로 인해 새로운 버그가 생길 가능성이 높다.&lt;/li>
&lt;/ul>
&lt;h3 id="바뀌는-부분과-그렇지-않은-부분-분리하기">바뀌는 부분과 그렇지 않은 부분 분리하기&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>변화하는 부분과 그대로 있는 부분&lt;/strong>을 분리하려면 2개의 클래스 집합을 만든다.&lt;/li>
&lt;li>각 클래스의 집합에는 각각의 행동을 구현한 것을 전부 집어넣는다.&lt;/li>
&lt;/ol>
&lt;p>변화하는 기능을 슈퍼클래스에서 모두 분리하여 각 행동을 나타낼 클래스 집합을 새로 만들어야 한다.&lt;/p>
&lt;pre class="mermaid">flowchart LR
a((슈퍼클래스))-->b
a-->c
subgraph 달라지는 기능
b([메소드 구현 1])
c([메소드 구현 2])
end
&lt;/pre>
&lt;h3 id="달라지는-기능을-디자인하는-방법">달라지는 기능을 디자인하는 방법&lt;/h3>
&lt;p>달라지는 기능을 구현하는 클래스 집합은 최대한 유연하게 만들고, 인스턴스에 기능을 할당할 수 있어야 한다. 이를 위해 각 행동은 인터페이스로 표현하고 인테페이스를 사용해 행동을 구현한다.&lt;/p>
&lt;ul>
&lt;li>시나리오에서는 슈퍼클래스에서 구체적으로 구현하거나 서브클래스 자체에서 별도로 구현하는 방법에서 항상 특정 구현에 의존한다.&lt;/li>
&lt;li>서브클래스는 인터페이스로 표현되는 행동을 사용하기 때문에 실제 행동 구현이 슈퍼클래스를 활용하는 서브클래스에게만 국한되지 않는다.
&lt;ul>
&lt;li>인터페이스로 인해 서브클래스마다 해당 기능을 구현해야하는 문제점이 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>실제 실행 시에 쓰이는 객체가 코드에 고정되지 않도록 상속이 아닌 상위 형식(super type)에 맞춰 프로그래밍해서 다형성을 활용해야 한다는 점에서 인터페이스에 맞춰서 프로그래밍한다는 말은 사실 상위 형식에 맞춰 프로그래밍한다는 의미이다.&lt;/p>
&lt;ul>
&lt;li>변수를 선언할 때 보통 추상 클래스나 인테페이스 같은 상위 형식으로 선언해야 한다.&lt;/li>
&lt;li>객체를 변수에 대입할 때 상위 형식을 구체적으로 구현한 형식이라면 어떤 객체든 넣을 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="행동-통합하기">행동 통합하기&lt;/h3>
&lt;p>특정 행동을 슈퍼클래스 또는 서브클래스에서 정의한 메소드를 써서 구현하지 않고 다른 클래스에 위임한다.&lt;/p>
&lt;pre class="mermaid">classDiagram
class Duck {
+ FlyBehavior flyBehavior
+ QuackBehavior quackBehavior
+ performQuack()
- quack()
swim()
display()
+ performFly()
- performFly()
}
&lt;/pre>
&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Duck&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">QuackBehavior&lt;/span> &lt;span class="n">quackBehavior&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">performQuack&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">quackBehavior&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">quack&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>특정 행동을 해고 싶을땐 인테페이스에 의해 참조되는 객체에서 동작하는 방식으로 위임할 수 있다.&lt;/p>
&lt;h3 id="동적으로-행동-지정하기">동적으로 행동 지정하기&lt;/h3>
&lt;p>Setter를 이용하여 위임한 다른 클래스를 설정한다면 동적으로 변경될 수 있다.&lt;/p>
&lt;h2 id="전략-패턴">전략 패턴&lt;/h2>
&lt;p>알고리즘군을 정의하고 캡슐화하여 각각의 알고리즘군을 수정해서 쓸 수 있게 해준다. 전략패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다.&lt;/p>
&lt;ul>
&lt;li>여러 알고리즘 또는 동작을 동적으로 선택하고 사용해야 할 때&lt;/li>
&lt;li>클래스의 행동을 변경하고 확장하기 쉬운 구조를 갖추고자 할 때&lt;/li>
&lt;li>코드 중복을 방지하고 재사용성을 높힐때&lt;/li>
&lt;/ul>
&lt;h3 id="구조">구조&lt;/h3>
&lt;ol>
&lt;li>전략(Strategy): 다양한 알고리즘 또는 동작을 나타내는 인터페이스 또는 추상 클래스
&lt;ul>
&lt;li>이 인터페이스를 구현하는 여러 전략 클래스가 존재함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>전략 컨텍스트(Strategy Context): 전략 객체를 사용하는 클래스로, 전략을 변경하고 실행하는 역할을 수행
&lt;ul>
&lt;li>컨텍스트 객체는 전략 객체를 가지며 필요에 따라 전략을 바꿀 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>전략 구체 클래스(Concrete Strategy): 전략 인터페이스를 구현한 구체 클래스들
&lt;ul>
&lt;li>각 클래스는 특정한 알고리즘이나 동작을 구현&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="캡슐화된-행동-살펴보기">캡슐화된 행동 살펴보기&lt;/h3>
&lt;pre class="mermaid">classDiagram
class Duck {
FlyBehavior flyBehavior
QuackBehavior quackBehavior
swim()
display()
performQuack()
performFly()
setFlyBehavior()
setQuackBehavior()
}
class MallardDuck {
display()
}
class RedheadDuck {
display()
}
class RubberDuck {
display()
}
class DecoyDuck {
display()
}
Duck &lt;|-- MallardDuck
Duck &lt;|-- RedheadDuck
Duck &lt;|-- RubberDuck
Duck &lt;|-- DecoyDuck
class ImpFlyBehavior {
fly()
}
class FlyWithWings {
fly() // 나는 행동 구현
}
class FlyNoWay {
fly() // 아무것도 하지 않음
}
ImpFlyBehavior&lt;|--Duck
ImpFlyBehavior&lt;|--FlyWithWings
ImpFlyBehavior&lt;|--FlyNoWay
class ImpQuackBehavior {
quack()
}
class Quack {
quack() // 소리 내는 행동 구현
}
class Squeak {
quack() // 고무 오리 소리 구현
}
class MuteQuack {
quack() // 아무 소리 내지 못함
}
ImpQuackBehavior&lt;|--Duck
ImpQuackBehavior&lt;|--Quack
ImpQuackBehavior&lt;|--Squeak
ImpQuackBehavior&lt;|--MuteQuack
&lt;/pre>
&lt;p>행동들을 알고리즘군(family of algorithms)으로 생각하고 위처럼 행동을 상속받는 대신 올바른 행동 객체로 구성되는 행동을 부여받기 위해 두 클래스를 합치는 것을 &lt;strong>구성을 이용한다&lt;/strong>라고 표현한다.&lt;/p>
&lt;h2 id="정리">정리&lt;/h2>
&lt;ul>
&lt;li>객체지향 기초 지식만 가지고는 휼륭한 객체지향 디자이너가 될 수 없다.&lt;/li>
&lt;li>휼륭한 객체지향 디자인이라면 재사용성, 확장성, 관리의 용이성을 갖출 줄 알아야 한다.&lt;/li>
&lt;li>패턴은 훌륭한 객체지향 디자인 품질을 갖추고 있는 시스템을 만드는 방법을 제공한다.&lt;/li>
&lt;li>패턴은 검증받은 객체지향 경험의 산물이다.&lt;/li>
&lt;li>패턴이 코드를 바로 제공하는 것은 아니나, 디자인 문제의 보편적인 해법을 제공한다.&lt;/li>
&lt;li>패턴은 발명되는 것이 아니라 발견되는 것이다.&lt;/li>
&lt;li>대부분의 패턴과 원칙은 소프트웨어의 변경 문제와 연관되어 있다.&lt;/li>
&lt;li>대부분 패턴은 시스템의 일부분을 나머지 부분과 무관하게 변경하는 방법을 제공한다.&lt;/li>
&lt;li>많은 경우에 시스템에서 바뀌는 부분을 골라내서 캡슐화해야 한다.&lt;/li>
&lt;li>패턴은 다른 개발자와의 의사소통을 극대화하는 전문 용어 역할을 한다.&lt;/li>
&lt;/ul></description></item></channel></rss>