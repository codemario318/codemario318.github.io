<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Common on Mario Blog</title><link>https://codemario318.github.io/categories/common/</link><description>Recent content in Common on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Sat, 18 Jan 2025 15:24:49 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/categories/common/index.xml" rel="self" type="application/rss+xml"/><item><title>2. 데이터 모델과 질의 언어 - 관계형 모델과 문서 모델</title><link>https://codemario318.github.io/post/designing-data-intensive-application/2/1/</link><pubDate>Sat, 18 Jan 2025 15:24:49 +0900</pubDate><guid>https://codemario318.github.io/post/designing-data-intensive-application/2/1/</guid><description>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/1/cover.png" alt="Featured image of post 2. 데이터 모델과 질의 언어 - 관계형 모델과 문서 모델" />&lt;p>&lt;strong>데이터 모델&lt;/strong>은 소프트웨어가 어떠헥 작성됐는지 뿐만 아니라 해결하려는 &lt;strong>문제를 어떻게 생각해야 하는지&lt;/strong>에 대해 지대한 영향을 미친다.&lt;/p>
&lt;p>대부분 애플리케이션은 하나의 데이터 모델을 다른 데이터 모델 위에 계층을 둬서 만든다.&lt;/p>
&lt;p>각 계층의 핵심적인 문제는 다음 하위 계층 관점에서 데이터 모델을 &lt;strong>표현&lt;/strong>하는 방법이다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션 개발자는 현실(사람, 조직, 상품, 행동, 자금 흐름, 센서)을 보고 객체나 데이터 구조, 그리고 이러한 데이터 구조를 다루는 API를 모델링한다.
&lt;ul>
&lt;li>이러한 구조는 보통 애플리케이션에 특화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 구조를 저장할 때는 JSON이나 XML 문서, 관계형 데이터베이스 테이블이나 그래프 모델 같은 범용 데이터 모델로 표현한다.&lt;/li>
&lt;li>데이터베이스 소프트웨어를 개발하는 엔지니어는 JSON/XML/관계형/그래프 데이터를 메모리나 디스크 또는 네트워크 상의 바이트 단위로 표현하는 방법을 결정한다.
&lt;ul>
&lt;li>이 표현은 다양한 방법으로 데이터를 질의, 탐색, 조작 처리할 수 있게 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>더 낮은 수준에서 하드웨어 엔지니어는 전류, 빛의 파동, 자기장 등의 관점에서 바이트를 표현하는 방법을 알아냈다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>복잡한 애플리케이션에서는 여러 API를 기반으로 만든 API처럼 중간 단계를 더 둘 수 있지만 기본 개념은 여전히 동일하다.&lt;/p>
&lt;/blockquote>
&lt;p>각 계층은 명확한 데이터 모델을 제공해 하위 계층의 복잡성을 숨겨(추상화), 다른 그룹의 사람들이 효율적으로 함께 일할 수 있게끔 한다.&lt;/p>
&lt;hr>
&lt;p>다양한 유형의 데이터 모델이 존재하며, 각 데이터 모델은 사용 방법에 대한 가정을 나타낸다.&lt;/p>
&lt;ul>
&lt;li>어떤 종류의 데이터모델의 사용법은 쉬우나 어떤 동작은 지원하지 않는다.&lt;/li>
&lt;li>데이터 모델의 종류에 따라 어떤 연산은 빠르지만 다른 연산은 매우 느리게 작동한다.&lt;/li>
&lt;li>어떤 데이터 변환은 자연스럽지만 달느 어떤 데이터 변환은 부자연스럽다.&lt;/li>
&lt;/ul>
&lt;p>하나의 데이터 모델만을 완전히 익히는 데도 많은 노력이 필요하며(관계형 데이터 모델링 관련된 학습 분량만해도 방대하다), 데이터 모델을 하나만 사용하면서도 내부 동작에 대한 걱정이 없더라도 소프트웨어 작성은 그 자체로 충분히 어렵다.&lt;/p>
&lt;p>그러나 데이터 모델은 그 위에서 &lt;strong>소프트웨어가 할 수 있는 일과 할 수 없는 일에 지대한 영향&lt;/strong>을 주므로 애플리케이션에 적합한 데이터 모델을 선택하는 작업은 상당히 중요하다.&lt;/p>
&lt;h2 id="관계형-모델과-문서-모델">관계형 모델과 문서 모델&lt;/h2>
&lt;p>오늘날 가장 잘 알려진 모델은 1970년 에드가 코드(Edgar Codd)가 제안한 관계형 모델을 기반으로 한 SQL이다.&lt;/p>
&lt;ul>
&lt;li>데이터는 &lt;strong>관계&lt;/strong>로 구성되고 각 관계는 순서 없는 &lt;strong>튜플&lt;/strong> 모음이다.&lt;/li>
&lt;/ul>
&lt;p>관계형 데이터베이스의 근원은 1960년대와 1970년대에 메인프레임 컴퓨터에서 수행된 &lt;strong>비즈니스 데이터 처리&lt;/strong>에 있다.&lt;/p>
&lt;ul>
&lt;li>트랜잭션 처리, 일괄 처리 등&lt;/li>
&lt;/ul>
&lt;p>당시 다른 데이터베이스를 사용하는 개발자는 데이터베이스 내부 데이터 표현에 대해 고민해야 했지만, 관계형 모델로 인해 정리된 인터페이스 뒤로 구현 세부 사항을 숨길 수 있게 되었다.&lt;/p>
&lt;p>이후 컴퓨터가 훨씬 더 강력해지고 네트워크화됨에 따라 다양한 목적으로 활용되기 시작하였고, 관계형 데이터베이스는 비즈니스 데이터 처리 뿐만이 아닌 폭넓은 다양한 사용 사례에도 보편화 되는 것으로 나타났다.&lt;/p>
&lt;p>오늘날 대부분의 서비스는 여전히 관계형 데이터베이스를 통해 제공된다.&lt;/p>
&lt;h2 id="nosql의-탄생">NoSQL의 탄생&lt;/h2>
&lt;p>2010년대에 들어서며 NoSQL이 빠르게 확산되었는데 다양한 이유가 있다.&lt;/p>
&lt;ul>
&lt;li>대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성의 필요&lt;/li>
&lt;li>상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산&lt;/li>
&lt;li>관계형 모델에서 지원하지 않는 특수 질의 동작&lt;/li>
&lt;li>관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람&lt;/li>
&lt;/ul>
&lt;p>애플리케이션은 저마다 요구사항이 다르기 때문에, 사용 사례에 맞는 최적의 기술 선택은 동시에 요구되는 사용 사례에 맞는 최적의 선택과는 다를 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>이 때문에 관계형 데이터베이스가 폭넓은 다양함을 가진 비관계형 데이터스토어와 함께 사용될 것이다.(😲)&lt;/p>
&lt;/blockquote>
&lt;p>이런 개념을 종종 &lt;strong>다중 저장소 지속성&lt;/strong>(polyglot persistence)이라고 부른다.&lt;/p>
&lt;h2 id="객체-관계형-불일치">객체 관계형 불일치&lt;/h2>
&lt;p>오늘날의 대부분의 애플리케이션은 객체지향 프로그래밍 언어로 개발되는데, 이는 SQL 데이터 모델과 객체 모델 사이에 불일치가 발생한다.&lt;/p>
&lt;ul>
&lt;li>데이터를 관계형 테이블에 저장하려면 애플리케이션 코드와 데이터베이스 모델 객체 사이에 거추장스러운 전환 계층이 필요함&lt;/li>
&lt;li>이런 모델 사이의 분리를 임피던스 불일치(impedance mismatch)라고 부른다.&lt;/li>
&lt;/ul>
&lt;p>액티브레코드(Active Record)나 하이버네이트(Hibernate)와 같은 ORM 프레임워크는 전환 계층에 필요한 상용구 코드(boilerplate code)의 양을 줄이지만 두 모델 간의 차이를 완벽히 숨길 수 없다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image.png"
width="728"
height="654"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image_huf7279fce334eb341135beb90b76ab788_145375_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/1/image_huf7279fce334eb341135beb90b76ab788_145375_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="관계형 스키마를 사용해 링크트인 프로필을 표현"
class="gallery-image"
data-flex-grow="111"
data-flex-basis="267px"
>&lt;/p>
&lt;p>프로필 전체는 고유 식별자인 &lt;code>user_id&lt;/code>로 식별가능하고, &lt;code>first_name&lt;/code>, &lt;code>last_name&lt;/code> 같은 필드는 사용자마다 하나만 있으므로 &lt;code>users&lt;/code> 테이블 컬럼으로 모델링 가능하다.&lt;/p>
&lt;p>하지만 경력에 넣을 직업이 하나 이상이며 학력 기간과 연락처 정보도 다양하기 때문에, 사용자와 이들 사이의 관계는 일대다 관계(one-to-many)이며 이는 다양한 방법으로 표현할 수 있다.&lt;/p>
&lt;ul>
&lt;li>전통적인 SQL 모델의 일반적인 정구화 표현은 직위, 학력, 연락처 정보를 개별 테이블에 넣고 외래 키로 &lt;code>users&lt;/code> 테이블을 참조&lt;/li>
&lt;li>구조화된 데이터타입으로 저장(XML, JSON 등)
&lt;ul>
&lt;li>SQL 표준의 마지막 버번에서 구조화된 데이터타입에 대한 지원이 추가됨에 따라, 한 로우에 다중 값을 저장하고 질의와 색인이 가능해짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>직업, 학력, 연략처 정보를 JSON이나 XML 문서로 부호화해 데이터베이스의 텍스트 컬럼에 저장 후, 애플리케이션이 구조와 내용을 해석
&lt;ul>
&lt;li>일반적으로 부호화된 컬럼의 값을 질의하는 데 데이터베이스를 사용할 수 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이력서와 같은 데이터 구조는 모든 내용을 갖추고 있는 &lt;strong>문서&lt;/strong>라서 JSON 표현에 매우 적합하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">251&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;first_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Bill&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;last_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Gates&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;summary&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Co-chair of the Bill &amp;amp; Melinda Gates... Active blogger.&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;region_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;us:91&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;industry_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">131&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;photo_url&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;/p/7/000/253/05b/308dd6e.jpg&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;positions&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;job_title&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Co-chair&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;organization&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Bill &amp;amp; Melinda Gates Foundation&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;job_title&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Co-founder, Chairman&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;organization&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Microsoft&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;education&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;school_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Harvard University&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;start&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1973&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;end&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1975&lt;/span>&lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;school_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Lakeside School, Seattle&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;start&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;end&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;contact_info&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;blog&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;http://thegatesnotes.com&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;twitter&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;http://twitter.com/BillGates&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>일부 개발자는 JSON 모델이 애플리케이션 코드와 저장 계층 간 임피던스 불일치를 줄인다고 생각한다.&lt;/p>
&lt;ul>
&lt;li>물론 데이터 부화화 형식으로서 JSON의 문제도 있음(4장)&lt;/li>
&lt;/ul>
&lt;p>JSON 표현은 다중 테이블 스키마보다 더 나은 &lt;strong>지역성&lt;/strong>(locality)을 갖는다.&lt;/p>
&lt;ul>
&lt;li>관계형 예제에서 프로필을 가져오려면 다중 질의를 수행하거나 &lt;code>users&lt;/code> 테이블과 그 하위 테이블 간에 난잡한 다중 조인이 필요함&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-1.png"
width="726"
height="330"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-1_huf01bd4b866b0b0735bdca555b8616a7f_45548_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-1_huf01bd4b866b0b0735bdca555b8616a7f_45548_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="트리 구조를 형성하는 일대다 관계"
class="gallery-image"
data-flex-grow="220"
data-flex-basis="528px"
>&lt;/p>
&lt;p>사용자 프로필에서 사용자에서 직위, 학력 기록, 연락처 정보로 대응되는 일대다 관계는 의미상 데이터 트리 구조와 같다.&lt;/p>
&lt;ul>
&lt;li>이러한 트리 구조는 JSON 표현에서 명시적으로 드러나게된다.&lt;/li>
&lt;/ul>
&lt;h2 id="다대일과-다대다-관계">다대일과 다대다 관계&lt;/h2>
&lt;p>이력서 예시에서 &lt;code>region_id&lt;/code>와 &lt;code>industry_id&lt;/code>는 평문이 아닌 외래 키인데, 지리적 지역과 업계 표준 목록으로 드롭다운 리스트나 자동 완성 기능을 만들어 사용자가 선택하게 하는 데는 다음과 같은 장점이 있다.&lt;/p>
&lt;ul>
&lt;li>프로필 간 일관된 스타일 철자&lt;/li>
&lt;li>모호함 회피(이름이 같은 여러 도시 등)&lt;/li>
&lt;li>갱신의 편의성
&lt;ul>
&lt;li>이름이 한 곳에만 저장되므로 이름을 변경해야 하는 경우 전반적인 갱신이 쉬움&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>현지화 지원
&lt;ul>
&lt;li>글로벌 서비스의 경우 표준 목록을 현지화하는데 용이함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>더 나은 검색
&lt;ul>
&lt;li>검색할 특정 항목이 특정 지역 목록에 포함된다는 것을 부호화하여 더 정확한 검색 결과를 얻을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>ID나 텍스트 문자열의 저장 여부는 중복의 문제로 텍스트로 저장하게되면 같은 의미의 데이터가 중복된다.&lt;/p>
&lt;blockquote>
&lt;p>비정규화는 데이터 중복을 일부로 발생시키는 방법인데 이후 다룸&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>중복된 데이터를 정규화하려면 &lt;strong>다대일&lt;/strong> 관계가 필요한데 이는 문서 모델에 적합하지 않다.&lt;/p>
&lt;p>관계형 데이터베이스에서는 조인이 쉬어 ID로 다른 테이블의 로우를 참조하는 방식이 일반적이지만, 문서 데이터베이스에서는 일대다 트리 구조를 위해 조인이 필요하지 않지만 조인에 댛나 지원이 보통 약하다.&lt;/p>
&lt;p>데이터베이스가 조인을 지원하지 않으면 데이터베이스에 대한 다중 질의를 만들어 애플리케이션 코드에서 조인을 흉내 내야 한다.&lt;/p>
&lt;p>더욱이 애플리케이션의 초기 버전이 조인 없는 문서 모델에 적합하더라도 애플리케이션에 기능을 추가하면서 데이터는 점차 상호 연결되는 경향이 있다.&lt;/p>
&lt;ul>
&lt;li>예시에서는 직장, 학교, 추천서 등&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-2.png"
width="726"
height="500"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-2_hu1901cea60f5abd3dcdc7332c37186851_87478_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-2_hu1901cea60f5abd3dcdc7332c37186851_87478_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="다대다 관계로 이력서 확장"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="348px"
>&lt;/p>
&lt;h2 id="문서-데이터베이스는-역사를-반복하고-있나">문서 데이터베이스는 역사를 반복하고 있나?&lt;/h2>
&lt;p>문서 데이터베이스와 NoSQL은 데이터베이스에서 다대다 관계를 표현하는 제일 좋은 방법에 대한 논쟁을 다시 열었다.&lt;/p>
&lt;p>1970년대 많이 사용된 데이터베이스로 IBM의 정보 관리 시스템(Information Management System, IMS)은 &lt;strong>계층 모델&lt;/strong>이라 부르는 간단한 데이터 모델을 사용했는데, JSON 모델과 매우 유사하다.&lt;/p>
&lt;p>이때 관계형 모델에 대한 한계를 극복하기 위해 대표적으로 &lt;strong>관계형 모델&lt;/strong>(SQL로 세상을 지배중)과 &lt;strong>네트워크 모델&lt;/strong>이 제안되었는데, 해결하려는 문제가 지금 풀려는 문제와 매우 유사하다.&lt;/p>
&lt;h3 id="네트워크-모델">네트워크 모델&lt;/h3>
&lt;p>네트워크 모델은 코다실(Conference for Data Systems Languages, CODASYL)이 제안한 모델로 &lt;strong>코다실 모델&lt;/strong>이라고도 부른다.&lt;/p>
&lt;p>코다실 모델은 계층 모델을 일반화한다.&lt;/p>
&lt;ul>
&lt;li>계층 모델의 트리 구조에서 모든 레코드는 정확하게 하나의 부모가 있지만, 네트워크 모델에서는 레코드는 다중 부모가 있을 수 있다.&lt;/li>
&lt;li>네트워크 모델에서 레코드 간 연결은 왜래 키 보다는 프로그래밍 언어의 포인터와 더 비슷하다.&lt;/li>
&lt;/ul>
&lt;p>레코드에 접근하는 유일한 방법은 최상위 레코드(root record)에서 시작하는 경로를 따라가는 것이다.(&amp;ldquo;접근 경로&amp;quot;라고 함)&lt;/p>
&lt;ul>
&lt;li>다대다 관계는 다양한 다른 경로가 같은 레코드로 이어질 수 있으므로, 네트워크 모델을 사용하는 프로그래머는 경로의 맨 앞에서 이런 다양한 접근 경로를 계속 추적해야 한다.&lt;/li>
&lt;/ul>
&lt;p>코다실에서 질의는 레코드 목록을 반복해 접근 경로를 따라 데이터베이스의 끝에서 끝까지 커서를 움직여 수행되며, 레코드가 다중 부모를 가진다면 애플리케이션 코드는 다양한 관계를 모두 추적해야한다.&lt;/p>
&lt;ul>
&lt;li>수동 접근 경로 선택은 매우 제한된 하드웨어 성능을 가장 효율적으로 사용할 수 있었지만 데이터베이스 질의와 갱신을 위한 코드가 복잡하고 유연하지 못했다.&lt;/li>
&lt;/ul>
&lt;p>계층 모델과 네트워크 모델 모두, 원하는 데이터에 대한 결오가 없다면 어려운 상황에 놓인다.&lt;/p>
&lt;ul>
&lt;li>접근 경로를 변경할 수 있지만 아주 많은 수작업 데이터베이스 질의 코드를 살펴야한다.&lt;/li>
&lt;li>새로운 접근 경로를 다루기 위해 재작성 해야한다.&lt;/li>
&lt;/ul>
&lt;p>애플리케이션의 데이터 모델을 바꾸는 작업은 매우 어려운 일이었다.&lt;/p>
&lt;h3 id="관계형-모델">관계형 모델&lt;/h3>
&lt;p>관계형 모델이 하는 일은 알려진 모든 데이터를 배치하는 것이다.&lt;/p>
&lt;ul>
&lt;li>관계(테이블)는 단순히 튜플(로우)의 컬렉션이 전부이다.&lt;/li>
&lt;li>복잡한 중첩 구조와 데이터를 보고 싶을 때 따라가야 할 복잡한 접근 경로가 없다.&lt;/li>
&lt;/ul>
&lt;p>임의 조건과 일치하는 테이블의 일부 또는 모든 로우를 선택해서 읽을 수 있고 일부 칼럼을 키로 지정해 칼럼과 일치하는 특정 로우를 읽을 수 있다.&lt;/p>
&lt;p>다른 테이블과의 외래 키 관계에 대해 신경 쓰지 않고 임의 테이블에 새 로우를 삽입할 수 있다.&lt;/p>
&lt;p>관계형 데이터베이스에서 질의 최적화기(query optimizer)는 네트워크 모델의 접근 경로와 같은 실행 계획을 선택한다.&lt;/p>
&lt;p>따라서 애플리케이션 개발자가 접근 경로를 따로 생각할 필요는 없으며, 새로운 방식으로 데이터에 질의하고 싶다면 새로운 색인을 선언하면 잘의는 자동으로 가장 적합한 색인을 사용하게 된다.&lt;/p>
&lt;ul>
&lt;li>관계형 모델은 애플리케이션에 새로운 기능을 추가하는 작업이 훨씬 쉽다.&lt;/li>
&lt;/ul>
&lt;h3 id="문서-데이터베이스와의-비교">문서 데이터베이스와의 비교&lt;/h3>
&lt;p>문서 데이터베이스는 별도 테이블이 아닌 상위 레코드 내에 중첩된 레코드를 저장한다.&lt;/p>
&lt;p>하지만 다대일과 다대다 관계를 표현할 때 관계형 데이터베이스와 문서 데이터베이스는 근본적으로 다르지 않다.&lt;/p>
&lt;ul>
&lt;li>둘 다 관련 항목은 고유한 식별자로 참조&lt;/li>
&lt;li>관계형 모델에서는 &lt;strong>외래 키&lt;/strong>, 문서 모델에서는 &lt;strong>문서 참조&lt;/strong>(document reference)&lt;/li>
&lt;/ul>
&lt;p>이 식별자는 조인이나 후속 질의를 사용해 읽기 시점을 확인한다.&lt;/p>
&lt;h2 id="관계형-데이터베이스와-오늘날의-문서-데이터베이스">관계형 데이터베이스와 오늘날의 문서 데이터베이스&lt;/h2>
&lt;p>관계형 데이터베이스와 문서 데이터베이스를 비교할 때 많은 부분을 고려해야하지만 데이터 모델의 차이점에만 집중한다.&lt;/p>
&lt;p>문서 데이터 모델을 선호하는 주요 이유는 &lt;strong>스키마 유연성&lt;/strong>, &lt;strong>지역성에 기인한 더 나은 성능&lt;/strong> 때문이고 일부 애플리케이션의 경우 애플리케이션에서 사용하는 데이터 구조와 더 까깝기 때문이다.&lt;/p>
&lt;p>관계형 모델은 조인, 다대일, 다대다 관계를 더 잘 지원함으로써 문서 데이터 모델에 대항한다.&lt;/p>
&lt;h3 id="어떤-데이터-모델이-애플리케이션-코드를-더-간단하게-할까">어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?&lt;/h3>
&lt;p>애플리케이션에서 데이터가 문서와 비슷한 구조라면 문서 모델을 사용하는 것이 좋다.&lt;/p>
&lt;ul>
&lt;li>문서와 비슷한 구조를 여러 테이블로 나누어 찢는(shredding) 관계형 기법은 다루기 힘든 스키마와 불필요하게 복잡한 애플리케이션 코드를 발생시킨다.&lt;/li>
&lt;/ul>
&lt;p>문서 모델은 문서 내 중첩 항목을 바로 참조할 수는 없다는 제한으로 인해 &amp;ldquo;사용자 251의 직위 목록의 두 번째 항목&amp;quot;과 같이 표현해야하지만, 문서가 너무 깊게 중첩되지 않으면 일반적으로 문제되진 않는다.&lt;/p>
&lt;p>문서 데이터베이스의 미흡한 조인 지원은 애플리케이션에 따라 문제일 수 일 수 있지만 아닐수도 있다.&lt;/p>
&lt;ul>
&lt;li>ex) 어떤 시점에 발생한 이벤트를 기록하는 문서 데이터베이스를 사용하는 분석 애플리케이션&lt;/li>
&lt;/ul>
&lt;p>하지만 애플리케이션에서 다대다 관계를 사용한다면 문서 모델은 매력이 떨어진다.&lt;/p>
&lt;ul>
&lt;li>비정규화로 조인의 필요성 줄이기가 가능하지만 애플리케이션 코드에서 비정규화된 데이터의 일관성을 유지하기 위한 추가 작업 필요&lt;/li>
&lt;li>조인은 애플리케이션 코드에서 데이터베이스에 다중 요청을 만들어 흉내낼 수 있지만 복잡도가 높고, 조인보다 느림
이러한 경우 문서 모델을 사용하는 것이 훨씬 더 복잡한 애플리케이션 코드와 나쁜 성능으로 이어질 수 있다.&lt;/li>
&lt;/ul>
&lt;p>일반적으로 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 만드는지는 데이터 항목 간에 존재하는 관계 유형에 따라 다르다.&lt;/p>
&lt;ul>
&lt;li>상호 연결이 많은 데이터의 경우
&lt;ul>
&lt;li>문서 모델: 곤란&lt;/li>
&lt;li>관계형 모델: 무난&lt;/li>
&lt;li>그래프 모델: 매우 자연스러움&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="문서-모델에서의-스키마-유연성">문서 모델에서의 스키마 유연성&lt;/h3>
&lt;p>대부분의 문서 데이터베이스는 스키마를 강요하지 않는데, 이는 임의의 키와 값을 문서에 추가할 수 있고 읽을 때 클라이언트는 문서에 포함된 필드의 존재 여부를 보장하지 않는다는 의미이다.&lt;/p>
&lt;p>문서 데이터베이스는 종종 &lt;strong>스키마리스&lt;/strong>(schema-less)라고 부르는데, 오해의 소지가 있다. 보통은 읽는 코드는 어떤 구조를 가정하므로, 암묵적인 스키마가 있지만 강요하지 않는다는 뜻이 더 정확하다.&lt;/p>
&lt;ul>
&lt;li>쓰기 스키마(schema-on-write)
&lt;ul>
&lt;li>관계형 데이터베이스의 전통적인 접근 방식&lt;/li>
&lt;li>스키마는 명시적이고 데이터베이스는 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>읽기 스키마(schema-on-read)
&lt;ul>
&lt;li>데이터 구조는 암묵적이고 데이터를 읽을 때만 해석&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>데이터베이스에서 스키마 강제는 논쟁의 여지가 있는 주제이며 일반적으로 옳고 그른 정답은 없다.&lt;/p>
&lt;p>접근 방식 간 차이는 애플리케이션이 데이터 타입을 변경하고자 할 때 특히 뚜렷이 나타나는데, 문서 데이터베이스에서는 새로운 필드를 가진 새로운 문서를 작성하기 시작하고 애플리케이션에서는 예전 문서를 읽은 경우를 처리하는 코드만 있으면 된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">if (user &amp;amp;&amp;amp; user.name &amp;amp;&amp;amp; !user.first_name) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // Documents written before Dec 8, 2013 don&amp;#39;t have first_name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> user.first_name = user.name.split(&amp;#34; &amp;#34;)[0];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>데이터베이스 스키마에서는 보통 마이그레이션(migration)을 수행한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ADD&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COLUMN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">text&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">UPDATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">split_part&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- PostgreSQL
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">UPDATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">substring_index&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- MySQL
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>스키마 변경은 느리고 중단시간을 요구하기 때문에 평판이 나쁘지만, 대부분의 관계형 데이터베이스 시스템에서 엄청 느리지는 않다.&lt;/p>
&lt;ul>
&lt;li>MySQL은 예외적으로 &lt;code>ALTER TABLE&lt;/code>시 전체 테이블을 복사하기 때문에 큰 테이블을 변경할 때 수 분에서 수 시간까지 중단 시간이 발생할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>큰 테이블에 &lt;code>UPDATE&lt;/code>문을 실행하면 모든 로우가 재작성될 수 있기 때문에 어떤 데이터베이스는 오래 걸릴수 있다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션은 입력될 항목이 기본값인 널로 설정되게 남겨두고 문서 데이터베이스처럼 읽는 시점에 채울 수도 있다.&lt;/li>
&lt;/ul>
&lt;p>읽기 스키마 접근 방식은 컬렉션 안의 항목이 어떤 이유로 모두 동일한 구조가 아닐 때(데이터가 여러 다른 유형으로 구성돼 있을 때) 유용하다.&lt;/p>
&lt;ul>
&lt;li>다른 여러 유형의 오브젝트가 있고 각 유형의 오브젝트별로 자체 테이블에 넣는 방법은 실용적이지 않다.&lt;/li>
&lt;li>사용자가 제어할 수 없고 언제나 변경 가능한 외부 시스템에 의해 데이터 구조가 결정된다.&lt;/li>
&lt;/ul>
&lt;p>하지만 모든 레코드가 동일한 구조라서 예상 가능하다면 스키마가 문서화와 구조를 강제하기 위한 유용한 메커니즘이다.&lt;/p>
&lt;h3 id="질의를-위한-지역성">질의를 위한 지역성&lt;/h3>
&lt;p>문서는 보통 JSON, XML로 부호화된 단일 연속 문자열이나(MongoDB의 BSON) JSON 또는 XML의 이진 변형으로 저장된다.&lt;/p>
&lt;p>애플리케이션이 자주 전체 문서에 접근해야 할 때 &lt;strong>저장소 지역성&lt;/strong>(storage locality)을 활용하면 성능 이점이 있다.&lt;/p>
&lt;ul>
&lt;li>처음 봤던 이력서 예시처럼 데이터가 다중 테이블로 나눠졌으면 전체를 검색하기 위해 다중 색인 검색이 필요하므로 더 많은 디스크 탐색이 필요하다.&lt;/li>
&lt;/ul>
&lt;p>지역성의 이점은 한 번에 해당 문서의 많은 부분을 필요로 하는 경우에만 적용된다.&lt;/p>
&lt;ul>
&lt;li>문서의 작은 부분에만 접근해도 전체 문서를 적재해야 하기에 큰 문서에서는 낭비일 수 있다.&lt;/li>
&lt;li>문서를 갱신할 때도 보통 전체 문서를 재작성 해야한다.&lt;/li>
&lt;li>부호화된 문서의 크기를 바꾸지 않는 수정은 쉽게 수행할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이런 이유로 일반적으로 문서를 아주 작게 유지하면서 문서의 크기가 증가하는 쓰기를 피하라고 권장한다.&lt;/p>
&lt;ul>
&lt;li>이 성능 제한 때문에 문서 데이터베이스가 유용한 상황이 많이 줄어든다.&lt;/li>
&lt;/ul>
&lt;p>지역성을 위해 관련 데이터를 함께 그룹화하는 개념이 문서 모델에만 국한되지는 않는다는 점이 중요하다.&lt;/p>
&lt;ul>
&lt;li>구글의 스패너(Spanner) 데이터베이스는 부모 테이블 내에 테이블의 로우를 교차 배치되게끔 선언하는 스키마를 허용하여 관계형 데이터 모델에서 지역성 특성을 동일하게 제공&lt;/li>
&lt;li>오라클은 &lt;strong>다중 테이블 색인 클러스터 테이블&lt;/strong>(multi-table index cluster table)을 사용해 관계형 데이터베이스에서 지역성을 제공&lt;/li>
&lt;li>빅테이블(Bigtable) 데이터 모델의 &lt;strong>컬럼 패밀리&lt;/strong>(column family)개념(카산드라, HBase)이 지역성 관리와 유사항 목적이 있음&lt;/li>
&lt;/ul>
&lt;h3 id="문서-데이터베이스와-관계형-데이터베이스의-통합">문서 데이터베이스와 관계형 데이터베이스의 통합&lt;/h3>
&lt;p>대부분 관계형 데이터베이스 시스템은 2000년대 중반 이후로 XML을 지원한다.&lt;/p>
&lt;ul>
&lt;li>XML 문서의 저역적 수정 및 문서 내부 색인과 질의 기능 포함&lt;/li>
&lt;/ul>
&lt;p>그래서 문서 데이터베이스를 사용할 때와 매우 비슷한 데이터 모델을 애플리케이션이 사용할 수 있다.&lt;/p>
&lt;p>PostgreSQL 9.3, MySQL 5.7, DB2 10.5 부터는 JSON 문서에 대해 비슷한 수준의 지원 기능을 제공한다.&lt;/p>
&lt;ul>
&lt;li>웹 API용 JSON의 인기를 고려할 때, 그 밖의 관계형 데이터베이스도 선례를 쫒아 JSON 지원 기능을 추가할 가능성이 높아보임&lt;/li>
&lt;/ul>
&lt;p>문서 데이터베이스 쪽에서 본다면 리싱키DB는 질의 언어에서 관계형 조인을 지원하고 MongoDB 드라이버는 자동으로 데이터베이스 참조를 확인한다.&lt;/p>
&lt;ul>
&lt;li>실제로는 클라이언트 측 조인을 수행&lt;/li>
&lt;li>네트워크 왕복이 추가로 필요하고 최적화가 덜 되기 때문에 데이터베이스에서 수행되는 조인보다 느릴 수 있음&lt;/li>
&lt;/ul>
&lt;p>관계형 데이터베이스와 문서 데이터베이스는 시간이 지남에 따라 점점 더 비슷해지고 있다.&lt;/p>
&lt;p>만약 데이터베이스가 데이터를 문서처럼 다룰 수 있고 관계형 질의를 수행할 수 있다면 애플리케이션은 필요에 따라 가장 적합한 기능을 조합해 사용하면 된다.&lt;/p>
&lt;blockquote>
&lt;p>관계형과 문서형의 혼합 모델은 미래 데이터베이스들이 가야 할 올바른 길이다.🫨&lt;/p>
&lt;/blockquote></description></item><item><title>웹소켓 시스템의 성능 개선하기</title><link>https://codemario318.github.io/post/websocket-scale-out/</link><pubDate>Sat, 04 Jan 2025 14:57:49 +0900</pubDate><guid>https://codemario318.github.io/post/websocket-scale-out/</guid><description>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/cover.png" alt="Featured image of post 웹소켓 시스템의 성능 개선하기" />&lt;p>최근 실시간 다중 사용자 퀴즈 게임을 구현하면서 단순하게 서버 1대와 인메모리(이하 세션)를 이용한 방식으로 웹소켓을 이용해 게임 진행과 채팅 기능을 구현했었는데요.&lt;/p>
&lt;p>당시 부하 테스트 결과로 초당 5,000건 이상의 메시지 처리가 가능했기 때문에, 목표로 했던 300명 이상의 참여자 동시 진행이 가능했습니다.&lt;/p>
&lt;p>하지만 게임에 참여하는 사용자가 많아지면 현재 상황에서는 분명 한계가 있겠죠? 그래서 웹소켓 서버의 처리량을 늘리는 방법들에 대해서 알아보려 합니다.&lt;/p>
&lt;h2 id="수평-확장과-수직-확장">수평 확장과 수직 확장&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img.png"
width="1024"
height="659"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_hu1795940aac2814a197193d8fc3eed447_80445_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_hu1795940aac2814a197193d8fc3eed447_80445_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="img.png"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="372px"
>&lt;/p>
&lt;p>시스템의 성능을 향상시킬 때 기본적으로 &lt;strong>수평 확장&lt;/strong>과 &lt;strong>수직 확장&lt;/strong> 두 가지 접근 방식을 고려할 수 있습니다.&lt;/p>
&lt;h3 id="수직-확장-scale-up">수직 확장 (Scale Up)&lt;/h3>
&lt;p>단일 서버의 성능을 향상시키는 방법입니다. CPU, 메모리, 디스크 등 하드웨어 리소스를 증설하여 성능을 개선합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>장점:&lt;/strong>
&lt;ul>
&lt;li>구현이 간단하며 추가적인 아키텍처 변경이 필요 없음&lt;/li>
&lt;li>단일 서버이므로 데이터 일관성 유지가 쉬움&lt;/li>
&lt;li>네트워크 복잡도가 낮음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>단점:&lt;/strong>
&lt;ul>
&lt;li>하드웨어 비용이 기하급수적으로 증가&lt;/li>
&lt;li>물리적인 한계가 존재&lt;/li>
&lt;li>장애 발생 시 전체 시스템에 영향&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="수평-확장-scale-out">수평 확장 (Scale Out)&lt;/h3>
&lt;p>동일한 서버를 여러 대 추가하여 부하를 분산시키는 방법입니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>장점:&lt;/strong>
&lt;ul>
&lt;li>선형적인 비용 증가로 효율적&lt;/li>
&lt;li>무한한 확장이 이론적으로 가능&lt;/li>
&lt;li>고가용성과 장애 허용성 확보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>단점:&lt;/strong>
&lt;ul>
&lt;li>아키텍처가 복잡해짐&lt;/li>
&lt;li>데이터 일관성 유지가 어려움&lt;/li>
&lt;li>네트워크 오버헤드 발생&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>수직 확장은 단순히 서버 스펙을 올리는 것으로 한계가 명확하기 때문에(&lt;del>비싸기 때문에&lt;/del>), 수평 확장 위주로 성능을 개선하는 것이 바람직해보입니다.&lt;/p>
&lt;p>이제 수평 확장을 위한 구체적인 방법들을 살펴보겠습니다.&lt;/p>
&lt;h2 id="웹소켓의-특성">웹소켓의 특성&lt;/h2>
&lt;p>먼저 여러 시도를 하기 전 웹소켓의 연결 특성에 대해 이해할 필요가 있습니다.&lt;/p>
&lt;p>웹소켓은 클라이언트와 서버 간에 지속 &lt;strong>연결 상태를 유지&lt;/strong>하므로, 수평 확장 시 각 서버에 &lt;strong>클라이언트 연결이 분산&lt;/strong>됩니다.&lt;/p>
&lt;p>이를 해결하기 위해 &lt;strong>서버 간 상태를 동기화&lt;/strong>하거나 상황에 맞게 클라이언트가 &lt;strong>특정 서버에 고정&lt;/strong>되도록 설정해야 합니다.&lt;/p>
&lt;h2 id="로드-밸런싱">로드 밸런싱&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_1.png"
width="1650"
height="1275"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_1_hue58ad55d5fe691e3e59586d3994effac_81538_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_1_hue58ad55d5fe691e3e59586d3994effac_81538_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="로드 밸런싱"
class="gallery-image"
data-flex-grow="129"
data-flex-basis="310px"
>&lt;/p>
&lt;p>수평 확장을 통해 서비스의 요청을 분산하기 위해 여러 대의 서버를 배포하면 실제로 배포된 여러 서버로 요청을 분산해야겠죠&lt;/p>
&lt;p>로드 밸런싱은 들어오는 네트워크 트래픽을 여러 서버에 효율적으로 분산하는 기술입니다.&lt;/p>
&lt;h3 id="sticky-sessions-vs-non-sticky-sessions">Sticky Sessions vs Non-Sticky Sessions&lt;/h3>
&lt;p>네트워크 트래픽을 분산하기 위한 여러 알고리즘이 존재하는데, 클라이언트 요청이 같은 서버로 가는지 아닌지에 따라 나눌 수 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_2.png"
width="850"
height="400"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_2_hu00407f29da576d8704b9ee37e577ead4_25051_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_2_hu00407f29da576d8704b9ee37e577ead4_25051_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Sticky Sessions vs Non-Sticky Sessions"
class="gallery-image"
data-flex-grow="212"
data-flex-basis="510px"
>&lt;/p>
&lt;p>Non-Sticky Sessions은 클라이언트의 요청이 매번 다른 서버로 자유롭게 라우팅될 수 있는 방식으로 stateless 아키텍처를 구현할 때 선호되는 방식입니다.&lt;/p>
&lt;p>주요 차이점을 비교하면:&lt;/p>
&lt;ol>
&lt;li>상태 관리
&lt;ul>
&lt;li>Sticky Sessions: 서버가 클라이언트의 상태를 메모리에 보관&lt;/li>
&lt;li>Non-Sticky Sessions: 모든 상태를 Redis 같은 외부 저장소에 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>장애 대응
&lt;ul>
&lt;li>Sticky Sessions: 서버 장애 시 해당 서버의 모든 세션 손실&lt;/li>
&lt;li>Non-Sticky Sessions: 서버 장애와 무관하게 세션 유지 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장성
&lt;ul>
&lt;li>Sticky Sessions: 특정 서버에 부하가 집중될 수 있음&lt;/li>
&lt;li>Non-Sticky Sessions: 더 균등한 부하 분산 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>웹소켓의 경우 연결 자체가 stateful하기 때문에 일반적으로 Sticky Sessions을 사용하지만, &lt;strong>대규모 시스템&lt;/strong>에서는 Non-Sticky Sessions 방식을 채택하고 모든 상태를 외부 저장소에 보관하는 방식을 사용하기도 합니다.&lt;/p>
&lt;h2 id="서버-간-상태-동기화">서버 간 상태 동기화&lt;/h2>
&lt;p>저희 서비스에서는 사용자가 퀴즈존을 기반으로 서버의 세션을 통해 관리되기 때문에, 퀴즈존에 참여하고 있는 모든 사용자가 동일한 서버에 연결되어야 합니다.&lt;/p>
&lt;p>이는 상황에 따라 사용자가 많이 참여하고 있는 퀴즈존이 특정 서버에 집중되는 경우 수평 확장의 장점을 가져갈 수 없게 되는 문제를 발생시킬 수 있습니다.&lt;/p>
&lt;p>이렇게 특정 서버에 세션에 의존하지 않게 만들기 위해 &lt;strong>서버 간의 상태를 동기화&lt;/strong> 해야할 필요가 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_3.png"
width="385"
height="131"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_3_hufe3d7b7f11325482bb16b822eb0a78ec_8599_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_3_hufe3d7b7f11325482bb16b822eb0a78ec_8599_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Redis"
class="gallery-image"
data-flex-grow="293"
data-flex-basis="705px"
>&lt;/p>
&lt;p>단순히 서버 간의 상태를 동기화 한다면, 모든 사용자에 대한 정보를 모든 서버가 메모리로 가져야하고 이를 수시로 업데이트 해야하는 문제가 있습니다.&lt;/p>
&lt;p>이는 배포된 각각의 서버의 메모리가 충분해야는 것이 기본 전제이므로 메모리로 인한 서버 비용 절감은 의미가 없어질 뿐 아니라 상태 동기화를 위한 여러 오버헤드가 발생하므로 효과적인 방식으로 보긴 어렵습니다.&lt;/p>
&lt;p>그래서 더 단순한 방법으로 배포된 여러 서버가 같은 세션을 바라보게 만드는 방법을 활용하는 경우가 많고, 세션은 빠른 읽기/쓰기가 요구되므로 주로 &lt;code>Redis&lt;/code>를 활용합니다.&lt;/p>
&lt;h2 id="pubsub-패턴-적용">Pub/Sub 패턴 적용&lt;/h2>
&lt;p>위처럼 서버 간의 상태를 동기화했다고 하더라도, 웹소켓의 특성상 특정 서버에 연결된 클라이언트에게만 직접 메시지를 전송할 수 있습니다. 다른 서버에 연결된 클라이언트에게는 직접적인 메시지 전송이 불가능한 것이죠.&lt;/p>
&lt;p>이 문제를 해결하기 위해 메시지 브로커를 활용한 Pub/Sub 패턴을 적용할 수 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_4.png"
width="2050"
height="1168"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_4_hu3cc9ed0eaf825475f37e7ff59c7a86c6_734061_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_4_hu3cc9ed0eaf825475f37e7ff59c7a86c6_734061_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Pub/Sub 패턴"
class="gallery-image"
data-flex-grow="175"
data-flex-basis="421px"
>&lt;/p>
&lt;ul>
&lt;li>각 서버는 메시지 브로커(예: Redis, RabbitMQ, Kafka)의 채널을 구독(Subscribe)&lt;/li>
&lt;li>메시지 전송이 필요할 때는 해당 채널에 메시지를 발행(Publish)&lt;/li>
&lt;li>모든 서버가 메시지를 수신하고, 자신에게 연결된 클라이언트에게 필요한 메시지를 전달&lt;/li>
&lt;/ul>
&lt;p>이러한 방식을 통해 서버 간 직접적인 통신 없이도 모든 클라이언트에게 메시지를 전달할 수 있습니다.&lt;/p>
&lt;h2 id="auto-scaling">Auto Scaling&lt;/h2>
&lt;p>리소스를 효율적으로 관리하기 위해, 트래픽에 따라 서버를 동적으로 확장하고 축소하는 것이 이상적입니다.&lt;/p>
&lt;ul>
&lt;li>저희 서비스도 근본적으로는 게임이라서 저녁 시간대에 트래픽이 집중되지 않을까 예상해봅니다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_5.png"
width="560"
height="332"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_5_hu8d0a7bc59b0e5202eca4aab1e4c19efd_27969_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_5_hu8d0a7bc59b0e5202eca4aab1e4c19efd_27969_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Auto Scaling"
class="gallery-image"
data-flex-grow="168"
data-flex-basis="404px"
>&lt;/p>
&lt;p>하지만 웹소켓 서버의 동적 확장 시에는 몇 가지 고려해야 할 문제들이 있습니다.&lt;/p>
&lt;h3 id="서버-추가">서버 추가&lt;/h3>
&lt;p>새로운 서버가 추가되었을 때, 기존 클라이언트들은 이미 다른 서버들과 연결이 되어있는 상태입니다. 이로 인해 새로운 서버는 새로 접속하는 클라이언트의 연결만 받게 되어 서버 간 부하 분산이 균형있게 이루어지지 않을 수 있습니다.&lt;/p>
&lt;p>이를 해결하기 위해서는 다음과 같은 방법들을 고려할 수 있습니다:&lt;/p>
&lt;ul>
&lt;li>연결 재분배 (Connection Rebalancing)
&lt;ul>
&lt;li>주기적으로 서버 간 연결 수를 확인하고 불균형이 발생하면 일부 클라이언트에게 재연결 요청&lt;/li>
&lt;li>클라이언트는 재연결 시 로드밸런서를 통해 새로운 서버에 고르게 분배됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가중치 기반 라우팅
&lt;ul>
&lt;li>새로운 서버에 더 높은 가중치를 부여하여 신규 연결을 더 많이 할당&lt;/li>
&lt;li>점진적으로 서버 간 연결 수가 균형을 이루도록 조정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="서버-제거">서버 제거&lt;/h3>
&lt;p>서버를 제거할 때는 해당 서버에 연결된 클라이언트들의 연결을 적절히 처리해야 합니다. 갑작스러운 연결 종료는 사용자 경험을 해칠 수 있으며, 서비스의 안정성에도 영향을 미칩니다.&lt;/p>
&lt;p>이를 위한 해결 방안으로는:&lt;/p>
&lt;ul>
&lt;li>Draining Mode 구현
&lt;ul>
&lt;li>서버 제거 전에 해당 서버를 &amp;lsquo;draining&amp;rsquo; 상태로 전환&lt;/li>
&lt;li>더 이상 새로운 연결을 받지 않도록 로드밸런서 설정 변경&lt;/li>
&lt;li>기존 연결은 유지하면서 자연스럽게 감소하도록 유도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Graceful Shutdown with Notification
&lt;ul>
&lt;li>종료 예정인 서버의 클라이언트들에게 재연결 필요성을 알리는 메시지 전송&lt;/li>
&lt;li>클라이언트는 메시지 수신 후 다른 서버로 재연결 시도&lt;/li>
&lt;li>일정 시간 후 남아있는 연결을 정상적으로 종료&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="zookeeper">ZooKeeper&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_6.png"
width="921"
height="498"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_6_hu9638b0602de60e14c3a3201684f97ad9_138457_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_6_hu9638b0602de60e14c3a3201684f97ad9_138457_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Apache ZooKeeper"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="443px"
>&lt;/p>
&lt;p>이러한 처리들의 원활한 관리를 위해 서버들의 상태를 효과적으로 관리하고 모니터링하는 것이 중요합니다. Apache ZooKeeper와 같은 도구를 활용하면 이러한 분산 환경에서의 서버 관리를 효율적으로 수행할 수 있습니다.&lt;/p>
&lt;ul>
&lt;li>서버 상태 관리
&lt;ul>
&lt;li>각 서버는 ZooKeeper에 임시 노드(ephemeral node)를 생성하여 자신의 상태를 등록&lt;/li>
&lt;li>서버 장애 시 노드가 자동으로 삭제되어 빠른 장애 감지 가능&lt;/li>
&lt;li>현재 활성화된 서버 목록을 실시간으로 파악 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>부하 분산 정보 공유
&lt;ul>
&lt;li>각 서버의 현재 연결 수, 리소스 사용량 등을 ZooKeeper에 저장&lt;/li>
&lt;li>로드밸런서는 이 정보를 바탕으로 최적의 서버 선택 가능&lt;/li>
&lt;li>동적 가중치 조정에 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>설정 정보 관리
&lt;ul>
&lt;li>서버 구성 정보, 환경 설정 등을 중앙화된 저장소에서 관리&lt;/li>
&lt;li>설정 변경 시 모든 서버에 실시간으로 반영 가능&lt;/li>
&lt;li>일관된 설정 유지 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>Auto Scaling과의 연계&lt;/strong>&lt;/p>
&lt;p>ZooKeeper를 Auto Scaling과 연계하면 더욱 효과적인 서버 관리가 가능합니다:&lt;/p>
&lt;ul>
&lt;li>스케일 인/아웃 이벤트 발생 시 서버 목록 자동 업데이트&lt;/li>
&lt;li>새로운 서버 추가 시 기존 서버들과의 설정 동기화&lt;/li>
&lt;li>서버 제거 시 안전한 종료 절차 조율&lt;/li>
&lt;li>서버 간 부하 분산 상태 모니터링 및 재조정&lt;/li>
&lt;/ul>
&lt;p>이러한 ZooKeeper의 활용은 특히 Auto Scaling 환경에서 서버들의 동적인 변화를 안정적으로 관리하는 데 큰 도움이 될 수 있고, 서버의 추가와 제거가 자주 발생하는 환경에서도 서비스의 안정성과 가용성을 높은 수준으로 유지할 수 있다는 장점도 있습니다.&lt;/p>
&lt;h2 id="정리">정리&lt;/h2>
&lt;p>웹소켓 기반의 실시간 게임 서비스를 확장하면서 발생할 수 있는 문제들과 해결 방안들을 살펴보았습니다.&lt;/p>
&lt;ul>
&lt;li>서버 확장성 문제
&lt;ul>
&lt;li>수평적 확장을 통한 처리량 증가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>상태 관리 문제
&lt;ul>
&lt;li>Redis를 활용한 세션 저장소 외부화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 전달 문제
&lt;ul>
&lt;li>Pub/Sub 패턴 도입&lt;/li>
&lt;li>메시지 브로커를 통한 효율적인 메시지 전파&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>동적 확장 문제
&lt;ul>
&lt;li>서버의 동적 추가, 제거로 인한 문제&lt;/li>
&lt;li>ZooKeeper 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>연결이 유지되는 특성 때문에 발생하는 문제들이 많았네요&lt;/p>
&lt;p>어떤 방식들을 적용해야할지 고민을 더 해봐야겠습니다.&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다😊&lt;/p></description></item><item><title>1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 어플리케이션</title><link>https://codemario318.github.io/post/designing-data-intensive-application/1/</link><pubDate>Thu, 02 Jan 2025 13:54:49 +0900</pubDate><guid>https://codemario318.github.io/post/designing-data-intensive-application/1/</guid><description>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/cover.png" alt="Featured image of post 1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 어플리케이션" />&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img.png"
width="2100"
height="2756"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_hu7c7d9bbab499c5082d7f275bac15d9e4_1376618_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_hu7c7d9bbab499c5082d7f275bac15d9e4_1376618_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 중심 어플리케이션 설계"
class="gallery-image"
data-flex-grow="76"
data-flex-basis="182px"
>&lt;/p>
&lt;p>오늘날 많은 애플리케이션은 &lt;strong>계산 중심&lt;/strong>(compute-intensive)과는 다르게 &lt;strong>데이터 중심&lt;/strong>(data-intensive)적이다.&lt;/p>
&lt;p>이러한 애플리케이션의 경우 CPU 성능보다 &lt;strong>데이터의 양&lt;/strong>, &lt;strong>데이터의 복잡도&lt;/strong>, &lt;strong>데이터의 변화 속도&lt;/strong>가 애플리케이션을 제한하는 요소이다.&lt;/p>
&lt;p>일반적으로 데이터 중심 애플리케이션은 공통으로 필요로 하는 기능을 제공하는 표준 구성 요소(standard building block)로 만든다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장(&lt;strong>데이터베이스&lt;/strong>)&lt;/li>
&lt;li>읽기 속도 향상을 위해 값비싼 수행 결과를 기억(&lt;strong>캐시&lt;/strong>)&lt;/li>
&lt;li>사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공(&lt;strong>검색 색인, search index&lt;/strong>)&lt;/li>
&lt;li>비동기 처리를 위해 다른 프로세스로 메시지 보내기(&lt;strong>스트림 처리, stream processing&lt;/strong>)&lt;/li>
&lt;li>주기적으로 대량의 누적된 데이터를 분석(&lt;strong>일괄 처리, batch processing&lt;/strong>)&lt;/li>
&lt;/ul>
&lt;p>애플리케이션마다 요구사항이 다르기 때문에 데이터베이스 시스템 도한 저마다 다양한 특성을 가지고 있다.&lt;/p>
&lt;ul>
&lt;li>캐싱을 위한 다양한 접근 방식, 검색 색인을 구축하는 여러 가지 방법 등&lt;/li>
&lt;/ul>
&lt;p>애플리케이션을 만들 때 어떤 도구와 어떤 접근 방식이 수행 중인 작업에 가장 적합한지 생각해야 한다.&lt;/p>
&lt;ul>
&lt;li>단 하나의 도구만으로 할 수 없는 것을 해야하는 경우 도구들을 결합하기 어려울 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이 책은 데이터 시스템의 원칙(principle)과 실용성(practicality), 이를 활용한 데이터 중심 애플리케이션을 개발하는 방법을 모두 담고있다.&lt;/p>
&lt;blockquote>
&lt;p>소개된 다양한 도구가 공통적으로 지닌 것은 무엇이고 서로 구별되는 것은 무엇인지, 어떠헥 그러한 특성을 구현해냈는지 알아본다.&lt;/p>
&lt;/blockquote>
&lt;p>그 전에 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 데이터 시스템을 구축하기 위한 가장 기초적인 노력을 살펴봐야한다.&lt;/p>
&lt;h2 id="데이터-시스템에-대한-생각">데이터 시스템에 대한 생각&lt;/h2>
&lt;p>일반적으로 데이터베이스, 큐, 캐시 등을 매우 다른 범주에 속하는 도구로 생각한다.&lt;/p>
&lt;p>데이터베이스와 메시지 큐는 표면적으로 비슷하더라도(얼마 동안 데이터를 저장함) 매우 다른 접근 패턴을 갖고 있어 서로 다른 성능 특성이 있기 때문에 구현 방식이 다르다.&lt;/p>
&lt;blockquote>
&lt;p>모든 것을 왜 &lt;strong>데이터 시스템&lt;/strong>이라는 포괄적 용어로 묶어야 하는가?&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>분류 간 경계가 흐려짐&lt;/strong>&lt;/p>
&lt;p>데이터 저장과 처리를 위한 여러 새로운 도구는 최근에 만들어졌고, 새로운 도구들은 다양한 사용 사례(use case)에 최적화되어 전통적인 분류에 딱 들어맞지 않는다.&lt;/p>
&lt;p>메시지 큐를 예시로 살펴보면&lt;/p>
&lt;ul>
&lt;li>레디스: 지속성을 보장하지 않음&lt;/li>
&lt;li>카프카: 데이터베이스처럼 지속성을 보장&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>광범위한 요구사항&lt;/strong>&lt;/p>
&lt;p>점점 더 많은 애플리케이션이 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없는 과도하고 광범위한 요구사항을 갖고있다.&lt;/p>
&lt;p>대신 작업(work)은 단일 도구에서 효율적으로 수행할 수 있는 태스크(task)로 나누고 다양한 도구들은 애플리케이션 코드를 이용해 서로 연결한다.&lt;/p>
&lt;ul>
&lt;li>메인 데이터베이스와 분리된 애플리케이션 관리 캐시 계층(멤캐시디, Memcached)이나 전문(full-text) 검색 서버(엘라스틱서치, 솔라)의 경우 메인 데이터베이스와 동기화된 캐시나 색인을 유지하는 것은 보통 애플리케이션 코드의 책임이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img_1.png"
width="2880"
height="2049"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_1_huf3ea3a46984851ffc8f25b1984abfd55_116627_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_1_huf3ea3a46984851ffc8f25b1984abfd55_116627_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="다양한 구성 요소를 결합한 데이터 시스템 아키텍처의 예"
class="gallery-image"
data-flex-grow="140"
data-flex-basis="337px"
>&lt;/p>
&lt;p>서비스 제공을 위해 각 도구를 결합할 때 서비스 인터페이스나 애플리케이션 프로그래밍 인터페이스(API)는 보통 클라이언트가 모르게 구현 세부사항을 숨긴다.&lt;/p>
&lt;ul>
&lt;li>기본적으로 좀 더 작은 범용 구성 요소들로 새롬고 특수한 목적의 데이터 시스템을 만든다.&lt;/li>
&lt;li>복합 데이터 시스템(composite data system)은 외부 클라이언트가 일관된 결과를 볼 수 있게끔 쓰기에서 캐시를 올바르게 무효화하거나 엡데이트 하는 등의 특정 보장 기능을 제공할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>여러 데이터 시스템을 설계, 통합하고 관리해야하는 요즘 개발자는 애플리케이션 개발자일 뿐 아니라 &lt;strong>데이터 시스템 설계자&lt;/strong>이기도 하다.&lt;/p>
&lt;hr>
&lt;p>데이터 시스템이나 서비스를 설계할 때 까다로운 문제가 많이 생긴다.&lt;/p>
&lt;ul>
&lt;li>내부적으로 문제가 있어도 데이터를 정확하고 완전하게 유지해야함&lt;/li>
&lt;li>시스템의 일부 성능이 저하되더라도 클라이언트에 일관되게 좋은 성능을 제공해야함&lt;/li>
&lt;li>부하 증가를 다루기 위해 규모를 확장할 수 있어야함&lt;/li>
&lt;li>서비스를 위해 좋은 API를 설계해야함&lt;/li>
&lt;/ul>
&lt;p>뿐만 아니라 관련자의 기술 숙련도, 기존 시스템의 의존성, 전달 시간 척도, 다양한 종류의 위험에 대한 조직의 내성, 규제 제약 등은 시스템 설계에 영향을 줄 수 있는 많은 요소이다.&lt;/p>
&lt;p>이런 요소는 상황에 크게 좌우되는 요소이므로 이 책에서는 &lt;strong>대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사에 중점&lt;/strong>을 둔다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>신뢰성&lt;/strong>(Reliability)
&lt;ul>
&lt;li>하드웨어나 소프트웨어 결함, 인적 오류 같은 &lt;strong>역경&lt;/strong>에 직면하더라도 시스템은 지속적으로 올바르게 동작(원하는 성능 수준에서 정확한 기능을 수행)해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>확장성&lt;/strong>(Scalability)
&lt;ul>
&lt;li>시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>유지보수성&lt;/strong>(Maintainability)
&lt;ul>
&lt;li>여러 다양한 사람들이 시스템 상에서 작업할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있어야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="신뢰성">신뢰성&lt;/h2>
&lt;p>소프트웨어의 경우 신뢰성에 대한 일반적인 기대치는 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션은 사용자가 기대한 기능을 수행한다.&lt;/li>
&lt;li>시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다.&lt;/li>
&lt;li>시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.&lt;/li>
&lt;li>시스템은 허가되지 않은 접근과 오남용을 방지한다.&lt;/li>
&lt;/ul>
&lt;p>이러한 내용들이 올바르게 동작함을 의미하는 경우, 대략 &amp;ldquo;&lt;strong>무언가 잘못 되더라도 지속적으로 올바르게 동작함&lt;/strong>&amp;ldquo;을 신뢰성의 의미로 이해할 수 있다.&lt;/p>
&lt;h3 id="결함">결함&lt;/h3>
&lt;p>잘못될 수 있는 일을 &lt;strong>결함&lt;/strong>(fault)이라 부른다.&lt;/p>
&lt;p>그리고 결함을 예측하고 대처할 수 있는 시스템을 &lt;strong>내결함성&lt;/strong>(fault-tolerant) 또는 &lt;strong>탄력성&lt;/strong>(resilient)을 지녔다고 말한다.&lt;/p>
&lt;p>모든 종류의 결함을 견딜 수 있는 시스템은 실제로 실현 가능하지 않으므로 &lt;strong>특정 유형&lt;/strong>의 결함 내성에 대해서만 이야기하는 것이 타당하다.&lt;/p>
&lt;p>결함과 장애(failure)는 다르다.&lt;/p>
&lt;ul>
&lt;li>결함
&lt;ul>
&lt;li>사양에서 벗어난 시스템의 한 구성 요소&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>장애
&lt;ul>
&lt;li>사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>결함 확률을 0으로 줄이는 것은 불가능하므로 결함으로 인해 장애가 발생하지 않게끔 내결함성 구조를 설계하는 것이 좋다.&lt;/p>
&lt;ul>
&lt;li>이 책에서는 신뢰할 수 없는 여러 부품들로 신뢰할 수 있는 시스템을 구축하는 다양한 기법을 배운다.&lt;/li>
&lt;/ul>
&lt;p>실제 많은 중대한 버그는 미흡한 오류 처리에서 기인한다.&lt;/p>
&lt;ul>
&lt;li>내결함성 시스템에서 고의적으로 결함을 유도함으로써 내결함성 시스템을 지속적으로 훈련하고 테스트해서 결함이 자연적으로 발생했을 때 올바르게 처리할 수 있다는 자신감을 높인다.&lt;/li>
&lt;li>ex) 넷플릭스의 &lt;strong>카오스 몽키&lt;/strong>(Chaos Monkey)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>일반적으로 결함 예방을 넘어 내결함성을 갖는 것을 선호하지만, 해결책이 없는 경우는 예방책이 필수적이다.&lt;/p>
&lt;ul>
&lt;li>보안 문제: 공격자가 시스템을 손상시키고 민감한 데이터에 대한 접근 권한을 얻는다면 되돌릴 수 없다.&lt;/li>
&lt;/ul>
&lt;h3 id="하드웨어-결함">하드웨어 결함&lt;/h3>
&lt;p>시스템 장애의 대표적인 예시로, 규모가 큰 데이터센터에서 일하는 사람은 많은 장비를 다룰 경우 이 같은 일은 늘상 일어난다고 말한다.&lt;/p>
&lt;ul>
&lt;li>10,000개의 디스크로 구성된 저장 클러스터는 평균적으로 하루에 한 개의 디스크가 죽는다고 예상해야한다.&lt;/li>
&lt;/ul>
&lt;p>시스템 장애율을 줄이기 위한 대표적인 방법은 각 하드웨어 구성 요소에 중복(redundancy)을 추가하는 방법이다.&lt;/p>
&lt;ul>
&lt;li>구성 요소가 죽으면 고장 난 구성 요소가 교체되는 동안 중복된 구성 요소를 대신 사용한다.&lt;/li>
&lt;/ul>
&lt;p>이런 접근 방식은 하드웨어 문제로 장애가 발생하는 것은 완전히 막으룻는 없지만 이해하기 쉽고 보통 수년 간 장비가 중단되지 않고 계속 동작할 수 있게 한다.&lt;/p>
&lt;p>최근까지 단일 장비의 전체 장애는 매우 드물기 때문에 대부분의 애플리케이션은 하드웨어 구성 요소의 중복으로 충분하여, 다중 장비 중복은 고가용성(high availability)이 절대적으로 필수적은 소수의 애플리케이션에서만 필요했다.&lt;/p>
&lt;ul>
&lt;li>새 장비에 백업을 매우 빠르게 복원할 수 있는 경우 중단시간(downtime)은 대부분의 애플리케이션에 치명적이지 않다.&lt;/li>
&lt;/ul>
&lt;p>하지만 데이터 양과 애플리케이션의 계산 요구가 늘어나면서 더 많은 애플리케이션이 많은 수의 장비를 사용하게 됐고 이와 비례해 하드웨어 결함율도 증가했다.&lt;/p>
&lt;p>따라서 소프트웨어 내결함성 기술을 사용하거나 하드웨어 중복성을 추가해 전체 장비의 손실을 견딜 수 있는 시스템으로 점점 옮겨가고 있으며, 이러한 시스템에는 운영상의 장점도 있다.&lt;/p>
&lt;ul>
&lt;li>장비를 재부팅 해야하는 경우 등&lt;/li>
&lt;/ul>
&lt;h3 id="소프트웨어-오류">소프트웨어 오류&lt;/h3>
&lt;p>보통 하드웨어 결함을 무작위적으고 서로 독립적이라고 생각한다.&lt;/p>
&lt;ul>
&lt;li>다수의 하드웨어 구성 요소에 동시 장애가 발생하는 경우는 드물다.&lt;/li>
&lt;/ul>
&lt;p>또 다른 부류의 결함으로 시스템 내 체계적 오류(systematic error)는 예상하기 더 어렵고 노드 간 상관관계 때문에 상관관계가 없는 하드웨어 결함보다 오히려 시스템 오류를 더욱 많이 유발하는 경향이 있다.&lt;/p>
&lt;ul>
&lt;li>잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그
&lt;ul>
&lt;li>ex) 리눅스 커널의 버그로 인해 많은 애플리케이션이 일제히 멈춰버린 원인니 된 2012년 6월 30일 윤초&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스&lt;/li>
&lt;li>시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스&lt;/li>
&lt;li>한 구성 요소의 작은 결함이 다른 구성 요소의 결함을 야기하고 차례차례 더 많은 결함이 발생하는 연쇄 장애(cascading failure)&lt;/li>
&lt;/ul>
&lt;p>이 같은 소프트웨어 결함을 유발하는 버그는 &lt;strong>특정 상황에 의해 발생하기 전까지 오랫동안 나타나지 않는다&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>소프트웨어에는 확여에 대한 일종의 가정이 있다는 시실을 알 수 있다.(일부 제외)&lt;/li>
&lt;/ul>
&lt;p>스프트웨어의 체계적 오류 문제는 신속한 해결책이 없다.&lt;/p>
&lt;ul>
&lt;li>시스템의 가정과 상호작용에 대해 주의 깊게 생각하기&lt;/li>
&lt;li>빈틈없는 테스트&lt;/li>
&lt;li>프로세스 격리(process isolation)&lt;/li>
&lt;li>죽은 프로세스의 재시작 허용&lt;/li>
&lt;li>프로덕션 환경에서 스스템 동작의 측정&lt;/li>
&lt;li>모니터링&lt;/li>
&lt;li>분석하기&lt;/li>
&lt;/ul>
&lt;p>위와 같은 여러 작은 일들이 문제 해결에 도움을 줄 수 있다.&lt;/p>
&lt;p>시스템이 무너가를 보장하길 기대한다면 수행 중에 이를 지속적으로 확인해 차이가 생기는 경우 경고를 발생시킬 수 있다.&lt;/p>
&lt;h3 id="인적-오류">인적 오류&lt;/h3>
&lt;p>사람은 소프트웨어 시스템을 설계하고 구축하며, 운영자로서 시스템을 계속 운영한다.&lt;/p>
&lt;ul>
&lt;li>대규모 인터넷 서비스에 대한 연구에 따르면 운영자의 설정 오류가 중단의 주요 원인이며, 하드웨어 결함은 중단 원인의 10~20%에 그친다.&lt;/li>
&lt;/ul>
&lt;p>다양한 접근 방식을 결합하여 신뢰성 있는 시스템을 만들어야 한다.&lt;/p>
&lt;ul>
&lt;li>오류의 가능성을 최소하 하는 방향으로 시스템을 설계
&lt;ul>
&lt;li>잘 설계된 추상화, API, 관리 인터페이스 사용으로 옳은 일은 쉽게 하고, 잘못된 일은 막는다.&lt;/li>
&lt;li>인터페이스가 지나치게 제한적이면 제한된 인터페이스를 사람들은 피해 작업하는 경향이 있어, 올바르게 작동하게끔 균형을 맞추기 어렵다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사람이 가장 많이 실수하는 장소(부분)에서 사람의 실수로 장애가 발생할 수 있는 부분을 분리
&lt;ul>
&lt;li>비 프로덕션 샌드박스(sandbox) 환경 제공&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트
&lt;ul>
&lt;li>코너 케이스를 다루는 데 유용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>장애 발생의 영향을 최소화하기 위해 인적 오류를 빠르고 쉽게 복구할 수 있는 환경
&lt;ul>
&lt;li>설정 변경 내역을 빠르게 롤백&lt;/li>
&lt;li>새로운 코드를 서서히 롤하웃하게 구성(예상치 못한 버그가 일부 사용자에게만 영향이 미치도록)&lt;/li>
&lt;li>이전 계산이 잘못된 경우를 대비해 데이터 재계산 도구 제공&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책 마련
&lt;ul>
&lt;li>원격 측정(telemetry)&lt;/li>
&lt;li>모니터링은 조기에 경고 신호를 보내줄 수 있고 특정 가정이나 제한을 벗어나는지 확인할 수 있게 함&lt;/li>
&lt;li>문제가 발생했을 때 지표는 문제를 분석하는 데 매우 중요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>조작 교육과 실습을 진행&lt;/li>
&lt;/ul>
&lt;h3 id="신뢰성은-얼마나-중요할까">신뢰성은 얼마나 중요할까?&lt;/h3>
&lt;p>신뢰성은 원자력 발전소나 항공 교통 관제 소프트웨어만을 위한 것이 아니며, 일상적인 애플리케이션도 안정적으로 작동해야한다.&lt;/p>
&lt;p>비즈니스 애플리케이션에서 버그는 생산성 저하의 원인이고 전자 상거래 사이트의 중단은 매출에 손실이 발생하고 명성에 타격을 준다는 면에서 많은 비용이 든다.&lt;/p>
&lt;p>중요하지 않은 애플리케이션도 사용자에 대한 책임이 있다.&lt;/p>
&lt;ul>
&lt;li>사소한 데이터라도 누군가에게는 매우 소중할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>비용을 줄이려 신뢰성을 희생해야 하는 경우, 비용을 줄여하는 시점을 매우 잘 알고 있어야 한다.&lt;/p>
&lt;h2 id="확장성">확장성&lt;/h2>
&lt;p>시스템이 현재 안정적으로 동작한다고 해서 미래에도 아정적으로 동작한다는 보장은 없다.&lt;/p>
&lt;p>성능 저하를 유발하는 흔한 이뉴 중 하나는 부하 증가로, 확장성은 증가한 부하에 대처하는 시스템 능력을 설명한다.&lt;/p>
&lt;p>확장성을 논한다는 것은 &amp;ldquo;&lt;strong>시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?&lt;/strong>&amp;ldquo;와 &amp;ldquo;&lt;strong>추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?&lt;/strong>&amp;rdquo; 같은 질문을 고여한다는 의미이다.&lt;/p>
&lt;h3 id="부하-기술하기">부하 기술하기&lt;/h3>
&lt;p>무엇보다 시스템의 현재 부하를 간결하게 기술해야 부하 성장 질문을 논의할 수 있다.&lt;/p>
&lt;p>부하는 &lt;strong>부하 매개변수&lt;/strong>(load parameter)라 부르는 몇 개의 숫자로 내타낼 수 있으며, 가장 적합한 부하 매개변수 선택은 시스템 설계에 따라 달라진다.&lt;/p>
&lt;ul>
&lt;li>웹 서버의 초당 요청 수&lt;/li>
&lt;li>데이터베이스의 읽기 대 쓰기 비율&lt;/li>
&lt;li>대화방의 동시 활성 사용자(active user)&lt;/li>
&lt;li>캐시 적중률 등&lt;/li>
&lt;/ul>
&lt;p>평균적인 경우가 중요할 수도 있고 소수의 극단적인 경우가 병목 현상의 우너인일 수도 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>트위터 예시&lt;/strong>&lt;/p>
&lt;p>트위터의 주요 두 가지 동작은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>트윗 작성
&lt;ul>
&lt;li>사용자는 팔로워에게 새로운 메시지를 게시할 수 있다.&lt;/li>
&lt;li>평균 초당 4.6k 요청, 피크일 때 12k 요청 이상&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>홈 타임라인
&lt;ul>
&lt;li>사용자는 팔로우한 사람이 작성한 트윗을 볼 수 있다.&lt;/li>
&lt;li>초당 300k 요청&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>단순히 초당 12,000쓰기 처리는 상당히 쉽지만, 트위터의 확장성 문제는 주로 트윗 양이 아닌 팬 아웃(fan-out) 때문이다.&lt;/p>
&lt;p>개별 사용자는 많은 사용자를 팔로우하고 많은 사람이 개별 사용자를 팔로우한다.&lt;/p>
&lt;ol>
&lt;li>트윗 작성은 간단히 새로운 트윗 전역 컬렉션에 삽입.
&lt;ul>
&lt;li>사용자가 자신의 홈 타임라인을 요청하면 팔로우하는 모든 사람을 찾고, 이 사람들의 모든 트윗을 찾아 시간순으로 정렬해서 합친다.&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tweets&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tweets&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tweets&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sender_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">follows&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">follows&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">followee_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">follows&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">follower_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">current_user&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 수신 사용자용 트윗 유편함처럼 개별 사용자의 홈 타임라인 캐시를 유지.
&lt;ul>
&lt;li>사용자가 트윗을 작성하면 해당 사용자를 팔오우하는 사람을 모두 찾고 팔로워 각자의 홈 타임라인 캐시에 새로운 트윗을 삽입&lt;/li>
&lt;li>홈 타임라인의 읽기 요청은 요청 결과를 미리 계산했으므로 비용이 저렴&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img_2.png"
width="2880"
height="1037"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_2_huef454c28ed509f14d0506aa4413f3fba_72867_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_2_huef454c28ed509f14d0506aa4413f3fba_72867_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="트위터 홈 타임라인 구현을 위한 간략한 관계형 스키마"
class="gallery-image"
data-flex-grow="277"
data-flex-basis="666px"
>&lt;br>
&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img_3.png"
width="2880"
height="1037"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_3_huf1eee131e293bb95b1294c4be771ef1f_79137_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_3_huf1eee131e293bb95b1294c4be771ef1f_79137_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="매개변수와 함께 팔로워에게 트윗을 전송하기 위한 트위터의 데이터 파이프라인"
class="gallery-image"
data-flex-grow="277"
data-flex-basis="666px"
>&lt;/p>
&lt;p>트위터의 첫 번째 버전은 1을 사용했는데, 시스템이 홈 타임라인 질의 부하를 버텨내기 위해 고군분투 해야했고, 그 결과 2로 전환했다.&lt;/p>
&lt;ul>
&lt;li>평균적으로 트윗 게시 요청량이 홈 타임라인 읽기 요청량에 비해 수백 배 적기 때문에 2가 훨씬 잘 동작함
이 경우는 쓰기 시점에 더 많은 일을 하고, 일기 시점에 적은 일을 하는 것이 바람직하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>2의 불리한 점은 트윗 작성이 많은 부가 작업을 필요로 한다는 점이다.&lt;/p>
&lt;ul>
&lt;li>평균 트윗이 약 75명의 팔로워에게 전달되므로 초당 4.6k 트윗은 홈 타임라인 캐시에 초당 345k건의 쓰기 요청 발생&lt;/li>
&lt;li>일부 사용자는 팔로워가 3천만명이 넘으므로 단일 트윗이 홈 타임라인에 3천만 건 이상의 쓰기 요청 발생 가능&lt;/li>
&lt;/ul>
&lt;p>트위터 사례에서 사용자당 팔로워의 분포는 팬 아웃 부하를 결정하기 때문에 확장성을 논의할 때 핵심 부하 매개변수가 된다.&lt;/p>
&lt;p>결과적으로 트위터는 접근 방식 2를 기반으로 하이브리드 형식으로 바꾸고 있다.&lt;/p>
&lt;ul>
&lt;li>대부분 사용자의 트윗은 계속해서 사람들이 작성할 때 홈 타임라인에 펼쳐지지만 유명인은 팬 아웃에서 제외된다.&lt;/li>
&lt;li>유명인의 트윗은 별도로 가져와 1처럼 읽는 시점에 사용자의 홈 타임라인에 합친다.&lt;/li>
&lt;/ul>
&lt;h3 id="성능-기술하기">성능 기술하기&lt;/h3>
&lt;p>일단 시스템 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있다.&lt;/p>
&lt;ul>
&lt;li>부하 매개변수를 증가시키고 시스템 자원은 병경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?&lt;/li>
&lt;li>부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까?&lt;/li>
&lt;/ul>
&lt;p>두 질문 모두 성능 수치가 필요하므로 시스템 성능에 대해 간단히 살펴본다.&lt;/p>
&lt;ul>
&lt;li>일괄 처리 시스템(ex. hadoop)
&lt;ul>
&lt;li>&lt;strong>처리량&lt;/strong>(throughput, 초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>온라인 시스템
&lt;ul>
&lt;li>서비스 &lt;strong>응답 시간&lt;/strong>(response time)&lt;/li>
&lt;li>클라이언트가 요청을 보내고 응답을 받는 사이의 시간&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>지연 시간(latency)과 응답 시간(response time)&lt;/strong>&lt;br>
응답 시간은 클라이언트 관점에서 본 시간으로, 요청을 처리하는 실제 시간 외에도 네트워크 지연과 큐 지연도 포함한다.&lt;br>
지연 시간은 요청이 처리되길 기다리는 시간으로, 서비스를 기다리며 휴지(latent) 상태인 시간을 말한다.&lt;/p>
&lt;/blockquote>
&lt;p>응답 시간은 매번 요청에 따라 달라지기 때문에, 단일 숫자가 아닌 측정 가능한 값의 분포로 생각해야한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img_4.png"
width="2880"
height="805"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_4_hu34112d46532c22af0f415ce8b7d25f2a_86463_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_4_hu34112d46532c22af0f415ce8b7d25f2a_86463_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="평균과 백분위 예시"
class="gallery-image"
data-flex-grow="357"
data-flex-basis="858px"
>&lt;/p>
&lt;p>대부분의 요청은 꽤 빠르지만 가끔 오래 걸리는 &lt;strong>특이 값(outlier)&lt;/strong> 이 있는데 다음과 같이 이유로 발생할 수 있다.&lt;/p>
&lt;ul>
&lt;li>백그라운드 프로세스의 컨텍스트 스위치&lt;/li>
&lt;li>네트워크 패킷 손실과 TCP 재전송&lt;/li>
&lt;li>가비지 컬렉션 휴지&lt;/li>
&lt;li>디스크에서 읽기를 강제하는 페이지 폴트&lt;/li>
&lt;li>서버 랙의 기계적인 진동 등&lt;/li>
&lt;/ul>
&lt;p>보고된 서비스 평균 응답 시간을 살피는 일이 일반적이지만, 전형적인 응답 시간을 알고 싶다면 평균은 좋은 지표는 아니다.&lt;/p>
&lt;ul>
&lt;li>얼마나 많은 사용자가 실제로 지연을 경험했는지 알 수 없음&lt;/li>
&lt;/ul>
&lt;p>일반적으로 평균보다는 &lt;strong>백분위&lt;/strong>(percentile)을 사용하는 편이 더 좋다.&lt;/p>
&lt;ul>
&lt;li>중앙값(median, p50)
&lt;ul>
&lt;li>사용자가 보통 얼마나 오랫동안 기다려야 하는지 알고 싶다면 좋은 지표&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>상위 백분위
&lt;ul>
&lt;li>p95, p99, p999 같은 상위 백분위를 통해특이 값이 얼마나 좋지 않은지 확인에 좋은 지표&lt;/li>
&lt;li>&lt;strong>꼬리 지연 시간(tail latency)&lt;/strong> 으로 알려진 상위 백분위 응답 시간은 서비스의 사용자 경험에 직접 영향을 주기 때문에 중요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>p9999 같이 최상위 백분위는 통제할 수 없는 임의 이벤트에 쉽게 영향을 받으므로 응답 시간을 줄이기가 매우 어려어 이점이 줄어든다.&lt;/p>
&lt;p>백분위는 서비스 수준 목표(service level objective, SLO)와 서비스 수준 협약서(service level agreement, SLA)에 자주 사용하고 기대 성능과 서비스 가용성르 정의하는 계약서에도 자주 등장한다.&lt;/p>
&lt;ul>
&lt;li>응답 시간 중앙값이 200밀리초 미만이고 99분위가 1초 미만인 경우 정상 서비스 상태로 간주하며 서비스 제공 시간은 99.9% 이상이어야 한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>선두 차단(head-of-line blocking)&lt;/strong>&lt;/p>
&lt;p>큐 대기 지연은 높은 백분위에서 응답 시간의 상당 부분을 차지한다.&lt;/p>
&lt;ul>
&lt;li>서버는 병렬로 소수의 작업만 처리할 수 있기 때문에 소수의 느린 요청 처리만으로 후속 요청 처리가 지체된다.&lt;/li>
&lt;li>서버에서 후속 요청이 빠르게 처리되더라도 이전 요청이 완료되길 기다리는 시간 때문에 클라이언트는 전체적으로 응답 시간이 느리다고 생각하게된다.&lt;/li>
&lt;/ul>
&lt;p>이런 문제로 인해 클라이언트 쪽 응답 시간 측정이 중요하다.&lt;/p>
&lt;hr>
&lt;p>시스템의 확장성을 테스트하려고 인위적으로 부하를 생성하는 경우 부하 생성 클라이언트는 응답 시간과 독립적으로 요청을 지속적으로 보내야한다.&lt;/p>
&lt;ul>
&lt;li>다음 요청을 보내기 전에 이전 요청이 완료되길 기다리면 테스트에서 인위적으로 대기 시간을 실제보다 더 짧게 만들어 평가를 왜곡한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img_5.png"
width="2880"
height="1304"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_5_hu4bbd8047ec59659dcb92a302da18488b_76022_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_5_hu4bbd8047ec59659dcb92a302da18488b_76022_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="요청을 처리하기 위해 여러 번 백엔드 호출이 필요한 상황에서 단 하나의 느린 백엔드 요청이 전체 최종 사용자 요청을 느리게 만든다."
class="gallery-image"
data-flex-grow="220"
data-flex-basis="530px"
>&lt;/p>
&lt;h3 id="부하-대응-접근-방식">부하 대응 접근 방식&lt;/h3>
&lt;p>부하 수준 1단계에 적합한 아키텍처로는 10배의 부하를 대응할 수 없기 때문에 급성장하는 서비스를 맡고 있다면 부하 규모의 자릿수가 바뀔 때마다 혹은 그보다 자주 아키텍처를 재검토해야 할지 모른다.&lt;/p>
&lt;p>확장성과 관련해 &lt;strong>용량 확장(scaling up, 수직 확장)&lt;/strong> 과 &lt;strong>규모 확장(scaling out, 수평 확장)&lt;/strong> 구분할 수 있다.&lt;/p>
&lt;p>다수의 장비에 부하를 분산하는 아키텍처를 &lt;strong>비공유(shared-noting)&lt;/strong> 아키텍처라 부르며, 단일 장비에서 수행될 수 있는 시스템은 보통 간단하지만 고사양 장비는 매우 비싸기 때문에 상당히 집약된 작업 부하는 대개 규모 확장을 피하지 못한다.&lt;/p>
&lt;p>현실적으로 좋은 아키텍처는 실용적인 접근 방식의 조합이 필요하다.&lt;/p>
&lt;ul>
&lt;li>적절한 사양의 장비 몇 대가 다량의 낮은 사양 가상 장비보다 여전히 훨씬 간단하고 저렴하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>일부 시스템은 &lt;strong>탄력적(elastic)&lt;/strong> 이다.&lt;/p>
&lt;ul>
&lt;li>부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가할 수 있다. 그렇지 않은 시스템은 수동으로 확장해야한다.&lt;/li>
&lt;/ul>
&lt;p>탄력적인 시스템은 부하를 예측할 수 없을 만큼 높은 경우 유용하지만, 수동으로 확장하는 시스템이 더 간단하고 운영상 예상치 못한 일이 더 적다.&lt;/p>
&lt;hr>
&lt;p>다수의 장비에 상태 비저앙(stateless) 서비스를 배포하는 일은 상당히 간단하지만, 단일 노드에 상태 유지(stateful) 데이터 시스템을 분산 설치하는 일은 아주 많은 복잡도가 추가적으로 발생한다.&lt;/p>
&lt;ul>
&lt;li>이런 이유로 확장 비용이나 데이터베이스를 분산으로 만들어야 하는 고가용성 요구가 있을 때 까지 단일 노드에 데이터베이스를 유지하는 것이 최근까지의 통념이다.&lt;/li>
&lt;/ul>
&lt;p>분산 시스템을 위한 도구와 추상화가 좋아지면서 이 통념이 적어도 일부 애플리케이션에서는 바뀌었다.&lt;/p>
&lt;ul>
&lt;li>대용량 데이터와 트래픽을 다루지 않는 사용 사례에도 분산 데이터 시스템이 향후 기본 아키텍처로 자리 잡을 가능성이 있다.&lt;/li>
&lt;/ul>
&lt;p>대개 대규모로 동작하는 시스템의 아키텍처는 해당 시스템을 사용하는 애플리케이션에 특화돼 있다.&lt;/p>
&lt;ul>
&lt;li>범용적으로 모든 상황에 맞는 확장 아키텍처는 없다.&lt;/li>
&lt;/ul>
&lt;p>아키텍처를 결정하는 요소는 읽기의 양, 쓰기의 양, 저장할 데이터의 양, 데이터의 복잡도, 응답 시간 요구사항, 접근 패턴 등이 있다.&lt;/p>
&lt;p>특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 무엇인지에 대한 가정을 바탕으로 구축한다.&lt;/p>
&lt;ul>
&lt;li>이 가정은 곧 부하 매개변수가 되며, 이 가정이 잘못되면 확장에 대한 엔지니어링 노력은 헛수고가 되고 최악의 경우 역효과를 낳을 수 있다.&lt;/li>
&lt;/ul>
&lt;p>스타트업 초기 단계나 검증되지 않은 제품의 경우 미래를 가정한 부하에 대비해 확장하기보다는 빠르게 반복해서 제품 기능을 개선하는 작업이 좀 더 중요하다.&lt;/p>
&lt;ul>
&lt;li>확장성을 갖춘 아키텍처가 특정 애플리케이션에 특화됐을 지라도 일너 아키텍처는 보통 익숙한 패턴으로 나열된 범용적인 구성 요소로 구축한다.&lt;/li>
&lt;/ul>
&lt;h2 id="유지보수성">유지보수성&lt;/h2>
&lt;p>소프트웨어 비용의 대부분은 지속해서 이어지는 유지보수에 들어간다.&lt;/p>
&lt;ul>
&lt;li>버그 수정, 시스템 운영 유지, 장애 조사, 시로운 플랫폼 적용, 새 사용 사례를 위한 변경, 기술 채무 상환, 새로운 기능 추가 등&lt;/li>
&lt;/ul>
&lt;p>모든 레거시 시스템은 각자 나름에 풀편함이 있어 이를 다루기 위해 일반적으로 추천할 만한 방법을 제시하는 일은 매우 어렵다.&lt;/p>
&lt;p>하지만 희망적인 점은 유지보수 중 고통을 최소화하고 레거시 소프트웨어를 직접 만들지 않게끔 소프투웨어를 설계할 수 있다는 점이다.&lt;/p>
&lt;p>그러기 위해 주의를 기울여야 할 소프트웨어 시스템 설계 원칙은 다음 세 가지이다.&lt;/p>
&lt;ul>
&lt;li>운용성(operability)
&lt;ul>
&lt;li>운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단순성(simplicity)
&lt;ul>
&lt;li>시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라&lt;/li>
&lt;li>사용자 인터페이스의 단순성과는 다르다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>발전성(evolvability)
&lt;ul>
&lt;li>엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라.&lt;/li>
&lt;li>요구사항 변경 같은 예기치 않은 사용 사례를 적용하기 쉽다.&lt;/li>
&lt;li>유연성, 수정 가능성, 적응성으로 알려져 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>신뢰성, 확장성을 달성하기 위한 쉬운 해결책은 없으므로, 운용성, 단순성, 발전성을 염두에 두고 시스템을 생각하려 노력해야한다.&lt;/p>
&lt;h3 id="운용성-운영의-편리함-만들기">운용성: 운영의 편리함 만들기&lt;/h3>
&lt;p>좋은 운영은 종종 나쁜 소프트웨어의 제약을 피하는 대안이 될 수 있다.&lt;/p>
&lt;p>하지만 좋은 소프트웨어라도 나쁘게 운영할 경우 작동을 신뢰할 수 없다는 말이 있다.&lt;/p>
&lt;ul>
&lt;li>운영 중 일부 측면은 자동화할 수 있고 또 자동화 해야한다.&lt;/li>
&lt;li>자동화를 처음 설정하고 제대로 동작하는지 확인하는 일은 여전히 사람의 몫이다.&lt;/li>
&lt;/ul>
&lt;p>시스템이 지속해서 원할하게 작동하려면 운영팀이 필수이며, 좋은 운영팀은 일반적으로 다음과 같은 작업 등을 책임진다.&lt;/p>
&lt;ul>
&lt;li>시스템 상태를 모니터링 하고 상태가 좋지 않다면 빠르게 서비스를 복원&lt;/li>
&lt;li>시스템 장애, 성능 저하 등의 문제의 원인을 추적&lt;/li>
&lt;li>보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지&lt;/li>
&lt;li>다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사하응ㄹ 손상을 입히기 전에 차단&lt;/li>
&lt;li>미래에 발생 가능한 문제를 예측해 문제가 발생하기 전에 해결(ex. 용량 계획 등)&lt;/li>
&lt;li>배포, 설정 관리 등을 위한 모범 사례와 도구를 마련&lt;/li>
&lt;li>애플리케이션을 특정 플랫폼에서 다른 플랫폼으로 이동하는 등 복잡한 유지보스 태스크를 수행&lt;/li>
&lt;li>설정 변경으로 생기는 시스템 보안 유지보수&lt;/li>
&lt;li>예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의&lt;/li>
&lt;li>개인 인사 이동에도 시스템에 대한 조직의 지식을 보존&lt;/li>
&lt;/ul>
&lt;p>좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활도에 노력을 집중한다는 의미이다.&lt;/p>
&lt;ul>
&lt;li>좋은 모니터링으로 런타임 동작과 시스템의 내부에 대한 가시성 제공&lt;/li>
&lt;li>표준 도구를 이용해 자동화와 통합을 위한 우수한 자원을 제공&lt;/li>
&lt;li>개별 장비 의존성을 회피. 유지보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고 계속해서 운영 가능해야함&lt;/li>
&lt;li>좋은 문서와 이해하기 쉬운 운영 모델(ex. X를 하면 Y가 발생한다.) 제공&lt;/li>
&lt;li>만족할 만한 기본 동작을 제공하고, 필요할 때 기본값을 다시 정의할 수 있는 자유를 관리자에게 부여&lt;/li>
&lt;li>적절하게 자기 회복이 가능할 뿐 아니라 필요에 따라 관리자가 시스템 상태를 수동으로 제어할 수 있게 함&lt;/li>
&lt;li>에측 가능하게 동작하고 예기치 않은 상황을 최소화함&lt;/li>
&lt;/ul>
&lt;h3 id="단순성-복잡도-관리">단순성: 복잡도 관리&lt;/h3>
&lt;p>프로젝트가 커짐에 따라 시스템은 매우 복잡하고 이해하기 어려워진다.&lt;/p>
&lt;p>복잡도는 같은 시스템에서 작업해야 하는 모든 사람의 진행을 느리게 하고 나아가 유지 보수 비용이 증가한다.&lt;/p>
&lt;ul>
&lt;li>커다란 진흙 덩어리(big ball of mud)로 묘사한다.&lt;/li>
&lt;/ul>
&lt;p>복잡도는 다양한 증상으로 나타난다.&lt;/p>
&lt;ul>
&lt;li>상태 공간의 급증&lt;/li>
&lt;li>모듈 간 강한 커플링(tight coupling)&lt;/li>
&lt;li>복잡한 의존성&lt;/li>
&lt;li>일관성 없는 명명과 용어&lt;/li>
&lt;li>성능 문제 해결을 목표로 한 해킹&lt;/li>
&lt;li>임시방편으로 문제를 해결한 특수 사례 등&lt;/li>
&lt;/ul>
&lt;p>복잡도가 높아 시스템 유지보수가 어려울 때 아래와 같은 문제들이 발생할 수 있다.&lt;/p>
&lt;ul>
&lt;li>예산과 일정이 초과&lt;/li>
&lt;li>변경이 있을 때 버그가 생길 위험이 더 큼&lt;/li>
&lt;li>개발자가 시스템을 이해하고 추론하기 어려워지면서 시스템에 숨겨진 가정과 의도치않은 결과 및 예기치 않은 상호작용을 간과하기 쉬움&lt;/li>
&lt;/ul>
&lt;p>반대로 복잡도를 줄이면 소프트웨어 유지보수성이 크게 향상되므로, 단순성이 구축하려는 시스템의 핵심 목표여야 한다.&lt;/p>
&lt;p>시스템을 단순하게 만드는 일은 단순히 기능을 줄인다는 의미는 아니며, &lt;strong>우발적 복잡도(accidental complexity)&lt;/strong> 를 줄인다는 뜻에 더 가깝다.&lt;/p>
&lt;ul>
&lt;li>우발적 복잡도: 소프트웨어가 풀어야 할 (사용자에게 보이는) 문제에 내재하고 있지 않고 구현에서만 발생하는 것&lt;/li>
&lt;/ul>
&lt;p>우발적 복잡도를 제거하기 위한 최상의 도구는 추상화이다.&lt;/p>
&lt;ul>
&lt;li>깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.&lt;/li>
&lt;/ul>
&lt;p>좋은 추상화는 다른 다양한 애플리케이션에서도 사용 가능하다.&lt;/p>
&lt;p>이러한 재사용은 비슷한 기능을 여러 번 재구현 하는 것보다 더 효율적일 뿐만 아니라 추상화된 구성 요소의 품질 향상이 이를 사용하는 모든 애플리케이션에 도움을 주므로 고품질 소프트웨어로 이어진다.&lt;/p>
&lt;p>하지만 좋은 추상화를 찾기는 매우 어렵다.&lt;/p>
&lt;p>분산 시스템 분야에서는 여러 좋은 알고리즘이 있지만 관리 가능한 수준에서 시스템 복잡도를 유지하는 데 도움이 되는 추상화로 이런 알고리즘을 묶는 방법은 명확하지 않다.&lt;/p>
&lt;h3 id="발전성-변화를-쉽게-만들기">발전성: 변화를 쉽게 만들기&lt;/h3>
&lt;p>시스템의 요구사항이 끊임없이 변할 가능성이 크다.&lt;/p>
&lt;ul>
&lt;li>새로운 사실을 배움&lt;/li>
&lt;li>미처 예기치 않은 사용 사례 발견&lt;/li>
&lt;li>비즈니스 우선순위 변경&lt;/li>
&lt;li>사용자의 새로운 니즈&lt;/li>
&lt;li>새로운 플랫폼 등장&lt;/li>
&lt;li>법적 또는 규제 요구사항 변경&lt;/li>
&lt;li>시스템의 성장으로 인한 아키텍처 변화&lt;/li>
&lt;/ul>
&lt;p>조직 프로세스 측면에서 &lt;strong>애자일&lt;/strong> 작업 패턴은 변화에 적응하기 위한 프레임워크를 제공한다. 또한 애자일 커뮤니티는 TDD, 리팩토링 같이 자주 변화하는 환경에서 소프트웨어를 개발할 때 도움이 되는 기술 도구와 패턴을 개발하고 있다.&lt;/p>
&lt;p>애자일 기법에 대한 설명은 대부분 매우 작고, 로컬 규모(동일 애플리케이션 내 소스코드 파일이 몇 개반 있음)에 초점을 맞추고 있는데, 이 책에서는 다양한 애플리케이션이나 다른 특성을 가진 서비스로 구성된 대규모 데이터 시스템 수준에서 민첩성을 높이는 방법을 찾는다.&lt;/p>
&lt;p>데이터 시스템 변경을 쉽게 하고 변화된 요구사항에 시스템을 맞추는 방법은 시스템의 간단함과 추상화와 밀접한 관련이 있다.&lt;/p>
&lt;ul>
&lt;li>간단하고 이해하기 쉬운 시스템은 대개 복잡한 시스템보다 수정하기 쉽다.&lt;/li>
&lt;li>데이터 시스템 수준에서 민첩성을 언급할 때는 &lt;strong>발전성&lt;/strong> 사용한다.&lt;/li>
&lt;/ul>
&lt;h2 id="정리">정리&lt;/h2>
&lt;p>이번 장에서는 데이터 중심 애플리케이션을 생각하는 기본적인 방법 몇 가지를 살펴봤다.&lt;/p>
&lt;p>애플리케이션이 유용하려면 다양한 요구사항을 충족시켜야 한다.&lt;/p>
&lt;ul>
&lt;li>기능적 요구사항
&lt;ul>
&lt;li>여러 방법으로 데이터를 저장하고 조회하고 검색하고 처리하게끔 허용하는 작업과 같이 해야하는 일&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비기능적 요구사항
&lt;ul>
&lt;li>보안, 신뢰성, 법규 준수, 확장성, 호환성, 유지보수성과 같은 일반 속성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이번 장에서는 신뢰성, 확장성, 유지보수성을 자세히 살폈다.&lt;/p>
&lt;ul>
&lt;li>신뢰성
&lt;ul>
&lt;li>결함이 발생해도 시스템이 올바르게 동작하게 만든다는 의미&lt;/li>
&lt;li>결함은 하드웨어와 소프트웨어 버그와 사람에게 있을 수 있음&lt;/li>
&lt;li>내결함성 기술은 최종 사용자에게 특정 유형의 결함을 숨길 수 있게 해준다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장성
&lt;ul>
&lt;li>부하가 증가해도 좋은 성능을 유지하기 위한 전략&lt;/li>
&lt;li>확장성을 설명하기 위해 양적으로 부하와 성능을 설명하는 방법이 필요함&lt;/li>
&lt;li>확장 가능한 시스템에서는 부하가 높은 상태에서 신뢰성을 유지하기 위해 처리 용량을 추가할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유지보수성
&lt;ul>
&lt;li>본질은 시스템에서 작업하는 엔지니어와 운영 팀의 삶을 개선하는 데 있음&lt;/li>
&lt;li>좋은 추상화는 복잡도를 줄이고 쉽게 시스템을 변경할 수 있게하며 새로운 사용 사례에 적용하는 데 도움이됨&lt;/li>
&lt;li>좋은 운용성이란 시스템의 건강 상태를 잘 관찰할 수 있고 시스템을 효율적으로 관리하는 방법을 보유한다는 의미&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>애플리케이션을 신뢰할 수 있고 확장 가능하며 유지보수하기 쉽게 만들어주는 간단한 해결책은 없다.&lt;/p>
&lt;p>하지만 여러 애플리케이션에서 계속 재현되는 특정 패턴과 기술이 있으며, 데이터 시스템 몇 가지를 예제로 살펴보고 이런 목표를 향해 데이터 시스템이 어떻게 작동하는지 분석한다.&lt;/p></description></item><item><title>13. 증권 거래소</title><link>https://codemario318.github.io/post/system-design-interview-2/13/</link><pubDate>Sun, 15 Dec 2024 14:38:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/13/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/cover.png" alt="Featured image of post 13. 증권 거래소" />&lt;p>이번 장에서는 &lt;strong>온라인 증권 거래 시스템&lt;/strong>을 설계해본다.&lt;/p>
&lt;p>&lt;strong>거래소의 기본 기능&lt;/strong>은 구매자와 판매자가 효율적으로 연결될 수 있도록 돕는 것이다.&lt;/p>
&lt;p>컴퓨터가 이 연결 과정을 자동으로 처리할 수 있게 되면서, 거래 지형을 크게 변화시켰고, 온라인에서 전자적으로 처리되는 거래량은 기하급수적으로 증가하고 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img.png"
width="2006"
height="962"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_hua12cbb62087db12f2c1823c9c4896b7f_955694_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_hua12cbb62087db12f2c1823c9c4896b7f_955694_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="가장 큰 증권 거래소"
class="gallery-image"
data-flex-grow="208"
data-flex-basis="500px"
>&lt;/p>
&lt;p>증권 거래소에는 뉴욕 증권 거래소(NYSE)나 나스닥 외에도 여러 유형의 거래소가 있다.&lt;/p>
&lt;ul>
&lt;li>금융 산업의 수직적 세분화에 초점을 맞추고 기술적 측면을 강조하는 유형&lt;/li>
&lt;li>공정성에 중점을 두는 유형&lt;/li>
&lt;/ul>
&lt;p>따라서 면접관에게 질문을 던져 거래소 규모 등 중요 특징을 먼저 확인해야한다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>현대적은 증권 거래소는 &lt;strong>지연시간&lt;/strong>, &lt;strong>처리량&lt;/strong>, &lt;strong>안정성&lt;/strong>에 대한 요구사항이 엄격한 아주 복잡한 시스템이다.&lt;/p>
&lt;ul>
&lt;li>간단하게 주식만 거래&lt;/li>
&lt;li>새 주문을 넣을 수 있음&lt;/li>
&lt;li>체결되지 않은 주문은 취소할 수도 있음&lt;/li>
&lt;li>주문 유형은 지정가 주문만 가능&lt;/li>
&lt;li>시갠 외 거래 지원 안함&lt;/li>
&lt;li>새로운 지정가 주문 접수&lt;/li>
&lt;li>기존 주문 취소&lt;/li>
&lt;li>주문이 체결된 경우 실시간으로 그 사실을 알 수 있어야함&lt;/li>
&lt;li>호가창(매수 및 매도 주문 목록 표시)&lt;/li>
&lt;li>최소 수만 명 사용자가 동시에 거래할 수 있어야 함&lt;/li>
&lt;li>최소 100가지 주식 거래가 가능해야함&lt;/li>
&lt;li>하루에 수십억 거느이 주문이 발생할 수 있음&lt;/li>
&lt;li>규제 시설이므로 위험성 점검이 가능해야함&lt;/li>
&lt;li>위험성 점검
&lt;ul>
&lt;li>한 사용자가 하루에 거래할 수 있는 주식을 제한 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>거래 전 충분한 자금이 있는지 먼저 확인해야함&lt;/li>
&lt;li>아직 체결되지 않은 주문이 있는 경우 해당 주문에 이용된 자금은 다른 주문에 쓰일 수 없음&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;p>최소 100가지 주식, 수만 명 사용자같은 요구사항은 소규모에서 중간 규모 정도의 거래소를 설계해야 한다는 뜻이다.&lt;/p>
&lt;p>많은 면접관이 후속 질문 과정에서 설계의 확장성을 확인하는 데 초점을 맞추므로 더 많은 주식과 사용자를 지원할 수 있게 확장 가능한 설계인지도 확인이 필요하다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>가용성&lt;/strong>: 최소 99.99%
&lt;ul>
&lt;li>거래소의 가용성은 매우 중요한 문제다. 단 몇초의 장애로도 평판이 크게 손상될 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>결함 내성&lt;/strong>:
&lt;ul>
&lt;li>프로덕션 장애의 파급을 줄이려면 결함 내성과 빠른 복구 매커니즘이 필요하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>지연 시간&lt;/strong>:
&lt;ul>
&lt;li>왕복 지연 시간은 &lt;strong>밀리초&lt;/strong> 수준이어야 하며, 특히 &lt;strong>p99&lt;/strong> 지연 시간이 중요하다.&lt;/li>
&lt;li>p99 지연 시간이 계속 높으면 일부 사용자의 거래소 이용 경험이 아주 나빠진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>보안&lt;/strong>: 거래소는 계정 관리 시스템을 갖추어야 한다.
&lt;ul>
&lt;li>법률 및 규정 준수를 위해 거래소는 새 계좌 개설 전 사용자의 신원 확인을 위한 KYC(Know Your Client) 확인을 수행한다.&lt;/li>
&lt;li>시장 데이터가 포함된 웹 페이지 등의 공개 자원의 경우 DDoS 공격을 방지하는 장치를 구비해두어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;p>간단한 계산을 통해 개략적인 규모를 추정해보자.&lt;/p>
&lt;ul>
&lt;li>100가지 주식&lt;/li>
&lt;li>하루 10억 건의 주문&lt;/li>
&lt;li>월요일 부터 금요일 까지, 오전 9시 30분부터 오후 4시까지 영업(총 6.5 시간)&lt;/li>
&lt;li>&lt;code>QPS = 10억 / 6.5시간 * 3600 =~ 43,000&lt;/code>&lt;/li>
&lt;li>&lt;code>최대 QPS = 5 * OPS = 215,000&lt;/code>
&lt;ul>
&lt;li>거래량은 장 시작 직후, 그리고 장 마감 직전에 훨씬 높다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>설계안을 살펴보기 전, 거래소 설계에 도움이 될 몇 가지 기본 개념과 용어를 살펴본다.&lt;/p>
&lt;h3 id="증권-거래-101">증권 거래 101&lt;/h3>
&lt;p>&lt;strong>브로커&lt;/strong>&lt;/p>
&lt;p>대부분의 개인 고객은 &lt;strong>브로커 시스템&lt;/strong>을 통해 거래소와 거래한다.&lt;/p>
&lt;ul>
&lt;li>ex) 찰스 슈왑(Charles Schwab), 로빈후드(Robinhood), E*Trade, 피델리티(Fidelity)&lt;/li>
&lt;/ul>
&lt;p>브로커 시스템은 개인 사용자가 증권을 거래하고 시장 데이터르 확인할 수 있도록 &lt;strong>편리한 사용자 인터페이스를 제공&lt;/strong>한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>기관 고객&lt;/strong>&lt;/p>
&lt;p>기관 고객(institutional client)은 전문 증권 거래 소프트웨어를 사용하여 대량으로 거래한다.&lt;/p>
&lt;p>기관 고객마다 거래 시스템에 대한 요구사항은 다르다.&lt;/p>
&lt;ul>
&lt;li>연기금(pension funds): 안정적인 수익을 목표로 하므로 거래 빈도는 낮지만 거래량은 많음
&lt;ul>
&lt;li>대규모 주문이 시장에 미치는 영향을 최소화하기 위해 &lt;strong>주문 분할&lt;/strong> 같은 기능을 필요로 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>헤지 펀드(hedge funds): 시장 조성을 전문으로 하며 수수료 리베이트를 통해 수익을 얻기 때문에 아주 낮은 응답 시간으로 거래하길 원함&lt;/li>
&lt;/ul>
&lt;p>일반 사용자처럼 웹페이지나 모바일 앱에서 시장 데이터를 확인하게 하면 곤란하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>지정가 주문&lt;/strong>&lt;/p>
&lt;p>지정가 주문(limit order)은 가격이 고정된 매수 또는 매도 주문이다.&lt;/p>
&lt;p>시장가 주문과는 달리 체결이 즉시 이루어지지 않을 수 있고, 부분적으로만 체결될 수도 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>시장가 주문&lt;/strong>&lt;/p>
&lt;p>시장가 주문(market order)은 가격을 지정하지 않는 주문으로, 시장가로 &lt;strong>즉시 체결&lt;/strong>된다.&lt;/p>
&lt;p>체결은 보장되나 비용 면에서는 손해를 볼 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>시장 데이터 수준&lt;/strong>&lt;/p>
&lt;p>미국 주식시장에서는 L1, L2, L3 세 가지 가격 정보(price quote) 등급이 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_1.png"
width="690"
height="462"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_1_hu79e11fd5b59fab294184109fcc47232d_21980_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_1_hu79e11fd5b59fab294184109fcc47232d_21980_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="L1"
class="gallery-image"
data-flex-grow="149"
data-flex-basis="358px"
>
&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_2.png"
width="976"
height="942"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_2_hue6340395d4b10cea5f47001c4bb4206a_71410_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_2_hue6340395d4b10cea5f47001c4bb4206a_71410_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="L2"
class="gallery-image"
data-flex-grow="103"
data-flex-basis="248px"
>
&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_3.png"
width="1336"
height="888"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_3_huecf63f0fdec090c8ba367978d66e2441_90763_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_3_huecf63f0fdec090c8ba367978d66e2441_90763_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="L3"
class="gallery-image"
data-flex-grow="150"
data-flex-basis="361px"
>&lt;/p>
&lt;ul>
&lt;li>L1: 최고 배호 호가(best bid price), 매도 호가(ask price) 및 수량(quantity)이 포함&lt;/li>
&lt;li>L2: L1에 더해 체결을 기다리는 물량의 호가를 보여줌, 어디 까지 보여줄 지를 의미하는 깊이(depth) 포함&lt;/li>
&lt;li>L3: 각 주문 가격에 체결을 기다리는 물량 정보까지 보여줌&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>봉 차트&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_4.png"
width="774"
height="670"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_4_hub24b60d213a945c93dc2e4cb5317d10c_27591_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_4_hub24b60d213a945c93dc2e4cb5317d10c_27591_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="캔들 차트"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="277px"
>&lt;/p>
&lt;p>특정 기간 동안의 주가로 하나의 봉 막대로 일정 시간 간격 동안 시장의 시작가, 종가, 최고가, 최저가를 표시할 수 있다.&lt;/p>
&lt;ul>
&lt;li>일반적으로 1분, 5분, 1시간, 1일, 1주일, 1개월 단위로 지원한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>FIX&lt;/strong>&lt;/p>
&lt;p>Financial Information Exchange Protocol(금융 정보 교환 프로토콜)의 약어로 증권 거래 정보 교환을 위한 기업 중립적 통신 프로토콜이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">8=FIX.4.2 | 9=176 | 35=8 | 49=PHLX | 56=PERS | 52=20071123-05:30:00.000 | 11=ATOMNOCCC9990900 | 20=3 | 150=E | 39=E | 55=MSFT | 167=CS | 54=1 | 38=15 | 40=2 | 44=15 | 58=PHLX EQUITY TESTING | 59=0 | 47=C | 32=0 | 31=0 | 151=15 | 14=0 | 6=0 | 10=128 |
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_5.png"
width="2000"
height="1088"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_5_hua0dff483c606d0768bb9e0948c938a18_293456_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_5_hua0dff483c606d0768bb9e0948c938a18_293456_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="441px"
>&lt;/p>
&lt;p>&lt;strong>거래 흐름&lt;/strong>&lt;/p>
&lt;p>거래 흐름(trading flow)을 통해 하나의 주문이 어떤 절차로 처리되는지 살펴본다.&lt;/p>
&lt;p>지연 시간 요건이 엄격한, 중요 경로(critical path)로 이 경로를 따라 흐르는 모든 정보는 신속하게 처리되어야 한다.&lt;/p>
&lt;ul>
&lt;li>1단계: 고객이 브로커의 웹 또는 모바일 앱을 통해 주문&lt;/li>
&lt;li>2단계: 브로커가 주문을 거래소에 전송&lt;/li>
&lt;li>3단계: 주문이 클라이언트 게이트웨이를 통해 거래소로 들어감
&lt;ul>
&lt;li>클라이언트 게이트웨이는 입력 유효성 검사, 속도 제한, 인증, 정규화 등과 같은 기본적인 게이트키핑 기능을 수행&lt;/li>
&lt;li>그 후 주문을 주문 관리자에게 전달&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>4~5단계: 주문 관리자가 위험 관리자가 설정한 규칙에 다라 위험성 점검을 수행&lt;/li>
&lt;li>6단계: 통과한 주문에 대해 지갑에 주문 처리 자금으 충분한지 확인&lt;/li>
&lt;li>7~9단계: 주문이 체결 엔진으로 전송
&lt;ul>
&lt;li>체결 가능 주문이 발견되면 매수 측과 매도 측에 각각 하나씩 &lt;strong>두 개의 집행(execution, fill(충족)이라고도 함) 기록 생성&lt;/strong>&lt;/li>
&lt;li>그 과정을 재생할 때 항상 결정론적으로 동일한 결과가 나오도록 보장하기 위해 시퀀서는 &lt;strong>주문 및 집행 기록을 일정 순서로 정렬&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>10~14단계: 주문 집행 사실을 클라이언트에 전송&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>시장 데이터 흐름&lt;/strong>&lt;/p>
&lt;p>시장 데이터 흐름(market data flow)을 따라서 하나의 주문이 체결 엔진부터 데이터 서비스를 거쳐 브로커로 전달되어 집행되기까지의 과정을 추적해본다.&lt;/p>
&lt;ul>
&lt;li>M1 단계: 체결 엔진은 주문이 체결되면 집행 기록 스트림(또는 충족 기록 스트림)을 만든다.
&lt;ul>
&lt;li>시장 데이터 게시 서비스로 전송된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>M2 단계: 시장 데이터 게시 서비스는 집행 기록 및 주문 스트림에서 얻은 데이터를 시장 데이터로 사용하여 봉 차트와 호가 창을 구성한다.
&lt;ul>
&lt;li>시장 데이터를 데이터 서비스로 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>M3 단계: 실시간 분석 전용 스토리지에 저장된다.
&lt;ul>
&lt;li>브로커는 데이터 서버스를 통해 실시간 시장 데이터를 읽는다.&lt;/li>
&lt;li>읽은 데이터를 고객에게 전달한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>보고 흐름&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>R1 ~ R2 단계: 보고 서비스(reporter)는 주문 및 실행 기록에서 보고에 필요한 모든 필드의 값을 모은다음 그 값을 종합해 만든 레코드를 데이터베이스에 기록한다.
&lt;ul>
&lt;li>ex) &lt;code>client_id&lt;/code>, &lt;code>price&lt;/code>, &lt;code>quantity&lt;/code>, &lt;code>order_type&lt;/code>, &lt;code>filled_quantity&lt;/code>, &lt;code>remaining_quantity&lt;/code> 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>거래 흐름&lt;/strong>은 &lt;strong>중요 경로&lt;/strong>를 따라 진행되지만 &lt;strong>시장 데이터 흐름&lt;/strong>이나 &lt;strong>보고 흐름&lt;/strong>은 지연 시간 요구사항이 다르다.&lt;/p>
&lt;h4 id="거래-흐름">거래 흐름&lt;/h4>
&lt;p>거래 흐름은 거래소의 중요 경로상에서 진행된다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>체결 엔진&lt;/strong>&lt;/p>
&lt;p>체결 엔진(matching engine)은 교차 엔진(cross engine)이라고도 부르며, 주요 역할은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>각 주식 심벌에 대한 주문서(order book) 내지 호가 창을 유지 관리
&lt;ul>
&lt;li>특정 주식에 대한 매수 및 매도 주문 목록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>매수 주문과 매도 주문을 연결
&lt;ul>
&lt;li>주문 체결 결과로 두 개의 집행 기록이 만들어짐(매수 1, 매도 1)&lt;/li>
&lt;li>체결은 빠르고 신속하게 처리되어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>집행 기록 스트림을 시장 데이터로 배포&lt;/li>
&lt;/ul>
&lt;p>가용성 높은 체결 엔진 구현체가 만드는 체결 순서는 &lt;strong>결정론적&lt;/strong>(deterministic)이어야 한다.&lt;/p>
&lt;ul>
&lt;li>입력으로 주어지는 주문 순서가 같으면 체결 엔진이 만드는 집행 기록 순서는 언제나 동일해야 함&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>시퀀서&lt;/strong>&lt;/p>
&lt;p>시퀀서(sequencer)는 &lt;strong>체결 엔진을 결정론적으로 만드는 핵심 구성 요소&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>주문을 전달하기 전 순서 ID를 붙여 보냄&lt;/li>
&lt;li>처리를 끝낸 모든 집행 기록 쌍에도 순서 ID를 붙임&lt;/li>
&lt;/ul>
&lt;p>즉 &lt;strong>입력 시퀀서&lt;/strong>와 &lt;strong>출력 시퀀서&lt;/strong> 두 가지가 각각 고유한 순서를 유지하며, 시퀀서가 만드는 순서 ID는 누락된 항목을 쉽게 발견할 수 있는 일련번호여야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_6.png"
width="1388"
height="436"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_6_hu1f5837d14860a1ca9f171403ac6a9e47_27154_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_6_hu1f5837d14860a1ca9f171403ac6a9e47_27154_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="입력 및 출력 시퀀서"
class="gallery-image"
data-flex-grow="318"
data-flex-basis="764px"
>&lt;/p>
&lt;p>입력되는 주문과 출력하는 실행 명령에 순서 ID를 직는 이유는 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>시의성(timeliness) 및 공정성(fairness)&lt;/li>
&lt;li>빠른 복구(recovery) 및 재생(replay)&lt;/li>
&lt;li>정확한 1회 실행 보증(exactly-once guarantee)&lt;/li>
&lt;/ul>
&lt;p>시퀀서는 순서 ID만 생성하는 것이 아닌 메시지 큐 역할도 한다.&lt;/p>
&lt;ul>
&lt;li>체결 엔진에 메시지(수신 주문)를 보내는 큐&lt;/li>
&lt;li>주문 관리자에게 메시지(집행 기록)를 회신하는 큐&lt;/li>
&lt;/ul>
&lt;p>주문과 집행 기록을 위한 이벤트 저장소로 볼 수도 있다.&lt;/p>
&lt;ul>
&lt;li>체결 엔진에 두 개 카프카 이벤트 스트림이 연겨로디어 있는 것과 비슷함&lt;/li>
&lt;li>입력되는 주문용, 출력될 집행 기록용&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>주문 관리자&lt;/strong>&lt;/p>
&lt;p>주문 관리자(order manager)는 한쪽에서 주문을 받고 다른 쪽에서는 집행 기록을 받아 주문 상태를 관리하는 것이 역할이다.&lt;/p>
&lt;p>주문 관리자는 클라이언트 게이트웨이를 통해 주문을 수신하고 다음을 실행한다.&lt;/p>
&lt;ul>
&lt;li>위험성 검토
&lt;ul>
&lt;li>ex) 사용자의 거래량이 하루 100만 달라 미만인지?&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>충분한 자금이 있는지 확인&lt;/li>
&lt;li>주문을 시퀀서에 전달
&lt;ul>
&lt;li>해당 주문에 순서 ID를 찍고 체결 엔진에 보내어 처리함&lt;/li>
&lt;li>메시지 크기를 줄이기 위해 많은 속성 중 필요한 속성만 전송&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>주문 관리자는 시퀀서를 통해 체결 엔진으로 부터 집행 기록도 받는데, &lt;strong>체결된 주문에 대한 집행 기록을 클라이언트 게이트웨이를 통해 브로커에 반환&lt;/strong>한다.&lt;/p>
&lt;p>주문 관리자는 &lt;strong>빠르고 효율적이며 정확&lt;/strong>해야 한다.&lt;/p>
&lt;ul>
&lt;li>주문 관리자는 주문의 현재 상태를 유지관리 해야하므로 다양한 상태 변화를 관리해야하는 문제 때문에 구현이 아주 복잡하다.&lt;/li>
&lt;li>이벤트 소싱은 주문 관리자 설계에 적함하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>클라이언트 게이트웨이&lt;/strong>&lt;/p>
&lt;p>거래소의 문지기 역할로 클라이언트로부터 주문을 받아 주문 관리자에게 보낸다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_7.png"
width="810"
height="494"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_7_hu9f0e994eaa77d0bdc9834466b41130f2_24083_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_7_hu9f0e994eaa77d0bdc9834466b41130f2_24083_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클라이언트 게이트웨이 구성 요소"
class="gallery-image"
data-flex-grow="163"
data-flex-basis="393px"
>&lt;/p>
&lt;p>클라이언트 게이트웨이는 중요 경로상에 놓이므로 지연 시간에 중요한 기능들을 신속하게 처리하여 가능한 한 빨리 올바른 목적지로 주문을 전달해야 한다.&lt;/p>
&lt;p>따라서 어떤 기능을 클라이언트 게이트웨이에 넣을지 말지는 타협적으로 생각해야한다.&lt;/p>
&lt;ul>
&lt;li>복잡한 기능이라면 체결 엔진이나 위험 점검 컴포넌트에 맡겨야 한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_8.png"
width="1370"
height="722"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_8_hub136b33b44c3c07169b00aac52793dd6_55338_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_8_hub136b33b44c3c07169b00aac52793dd6_55338_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클라이언트 게이트웨이"
class="gallery-image"
data-flex-grow="189"
data-flex-basis="455px"
>&lt;/p>
&lt;p>고객 유형별(개인/기업)로 지연 시간, 거래량, 보안 요구사항 등 고려사항이 다르므로 클라이언트 게이트웨이도 다양해질 수 있다.&lt;/p>
&lt;ul>
&lt;li>ex) 시장 조성자(market maker)는 거래소에 유동성의 상당 부분을 공급하므로 매우 낮은 지연 시간을 요구한다.&lt;/li>
&lt;/ul>
&lt;p>극단적인 사례인 코로케이션(colocation, colo) 엔진은 브로커가 거래소 데이터 센터에서 임대한 서버 일부에서 실행하는 거래 엔진 소프트웨어로 지연시간이 빛의 속도 정도이다.&lt;/p>
&lt;h4 id="시장-데이터-흐름">&lt;strong>시장 데이터 흐름&lt;/strong>&lt;/h4>
&lt;p>시장 데이터 게시 서비스(Market Data Publisher, MDP)는 체결 엔진에서 집행 기록을 수신하고 집행 기록 스트림에서 호가 창과 봉 차트를 만들어 낸다.&lt;/p>
&lt;ul>
&lt;li>호가 창과 봉 차트를 통칭하여 시장 데이터라고 한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_9.png"
width="1370"
height="908"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_9_hu53e382f4244b649b51d5ee7afb86a55c_47156_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_9_hu53e382f4244b649b51d5ee7afb86a55c_47156_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="시장 데이터 게시 서비스"
class="gallery-image"
data-flex-grow="150"
data-flex-basis="362px"
>&lt;/p>
&lt;p>시장 데이터는 데이터 서비스로 전송되어 해당 서비스의 구독자가 사용할 수 있게 된다.&lt;/p>
&lt;h4 id="보고-흐름">&lt;strong>보고 흐름&lt;/strong>&lt;/h4>
&lt;p>거래소에서 필수적인 부분 가운데 하나로, 보고 서비스는 거래의 중요 경로상에 있지는 않지만 여전히 시스템의 중요한 부분이다.&lt;/p>
&lt;ul>
&lt;li>거래 이력, 세금 보고, 규정 준수 여부 보고, 결산(settlement) 등의 기능 제공&lt;/li>
&lt;/ul>
&lt;p>거래 흐름과 달리 보고 서비스는 정확성과 규정 준수가 핵심적이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_10.png"
width="1380"
height="1466"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_10_hu48df8990762216930068bee2adfb4f4a_76277_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_10_hu48df8990762216930068bee2adfb4f4a_76277_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="리포터"
class="gallery-image"
data-flex-grow="94"
data-flex-basis="225px"
>&lt;/p>
&lt;p>입력으로 들어오는 주문과 그 결과로 나가는 집행 기록 모두에서 정보를 모아 속성(attributes)를 구성하는 것이 일반적 관행이다.&lt;/p>
&lt;ul>
&lt;li>새 주문은 주문 세부 정보만 포함&lt;/li>
&lt;li>집행 기록에는 주문 ID, 가격, 수량 및 집행 상태 정보만 포함&lt;/li>
&lt;/ul>
&lt;p>보고 서비스는 두 가지 출처에서 오는 정보를 잘 병합하여 보고서를 만든다.&lt;/p>
&lt;h3 id="api-설계">API 설계&lt;/h3>
&lt;p>고객은 브로커를 통해 증권 거래소와 상호 작용하여 &lt;strong>주문&lt;/strong>, &lt;strong>체결 조회&lt;/strong>, &lt;strong>시장 데이터 조회&lt;/strong>, 분석을 위한 &lt;strong>과거 데이터 다운로드&lt;/strong> 등을 수행한다.&lt;/p>
&lt;p>브로커와 클라이언트 게이트웨이 간의 인터페이스 명세 작성에는 RESTful 컨벤션을 사용한다.&lt;/p>
&lt;ul>
&lt;li>RESTful API로는 지연 시간 요구사항을 충족하지 못할 수도 있어 다른 프로토콜을 사용할 가능성이 높지만, 어떤 프로토콜도 아래 언급한 기본 기능은 동일하게 제공되어야 한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>주문&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-http" data-lang="http">&lt;span class="line">&lt;span class="cl">&lt;span class="err">POST /v1/order
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>주문을 처리하며, 인증이 필요하다.&lt;/p>
&lt;ul>
&lt;li>인자
&lt;ul>
&lt;li>&lt;code>symbol&lt;/code>: 주식을 나타내는 심볼&lt;/li>
&lt;li>&lt;code>side&lt;/code>: 매수 또는 매도&lt;/li>
&lt;li>&lt;code>price&lt;/code>: 지정가 주문 가격&lt;/li>
&lt;li>&lt;code>orderType&lt;/code>: 지정가 또는 시장가&lt;/li>
&lt;li>&lt;code>quantity&lt;/code>: 주문 수량&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>&lt;code>id&lt;/code>: 주문 ID&lt;/li>
&lt;li>&lt;code>creationTime&lt;/code>: 주문이 시스템에 생성된 시간&lt;/li>
&lt;li>&lt;code>filledQuantity&lt;/code>: 집행이 완료된 수량&lt;/li>
&lt;li>&lt;code>remainingQuantity&lt;/code>: 아직 체결되지 않은 주문 수량&lt;/li>
&lt;li>&lt;code>status&lt;/code>: new/canceled/filled&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>코드
&lt;ul>
&lt;li>&lt;code>200&lt;/code>: 성공&lt;/li>
&lt;li>&lt;code>40x&lt;/code>: 인자 오류/접근 불가/권한 없음&lt;/li>
&lt;li>&lt;code>500&lt;/code>: 서버 오류&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>집행&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-http" data-lang="http">&lt;span class="line">&lt;span class="cl">&lt;span class="err">GET /v1/execution?symbol={:symbol}&amp;amp;orderId={:orderId}&amp;amp;startTime={:startTime}&amp;amp;endTime={:endTime}
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>집행 정보를 질의하며 인증이 필요하다.&lt;/p>
&lt;ul>
&lt;li>인자
&lt;ul>
&lt;li>&lt;code>symbol&lt;/code>: 주식 심볼&lt;/li>
&lt;li>&lt;code>orderId&lt;/code>: 주문 ID(optional)&lt;/li>
&lt;li>&lt;code>startTime&lt;/code>: 질의 시작 시간&lt;/li>
&lt;li>&lt;code>endTime&lt;/code>: 질의 종료 시간&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답 본문
&lt;ul>
&lt;li>&lt;code>executions&lt;/code>: 범위 내의 모든 집행 기록 배열&lt;/li>
&lt;li>&lt;code>id&lt;/code>: 집행 기록&lt;/li>
&lt;li>&lt;code>orderId&lt;/code>: 주문 ID&lt;/li>
&lt;li>&lt;code>symbol&lt;/code>: 주식 심볼&lt;/li>
&lt;li>&lt;code>side&lt;/code>: 매수 혹은 매도&lt;/li>
&lt;li>&lt;code>price&lt;/code>: 체결 가격&lt;/li>
&lt;li>&lt;code>orderType&lt;/code>: 지정가 도는 시장가&lt;/li>
&lt;li>&lt;code>quantity&lt;/code>: 체결 수량&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답 코드
&lt;ul>
&lt;li>&lt;code>200&lt;/code>: 성공&lt;/li>
&lt;li>&lt;code>40x&lt;/code>: 인자 오류/해당 자원 없음/접근 불가/권한 없음&lt;/li>
&lt;li>&lt;code>500&lt;/code>: 서버 오류&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>가격 변동 이력(캔들 차트)&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-http" data-lang="http">&lt;span class="line">&lt;span class="cl">&lt;span class="err">GET /marketdata/candles?symbol={:symbol}&amp;amp;resolution={:resolution}&amp;amp;startTime={:startTime}&amp;amp;endTime={:endTime}
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>주어진 시간 범위, 해상도(resolution), 심볼에 대한 봉 차트 데이터 질의 결과를 반환&lt;/p>
&lt;ul>
&lt;li>인자
&lt;ul>
&lt;li>&lt;code>symbol&lt;/code>: 심볼&lt;/li>
&lt;li>&lt;code>resolution&lt;/code>: 윈도 길이&lt;/li>
&lt;li>&lt;code>startTime&lt;/code>: 질의 시작 시간&lt;/li>
&lt;li>&lt;code>endTime&lt;/code>: 질의 종료 시간&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답 본문
&lt;ul>
&lt;li>&lt;code>candles&lt;/code>: 각 봉의 데이터를 담은 배열&lt;/li>
&lt;li>&lt;code>open&lt;/code>: 해당 봉의 시가&lt;/li>
&lt;li>&lt;code>close&lt;/code>: 해당 봉의 종가&lt;/li>
&lt;li>&lt;code>high&lt;/code>: 해당 봉의 고가&lt;/li>
&lt;li>&lt;code>low&lt;/code>: 해당 봉의 저가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답 코드
&lt;ul>
&lt;li>&lt;code>200&lt;/code>: 성공&lt;/li>
&lt;li>&lt;code>40x&lt;/code>: 인자 오류/해당 자원 없음/접근 불가/권한 없음&lt;/li>
&lt;li>&lt;code>500&lt;/code>: 서버 오류&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>증권 거래소에는 세 가지 유형의 주요 데이터가 있다.&lt;/p>
&lt;h4 id="상품-주문-집행">상품, 주문, 집행&lt;/h4>
&lt;p>&lt;strong>상품&lt;/strong>&lt;br>
상품(product)은 거래 대상 주식(심벌)이 가진 속성으로 정의된다.&lt;/p>
&lt;ul>
&lt;li>상품의 유형, 거래에 쓰이는 심벌, UI에 표시될 심벌, 결산에 이용되는 통화 단위, 매매 수량 단위(lot size), 호가 가격 단위(tick size) 등&lt;/li>
&lt;/ul>
&lt;p>자주 변경되지 않고 주로 UI 표시를 위한 데이터이므로, 아무 데이터베이스에나 저장 가능하며, 캐시를 적용하기에도 좋다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>주문, 집행&lt;/strong>&lt;/p>
&lt;p>주문은 매수 또는 매도를 실행하라는 명령이며, 집행 기록은 체결이 이루어진 결과이다.&lt;/p>
&lt;ul>
&lt;li>집행 기록은 충족(fill)이라고도 부름&lt;/li>
&lt;/ul>
&lt;p>모든 주문이 집행되지는 않으며, 체결 엔진은 하나의 주문 체결에 관여한 매수 행위와 매도 행위를 나타내는 두 개의 집행 기록을 결과로 출력한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_11.png"
width="1354"
height="1560"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_11_hu7ef07b79c0f44bf30575e29381b0608d_316941_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_11_hu7ef07b79c0f44bf30575e29381b0608d_316941_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="상품, 주문, 집행"
class="gallery-image"
data-flex-grow="86"
data-flex-basis="208px"
>&lt;/p>
&lt;p>주문과 집행 기록은 &lt;strong>거래소가 취급하는 가장 중요한 데이터&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>중요 거래 경로는 주문 과 집행 기록을 데이터베이스에 저장하지 않는다.
&lt;ul>
&lt;li>성능을 높이기 위해 메모리에서 거래를 체결하고 하드디스크다 공유 메모리를 활용하여 주문과 집행 기록을 저장하고 공유한다.&lt;/li>
&lt;li>빠른 복구를 위해 시퀀서에 저장하며, 데이터 보관은 장 마감 후에 실행한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>보고 서비스는 조정이나 세금 보고 등을 위해 데이터베이스에 주문 및 집행 기록을 저장한다.&lt;/li>
&lt;li>집행 기록은 시장 데이터 프로세서로 전달되어 호가 창/주문서와 봉 차트 데이터 재고성에 쓰인다.&lt;/li>
&lt;/ul>
&lt;h4 id="호가-창">호가 창&lt;/h4>
&lt;p>호가 창은 &lt;strong>특정 증권 또는 금융 상품에 대한 매수 및 매도 주문 목록&lt;/strong>으로, 가격 수준별로 정리되어 있다.&lt;/p>
&lt;p>체결 엔진이 빠른 주문 체결을 위해 사용하는 핵심 자료구조로, 다음 요구사항을 만족할 수 있는 효율성이 높은 것 이어야한다.&lt;/p>
&lt;ul>
&lt;li>일정한 조회 시간:
&lt;ul>
&lt;li>특정 가격 수준의 주문량 조회&lt;/li>
&lt;li>특정 가격 범위 내의 주문량 조회 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>빠른 추가/취소/실행 속도: 가급적 &lt;code>O(1)&lt;/code> 시간 복잡도를 만족해야 한다.
&lt;ul>
&lt;li>새 주문 넣기, 기존 주문 취소하기, 주문 체결하기 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>빠른 업데이트:
&lt;ul>
&lt;li>주문 교체 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>최고 매수 호가/최저 매수 호가 질의&lt;/li>
&lt;li>가격 수준 순회(iteration)&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_12.png"
width="1434"
height="1042"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_12_hu909048187ea6cbd0e5682ba52c5069f4_139223_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_12_hu909048187ea6cbd0e5682ba52c5069f4_139223_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="지정가 주문 호가 창"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="330px"
>&lt;/p>
&lt;p>예제에서 최저 매도 호가 큐의 모든 매도 주문과 체결된 후에 호가 100.11 큐의 첫 번째 매도 주문과 체결되며 거래가 끝난다.&lt;/p>
&lt;p>이 결과로 매수/매도 호가 스프레드 간의 가격 차이가 넓어지고 주식 가격은 한 단계 상승하게된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">class PriceLevel{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private Price limitPrice;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private long totalVolume;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private List&amp;lt;Order&amp;gt; orders;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">class Book&amp;lt;Side&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private Side side;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private Map&amp;lt;Price, PriceLevel&amp;gt; limitMap;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">class OrderBook {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private Book&amp;lt;Buy&amp;gt; buyBook;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private Book&amp;lt;Sell&amp;gt; sellBook;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private PriceLevel bestBid;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private PriceLevel bestOffer;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private Map&amp;lt;OrderID, Order&amp;gt; orderMap;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>일반 연결 리스트를 사용하고 있으므로 모든 설계 요구사항을 만족할 수 없다.&lt;/p>
&lt;ul>
&lt;li>ex) 지정가 주문 추가/취소는 &lt;code>O(1)&lt;/code>이 아님&lt;/li>
&lt;/ul>
&lt;p>보다 효율적인 호가 창을 만들려면 &lt;code>orders&lt;/code>의 자료 구조는 &lt;strong>이중 연결 리스트&lt;/strong>로 변경하여 모든 삭제 연산(주문 취소나 체결 처리 등)이 &lt;code>O(1)&lt;/code>에 처리되도록 해야한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_13.png"
width="1752"
height="1444"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_13_hub19aed728312c3e2f4b107dce3af3598_175620_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_13_hub19aed728312c3e2f4b107dce3af3598_175620_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="O(1)로 주문 체결 및 추소 연산 실행"
class="gallery-image"
data-flex-grow="121"
data-flex-basis="291px"
>&lt;/p>
&lt;ul>
&lt;li>새 주문은 &lt;code>PriceLevel&lt;/code> 리스트 마지막에 새 &lt;code>Order&lt;/code> 추가를 의미(&lt;code>O(1)&lt;/code>)&lt;/li>
&lt;li>주문 체결은 &lt;code>PriceLevel&lt;/code> 리스트 맨 앞에 &lt;code>Order&lt;/code> 삭제를 의미(&lt;code>O(1)&lt;/code>)&lt;/li>
&lt;li>주문 취소는 &lt;code>OrderBook&lt;/code>에서 &lt;code>Order&lt;/code> 삭제를 의미(&lt;code>O(1)&lt;/code>)
&lt;ul>
&lt;li>&lt;code>OrderBook&lt;/code> 내의 핼퍼 자료 구조 &lt;code>Map&amp;lt;OrderID, Order&amp;gt; orderMap&lt;/code>을 활용하면 &lt;code>O(1)&lt;/code> 시간으로 취소할 주문을 찾을 수 있음&lt;/li>
&lt;li>이중 연결 리스트이므로 &lt;code>Order&lt;/code>의 이전 주문을 가르키는 포인터가 있으므로 전체 주문 목록을 순회하지 않고 주문을 삭제할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>호가 창 자료 구조는 집행 기록 스트림에서 L1, L2, L3 데이터를 재구성 하기 위해 시장 데이터 프로세서도 많이 사용하게된다.&lt;/p>
&lt;h4 id="봉-차트">봉 차트&lt;/h4>
&lt;p>봉 차트는 시장 데이터 프로세서가 시장 데이터를 만들 때 호가 창과 더불어 사용하는 핵심 자료구조이다.&lt;/p>
&lt;p>봉 차트를 모델링 하기 위해서 &lt;code>Candlestick&lt;/code> 클래스와 &lt;code>CandlestickChart&lt;/code> 클래스를 사용한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">class Candlestick {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private long openPrice;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private long closePrice;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private long highPrice;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private long lowPrice;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private long volume;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private long timestamp;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private int interval;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">class CandlestickChart {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private LinkedList&amp;lt;Candlestick&amp;gt; sticks;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>하나의 봉이 커버하는 시간 범위가 경과하면 다음 주기를 커버할 새 &lt;code>Candlestick&lt;/code> 클래스 객체를 생성하여 &lt;code>CandlestickChart&lt;/code> 객체의 내부 연결 리스트에 추가한다.&lt;/p>
&lt;hr>
&lt;p>봉 차트에서 많은 종목의 가격 이력을 다양한 시간 간격을 사용해 추적하려면 메모리가 많이 필요하므로 다음과 같은 방법을 고려할 수 있다.&lt;/p>
&lt;ul>
&lt;li>미리 메모리를 할당해 둔 링(ring) 버퍼에 봉을 보고나하면 새 객체 할당 횟수를 줄일 수 있다.&lt;/li>
&lt;li>메모리에 두는 봉의 개수를 제한하고 나머지는 디스크에 보관한다.&lt;/li>
&lt;/ul>
&lt;p>시장 데이터는 일반적으로 &lt;strong>실시간 분석을 위해 메모리 상주 칼럼형 데이터베이스(KDB)&lt;/strong> 에 둔다.&lt;/p>
&lt;ul>
&lt;li>시장이 마감된 후에는 데이터를 이력 유지 전용 데이터베이스에도 저장&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>현대의 거래소는 진화하여 하나의 거대 서버로 거의 모든 것을 운영하는 형태로 발전했다.&lt;/p>
&lt;h3 id="성능">성능&lt;/h3>
&lt;p>거래소는 평균 지연 시간은 낮아야 하고, 전반적인 지연 시간 분포는 안정적이어야 한다.&lt;/p>
&lt;ul>
&lt;li>지연 시간이 안정적인지 보는 좋은 척도는 P99(99% 백분위수) 지연시간이다.&lt;/li>
&lt;/ul>
&lt;p>지연 시간을 줄이는 방법에는 대표적으로 두 가지 방법이 있다.&lt;/p>
&lt;ul>
&lt;li>중요 경로에서 실행할 작업 수를 줄인다.&lt;/li>
&lt;li>각 작업의 소요 시간을 줄인다.
&lt;ul>
&lt;li>네트워크 및 디스크 사용량 경감&lt;/li>
&lt;li>각 작업의 실행 시간 경감&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>중요 경로 최적화&lt;/strong>&lt;/p>
&lt;p>중요 경로에는 꼭 필요한 구성 요소만 둔다.&lt;/p>
&lt;ul>
&lt;li>로깅도 지연 시간을 줄이기 위해 중요 경로에서는 뺀다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>작업 소요시간 최적화&lt;/strong>&lt;/p>
&lt;p>핵심 경로의 구성요소가 네트위커를 통해 연결된 개별 서버에서 실행된다고 가정하면, 왕복 네트워크 지연 시간은 약 500마이크로 초 이므로 핵심 경로에 네트워크를 통해 통신하는 컴포넌트가 많으면 지연 시간은 한 자릿수 밀리초 까지 늘어난다.&lt;/p>
&lt;p>또한 시퀀서는 &lt;strong>이벤트를 디스크에 저장&lt;/strong>하는 이벤트 저장소로 순차적 쓰기의 성능 이점을 활용하여 효율적으로 설계한다 해도 디스크 엑세스 지연 시간은 여전히 수십 밀리초 단위이다.&lt;/p>
&lt;p>네트워크 및 디스크 엑세스 지연 시간을 모두 고려하면 총 단대단(end-to-end) 지연 시간은 수십 밀리초에 달한다.&lt;/p>
&lt;blockquote>
&lt;p>거래소는 주로 네트워크 및 디스크 액세스 지연 시간을 줄이거나 없애는 방안을 통해 중요 경로의 단대단 지연 시간을 수십 마이크로초로 줄였다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_14.png"
width="1340"
height="992"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_14_hu89a7c5fe794897a7b63ee48dec94677c_74333_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_14_hu89a7c5fe794897a7b63ee48dec94677c_74333_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="지연 시간이 낮은, 단일 서버 기반 설계안"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="324px"
>&lt;/p>
&lt;p>모든 것을 동일한 서버에 배치하여 네트워크를 통하는 구간을 없애고, 컴포넌트 간 통신은 이벤트 저장소인 &lt;code>nmap&lt;/code>을 통한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_15.png"
width="1172"
height="1248"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_15_hu63ebef76be0577ba04d0e768bc6a7573_74102_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_15_hu63ebef76be0577ba04d0e768bc6a7573_74102_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="주문 관리자의 애플리케이션 루프 스레드"
class="gallery-image"
data-flex-grow="93"
data-flex-basis="225px"
>&lt;/p>
&lt;p>애플리케이션 루프의 주된 작업 실행 매커니즘은 &lt;strong>&lt;code>while&lt;/code> 순환문을 통해 실행할 작업을 계속 폴링&lt;/strong>한다.&lt;/p>
&lt;ul>
&lt;li>엄격한 지연 시간 요건을 만족하려면 목적 달성에 가장 중요한 작업만 이 순환문 안에서 처리해야한다.&lt;/li>
&lt;/ul>
&lt;p>이 매커니즘의 폭표는 &lt;strong>각 구성 요소의 실행 시간을 줄여 전체적인 실행 시간이 예측 가능하도록(ex. p99 지연 시간을 닞추어) 보장하는 것&lt;/strong> 이다.&lt;/p>
&lt;p>컴포넌트는 서버의 프로세스로 &lt;strong>CPU 효율성을 극대화 하기 위해 애플리케이션 루프는 단일 스레드로 구현하며, 특정 CPU 코어에 고정&lt;/strong>시킨다.&lt;/p>
&lt;p>애플리케이션 루프를 CPU에 고정하면 상당한 이점이 있다.&lt;/p>
&lt;ul>
&lt;li>컨텍스트 스위치가 없다.
&lt;ul>
&lt;li>CPU가 주문 관리자의 애플리케이션 루프 처리에 온전히 할당된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>상태를 업데이트하는 스레드가 하나뿐이라서 락을 사용할 필요가 없다.
&lt;ul>
&lt;li>잠금 경합(lock contention)도 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>CPU를 고정하는 방법의 단점은 &lt;strong>코딩이 더 복잡해진다&lt;/strong>는 것이다.&lt;/p>
&lt;ul>
&lt;li>엔지니어는 각 작업이 애플리케이션 루프 스레드를 너무 오래 점유하지 않도록 각 작업에 걸리는 시간을 신중하게 분석하여 후속 작업이 제때 실행될 수 있도록 해야한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;code>mmap&lt;/code>은 파일을 &lt;strong>프로세스의 메모리에 매핑하는 &lt;code>mmap(2)&lt;/code>라는 이름의 POSIX 호환 UNIX 시스템 콜&lt;/strong>을 일컫는다.&lt;/p>
&lt;p>&lt;code>mmap(2)&lt;/code>은 프로세스 간 고성능 메모리 공유 메커니즘을 제공하며, 메모리에 매핑할 파일이 메모리 기반 파일 시스템인 &lt;code>/dev/shm&lt;/code>에 있을 때 성능 이점은 더욱 커진다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>/dev/shm&lt;/code>에 있는 파일에 &lt;code>mmap(2)&lt;/code>을 수행하면 공유 메모리에 접근해도 디스크 I/O는 발생하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>서버에서 &lt;code>mmap(2)&lt;/code>를 사용하여 중요 경로에 놓인 구성 요소가 서로 통신할 때 이용할 메시지 버스를 구현하여 가능한 한 디스크 접근이 일어나지 않도록 한다.&lt;/p>
&lt;ul>
&lt;li>이 통신 경로를 사용하면 네트워크나 디스크에 접근하는 일은 없다.&lt;/li>
&lt;li>메시지 전송에 마이크로 초 미만의 시간이 걸린다.&lt;/li>
&lt;/ul>
&lt;p>이와 같은 이벤트 저장소에 &lt;strong>이벤트 소싱 설계&lt;/strong> 패러다임을 결합하면 &lt;strong>서버에 지연 시간이 낮은 마이크로서비스들을 구축&lt;/strong>할 수 있게 된다.&lt;/p>
&lt;h4 id="이벤트-소싱">이벤트 소싱&lt;/h4>
&lt;p>전통적인 애플리케이션은 상태를 데이터베이스에 유지하기 때문에 문제가 발생하면 원인을 추적하기 어렵다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스는 현재 상태만 유지할 뿐, 현재 상태를 초래한 이벤트의 기록은 없기 때문&lt;/li>
&lt;/ul>
&lt;p>이벤트 소싱 아키텍처는 &lt;strong>현재 상태를 저장하는 대신 상태를 변경하는 모든 이벤트의 변경 불가능한(immutable) 로그를 유지&lt;/strong>한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_16.png"
width="1404"
height="696"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_16_hu7bc68650e074e063dac0130790ce2ff6_74474_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_16_hu7bc68650e074e063dac0130790ce2ff6_74474_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비 이벤트 소싱 아키텍처 vs 이벤트 소싱 아키텍처"
class="gallery-image"
data-flex-grow="201"
data-flex-basis="484px"
>&lt;/p>
&lt;p>이벤트 소싱 아키텍처는 모든 이벤트를 추적하므로, 모든 이벤트를 순서대로 재생하면 주문 상태를 복구할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_17.png"
width="1508"
height="1490"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_17_hufe183a988f02777a0882f37bece15360_126641_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_17_hufe183a988f02777a0882f37bece15360_126641_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이벤트 소싱 설계"
class="gallery-image"
data-flex-grow="101"
data-flex-basis="242px"
>&lt;/p>
&lt;p>mmap 이벤트 저장소를 메시지 버스로 사용하는 이벤트 소싱 설계안으로, 카프카의 펍섭(pub-sub) 모델과 아주 비슷하다. (지연 시간에 대한 엄격한 요구사항만 없었으면 카프카를 사용할 수도 있다.)&lt;/p>
&lt;ul>
&lt;li>게이트웨이는 빠르고 간결한 인코딩을 위해 FIX를 SBE(Fix over Simple Binary Encoding)로 변환하고, 각 주문을 이벤트 저장소 클라이언트를 사용하여 미리 정의된 형식의 &lt;code>NewOrderEvent&lt;/code> 형태로 전송한다.&lt;/li>
&lt;li>체결 엔진에 내장된 주문 관리자는 이벤트 저장소로부터 &lt;code>NewOrderEvent&lt;/code>를 수신하면 유효성 검사한 다음 내부 주문 상태에 추가하며, 해당 주문은 처리 담당 CPU 코어로 전송된다.&lt;/li>
&lt;li>주문이 체결되면 &lt;code>OrderFilledEvent&lt;/code>가 생성되어 이벤트 저장소로 전송된다.&lt;/li>
&lt;li>시장 데이터 프로세서 및 보고 서비스 같은 다른 구성요소는 이벤트 저장소를 구독하고, 이벤트를 받을 때마다 적절히 처리한다.&lt;/li>
&lt;/ul>
&lt;p>이 설계는 앞서 살펴본 개략적 설계안에 대체적으로 부합하지만 이벤트 소싱 아키텍처에서 더 효율적으로 동작할 수 있도록 조정한 부분이 몇 가지 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>주문 관리자&lt;/strong>&lt;/p>
&lt;p>이벤트 소싱 아키텍처에서 주문 관리자는 컴포넌트에 내장되는 재사용 가능 라이브러리이다.&lt;/p>
&lt;ul>
&lt;li>중앙화된 주문 관리자를 이용하도록 할 경우 지연 시간이 길어질 수 있기 때문&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>시퀀서&lt;/strong>&lt;/p>
&lt;p>이 다이어그램에는 시퀀서가 없다.&lt;/p>
&lt;p>이벤트 저장소에 보관되는 항목에는 sequence 필드가 있고 이 필드의 값은 이벤트 저장소에 있는 시퀀서가 넣는다.&lt;/p>
&lt;ul>
&lt;li>각 이벤트 저장소에는 하나의 시퀀서만 있다.(저장소 쓰기 권한을 위한 경쟁 방지)&lt;/li>
&lt;/ul>
&lt;p>따라서 시퀀서는 이벤트 저장소에 보내기 전에 이벤트를 순서대로 정렬하는 유일한 쓰기 연산 주체이며, 개략적 설계와 달리 메시지 저장소 역할을 하지않는 한가지 간단한 역할만 수행하므로 아주 빠르다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_18.png"
width="1390"
height="1058"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_18_hu30c395596ecba4a6d6bf7e98ea28835f_212084_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_18_hu30c395596ecba4a6d6bf7e98ea28835f_212084_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="시퀀서 설계 사례"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="315px"
>&lt;/p>
&lt;p>각 컴포넌트에 고유한 링 버퍼에서 이벤트를 가져온 후 순서 ID를 찍고 다음 이벤트 저장소로 보낸다.&lt;/p>
&lt;ul>
&lt;li>주 시퀀서가 다운될 경우를 대비해, 백업 시퀀서를 두면 가용성을 높일 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="고가용성">고가용성&lt;/h3>
&lt;p>본 설계안은 99.99% 가용성을 염두에 두고 설계하였으며, 이는 거래소가 다운될 수 있는 시간이 하루에 8.64초를 넘으면 안된다는 뜻이다.&lt;/p>
&lt;p>따라서 서비스가 다운되면 &lt;strong>즉각 복구&lt;/strong>되어야 한다.&lt;/p>
&lt;p>가용성을 높여야 할 때는 다음과 같은 사항을 살펴야한다.&lt;/p>
&lt;ul>
&lt;li>단일 장애 지점을 식별
&lt;ul>
&lt;li>ex) 체결 엔진에 발생하는 장애는 거래소에는 재앙이다. 주 인스턴스를 다중화해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>장애 감지 및 백업 인스턴스로의 장애 조치 결정이 빨라야함&lt;/li>
&lt;/ul>
&lt;p>클라이언트 게이트웨이와 같은 무상태 서비스의 경우, 서버를 추가하면 쉽게 수평적 확장이 가능하지만, 주문 관리자나 체결 엔진처럼 상태를 저장하는 컴포넌트는, 사본 간에 상태 데이터를 복사할 수 있어야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_19.png"
width="1390"
height="536"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_19_hu6ee2798bf6b7e350074ba012eced2a2c_41958_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_19_hu6ee2798bf6b7e350074ba012eced2a2c_41958_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="주/부 체결 엔진"
class="gallery-image"
data-flex-grow="259"
data-flex-basis="622px"
>&lt;/p>
&lt;p>부 체결 엔진은 동일한 이벤트를 수신하고 처리하지만 이벤트 저장소로 이벤트를 전송하지는 않는다.&lt;/p>
&lt;ul>
&lt;li>주 인스턴스가 다운되면 부 인스턴스는 즉시 주 인스턴스 지위를 승계한 후 이벤트를 전송&lt;/li>
&lt;li>부 인스턴스가 다운된 경우 일단 재시작 후 이벤트 저장소 데이터를 사용해 모든 상태 복구&lt;/li>
&lt;/ul>
&lt;p>이벤트 소싱 아키텍처는 결정론적 특성으로 인해 상태 복구가 쉽고 정확하여 거래소에 적합하다.&lt;/p>
&lt;p>이 아키텍처에서는 &lt;strong>주 체결 엔진의 문제를 자동 감지할 메커니즘이 필요&lt;/strong>하다.&lt;/p>
&lt;ul>
&lt;li>하드웨어와 프로세스를 모니터링 하는 일반적인 방안&lt;/li>
&lt;li>체결 엔진과 박동 메시지를 주고 받는 방안&lt;/li>
&lt;/ul>
&lt;p>위 주/부 체결 엔진 설계안의 문제점은 &lt;strong>단일 서버 안에서만 동작한다는 것&lt;/strong>으로, 고가용성을 달성하려면 이 개념을 &lt;strong>여러 서버&lt;/strong> 또는 &lt;strong>데이터 센터 전반&lt;/strong>으로 확장해야 한다.&lt;/p>
&lt;ul>
&lt;li>주/부 체결 엔진이 아니라 주/부 서버의 클러스터를 구성해야함&lt;/li>
&lt;/ul>
&lt;p>이벤트 저장소를 여러 서버로 복제하는 데는 시간이 많이 걸리므로 안정적 UDP(reliable UDP)를 사용하면 모든 부 서버에 이벤트 메시지를 효과적으로 브로드캐스트 할 수 있다.&lt;/p>
&lt;h3 id="결함-내성">결함 내성&lt;/h3>
&lt;p>주/부 설계안은 비교적 잘 동작하지만 부 서버까지 전부 다운되는 상황이 발생할 수 있으므로 이에 대비해야한다.&lt;/p>
&lt;p>핵심 데이터를 여러 지역의 데이터센터에 복제하여 이 문제를 해결하는데, 결함 내성(fault-tolerant) 시스템을 만들려면 많은 확인이 필요하다.&lt;/p>
&lt;ul>
&lt;li>주 서버가 다운되면 언제, 그리고 어떻게 부 서버로 자동 전환하는 결정을 내리는가?&lt;/li>
&lt;li>부 서버 가운데 새로운 리더는 어떻게 선출하는가?&lt;/li>
&lt;li>복구 시간 목표(Recovery Time Objective, RTO)는 얼마인가?&lt;/li>
&lt;li>어떤 기능을 복구해야 하는가(Recovery Point Objective, RPO)?&lt;/li>
&lt;li>시스템이 성능 저하 상태로도 동작할 수 있는가?&lt;/li>
&lt;/ul>
&lt;p>먼저 장애가 생겼다는 것이 실제 무엇을 의미하는지 이해해야한다.&lt;/p>
&lt;ul>
&lt;li>시스템에서 잘못된 경보를 전송하면 불필요한 장애 극복 절차, 즉 부 시스템으로의 자동 전환 발생 가능&lt;/li>
&lt;li>코드의 버그로 인해 주 서버가 다운되었다면 부 서버로 자동 전환되더라도 같은 버그 때문에 부 서버까지 다운될 수 있음
&lt;ul>
&lt;li>모든 주/부 서버가 중단되면 시스템은 더 이상 사용할 수 없는 상태에 빠짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이는 어려운 문제로 몇 가지 해결책을 생각해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>새 시스템을 처음 출시할 때는 &lt;strong>수동&lt;/strong>으로 장애 복구 조치를 수행
&lt;ul>
&lt;li>충분한 시그널, 운영 경험을 축적하여 시스템의 이해도를 높이고 자동으로 장애를 감지하여 복구하는 프로세스를 도입&lt;/li>
&lt;li>카오스 엔지니어링(chaos engineering)은 드물게 발생하는 까다로운 사례를 수면으로 이끌어내고 운영 경험을 빠르게 축적하는 데 좋은 방법&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>래프트&lt;/strong>&lt;/p>
&lt;p>장애 복구 조치를 자동으로 올바르게 할 수 있다면 어떤 서버가 주 서버 역할을 인계 받을지 결정하는 검증된 리더 선출 알고리즘들을 고려할 수 있다.&lt;/p>
&lt;p>대표적으로 래프트가 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_20.png"
width="1852"
height="1150"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_20_hu78826d03ca3d3cd5bdff94806f424ac8_97316_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_20_hu78826d03ca3d3cd5bdff94806f424ac8_97316_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="래프트 클러스터에서의 이벤트 복제"
class="gallery-image"
data-flex-grow="161"
data-flex-basis="386px"
>&lt;/p>
&lt;p>수신된 이벤트는 팔로어의 자체 mmap 이벤트 저장소에 저장된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_21.png"
width="1400"
height="424"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_21_hubef2116e8433210b130cdef29a0180ec_25206_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_21_hubef2116e8433210b130cdef29a0180ec_25206_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="래프트 조건"
class="gallery-image"
data-flex-grow="330"
data-flex-basis="792px"
>&lt;/p>
&lt;ol>
&lt;li>리더는 팔로어에게 박동 메시지를 보내고, 일정 기간 동안 박동 메시지를 받지 못한 팔로어는 새 리더를 선출하는 선거 타이머를 시작한다.(&lt;code>AppendEnties&lt;/code>)&lt;/li>
&lt;li>가장 먼저 타이머가 타임아웃된 팔로어는 후보가 되고, 다른 나머지 팔로어에게 투표를 요청한다.(&lt;code>RequestVote&lt;/code>)&lt;/li>
&lt;li>그 팔로어가 과반 수 이상의 표를 받으면 새로운 리더가 된다.&lt;/li>
&lt;/ol>
&lt;p>첫번 째 팔로어의 임기(term) 값이 새 노드보다 짧으면 리더가 될 수 없으며, 여러 명의 팔로어가 동시에 후보가 되는 경우 &lt;strong>분할 투표&lt;/strong>(split vote)라고 한다.&lt;/p>
&lt;p>이 경우 기존 선거의 타임아웃을 선언하고 새로운 선거를 시작한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>복구 시간 목표&lt;/strong>&lt;/p>
&lt;p>복구 시간 목표는 &lt;strong>애플리케이션이 다운되어도 사업에 심각한 피해가 없는 시간의 최대값&lt;/strong>이다.&lt;/p>
&lt;p>증권 거래소의 경우 2등급을 RTO를 달성해야하는데, 이를 위해 서비스의 자동 복구가 반드시 가능해야 한다.&lt;/p>
&lt;ul>
&lt;li>우선순위에 따라 서비스를 분류하고 최소 서비스 수준을 유지하기 위한 성능 저하 전략(degradation strategy)을 정의한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>복구 지점 목표&lt;/strong>&lt;/p>
&lt;p>RPO는 비즈니스에 &lt;strong>심각한 피해가 발생하기 전 손실될 수 있는 데이터의 양, 즉 손실 허용 범위&lt;/strong>를 의미한다.&lt;/p>
&lt;ul>
&lt;li>실무에서는 데이터는 자주 백업해야 한다는 것과 같은 뜻으로 받아들인다.&lt;/li>
&lt;/ul>
&lt;p>증권 거래소는 데이터 손실을 용납할 수 없으므로 RPO가 0에 가깝다.&lt;/p>
&lt;p>레프트 메커니즘을 사용하면 데이터 사본은 많고, 모든 클러스터 노드가 같은 상태를 갖도록 보장할 수 있다.&lt;/p>
&lt;h3 id="체결-알고리즘">체결 알고리즘&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Context handleOrder(OrderBook orderBook, OrderEvent orderEvent) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (orderEvent.getSequenceId() != nextSequence) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return Error(OUT_OF_ORDER, nextSequence);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (!validateOrder(symbol, price, quantity)) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return ERROR(INVALID_ORDER, orderEvent);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Order order = createOrderFromEvent(orderEvent);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> switch (msgType):
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> case NEW:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return handleNew(orderBook, order);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> case CANCEL:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return handleCancel(orderBook, order);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> default:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return ERROR(INVALID_MSG_TYPE, msgType);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Context handleNew(OrderBook orderBook, Order order) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (BUY.equals(order.side)) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return match(orderBook.sellBook, order);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } else {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return match(orderBook.buyBook, order);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Context handleCancel(OrderBook orderBook, Order order) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (!orderBook.orderMap.contains(order.orderId)) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return ERROR(CANNOT_CANCEL_ALREADY_MATCHED, order);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> removeOrder(order);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> setOrderStatus(order, CANCELED);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return SUCCESS(CANCEL_SUCCESS, order);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Context match(OrderBook book, Order order) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Quantity leavesQuantity = order.quantity - order.matchedQuantity;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Iterator&amp;lt;Order&amp;gt; limitIter = book.limitMap.get(order.price).orders;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (limitIter.hasNext() &amp;amp;&amp;amp; leavesQuantity &amp;gt; 0) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Quantity matched = min(limitIter.next.quantity, order.quantity);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> order.matchedQuantity += matched;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> leavesQuantity = order.quantity - order.matchedQuantity;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> remove(limitIter.next);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> generateMatchedFill();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return SUCCESS(MATCH_SUCCESS, order);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이 의사 코드는 FIFO 체결 알고리즘을 사용한다.&lt;/p>
&lt;p>특정 가격 수준에서 먼저 들어온 주문이 먼저 체결되고, 마지막 주문이 가장 나중에 체결된다.&lt;/p>
&lt;p>체결 알고리즘은 다양하다.&lt;/p>
&lt;ul>
&lt;li>FIFO + LLM(Lead Market Maker): LLM에 먼저 일정 수량을 할당&lt;/li>
&lt;li>다크 풀(dark pool)&lt;/li>
&lt;/ul>
&lt;h3 id="결정론">결정론&lt;/h3>
&lt;p>결정론(determinism)에는 &lt;strong>기능적 결정론&lt;/strong>(functional determinism)과 &lt;strong>지연 시간 결정론&lt;/strong>(latency determinism)이 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>기능적 결정론&lt;/strong>&lt;/p>
&lt;p>이벤트를 동일한 순서로 재생하면 항상 같은 결과를 얻을 수 있도록 보장하는 것으로 이벤트가 발생하는 실제 시간은 대체로 중요하지 않고, 발생한 순서 자체가 중요하다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_22.png"
width="1708"
height="394"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_22_hu31e801bdc632011d92d5b5346568e4e9_28693_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_22_hu31e801bdc632011d92d5b5346568e4e9_28693_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이벤트 소싱 시간"
class="gallery-image"
data-flex-grow="433"
data-flex-basis="1040px"
>&lt;/p>
&lt;p>시간 축 위에 불규칙하게 나열된 타임스탬프들이 연속된 점들로 변환되었는데, 그렇게 되면 재생과 복구에 소요되는 시간이 크게 줄어든다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>지연 시간 결정론&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>특정 작업을 완료하거나 입력에 반응하는 데 걸리는 시간이 얼마나 일관되고 예측 가능한지를 의미한다.&lt;br>
결정론적 시스템은 지연 시간의 변동성을 최소화하여 예측 가능하고 일관된 응답 시간을 보장한다.(응답 시간도 결정되어야한다.)&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>각 거래의 처리 시간이 거의 같다는 뜻&lt;/strong>으로 사업에서 가장 중요한 부분이다.&lt;/p>
&lt;ul>
&lt;li>99번 백분위수 지연 시간이나 99.99번 백분위수 지연 시간을 측정하여 확인한다.&lt;/li>
&lt;/ul>
&lt;p>p99 지연 시간이 낮다는 것은 거래소가 거의 모든 거래에 안정적인 성능을 제공한다는 뜻 이다.&lt;/p>
&lt;p>지연 시간 변동 폭이 커지면 원인 조사가 필요하다.&lt;/p>
&lt;h3 id="시장-데이터-게시-서비스-최적화">시장 데이터 게시 서비스 최적화&lt;/h3>
&lt;p>L3 호가 창/주문서 데이터를 보면 시장을 더 잘 파악할 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>하루치 봉 차트 데이터는 무료로 얻을 수 있지만 자세한 L2/L3 호가 창 데이터를 얻으려면 비용이 많이 들기 때문에, 많은 헤지 펀드가 거래소 실시간 API를 통해 데이터를 직접 기록하여 기술적 분석을 위한 많은 차트를 자체적으로 구축한다.&lt;/p>
&lt;/blockquote>
&lt;p>시장 데이터 게시 서비스(Market Data Publisher, MDP)는 체결 엔진의 체결 결과를 받아 이를 기반으로 호가 창과 봉 차트를 재구축 한 다음 구독자에게 그 데이터를 게시한다.&lt;/p>
&lt;p>MDP는 다양한 수준의 서비스를 제공하는데, MDP의 메모리는 무한대로 확장할 수 없으므로 봉 차트에는 상한선을 두어야한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/13/img_23.png"
width="1738"
height="916"
srcset="https://codemario318.github.io/post/system-design-interview-2/13/img_23_hueb90a4a481010c9a3acb1342f2168913_161701_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/13/img_23_hueb90a4a481010c9a3acb1342f2168913_161701_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="시장 데이터 게시 서비스"
class="gallery-image"
data-flex-grow="189"
data-flex-basis="455px"
>&lt;/p>
&lt;p>이 설계안은 링 버퍼를 활용한다. 원형 버퍼라고도 하는 링 버퍼는 앞과 끝이 연결된 고정 크기의 큐로, 생산자는 계속 데이터를 넣고 하나 이상의 소비자는 데이터를 꺼낸다.&lt;/p>
&lt;p>링 버퍼의 공간은 사전에 할당된 것으로 객체를 생성하거나 삭제하는 연산이 필요없고, 락을 사용하지 않는다.&lt;/p>
&lt;ul>
&lt;li>패딩(padding)은 링 버퍼의 순서 번호가 다른 것과 같은 캐시 라인에 오지 않도록 한다.&lt;/li>
&lt;/ul>
&lt;h3 id="시장-데이터의-공정한-배포">시장 데이터의 공정한 배포&lt;/h3>
&lt;p>거래소에서 다른 사람보다 지연 시간이 낮다는 것은 미래를 예측할 수 있다는 것과 같은 의미로, 규제를 받는 거래소의 경우 모든 수신자가 동시에 시장 데이터를 받을 수 있도록 보장하는 것이 중요하다.&lt;/p>
&lt;ul>
&lt;li>안정적 UDP를 사용하는 멀티 케스트는 한 번에 많은 참가자에게 업데이트를 브로트캐스트 하기 좋은 솔루션이다.&lt;/li>
&lt;li>연결하는 순서로 데이터를 주는 대신, 무작위 순서로 주는 방법도 고려할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>거래소 설계에는 보편적으로 멀티캐스트를 사용하며, 같은 멀티캐스트 그룹에 속한 수신자는 이론적으로는 동시에 데이터를 수신한다.&lt;/p>
&lt;ul>
&lt;li>그러나 UDP는 신뢰성이 낮은 프로토콜이며 그 데이터그램이 모든 수신자에게 도달하지 못핦 수 있으므로 유의한다.&lt;/li>
&lt;/ul>
&lt;h3 id="코로케이션">코로케이션&lt;/h3>
&lt;p>많은 거래소가 헤지 펀드 또는 브로커의 서버를 거래소와 같은 데이터 센터에 둘 수 있도록 하는 코로케이션 서비스를 제공한다.&lt;/p>
&lt;ul>
&lt;li>체결 엔진에 주문을 넣는 지연 시간은 기본적으로 전송 경로 길이에 비례한다.&lt;/li>
&lt;li>유료 VIP 서비스로 취급한다.&lt;/li>
&lt;/ul>
&lt;h3 id="네트워크-보안">네트워크 보안&lt;/h3>
&lt;p>거래소는 일반적으로 몇 가지 인터페이스를 공개하고 있기 때문에 DDoS 공격에 대응할 수 있는 능력을 갖추는 것이 중요하다.&lt;/p>
&lt;ul>
&lt;li>공개 서비스와 데이터를 비공개 서비스에서 분리하여 DDoS 공격이 가장 중요한 클라이언트에 영향을 미치지 않도록 한다.
&lt;ul>
&lt;li>동일한 데이터를 제공해야 하는 경우 읽기 전용 사본을 여러 개 만들어 문제를 격리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>자주 업데이트되지 않는 데이터는 캐싱&lt;/li>
&lt;li>URL을 강화&lt;/li>
&lt;li>효과적인 허용/차단 리스트 메커니즘을 사용&lt;/li>
&lt;li>처리율 제한&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>대형 거래소를 위한 이상적인 배포 모델은 모든 것을 하나의 거대한 서버 도는 단일 프로세스에 배치하는 것이라는 결론에 도달할 것이다.&lt;/p>
&lt;ul>
&lt;li>일부 거래소는 이런 방식을 따른다.&lt;/li>
&lt;/ul>
&lt;p>암호화폐 산업이 발전함에 따라 많은 암호화폐 거래소가 클라우드 인프라를 사용하여 서비스를 배포한다.&lt;/p>
&lt;p>클라우드 생태계가 제공하는 편리함은 설계의 방향을 바구었을 뿐 아니라 업계 진입 문턱도 낮추고 있다.&lt;/p></description></item><item><title>12. 전자 지갑</title><link>https://codemario318.github.io/post/system-design-interview-2/12/</link><pubDate>Sat, 07 Dec 2024 13:51:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/12/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/cover.png" alt="Featured image of post 12. 전자 지갑" />&lt;p>결제 플랫폼은 일반적으로 고객게에 전자 지갑 서비스를 제공하여 지갑에 돈을 넣어두고 필요할 때 사용할 수 있도록 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_10.png"
width="1920"
height="372"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_10_hu882c1f440f1b9829d468d598d006e286_33295_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_10_hu882c1f440f1b9829d468d598d006e286_33295_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="전자 지갑"
class="gallery-image"
data-flex-grow="516"
data-flex-basis="1238px"
>&lt;/p>
&lt;ul>
&lt;li>결제 기능&lt;/li>
&lt;li>다른 사용자의 지갑으로 직접 송금
&lt;ul>
&lt;li>은행 간 이체보다 빠르며, 일반적으로 추가 수수료를 부과하지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>전자 지갑 애플리케이션의 백엔드를 설계해본다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;ul>
&lt;li>전자 지갑 간 이체&lt;/li>
&lt;li>10,000,000 TPS&lt;/li>
&lt;li>99.99% 안정성&lt;/li>
&lt;li>트랜잭션&lt;/li>
&lt;li>재현성&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-추정">개략적 추정&lt;/h3>
&lt;p>TPS를 거론한다는 것은 &lt;strong>트랜잭션 기반 데이터베이스&lt;/strong>를 사용한다는 것을 뜻한다.&lt;/p>
&lt;p>일반적인 데이터센터 노드에서 실행되는 관계형 데이터베이스는 초당 수천 건의 트랜잭션을 지원할 수 있다.&lt;/p>
&lt;ul>
&lt;li>설계안에서 사용할 데이터베이스 노드는 1,000 TPS를 지원할 수 있다고 가정&lt;/li>
&lt;li>1백만 TPS를 지원하려면 1,000개의 데이터베이스 노드가 필요함&lt;/li>
&lt;/ul>
&lt;p>이체 명령을 실행하려면 한 계좌에서 인출, 다른 계좌에서 입금을 실행해야하므로, 실제로는 2백만 TPS를 지원해야 하기 때문에, 2,000개의 데이터베이스 노드가 필요하다.&lt;/p>
&lt;p>하드웨어가 같아고 가정할 때, 한 노드가 초당 처리할 수 있는 트랜잭션 수가 많을수록 필요한 총 노드 수는 줄어들어 하드웨어 비용은 낮아진다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>노드당 TPS&lt;/th>
&lt;th>노드 수&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>100&lt;/td>
&lt;td>20,000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1,000&lt;/td>
&lt;td>2,000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10,000&lt;/td>
&lt;td>200&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>따라서 단일 노드가 처리할 수 있는 트랜잭션 수를 최대한 늘려 관리해야할 노드 수를 줄인다.&lt;/p>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;ul>
&lt;li>API 설계&lt;/li>
&lt;li>세가지 개략적 설계안
&lt;ul>
&lt;li>간단한 메모리 기반 솔루션&lt;/li>
&lt;li>데이터베이스 기반 분산 트랜잭션 솔루션&lt;/li>
&lt;li>재현성을 갖춘 이벤트 소싱(event sourcing) 솔루션&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="api-설계">API 설계&lt;/h3>
&lt;p>RESTful 규약을 따르는 하나의 API만 필요하다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>기능&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>POST /v1/wallet/balance_transfer&lt;/td>
&lt;td>한 지갑에서 다른 지급으로 자금 이체&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;p>&lt;strong>요청 인자&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>필드&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>자료형&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>from_account&lt;/td>
&lt;td>인출 계좌&lt;/td>
&lt;td>string&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>to_account&lt;/td>
&lt;td>이체 계좌&lt;/td>
&lt;td>string&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>amount&lt;/td>
&lt;td>금액&lt;/td>
&lt;td>string&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>currency&lt;/td>
&lt;td>통화 단위&lt;/td>
&lt;td>string&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>transaction_id&lt;/td>
&lt;td>중복 제거 ID&lt;/td>
&lt;td>uuid&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>유의할 부분은 &lt;code>amount&lt;/code> 필드의 자료형이 &lt;code>string&lt;/code> 이라는 점인데(11장 참고), 실제로는 &lt;code>float&lt;/code>이나 &lt;code>double&lt;/code>을 대부분의 프로그래밍 언어와 데이터베이스가 지원하기 때문에 택하는 경우도 많다.&lt;/p>
&lt;ul>
&lt;li>정밀도를 잃을 위험을 인지하고 사용한다면 적절한 선택일 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="인메모리-샤딩">인메모리 샤딩&lt;/h3>
&lt;p>지갑 애플리케이션은 모든 사용자 계정의 잔액을 유지한다.&lt;/p>
&lt;p>사용자와 잔액의 관계를 나타내기 좋은 자료 구조는 키-값 자료구조이고, 인메모리 키-값 저장소는 레디스가 가장 인기있다.&lt;/p>
&lt;p>그러나 레디스 노드 한대로 100만 TPS는 벅차기 때문에 클러스터를 구성하고 사용자 계정을 모든 노드에 균등하게 분산시켜야 한다.&lt;/p>
&lt;ul>
&lt;li>파티셔닝 또는 샤딩&lt;/li>
&lt;/ul>
&lt;p>키-값 데이터를 n개 파티션에 고르게 분배하려면 키의 해시 값을 계산하고 이를 파티션의 수 n으로 나누는 방법을 고려할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">String accountId = &amp;#34;A&amp;#34;;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Int partitionNumber = 7;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Int myPartition = accountId.hashCode() % partitionNumber;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>모든 레디스 노드의 파티션 수 및 주소는 한 군데 저장해 둔다.&lt;/p>
&lt;ul>
&lt;li>높은 가용성을 보장하는 설정 정보 전문 저장소 **주키퍼(ZooKeeper)**를 이 용도로 쓰면 좋다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img.png"
width="1654"
height="906"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_huf72c0536c84b69c0b7ed32c59bc234de_79804_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_huf72c0536c84b69c0b7ed32c59bc234de_79804_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="메모리 기반 솔루션"
class="gallery-image"
data-flex-grow="182"
data-flex-basis="438px"
>&lt;/p>
&lt;p>이 방안의 마지막 구성 요소는 &lt;strong>이체 명령 처리를 담당하는 서비스&lt;/strong>로(지갑 서비스, wallet service) 다음과 같은 역할을 담당한다.&lt;/p>
&lt;ol>
&lt;li>이체 명령 수신&lt;/li>
&lt;li>이체 명령의 유효성 검증&lt;/li>
&lt;li>명령이 유효한 것으로 확인되면 이체에 관계된 두 계정의 잔액 갱신
&lt;ul>
&lt;li>두 계정은 다른 레디스 노드에 있을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>이 서비스는 무상태 서비스이므로 수평적 규모 확장에 유리하다.&lt;/p>
&lt;hr>
&lt;p>이 설계는 작동은 하지만 정확성 요구사항을 충족하지 못한다.&lt;/p>
&lt;ul>
&lt;li>두 개의 레디스 노드를 업데이트 하는데, 그 두 연산이 모두 성공한다는 보장을 할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>따라서 두 업데이트 연산이 하나의 &lt;strong>원자적 트랜잭션&lt;/strong>(atomic transaction)으로 실행되어야한다.&lt;/p>
&lt;h3 id="분산-트랜잭션">분산 트랜잭션&lt;/h3>
&lt;h4 id="데이터베이스-샤딩">데이터베이스 샤딩&lt;/h4>
&lt;p>서로 다른 두 개 저장소 노드를 갱신하는 연산을 원자적으로 수행하려면 아래와 같은 방법들을 고려할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>레디스 노드를 트랜잭션을 지원하는 관계형 데이터베이스 노드로 교체&lt;/strong>&lt;/p>
&lt;p>클라이언트의 잔액 정보가 레디스 노드가 아닌 3개의 관계형 데이터베이스 노드로 분산된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_1.png"
width="1718"
height="1014"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_1_hu7e6610fae931e3e0420d5ef63bddb96b_77665_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_1_hu7e6610fae931e3e0420d5ef63bddb96b_77665_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="관계형 데이터 베이스"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="406px"
>&lt;/p>
&lt;p>트랜잭션 데이터베이스를 사용해도 위와 같은 방식이라면 문제의 일부반 해결할 수 있다.&lt;/p>
&lt;ul>
&lt;li>한 이체 명령이 서로 다른 두 데이터베이스 서버에 있는 계정 두 개를 업데이트해야 할 가능성이 아주 높은데, 이 두 작업이 정확히 동시에 처리된다는 보장이 없다.&lt;/li>
&lt;/ul>
&lt;p>분산 시스템에서 한 트랜잭션에서는 여러 노드의 프로세스가 관여할 수 있다.&lt;/p>
&lt;p>분산 트랜잭션은 이들 프로세스를 원자적인 하나의 트랜잭션으로 묶는 방안인데, 구현법으로 &lt;strong>저수준 방안&lt;/strong>과 &lt;strong>고수준 방안&lt;/strong>을 고려할 수 있다.&lt;/p>
&lt;h4 id="2단계-커밋">2단계 커밋&lt;/h4>
&lt;p>데이터베이스 자체에 의존하는 방안인 저수준 방안에서 가장 일반적으로 사용되는 알고리즘이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_2.png"
width="1852"
height="646"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_2_hu19f6cccbd10b2e2248e252cbf00774d8_79244_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_2_hu19f6cccbd10b2e2248e252cbf00774d8_79244_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="2단계 커밋"
class="gallery-image"
data-flex-grow="286"
data-flex-basis="688px"
>&lt;/p>
&lt;ol>
&lt;li>조정자는 정상적으로 여러 데이터베이스에 읽기 및 쓰기 작업을 수행한다.
&lt;ul>
&lt;li>데이터베이스 A, C에는 락이 걸린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>애플리케이션에서 트랜잭션을 커밋하려 할 때 조정자는 모든 데이터베이스에 트랜잭션 준비를 요청한다.&lt;/li>
&lt;li>조정자는 모든 데이터베이스의 등답을 받아 다음 절차를 수행한다.
&lt;ul>
&lt;li>모든 데이터베이스가 &amp;lsquo;예&amp;rsquo;라고 응답하면 모든 데이터베이스에 해당 트랜잭션 커밋을 요청한다.&lt;/li>
&lt;li>한 데이터베이스라도 &amp;lsquo;아니오&amp;rsquo;라고 응답하면 모든 데이터베이스에 트랜잭션 중단을 요청한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>준비 단계를 실행하려면 데이터베이스 트랜잭션 실행 방식을 변경해야 하기 때문에 저수준 방안으로 여겨진다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_3.png"
width="1852"
height="646"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_3_hu19f6cccbd10b2e2248e252cbf00774d8_79244_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_3_hu19f6cccbd10b2e2248e252cbf00774d8_79244_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="조정자 장애"
class="gallery-image"
data-flex-grow="286"
data-flex-basis="688px"
>&lt;/p>
&lt;ul>
&lt;li>2PC의 가장 큰 문제점은 다른 노드의 메시지를 기다리는 동안 락이 오랫동안 잠긴 상태로 남을 수 있어 성능이 좋지 않을 수 있다.&lt;/li>
&lt;li>조정자가 SPOF가 될 수 있다.&lt;/li>
&lt;li>모든 데이터베이스가 &lt;strong>X/Open XA 표준&lt;/strong>을 만족해야한다.&lt;/li>
&lt;/ul>
&lt;h3 id="분산-트랜잭션-tcc">분산 트랜잭션: TC/C&lt;/h3>
&lt;p>TC/C(시도-확정/취소, Try-Confirm/Cancel)는 두 단계로 구성된 보상 트랜잭션이다.&lt;/p>
&lt;ol>
&lt;li>조정자는 모든 데이터베이스에 트랜잭션에 필요한 자원 예약을 요청한다.&lt;/li>
&lt;li>조정자는 모든 데이터베이스로부터 회신을 받는다.
&lt;ul>
&lt;li>모두 &amp;lsquo;예&amp;rsquo; 라고 응답하면 모든 데이터베이스에 작업 확인을 요청한다.(시도-확정, Try-Confirm)&lt;/li>
&lt;li>하나라도 &amp;lsquo;아니오&amp;rsquo; 라고 응답하면 모든 데이터베이스에 작업 취소를 요청한다. (시도-취소, Try-Cancel)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>2PC의 두 단계는 한 트랜잭션이지만, TC/C에서는 각 단계가 별도 트랜잭션이라는 점을 유의하자.&lt;/p>
&lt;h4 id="tcc-사례">&lt;strong>TC/C 사례&lt;/strong>&lt;/h4>
&lt;p>계좌 A 에서 계좌 C로 1달러를 이체한다고 가정한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>단계&lt;/th>
&lt;th>실행연산&lt;/th>
&lt;th>A&lt;/th>
&lt;th>C&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>시도&lt;/td>
&lt;td>잔액 변경: -$1&lt;/td>
&lt;td>아무것도 하지 않음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>확인&lt;/td>
&lt;td>아무것도 하지 않음&lt;/td>
&lt;td>잔액 변경: +$1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>취소&lt;/td>
&lt;td>잔액 변경: +$1&lt;/td>
&lt;td>아무것도 하지 않음&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>지갑 서비스가 TC/C의 조정자로고 가정하고, 분산 트랜잭션이 시작될 때 계정 A의 잔액은 1달러이고 계정 C의 잔액은 0달러이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>첫 번째 단계: 시도&lt;/strong>&lt;/p>
&lt;p>시도 단계에서는 조정자 역할을 하는 지갑 서비스가 두 개의 트랜잭션 명령을 두 데이터베이스로 전송한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_4.png"
width="1384"
height="626"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_4_hud16c29872b996ec2beb3f34f5dddf1ea_58583_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_4_hud16c29872b996ec2beb3f34f5dddf1ea_58583_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="시도 단계"
class="gallery-image"
data-flex-grow="221"
data-flex-basis="530px"
>&lt;/p>
&lt;ul>
&lt;li>계정 A가 포함된 데이터베이스에 잔액을 1달러 감소시키는 트랜잭션을 시작한다.&lt;/li>
&lt;li>계정 C가 포함된 데이터베이스에는 아무 작업도 하지 않는다.
&lt;ul>
&lt;li>데이터베이스에 NOP(No Operation) 명령을 보내며, 항상 성공한다는 응답을 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>두 번째 단계: 확정&lt;/strong>&lt;/p>
&lt;p>두 데이터베이스가 모두 예라고 응답하면 지갑 서비스는 확정 단계를 시작한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_5.png"
width="2000"
height="724"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_5_hu9f66d079e3e4710ead273cc50adf3a3e_100091_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_5_hu9f66d079e3e4710ead273cc50adf3a3e_100091_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="확정 단계"
class="gallery-image"
data-flex-grow="276"
data-flex-basis="662px"
>&lt;/p>
&lt;p>계정 A의 잔액은 이미 첫 번째 단계에서 갱신되었으므로 잔액을 변경할 필요가 없으나, 계정 C에서 1달러를 받지 못했으므로 확인 단계에서 실행되어야한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>세 번째 단계: 취소&lt;/strong>&lt;/p>
&lt;p>첫번째 시도 단계에서 C 계정이 불법 계정이라던가하는 이유로 실패한다면 분산 트랜잭션을 취소하고 관련된 자원을 반환해야한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_6.png"
width="1986"
height="560"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_6_hud585c22ea7c26bf4e72e8f7a01cdf3a3_89572_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_6_hud585c22ea7c26bf4e72e8f7a01cdf3a3_89572_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="취소 단계"
class="gallery-image"
data-flex-grow="354"
data-flex-basis="851px"
>&lt;/p>
&lt;p>시도 단계의 트랜잭션에서 계정 A의 잔액은 이미 바뀌었기 때문에 &lt;strong>또 다른 트랜잭션을 시작하여 계정 A에 다시 1달라를 추가&lt;/strong>해야한다.&lt;/p>
&lt;ul>
&lt;li>시도 단계에서 계정 C의 잔액은 업데이트하지 않았으므로, 계정 C의 데이터베이스에는 NOP 명령만 보내면 된다.&lt;/li>
&lt;/ul>
&lt;h4 id="2pc와-tcc-비교">2PC와 TC/C 비교&lt;/h4>
&lt;p>2PC와 TC/C 간에는 많은 유사점이 있지만 차이점도 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>첫 번째 단계&lt;/th>
&lt;th>두 번째 단계: 성공&lt;/th>
&lt;th>두 번째 단계: 실패&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>2PC&lt;/td>
&lt;td>로컬 트랜잭션은 아지 완료되지 않은 상태&lt;/td>
&lt;td>모든 로컬 트랜잭션을 커밋&lt;/td>
&lt;td>모든 로컬 트랜잭션을 취소&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TC/C&lt;/td>
&lt;td>모든 로컬 트랜잭션이 커밋되거나 취소된 상태로 종료&lt;/td>
&lt;td>필요한 경우 새 로컬 트랜잭션 실행&lt;/td>
&lt;td>이미 커밋된 트랜잭션의 실행 결과를 되돌림&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>TC/C는 &lt;strong>보상 기반 분산 트랜잭션&lt;/strong>(distributed transaction by compensation)이라고도 부른다.&lt;/p>
&lt;ul>
&lt;li>실행 취소 절차를 비즈니스 로직으로 구현하므로 고수준 해법이다.&lt;/li>
&lt;/ul>
&lt;p>장점은 데이터베이스가 트랜잭션을 지원한다면 동작하므로 데이터베이스에 구애받지 않는다.&lt;/p>
&lt;p>하지만 애플리케이션 계층의 비즈니스 로직에서 세부 사항을 관리하고 분산 트랜잭션의 복잡성을 관리해야한다.&lt;/p>
&lt;h4 id="단계별-상태-테이블">단계별 상태 테이블&lt;/h4>
&lt;p>TC/C 실행 도중 지갑 서비스가 다시 시작된다면 과거 모든 작업 기록이 사라질 수 있으며, 이로인해 어떻게 복구해야 할지 알 수 없게 된다.&lt;/p>
&lt;p>해결책은 간단한데, TC/C의 진행 상황, 특히 각 단계 상태 정보를 트랜잭션 데이터베이스에 저장하면 된다.&lt;/p>
&lt;p>이를 위해 상태 정보는 최소한 다음 내용을 포함해야한다.&lt;/p>
&lt;ul>
&lt;li>분산 트랜잭션의 ID와 내용&lt;/li>
&lt;li>각 데이터베이스에 대한 시도(Try) 단계의 상태
&lt;ul>
&lt;li>&lt;code>not sent yet&lt;/code>, &lt;code>has been sent&lt;/code>, &lt;code>response received&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>두 번째 단계의 이름
&lt;ul>
&lt;li>&lt;code>Confirm&lt;/code>, &lt;code>Cancel&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>두 번째 단계의 상태&lt;/li>
&lt;li>순서가 어긋났음을 나타내는 플래그&lt;/li>
&lt;/ul>
&lt;p>단계별 상태 테이블(phase status table)은 일반적으로 돈을 인출할 지갑의 계정이 있는 데이터베이스에 둔다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_7.png"
width="1474"
height="800"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_7_hud4669546e1f63e17e27a3072a8f66c9b_70447_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_7_hud4669546e1f63e17e27a3072a8f66c9b_70447_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="단계별 상태 테이블"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/p>
&lt;h4 id="불균형-상태">불균형 상태&lt;/h4>
&lt;p>모든 것이 순조롭게 진행된다고 가정하면 시도 단계가 끝났을 때 계정 A에서 1달러가 차감되고, 계정 C는 변화가 없다.&lt;/p>
&lt;p>이는 계좌의 총 잔고가 TC/C를 시작 시점보다 작은 값임을 의미하며, 거래 후에도 잔액 총합은 동일해야 한다는 회계 기본 원칙을 위반한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_8.png"
width="1972"
height="814"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_8_hucced9b9d9b1395df44ced0afa86b2d62_121957_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_8_hucced9b9d9b1395df44ced0afa86b2d62_121957_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="불균형 상태"
class="gallery-image"
data-flex-grow="242"
data-flex-basis="581px"
>&lt;/p>
&lt;p>다행스럽게도 트랜잭션 보증(transactional guarantee)은 TC/C 방안에서도 여전히 유효하다.&lt;/p>
&lt;p>TC/C는 여러 개의 독립적인 로컬 트랜잭션으로 구성된다.&lt;/p>
&lt;ul>
&lt;li>TC/C의 실행 주체는 애플리케이션이며, 애플리케이션은 이런 독립적 로컬 트랜잭션이 만드는 중간 결과를 볼 수 있다.&lt;/li>
&lt;li>데이터베이스 트랜잭션이나 2PC 같은 분산 트랜잭션의 경우 실행 주체는 데이터베이스이며 애플리케이션은 중간 실행 결과를 알 수 없다.&lt;/li>
&lt;/ul>
&lt;p>분산 트랜잭션 실행 도중에는 &lt;strong>항상 데이터의 불일치&lt;/strong>가 발생한다.&lt;/p>
&lt;p>데이터베이스와 같은 하위 시스템에서 불일치를 수정하는 경우에는 그 사실을 알 필요는 없지만, TC/C 같은 메커니즘을 사용하는 경우에는 직접 처리해야한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>유효한 연산 순서&lt;/strong>&lt;/p>
&lt;p>시도 단계에서 할 수 있는 일은 세 가지다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>선택지&lt;/th>
&lt;th>A&lt;/th>
&lt;th>B&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>선택 1&lt;/td>
&lt;td>-$1&lt;/td>
&lt;td>NOP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>선택 2&lt;/td>
&lt;td>NOP&lt;/td>
&lt;td>+$1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>선택 3&lt;/td>
&lt;td>-$1&lt;/td>
&lt;td>+$1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>두 번째 선택지의 경우, 계정 C의 연산은 성공하였으나 계정 A에서 실패한 경우(NOP) 지갑 서비스는 취소 단계를 실행해야 한다.&lt;/p>
&lt;ul>
&lt;li>취소 단계 실행 전 누군가 C 게정에서 1달러를 이체하였다면, C에서 1달러를 차감하려 할 때 남은 잔액이 없기때문에 분산 트랜잭션의 트랜잭션 보증을 위반하게된다.&lt;/li>
&lt;/ul>
&lt;p>세 번째 선택지의 경우, 1달러를 A에서 차감하고 동시에 C에 추가하면 많은 문제가 발생할 수 있다.&lt;/p>
&lt;ul>
&lt;li>C 계좌에서 1달러를 추가하였으나 A에서 1달러를 차감하는 연산을 실패한다면 유효하지 않다.&lt;/li>
&lt;/ul>
&lt;p>따라서 선택지 1만 올바른 방법이다.&lt;/p>
&lt;h4 id="잘못된-순서로-실행된-경우">잘못된 순서로 실행된 경우&lt;/h4>
&lt;p>TC/C에는 실행 순서가 어긋날 수 있다는 문제가 있다.&lt;/p>
&lt;p>시도 단계에서 A에 대한 작업이 실패하여 지갑 서비스에 실패를 반환한 다음 취소 단계로 진입하여 A와 C 모두에 취소 명령을 전송하는 과정에 계정 C를 관리하는 데이터베이스의 네트워크 문제로 시도 명령 전 취소 명령부터 받게 되었다고 가정한다.&lt;/p>
&lt;ul>
&lt;li>그 시점에서 취소할 것이 없는 상태&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_9.png"
width="1690"
height="720"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_9_hubc311339aed0d3059e9d61a5ed30dd39_75845_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_9_hubc311339aed0d3059e9d61a5ed30dd39_75845_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="잘못된 순서로 명령이 실행되는 시나리오"
class="gallery-image"
data-flex-grow="234"
data-flex-basis="563px"
>&lt;/p>
&lt;p>순서가 바뀌어 도착하는 명령도 처리할 수 있도록 하려면 기존 로직을 다음과 같이 수정하면 된다.&lt;/p>
&lt;ul>
&lt;li>취소 명령이 먼저 도착하면 데이터베이스에 아직 상응하는 시도 명령을 못 보았음을 나타내는 플래그를 참으로 설정하여 저장해둔다.&lt;/li>
&lt;li>시도 명령이 도착하면 항상 먼저 도착한 취소 명령이 있었는지 확인한다.
&lt;ul>
&lt;li>있다면 바로 실패를 반환한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>단계별 상태 테이블 절에서 테이블에 순서가 어긋난 경우를 처리하기 위한 플래그를 마련했던 것은 이를 위해서이다.&lt;/p>
&lt;h3 id="분산-트랜잭션-사가">분산 트랜잭션: 사가&lt;/h3>
&lt;h4 id="선형적-명령-수행">선형적 명령 수행&lt;/h4>
&lt;p>사가는 유명한 분산 트랜잭션 솔루션 가운데 하나로 MSA 에서는 사실상 표준이다.&lt;/p>
&lt;ul>
&lt;li>모든 연산은 순서대로 정렬된다.
&lt;ul>
&lt;li>각 연산은 자기 데이터베이스에 독립적인 트랜잭션으로 실행된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>연산은 첫 번째부터 마지막 순서대로 실행된다.
&lt;ul>
&lt;li>한 연산이 완료되면 다음 연산이 개시된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>연산이 실패하면 전체 프로세스는 실패한 연산부터 맨 처음 연산까지 역순으로 보상 트랜잭션을 통해 롤백된다.
&lt;ul>
&lt;li>n개의 연산을 실행하는 분산 트랜잭션은 보상 트랜잭션을 위한 n개의 연산까지 총 2n개의 연산을 준비해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_11.png"
width="1370"
height="858"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_11_hu7c215391fe3e027ba38ddce1f1c34f27_35915_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_11_hu7c215391fe3e027ba38ddce1f1c34f27_35915_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="사가의 작업 흐름"
class="gallery-image"
data-flex-grow="159"
data-flex-basis="383px"
>&lt;/p>
&lt;p>오류가 발생하면 이체는 롤백되고 클라이언트는 오류 메시지를 받는다.&lt;/p>
&lt;p>&lt;strong>유효한 연산 순서&lt;/strong>에서 언급했듯 입금 전 인출부터 해야하는데, &lt;strong>연산 실행 순서 조율&lt;/strong>은 2가지 방법을 활용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>분산 조율(Choreography, 안무)
&lt;ul>
&lt;li>사가 분산 트랜잭션에 관련된 모든 서비스가 다른 서비스의 이벤트를 구독하여 작업을 수행하는 방식&lt;/li>
&lt;li>완전히 탈 중앙화된 조율 방식&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>중앙 집중형 조율(Orchestration)
&lt;ul>
&lt;li>하나의 조정자(coordinator)가 모든 서비스가 올바른 순서로 작업을 실행하도록 조율&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>어떤 방식을 활용할지는 사업상의 필요와 목표에 따라 정한다.&lt;/p>
&lt;p>분산 조율 방식은 서비스가 서로 비동기식으로 통신하므로 모든 서버스는 다른 서비스가 발생시킨 이벤트 결과로 어떤 작업을 수행할지 정하기 위해 내부적으로 상태 기계를 유지해야한다.&lt;/p>
&lt;ul>
&lt;li>서비스가 많으면 관리가 어려워질 수 있다.&lt;/li>
&lt;/ul>
&lt;p>일반적으로 &lt;strong>복잡한 상황을 잘 처리하는 중앙 집중형 조율 방식&lt;/strong>이 선호된다.&lt;/p>
&lt;h3 id="tcc-vs-사가">TC/C vs 사가&lt;/h3>
&lt;p>모두 애플리케이션 수준 분산 트랜잭션이지만 차이점도 존재한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>TC/C&lt;/th>
&lt;th>사가&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>보상 트랜잭션 실행&lt;/td>
&lt;td>취소 단계에서&lt;/td>
&lt;td>롤백 단계에서&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>중앙 조정&lt;/td>
&lt;td>예&lt;/td>
&lt;td>예(중앙 집중형 조율 모드)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>작업 실행 순서&lt;/td>
&lt;td>임의&lt;/td>
&lt;td>선형&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>병렬 실행 가능성&lt;/td>
&lt;td>예&lt;/td>
&lt;td>아니오(선형적 실행)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>일시적으로 일관되지 않은 상태 허용&lt;/td>
&lt;td>예&lt;/td>
&lt;td>예&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구현 계층: 애플리케이션 또는 데이터베이스&lt;/td>
&lt;td>애플리케이션&lt;/td>
&lt;td>애플리케이션&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>실무에서는 지연 시간(latency) 요구사항에 따라 둘 가운데 하나를 선택하면 된다.&lt;/p>
&lt;ul>
&lt;li>지연 시간 요구사항이 없거나 앞서 살펴본 송금 사례처럼 서비스 수가 매우 적다면 아무거나 쓴다.
&lt;ul>
&lt;li>MSA에서 흔히 하는데로 하고싶다면 사가를 선택&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지연 시간에 민감하고 많은 서비스/운영이 관계된 시스템이라면 TC/C가 더 낫다.&lt;/li>
&lt;/ul>
&lt;h3 id="이벤트-소싱">이벤트 소싱&lt;/h3>
&lt;p>분산 트랜잭션 방안도 제대로 작동하지 않는 경우가 있을 수 있다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션 수준에서 잘못 된 작업을 입력(입력된 금액 자체가 잘못됨)&lt;/li>
&lt;/ul>
&lt;p>문제의 근본 원인을 역추적하고 모든 계정에서 발생하는 연산을 감사할 방법이 있으면 좋다.&lt;/p>
&lt;p>전자 지갑 서비스 제공 업체도 외부 감사를 받을 수 있다.&lt;/p>
&lt;ul>
&lt;li>특정 시점의 계정 잔액은?&lt;/li>
&lt;li>과거 및 현재 계정 잔액이 정확한지?&lt;/li>
&lt;li>코드 변경 후에도 시스템 로직이 올바른지 검증 방법은?&lt;/li>
&lt;/ul>
&lt;p>이러한 질문에 체계적으로 답할 수 있는 설계 철학 중 하나는 &lt;strong>도메인 주도 설계&lt;/strong>(Domain-Driven Design, DDD)에서 개발된 기법인 이벤트 소싱이다.&lt;/p>
&lt;h4 id="정의">정의&lt;/h4>
&lt;p>이벤트 소싱에는 네가지 중요한 용어가 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>명령&lt;/strong>&lt;/p>
&lt;p>명령은 외부에서 전달된, 의도가 명확한 요청이다.&lt;/p>
&lt;ul>
&lt;li>ex) A에서 C로 1달러 이체&lt;/li>
&lt;/ul>
&lt;p>이벤트 소싱에서 순서는 아주 중요하므로 명령은 일반적으로 FIFO 큐에 저장된다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>이벤트&lt;/strong>&lt;/p>
&lt;p>명령은 의도가 명확하지만 사실(fact)는 아니기 때문에 유효하지 않을 수도 있다.&lt;/p>
&lt;p>유효하지 않은 명령은 실행할 수 없다.&lt;/p>
&lt;ul>
&lt;li>ex) 이체 후 잔액이 음수가 된다면 이체는 실패한다.&lt;/li>
&lt;/ul>
&lt;p>작업 이행 전에는 반드시 명령의 유효성을 검사해야 한다. 그리고 검사를 통과한 명령은 반드시 이행(fulfill)되어야 한다.&lt;/p>
&lt;p>이렇게 이행된 결과를 이벤트라고 부른다.&lt;/p>
&lt;ul>
&lt;li>이벤트는 검증된 사실로 실행이 끝난 상태이다.
&lt;ul>
&lt;li>이벤트에 대해 이야기 할 때는 과거 시제를 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>명령에는 무작위성(randomness)이나 I/O가 포함될 수 있지만 이벤트는 결정론적(deterministic)이다.
&lt;ul>
&lt;li>이벤트는 과거에 실제로 있었던 일이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이벤트 생성 프로세스에는 두 가지 중요한 특성이 있다.&lt;/p>
&lt;ul>
&lt;li>하나의 명령으로 여러 이벤트가 만들어질 수 있다.(0 이상)&lt;/li>
&lt;li>이벤트 생성 과정에는 무작위성이 개입될 수 있어 같은 명령에 항상 동일한 이벤트들이 만들어진다는 보장이 없다.
&lt;ul>
&lt;li>이벤트 생성 과정에는 외부 I/O 또는 난수가 개입될 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이벤트 순서는 명령 순서를 따라야하므로 이벤트도 FIFO 큐에 저장한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>상태&lt;/strong>&lt;/p>
&lt;p>상태는 이벤트가 적용될 때 변경되는 내용이다.&lt;/p>
&lt;p>지갑 시스템에서 상태는 모든 클라이언트 계정의 잔액으로, 맵 자료 구조로 표현할 수 있다.&lt;/p>
&lt;ul>
&lt;li>키는 계정 이름 또는 ID&lt;/li>
&lt;li>값은 계정 잔액&lt;/li>
&lt;/ul>
&lt;p>관계형 데이터베이스도 키-값 저장소로 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>키는 PK, 값은 레코드&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>상태 기계&lt;/strong>&lt;/p>
&lt;p>상태 기계는 이벤트 소싱 프로세스를 구동한다.&lt;/p>
&lt;ul>
&lt;li>명령의 유효성을 검사하고 이벤트를 생성&lt;/li>
&lt;li>이벤트를 적용하여 상태를 갱신&lt;/li>
&lt;/ul>
&lt;p>이벤트 소싱을 위한 상태 기계는 결정론적으로 동작해야 하므로 무작위성을 내포할 수 없다.&lt;/p>
&lt;ul>
&lt;li>I/O를 통해 외부에서 무작위적 데이터를 읽거나 난수를 사용하는 것은 허용되지 않는다.&lt;/li>
&lt;li>이벤트를 상태에 반영하는 것 또한 항상 같은 결과를 보장해야한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_12.png"
width="1350"
height="586"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_12_hu75775d77e3a277a469275ba0db2d7fcb_32101_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_12_hu75775d77e3a277a469275ba0db2d7fcb_32101_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="정적 관점에서 표현한 이벤트 소싱 아키텍처"
class="gallery-image"
data-flex-grow="230"
data-flex-basis="552px"
>&lt;/p>
&lt;p>명령을 이벤트로 변환하고 이벤트르 적용하는 두 가지 기능을 지원해야 하므로 명령 유효성 검사를 위한 상태 기계 하나와 이벤트 적용을 위한 상태 기계 하나를 둔다.&lt;/p>
&lt;p>여기에 시간을 하나의 차원으로 추가하면 동적 관점으로도 표현할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_13.png"
width="1770"
height="472"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_13_hu9c945e56a87989f709ad84e26a9c6b8b_39233_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_13_hu9c945e56a87989f709ad84e26a9c6b8b_39233_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="동적 관점에서 표현한 이벤트 소싱 아키텍처"
class="gallery-image"
data-flex-grow="375"
data-flex-basis="900px"
>&lt;/p>
&lt;p>명령을 수신하고 처리하는 과정을 계속 반복하는 시스템이다.&lt;/p>
&lt;h4 id="지갑-서비스-예시">지갑 서비스 예시&lt;/h4>
&lt;p>지갑 서비스의 경우 명령은 &lt;strong>이체 요청&lt;/strong>일 것이다.&lt;/p>
&lt;p>명령은 FIFO 큐에 기록하며, 큐로는 카프카를 널리 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_14.png"
width="1418"
height="364"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_14_huc4e4e079d616645a799fbdc27878d67d_22905_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_14_huc4e4e079d616645a799fbdc27878d67d_22905_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="명령 큐"
class="gallery-image"
data-flex-grow="389"
data-flex-basis="934px"
>&lt;/p>
&lt;ul>
&lt;li>상태, 즉 계정 잔액은 관계형 데이터베이스에 있다고 가정&lt;/li>
&lt;/ul>
&lt;p>상태 기계는 명령 큐에 들어간 순서대로 확인한다.&lt;/p>
&lt;p>명령 하나를 읽을 때마다 계정에 충분한 잔액이 있는지 확인하며, 충분하다면 상태 기계는 각 계정에 대한 이벤트를 만든다.&lt;/p>
&lt;ul>
&lt;li>명령이 &lt;code>A -&amp;gt; $1 -&amp;gt; C&lt;/code>라면 &lt;code>A: -$1&lt;/code>, &lt;code>C: +$1&lt;/code> 두 이벤트를 만든다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_15.png"
width="1418"
height="364"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_15_huc4e4e079d616645a799fbdc27878d67d_22905_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_15_huc4e4e079d616645a799fbdc27878d67d_22905_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="상태 기계 동작 원리"
class="gallery-image"
data-flex-grow="389"
data-flex-basis="934px"
>&lt;/p>
&lt;ol>
&lt;li>명령 대기열에서 명령을 읽는다.&lt;/li>
&lt;li>데이터베이스에서 잔액 상태를 읽는다.&lt;/li>
&lt;li>명령의 유효성을 검사하고 유효하면 계정별로 이벤트를 생성한다.&lt;/li>
&lt;li>다음 이벤트를 읽는다.&lt;/li>
&lt;li>데이터베이스의 잔액을 갱신하여 이벤트 적용을 마친다.&lt;/li>
&lt;/ol>
&lt;h4 id="재현성">재현성&lt;/h4>
&lt;p>이벤트 소싱이 다른 아키텍처에 비해 갖는 가장 중요한 장점은 재현성(reproducibility)이다.&lt;/p>
&lt;p>분산 트랜잭션 방안의 경우 지갑 서비스는 갱신한 계정 잔액(상태)을 데이터베이스에 저장하며, 특정 시점의 잔액이 얼마인지만 보여준다.&lt;/p>
&lt;ul>
&lt;li>계정 잔액이 변경된 이유는 알기 어렵다.&lt;/li>
&lt;li>한번 업데이트가 이루어지고 나면 과거 잔액이 얼마였는지는 알 수 없다.&lt;/li>
&lt;/ul>
&lt;p>하지만 이벤트를 처음부터 다시 재생하면 과거 잔액 상태는 언제든 재구성할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_16.png"
width="1404"
height="1044"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_16_hu529a7607382b42a04dfe6f752d90cee3_74655_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_16_hu529a7607382b42a04dfe6f752d90cee3_74655_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="상태 재현"
class="gallery-image"
data-flex-grow="134"
data-flex-basis="322px"
>&lt;/p>
&lt;p>이벤트 리스트는 불변이고(과거의 발생한 이벤트 이력을 변경할 수 없다) 상태 기계 로직은 결정론적이므로 이벤트 이력을 재생하여 만들어낸 상태는 언제나 동일하다.&lt;/p>
&lt;p>재현성을 갖추면 감사관이 던지는 까다로운 질문에 쉽게 답할 수 있다.&lt;/p>
&lt;ul>
&lt;li>특정 시점의 계정 잔액을 알 수 있는가?
&lt;ul>
&lt;li>시작부터 계정 잔액을 알고싶은 시점까지 이벤트를 재생한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>과거 및 현재 계정 잔액이 정확한지 알 수 있는가?
&lt;ul>
&lt;li>이벤트 이력에서 계정 잔액을 다시 계산해 보면 잔액이 정확한지 확인할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>코드 변경 후에도 시스템 로직이 올바른지 증명할 수 있는가?
&lt;ul>
&lt;li>새로운 코드에 동일한 이벤트 이력을 입력으로 주고 같은 결과가 나오는지 확인한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="명령-질의-책임-분리cqrs">명령-질의 책임 분리(CQRS)&lt;/h4>
&lt;p>지금까지 효과적인 계좌 이체가 가능한 지갑 서비스를 설계했다.&lt;/p>
&lt;p>하지만 클라이언트는 여전히 계정 잔액을 알 수 없으므로, 이벤트 소싱 프레임워크 외부의 클라이언트가 상태(잔액)을 알도록 할 방법이 필요하다.&lt;/p>
&lt;p>직관적인 해결책 하나는 상태 이력 데이터베이스의 읽기 전용 사본을 생성한 후 외부와 공유하는 것인데 이벤트 소싱은 이와는 조금 다른 해결책을 제시한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_17.png"
width="1750"
height="1454"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_17_hu15cc75bbcc1ad3d80f056e38d4cac374_130803_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_17_hu15cc75bbcc1ad3d80f056e38d4cac374_130803_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="CQRS 아키텍처"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="288px"
>&lt;/p>
&lt;p>이벤트 소싱은 상태, 즉 계정 잔액을 공개하는 대신 모든 이벤트를 외부에 보낸다.&lt;/p>
&lt;p>따라서 이벤트를 수신하는 외부 주체가 직접 상태를 재구축할 수 있다.&lt;/p>
&lt;p>이런 설계 철학을 &lt;strong>명령-질의 책임 분리&lt;/strong>(Command-Query Responsibility Separation, CQRS)라고 부른다.&lt;/p>
&lt;p>CQRS에서는 상태 기록을 담당하는 상태 기계는 하나고, 읽기 전용 상태 기계는 여러 개 있을 수 있다.&lt;/p>
&lt;p>읽기 전용 상태 기계는 상태 뷰를 만들고, 이 뷰는 질의에 이용된다.&lt;/p>
&lt;p>읽기 전용 상태 기계는 이벤트 큐에서 다양한 상태 표현을 도출할 수 있다.&lt;/p>
&lt;ul>
&lt;li>클라이언트의 잔액 질의 요청을 처리하기 위해 별도 데이터베이스에 상태를 기록한다.&lt;/li>
&lt;li>이중 청구 등의 문제를 쉽게 조사할 수 있도록 하기 위해 특정 기간 동안의 상태를 복원할 수도 있다.&lt;/li>
&lt;/ul>
&lt;p>읽기 전용 상태 기계는 실제 상태에 어느 정도 뒤처질 수 있으나 결국에는 같아지므로 결과적 일관성 모델을 따른다고 할 수 있다.&lt;/p>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>높은 성능과 안정성 및 확장성을 달성하기 위한 기술에 대해 자세히 살펴본다.&lt;/p>
&lt;h3 id="고성능-이벤트-소싱">고성능 이벤트 소싱&lt;/h3>
&lt;p>카프카를 명령 및 이벤트 저장소로, 데이터베이스를 상태 저장소로 사용했는데 가능한 최적화 방안을 살펴본다.&lt;/p>
&lt;h4 id="파일-기반-명령-및-이벤트-목록">파일 기반 명령 및 이벤트 목록&lt;/h4>
&lt;p>&lt;strong>로컬 디스크에 저장하는 방안&lt;/strong>&lt;/p>
&lt;p>명령과 이벤트를 카프카 같은 원격 저장소가 아닌 로컬 디스크에 저장하는 방안을 생각해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>네트워크를 통한 전송 시간을 피할 수 있다.&lt;/li>
&lt;li>이벤트 목록은 추가 연산만 가능한 자료 구조에 저장한다.&lt;/li>
&lt;/ul>
&lt;p>추가는 순차적 쓰기 연산으로 일반적으로 매우 빠르다.&lt;/p>
&lt;ul>
&lt;li>운영체제는 보통 순차적 읽기 및 쓰기 연산에 최적화 되어있어 HDD에서도 잘 작동한다.&lt;/li>
&lt;li>경우에 따라서는 무작위 메모리 접근보다 빠르게 실행될 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>최근 명령과 이벤트를 메모리에 캐시하는 방안&lt;/strong>&lt;/p>
&lt;p>명령과 이벤트는 지속성 저장소에 보관된 이후에 처리되므로, 메모리에 캐시해 놓으면 로컬 디스크에서 다시 로드하지 않아도 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_18.png"
width="1346"
height="1096"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_18_huf431578dc5a373e9fad161237382f0ce_42241_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_18_huf431578dc5a373e9fad161237382f0ce_42241_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="파일 기반의 명령 및 이벤트 저장소"
class="gallery-image"
data-flex-grow="122"
data-flex-basis="294px"
>&lt;/p>
&lt;p>mmap 기술은 앞서 언급한 최적화 구현에 유용하다.&lt;/p>
&lt;ul>
&lt;li>로컬 디스크에 쓰는 동시에 최근 데이터는 메모리에 자동으로 캐시할 수 있다.&lt;/li>
&lt;li>디스크 파일을 메모리 배열에 대응시킨다.&lt;/li>
&lt;/ul>
&lt;p>운영체제는 파일의 특정 부분을 메모리에 캐시하여 읽기 및 쓰기 연산을 높히므로, 추가만 가능한 파일에 이루어지는 연산의 경우 필요한 모든 데이터는 거의 항상 메모리에 있으므로 실행 속도를 높힐 수 있다.&lt;/p>
&lt;h4 id="파일-기반-상태">파일 기반 상태&lt;/h4>
&lt;p>이번 설계안에서는 상태, 즉 잔액 정보를 관계형 데이터베이스에 저장했는데, 프로덕션 환경에서는 일반적으로 네트워크를 통해서만 접근 가능한 독립형 서버에서 데이터베이스를 실행한다.&lt;/p>
&lt;p>그러나 명령 및 이벤트 저장소 최적화 방안과 마찬가지로, 상태 정보도 로컬 디스크에 저장할 수 있다.&lt;/p>
&lt;ul>
&lt;li>파일 기반 로컬 관계형 데이터베이스 SQLite를 사용한다.&lt;/li>
&lt;li>로컬 파일 기반 키-값 저장소 RocksDB를 사용한다.&lt;/li>
&lt;/ul>
&lt;p>본 설계안에서는 쓰기 작업에 최적화된 자료 구조인 LSM(Log-Structured Merge-tree)를 사용하는 RocksDB를 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_19.png"
width="1352"
height="1076"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_19_hud7385ca1b5ecf0e28d3f616ea8ad9a8c_54361_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_19_hud7385ca1b5ecf0e28d3f616ea8ad9a8c_54361_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="명령, 이벤트 및 상태 저장을 위한 파일 기반 아키텍처"
class="gallery-image"
data-flex-grow="125"
data-flex-basis="301px"
>&lt;/p>
&lt;h4 id="스냅숏">스냅숏&lt;/h4>
&lt;p>모든 것이 파일 기반일 때 재현 프로세스의 속도를 높힐 방법을 고민해보자.&lt;/p>
&lt;p>재현성 확보를 위해 사용한 방법은 상태 기계로 하여금 이벤트를 항상 처음부터 다시 읽도록 하는 것 이었는데, 그 대신 주기적으로 상태 기계를 멈추고 현재 상태를 파일에 저장한다면 시간을 절약할 수 있다. 이 파일을 스냅숏 이라고 한다.&lt;/p>
&lt;ul>
&lt;li>스냅숏은 과거 특정 시점의 상태로 변경 불가능하다.&lt;/li>
&lt;li>스냅숏을 저장하고나면 상태 기계는 더 이상 최초 이벤트에서 시작할 필요가 없어진다.
&lt;ul>
&lt;li>어느 시점에 만들어졌는지 확인 후 그 시점부터 이벤트 처리를 시작한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>지갑 서비스 같은 금융 애플리케이션은 00:00에 스냅숏을 찍는 일이 많다.&lt;/p>
&lt;ul>
&lt;li>그래야만 재무팀이 당일 발생한 모든 거래를 확인할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>스냅숏을 사용하면 읽기 전용 상태 기계는 해당 데이터가 포함된 스냅숏 하나만 로드하면 된다.&lt;/p>
&lt;p>일반적으로 스냅숏은 거대한 이진 파일이며, 일반적으로는 HDFS(Hadoop Distributed File System)과 같은 &lt;strong>객체 저장소&lt;/strong>에 저장한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_20.png"
width="1976"
height="952"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_20_hu60d89f48231c83556200ca53f86f867b_88111_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_20_hu60d89f48231c83556200ca53f86f867b_88111_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="스냅숏"
class="gallery-image"
data-flex-grow="207"
data-flex-basis="498px"
>&lt;/p>
&lt;p>모든 것이 파일 기반일 때 시스템은 컴퓨터 하드웨어의 I/O 처리량을 그 한계까지 최대로 활용할 수 있다.&lt;/p>
&lt;h3 id="신뢰할-수-있는-이벤트-소싱">신뢰할 수 있는 이벤트 소싱&lt;/h3>
&lt;p>로컬 파일 기반의 솔루션 성능은 원격 카프카나 데이터베이스에 저장된 데이터를 액세스하는 시스템보다는 좋다고 할 수 있으나, 로컬 디스크에 데이터를 저장하는 서버는 더 이상 무상태 서버가 아니며, 단일 장애 지점이 될 수 있다.&lt;/p>
&lt;h4 id="신뢰성-분석">신뢰성 분석&lt;/h4>
&lt;p>개념적으로 서버 노드가 하는 일은 데이터와 연산이라는 두 가지 개념에 관계되어 있다.&lt;/p>
&lt;p>그러나 데이터 내구성이 보장되는 한, 계산 결과는 코드를 다른 노드에서 돌리면 복구할 수 있다.&lt;/p>
&lt;ul>
&lt;li>데이터 신뢰성이 훨씬 중요하다.&lt;/li>
&lt;li>데이터가 손실되면 계산 결과를 복원할 방법이 없기 때문&lt;/li>
&lt;/ul>
&lt;p>이러한 이유로 시스템 신뢰성 문제는 대부분 데이터 신뢰성 문제이다.&lt;/p>
&lt;ul>
&lt;li>파일 기반 명령
&lt;ul>
&lt;li>이벤트는 명령을 통해 만들어지니 명령의 신뢰성만 강력하게 보장하면 충분할 것 같지만 아니다.&lt;/li>
&lt;li>이벤트 생성은 결정론적 과정이 아니며, 난수나 외부 입축력 등의 무작위적 요소가 포함될 수 있다.&lt;/li>
&lt;li>명령의 신뢰성 만으로는 이벤트의 재현성을 보장할 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파일 기반 이벤트
&lt;ul>
&lt;li>상태(잔액)에 변화를 가져오는 과저의 사실이다.&lt;/li>
&lt;li>이벤트는 불변이며 상태 재구성에 사용할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파일 기반 상태
&lt;ul>
&lt;li>이벤트 목록을 재생하면 언제든 다시 만들 수 있다.(이벤트 목록의 신뢰성을 보장하면 따라온다.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>상태 스냅숏
&lt;ul>
&lt;li>이벤트 목록을 재생하면 언제든 다시 만들 수 있다.(이벤트 목록의 신뢰성을 보장하면 따라온다.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>따라서 &lt;strong>높은 신뢰성을 보장할 유일한 데이터는 이벤트 뿐&lt;/strong>이다.&lt;/p>
&lt;h4 id="합의">합의&lt;/h4>
&lt;p>높은 안정성을 제공하려면 이벤트 목록을 여러 노드에 복제해야 하며 다음을 보장해야한다.&lt;/p>
&lt;ul>
&lt;li>데이터 손실 없음&lt;/li>
&lt;li>로그 파일 내 데이터의 상대적 순서는 모든 노드에 동일&lt;/li>
&lt;/ul>
&lt;p>이러한 목표를 달성하는 데는 &lt;strong>합의 기반 복제&lt;/strong>(consensus-based replication) 방안이 적합하다.&lt;/p>
&lt;ul>
&lt;li>모든 노드가 동일한 이벤트 목록에 합의하도록 보장한다.&lt;/li>
&lt;/ul>
&lt;p>래프트 알고리즘을 사용하면 노드의 절반 이상이 온라인 상태일 때 그 모두에 보관된 추가 전용 리스트는 같은 데이터를 가진다.&lt;/p>
&lt;p>래프트 알고리즘에서 노드는 세 가지 역할을 가질 수 있다.&lt;/p>
&lt;ul>
&lt;li>리더&lt;/li>
&lt;li>후보&lt;/li>
&lt;li>팔로어&lt;/li>
&lt;/ul>
&lt;p>최대 하나의 노드만 클러스터의 리더가 되고 나머지 노드는 팔로어가 된다.&lt;/p>
&lt;p>리더는 외부 명령을 수신하고 클러스터 노드 간에 데이터를 안정적으로 복제하는 역할을 담당한다.&lt;/p>
&lt;h4 id="고신뢰성-솔루션">고신뢰성 솔루션&lt;/h4>
&lt;p>복제 매커니즘을 활용하면 파일 기반 이벤트 소싱 아키텍처에서 단일 장애 지점 문제를 없앨 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_21.png"
width="1588"
height="982"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_21_hu3c5751a41f69567bce8871525f956c20_71049_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_21_hu3c5751a41f69567bce8871525f956c20_71049_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="래프트 노드 그룹"
class="gallery-image"
data-flex-grow="161"
data-flex-basis="388px"
>&lt;/p>
&lt;p>리더는 외부 사용자로 부터 들어오는 명령 요청을 받아 이벤트로 변환하고 로컬 이벤트 목록에 추가한다.&lt;/p>
&lt;ul>
&lt;li>래프트 알고리즘은 새로운 이벤트를 모든 팔로워에 복제한다.&lt;/li>
&lt;/ul>
&lt;p>팔로어를 포함한 모든 노드가 이벤트 목록을 처리하고 상태를 업데이트한다.&lt;/p>
&lt;p>래프트 알고리즘은 리더와 팔로어가 동일한 이벤트 목록을 갖도록 하며, 이벤트 소싱은 동일한 이벤트 목록에서 항상 동일한 상태가 만드러지도록 한다.&lt;/p>
&lt;hr>
&lt;p>리더에 장애가 발생하면 래프트 알고리즘은 나머지 정상 노드 중에서 새 리더를 선출한다.&lt;/p>
&lt;p>유의할 것은 리더 장애가 명령 목록이 이벤트로 변환되기 전에 발생 하는 경우이다.&lt;/p>
&lt;ul>
&lt;li>클라이언트는 시간 초과 또는 오류 응답을 받고 새로 선출된 리더에게 같은 명령을 다시 보내야한다.&lt;/li>
&lt;/ul>
&lt;p>팔로어에 장애가 생기면 래프트는 죽은 노드가 다시 시작되거나 새로운 노드로 대체될 때 까지 기한없이 재시도하여 장애를 처리한다.&lt;/p>
&lt;h3 id="분산-이벤트-소싱">분산 이벤트 소싱&lt;/h3>
&lt;p>100만 TPS를 처리하려면 서버 한 대로는 충분하지 않다.&lt;/p>
&lt;p>지금까지 설계한 아키텍처는 신뢰성 문제는 해결하지만 다른 문제가 있다.&lt;/p>
&lt;ul>
&lt;li>전자 지갑 업데이트 결과는 즉시 받고 싶다.
&lt;ul>
&lt;li>CQRS 시스템에서는 요청/응답 흐름이 느릴 수 있다.&lt;/li>
&lt;li>클라이언트가 지갑의 업데이트 시점을 정확히 알 수 없어 주기적 폴링에 의존해야 할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단일 래프트 그룹의 용량은 제한되어 있다.
&lt;ul>
&lt;li>일정 규모 이상에서는 데이터를 샤딩하고 분산 트랜잭션을 구현해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="풀-vs-푸시">풀 vs 푸시&lt;/h4>
&lt;p>풀 모델에서는 외부 사용자가 읽기 전용 상태 기계에서 주기적으로 실행 상태를 읽는다.&lt;/p>
&lt;p>모델은 실시간이 아니므로 읽는 주기를 너무 짧게 설정하면 지갑 서비스에 과부하가 걸릴 수도 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_22.png"
width="1734"
height="1226"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_22_hu0b1fb98fa497bc80e07967ba8b35831a_91564_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_22_hu0b1fb98fa497bc80e07967ba8b35831a_91564_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="풀 모델"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="339px"
>&lt;/p>
&lt;p>외부 사용자와 이벤트 소싱 사이에 역방향 프락시를 추가하면 개선될 수 있다.&lt;/p>
&lt;p>외부 사용자는 역방향 프락시에 명령을 보내고, 역방향 프락시는 명령을 이벤트 소싱 노드로 전달하는 한편 주기적으로 실행 상태를 질의한다.&lt;/p>
&lt;ul>
&lt;li>여전히 통신이 실시간으로 이루어지지는 앖지만 클라이언트의 로직은 단순해진다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_23.png"
width="1800"
height="1106"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_23_hubdb7fad968784b5f01bb1aa614072f63_92888_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_23_hubdb7fad968784b5f01bb1aa614072f63_92888_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="역방향 프락시가 있는 풀 모델"
class="gallery-image"
data-flex-grow="162"
data-flex-basis="390px"
>&lt;/p>
&lt;p>역방향 프락시르 두고 나면 읽기 전용 상태 기계를 수정하여 응답 속도를 높힐 수 있다.&lt;/p>
&lt;p>일기 전용 상태 기계로 하여금 이벤트를 수신하자마자 &lt;strong>실행 상태를 역방향 프락시에 푸시&lt;/strong>하도록 하면, 사용자에게 실시간으로 응답이 이루어지는 느낌을 줄 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_24.png"
width="1762"
height="1098"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_24_hub9e1ac66749a75fd0bc98ec293c14240_97776_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_24_hub9e1ac66749a75fd0bc98ec293c14240_97776_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="푸시 모델"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="385px"
>&lt;/p>
&lt;h4 id="분산-트랜잭션-1">분산 트랜잭션&lt;/h4>
&lt;p>모든 이벤트 소싱 노드 그룹이 동기적 실행 모델을 채택하면 TC/C나 사가 같은 분산 트랜잭션 솔루션을 재사용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>키의 해시 값을 2로 나누어 데이터가 위치할 파티션을 정한다고 가정&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/12/img_25.png"
width="1428"
height="1564"
srcset="https://codemario318.github.io/post/system-design-interview-2/12/img_25_hu8559c9e43bde10a3e1479c822f75107b_153809_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/12/img_25_hu8559c9e43bde10a3e1479c822f75107b_153809_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="최종 설계"
class="gallery-image"
data-flex-grow="91"
data-flex-basis="219px"
>&lt;/p>
&lt;p>송금에는 2개의 분산 연산(&lt;code>A: -$1&lt;/code>, &lt;code>C: +$1&lt;/code>)이 필요하다.&lt;/p>
&lt;ol>
&lt;li>A가 사가 조정자에게 분산 트랜잭션을 보낸다.(&lt;code>A: -$1&lt;/code>, &lt;code>C: +$1&lt;/code>)&lt;/li>
&lt;li>사가 조정자는 단계별 상태 테이블에 레코드를 생성하여 트랜잭션 상태를 추적한다.&lt;/li>
&lt;li>사가 조정자는 작업 순서를 검토한 후 &lt;code>A: -$1&lt;/code>를 먼저 처리하기로 결정하고 &lt;code>A: -$1&lt;/code> 명령을 계정 정보 A가 있는 파티션 1로 보낸다.&lt;/li>
&lt;li>파티션 1의 래프트 리더는 &lt;code>A: -$1&lt;/code> 명령을 수신하고 명령 목록에 저장한 후, 명령의 유효성을 검사하고 이벤트로 변환한다.
&lt;ul>
&lt;li>래프트 합의 알고리즘을 통해 동기화가 완료되면 이벤트가 실행된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이벤트가 동기화도면 파이션 1의 이벤트 소싱 프레임워크가 CQRS를 사용하여 데이터를 읽기 경로로 동기화한다. 읽기 경로는 상태 및 실행 상태를 재구성한다.&lt;/li>
&lt;li>파티션 1의 읽기 경로는 이벤트 소싱 프레임워크를 호출한 사가 조정자에게 상태를 푸시한다.&lt;/li>
&lt;li>사가 조정자는 파티션 1에서 성공 상태를 수신한다.&lt;/li>
&lt;li>사가 조정자는 단계별 상태 테이블에 파티션 1의 작업이 성공했음을 나타내는 레코드를 생성한다.&lt;/li>
&lt;li>첫 번째 작업이 성공했으므로 사가 조정자는 두 번째 작업인 &lt;code>C: +$1&lt;/code>를 실행한다. 조정자는 계정 C의 정보가 포함된 파티션 2에 명령을 보낸다.&lt;/li>
&lt;li>파티션 2의 래프트 리더가 &lt;code>C: +$1&lt;/code> 명령을 수신하여 명령 목록에 저장한다. 유효한 명령이면 이벤트로 변환되고 데이터를 동기화한다. 동기화가 끝나면 해당 이벤트가 실행된다.&lt;/li>
&lt;li>이벤트가 동기화되면 파티션 2의 이벤트 소싱 프레임워크는 CQRS를 사용하여 데이터 읽기 경로로 동기화한다. 읽기 경로는 상태 및 실행 상태를 재구성ㅎ나다.&lt;/li>
&lt;li>파티션 2읽기 경로는 이벤트 소싱 프레임위크를 호출한 사가 조장자에 상태를 푸시한다.&lt;/li>
&lt;li>사가 조정자는 파티션 2로부터 성공 상태를 받는다.&lt;/li>
&lt;li>사가 조정자는 단계별 상태 테이블에 파티션 2의 작업이 성공했음을 나타내는 레코드를 생성한다.&lt;/li>
&lt;li>모든 작업이 성공하고 분산 트랜잭션이 완료되며 사가 조정자는 호출자에게 결과를 응답한다.&lt;/li>
&lt;/ol>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>이번 장에서는 초당 100만 건 이상 결제 명령을 처리할 수 있는 지갑 서비스를 설계해 보았다.&lt;/p>
&lt;ol>
&lt;li>레디스 같은 인베모리 키-값 저장소를 사용하는 솔루션
&lt;ul>
&lt;li>데이터가 내구성이 없는 문제점&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>인메모리 캐시를 트랜잭션 데이터베이스로 바꿈
&lt;ul>
&lt;li>여러 노드에 걸친 분산 트랜잭션을 지원하기 위한 2PC, TC/C, 사가와 같은 트랜잭션 프로토콜&lt;/li>
&lt;li>데이터 감사가 어렵다는 문제점&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이벤트 소싱 방안
&lt;ol>
&lt;li>외부 데이터베이스와 큐를 사용
&lt;ul>
&lt;li>성능이 떨어짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>명령 이벤트, 상태 데이터를 로컬 파일 시스템에 저장하도록 개선
&lt;ul>
&lt;li>데이터를 한 곳에 두면 SPOF가 되는 문제가 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>래프트 합의 알고리즘을 사용하여 이벤트 목록을 여러 노드에 복제&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>이벤트 소싱에 CQRS 개념 도입&lt;/li>
&lt;li>외부 사용자에게 비동기 이벤트 소싱 프레임워크를 동기식처럼 제공하기 위한 역방향 프락시 추가&lt;/li>
&lt;li>TC/C, 사가 프로토콜을 사용하여 어러 노드에 명령 실행을 조율하는 방법&lt;/li>
&lt;/ol></description></item><item><title>11. 결제 시스템</title><link>https://codemario318.github.io/post/system-design-interview-2/11/</link><pubDate>Sun, 24 Nov 2024 18:10:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/11/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/11/cover.png" alt="Featured image of post 11. 결제 시스템" />&lt;p>이번 장에서는 결제 시스템(Payment system)을 설계한다.&lt;/p>
&lt;p>전자 상거래를 가능하게 하는 것이 바로 결제 시스템이며, 안정적이고 확장 가능하며 유연한 결제 시스템은 필수다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>결제 시스템?&lt;/strong>&lt;br>
결제 시스템은 금전적 가치의 이전을 통해 금융 거래를 정산하는 데 사용되는 모든 시스템&lt;/p>
&lt;/blockquote>
&lt;p>결제 시스템의 구조 자체는 어렵지 않지만, 작은 실수로도 상당한 매출 손실이 발생하고, 사용자의 믿음이 무너질 수 있기 때문에 작업하기 부담스러운 시스템이다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>애플 페이나 구글 페이 같은 &lt;strong>디지털 지갑&lt;/strong>, 페이팔, 스트라이프 같은 &lt;strong>결제 처리 백엔드&lt;/strong>모두 결제 시스템 이므로, 면접을 시작할 때 정확한 요구사항을 파악하여 설계를 시작해야한다.&lt;/p>
&lt;ul>
&lt;li>Q. 어떤 결제 시스템?
&lt;ul>
&lt;li>A. 전자상거래 애플리케이션을 위한 결제 백엔드 구축, 돈의 흐름에 대한 모든 것을 처리해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 어떤 결제 방법 지원?
&lt;ul>
&lt;li>A. 이번 면접에서는 신용 카드 결제만 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 신용 카드 결제 처리를 직접 수행?
&lt;ul>
&lt;li>A. 전문 결제 서비스 업체 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 신용 카드 데이터를 시스템에 저장?
&lt;ul>
&lt;li>A. 보안 및 법규 준수에 대한 어려움으로 결제 처리 업체에 의존&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 다양한 통화 및 국제 결제 지원?
&lt;ul>
&lt;li>A. No&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 하루에 발생하는 결제 건수는?
&lt;ul>
&lt;li>A. 100만건&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 정산 처리 지원?
&lt;ul>
&lt;li>A. Yes&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 다른 주의사항은?
&lt;ul>
&lt;li>A. 많은 내부 서비스 및 외부 서비스와 연동하므로 조정 작업을 통해 불일치를 발견하고 교정해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="기능-요구사항">기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>대금 수신(pay-in) 흐름
&lt;ul>
&lt;li>결제 시스템이 판매자를 대신하여 고객으로부터 대금을 수령&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>대금 정산(pay-out) 흐름
&lt;ul>
&lt;li>결제 시스템이 전 세계의 판매자에게 제품 판매 대금을 송금&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>신뢰성 및 내결함성
&lt;ul>
&lt;li>결제 실패는 신중하게 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>내부 서비스(결제, 회계)와 외부 서비스(결제 서비스 제공 업체) 간 조정 프로세스
&lt;ul>
&lt;li>시스템 간의 결제 정보가 일치하는지 비동기적으로 확인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;p>하루에 100만 건의 트랜잭션을 처리해야하므로 &lt;code>1,000,000 만건 / 10^5초 = 10 TPS&lt;/code>이다.&lt;/p>
&lt;p>10TPS는 일반적인 데이터베이스로 별 문제 없이 처리 가능한 양이므로, 처리 대역폭 대신 결제 트랜잭션의 정확한 처리에 초점을 맞춰 진행해야한다.&lt;/p>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/11/img.png"
width="1304"
height="474"
srcset="https://codemario318.github.io/post/system-design-interview-2/11/img_hub87ab82242e12f226db74e6d71d5c77c_32359_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/11/img_hub87ab82242e12f226db74e6d71d5c77c_32359_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="간소화된 수신 및 정산 흐름"
class="gallery-image"
data-flex-grow="275"
data-flex-basis="660px"
>&lt;/p>
&lt;h3 id="대금-수신-흐름">대금 수신 흐름&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/11/img_1.png"
width="1792"
height="952"
srcset="https://codemario318.github.io/post/system-design-interview-2/11/img_1_hu3624bdba9d5208e07ab505f252807012_241034_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/11/img_1_hu3624bdba9d5208e07ab505f252807012_241034_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="대금 수신 흐름"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="451px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>결제 서비스&lt;/strong>&lt;/p>
&lt;p>사용자로부터 결제 이벤트를 수락하고 결제 프로세스를 조율하는데, 일반적으로 가장 먼저 위험 점검(risk check)을 수행한다.&lt;/p>
&lt;ul>
&lt;li>AML/CFT 같은 규정을 준수 여부 확인&lt;/li>
&lt;li>자금 세탁이나 테러 자금 조달과 같은 범죄 행위의 증거가 있는지 평가&lt;/li>
&lt;/ul>
&lt;p>위험 확인 서비스는 매우 복잡하고 고도로 전문화되어 있기 때문에 제3자 제공 업체를 이용한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>결제 실행자&lt;/strong>&lt;/p>
&lt;p>결제 서비스 공급자(PSP)를 통해 결제 주문(payment order) 하나를 실행한다.&lt;/p>
&lt;ul>
&lt;li>하나의 결제 이벤트에는 여러 결제 주문이 포함될 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>결제 서비스 공급자&lt;/strong>&lt;/p>
&lt;p>PSP(Payment Service Provider)는 A 계정에서 B 계정으로 돈을 옮기는 역할을 담당한다.&lt;/p>
&lt;ul>
&lt;li>구매자의 신용 카드 계좌에서 돈을 인출하는 역할 등&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>카드 유형&lt;/strong>&lt;/p>
&lt;p>카드사는 신용 카드 업무를 처리하는 조직이다.&lt;/p>
&lt;ul>
&lt;li>비자, 마스터카드 등&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>원장 ledger&lt;/strong>&lt;/p>
&lt;p>결제 트랜잭션에 대한 금융 기록이다.&lt;/p>
&lt;ul>
&lt;li>사용자가 판매자에게 1달러를 결제하면 사용자로부터 1달러 인출, 판매자에게 1달러 지급하는 기록&lt;/li>
&lt;/ul>
&lt;p>원장 시스템은 전자상거래 웹사이트의 총 수익을 계산하거나 향후 수익을 예측하는 등, 결제 후 분석(post-payment analysis)에서 매우 중요한 역할을 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>지갑&lt;/strong>&lt;/p>
&lt;p>판매자의 계정 잔액을 기록한다.&lt;/p>
&lt;ul>
&lt;li>특정 사용자가 결제한 총 금액을 기록할 수도 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="결제-서비스-api">결제 서비스 API&lt;/h3>
&lt;hr>
&lt;p>&lt;strong>&lt;code>POST /v1/payments&lt;/code>&lt;/strong>&lt;/p>
&lt;p>결제 이벤트를 실행한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>하나의 결제 이벤트에는 여러 결제 주문이 포함될 수 있다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>buyer_info&lt;/code>&lt;/p>
&lt;ul>
&lt;li>구매자 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>checkout_id&lt;/code>&lt;/p>
&lt;ul>
&lt;li>해당 결제 이벤트를 식별하는 전역적으로 고유한 ID&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>credit_card_info&lt;/code>&lt;/p>
&lt;ul>
&lt;li>암호화된 신용 카드 정보 또는 결제 토큰.&lt;/li>
&lt;li>PSP마다 다름&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>payment_orders&lt;/code>&lt;/p>
&lt;ul>
&lt;li>결제 주문 목록&lt;/li>
&lt;li>&lt;code>payment_order&lt;/code>
&lt;ul>
&lt;li>&lt;code>seller_account&lt;/code>&lt;/li>
&lt;li>&lt;code>amount&lt;/code>
&lt;ul>
&lt;li>&lt;code>double&lt;/code>같은 자료형은 반올림 오차, 화폐 단위의 차이 등으로 인해 &lt;code>string&lt;/code>으로 사용하는 것이 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>currency&lt;/code>&lt;/li>
&lt;li>&lt;code>payment_order_id&lt;/code>
&lt;ul>
&lt;li>전역적으로 고유한 ID&lt;/li>
&lt;li>결제 실행자가 중복 제거를 위한 멱등키로 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/payments/{:id}&lt;/code>&lt;/strong>&lt;/p>
&lt;p>&lt;code>payment_order_id&lt;/code>가 가르키는 단일 결제 주문의 실행 상태를 반환한다.&lt;/p>
&lt;hr>
&lt;h3 id="결제-서비스-데이터-모델">결제 서비스 데이터 모델&lt;/h3>
&lt;p>결제 이벤트와 결제 주문 두 개의 테이블이 필요하다.&lt;/p>
&lt;p>결제 시스템용 저장소 솔루션을 고를 때 일반적으로 성능은 가장 중요한 고려사항은 아니며, 다음 사항에 중점을 둬야한다.&lt;/p>
&lt;ul>
&lt;li>안정성
&lt;ul>
&lt;li>다른 대형 금융 회사에서 긴 기간동안 긍정적인 피드백을 받으며 사용된 적이 있는가?&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모니터링 및 데이터 탐사
&lt;ul>
&lt;li>관련 기능을 위한 도구가 풍부하게 지원되는가?&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>인재풀
&lt;ul>
&lt;li>데이터베이스 관리자 채용 시장의 성숙도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>일반적으로는 NoSQL/NewSQL 보다는 ACID 트랜잭션을 지우너하는 전통적인 관계형 데이터베이스를 선호한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
PaymentEvent {
checkout_id string PK
buyer_info string
seller_info string
credit_card_info string
is_payment_done boolean
}
&lt;/pre>
&lt;ul>
&lt;li>한번의 결제 행위는 하나의 결제 이벤트를 만들고, 하나의 결제 이벤트에는 여러 개의 결제 주문이 포함될 수 있다.&lt;/li>
&lt;li>사용자의 결제를 처리하는 중에는 판매자의 응행 계좌가 아닌 구매자의 카드 정보만 필요하다.&lt;/li>
&lt;/ul>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
PaymentOrder {
payment_order_id string pk
buyer_account string
amount string
currency string
checkout_id string FK
payment_order_status string
ledger_updated boolean
wallet_updated boolean
}
&lt;/pre>
&lt;p>&lt;code>payment_order_status&lt;/code>는 결제 주문의 실행 상태를 유지하는 열거 자료형이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>NOT_STARTED&lt;/code>, &lt;code>EXECUTING&lt;/code>, &lt;code>SUCCESS&lt;/code>, &lt;code>FAILED&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>업데이트 로직의 흐름은 다음과 같다.&lt;/p>
&lt;ol>
&lt;li>초기값은 &lt;code>NOT_STARTED&lt;/code>&lt;/li>
&lt;li>결제 서비스는 결제 실행자에 주문을 전송하면 &lt;code>payment_order_status&lt;/code>의 값을 &lt;code>EXECUTING&lt;/code>으로 바꾼다.&lt;/li>
&lt;li>결제 서비스는 결제 처리자의 응답에 따라 &lt;code>payment_order_status&lt;/code>의 값을 &lt;code>SUCCESS&lt;/code> 또는 &lt;code>FAIL&lt;/code>로 바꾼다.&lt;/li>
&lt;/ol>
&lt;p>&lt;code>payment_order_status&lt;/code> 값이 &lt;code>SUCCESS&lt;/code>로 결정되면 결제 서비스는 지갑 서비스를 호출하여 판매자 잔액을 업데이트하고, &lt;code>wallet_updated&lt;/code> 필드의 값은 &lt;code>true&lt;/code>로 업데이트한다.&lt;/p>
&lt;p>이 절차가 끝나면 결제 서비스는 원장 서비스를 호출하여 &lt;code>ledger_updated&lt;/code> 필드를 &lt;code>true&lt;/code>로 갱신한다.&lt;/p>
&lt;p>동일한 &lt;code>check_id&lt;/code> 아래의 모든 결제 주문이 성공적으로 처리되면 결제 서비스는 결제 이벤트 테이블의 &lt;code>is_payment_done&lt;/code>을 &lt;code>true&lt;/code>로 업데이트한다.&lt;/p>
&lt;p>일반적으로 종결되지 않은 결제 주문을 모니터링 하기 위해 주기적으로 실행되는 작업을 마련해둔다.&lt;/p>
&lt;ul>
&lt;li>임계값 형태로 설정된 기간이 지나도록 완료되지 않은 결제 주문이 있을 경우 살펴보도록 엔지니어에게 경보를 보낸다.&lt;/li>
&lt;/ul>
&lt;h3 id="복식부기-원장-시스템">복식부기 원장 시스템&lt;/h3>
&lt;p>원장 시스템에는 복식부기(double-entry)라는 중요한 설계 원칙이 있다.&lt;/p>
&lt;ul>
&lt;li>복식부기 회계(accounting)/부기(bookeeping)라고도 한다.&lt;/li>
&lt;/ul>
&lt;p>복식부기는 모든 결제 시스템에 필수 요소이며 정확한 기록을 남기는 데 핵심적 역할을 한다.&lt;/p>
&lt;p>모든 결제 거래를 두 개의 별도 원장 계좌에 같은 금액으로 기록하며, 한 계좌에서는 차감, 다른 계좌에서는 입금이 이루어진다.&lt;/p>
&lt;p>복식부기 시스템에서 모든 거래 항목의 합계는 0이어야 한다.&lt;/p>
&lt;p>이 시스템을 활용하면 자금의 흐름을 시작부터 끝까지 추적할 수 있으며, 결제 주기 전반에 걸쳐 일관성을 보장할 수 있다.&lt;/p>
&lt;h3 id="외부-결제-페이지">외부 결제 페이지&lt;/h3>
&lt;p>대부분 기업은 신용 카드 정보를 내부에 저장하면 복잡한 규정을 준수해야 하므로 저장하지 않는다.&lt;/p>
&lt;p>따라서 PSP에서 제공하는 **외부 신용 카드 페이지(hosted credit card page)**를 사용한다.&lt;/p>
&lt;ul>
&lt;li>위젯, iframe, SDK등&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/11/img_2.png"
width="1394"
height="1470"
srcset="https://codemario318.github.io/post/system-design-interview-2/11/img_2_hud667a892ca5bb7d7af3ab9644c7b029d_300845_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/11/img_2_hud667a892ca5bb7d7af3ab9644c7b029d_300845_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="페이팔 외부 결제 페이지"
class="gallery-image"
data-flex-grow="94"
data-flex-basis="227px"
>&lt;/p>
&lt;p>이를 통해 우리 결제 서비스가 아닌 PSP가 제공하는 외부 결제 페이가 직접 고객 카드 정보를 수집한다.&lt;/p>
&lt;h3 id="대금-정산-흐름">대금 정산 흐름&lt;/h3>
&lt;p>대금 수신 흐름과 아주 유사하다.&lt;/p>
&lt;p>한 가지 차이는 PSP를 사용하여 구매자의 신용 카드에서 전자 상거래 웹사이트 은행 계좌로 돈을 이체하는 대신, 타사 정산 서비스를 사용하여 전자 상거래 웹사이트 은행 계좌에서 판매자 은행 계좌로 돈을 이체한다.&lt;/p>
&lt;p>일반적으로 외상 매입금(accounts payable) 지급 서비스 제공 업체를 이용한다.&lt;/p>
&lt;ul>
&lt;li>마찬가지로 다양한 규제 요구사항들이 있기 때문&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>이번 절에서는 시스템을 더 빠르고 강력하며 안전하게 만드는 데 초점을 맞춘다.&lt;/p>
&lt;ul>
&lt;li>분산 시스템에서 오류와 장애는 피할 수 없을 뿐만 아니라 흔하다.&lt;/li>
&lt;/ul>
&lt;h3 id="psp-연동">PSP 연동&lt;/h3>
&lt;p>결제 시스템이 카드 시스템에 직접 연결할 수 있다면 PSP 없이도 결제할 수 있지만, 매우 큰 회사만 가능하여 특수한 경우로 간주한다.&lt;/p>
&lt;p>대부분 회사는 두 가지 방법 중 하나로 결제 시스템을 PSP와 연동한다.&lt;/p>
&lt;ul>
&lt;li>민감 정보를 안전하게 저장할 수 있다면 API를 통해 PSP와 연동한다.
&lt;ul>
&lt;li>회사는 결제 웹페이지 개발, 민감 정보 수집&lt;/li>
&lt;li>PSP는 은행 연결, 다양한 카드 지원&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>민감 정보를 저장하지 않는다면 PSP를 전부 활용
&lt;ul>
&lt;li>대부분 기업들이 택하는 접근법&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/11/img_3.png"
width="1936"
height="1088"
srcset="https://codemario318.github.io/post/system-design-interview-2/11/img_3_hu8ada61af5d55bc7a710f124ce0a3c467_292077_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/11/img_3_hu8ada61af5d55bc7a710f124ce0a3c467_292077_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="외부 결제 페이지 이용 흐름"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="427px"
>&lt;/p>
&lt;h3 id="조정">조정&lt;/h3>
&lt;p>시스템 구성 요소가 비동기적으로 통신하는 경우 메시지가 전달되거나 응답이 반환된다는 보장이 없다.&lt;/p>
&lt;ul>
&lt;li>시스템 성능을 높이기 위해 비동기 통신을 자주 사용하는 결제 관련 사업에 일반적인 문제&lt;/li>
&lt;/ul>
&lt;p>PSP나 은행 같은 외부 시스템도 비동기 통신을 선호하므로 조정을 통해 정확성을 보장할 수 있어야한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>조정 Reconciliation&lt;/strong>&lt;br>
관련 서비스 간의 상태를 주기적으로 비교하여 일치하는지 확인하며, 일반적으로 결제 시스템의 마지막 방어선으로 받아들여진다.&lt;/p>
&lt;/blockquote>
&lt;p>매일 밤 PSP나 은행은 고객에게 정산 파일을 보낸다.&lt;/p>
&lt;ul>
&lt;li>은행 계좌의 잔액, 하루 동안 계좌에서 발생한 모든 거래 내역이 기재&lt;/li>
&lt;/ul>
&lt;p>조정 시스템은 정산 파일의 세부 정보를 읽어 원장 시스템과 비교한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/11/img_4.png"
width="1758"
height="938"
srcset="https://codemario318.github.io/post/system-design-interview-2/11/img_4_hue9673b3cc4643caa7ab63a0b1cac71c6_254873_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/11/img_4_hue9673b3cc4643caa7ab63a0b1cac71c6_254873_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="조정"
class="gallery-image"
data-flex-grow="187"
data-flex-basis="449px"
>&lt;/p>
&lt;p>조정은 결제 시스템의 내부 일관성을 확인할 때도 사용된다.&lt;/p>
&lt;ul>
&lt;li>원장과 지갑의 상태가 같은지 확인&lt;/li>
&lt;/ul>
&lt;p>조정 중 발견된 차이는 일반적으로 재무팀에 의뢰하여 수동으로 고치게되느데 발생 가능한 불일치 문제 및 해결 방안은 세 가지 범주로 나눌 수 있다.&lt;/p>
&lt;ul>
&lt;li>어떤 유형의 문제인지 알고 있으며 문제 해결 절차를 자동화할 수 있는 경우
&lt;ul>
&lt;li>자동화 프로그램을 작성하는 것이 효율적이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>어떤 유형의 문제인지는 알니만 자동화할 수 없는 경우
&lt;ul>
&lt;li>작업 대기열에 넣고 재무팀에서 수동으로 수정하도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>분류할 수 없는 유형 문제인 경우
&lt;ul>
&lt;li>특별 작업 대기열에 넣고 재무팀에서 조사하도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="결제-지연-처리">결제 지연 처리&lt;/h3>
&lt;p>결제 요청은 많은 컴포넌트를 거치며, 내부 및 외부의 다양한 처리 주체와 연동한다.&lt;/p>
&lt;p>대부분의 경우 결제 요청은 몇 초만에 처리되지만, 완료되거나 거부되기까지 몇 시간 또는 며칠이 걸리는 경우도 있다.&lt;/p>
&lt;ul>
&lt;li>PSP가 해당 결제 요청의 위험성이 높다고 보고 담당자 검토를 요구하는 경우&lt;/li>
&lt;li>신용 카드사가 구매 확인 용도로 카드 소유자의 추가 정보를 요청하는 3D 보안 인증 같은 추가 보호 장치를 요구하는 경우&lt;/li>
&lt;/ul>
&lt;p>결제 서비스는 처리하는 데 시간이 오래 걸리는 위와 같은 요청에도 대응할 수 있어야 하며, 구매 페이지가 외부 PSP에 호스팅 되는 경우 PSP는 대부분 다음과 같이 처리한다.&lt;/p>
&lt;ul>
&lt;li>결제가 대기 상태임을 알리는 상태 정보를 클라이언트에 반호나하고, 클라이언트는 이를 사용자에게 표시한다.&lt;/li>
&lt;li>우리 회사를 대신하여 대기 중인 결제의 진행 상황을 추적하고, 상태가 바뀌면 PSP에 등록된 웹훅을 통해 결제 서비스에 알린다.&lt;/li>
&lt;/ul>
&lt;p>결제 요청이 최종적으로 완료되면 PSP는 웹훅을 호출한다.&lt;/p>
&lt;p>결제 서비스는 내부 시스템에 기록된 정보를 업데이트하고 고객에게 배송을 완료한다.&lt;/p>
&lt;ul>
&lt;li>어떤 PSP는 웹훅을 통해 결제 서비스에 결제 상태 변경을 알리는 대신, 결제 서비스로 하여금 대기 중인 결제 요청의 상태를 주기적으로 확인하도록 하기도 한다.&lt;/li>
&lt;/ul>
&lt;h3 id="내부-서비스-간-커뮤니케이션">내부 서비스 간 커뮤니케이션&lt;/h3>
&lt;p>두 가지 패턴이 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>동기식 통신&lt;/strong>&lt;/p>
&lt;p>HTTP 같은 동기식 통신은 소규모 시스템에서는 잘 작동하지만 규모가 커지면 단점이 분명해지며, 한 요청에 응답을 만드는 처리 주기는 관련된 서비스가 많을수록 길어진다.&lt;/p>
&lt;ul>
&lt;li>성능 저하
&lt;ul>
&lt;li>처리에 관계된 서비스 가운데 하나에 발생한 성능 문제가 전체 시스템의 성능에 영향을 끼친다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>장애 격리 곤란
&lt;ul>
&lt;li>PSP 등의 서비스에 장애가 발생하면 클라이언트는 더 이상 응답을 받지 못한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>높은 결합도
&lt;ul>
&lt;li>요청 발신자는 수신자를 알아야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>낮은 확정성
&lt;ul>
&lt;li>큐를 버퍼로 사용하지 않고서는 갑작스러운 트래픽 증가에 대응할 수 있도록 시스템을 확장하기 어렵다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>비동기 통신&lt;/strong>&lt;/p>
&lt;p>크게 두가지 점주로 나눌 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/11/img_5.png"
width="1126"
height="1262"
srcset="https://codemario318.github.io/post/system-design-interview-2/11/img_5_hu67fcaf6c880616f05483504aed1bccfa_55708_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/11/img_5_hu67fcaf6c880616f05483504aed1bccfa_55708_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="단일 수신자"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="214px"
>&lt;/p>
&lt;ul>
&lt;li>단일 수신자
&lt;ul>
&lt;li>요청은 하나의 수신자 또는 서비스가 처리한다.&lt;/li>
&lt;li>공유 메시지 큐를 사용해 구현한다.
&lt;ul>
&lt;li>복수 구독자가 있을 수 있으나 처리된 메시지는 큐에서 바로 제거&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/11/img_6.png"
width="1356"
height="548"
srcset="https://codemario318.github.io/post/system-design-interview-2/11/img_6_hua8e092a43e387e527c03916905711cfa_34975_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/11/img_6_hua8e092a43e387e527c03916905711cfa_34975_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="다중 수신자"
class="gallery-image"
data-flex-grow="247"
data-flex-basis="593px"
>&lt;/p>
&lt;ul>
&lt;li>다중 수신자
&lt;ul>
&lt;li>메시지는 여러 수신자 또는 서버가 처리한다.&lt;/li>
&lt;li>카프카가 적합하다.&lt;/li>
&lt;li>소비자가 수신한 메시지는 카프카에서 바로 사라지지 않기 때문에 동일한 메시지를 여러 서비스가 받아 처리할 수 있다.&lt;/li>
&lt;li>결제시스템에서는 하나의 요청이 푸시 알림, 재무 보고 업데이트, 분석 결과 업데이트 등 다양한 용도로 쓰일 수 있기 때문에 적합하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>일반적으로 동기식 통신은 설계하기 쉽지만 서비스의 자율성을 높이기에는 적합하지 않다.&lt;/p>
&lt;ul>
&lt;li>의존성 그래프가 커지면 전반적 성능은 낮아진다.&lt;/li>
&lt;/ul>
&lt;p>비동기 통신은 설계의 단순성과 데이터 일관성을 시스템 확장성 및 장애 감내 능력과 맞바꾼 결과다.&lt;/p>
&lt;ul>
&lt;li>비즈니스 로직이 복잡하고 타사 서비스 의존성이 높은 대규모 결제 시스템에는 비동기 통신이 더 나은 선택이다.&lt;/li>
&lt;/ul>
&lt;h3 id="결제-실패-처리">결제 실패 처리&lt;/h3>
&lt;p>모든 결제 시스템은 안정성 및 결함 내성이 핵심적 요구사항으로 실패한 결제를 적절히 처리할 수 있어야한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>결제 상태 추적&lt;/strong>&lt;/p>
&lt;p>결제 주기의 모든 단계에서 결제 상태를 정확하게 유지하는 것은 매우 중요하다.&lt;/p>
&lt;p>실패가 일어날 때마다 결제 거래의 현재 상태를 파악하고 재시도 또는 환불이 필요한지 여부를 결정한다.&lt;/p>
&lt;ul>
&lt;li>결제 상태는 데이터 추가만 가능한 데이터베이스 테이블에 보관한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>재시도 큐 및 실패 메시지 큐&lt;/strong>&lt;/p>
&lt;p>실패를 우아하게 처리하기 위해서는 재시도 큐와 실패 메시지 큐를 두는 것이 바람직하다.&lt;/p>
&lt;ul>
&lt;li>재시도 큐
&lt;ul>
&lt;li>일시적 오류 같은 재시도 가능 오류는 재시도 큐에 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>실패 메시지 큐
&lt;ul>
&lt;li>반복적으로 처리에 실패한 메시지는 실패 메시지 큐로 보낸다.&lt;/li>
&lt;li>문제가 있는 메시지를 디버깅하고 결기하여 성공적으로 처리되지 않은 이유를 파악하기 위한 검사에 유용하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/11/img_7.png"
width="1956"
height="846"
srcset="https://codemario318.github.io/post/system-design-interview-2/11/img_7_huef8f628fcca5c9eaf068ff3664dff431_63343_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/11/img_7_huef8f628fcca5c9eaf068ff3664dff431_63343_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="실패한 결제의 처리"
class="gallery-image"
data-flex-grow="231"
data-flex-basis="554px"
>&lt;/p>
&lt;h3 id="정확히-한-번-전달">정확히 한 번 전달&lt;/h3>
&lt;p>결제 시스템에 발생 가능한 가장 심각한 문제 중 하나는 고객에게 이중으로 청구하는 것이다.&lt;/p>
&lt;p>결제 주문이 정확히 한 번만 실행되도록 결제 시스템을 설계하는 것이 중요하다.&lt;/p>
&lt;p>어려운 문제로 보이지남 문제를 두 부분으로 나누면 훨씬 쉽게 해결할 수 있으며 수학적으로 다음 요건이 충족되면 주어진 연산은 정확히 한 번 실행된다.&lt;/p>
&lt;ul>
&lt;li>최소 한 번은 실행된다.&lt;/li>
&lt;li>최대 한 번 실행된다.&lt;/li>
&lt;/ul>
&lt;p>재시도를 통해 최소 한 번 실행을 보증하는 방법과 멱등성 검사를 통해 최대 한 번 실행을 보증하는 방법을 알아본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>재시도&lt;/strong>&lt;/p>
&lt;p>네트워크 오류나 시간 초과로 인해 결제 거래를 다시 시도해야 하는 경우 재시도 메커니즘을 활용하면 어떤 결제가 최소 한 번은 실행되도록 보장 가능하다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/11/img_8.png"
width="1116"
height="876"
srcset="https://codemario318.github.io/post/system-design-interview-2/11/img_8_hua7b7f39cd2c6ca0abd91ed0e2a970add_45746_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/11/img_8_hua7b7f39cd2c6ca0abd91ed0e2a970add_45746_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="재시도"
class="gallery-image"
data-flex-grow="127"
data-flex-basis="305px"
>&lt;/p>
&lt;p>재시도 매커니즘을 도입할 때는 얼마나 간격을 두고 재시도할지 정하는 것이 중요하다.&lt;/p>
&lt;ul>
&lt;li>즉시 재시도(immediate retry)
&lt;ul>
&lt;li>클라이언트는 즉시 요청을 다시 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>고정 간격(fixed interval)
&lt;ul>
&lt;li>재시도 전에 일정 시간을 기다린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>증분 간격(incremental interval)
&lt;ul>
&lt;li>재시도 전에 기다리는 시간을 특정한 양 만큼 점진적으로 늘려나간다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지수적 백오프(exponential backoff)
&lt;ul>
&lt;li>재시도 전에 기다리는 시간을 직전 재시도 대비 두 배씩 늘려 나가는 방안&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>취소(cancel)
&lt;ul>
&lt;li>요청을 철회한다.&lt;/li>
&lt;li>실패가 영구적이거나 재시도를 하더라도 성공 가능성이 낮은 경우 흔히 사용된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>모든 상황에 맞는 해결책은 없지만, 일반적으로 네트워크 문제가 단시간 해결될 것 같지 않다면 지수적 백오프를 사용한다.&lt;/p>
&lt;p>지나치게 공격적인 재시도 전략은 컴퓨팅 자원을 낭비하고 서비스 과부하를 유발한다.&lt;/p>
&lt;ul>
&lt;li>에러 코드를 반환할 때는 &lt;code>Retry-After&lt;/code> 헤더를 같이 붙여 봰는 것이 바람직하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>멱등성&lt;/strong>&lt;/p>
&lt;p>멱등성은 최대 한 번 실행을 보장하기 위한 핵심 개념이다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>멱등성 Idempotency&lt;/strong>&lt;br>
수학 또는 컴퓨터 과학적 연산이 가질 수 있는 한 가지 속성으로, 연산을 여러 번 실행하여도 최초 실행 결과가 그대로 보존되는 특성 일걷는다.&lt;/p>
&lt;/blockquote>
&lt;p>API 관점에서 보자면 클라이언트가 API 여러번 호출해도 항상 동일한 결과가 나온다는 뜻이다.&lt;/p>
&lt;p>클라이언트와 서버 간의 통신을 위해서 일반적으로 클라이언트가 생성하고 일정 시간이 지나면 만료되는 고유한 값을 멱등 키로 사용한다.&lt;/p>
&lt;ul>
&lt;li>UUID를 멱등 키로 군장하며 실제 널리 쓰인다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>시나리오 1: 고객이 결제 버튼을 빠르게 두 번 클릭하는 경우&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/11/img_9.png"
width="1348"
height="930"
srcset="https://codemario318.github.io/post/system-design-interview-2/11/img_9_huf77824a6592560d8cafdb96ed122454b_79505_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/11/img_9_huf77824a6592560d8cafdb96ed122454b_79505_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="멱등성"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;p>요청에 포함된 멱등 키를 이전에 받은 적이 있다면 재시도로 처리하며, 이전 결제 요청의 가장 최근 상태를 활용한다.&lt;/p>
&lt;p>동일한 멱등 키로 동시에 많은 요청을 받으면 결제 서비스는 그 가운데 하나만 처리하고 나머지에 대해서 &lt;code>429 Too Many Requests&lt;/code> 상태 코드를 반환한다.&lt;/p>
&lt;ul>
&lt;li>멱등성을 지원하는 한 가지 방법으로 데이터베이스의 고유 키 제약 조건을 활용하여 테이블의 기본 키를 멱등키로 사용할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>시나리오 2: PSP가 결제를 성공적으로 처리했지만 네트워크 오류로 응답이 결제 시스템에 전달되지 않아 사용자가 결제 버튼을 다시 클릭하는 경우&lt;/strong>&lt;/p>
&lt;p>결제 서비스는 PSP에 비중복 난수를 전송하고 PSP는 해당 난수에 대응되는 토큰을 반환한다.&lt;/p>
&lt;p>이 난수는 결제 주문을 유일하게 식별하며, 해당 토큰은 그 난수에 일대일로 대응되어 토큰 또한 결제 주문을 유일하게 식별할 수 있다.&lt;/p>
&lt;p>사용자가 결제 버튼을 다시 누른다고 해도 결제 주문이 같으니 PSP로 전동되는 토큰도 같기 때문에, PSP가 이중 결제로 판단하고 종전 실행 결과를 반환하게 된다.&lt;/p>
&lt;h3 id="일관성">일관성&lt;/h3>
&lt;p>결제 실행 과정에서 상태 정보를 유지 관리하는 여러 서비스가 호출된다.&lt;/p>
&lt;ul>
&lt;li>결제 서비스
&lt;ul>
&lt;li>비중복 난수, 토큰, 결제 주문, 실행 상태 등 결제 관련 데이터&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>원장
&lt;ul>
&lt;li>모든 회계 데이터&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지갑
&lt;ul>
&lt;li>판매자의 계정 잔액&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>PSP
&lt;ul>
&lt;li>결제 실행 상태&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>+ 여러 데이터베이스의 사본에 복제될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>분산 환경에서는 서비스 간 통신 실패로 데이터의 불일치가 발생할 수 있으므로 내부 서비스 간 데이터 일관성을 유지하려면 요청이 &lt;strong>정확히 한 번 처리&lt;/strong>되도록 보장하는 것이 아주 중요하다.&lt;/p>
&lt;ul>
&lt;li>내부 서비스와 외부 서비스(PSP) 간의 데이터 일관성 유지를 위해 일반적으로 멱등성과 조정 프로세스를 활용한다.&lt;/li>
&lt;/ul>
&lt;p>하지만 외부 서비스가 멱등 API를 지원하더라도 &lt;strong>항상 옳다고 가정할 수는 없다&lt;/strong>.&lt;/p>
&lt;p>데이터를 다중화하는 경우 복제 지연으로 인해 기본 데이터베이스와 사본 데이터베이스가 불일치하는 일이 발생할 수 있으며 두 가지 해결 방법이 있다.&lt;/p>
&lt;ul>
&lt;li>주 데이터베이스에서만 읽기와 쓰기를 수행
&lt;ul>
&lt;li>설정은 쉽지만 규모 확장성이 떨어진다.&lt;/li>
&lt;li>사본은 데이터 안정성 보장에만 활용하고 트래픽은 처리하지 않는다.
&lt;ul>
&lt;li>자원 낭비&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모든 사본을 항상 동기화
&lt;ul>
&lt;li>팩서스, 래프트 같은 합의 알고리즘을 사용&lt;/li>
&lt;li>YugabyteDb, CockroachDB와 같은 합의 기반 분산 데이터베이스를 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="결제-보안">결제 보안&lt;/h3>
&lt;p>결제 보안은 매우 중요하다. 사이버 공격과 카드 도난에 대응하기 위한 몇 가지 그술을 간략하게 살펴본다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>문제&lt;/th>
&lt;th>해결책&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>요청/응답 도청&lt;/td>
&lt;td>HTTPS&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 변조&lt;/td>
&lt;td>암호화 및 무결성 강화 모니터링&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>중간자 공격&lt;/td>
&lt;td>인증서 고정과 함께 SSL 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 손실&lt;/td>
&lt;td>여러 지역에 걸쳐 데이터베이스 복제 및 스냅숏 생성&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>분산 서비스 거부 공격&lt;/td>
&lt;td>처리율 제한 및 방화벽&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>카드 도난&lt;/td>
&lt;td>토큰화. 실제 카드 번호를 사용하는 대신 토큰을 저장하고 결제에 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PCI 구정 준수&lt;/td>
&lt;td>PCI DSS는 브랜드 신용 카드를 처리하는 조직을 위한 정보 보안 표준&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사기&lt;/td>
&lt;td>주소 확인, 카드 확인 번호(CVV), 사용자 행동 분석 등&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>대금 수신과 정산 흐름을 살펴보고 재시도, 멱등성, 일관성에 대해서도 자세히 살펴보았다.&lt;/p>
&lt;p>결제 시스템은 아주 복잡하며 다루지 않았지만 중요한 주제들도 많이 남아있다.&lt;/p>
&lt;ul>
&lt;li>모니터링
&lt;ul>
&lt;li>주요 지표를 모니터링 하는 것은 모든 현대적 애플리케이션에 아주 중요하다.&lt;/li>
&lt;li>광범위한 모니터링을 통해 많은 정보들을 알 수 있다.&lt;/li>
&lt;li>대시보드를 만들 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>경보
&lt;ul>
&lt;li>비정상적인 사요항이 발생하면 온콜 중인 개발자에게 알려 신속하게 대앙흘 수 있도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>디버깅 도구
&lt;ul>
&lt;li>엔지니어와 고객 지원팀이 더 쉽게 디버깅 할 수 있도록 결제 거래의 상태, 처리 서버 기록, PSP 기록 등을 검토할 수 있는 도구를 개발하는 것이 중요하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>환율
&lt;ul>
&lt;li>국제적인 결제 시스템 설계에 중요한 고려 사항&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지역
&lt;ul>
&lt;li>지역마다 가용한 결제 수단이 완전히 달라질 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>현금 결제&lt;/li>
&lt;li>구글/애플 페이 연동 등&lt;/li>
&lt;/ul></description></item><item><title>10. 실시간 게임 순위표</title><link>https://codemario318.github.io/post/system-design-interview-2/10/</link><pubDate>Sun, 17 Nov 2024 14:41:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/10/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/cover.png" alt="Featured image of post 10. 실시간 게임 순위표" />&lt;p>이번 장에서는 &lt;strong>온라인 게임 리더보드&lt;/strong>, 즉 순위표를 설계해본다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>순위표?&lt;/strong>&lt;br>
누가 선두를 달리고 있는지 보여주기 위해 게임 등에서 흔히 사용하는 장치로, 가장 많은 포인트를 획득한 사람이 순위표의 맨 위에 자리한다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img.png"
width="1390"
height="560"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_hu968a6c0a83c3daa84d4ec97bc604aae0_41694_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_hu968a6c0a83c3daa84d4ec97bc604aae0_41694_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="순위표"
class="gallery-image"
data-flex-grow="248"
data-flex-basis="595px"
>&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;ul>
&lt;li>게임에 승리하면 포인트 획득&lt;/li>
&lt;li>모든 플레이어가 순위표에 포함&lt;/li>
&lt;li>새로운 토너먼트를 시작할 때 마다 새로운 순위표 생성&lt;/li>
&lt;li>상위 10명의 사용자와 특정 사용자의 순위를 순위표에 표시
&lt;ul>
&lt;li>특정 사용자의 순위를 보여줄 때 위, 아래로 4순위 차이 사용자 포함(추가 요구사항)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DAU 500만명, MAU 2,500만명&lt;/li>
&lt;li>각 선수는 하루에 평균 10 경기 진행&lt;/li>
&lt;li>실시간 또는 실시간에 가깝게 결과를 표시&lt;/li>
&lt;li>누적된 결과 이력을 보여주는건 바람직하지 않음&lt;/li>
&lt;/ul>
&lt;h3 id="기능-요구사항">기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>순위표에 상위 10명의 플레이어를 표시&lt;/li>
&lt;li>특정 사용자의 순위를 표시&lt;/li>
&lt;li>어떤 사용자보다 4순위 위, 아래에 있는 사용자를 표시(추가 요구 사항)&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>점수 업데이트는 실시간으로 순위표에 반영&lt;/li>
&lt;li>일반적인 확장성, 가용성 및 안정성 요구사항&lt;/li>
&lt;/ul>
&lt;h3 id="개략적인-규모-추정">개략적인 규모 추정&lt;/h3>
&lt;p>설계를 통해 해결해야 할 문제의 잠재적 규모와 과제를 결정하기 위한 몇가지 계산 결과를 살펴본다.&lt;/p>
&lt;p>게임은 대부분 사용량이 균등한 경우가 없으며, 북미 기준 저녁 시간이 피크 시간대일 가능성이 높다.&lt;/p>
&lt;p>이를 고려하여 최대 부하는 평균의 다섯배 정도로 가정한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>사용자 수&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>500만 / 10^5 초 =~ 50 * 5 = 초당 250 사용자&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>점수 획득 QPS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>한 사용자가 하루 평균 10개의 게임을 플레이한다고 가정&lt;/li>
&lt;li>점수를 획득하는 이벤트가 발생하는 평균 QPS는 &lt;code>50 * 10 =~ 500&lt;/code>&lt;/li>
&lt;li>최대 QPS는 평균의 5배로 가정하였으므로 &lt;code>500 * 5 = 2,500&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>상위 10명 순위표 가져오기&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>각 사용자가 하루 한 번 게임을 실행&lt;/li>
&lt;li>상위 10명 순위표는 사용자가 처음 게임을 열 때만 표시한다고 가정&lt;/li>
&lt;li>&lt;code>QPS =~ 50&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="api-설계">API 설계&lt;/h3>
&lt;p>개략적으로 3가지 API가 필요하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>POST /v1/scores&lt;/code>&lt;/strong>&lt;/p>
&lt;p>사용자가 게임에서 승리하면 순위표에서 사용자의 순위를 갱신한다.&lt;/p>
&lt;p>API는 게임 서버에서만 호출할 수 있는 내부 API로 클라이언트는 해당 API를 통하지 않고 순위표 점수를 직접 업데이트 할 수 없다.&lt;/p>
&lt;ul>
&lt;li>요청&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>필드&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>user_id&lt;/code>&lt;/td>
&lt;td>게임에서 승리한 사용자&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>points&lt;/code>&lt;/td>
&lt;td>사용자가 게임에서 승리하여 획득한 포인트 수&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>응답&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>이름&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>200 OK&lt;/code>&lt;/td>
&lt;td>사용자 점수를 성공적으로 갱신&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>400 Bad Request&lt;/code>&lt;/td>
&lt;td>잘못된 인자가 전달되어 사용자 점수를 갱신할 수 없음&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/scores&lt;/code>&lt;/strong>&lt;/p>
&lt;p>순위표에서 상위 10명의 플레이어를 조회&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;data&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;user_id1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;alice&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;rank&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;score&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">12543&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;user_id2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;bob&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;rank&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;score&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">11500&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;total&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>`GET /v1/scores/{:user_id}&lt;/strong>&lt;/p>
&lt;p>특정 사용자의 순위를 가져옴&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>필드&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>user_id&lt;/code>&lt;/td>
&lt;td>순위 정보를 가져올 사용자 ID&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_info&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;user5&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;score&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;rank&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>두 가지 서비스가 포함된다.&lt;/p>
&lt;ul>
&lt;li>게임 서비스
&lt;ul>
&lt;li>사용자가 게임을 플레이할 수 있도록 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>순위표 서비스
&lt;ul>
&lt;li>순위표를 생성하고 표시하는 역할 담당&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_1.png"
width="1102"
height="1066"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_1_hu51c0eaf019b910cb8404ff183ad3d839_54249_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_1_hu51c0eaf019b910cb8404ff183ad3d839_54249_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계"
class="gallery-image"
data-flex-grow="103"
data-flex-basis="248px"
>&lt;/p>
&lt;ol>
&lt;li>사용자가 게임에서 승리하면 클라이언트는 게임 서비스에 요청을 보낸다.&lt;/li>
&lt;li>게임 서비스는 해당 승리가 정당하고 유효한 것인지 확인한 다음 순위표 서비스에 점수 갱신 요청을 보낸다.&lt;/li>
&lt;li>순위표 서비스는 순위표 저장소에 기록된 해당 사용자의 점수를 갱신한다.&lt;/li>
&lt;li>해당 사용자의 클라이언트는 순위표 서비스에 직접 요청하여 다음과 같은 데이터를 가져온다.
&lt;ul>
&lt;li>상위 10명 순위표&lt;/li>
&lt;li>해당 사용자 순위&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>다른 대안들도 있지만 채택하지 않은 이유를 살펴보면 도움이 될 것이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>클라이언트가 순위표 서비스와 직접 통신해야 하나?&lt;/strong>&lt;/p>
&lt;p>클라이언트가 점수를 정하는 방식(클라이언트가 직접 순위표 서비스에 요청하는 방식)은, 사용자가 프락시를 설치하고 점수를 마음대로 바꾸는 중간자 공격을 할 수 있기 때문에 보안상 안전하지 않다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_2.png"
width="1366"
height="1108"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_2_hu9c2130220f7a6e4a19f502b9d6fb58c8_75990_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_2_hu9c2130220f7a6e4a19f502b9d6fb58c8_75990_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="순위표 점수는 누가 설정하는가"
class="gallery-image"
data-flex-grow="123"
data-flex-basis="295px"
>&lt;/p>
&lt;p>서버가 게임 전반을 통솔하는 경우 클라이언트가 점수를 설정하기 위해서 게임 서버를 명시적으로 호출할 필요가 없을수도 있다.&lt;/p>
&lt;ul>
&lt;li>게임 서버가 모든 게임 로직을 처리하고 게임이 언제 끝나는지 알기 때문에 클라이언트의 개입 없이도 점수를 정할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>게임 서비스와 순위표 서버 사이에 메시지 큐가 필요한가?&lt;/strong>&lt;/p>
&lt;p>게임 점수가 어떻게 사용되는지에 따라 크게 달라질 수 있다.&lt;/p>
&lt;p>해당 데이터가 다른 곳에서도 이용되거나 여러 기능을 지원해야 한다면 카프카에 데이터를 넣는 것이 합리적일 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_3.png"
width="1372"
height="516"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_3_hu1571b99ddafa8ab0beb62502c9444491_33359_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_3_hu1571b99ddafa8ab0beb62502c9444491_33359_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="게임 점수를 여러 서비스에서 사용하는 방안"
class="gallery-image"
data-flex-grow="265"
data-flex-basis="638px"
>&lt;/p>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>순위표 저장소는 시스템의 핵심 구성 요소 중 하나다.&lt;/p>
&lt;p>저장소 구현에 사용할 수 있는 세 가지 기술을 살펴본다.&lt;/p>
&lt;h4 id="관계형-데이터베이스">&lt;strong>관계형 데이터베이스&lt;/strong>&lt;/h4>
&lt;p>규모 확정성이 중요하지 않고, 사용자 수가 적다면 관계형 데이터베이스 시스템을 활용할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_4.png"
width="884"
height="580"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_4_hu87323fa7d86eb1b53840a0a18b78a259_68258_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_4_hu87323fa7d86eb1b53840a0a18b78a259_68258_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="leaderboard 테이블"
class="gallery-image"
data-flex-grow="152"
data-flex-basis="365px"
>&lt;/p>
&lt;p>각 &lt;strong>월별 순위표&lt;/strong>는 사용자 ID와 점수 열을 갖는 데이블로 표현할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>사용자가 점수를 딴 경우&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_5.png"
width="1354"
height="216"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_5_hu0a7ccfe89d76bf8da6055832ddc6d048_15214_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_5_hu0a7ccfe89d76bf8da6055832ddc6d048_15214_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="사용자가 점수를 획득한 경우"
class="gallery-image"
data-flex-grow="626"
data-flex-basis="1504px"
>&lt;/p>
&lt;p>점수가 1점씩만 늘어난다고 가정하면 해당 월의 순위표에 아직 햊당 사용자가 없다면 새로운 레코드를 만들어 넣고,&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leaderboard&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;mary1934&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>있다면 증가시킨다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">UPDATE leaderboard set score=score + 1 where user_id=&amp;#39;mary1934&amp;#39;;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>특정 사용자 순위 검색&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_6.png"
width="1364"
height="242"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_6_hu9653a2a00caf7b6c21525c7fedeabb71_17500_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_6_hu9653a2a00caf7b6c21525c7fedeabb71_17500_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="사용자의 순위 검색"
class="gallery-image"
data-flex-grow="563"
data-flex-basis="1352px"
>&lt;/p>
&lt;p>사용자의 순위를 가져오려면 순위표 테이블을 점수 기준으로 정렬한 후 순위를 매긴다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">@&lt;/span>&lt;span class="n">rownum&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@&lt;/span>&lt;span class="n">rownum&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rank&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leaderboard&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>이 방안은 데이터가 많지 않을 때는 효과적이지만, 레코드가 수백만 개 정도로 많아지면 성능이 너무 나빠지는 문제가 있다.&lt;/p>
&lt;ul>
&lt;li>사용자의 순위를 파악하려면 모든 플레이어를 순외표의 정확산 위치에 정렬해야한다.&lt;/li>
&lt;li>같은 점수를 받은 사용자가 여럿일 수 있으므로, 순위는 단순히 해당 목록 내의 사용자 위치라고도 할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>SQL 데이터베이스는 지속적으로 변화하는 대량의 정보를 신속하게 처리하지 못한다.&lt;/p>
&lt;ul>
&lt;li>수백만 개 레코드에 순위를 매기려면 대략 수십 초 정도가 걸린다.&lt;/li>
&lt;/ul>
&lt;p>따라서 실시간성을 요구하는 애플레키에션에는 적합하지 않고, 데이터가 지속적으로 변경되므로 캐시 도입도 어렵다.&lt;/p>
&lt;ul>
&lt;li>일괄 작업(배치)로 처리하면 가능할 수 있지만 실시간 순위를 보여주어야 한다는 요구사항에는 적절치 않다.&lt;/li>
&lt;/ul>
&lt;p>인덱스를 추가하고 &lt;code>LIMIT&lt;/code> 절을 사용하여 스캔할 페이지 수를 제한할 수 있지만, 확장성이 좋지 않다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">@&lt;/span>&lt;span class="n">rownum&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@&lt;/span>&lt;span class="n">rownum&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rank&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leaderboard&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>특정 사용자의 순위를 알아내려면 기본적으로 전체 테이블을 훑어야 한다.&lt;/li>
&lt;li>순위표 상단에 있지 않은 사용자의 순위를 간단히 찾을 수 없다.&lt;/li>
&lt;/ul>
&lt;h4 id="레디스">레디스&lt;/h4>
&lt;p>레디스는 메모리 기반 키-값 저장소 시스템으로 메모리에서 동작하여 빠른 읽기 및 쓰기가 가능하다.&lt;/p>
&lt;p>이를 통해 수백만 명의 사용자에 대해서도 예측 가능한 ㅅ어능ㅇ르 제공하고 복잡한 DB 쿼리 없이도 일반적인 순위표 작업을 쉽게 수행할 수 있다.&lt;/p>
&lt;p>아울러 순위표 시스템 설계 문제를 해결하는 데 이상적인 &lt;strong>정렬 집합&lt;/strong>(sorted set)이라는 자료형을 제공한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>정렬 집합이란?&lt;/strong>&lt;/p>
&lt;p>집합과 유사항 자료형으로 저장된 각 원소는 점수에 연결되어 있다.&lt;/p>
&lt;p>집합 내 원소는 고유해야 하지만 같은 점수는 있을 수도 있고, 정렬 집합 내 원소를 오름차순 정렬하는 데 이용된다.&lt;/p>
&lt;p>정렬 집합은 내부적으로 해시 테이블과 스킵 리스트라는 두 가지 자료 구조를 사용한다.&lt;/p>
&lt;ul>
&lt;li>해시 테이블: 사용자의 점수를 저장&lt;/li>
&lt;li>스킵 리스트: 특정 점수를 딴 사용자들의 목록을 저장&lt;/li>
&lt;/ul>
&lt;p>사용자는 점수를 기준으로 정렬한다.&lt;/p>
&lt;ul>
&lt;li>점수 및 사용자 열이 있는 테이블로 생각하면 이해하기 쉽다.
&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_7.png"
width="1352"
height="760"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_7_hu85fd85f56d1e350543434c4ec022a6b0_119803_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_7_hu85fd85f56d1e350543434c4ec022a6b0_119803_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="정렬 집합으로 표현한 2월 순위표"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>스킵 리스트&lt;/strong>&lt;/p>
&lt;p>빠른 검색을 가능하게 하는 자료구조로, 정렬된 연결 리스트에 다단계 색인을 두는 구조이다.&lt;/p>
&lt;p>이 자료 구조의 근간은 정렬된 단방향 연결 리스트로, 이 연결 리스트에 삽입, 삭제, 검색 연산을 실행하는 시간 복잡도는 &lt;code>O(n)&lt;/code>이다.&lt;/p>
&lt;p>연산이 더 빨리 실행할 수 있도록 하기 위해 이진 검색 알고리즘을 통해 중간 지점에 더 빨리 도달할 수 있도록 한다.&lt;/p>
&lt;ul>
&lt;li>중간 노드를 하나씩 건너뛰는 1차 색인과 1차 색인 노드를 하나씩 건너 뛰는 2차 색인을 추가한다.&lt;/li>
&lt;/ul>
&lt;p>새로운 색인을 추가할 때마다 이전 차수의 노드를 하나씩 건너뛸 수 있다.&lt;/p>
&lt;ul>
&lt;li>노드 사이의 거리가 &lt;code>n-1&lt;/code>이 되면 더 이상의 색인을 추가하지 않는다.&lt;/li>
&lt;li>n은 총 노드의 개수&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_8.png"
width="1342"
height="1182"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_8_hu61e3939b81b6b789001ba6d07810bb60_81509_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_8_hu61e3939b81b6b789001ba6d07810bb60_81509_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="스킵 리스트"
class="gallery-image"
data-flex-grow="113"
data-flex-basis="272px"
>&lt;/p>
&lt;p>다단계 색인을 사용하면 특정 값을 훨씬 빠르게 찾을 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_9.png"
width="1956"
height="322"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_9_hu9354600d37260ed8b8d530bf7b5a8225_24588_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_9_hu9354600d37260ed8b8d530bf7b5a8225_24588_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="5차 색인까지 사용하는 스킵 리스트"
class="gallery-image"
data-flex-grow="607"
data-flex-basis="1457px"
>&lt;/p>
&lt;p>데이터 양이 적을 때는 스킵 리스트의 속도 개선 효과가 분명하지 않지만, 5차 색인까지 사용하는 스킵 리스트를 예시로 들면 개선을 확인할 수 있다.&lt;/p>
&lt;p>기본 리스트만 있는 경우 찾는 노드에 도달하기 위해 62개의 노드를 거쳐야하지만, 스킵 리스트의 경우에는 11개의 노드만 통과하면 된다.&lt;/p>
&lt;p>정렬 집합은 삽입이나 갱신 연산을 할 때 모든 원소가 올바른 위치에 자동으로 배치되며 새 원소를 추가하거나 기존 원소를 검색하는 연산의 시간 복잡도가 &lt;code>O(log(n))&lt;/code>이므로 관계형 데이터베이스보다 성능이 좋다.&lt;/p>
&lt;p>관계형 데이터베이스에서 특정 사용자의 순위를 계산하려면 중첩 질의문을 수행해야한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">,(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COUNT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leaderboard&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lb2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lb2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lb1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RANK&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leaderboard&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lb1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lb1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">{&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>레디스 정렬 집합을 사용한 구현&lt;/strong>&lt;/p>
&lt;p>순위표 구현에 사용할 레디스 연산들을 살펴본다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>ZADD&lt;/code>
&lt;ul>
&lt;li>기존에 없던 사용자를 집합에 추가한다.&lt;/li>
&lt;li>기존 사용자의 경우에는 점수를 업데이트한다.&lt;/li>
&lt;li>&lt;code>O(log(n))&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ZINCRBY&lt;/code>
&lt;ul>
&lt;li>사용자 점수를 지정된 값 만큼 증가시킨다.&lt;/li>
&lt;li>집합에 없는 사용자는 0점으로 가정한다.&lt;/li>
&lt;li>&lt;code>O(log(n))&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ZRANGE&lt;/code>/&lt;code>ZREVRANGE&lt;/code>
&lt;ul>
&lt;li>점수에 따라 정렬된 사용자 중 특정 범위에 드는 사용자들을 가져온다.&lt;/li>
&lt;li>순서, 항목 수, 시작 위치를 지정할 수 있다.&lt;/li>
&lt;li>&lt;code>O(log(n) + m)&lt;/code>
&lt;ul>
&lt;li>&lt;code>m&lt;/code>: 가져올 항목 수&lt;/li>
&lt;li>&lt;code>n&lt;/code>: 정렬 집합의 크기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ZRANK&lt;/code>/&lt;code>ZREVRANK&lt;/code>
&lt;ul>
&lt;li>오름차순/내림차순 정렬하였을 때 특정 사용자의 위치를 가져온다.&lt;/li>
&lt;li>&lt;code>O(log(n))&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;code>ZREVRANGE&lt;/code>는 향후 사용이 중단될 명령으로, &lt;code>ZRANGE&lt;/code> 명령에 추가 속성을 전달하면 같은 결과를 얻을 수 있다.&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>&lt;strong>사용자가 점수를 획득한 경우&lt;/strong>&lt;/p>
&lt;p>매 월 새로운 순위표를 위한 정렬 집합을 만들고 이전 순위표는 이력 데이터 저장소로 보낸다.&lt;/p>
&lt;p>사용자는 승리하면 점수를 얻은데, &lt;code>ZINCRBY&lt;/code>를 호출하여 사용자 점수를 증가시키거나 순위표 세트에 없는 경우 사용자를 순위표 집합에 추가한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZINCRBY leaderboard_feb_2021 1 &amp;#39;mary1934&amp;#39;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>사용자가 순위표 상위 10명을 조회하는 경우&lt;/strong>&lt;/p>
&lt;p>가장 높은 점수를 받은 사용자로부터 내림차순으로 정렬한 결과를 가져와야 하므로 &lt;code>ZREVRANGE&lt;/code>를 호출한다.&lt;/p>
&lt;p>사용자 목록뿐 아니라 각 사용자의 현재 점수도 가져와야 하므로 &lt;code>WITHSCORES&lt;/code> 속성도 전달한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZREVRANGE leaderboard_feb_2021 0 9 WITHSCORES
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>다음과 같은 목록이 반환된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[(user2,score2),(user1,score1),(user5,score5)...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>사용자가 자기 순위를 조회하는 경우&lt;/strong>&lt;/p>
&lt;p>&lt;code>ZREVRANK&lt;/code>를 호출하면 특정 사용자의 순위를 가져올 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZREVRANGE leaderboard_feb_2021 357 365
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>특정 사용자 순위를 기준으로 일정 범위 내 사용자를 질의하는 경우&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_10.png"
width="1344"
height="1112"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_10_hucd013a2567009eacc82bc2b2f59fca18_84653_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_10_hucd013a2567009eacc82bc2b2f59fca18_84653_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="특정 사용자 직전 순위 사용자 4명, 직후 순위 사용자 4명"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="290px"
>&lt;/p>
&lt;p>&lt;code>ZREVRANGE&lt;/code>를 활용하면 특정한 사용자 전/후 순위 사용자 목록을 얻어낼 수 있다.&lt;/p>
&lt;p>&lt;code>Mallow007&lt;/code>의 사용자가 361등이고, 전 후로 4명씩 조회한다면&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZREVRANGE leaderboard_feb_2021 357 365
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="저장소-요구사항">저장소 요구사항&lt;/h3>
&lt;p>최소한 &lt;code>사용자 ID&lt;/code>와 &lt;code>점수&lt;/code>는 저장해야 한다.&lt;/p>
&lt;p>최악의 시나리오는 월간 활성 사용자 2,500만 명 모두가 최소 한 번 이상 게임에서 승리하는 바람에 모두 월 순위표에 올라야 하는 경우이다.&lt;/p>
&lt;ul>
&lt;li>ID: 24자 문자열&lt;/li>
&lt;li>점수: 16비트 정수&lt;/li>
&lt;li>순위표 한 항목당 26바이트 필요&lt;/li>
&lt;li>MAU 순위표 항목이 하나라는 최악의 시나리오를 가정하면 &lt;code>26바이트 * 2,500만 = 650MB&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>이 정도라면 스킵 리스트 구현에 필요한 오베헤드와 정렬 집합 해시를 고려해 메모리 사용량을 두 배로 늘린다고 해도 최신 레디스 서버 한 대만으로도 데이터를 충분히 저장할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>CPU 및 I/O 사용량&lt;/strong>&lt;/p>
&lt;p>개략적인 추정치에 따르면 갱신 연산의 최대 QPS는 2500/초 정도로 레디스 서버로도 충분히 감당할 수 있는 부하이다.&lt;/p>
&lt;p>하지만 레디스 노드에 장애 발생으로 인한 영속성을 고려해야한다.&lt;/p>
&lt;p>레디스는 데이터를 디스크에 영속적으로 보관하는 옵션도 지원하나, 디스크에서 데이터를 읽어 대규모 레디스 인스턴스를 재시작하려면 시간이 많이 걸린다.&lt;/p>
&lt;ul>
&lt;li>그래서 보통은 레디스에 읽기 사본을 두는 방식으로 구성한다.&lt;/li>
&lt;/ul>
&lt;p>MySQL과 같은 관계형 데이터베이스를 사용하는 경우에는 사용자와 점수 테이블이 필요하다.&lt;/p>
&lt;p>점수 테이블에는 사용자 ID, 점수, 게임에서 승리한 시각(타임스템프)를 저장하여 경연 기록 등과 같은 다른 게임 기능 구현에 활용될 수 있고, 인프라 장애 발생 시 레디스 순위표를 복구하는 데에도 활용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>가장 자주 검색되는 상위 10명의 사용자 정보를 캐시하면 쉽게 성능을 최적화 할 수 있다.&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="클라우드-서비스-사용-여부">클라우드 서비스 사용 여부&lt;/h3>
&lt;p>솔루션 배포 방식은 기존 인프라 구성 형태에 따라 일반적으로 두 가지로 나눌 수 있다.&lt;/p>
&lt;h4 id="자체-서비스-사용">자체 서비스 사용&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_11.png"
width="1836"
height="770"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_11_huc99aadd03e637796689cc9fe1c2d43ef_172903_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_11_huc99aadd03e637796689cc9fe1c2d43ef_172903_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="자체 서버스를 이용하는 방안"
class="gallery-image"
data-flex-grow="238"
data-flex-basis="572px"
>&lt;/p>
&lt;ul>
&lt;li>매월 정렬 집합을 생성하여 사용자 및 점수 정보를 이용해 해당 기간의 순위표를 저장한다.&lt;/li>
&lt;li>이름 및 프로필 이미지와 같은 사용자 세부 정보는 MySQL 데이터베이스에 저장한다.&lt;/li>
&lt;/ul>
&lt;p>순위표를 가져올 때 API 서버는 순위 데이터와 더불어 데이터베이스에 저장된 사용자 이름과 프로필 이미지도 가져온다.&lt;/p>
&lt;ul>
&lt;li>이 작업이 장기적으로 너무 비효율적이면 상위 사용자 10명의 세부 정보를 저장하는 프로필 캐시를 두어 해결할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="클라우드-서비스-이용">클라우드 서비스 이용&lt;/h4>
&lt;blockquote>
&lt;p>기존 인프라가 AWS에 있어 클라우드로 순위표를 구축하는 것이 자연스러운 상황이라 가정한다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>아마존 API 게이트웨이&lt;/strong>와 &lt;strong>AWS 람다&lt;/strong>(Lambda) 두 가지를 활용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>API 게이트웨이를 사용하면 RESTful API의 HTTP 엔드포인트를 정의하고 아무 백엔드 서비스에나 연결할 수 있다.&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>람다 함수&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>GET /v1/scores&lt;/code>&lt;/td>
&lt;td>&lt;code>LeaderboardFetchTop10&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>GET /v1/scores/{:user_id}&lt;/code>&lt;/td>
&lt;td>&lt;code>LeaderboardFetchPlayerRank&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>GET /v1/scores&lt;/code>&lt;/td>
&lt;td>&lt;code>LeaderboardUpdateScores&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>&lt;strong>AWS 람다&lt;/strong>&lt;br>
가장 인기있는 서버리스 컴퓨팅 플랫폼 중 하나로 서버를 직접 준비하거나 관리할 필요 없이 코드를 실행할 수 있다.&lt;br>
람다는 필요할 때만 실행되며 트래픽에 따라 규모가 자동으로 확장된다.&lt;/p>
&lt;/blockquote>
&lt;p>개략적으로 설명하면&lt;/p>
&lt;ol>
&lt;li>API 게이트웨이를 호출&lt;/li>
&lt;li>게이트웨이는 적절한 람다 함수를 호출&lt;/li>
&lt;li>스토리지 계층(레디스 및 MySQL)의 명령을 호출하여 얻은 결과를 API 게이트웨이에 반환&lt;/li>
&lt;li>API 게이트웨이는 그 결과를 애플리케이션에 전달&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>람다 함수를 사용하면 서버 인스턴스를 만들지 않아도 질의를 실행할 수 있다.
&lt;ul>
&lt;li>레디스를 호출할 수 있도록 하는 클라이언트를 제공한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>람다를 사용하면 DAU 성장세에 맞춰 자동으로 서비스 규모를 확장할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>점수 획득&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_12.png"
width="1978"
height="496"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_12_hua00e417a6ce8d46751065c258b5a49fc_148407_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_12_hua00e417a6ce8d46751065c258b5a49fc_148407_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="점수 획득"
class="gallery-image"
data-flex-grow="398"
data-flex-basis="957px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>순위 검색&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_13.png"
width="1964"
height="506"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_13_hud870a85155701f522546b2affcdafcf0_158178_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_13_hud870a85155701f522546b2affcdafcf0_158178_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="순위 검색"
class="gallery-image"
data-flex-grow="388"
data-flex-basis="931px"
>&lt;/p>
&lt;hr>
&lt;p>람다는 서비리스 접근 방식이라 인프라의 규모가 필요에 맞게 자동으로 확장되며, 환경 설정, 유지 보수 등의 문제를 직접 관리할 필요가 없다.&lt;/p>
&lt;h3 id="레디스-규모-확장">레디스 규모 확장&lt;/h3>
&lt;p>5백만 DAU 정도라면 한 대의 레디스 캐시 서버로도 충분히 지원 가능하나, 원래 규모의 100배인 5억 DAU를 처리해야한다면 규모 확장이 필요하다.&lt;/p>
&lt;ul>
&lt;li>저장 용량은 65GB&lt;/li>
&lt;li>250,000 QPS 처리&lt;/li>
&lt;/ul>
&lt;p>이 정도 규모를 감당하려면 샤딩이 필요하다.&lt;/p>
&lt;h4 id="데이터-샤딩-방안">데이터 샤딩 방안&lt;/h4>
&lt;p>고정 파티션과 해시 파티션 방식을 고려할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>고정 파티션&lt;/strong>&lt;/p>
&lt;p>순위표에 등장하는 점수의 범위에 따라 파티션을 나누는 방안이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_14.png"
width="1856"
height="206"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_14_hu7658f9e716ce647a0256027405e30bb0_20879_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_14_hu7658f9e716ce647a0256027405e30bb0_20879_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="고정 파티션"
class="gallery-image"
data-flex-grow="900"
data-flex-basis="2162px"
>&lt;/p>
&lt;ul>
&lt;li>획득할 수 있는 점수가 1~1000 이라면 데이터를 범위별로 나눈다.&lt;/li>
&lt;li>(1~100), (101~200) &amp;hellip;, (901, 1000)&lt;/li>
&lt;/ul>
&lt;p>이 기능이 제대로 작동하려면 순위표 전반에 점수가 고르게 분포되어야 하며, 그렇지 않다면 각 샤드에 할당되는 점수 범위를 조정하여 비교적 고른 분포가 되도록 해야한다.&lt;/p>
&lt;hr>
&lt;p>애플리케이션이 샤딩 처리의 추제라면 특정 사용자의 점수를 입력하거나 갱신할 때 해당 사용자가 어느 샤드에 있는지 알아야 한다.&lt;/p>
&lt;ul>
&lt;li>MySQL 질의로 사용자의 현재 점수를 계산하여 알아낼 수도 있다.&lt;/li>
&lt;li>사용자 ID와 점수 사이의 관계를 저장하는 2차 캐시를 활용하면 성능을 더 높일 수 있다.&lt;/li>
&lt;/ul>
&lt;p>사용자의 점수가 높아져서 다른 샤드로 옮겨야 할 때는 기존 샤드에서 해당 사용자를 제거한 다음 새 샤드로 옮겨야 한다.&lt;/p>
&lt;hr>
&lt;p>순위표에서 상위 10명의 플레이어를 가져오려면, 가장 높은 점수가 저장되는 샤드에서 상위 10명을 가져온다.&lt;/p>
&lt;p>특정 사용자의 순위를 알려면 해당 사용자가 속한 샤드 내 순위뿐 아니라 해당 샤드보다 높은 점수를 커버하는 모든 샤드의 모든 사용자 수를 알아야 한다.&lt;/p>
&lt;ul>
&lt;li>특정 샤드에 속한 모든 사용자 수는 &lt;code>info keyspace&lt;/code> 명령을 통해 &lt;code>O(1)&lt;/code>시간에 알아낼 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>해시 파티션&lt;/strong>&lt;/p>
&lt;p>레디스 클러스터를 사용하는 방법으로 사용자들의 점수가 특정 대역에 과도하게 모여있는 경우 효과적이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_15.png"
width="1694"
height="1344"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_15_huf77687aca255ea1376fddaaa280306c9_415936_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_15_huf77687aca255ea1376fddaaa280306c9_415936_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="해시 파티션"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="302px"
>&lt;/p>
&lt;blockquote>
&lt;p>레디스 클러스터&lt;br>
안정 해시는 사용하지 않지만 각 키가 특정한 해시 슬롯에 속하도록 하는 샤딩 기법을 사용한다.&lt;/p>
&lt;ul>
&lt;li>총 16384개 해시 슬롯이 있으며, &lt;code>CRC16(key) % 16384&lt;/code>의 연산을 수행하여 어떤 키가 어느 슬롯에 속하는지 계산한다.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>모든 키를 재분배하지 않아도 클러스터에 쉽게 노드를 추가하거나 제거할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>점수 갱신&lt;/strong>&lt;br>
점수를 갱신하려면 해당 사용자의 샤드를 찾아(&lt;code>CRC16(key) % 16394&lt;/code>) 해당 사용자의 점수를 변경한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>상위 10명 플레이어 검색&lt;/strong>&lt;/p>
&lt;p>모든 샤드에서 상위 10명을 받아 애플리케이션 내에서 다시 정렬하는 &lt;strong>분산-수집&lt;/strong>(scatter-gather) 접근법을 사용해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_16.png"
width="1460"
height="1388"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_16_hu1e8e084fe62cd2c4275cacc14a07a2eb_271118_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_16_hu1e8e084fe62cd2c4275cacc14a07a2eb_271118_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="분산-수집 방안"
class="gallery-image"
data-flex-grow="105"
data-flex-basis="252px"
>&lt;/p>
&lt;p>모든 샤드에 사용자를 질의하는 절차를 병렬화하면 지연 시간을 줄일수 있지만 다음과 같은 문제가 있다.&lt;/p>
&lt;ul>
&lt;li>상위 k개의 결과를 반환해야 하는 경우(k는 매우 큰 값) 각 샤드에서 많은 데이터를 읽고 정렬해야 하므로 지연 시간이 늘어난다.&lt;/li>
&lt;li>가장 느린 파티션에서 데이터를 다 읽고 나서야 질의 결과를 계산할 수 있으므로 지연 시간이 길어진다.&lt;/li>
&lt;li>특정 사용자의 순위를 결정할 간단한 방법이 없다.&lt;/li>
&lt;/ul>
&lt;p>따라서 고정 파티션 방안을 활용한다.&lt;/p>
&lt;h4 id="레디스-노드-크기-조정">&lt;strong>레디스 노드 크기 조정&lt;/strong>&lt;/h4>
&lt;p>레디스 노드의 크기를 조정할 때 여러가지를 고려해야한다.&lt;/p>
&lt;p>쓰기 작업이 많은 애플리케이션에서는 장애에 대비해 스냇숏을 생성할 때 필요한 모든 쓰기 연산을 감당할 수 있어야 하므로 많은 메모리가 필요하다.&lt;/p>
&lt;ul>
&lt;li>메모리를 두 배 더 할당하는 것이 안전하다.&lt;/li>
&lt;/ul>
&lt;p>레디스는 성능 밴체마킹을 위해 &lt;code>redis-benchmark&lt;/code>라는 도구를 제공하므로, 여러 클라이언트가 동시에 여러 질의를 실행하는 것을 실뮬레이션하여 주어진 하드웨어로 초당 얼마나 많은 요청을 처리할 수 있는지 측정할 수 있다.&lt;/p>
&lt;h4 id="대안-nosql">대안: NoSQL&lt;/h4>
&lt;p>NoSQL 데이터베이스를 다른 솔루션으로 고려할 수 있으며, 다음과 같은 데이터베이스가 이상적이다.&lt;/p>
&lt;ul>
&lt;li>쓰기 연산에 최적화&lt;/li>
&lt;li>같은 파티션 내의 항목을 점수에 따라 효율적으로 정렬 가능&lt;/li>
&lt;/ul>
&lt;p>아마존 DynamoDB, 카산드라, MongoDB 등을 고려할 수 있는데, DynamoDB를 예시로 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_17.png"
width="1344"
height="286"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_17_huc61d6265b699516ef39c14922102b774_97876_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_17_huc61d6265b699516ef39c14922102b774_97876_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="DynamoDB 기반 솔루션"
class="gallery-image"
data-flex-grow="469"
data-flex-basis="1127px"
>&lt;/p>
&lt;blockquote>
&lt;p>DynamoDB&lt;br>
안정적인 성능과 뛰어난 확장성을 제공하는 완전 관리형 NoSQL 데이터베이스로, 기본키 이외의 속성을 활용하여 데이터를 효과적으로 질의할 수 있도록, 전역 보조 색인을 제공한다.&lt;/p>
&lt;/blockquote>
&lt;p>전역 보조 색인은 부모 테이블의 속성들로 구성되지만 기본 키는 부모 테이블과는 다르다.&lt;/p>
&lt;hr>
&lt;p>체스 게임의 순위표를 설계하고, 데이터베이스 테이블은 순위표와 사용자 테이블을 비정규화 한 것으로 순위표를 화면에 표시하는 데 필요한 모든 정보를 담고 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_18.png"
width="1452"
height="532"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_18_hu9da5772d01231304c597cd3dfad33994_246694_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_18_hu9da5772d01231304c597cd3dfad33994_246694_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="순위표 및 사용자 테이블의 비정규화"
class="gallery-image"
data-flex-grow="272"
data-flex-basis="655px"
>&lt;/p>
&lt;p>이 방안은 레코드가 많아지면 상위 점수를 찾기 위해 전체 테이블을 뒤져야 하므로 사용자가 많아지면 성능이 떨어져 규모 확장이 어렵다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_19.png"
width="1464"
height="614"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_19_hua32ae9c65839c9e9bdba8742ab5270bb_257414_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_19_hua32ae9c65839c9e9bdba8742ab5270bb_257414_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="파티션 키 및 정렬 키"
class="gallery-image"
data-flex-grow="238"
data-flex-basis="572px"
>&lt;/p>
&lt;p>위와 같이 &lt;code>game_name#{year-month}&lt;/code>를 파티션 키로, 점수를 정렬 키로 사용하면 테이블 전체를 읽어야 하는 일을 피할 수 있지만, 부하가 높을 때 문제가 발생한다.&lt;/p>
&lt;p>DynamoDB는 안정 해시를 사용하여 여러 노드에 데이터를 분산하는데, 각 항목이 파티션 키에 따라 선정된 노드에 저장된다.&lt;/p>
&lt;p>위와 같이 테이블을 설계하면 가장 최근 한 달치 데이터가 동일한 파티션에 저장될 뿐 아니라 핫 파티션이 되고 만다.&lt;/p>
&lt;p>따라서 데이터를 n개 파티션으로 분할하고 파티션 번호(&lt;code>user_id % number_of_partitinons&lt;/code>)를 파티션 키에 추가하는 &lt;strong>쓰기 샤딩&lt;/strong>이라고 부르틑 패턴을 활용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>하지만 읽기 및 쓰기 작업 모두를 복잡하게 만드므로, 장단점을 꼼꼼히 따져봐야 한다.&lt;/li>
&lt;/ul>
&lt;p>쓰기 볼륨 또는 DAU를 기준으로 파티션의 수를 결정할 수 있으나 파티션이 받는 부하와 읽기 복잡도 사이에는 타협적인 부분이 있다.&lt;/p>
&lt;ul>
&lt;li>같은 달 데이터를 여러 파티션에 고르게 분산시키면 한 파티션이 받는 부하는 낮아짐&lt;/li>
&lt;li>특정한 달의 데이터를 읽으려고 하면 모든 파티션을 질의한 결과를 합쳐야 하므로 구현은 복잡해짐&lt;/li>
&lt;/ul>
&lt;p>파티션 키는 &lt;code>game#{year-moth}#p{partition_number}&lt;/code>와 같이 지정할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_20.png"
width="1450"
height="598"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_20_hu3a0e87c0bef2264457ba3bd9686d164f_269843_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_20_hu3a0e87c0bef2264457ba3bd9686d164f_269843_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="새로운 파티션 키"
class="gallery-image"
data-flex-grow="242"
data-flex-basis="581px"
>&lt;/p>
&lt;p>전역 보조 색인은 &lt;code>game#{year-moth}#p{partition_number}&lt;/code>를 파티션 키로, 점수를 정렬 키로 사용하게 구성한다.&lt;/p>
&lt;ul>
&lt;li>같은 파티션 내 데이터는 전부 점수 기준으로 정렬된 n개의 파티션이 만들어진다.&lt;/li>
&lt;/ul>
&lt;p>3개 파티션이 있다고 했을 때 상위 10명의 사용자를 가져오려면 &lt;strong>분산-수집&lt;/strong> 접근법을 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_21.png"
width="1744"
height="1284"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_21_hu7ef60b94fc6260de3accc6dec63a7cc1_363372_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_21_hu7ef60b94fc6260de3accc6dec63a7cc1_363372_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="분산 수집"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="325px"
>&lt;/p>
&lt;p>파티션 수는 신중한 벤치마킹이 필요할 수 있다.&lt;/p>
&lt;ul>
&lt;li>파티션이 많으면 각 파티션의 부하는 줄지만 최종 순위표를 만들기 위해 읽어야 하는 파티션은 더 많으므로 복잡성은 증가&lt;/li>
&lt;/ul>
&lt;p>그러나 앞서 언급한 레디스 파티션 기법과 마찬가지로, 사용자의 상대적 순위를 쉽게 정할 수 없다.&lt;/p>
&lt;p>하지만 사용자의 위치의 백분위수를 구하는 것은 가능하며, 충분히 괜찮은 방법일 수 있다.&lt;/p>
&lt;ul>
&lt;li>ex) 상위 10~20%에 속함&lt;/li>
&lt;li>규모가 충분히 커서 샤딩이 필요한 상황이라면 모든 샤드의 점수 분포는 거의 같다고 가정할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이 가정이 사실이라면 각 샤드의 점수 분포를 분석한 결과를 캐시하는 크론 작업을 만들어 볼 수도 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">10th percentile = score &amp;lt; 100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">20th percentile = score &amp;lt; 500
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">90th percentile = score &amp;lt; 6500
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이를 통해 사용자의 상대적 순위를 빠르게 계산할 수 있다.&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>이번 장에서는 수백만 DAU 규모의 실시간 게임 순위표를 구축하기 위한 솔루션을 설계해 보았다.&lt;/p>
&lt;ul>
&lt;li>MySQL 데이터베이스를 사용하는 간단한 솔루션부터 검토하여, 정렬 집합을 사용하여 순위표를 구현하기로 했다.&lt;/li>
&lt;li>여러 레디스 캐시에 데이터르 샤딩하여 5억 DAU도 지언할 수 있도록 규모를 확장하는 방안도 살펴보았다.&lt;/li>
&lt;li>대안으로 NoSQL 데이터베이스를 이용하는 방법도 살펴보았다.&lt;/li>
&lt;/ul>
&lt;p>시간이 남는다면 아래와 같은 주제도 살펴볼 수 있을것이다.&lt;/p>
&lt;h3 id="더-빠른-조회-및-동점자-순위-판정">더 빠른 조회 및 동점자 순위 판정&lt;/h3>
&lt;p>레디스 해시를 사용하면 문자열 필드와 값 사이의 대응 관계를 저장해 둘 수 있으며 아래와 같이 활용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>순위표에 표시할 사용자 ID와 사용자 객체 사이의 대응 관계를 저장하여 데이터베이스 질의를 줄일 수 있다.&lt;/li>
&lt;li>동점자는 누가 먼저 점수를 받았는지에 따라 순위를 정할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="시스템-장애-복구">시스템 장애 복구&lt;/h3>
&lt;p>레디스 클러스터에도 대규모 장애는 발생할 수 있다.&lt;/p>
&lt;p>지금까지 살펴본 설계안에서는 사용자가 게임에서 이길 때마다 MySQL 데이터베이스에 타임 스탬프와 함께 저장하므로, 이를 활용한 스크립트를 만들어 간단히 복구할 수 있다.&lt;/p>
&lt;ul>
&lt;li>사용자별로 모든 레코드를 훑으며 레코드당 한 번씩 &lt;code>ZINFRBY&lt;/code>를 호출&lt;/li>
&lt;/ul></description></item><item><title>9. S3와 유사한 객체 저장소</title><link>https://codemario318.github.io/post/system-design-interview-2/9/</link><pubDate>Sun, 03 Nov 2024 19:14:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/9/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/cover.png" alt="Featured image of post 9. S3와 유사한 객체 저장소" />&lt;p>이번 장에서는 아마존 S3(Simple Storage Service)와 유사한 객체 저장소 서비스를 설계한다.&lt;/p>
&lt;p>S3는 AWS가 제공하는 서비스로 RESTful API 기반 인터페이스로 이용 가능한 객체 저장소다.&lt;/p>
&lt;p>객체 저장소에 대해 더 자세히 살펴보기 전, 일반적으로 저장소란 어떤 시스템인지 알아보고, 몇 가지 용어를 정의해본다.&lt;/p>
&lt;h2 id="저장소-시스템-101">저장소 시스템 101&lt;/h2>
&lt;p>개략적으로 보면 저장소 시스템에는 3가지 부류가 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img.png"
width="1802"
height="684"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_hu1df0f1708df54f3b26fa0b850b382790_117739_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_hu1df0f1708df54f3b26fa0b850b382790_117739_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="저장소 유형"
class="gallery-image"
data-flex-grow="263"
data-flex-basis="632px"
>&lt;/p>
&lt;h3 id="블록-저장소">블록 저장소&lt;/h3>
&lt;p>HDD, SSD 처럼 서버에 물리적으로 연결되는 형태의 드라이브는 블록 저장소에 가장 흔한 형태이다.&lt;/p>
&lt;p>블록저장소는 원시 블록(raw block)을 서버에 볼륨 형태로 제공하는 가장 유연하고 융통성 높은 저장소다.&lt;/p>
&lt;ul>
&lt;li>서버는 원시 블록을 포맷한 다음 파일 시스템으로 이용하거나 애플리케이션에 블록 제어권을 넘겨 버릴 수도 있다.&lt;/li>
&lt;li>데이터베이스나 가상 머신 엔진 같은 애플리케이션은 원시 블록을 직접 제어하여 최대한의 성능을 끌어낸다.&lt;/li>
&lt;/ul>
&lt;p>서버에 물리적으로 직접 연겨로디는 저장소에 국한되지 않는다.&lt;/p>
&lt;ul>
&lt;li>고속 네트워크를 통해 연결될 수도 있다.&lt;/li>
&lt;li>업계 표준 연결 프로토콜은 FC(Fiber Channel)이나 ISCSI를 통해 연결될 수도 있다.&lt;/li>
&lt;/ul>
&lt;p>개념적으로 보면 네트워크를 통해 연결되는 블록 저장소도 원시 블록을 제공한다는 점에서 다르지 않으며, 서버 입장에서 보면 물리적으로 연결된 블록 저장소와 마찬가지로 동작한다.&lt;/p>
&lt;h3 id="파일-저장소">파일 저장소&lt;/h3>
&lt;p>파일 저장소는 블록 저장소 위에 구현된다.&lt;/p>
&lt;ul>
&lt;li>파일과 디렉터리를 손쉽게 다루는 데 필요한, 더 높은 수준의 추상화를 제공한다.&lt;/li>
&lt;li>데이터는 계층적으로 구성되는 디렉터리 안에 보관된다.&lt;/li>
&lt;/ul>
&lt;p>파일 저장소는 가장 널리 사용되는 범용 저장소 솔루션으로, SMB/CIFS나 NFS와 같은 파일 수준 네트워크 프로토콜을 사용하면 하나의 저장소를 여러 서버에 동시에 붙일 수도 있다.&lt;/p>
&lt;p>파일 저장소를 사용하는 서버는 블록을 직접 제어하고, 볼륨을 포맷하는 등의 까다로운 작업을 신경 쓸 필요가 없다.&lt;/p>
&lt;ul>
&lt;li>단순하기 때문에 폴더나 파일을 같은 조직 구성원에 공유하는 솔루션으로 사용하기 좋다.&lt;/li>
&lt;/ul>
&lt;h3 id="객체-저장소">객체 저장소&lt;/h3>
&lt;p>새로운 형태의 저장소로 데이터 영속성을 높이고 대규모 애플리케이션을 지원하며 비용을 낮추기 위해 의도적으로 성능을 희생한다.&lt;/p>
&lt;ul>
&lt;li>실시간으로 갱신할 필요가 없는 상대적으로 차가운(cold) 데이터 보관에 초점을 맞추며, 데이터 아카이브나 백업에 주로 쓰인다.&lt;/li>
&lt;/ul>
&lt;p>모든 데이터를 수평적 구조 내에 객체로 보관한다.&lt;/p>
&lt;ul>
&lt;li>계층적 디렉터리 구조는 제공하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>데이터 접근은 보통 RESTful API를 사용하며, 다른 유형의 저장소에 비해 상대적으로 느리다.&lt;/p>
&lt;h3 id="비교">비교&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>블록 저장소&lt;/th>
&lt;th>파일 저장소&lt;/th>
&lt;th>객체 저장소&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>저장된 내용의 변경 가능성&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>N(새로운 버전의 객체를 추가하는 것은 가능)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>비용&lt;/td>
&lt;td>고&lt;/td>
&lt;td>중 ~ 고&lt;/td>
&lt;td>저&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>성능&lt;/td>
&lt;td>중 ~ 고 혹은 최상&lt;/td>
&lt;td>중 ~ 고&lt;/td>
&lt;td>저 ~ 중&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 일관성&lt;/td>
&lt;td>강력&lt;/td>
&lt;td>강력&lt;/td>
&lt;td>강력&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 접근&lt;/td>
&lt;td>SAS/iSCSI/FC&lt;/td>
&lt;td>표준 파일 접근, CIFS/SMB, NFS&lt;/td>
&lt;td>RESTful API&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>규모 확장성&lt;/td>
&lt;td>중&lt;/td>
&lt;td>고&lt;/td>
&lt;td>최상&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>적합한 응용&lt;/td>
&lt;td>가상머신, 데이터베이스 같은 높은 성능이 필요한 애플리케이션&lt;/td>
&lt;td>범용적 파일 시스템 접근&lt;/td>
&lt;td>이진 데이터, 구조화되지 않은 데이터&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="용어-정리">용어 정리&lt;/h3>
&lt;p>객체 저장소의 핵심 개념을 먼저 이해할 필요가 있다.&lt;/p>
&lt;ul>
&lt;li>버킷(bucket)
&lt;ul>
&lt;li>객체를 보관하는 논리적 컨테이너&lt;/li>
&lt;li>버킷 이름은 전역적으로 유일해야 함(globally unique)&lt;/li>
&lt;li>데이터를 업로드하려면 우선 버킷부터 만들어야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객체(Object)
&lt;ul>
&lt;li>버킷에 저장하는 개별 데이터&lt;/li>
&lt;li>데이터(페이로드라고도 함)와 메타데이터를 가짐
&lt;ul>
&lt;li>객체 데이터로는 어떤 것도 가능함&lt;/li>
&lt;li>메타데이터는 객체를 기술하는 이름-값 쌍&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>버전(version)
&lt;ul>
&lt;li>한 객체의 여러 버전을 같은 버킷 안에 둘 수 있도록 하는 기능&lt;/li>
&lt;li>버킷마다 별도 설정 가능&lt;/li>
&lt;li>객체를 복구할 수 있도록 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>URI(Uniform Resource Identifier)
&lt;ul>
&lt;li>객체 저장소는 버킷과 객체에 접근할 수 있도록 하는 RESTful API를 제공하기 때문에 각 객체는 해당 API URI를 통해 고유하게 식별할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>SLA(서비스 수준 협약, Service-Level Agreement)
&lt;ul>
&lt;li>서비스 제공자와 클라이언트 사이에 맺어지는 계약
&lt;ul>
&lt;li>여러 AZ(availability zone)에 걸쳐 99.999999999%의 객체 내구성을 제공&lt;/li>
&lt;li>하나의 가용성 구역 전체가 소실되어도 데이터 복원 가능&lt;/li>
&lt;li>연간 99.9%의 가용성 제공&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;ul>
&lt;li>다음 기능을 제공하는 S3와 유사한 객체 저장소 시스템 설계
&lt;ul>
&lt;li>버킷 생성&lt;/li>
&lt;li>객체 업로드 및 다운로드&lt;/li>
&lt;li>객처 버전&lt;/li>
&lt;li>버킷 내 객체 목록 출력 기능(aws s3 ls)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>아주 큰 객체(수 GB 이상)와 다량의 소형 객체(수 KB 정도)를 효율적으로 저장할 수 있어야함&lt;/li>
&lt;li>매년 추가되는 데이터는 100PB&lt;/li>
&lt;li>99.9999%의 데이터 내구성과 99.99% 서비스 가용성을 보장&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>100PB 데이터&lt;/li>
&lt;li>식스 나인(six nines, 99.9999%) 수준의 데이터 내구성&lt;/li>
&lt;li>포 나인(four nines, 99.99%) 수준의 서비스 가용성&lt;/li>
&lt;li>저장소 효율성
&lt;ul>
&lt;li>높은 수준의 안정성과 성능은 보증하되 저장소 비용의 최대한 낮춰야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="대략적-규모-추정">대략적 규모 추정&lt;/h3>
&lt;p>객체 저장소는 &lt;strong>디스크 용량&lt;/strong>이나 &lt;strong>초당 디스크 IO&lt;/strong>(IOPS)가 병목이 될 가능성이 높다.&lt;/p>
&lt;ul>
&lt;li>디스크 용량: 객체 크기는 다음 분포를 따른다.
&lt;ul>
&lt;li>객체 가운데 20%는 그 크기가 1MB 미만의 작은 객체&lt;/li>
&lt;li>60% 정도의 객체는 1MB ~ 64MB 정도의 중간 크기 객체&lt;/li>
&lt;li>나머지 20% 정도는 64MB 이상의 대형 객체&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>IOPS
&lt;ul>
&lt;li>SATA 인터페이스를 탑재하고 7200rpm을 지원하는 하드 디스크 하나가 초당 100 ~ 150 임의 데이터 탐색을 지원할 수 있다고 가정(100 ~ 150 IOPS)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 가정에 기반하여 시스템이 저장 가능한 객체 수를 가늠할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>100PB = 100 * 1000 * 1000 * 1000MB = 10MB&lt;/code>&lt;/li>
&lt;li>&lt;code>(10^11 * 0.4) / (0.2 * 0.5MB + 0.6 * 32MB + 0.2 * 200MB) = 6억 8천만 개&lt;/code>&lt;/li>
&lt;li>모든 객체의 메타데이터 크기가 대략 1KB라고 가정하면 메타데이터 정보를 저장하기 위해 약 0.68TB 필요함&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="객체-저장소의-속성">객체 저장소의 속성&lt;/h3>
&lt;p>설계를 진행하기 전 설계안에 영향을 끼칠 수 있는 객체 저장소의 몇 가지 속성을 살펴본다.&lt;/p>
&lt;ul>
&lt;li>객체 불변성(object immutability)
&lt;ul>
&lt;li>객체 저장소와 다른 두 가지 유형의 저장소 시스템의 가장 큰 차이는 객체 저장소에 보관되는 객체들은 변경이 불가능하다는 것이다.&lt;/li>
&lt;li>삭제한 다음 새 버전 객체로 완전히 대체할 수는 있어도 그 값을 점진적으로 변경할 수는 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>키-값 저장소(key-value store)
&lt;ul>
&lt;li>객체 저장소를 사용하는 경우 해당 객체의 URI를 사용하여 데이터를 가져올 수 있다.&lt;/li>
&lt;li>이때 URI는 키이고 데이터는 값에 해당하므로 키-값 저장소로 볼 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>저장은 1회, 읽기는 여러번
&lt;ul>
&lt;li>링크드인에서 조사한 결과에 따르면 객체 저장소에 대한 요청 가운데 95%가 읽기 요청&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>소형 및 대형 객체 동시 지원&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_1.png"
width="1368"
height="1058"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_1_hu7a09d655bdca71a694f3b89fa147b0fe_118779_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_1_hu7a09d655bdca71a694f3b89fa147b0fe_118779_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="UNIX 파일 시스템과 객체 저장소"
class="gallery-image"
data-flex-grow="129"
data-flex-basis="310px"
>&lt;/p>
&lt;p>객체 저장소의 설계 철학은 UNIX 파일 시스템의 설계 철학과 아주 비슷하다.&lt;/p>
&lt;ul>
&lt;li>파일을 로컬 파일 시스템에 저장하면 파일의 이름과 데이터는 같은 곳에 저장되지 않음
&lt;ul>
&lt;li>아이노드(inode)라고 불리는 자료 구조에 보관되고 파일의 데이터는 디스크의 다른 위치로 들어감&lt;/li>
&lt;li>아이노드에는 파일 블록 포인터 목록(디스크상의 위치를 가르킴)이 들어감&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>객체 저장소의 동작 방식도 비슷하다.&lt;/p>
&lt;ul>
&lt;li>객체 저장소의 메타데이터 저장소는 아이노드에 해당
&lt;ul>
&lt;li>파일 블록 포인터 대신 네트워크를 통해 데이터 저장소에 보관된 객체를 요청하는 데 필요한 식별자가 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 저장소는 하드 디스크에 해당&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_2.png"
width="1400"
height="648"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_2_hu9a3c03d51fe0a5ac2771442398f3385a_54968_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_2_hu9a3c03d51fe0a5ac2771442398f3385a_54968_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="버킷과 객체"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="518px"
>&lt;/p>
&lt;p>메타데이터와 객체의 실제 데이터를 분리하면 설계가 단순해진다.&lt;/p>
&lt;ul>
&lt;li>데이터 저장소에 보관되는 데이터는 불변&lt;/li>
&lt;li>메타데이터 저장소에 보관되는 데이터는 변경 가능&lt;/li>
&lt;/ul>
&lt;p>이렇게 분리해 두면 그 두 컴포넌트를 독립적으로 구현하고 최적화 할 수 있다.&lt;/p>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_3.png"
width="1596"
height="1102"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_3_hud2179ecbb7aca45fd8052ff6358b8624_96587_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_3_hud2179ecbb7aca45fd8052ff6358b8624_96587_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;ul>
&lt;li>로드밸런서
&lt;ul>
&lt;li>요청을 API 서버들에 분산&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>API 서비스
&lt;ul>
&lt;li>IAM 서비스, 메타데이터 서비스, 저장소 서비스에 대한 호출을 조율하는 역할 담당&lt;/li>
&lt;li>무상태 서비스이므로 수평적인 규모 확장이 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>IAM 서비스
&lt;ul>
&lt;li>인증, 권한 부여, 접근 제어 등을 중앙에서 맡아 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 저장소
&lt;ul>
&lt;li>실제 데이터를 보관하고 필요할 때마다 읽어가는 장소&lt;/li>
&lt;li>모든 데이터 관련 연산은 객체 ID(UUID)를 통함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 저장소
&lt;ul>
&lt;li>객체 메타데이터를 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>메타데이터 저장소와 데이터 저장소는 논리적은 구분이 뿐이며 구현 방법은 여러가지 있을 수 있다.&lt;/p>
&lt;ul>
&lt;li>RGW(Ceph&amp;rsquo;s Rados Gateway)는 독립적인 메타데이터 저장소를 두지 않고 객체 버킷을 포함한 모든 객체는 하나 이상의 라도스 객체로 저장됨&lt;/li>
&lt;/ul>
&lt;h3 id="객체-업로드">객체 업로드&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_4.png"
width="1638"
height="1110"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_4_hudeb03fde8424d983bb6ca7e620253294_125124_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_4_hudeb03fde8424d983bb6ca7e620253294_125124_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="객체 업로드"
class="gallery-image"
data-flex-grow="147"
data-flex-basis="354px"
>&lt;/p>
&lt;ol>
&lt;li>클라이언트는 &lt;code>bucket-to-share&lt;/code> 버킷을 생성하기 위한 &lt;code>HTTP PUT&lt;/code> 요청을 보낸다.&lt;/li>
&lt;li>API 서비스는 IAM을 호출하여 &lt;code>WRITE&lt;/code> 권한을 가졌는지 확인한다.&lt;/li>
&lt;li>API 서비스는 메타데이터 데이터베이스에 버킷 정보를 등록하기 위해 메타데이터 저장소를 호출한다.
&lt;ul>
&lt;li>버킷 정보가 만들어지면 그 사실을 알리는 메시지가 클라이언트에 전송된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>버킷이 만들어지고 나면 클라이언트는 &lt;code>script.txt&lt;/code> 객체를 생성하기 위한 &lt;code>HTTP PUT&lt;/code> 요청을 보낸다.&lt;/li>
&lt;li>API 서비스는 해당 사용자 신원 및 &lt;code>WRITE&lt;/code> 권한을 확인한다.&lt;/li>
&lt;li>문제가 없다면 &lt;code>HTTP PUT&lt;/code> 요청 body에 실린 객체 데이터를 데이터 저장소로 보낸다.
&lt;ul>
&lt;li>데이터 저장소는 해당 데이터를 객체로 저장하고 해당 객체의 UUID를 반환한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>API 서비스는 메타데이터 저장소를 호출하여 새로운 항목을 등록한다.
&lt;ul>
&lt;li>&lt;code>object_id&lt;/code>: UUID&lt;/li>
&lt;li>&lt;code>bucket_id&lt;/code>: 해당 객체가 속한 버킷&lt;/li>
&lt;li>&lt;code>object_name&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="객체-다운로드">객체 다운로드&lt;/h3>
&lt;p>버킷은 디렉터리 같은 계층 구조를 지원하지 않지만 버킷 이름과 객체 이름을 연결하면 폴더 구조를 흉내 내는 논리적 계층을 만들수는 있다.&lt;/p>
&lt;ul>
&lt;li>객체 이름을 &lt;code>script.txt&lt;/code> 대신 &lt;code>bucket-to-share/script.txt&lt;/code>로 설정한다.&lt;/li>
&lt;/ul>
&lt;p>앞서 언급한 대로 데이터 저장소는 객체 이름을 보관하지 않으며 &lt;code>object_id&lt;/code>(UUID)를 통한 객체 연산만 지원한다.&lt;/p>
&lt;p>따라서 객체를 다운로드 하려면 객체 이름을 우선 UUID로 변환해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_5.png"
width="1678"
height="1130"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_5_hu110197024181dbd370c8f07617508a76_123232_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_5_hu110197024181dbd370c8f07617508a76_123232_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="객체 다운로드"
class="gallery-image"
data-flex-grow="148"
data-flex-basis="356px"
>&lt;/p>
&lt;ol>
&lt;li>클라이언트는 요청을 로드밸런서로 보내고, 로드밸런서는 이 요청을 API 서버로 보낸다.&lt;/li>
&lt;li>API 서버는 IAM을 통해 &lt;code>READ&lt;/code> 권한 확인한다.&lt;/li>
&lt;li>권한이 있다면 해당 객체의 UUID를 메타데이터 자장소에서 가져온다.&lt;/li>
&lt;li>해당 UUID를 이용해 ㄱ데이터 저장소에서 객체 데이터를 가져온다.&lt;/li>
&lt;li>&lt;code>HTTP GET&lt;/code> 요청에 대한 응답으로 해당 객체 데이터를 반환한다.&lt;/li>
&lt;/ol>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="데이터-저장소">데이터 저장소&lt;/h3>
&lt;p>API 서비스는 사용자의 요청을 받으면 그 요청을 처리하기 위해 다른 내부 서비스들을 호출한다.&lt;/p>
&lt;p>객체를 저장하거나 가져오는 작업은 데이터 저장소를 호출하여 치리한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_6.png"
width="1562"
height="812"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_6_hue1e1f6cb970aa79d651ef8332bbfc81c_94602_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_6_hue1e1f6cb970aa79d651ef8332bbfc81c_94602_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="객체 업로드/다운로드"
class="gallery-image"
data-flex-grow="192"
data-flex-basis="461px"
>&lt;/p>
&lt;h3 id="데이터-저장소의-개략적-설계">데이터 저장소의 개략적 설계&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_7.png"
width="1562"
height="926"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_7_huee933f54ae912df3dcfab4f3820c10c9_199981_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_7_huee933f54ae912df3dcfab4f3820c10c9_199981_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 저장소 컴포넌트"
class="gallery-image"
data-flex-grow="168"
data-flex-basis="404px"
>&lt;/p>
&lt;p>세 가지 주요 컴포넌트로 구성된다.&lt;/p>
&lt;h3 id="데이터-라우팅-서비스">데이터 라우팅 서비스&lt;/h3>
&lt;p>데이터 노드 클러스터에 접근하기 위한 RESTful 또는 gRPC 서비스르 제공한다.&lt;/p>
&lt;p>더 많은 서버를 추가하여 쉽게 규모를 확장할 수 있는 무상태 서비스다.&lt;/p>
&lt;ul>
&lt;li>배치 서비스(placement service)를 호출하여 데이터를 저장할 최적의 데이터 노드를 판단&lt;/li>
&lt;li>데이터 노드에서 데이터를 읽어 API 서비스에 반환&lt;/li>
&lt;li>데이터 노드에 데이터 기록&lt;/li>
&lt;/ul>
&lt;h3 id="배치-서비스">배치 서비스&lt;/h3>
&lt;p>어느 데이터 노드에 데이터를 저장할 지 결정하는 역할을 담당한다.&lt;/p>
&lt;ul>
&lt;li>데이터 노드에는 주 데이터 노드와 부 데이터 노드가 있다.&lt;/li>
&lt;/ul>
&lt;p>배치 서비스는 내부적으로 가상 클러스터 지도(virtual cluster map)를 유지하는데, 믈러스터의 물리적 형상 정보가 보관된다.&lt;/p>
&lt;ul>
&lt;li>이 지도에 보관되는 데이터 노드의 위치 정보를 이용하여 데이터 사본이 물리적으로 다른 위치에 놓이도록 한다.&lt;/li>
&lt;li>물리적인 분리는 높은 데이터 내구성을 달성하는 핵심 요소이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_8.png"
width="1796"
height="574"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_8_hubd3eed9b0fa2cb41ef412d0106cdbfa1_46429_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_8_hubd3eed9b0fa2cb41ef412d0106cdbfa1_46429_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="가상 클러스터 지도"
class="gallery-image"
data-flex-grow="312"
data-flex-basis="750px"
>&lt;/p>
&lt;p>배치 서비스는 모든 데이터 노드와 지속적으로 박동 메시지를 주고받으며 상태를 모니터링 한다.&lt;/p>
&lt;ul>
&lt;li>15초의 유예 기간(grace period) 동안 박동 메시지에 응답하지 않는 데이터 노드는 지도에 죽은 노드로 표시한다.&lt;/li>
&lt;/ul>
&lt;p>배치 서비스는 아주 중요한 서비스이므로 5개에서 7개의 노드를 갖는 배치 서비스 클러스터를 팩서스(Paxos)나 래프트(Raft) 같은 합의 프로토콜을 사용하여 구축살 것을 권장한다.&lt;/p>
&lt;ul>
&lt;li>7개 노드로 구성된 배치 서비스 클러스터는 최대 3개까지의 노드 장애는 감내할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="데이터-노드">데이터 노드&lt;/h3>
&lt;p>실제 객체 데이터가 보관되는 곳으로 여러 노드에 데이터를 복제함으로써 데이터의 안정성과 내구성을 보증한다.(다중화 그룹, replication group)&lt;/p>
&lt;p>각 데이터 노드에는 배치 서비스에 주기적으로 박동 메시지를 보내는 서비스 데몬(service daemon)이 돈다.&lt;/p>
&lt;p>박동 메시지에는 다은과 같은 정보가 들어있다.&lt;/p>
&lt;ul>
&lt;li>해당 데이터 노드에 부착된 디스크 드라이브(HDD/SSD) 수&lt;/li>
&lt;li>각 드라이브에 저장된 데이터의 양&lt;/li>
&lt;/ul>
&lt;p>배치 서비스는 못 보던 데이터 노드에서 박동 메시지를 처음 받으면 해당 노드에 ID를 부여하고 가상 클러스터 지도에 추가한 다음, 아래 정보를 반환한다.&lt;/p>
&lt;ul>
&lt;li>해당 데이터 노드에 부여한 고유 식별자&lt;/li>
&lt;li>가상 클러스터 지도&lt;/li>
&lt;li>데이터 사본을 보관할 위치&lt;/li>
&lt;/ul>
&lt;h3 id="데이터-저장-흐름">데이터 저장 흐름&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_9.png"
width="1842"
height="846"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_9_hud2484f5adb04e6c8af35aa41b56cd91b_218424_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_9_hud2484f5adb04e6c8af35aa41b56cd91b_218424_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터를 영속적으로 보관하는 흐름"
class="gallery-image"
data-flex-grow="217"
data-flex-basis="522px"
>&lt;/p>
&lt;ol>
&lt;li>API 서비스는 객체 데이터를 데이터 저장소로 포워딩한다.&lt;/li>
&lt;li>데이터 라우팅 서비스는 해당 객체에 UUID를 할당하고 배치 서비스에 해당 객체를 보관할 데이터 노드를 질의한다.
&lt;ul>
&lt;li>배치 서비스는 가상 클러스터 지도를 확인하여 데이터를 보관할 주 데이터 노드를 반환한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 라우팅 서비스는 저장할 데이터를 UUID와 함께 주 데이터 노드에 직접 전송한다.&lt;/li>
&lt;li>주 데이터 노드는 데이터를 자기 노드에 지격적으로 저장하면서 두 개의 부 데이터 노드에 다중화한다.
&lt;ul>
&lt;li>주 데이터 노드는 데이터를 모든 부 데이터 노드에 성공적으로 다중화하고 나면 데이터 라우팅 서비스에 응답을 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객체의 UUID(객체 ID)를 API 서비스에 반환한다.&lt;/li>
&lt;/ol>
&lt;p>2단계는 배치 서비스에 UUID를 입력으로 주고 질의하면 해당 객체에 대한 &lt;strong>다중화 그룹&lt;/strong>이 반환된다는 뜻이다.&lt;/p>
&lt;ul>
&lt;li>계산 결과는 결정적(deterministric)이어야 한다.&lt;/li>
&lt;li>다중화 그룹이 추가되거나 삭제되는 경우에도 유지되어야 한다.&lt;/li>
&lt;li>안정해시를 주로 사용한다.&lt;/li>
&lt;/ul>
&lt;p>4단계는 응답을 반환하기 전 데이터를 모든 부 노드에 다중화하여 모든 데이터 노드에 강력한 데이터 일관성을 보장한다.&lt;/p>
&lt;ul>
&lt;li>가장 느린 사본에 대한 작업이 완료될 때까지 응답을 반환하지 못하므로, 지연 시간 측면에서는 손해이다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>데이터 일관성과 지연 시간의 관계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_10.png"
width="1548"
height="1152"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_10_hu9ec2670cad1863e2491411118c330729_153472_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_10_hu9ec2670cad1863e2491411118c330729_153472_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 일관성과 지연 시간 사이의 타협적 관계"
class="gallery-image"
data-flex-grow="134"
data-flex-basis="322px"
>&lt;/p>
&lt;ol>
&lt;li>데이터를 세 노드에 전부 보관하면 성공적으로 보관하였다고 간주
&lt;ul>
&lt;li>데이터 일관성 측면에서는 최선이지만 응답 지연은 가장 높다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터르 주 데이터 및 두 개 부 노드 가운데 하나에 성공적으로 보관하면 성공적으로 저장하였다고 간주
&lt;ul>
&lt;li>중간 정도의 데이터 일관성 및 응답 지연을 제공&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터를 주 데이터에 보관하고 나면 성공적으로 저장했다고 간주
&lt;ul>
&lt;li>데이터 일관성 측면에서는 최악이지만 응답 지연은 가장 낮다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>2, 3은 모두 &lt;strong>결과적 일관성&lt;/strong>(eventual consistency)의 한 형태로 볼 수 있다.&lt;/p>
&lt;h3 id="데이터는-어떻게-저장되는가">데이터는 어떻게 저장되는가&lt;/h3>
&lt;p>가장 단순한 방안은 각각의 객체를 개별 파일로 저장하는 것 이지만 작은 파일이 많아지면 성능이 떨어진다.&lt;/p>
&lt;ul>
&lt;li>낭비되는 데이터 블록 수가 늘어난다.
&lt;ul>
&lt;li>파일 시스템은 보통 4KB의 디스크 블록으로 파일을 저장하는데 크기가 작아도 하나의 블록을 모두 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>시스템의 아이노드(inode) 용량 한계를 초과할 수 있다.
&lt;ul>
&lt;li>사용 가능한 아이노드 수는 디스크가 초기화 되는 순간 결정되고, 작은 파일의 수가 매우 많아지면 전부 소진될 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파일 시스템 메타데이터를 공격적으로 캐싱하는 전략을 취하더라도 아주 많은 양의 아이노드를 효과적으로 처리하지 못한다.&lt;/li>
&lt;/ul>
&lt;p>따라서 작은 객체를 개별 파일 형태로 저장하는 방안은 현실에서는 쓸모없으며, 작은 객체들을 큰 파일 하나로 모아서 처리해야한다.&lt;/p>
&lt;ul>
&lt;li>개념적으로는 WAL(Write-Ahead Log)와 같이 객체를 저장할 때 이미 존재하는 파일에 추가하는 방식&lt;/li>
&lt;li>용량 임계치에 도달한 파일(보통 수 GB)은 읽기 전용 파일로 변경하고 새로운 파일을 만든다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_11.png"
width="1644"
height="1068"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_11_hu8ca19c5a46cc9441fdf4a4e9249e00d6_63670_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_11_hu8ca19c5a46cc9441fdf4a4e9249e00d6_63670_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="작은 객체들을 한 파일에 저장하는 방안"
class="gallery-image"
data-flex-grow="153"
data-flex-basis="369px"
>&lt;/p>
&lt;ul>
&lt;li>읽기-쓰기 파일에 대한 쓰기 연산은 순차적으로 이루어져야 함&lt;/li>
&lt;li>객체는 파일에 일렬로 저장됨&lt;/li>
&lt;li>여러 CPU 코어가 쓰기 연산을 병렬로 진행하더라도 객체 내용이 뒤섞이면 안된다.
&lt;ul>
&lt;li>파일에 객체를 기록하기 위해 순서를 기다려야 한다.&lt;/li>
&lt;li>쓰기 대역폭이 심각하게 줄어들기 때문에 서버에 오는 요청을 처리하는 코어별로 전담 읽기-쓰기 파일을 두는 것이 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="객체-소재-확인">객체 소재 확인&lt;/h3>
&lt;p>각각의 데이터 파일 안에 많은 작은 객체가 들어 있다면 데이터노드가 UUID로 객체를 찾기 위해 다음 정보가 필요하다.&lt;/p>
&lt;ul>
&lt;li>객체가 보관된 데이터 파일&lt;/li>
&lt;li>데이터 파일 내 객체 오프셋&lt;/li>
&lt;li>객체 크기&lt;/li>
&lt;/ul>
&lt;pre class="mermaid" style="text-align: center;">classDiagram
class object_mapping {
object_id
file_name
start_offset
object_size
}
&lt;/pre>
&lt;p>이 정보를 저장하는 데 두 가지 방법이 있다.&lt;/p>
&lt;ul>
&lt;li>파일 기반 키-값 저장소(ex. RocksDB)
&lt;ul>
&lt;li>SSTable에 기반한 방법으로 쓰기 연산 성능은 좋지만 읽기 성능은 느리다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>관계형 데이터베이스
&lt;ul>
&lt;li>B+ 트리 기반 저장 엔진을 이용하며 읽기 연산 성능은 좋지만 쓰기 성능은 느리다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>객체 저장소의 데이터는 한 번 기록된 후에는 변경되지 않고, 읽기 연산이 매우 많이 발생하므로 읽기 연산 성능이 좋은 관계형 데이터베이스가 더 나은 선택이다.&lt;/p>
&lt;hr>
&lt;p>객체 위치를 저장하는 테이블의 데이터 양은 막대하므로, 하나의 거대 클러스터에 모든 데이터 노드를 저장하는 방안도 가능하지만 관리가 까다롭다.&lt;/p>
&lt;p>하지만 데이터 노드에 저장되는 위치 데이터를 다른 데이터 노드와 공유할 필요가 없기 때문에 데이터 노드마다 관계형 데이터베이스를 설치하는 방안이 가능하다.&lt;/p>
&lt;ul>
&lt;li>SQLite는 이런 경우 딱 만는 파일 기반 관계형 데이터베이스이다.&lt;/li>
&lt;/ul>
&lt;h3 id="개선된-데이터-저장-흐름">개선된 데이터 저장 흐름&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_12.png"
width="1824"
height="1032"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_12_hu427877cf20e851a8fff9b8e8fd5c331f_120715_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_12_hu427877cf20e851a8fff9b8e8fd5c331f_120715_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="img_12.png"
class="gallery-image"
data-flex-grow="176"
data-flex-basis="424px"
>&lt;/p>
&lt;ol>
&lt;li>API 서비스는 새로운 객체를 저장하는 요청을 데이터 노드 서비스에 전송한다.&lt;/li>
&lt;li>데이터 노드 서비스는 새로운 객체를 읽기-쓰기 파일 &lt;code>/data/c&lt;/code>의 마지막 부분에 추가한다.&lt;/li>
&lt;li>해당 객체에 대한 새로운 레코드를 &lt;code>object_mapping&lt;/code> 테이블에 추가한다.&lt;/li>
&lt;li>데이터 노드 서비스는 API 서비스에 해당 객체의 UUID를 반환한다.&lt;/li>
&lt;/ol>
&lt;h3 id="데이터-내구성">데이터 내구성&lt;/h3>
&lt;p>데이터 안정성은 데이터 저장 시스템에 아주 중요하다.&lt;/p>
&lt;p>식스 나인 수준의 데이터 내구성을 제공하는 저장소 시스템을 만들려면 장애가 발생할 모든 경우를 세심하게 살핀 다음 데이터를 적절히 다중화해야한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>하드웨어 장애와 장애 도메인&lt;/strong>&lt;/p>
&lt;p>기록 매체 종류와 관계없이, 하드 디스크 장애는 필할 수 없기 때문에 드라이브 한 대로 원하는 내구성 목표를 달성 불가능하다.&lt;/p>
&lt;p>내구성을 높이는 검증된 방법은 &lt;strong>데이터를 여러 대의 하드 드라이브에 복제하여 어떤 드라이브에서 발생한 장애가 전체 데이터 가용성에 영향을 주지 않도록 하는 것&lt;/strong> 이다.&lt;/p>
&lt;p>본 설계안에서는 데이터를 3중 복제 한다.&lt;/p>
&lt;ul>
&lt;li>회전식 드라이브 연간 장애율이 0.81%라면 3중 복제했을 때 내구성은 &lt;code>1 - 0.0081^3 = ~0.999999&lt;/code> 이다.&lt;/li>
&lt;/ul>
&lt;p>완전한 내구성 평가를 위해서는 여러 장애 도메인의 영향을 복합적으로 고려할 필요가 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>장애 도매인&lt;/strong>&lt;br>
중요한 서비스에 문제가 발생했을 때 부정적인 영향을 받는 물리적 또는 논리적 구획&lt;/p>
&lt;/blockquote>
&lt;p>대규모의 장애 도메인 사례로는 데이터센터의 가용성 구역(Availability Zone, AZ)가 있다.(다른 데이터센터와 물리적 인프라를 공유하지 않는 독립적 데이터센터 하나)&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_13.png"
width="1652"
height="1148"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_13_hudb8ff539c5bf2674cee737d5db0dd958_73597_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_13_hudb8ff539c5bf2674cee737d5db0dd958_73597_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="여러 데이터센터를 활용한 데이터 다중화"
class="gallery-image"
data-flex-grow="143"
data-flex-basis="345px"
>&lt;/p>
&lt;p>데이터를 여러 AZ에 복제해 놓으면 장애 여파를 최소화할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>소거 코드&lt;/strong>&lt;/p>
&lt;p>소거 코드(erasure coding)라는 방안으로 내구성을 달성하는 방안도 고려할 수 있다.&lt;/p>
&lt;p>데이터를 작은 단위로 분할하여 다른 서버에 배치하는 한편, 그 가운데 일부가 소실되었을 때 복구하기 위한 패리티(parity)라는 정보를 만들어 중복성(redundancy)를 확보한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_14.png"
width="1342"
height="918"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_14_hu836aad3383e3c48a234e9d0f35991e7d_87832_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_14_hu836aad3383e3c48a234e9d0f35991e7d_87832_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="4&amp;#43;2 소거 코드를 통한 데이터 복구"
class="gallery-image"
data-flex-grow="146"
data-flex-basis="350px"
>&lt;/p>
&lt;p>장애가 생기면 남은 데이터와 패리티를 조합하여 소실된 부분을 복구한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_15.png"
width="1396"
height="1394"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_15_hub4ff7f8e2f435a2e0b557649a977f288_176307_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_15_hub4ff7f8e2f435a2e0b557649a977f288_176307_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="8&amp;#43;4 소거 코드"
class="gallery-image"
data-flex-grow="100"
data-flex-basis="240px"
>&lt;/p>
&lt;ul>
&lt;li>원본 데이터는 8조각으로 분할하고 4개의 패리티를 계산&lt;/li>
&lt;li>그 결과로 만들어진 12조각의 데이터는 전부 같은 크기로, 12개의 장애 도메인에 분산&lt;/li>
&lt;/ul>
&lt;p>소거 코드 이며느이 수식으로 최대 4대 노드에 장애가 동시에 발생하더라도 원본 데이터를 복원해 낼 수 있다.&lt;/p>
&lt;p>데이터를 다중화 할 경우 데이터 라우터는 객체 데이터를 하나의 건강한 노드에서 읽으면 충분하겠지만 소거 코드를 사용하면 최대 8개의 건강한 노드에서 데이터를 가져와야 한다.&lt;/p>
&lt;ul>
&lt;li>응답 지연은 높아지는 대신 내구성은 향상되고 저장소 비용은 낮아진다.&lt;/li>
&lt;li>객체 저장소는 저장 비용이 대부분이어서 고려할 가치가 있다.
&lt;ul>
&lt;li>소거 코드를 사용하면 2개 데이터 블록에 하나의 패리티 블록이 필요하므로 저장 공간이 50% 더 필요하다.&lt;/li>
&lt;li>3중 복제 다중화 방안을 채택한다면 200%&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_16.png"
width="1100"
height="822"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_16_hu2a647937338907523b8691a4543fbf22_49675_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_16_hu2a647937338907523b8691a4543fbf22_49675_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="유형 별 요구하는 추가 용량"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="321px"
>&lt;/p>
&lt;p>소거 코드를 사용하면 노드의 연산 장애 발생률이 0.81%라고 했을 때 11 나인 내구성을 달성할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>비교&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>다중화&lt;/th>
&lt;th>소거 코드&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>내구성&lt;/td>
&lt;td>3중 복제시 4-nines&lt;/td>
&lt;td>8+4 소거 코드 사용시 11-nines&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>저장소 효율성&lt;/td>
&lt;td>200% 오버헤드&lt;/td>
&lt;td>50%의 오버헤드&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>계산 자원&lt;/td>
&lt;td>계산이 필요없음&lt;/td>
&lt;td>패리티 계산에 많은 계산 자원 소모&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>쓰기 성능&lt;/td>
&lt;td>데이터를 여러 노드에 복제하므로 추가로 필요한 계산은 없음&lt;/td>
&lt;td>데이터를 디스크에 기록하기 전에 패리티 계산이 필요하므로 쓰기 연산의 응답 지연 증가&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>읽기 성능&lt;/td>
&lt;td>장애가 발생하지 않은 노드에서 데이터를 읽음&lt;/td>
&lt;td>데이터를 읽어야할 때마다 클러스터 내의 여러 노드에서 데이터를 가져와야 함. 장애가 발생한 경우 빠진 데이터를 먼저 복원해야하므로 지연 시간 증가&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>응답 지연이 중요한 애플리케이션에서는 다중화 방안이 좋을 수 있다.&lt;/li>
&lt;li>저장소 비용이 중요한 애플리케이션에서는 소거 코드가 좋을 수 있다.&lt;/li>
&lt;/ul>
&lt;p>소거 코드는 비용 효율과 내구성 측면에서 매력적이지만 데이터 노드의 설계 측면에서는 까다롭다.&lt;/p>
&lt;h3 id="정확성-검증">정확성 검증&lt;/h3>
&lt;p>대규모 시스템의 경우 데이터 훼손 문제는 디스크에 국한되지 않고, 메모리의 데이터가 망가지는 일도 자주 일어난다.&lt;/p>
&lt;p>메모리 데이터가 훼손되는 문제는 프로세스 경계에 데이터 검증을 위한 체크섬을 두어 해결할 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>체크섬&lt;/strong>&lt;br>
데이터 에러를 발견하는 데 사용되는 작은 크기의 데이터 블록&lt;/p>
&lt;/blockquote>
&lt;p>원본 데이터의 체크섬을 알면 전송 받은 데이터의 정확성은 해당 데이터의 체크섬을 다시 계산한 후 다음과 절차로 확인한다.&lt;/p>
&lt;ul>
&lt;li>새로 계산한 체크 섬이 원본 체크섬과 다르면 데이터가 만가진 것이다.&lt;/li>
&lt;li>같은 경우에는 아주 높은 확률로 데이터는 온전하다고 볼 수 있다.
&lt;ul>
&lt;li>100%는 아니지만 아주 낮다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>좋은 체크섬 알고리즘은 입력이 조금이라도 달라지면 크게 달라진 체크섬을 내놓는다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_17.png"
width="1392"
height="1238"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_17_hu1a5439a4a88930d5116191c16c7bcf73_86242_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_17_hu1a5439a4a88930d5116191c16c7bcf73_86242_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 노드에 체크섬 추가"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="269px"
>&lt;/p>
&lt;p>체크섬은 객체 데이터 끝에 두며, 파일을 읽기 전용으로 전환하기 직전에 전체 파일의 체크섬을 계산한 후 파일 끝에 추가한다.&lt;/p>
&lt;hr>
&lt;p>(8 + 4) 소거 코드와 체크섬 확인 매커니즘을 동시에 활용하는 경우 객체 데이터를 읽을 때마다 다음 절차를 수행한다.&lt;/p>
&lt;ol>
&lt;li>객체 데이터와 체크섬을 가져온다.&lt;/li>
&lt;li>수신된 데이터의 체크섬을 계산한다.
&lt;ol>
&lt;li>두 체크섬이 일치하면 데이터에는 에러가 없다고 간주한다.&lt;/li>
&lt;li>체크섬이 다르면 망가진 것 이므로 다른 장애 도메인에서 데이터를 가져와 복구를 시도한다.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>데이터 8조각을 전부 수신할 때 까지 1과 2를 반복한 후, 원래 객체를 복원한 다음 클라이언트에게 보낸다.&lt;/li>
&lt;/ol>
&lt;h3 id="메타데이터-데이터-모델">메타데이터 데이터 모델&lt;/h3>
&lt;p>&lt;strong>스키마&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_18.png"
width="1142"
height="406"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_18_hu1b891d9c3dfed1d4ce48f3ad5689625e_77413_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_18_hu1b891d9c3dfed1d4ce48f3ad5689625e_77413_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="메타데이터 데이터베이스 스키마"
class="gallery-image"
data-flex-grow="281"
data-flex-basis="675px"
>&lt;/p>
&lt;p>이 데이터베이스 스키마는 다음 3가지 질의를 지원해야한다.&lt;/p>
&lt;ul>
&lt;li>객체 이름으로 객체 ID 찾기&lt;/li>
&lt;li>객체 이름에 기반하여 객체 삽입 또는 삭제&lt;/li>
&lt;li>같은 접두어를 갖는 버킷 내의 모든 객체 목록 확인&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>bucket 테이블 규모 확장&lt;/strong>&lt;/p>
&lt;p>보통 한 사용자가 만들 수 있는 버킷의 수에는 제한이 있으므로, 테이블의 크기는 작기 때문에 최신 데이터베이스 서버 한 대에 충분히 저장할 수 있다.&lt;/p>
&lt;ul>
&lt;li>백만명 고객이 10개의 버킷을 가지고 있고, 레코드가 10KB라면 10GB 정도 필요함&lt;/li>
&lt;/ul>
&lt;p>하지만 모든 읽기 요청을 처리하기에는 CPU 용량이나 네트워크 대역폭이 부족할 수 있으므로, 데이터베이스 사본을 만들어 읽기 부하를 분산한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>object 테이블의 규모 확장&lt;/strong>&lt;/p>
&lt;p>&lt;code>object&lt;/code> 테이블에는 객체 메타데이터가 보관되는데, 설계안이 다루는 규모의 경우 객체 메타데이터를 데이터베이스 서버 한 대에 보관하기는 불가능하므로 샤딩을 통해 확장해야한다.&lt;/p>
&lt;ul>
&lt;li>테이블을 샤딩할 때 &lt;code>bucket_id&lt;/code>을 샤딩키로 사용하게되면, 핫스팟 샤드를 지원하지 못하므로 좋은 방안은 아니다.&lt;/li>
&lt;li>&lt;code>object_id&lt;/code>를 기준으로 샤딩하면 부하를 균등하게 분산할 수는 있지만 URI를 기준으로 동작하는 질의 1, 2를 효율적으로 지원하지 못한다.&lt;/li>
&lt;/ul>
&lt;p>대부분의 메타데이터 관련 연산이 객체 URI를 기준으로 하는 특성을 고려하여 &lt;code>bucket_name&lt;/code>과 &lt;code>object_name&lt;/code>을 결합하여 샤딩에 사용한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>bucket_name&lt;/code>과 데이터를 균등하게 분산하기위해 &lt;code>object_name&lt;/code>의 순서쌍을 해싱한 값을 샤딩키로 사용한다.&lt;/li>
&lt;/ul>
&lt;h3 id="버킷-내-객체-목록-확인">버킷 내 객체 목록 확인&lt;/h3>
&lt;p>객체 저장소는 객체를 파일 시스템처럼 계층적 구조로 보관하지 않는다.&lt;/p>
&lt;p>&lt;code>s3://mybucket/abc/d/e/f/file.txt&lt;/code>와 같은 경로가 있다면&lt;/p>
&lt;ul>
&lt;li>&lt;code>mybucket&lt;/code>은 버킷 이름&lt;/li>
&lt;li>&lt;code>abc/d/e/f/file.txt&lt;/code>는 파일 이름&lt;/li>
&lt;/ul>
&lt;p>S3는 사용자가 버킷 내 객체들을 잘 정리할 수 있도록 &lt;strong>접두어&lt;/strong>(prefix)라는 개념을 지원한다.&lt;/p>
&lt;p>접두어는 객체 이름의 시작 부분 문자열을 일컫는데, 잘 사용한다면 디렉터리와 비슷하게 데이터를 잘 정리할 수 있다.&lt;/p>
&lt;p>하지만 접두어는 디렉터리가 아니므로 어떤 접두어에 대응되는 객체 목록을 얻으려 하면 오직 해당 접두어로 시작하는 이름의 객체만 반환될 것이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>s3://mybucket/abc/d/e/f/file.txt&lt;/code>의 접두어는 &lt;code>abc/d/e/f&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>S3가 제공하는 목록 출력 명령어는 보통 다음과 같이 쓰인다.&lt;/p>
&lt;ul>
&lt;li>어떤 사용자가 가진 모든 버킷 목록 출력
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">aws s3 list-buckets
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>주어진 접두어를 가진 같은 버킷 내 모든 객체 목록 출력
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">aws s3 ls s3://mybucket/abc/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>주어진 접두어를 가진, 같은 버킷 내 모든 객체를 재귀적으로 출력
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">aws s3 ls s3://mybucket/abc/ --recursive
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="단일-데이터베이스-서버">단일 데이터베이스 서버&lt;/h3>
&lt;p>단일 데이터베이스 서버로 목록 출력 명령어를 어떻게 지원하는지 살펴본다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">object&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bucket_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">123&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">object_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">abc&lt;/span>&lt;span class="o">/%`&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>목록 출력 명령어의 두번째 명령과 같이 해당 접두어 이후에 더 많은 샐래시 기호가 포함된 이름을 가진 객체들을 디렉터리처럼 보이도록 묶는 작업은 애플리케이션에서 담당한다.&lt;/p>
&lt;h3 id="분산-데이터베이스">분산 데이터베이스&lt;/h3>
&lt;p>메타데이터 테이블을 샤딩하면 어떤 샤드에 데이터가 있는지 모르므로 목록 출력 기능을 구현하기 어렵다.&lt;/p>
&lt;p>가장 단순한 해결책은 검색 질의를 모든 샤드에 돌린 다음 결과를 취합하는 것 이지만 페이지 나눔(pagination) 기능을 구현하기 복잡하다.&lt;/p>
&lt;p>객체가 여러 샤드에 나눠져 있으므로, 샤드마다 반호나하는 객체 수는 제각각이다.&lt;/p>
&lt;ul>
&lt;li>어떤 샤드에는 한 페이지를 꽉 채울 객체가 있을 수 있지만, 적거나 없는 샤드도 있을 수 있다.&lt;/li>
&lt;/ul>
&lt;p>애플리케이션 코드는 모든 샤드의 질의 결과를 받아 취합한 다음 정렬하여 그중 10개만 추려야한다.&lt;/p>
&lt;ul>
&lt;li>이번에 반환할 페이지에 포함되지 못한 객체는 다음에 다시 고려해야하므로, 샤드마다 추적해야하는 오프셋이 달라질 수 있다.&lt;/li>
&lt;/ul>
&lt;p>따라서 서버는 모든 샤드의 오프셋을 추적하여 커서에 결부시킬수 있어야 하므로 관리가 어려워진다.&lt;/p>
&lt;p>이 문제를 해결할 방법은 있으나 객체 저장소는 규모와 내구성 최적화에 치중하고, 객체 목록 출력 명령의 성능을 보장하는 것은 우선순위가 낮다.&lt;/p>
&lt;p>그 사실을 감안하여 버킷 ID로 샤딩하는 별도 테이블에 목록 데이터를 비정규화할 수 있다.&lt;/p>
&lt;ul>
&lt;li>객체 목록을 출력할 때는 이 테이블에 있는 데이터만 사용한다.&lt;/li>
&lt;li>목록 질의문을 한 대의 데이터베이스 서버로 돌릴 수 있으므로, 구현을 단순하게 만들 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="객체-버전">객체 버전&lt;/h3>
&lt;p>객체 버전은 버킷 안에 한 객체의 여러 버전을 둘 수 있도록 하는 기능으로 실수로 지우거나 덮어 쓴 객체를 쉽게 복구할 수 있다.&lt;/p>
&lt;p>문서를 수정한 다음 같은 버킷 안에 같은 이름으로 저장했다면&lt;/p>
&lt;ul>
&lt;li>버전 기능이 없으면
&lt;ul>
&lt;li>해당 문서의 이전 메타데이터는 새 메타데이터로 완전히 대체된다.&lt;/li>
&lt;li>이전 문서는 삭제된 것으로 표시되고, 쓰레기 수집기가 회수한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>버전 기능이 있으면
&lt;ul>
&lt;li>객체 저장소는 해당 문서의 모든 이전 버전을 메타데이터 저장소에 유지한다.&lt;/li>
&lt;li>이전 버전에 삭제 표시를 할 수 있다(안해도 된다.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>버전이 다른 객체 업로드&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_19.png"
width="1844"
height="858"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_19_hu63377921f525c42971966f2d10821269_90319_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_19_hu63377921f525c42971966f2d10821269_90319_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="메타데이터와 버전 정보"
class="gallery-image"
data-flex-grow="214"
data-flex-basis="515px"
>&lt;/p>
&lt;p>버전 기능을 지원하기 위해 메타데이터 저장소의 객체 테이블에는 &lt;code>object_version&lt;/code>이라는 컬럼이 있고, 버전 기능이 활성화 되었을 경우에만 사용한다.&lt;/p>
&lt;ul>
&lt;li>기존 레코드를 덮어쓰는 대신, &lt;code>bucket_id&lt;/code>, &lt;code>object_name&lt;/code>은 같지만 &lt;code>object_id&lt;/code>, &lt;code>object_version&lt;/code>은 새로운 값인 레코드를 추가한다.
&lt;ul>
&lt;li>&lt;code>object_id&lt;/code>: 새 객체의 UUID&lt;/li>
&lt;li>&lt;code>object_version&lt;/code>: 새로운 레코드가 테이블에 추가될 때 만들어지는 TIMEUUID 값&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>메타데이터 저장소로 어떤 데이터베이스를 선택하건, 특정 객체의 현재 버전을 조회하는 연산은 효과적으로 처리될 수 있어야 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>객체 삭제&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_20.png"
width="1850"
height="896"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_20_hu154db864fa60cf04595279bac743b9f1_103831_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_20_hu154db864fa60cf04595279bac743b9f1_103831_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="삭제 표식 삽입을 통한 객체 삭제"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="495px"
>&lt;/p>
&lt;p>객체를 삭제할 때는 해당 객체의 모든 버전을 버킷 안에 그대로 둔 채 삭제 표식만 추가한다.&lt;/p>
&lt;p>삭제 표식은 객체의 새로운 버전으로 삽입되는 순간 해당 &lt;strong>객체의 새로운 현재 버전&lt;/strong>이 된다.&lt;/p>
&lt;ul>
&lt;li>현재 버전 객체(삭제된 버전)를 가져오는 &lt;code>GET&lt;/code> 요청은 보내면 &lt;code>404 Object Not Found&lt;/code> 오류가 반환된다.&lt;/li>
&lt;/ul>
&lt;h3 id="큰-파일의-업로드-성능-최적화">큰 파일의 업로드 성능 최적화&lt;/h3>
&lt;p>큰 파일(몇 GB 이상)을벜닛에 직접 업로드하는 것도 가능은 하지만 시간이 매우 오래 걸릴 것이다.&lt;/p>
&lt;p>업로드 중간 네트워크 문제가 생기면 다시 업로드 해야한다는 문제도 있다.&lt;/p>
&lt;p>따라서 큰 객체는 작게 쪼갠 다음 독립적으로 업로드하는 것이 더 나은 방법이다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>멀티파트(multipart) 업로드&lt;/strong>&lt;br>
크기가 큰 대상을 쪼개 독립적으로 업로드한 후 모든 조각이 업로드되면 그 조각을 모아 원본을 복원하는 방법&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_21.png"
width="1210"
height="1414"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_21_hu9bfa49f24a5be20edd7d8c375a3b17ab_94328_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_21_hu9bfa49f24a5be20edd7d8c375a3b17ab_94328_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="멀티파트 업로드"
class="gallery-image"
data-flex-grow="85"
data-flex-basis="205px"
>&lt;/p>
&lt;p>객체 조립이 끝난 뒤에는 조각들은 더이상 쓸모가 없어지므로 이러한 조각을 삭제하여 저장 용량을 확보하는 쓰레기 수집 프로세스를 구현할 필요가 있을 수 있다.&lt;/p>
&lt;h3 id="쓰레기-수집">쓰레기 수집&lt;/h3>
&lt;p>쓰레기 수집(garbage collection)은 더 이상 사용되지 않는 데이터에 할당된 저장 공간을 자동으로 회수하는 절차이다.&lt;/p>
&lt;p>본 시스템은 다음과 같은 경우 쓰레기 데이터가 생길 수 있다.&lt;/p>
&lt;ul>
&lt;li>객체의 지연된 삭제(lazy object deletion)
&lt;ul>
&lt;li>삭제했다고 표시는 하지만 실제로 지우지는 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>갈 곳 없는 데이터(orphaned data)
&lt;ul>
&lt;li>반쯤 업로드된 데이터, 또는 취소된 멀티 파트 업로드 데이터&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>훼손된 데이터(corrupted data)
&lt;ul>
&lt;li>체크섬 검사에 실패한 데이터&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>쓰레기 수집기는 객체를 데이터 저장소에 바로 지우지 않고 정리(compaction) 메커니즘을 주기적으로 실행하여 지운다.&lt;/p>
&lt;p>쓰레기 수집기는 사용되지 않는 사본에 할당된 저장 공간을 회수하는 역할도 담당한다.&lt;/p>
&lt;ul>
&lt;li>데이터를 다중화하는 경우 객체는 주 저장소 노드에서 뿐 아니라 부 저장소 노드에서도 지워야 한다.&lt;/li>
&lt;li>(8+2) 소거 코드를 사용하는 경우 12개 노드에서 전부 지워야한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/9/img_22.png"
width="1650"
height="1344"
srcset="https://codemario318.github.io/post/system-design-interview-2/9/img_22_hu27b10be6477e1cda4b354626a6189f79_110941_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/9/img_22_hu27b10be6477e1cda4b354626a6189f79_110941_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="쓰레기 수집기 정리 메커니즘"
class="gallery-image"
data-flex-grow="122"
data-flex-basis="294px"
>&lt;/p>
&lt;ol>
&lt;li>쓰레기 수집기는 &lt;code>/data/b&lt;/code>의 객체를 &lt;code>/data/d&lt;/code>로 복사한다.&lt;/li>
&lt;li>모든 객체를 복사한 다음 &lt;code>object_mapping&lt;/code> 테이블을 갱신한다.
&lt;ul>
&lt;li>객체 3의 경우 &lt;code>file_name&lt;/code>과 &lt;code>start_offset&lt;/code> 값은 새 위치를 가리키도록 수정된다.&lt;/li>
&lt;li>데이터 일관성을 위해 같은 트랜잭션 안에서 연산을 수행하는 것이 바람직하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>정리 후 새 파일의 크기는 종전보다 작다.&lt;/p>
&lt;p>작은 파일을 많이 만들지 않기 위해 쓰레기 수집기는 보통 압출할 읽기 전용 파일이 많아질 때가지 기다리며, 압축을 진행하면서 여러 읽기 전용 파일에 기록된 객체를 하나의 파일로 모은다.&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;ul>
&lt;li>블록 저장소, 파일 저장소, 객체 저장소의 차이&lt;/li>
&lt;li>객체 업로드, 다운로드, 버킷 내 객체 목록 표시, 객체 버전 등의 기능의 구현&lt;/li>
&lt;li>데이터 저장소와 메타데이터 저장소 구현&lt;/li>
&lt;li>데이터 저장소에 어떻게 영속적으로 저장되는지&lt;/li>
&lt;li>데이터 안정성과 내구성을 높이는 두 가지 방안(다중화, 소거 코드)&lt;/li>
&lt;li>멀티파트 업로드&lt;/li>
&lt;li>쓰레기 수집 장법&lt;/li>
&lt;/ul></description></item><item><title>아키텍처 관점에서 ORM을 사용하는 이유</title><link>https://codemario318.github.io/post/common/architect-orm/</link><pubDate>Sat, 02 Nov 2024 10:11:49 +0900</pubDate><guid>https://codemario318.github.io/post/common/architect-orm/</guid><description>&lt;img src="https://codemario318.github.io/post/common/architect-orm/cover.png" alt="Featured image of post 아키텍처 관점에서 ORM을 사용하는 이유" />&lt;p>안녕하세요😁 오늘은 제가 생각하는 &lt;strong>ORM&lt;/strong>(Object Relational Mapping)을 사용하는 이유에 대한 개인적인 생각을 써보려고 합니다.&lt;/p>
&lt;p>저는 현재 부스트캠프 웹 풀스택 9기 멤버십 과정에 참여중인데, 피어 세션이라던가 스터디 그룹에서 다른 분들과 ORM에 대한 이야기를 할 일이 많았어요&lt;/p>
&lt;p>이야기 나눴던 분들이 말하는 ORM은 아래와 같은 내용이 대부분이었습니다.&lt;/p>
&lt;ul>
&lt;li>ORM은 쿼리 빌더처럼 직접 SQL을 사용하지 않고도 쿼리를 작성해주는 도구이다.&lt;/li>
&lt;li>RDB 테이블을 객체 지향적으로 사용할 수 있게 만들어주는 도구이다.&lt;/li>
&lt;li>일관된 구조를 활용하기 때문에 유지보수가 편리해진다.&lt;/li>
&lt;/ul>
&lt;p>위 처럼 제가 이야기나눴던 분들은 대부분 편의성에 초점을 맞추시는 것 같았어요&lt;/p>
&lt;hr>
&lt;p>조금 깔끔하게 정리해보면 &lt;strong>ORM은 RDB 테이블에 저장된 데이터 조회하여 주요 관심사 단위인 엔티티 객체로 만들기 위해 사용&lt;/strong>됩니다.&lt;/p>
&lt;p>다른 분들이 말씀해주셨던 내용 모두 맞는 말 입니다. 그런데 위에서 언급했던 장점들이 ORM을 사용하는 &lt;strong>본질적인 이유&lt;/strong>일까요?&lt;/p>
&lt;p>이는 사실 ORM을 사용했을 때 &lt;strong>부가적으로 따라오는 장점&lt;/strong>이며 저는 조금 더 근본적인 이유가 바로 &lt;strong>아키텍처&lt;/strong>에 있다고 생각합니다.&lt;/p>
&lt;h2 id="rdbms와-아키텍처">RDBMS와 아키텍처&lt;/h2>
&lt;p>먼저 관계형 데이터베이스가 소프트웨어 아키텍처에 어떤 영향을 주는지 살펴보면 좋을 것 같아요&lt;/p>
&lt;p>아직까지도 관계형 데이터베이스는 웹서비스에서 가장 많이 활용되는 기술입니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/common/architect-orm/img_2.png"
width="866"
height="650"
srcset="https://codemario318.github.io/post/common/architect-orm/img_2_huc333306ede2f54d49d5eff7dc126e0c7_92178_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/common/architect-orm/img_2_huc333306ede2f54d49d5eff7dc126e0c7_92178_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="319px"
>&lt;img src="https://codemario318.github.io/post/common/architect-orm/img_3.png"
width="213"
height="237"
srcset="https://codemario318.github.io/post/common/architect-orm/img_3_hu875005b2d960dbb09b53d1a8c10ff308_9502_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/common/architect-orm/img_3_hu875005b2d960dbb09b53d1a8c10ff308_9502_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="PostgreSQL"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="215px"
>&lt;/p>
&lt;p>관계형 데이터베이스는 데이터를 표(table) 형식으로 구성하여 저장하고, 연관된 데이터는 각 테이블의 관계를 통해 관리할 수 있죠&lt;/p>
&lt;hr>
&lt;p>책 &lt;strong>클린 아키텍처&lt;/strong>에서는 소프트웨어 아키텍처는 세부사항에 의존하면 유연하지 못한 아키텍처가 된다는 것을 항상 강조하고 있습니다.&lt;/p>
&lt;p>&lt;strong>데이터베이스는 세부사항이다&lt;/strong> 단락을 보면 아래와 같은 내용들이 언급됩니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>아키텍처 관점에서 볼 때 &lt;strong>데이터베이스는 엔티티&lt;/strong>가 아니다.&lt;/em>&lt;br>
&lt;em>데이터 모델과는 달리 아키텍처 관점에서는 데이터베이스는 세부사항이라 &lt;strong>아키텍처의 구성 요소 수준으로 끌어올릴 수 없다&lt;/strong>.&lt;/em>&lt;br>
&lt;em>데이터베이스는 &lt;strong>소프트웨어&lt;/strong>일 뿐이며, &lt;strong>데이터에 접근할 방법을 제공하는 유틸리티&lt;/strong>다.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>그리고 아키텍처 관점의 &lt;strong>컴포넌트&lt;/strong>에 대해 중요하게 언급하는데요, &lt;strong>아키텍처 관점의 컴포넌트&lt;/strong>를 설명한다면 아래와 같습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>컴포넌트는 &lt;strong>시스템의 구성 요소로 배포할 수 있는 가장 작은 단위&lt;/strong>다.&lt;/em>&lt;br>
&lt;em>&amp;lt;중략&amp;hellip;&amp;gt;&lt;/em>&lt;br>
&lt;em>컴포넌트가 마지막에 어떤 형태로 배포되든, &lt;strong>잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야한다&lt;/strong>.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>이러한 이유 때문에 &lt;strong>Spring&lt;/strong> 같은 경우는 데이터 저장소에 대한 일관된 처리 추상화한 &lt;code>Spring Data&lt;/code>를 제공합니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이제 위에서 언급한 클린 아키텍처에서 언급했던 컴포넌트 그리고 세부사항을 중심으로 관계형 데이터베이스의 활용을 다시 생각해볼게요&lt;/p>
&lt;p>관계형 데이터베이스에서 외래키로 표현되는 &lt;strong>의존 관계&lt;/strong>는 각 데이터베이스 수준에서 &lt;strong>엔티티간 결합&lt;/strong>이 발생한다는 것을 의미합니다.&lt;/p>
&lt;p>이 때문에 아키텍처 관점에서 &lt;strong>데이터베이스를 사용한다는 것 자체&lt;/strong>와 &lt;strong>엔티티를 기준으로 분리될 수 있는 컴포넌트의 결합&lt;/strong>이 문제가 될 수 있습니다.&lt;/p>
&lt;h2 id="고전적인-처리-방식">고전적인 처리 방식&lt;/h2>
&lt;p>일단 ORM을 활용하지 않는 RDB를 사용하던 방식을 확인해보면 도움이 될 것 같아요&lt;/p>
&lt;p>이전에는 물리적인 제한으로 인해 발생하는 지연(네트워크 오버헤드 등)과 고전적인 SSR 같은 이유로 &lt;strong>페이지&lt;/strong>나 &lt;strong>API 엔드포인트&lt;/strong> 별로 하나의 큰 쿼리(한방 쿼리 라고도 한다고 하네요)를 사용하는 것이 정석이었습니다.&lt;/p>
&lt;p>게시글, 댓글을 예시로 확인해볼까요?&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
User {
int user_id PK
string user_name
}
Post {
int post_id PK
int user_id FK
string post_title
string post_content
}
Reply {
int reply_id PK
int user_id FK
int post_id FK
string reply_content
}
User ||--o{ Post : ""
User ||--o{ Reply : ""
Post ||--o{ Reply : ""
&lt;/pre>
&lt;p>위 테이블 구조에서 고전적인 SSR을 이용하여 게시글 상세 정보를 보여주는 페이지를 렌더링해야 한다고 가정해보겠습니다.&lt;/p>
&lt;ul>
&lt;li>게시글 정보&lt;/li>
&lt;li>게시글 작성자 정보&lt;/li>
&lt;li>댓글 정보&lt;/li>
&lt;li>댓글 작성자 정보&lt;/li>
&lt;li>게시글에 달린 댓글 수&lt;/li>
&lt;li>댓글 페이지네이션&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_title&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_content&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">post_author&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COUNT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply_count&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_content&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply_author&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">post&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">LEFT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">LEFT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="k">limit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">OFFSET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="k">offset&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>아마 위와 같은 쿼리로 모든 데이터를 조회한 후 서비스 로직에서의 처리를 통해 HTML을 그려줬을거에요&lt;/p>
&lt;p>만약 쿼리를 나누고 싶다던가, &lt;code>Ajax&lt;/code>로 댓글 정보만 별도로 불러온다면 &lt;code>reply&lt;/code> 테이블에 대한 조회를 분리할 수 있을겁니다. 아래처럼요!&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_title&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_content&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">author&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">post&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COUNT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply_count&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_content&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply_author&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="k">limit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">OFFSET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="k">offset&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위 예시는 간단한 편 이지만, 실제 운영되는 서비스는 복잡하고 연관된 데이터가 훨씬 많기 때문에 많은 수의 테이블을 &lt;code>JOIN&lt;/code> 해야할 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>이처럼 이전에는 서버와 데이터베이스간 통신 오버헤드, 서버의 응답 처리 방식, 분산 처리의 여러움(하드웨어 비용, 기술 부재) 등으로 인해 쿼리를 작게 나눠 조회하는 것 보다 한번에 조회하는 방식이 성능을 위해 더 좋은 방식으로 여겨졌습니다.&lt;/p>
&lt;p>한번에 조회해야 할 단위가 클라이언트에게 응답해야 할 데이터 전체이므로, 쿼리 자체도 제공해야할 뷰나 API 응답 결과에 종속적이 된다는 문제도 있었어요&lt;/p>
&lt;p>위와 같은 고전적인 방식을 활용할 때, 테이블에 저장되는 데이터가 너무 커져서 데이터베이스를 분리하고 싶다던가, NoSQL로 마이그레이션 하고 싶다던가, &lt;code>MSA&lt;/code>로 변경하여 각각을 독립적으로 운영해야한다면 어떤 문제가 있을까요?&lt;/p>
&lt;p>매우 귀찮고 복잡한 일 이므로, 서비스의 규모가 크다면 작업을 시작하기도 어려울겁니다🥲&lt;/p>
&lt;h2 id="처리-방식의-변화">처리 방식의 변화&lt;/h2>
&lt;p>시간이 흐르면서 하드웨어, 소프트웨어의 발전과 비용 감소 등 여러 이유로 &lt;strong>수평 확장&lt;/strong>이 쉬워지게 되었어요&lt;/p>
&lt;p>필요에 따라 서버를 많이 배포하는 것이 어려운 일이 아니게되었고, 데이터베이스도 많은 수의 &lt;code>Read Replica&lt;/code>를 확보해서 &lt;strong>조회 요청&lt;/strong>에 대한 트래픽에 비교적 쉽게 대응할 수 있게 되었습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/common/architect-orm/img_4.png"
width="640"
height="603"
srcset="https://codemario318.github.io/post/common/architect-orm/img_4_hu22a297eba345d3df949b53c8e2b3a027_170554_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/common/architect-orm/img_4_hu22a297eba345d3df949b53c8e2b3a027_170554_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Scale Out"
class="gallery-image"
data-flex-grow="106"
data-flex-basis="254px"
>&lt;/p>
&lt;p>이러한 이유로 위에서 살짝 보여드린 것 처럼 &lt;strong>커다란 쿼리를 작게 나누는 것&lt;/strong>이 성능 향상에 더 유리하다고 여겨지게 되었어요 &lt;del>쿼리 튜닝도 훨씬 쉬워집니다&lt;/del>&lt;/p>
&lt;p>이전과 달리 다뤄야하는 데이터의 범위와 크기도 작아졌기 때문에 &lt;strong>객체지향적으로 데이터를 관리&lt;/strong>하는 것이 비교적 용이해졌고, 비즈니스 요구사항들을 처리하기 위해 &lt;strong>엔티티 중심으로 설계&lt;/strong>하는 것이 적극적으로 고려되었습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/common/architect-orm/img.png"
width="1000"
height="1432"
srcset="https://codemario318.github.io/post/common/architect-orm/img_hufca2fe698ad69cd2a61645fa2aa0686a_2740195_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/common/architect-orm/img_hufca2fe698ad69cd2a61645fa2aa0686a_2740195_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="엔티티"
class="gallery-image"
data-flex-grow="69"
data-flex-basis="167px"
>&lt;/p>
&lt;p>소프트웨어 아키텍처에서 &lt;strong>엔티티&lt;/strong>(Entity)는 도메인 모델의 핵심 구성 요소로, 시스템이 다루는 중요한 개체 혹은 개념이에요&lt;/p>
&lt;p>조금 더 설명하면 시스템의 도메인에서 고유한 속성과 행동을 가진 데이터 단위로서, 시스템의 주체가되고 주요 비즈니스 로직의 기본 단위입니다.&lt;/p>
&lt;p>앞에서 언급했던 &lt;strong>아키텍처 관점의 컴포넌트&lt;/strong>의 단위가 될 수도 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/common/architect-orm/img_1.png"
width="940"
height="909"
srcset="https://codemario318.github.io/post/common/architect-orm/img_1_hu9b47f7a709a7aa24fdf2e6ddd0a86654_52592_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/common/architect-orm/img_1_hu9b47f7a709a7aa24fdf2e6ddd0a86654_52592_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="레이어드 아키텍처"
class="gallery-image"
data-flex-grow="103"
data-flex-basis="248px"
>&lt;/p>
&lt;p>위 그림은 레이어드 아키텍처의 데이터 흐름을 표현한 것 인데, &lt;code>Business Layer&lt;/code>에서 특정 &lt;strong>비즈니스 로직을 처리하기 위한 주요 속성을 묶은 단위&lt;/strong>(객체 등)를 &lt;strong>엔티티&lt;/strong>라고 표현할 수 있어요&lt;/p>
&lt;h2 id="orm과-아키텍처의-관계">ORM과 아키텍처의 관계&lt;/h2>
&lt;p>여기까지 쓰고나니 조금 돌아온 기분이 드는군요🤣 그래서 ORM과 아키텍처가 무슨 관계냐?!&lt;/p>
&lt;p>위에서 언급했던 내용을 다시 살펴보면 &lt;strong>ORM은 RDB의 데이터를 조회하여 엔티티 객체로 만들어주는 역할&lt;/strong>을 수행하게 되어요&lt;/p>
&lt;p>이 때문에 ORM을 사용하기 위해 &lt;strong>엔티티를 분리&lt;/strong>해야하고, 이는 &lt;strong>관심사에 대한 수직 분해&lt;/strong>가 되었다는 의미이기도 합니다.&lt;/p>
&lt;p>또한 관계형 데이터베이스를 사용한다는 사실은 변하지 않았지만 설정 값으로 특정 데이터베이스를 선택할 수 있는 기능을 제공하므로 어느정도 &lt;strong>수평 분해를 위한 추상화가 되었다&lt;/strong>고 볼 수 있어요&lt;/p>
&lt;p>여기해 더해 레이어드 아키텍처의 예시에서 &lt;code>Persistence Layer&lt;/code> 역할을 하는 계층을 분리했다면, &lt;strong>인터페이스&lt;/strong> 등을 통해 &lt;strong>의존성 역전&lt;/strong>을 활용하여 완전히 다른 유형의 데이터베이스(또는 API 응답)에 대해 거의 완전하게 관심사 분리가 가능해집니다.&lt;/p>
&lt;h2 id="연관-관계-분리">연관 관계 분리&lt;/h2>
&lt;p>연관 관계가 있는 테이블들도 마찬가지로 ORM을 사용하여 관계를 관리해주기 위해 별도 엔티티로 분리해줘야합니다.&lt;/p>
&lt;p>그렇기 때문에 자연스럽게 비즈니스 로직에서의 결합이 낮아지게 되어요&lt;/p>
&lt;p>따라서 완전히 다른 데이터 주체로 변경된다고 하더라도 연관 관계에 있는 엔티티에 변경 내역이 비교적 적어질 것을 기대할 수 있습니다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>그래서 제가 하고싶었던 말을 정리해보면 아래와 같습니다.&lt;/p>
&lt;ul>
&lt;li>ORM을 사용하기 위해서는 비즈니스의 주요 관심사인 엔티티에 대한 분리가 전제되어야한다.&lt;/li>
&lt;li>데이터를 조회 계층 분리를 통해 추상화를 쉽게 적용할 수 있고, 이를 통해 조회 주체에 대한 의존성이 없어진다.&lt;/li>
&lt;li>그러한 이유로 독립적으로 배포 가능한 단위인 아키텍처 관점의 컴포넌트로 분리된다.&lt;/li>
&lt;li>ORM 방식도 여러 문제가 있지만 아키텍처 관점에서 장점이 있기 때문에 계속해서 활용되고 있는 것 같다.&lt;/li>
&lt;/ul>
&lt;p>사실 ORM을 사용해서라기보다는 &lt;strong>&amp;ldquo;좋은 아키텍처를 만들기 위해 개별 배포 가능한 컴포넌트로 관심사를 분리가 필요한데, ORM이 이러한 방향을 추구하고 있고, 어느정도 강제하고 있기 때문에 자연스럽게 좋은 아키텍처를 만든다.&amp;rdquo;&lt;/strong> 가 이 글의 결론이겠네요&lt;/p>
&lt;p>추가로 &lt;strong>&amp;ldquo;ORM 라이브러리는 이러한 아키텍처를 지원하기 위해 사용되는 도구일 뿐이다.&amp;rdquo;&lt;/strong>, &lt;strong>&amp;ldquo;ORM을 사용하지 않더라도(직접 구현하더라도) 관심사를 잘 분리할 수 있는 구조를 만들어야 한다.&amp;rdquo;&lt;/strong> 라는 걸 말씀 드리고 싶었습니다.&lt;/p>
&lt;p>다 쓰고 보니 정말 많이 돌아왔네요&amp;hellip; 쓴게 아까워서 지우진 않겠습니다🤣&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다.&lt;/p></description></item><item><title>8. 분산 메일 서비스</title><link>https://codemario318.github.io/post/system-design-interview-2/8/</link><pubDate>Wed, 23 Oct 2024 13:53:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/8/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/cover.png" alt="Featured image of post 8. 분산 메일 서비스" />&lt;p>이번 장에서는 지메일, 아웃룩 같은 대규모 이메일 서비스를 설계해본다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>현대적 이메일 서비스는 다양한 기능을 갖춘 복잡한 시스템으로 발전했다. 따라서 짧은시간에 설계는 불가능하므로 질문을 통해 설계 범위를 좁혀야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;del>인증&lt;/del>&lt;/li>
&lt;li>이메일 발송/수신&lt;/li>
&lt;li>모든 이메일 가져오기&lt;/li>
&lt;li>읽음 여부에 따른 이메일 필터링&lt;/li>
&lt;li>제목, 발신인, 메일 내용에 따른 검색 기능&lt;/li>
&lt;li>스팸 및 바이러스 방지 기능&lt;/li>
&lt;li>프로토콜
&lt;ul>
&lt;li>SMTP, POP, IMAP 등과 같은 서비스 제공자 전용 프로토콜이 있으나 HTTP 사용한다고 가정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부파일 지원&lt;/li>
&lt;/ul>
&lt;h3 id="비기능적-요구사항">비기능적 요구사항&lt;/h3>
&lt;ul>
&lt;li>안정성
&lt;ul>
&lt;li>이메일 데이터는 소실되어선 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성
&lt;ul>
&lt;li>이메일과 사용자 데이터를 여러 노드에 자동으로 복제하여 가용성을 보장해야한다.&lt;/li>
&lt;li>부분적으로 장애가 발생해도 시스템은 계속 동작해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확정성
&lt;ul>
&lt;li>사용자 수가 늘어나더라도 감당할 수 있어야 한다.&lt;/li>
&lt;li>사용자나 이메일이 많아져도 시스템 성능은 저하되지 않아야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유연성과 확장성
&lt;ul>
&lt;li>새 컴포넌트를 더하여 쉽게 기능을 추가하고 성능을 개선할 수 있는 유연하고 확장성 높은 시스템이어야 한다.&lt;/li>
&lt;li>POP나 IMAP 같은 기존 이메일 프로토콜은 기능이 매우 제한적이므로, 요구사항을 만족하기 위해 맞춤형 프로토콜이 필요할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적인-규모-추정">개략적인 규모 추정&lt;/h3>
&lt;ul>
&lt;li>10억 사용자&lt;/li>
&lt;li>한 사람이 하루에 보내는 평균 이메일 수는 10건 가정
&lt;ul>
&lt;li>&lt;code>QPS = 10^9 * 10 / 10^5 = 100,000&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>한 사람이 하루에 수신하는 이메일 수는 평균 40건 가정&lt;/li>
&lt;li>메일 하나의 메타데이터는 평균 50KB로 가정(첨부파일 X)&lt;/li>
&lt;li>메타데이터는 데이터베이스에 저장한다고 가정
&lt;ul>
&lt;li>1년간 메타데이터를 유지하기 위한 스토리지 요구사항은 &lt;code>10억 사용자 * 하루 40건 * 365일 * 50KB = 730PB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부 파일을 포함하는 이메일의 비율은 20%, 평균 크기는 50KB 가정
&lt;ul>
&lt;li>1년간 첨부 파일을 보관하는 데 필요한 저장 용량은 &lt;code>10억 사용자 * 하루 40건 * 365 * 20% * 500KB = 1,460PB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>많은 데이터를 처리해야하므로 분산 데이터베이스 솔루션이 필요하다.&lt;/p>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>이메일 서버에 대해 알아야 할 기본적인 사항과 더불어 서버가 시간이 흐름에 따라 어떻게 진화하는지 논의한다.&lt;/p>
&lt;p>그 후 분산 이메일 서버의 개략적인 설계안을 살펴본다.&lt;/p>
&lt;h3 id="이메일-101">이메일 101&lt;/h3>
&lt;p>이메일을 주고받는 프로토콜에는 대부분 POP, IMAP, SMTP 같은 프로토콜을 사용해왔다.&lt;/p>
&lt;h4 id="이메일-프로토콜">이메일 프로토콜&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>SMTP&lt;/strong>(Simple Mail Transfer Protocol)
&lt;ul>
&lt;li>이메일을 한 서버에서 다른 서버로 보내는 표준 프로토콜&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>POP&lt;/strong>(Post Office Protocol)
&lt;ul>
&lt;li>이메일을 가져오는 목적으로 널리 사용&lt;/li>
&lt;li>이메일 클라이언트가 원격 메일 서버에서 이메일을 수신하고 다운로드하기 위해 사용하는 표준 프로토콜&lt;/li>
&lt;li>단말로 다운로드된 이메일은 서버에서 삭제
&lt;ul>
&lt;li>결과적으로 한 대 단말에서만 이메일을 읽을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일을 확인하기 위해 전부 내려받아야 함
&lt;ul>
&lt;li>용량이 큰 첨부 파일이 붙은 이메일은 읽으려면 시간이 오래걸림&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>IMAP&lt;/strong>(Internet Mail Access Protocol)
&lt;ul>
&lt;li>이메일을 가져오는 목적으로 널리 사용&lt;/li>
&lt;li>POP과 달리 클리하지 않으면 메시지는 다운로드 되지 않으며, 메일 서버에서 지워지지도 않음
&lt;ul>
&lt;li>여러 단말에서 이메일을 읽을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개인 이메일 계정에서 가장 널리 사용되는 프로토콜&lt;/li>
&lt;li>이메일을 실제로 열기 전에는 헤더만 다운로드
&lt;ul>
&lt;li>인터넷 속도가 느려도 잘 동작함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>HTTPS&lt;/strong>
&lt;ul>
&lt;li>메일 전송 프로토콜은 아니지만 웹 기반 이메일 시스템의 메일함 접속에 이용될 수 있음&lt;/li>
&lt;li>ex) 아웃룩의 액티브 싱크&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="dns---도메인-이름-서비스">DNS - 도메인 이름 서비스&lt;/h4>
&lt;p>수신자 도메인의 메일 교환기 레코드(Mail Exchange, MX) 검색에 이용된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img.png"
width="1494"
height="546"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_hub7f0eb4bd2d0a33dfc88796a278dea75_678809_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_hub7f0eb4bd2d0a33dfc88796a278dea75_678809_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MX 레코드"
class="gallery-image"
data-flex-grow="273"
data-flex-basis="656px"
>&lt;/p>
&lt;ul>
&lt;li>숫자는 우선순위 값으로 선호도를 나타내어 값이 낮으면 높은 우선순위로 처리됨&lt;/li>
&lt;/ul>
&lt;h4 id="첨부-파일">첨부 파일&lt;/h4>
&lt;p>첨부 파일은 이메일 메시지와 함께 전송되며 일반적으로 Base64 인코딩을 활용한다.&lt;/p>
&lt;p>일반적으로 첨부 파일에는 크기 제한이 있고, 설정 가능한 수치로, 개인 계정이냐 기업 계정이냐에 따라 다르게 설정된다.(필요한 만큼 알아서 설정한다)&lt;/p>
&lt;ul>
&lt;li>아웃룩 20MB, 지메일 25MB&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>MIME&lt;/strong>( Multi-purpose Internet Mail Extension)&lt;br>
인터넷을 통해 첨부 파일을 전송할 수 있도록 하는 표준 규격&lt;/p>
&lt;/blockquote>
&lt;h4 id="전통적-메일-서버">전통적 메일 서버&lt;/h4>
&lt;p>분산 메일 서버에 알아보기 전 기존 메일 서버의 역사와 동작 방식에 대해 살펴본다.&lt;/p>
&lt;p>전통적인 메일 서버는 보통 &lt;strong>서버 한 대로 운용되는, 사용자가 많지 않을 때 잘 동작하는 시스템&lt;/strong>이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>전통적 메일 서버 아키텍처&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_1.png"
width="1166"
height="928"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_1_hu802478e41453ab6fdfaa430529afc2d8_190128_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_1_hu802478e41453ab6fdfaa430529afc2d8_190128_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="전통적 메일 서버"
class="gallery-image"
data-flex-grow="125"
data-flex-basis="301px"
>&lt;/p>
&lt;ol>
&lt;li>보내기 버튼을 누르면 메일 서버로 전송된다.(SMTP)&lt;/li>
&lt;li>메일 서버는 DNS 질의를 통해 수신 SMTP 서버를 찾고 해당 서버로 이메일을 보낸다(SMTP)&lt;/li>
&lt;li>메일을 수신한 서버는 이메일을 저장하고 수신자가 읽어갈 수 있도록 한다.&lt;/li>
&lt;li>수신자가 로그인하면 IMAP/POP 서버를 통해 새 이메일을 가져온다.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>&lt;strong>저장소&lt;/strong>&lt;/p>
&lt;p>전통적 메일 서버는 &lt;strong>이메일을 파일 시스템의 디렉터리에 저장&lt;/strong>한다.&lt;/p>
&lt;p>각각의 이메일은 고유한 이름을 가진 별도 파일로 보관도며, 각 사용자의 설정 데이터와 메일함은 사용자 디렉터리에 보관한다.&lt;/p>
&lt;ul>
&lt;li>이러한 디렉터리 구조를 &lt;strong>Maildir&lt;/strong> 이라고 함&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_2.png"
width="920"
height="1166"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_2_hu2474c31464cc06986e6e832f2b67e40e_32499_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_2_hu2474c31464cc06986e6e832f2b67e40e_32499_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Maildir"
class="gallery-image"
data-flex-grow="78"
data-flex-basis="189px"
>&lt;/p>
&lt;p>파일과 디렉터리를 활용하는 방안은 사용자가 많지 않을 때는 잘 동작하나 디스크 I/O로 인한 병목으로 인해 수십억 개의 이메일을 검색하고 백업하는 목적으로 활용하기에는 곤란했다.&lt;/p>
&lt;p>그리고 &lt;strong>이메일을 서버의 파일 시스템에 보관&lt;/strong>하였기 때문에 &lt;strong>가용성과 안정성&lt;/strong> 요구사항도 만족할 수 없었기 때문에 더 안정적인 분산 데이터 저장소 계층이 필요했다.&lt;/p>
&lt;ul>
&lt;li>디스크 손상, 서버 장애 등&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이메일 기능은 1960년대에 발명된 이래로 텍스트 중심에서 멀티미디어, 메일 스레드, 검색, 레이블 등 다양한 기능을 지원하도록 발전해 왔지만, POP, IMAP, SMTP 같은 이메일 프로토콜은 이러한 기능을 지원하도록 설계되지 않았기 때문에 확장할 수 없었다.&lt;/p>
&lt;h3 id="분산-메일-서버">분산 메일 서버&lt;/h3>
&lt;p>분산 메일 서버는 현대적 사용 패턴을 지원하고 확장성과 안정성 문제를 해결한다.&lt;/p>
&lt;h4 id="이메일-api">이메일 API&lt;/h4>
&lt;p>이메일 API의 의미는 메일 클라이언트, 이메일 생명주기 단계마다 달라질 수 있다.&lt;/p>
&lt;ul>
&lt;li>모바일 단말 클라이언트를 위한 SMTP/POP/IMAP API&lt;/li>
&lt;li>송신 측 메일 서버와 수신 측 메일 서버 간의 SMTP 통신&lt;/li>
&lt;li>대화형 웹 기반 이메일 애플리케이션을 위한 HTTP 기반 RESTful API&lt;/li>
&lt;/ul>
&lt;p>이 책에서는 가장 중요한 API만 다루며, 웹메일 통신에는 일반적으로 HTTP 프로토콜이 쓰인다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>POST /v1/messages&lt;/code>&lt;/strong>&lt;/p>
&lt;p>To, Tc, Bcc 헤더에 명시된 수신자에게 메시지를 전송한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/folders&lt;/code>&lt;/strong>&lt;/p>
&lt;p>주어진 이메일 계정에 존재하는 모든 폴더를 반환한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">[{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;id&amp;#34;: string,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;name&amp;#34;: string,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;user_id&amp;#34;: string
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/folders/{:folder_id}/messages&lt;/code>&lt;/strong>&lt;/p>
&lt;p>주어진 폴더 아래의 모든 메시지를 반환한다.&lt;/p>
&lt;ul>
&lt;li>단순화한 명세로 페이지네이션을 지원해야 하는 등 훨씬 복잡할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/messages/{:message_id}&lt;/code>&lt;/strong>&lt;/p>
&lt;p>주어진 특정 메시지에 대한 모든 정보를 반환한다.&lt;/p>
&lt;p>메시지는 이메일 애플리케이션의 핵심 구성 요소이다.&lt;/p>
&lt;ul>
&lt;li>발신자, 수신자, 메시지 제목, 본문, 첨부 파일 등의 정보로 구성&lt;/li>
&lt;/ul>
&lt;h4 id="분산-메일-서버-아키텍처">분산 메일 서버 아키텍처&lt;/h4>
&lt;p>전통적인 이메일 서버가 단일 장비 위에서만 동작하도록 설계되었기 때문에 한 대 이상의 서버로 규모를 늘리는 것은 까다롭다.&lt;/p>
&lt;ul>
&lt;li>여러 서버 사이에 데이터를 동기화하는 것은 어려운 작업이다.&lt;/li>
&lt;li>수신자 메일 서버에서 이메일이 스팸으로 잘못 분류되지 않도록 하려면 까다로운 문제들을 풀어야한다.&lt;/li>
&lt;/ul>
&lt;p>이번 절에서는 클라우드 기술을 활용하여 이러한 문제를 쉽게 푸는 방법을 알아본다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_3.png"
width="1328"
height="1040"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_3_hu97293f0920808d780af3a4f7f2404b28_190471_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_3_hu97293f0920808d780af3a4f7f2404b28_190471_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="127"
data-flex-basis="306px"
>&lt;/p>
&lt;ul>
&lt;li>웹메일
&lt;ul>
&lt;li>사용자는 웹브라우저를 사용해 메일을 받고 보냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹서버
&lt;ul>
&lt;li>사용자가 이용하는 요청/응답 서비스로, 로그인, 가입, 사용자 프로파일 등에 대한 관리 기능을 담당&lt;/li>
&lt;li>본 설계안에서는 이메일 발송, 폴더 목록 확인, 폴더 내 모든 메시지 확인 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>실시간 서버
&lt;ul>
&lt;li>새로운 이메일 내역을 클라이언트에 실시간으로 전달한다.&lt;/li>
&lt;li>지속성 연결을 맺고 유지해야하므로 상태 유지 서버다.
&lt;ul>
&lt;li>롱폴링, 웹소켓 등&lt;/li>
&lt;li>웹소켓이 좀 더 우아하지만 브라우저 호환성 문제가 있을 수 있다.&lt;/li>
&lt;li>기본적으로는 웹 소켓을 쓰되 여의치 않으면 롱 폴링을 백업으로 이용할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 데이터베이스
&lt;ul>
&lt;li>이메일 제목, 본문, 발신인, 수신인 목록 등 메타 데이터를 저장하는 데이터베이스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부 파일 저장소
&lt;ul>
&lt;li>아마존 S3(Simple Storage Service) 같은 객체 저장소를 사용할 것이다.
&lt;ul>
&lt;li>이미지나 동영상 등의 대용량 파일을 저장하는 데 적합하고 확장이 용이한 인프라이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부파일 크기는 25MB로 제한한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>분산 캐시
&lt;ul>
&lt;li>최근에 수신된 이메일은 자주 읽을 가능성이 높으므로 클라이언트로 하여금 메모리에 캐시해 두도록 하면 메일을 표시하는 시간을 많이 줄일 수 있다.&lt;/li>
&lt;li>레디스
&lt;ul>
&lt;li>리스트와 같은 다양한 기능을 제공하고, 규모 확장이 용이하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>검색 저장소
&lt;ul>
&lt;li>검색 저장소는 분산 문서 저장소이다.&lt;/li>
&lt;li>고속 텍스트 검색을 지원하는 &lt;strong>역 인덱스&lt;/strong>를 자료 구조로 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>카산드라가 첨부 파일 저장소로 적합하지 않은 이유&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>카산드라가 BLOB 자료형을 지원하고 해당 자료형이 지원하는 데이터의 최대 크기가 2GB이긴 하지만 실질적으로는 1MB 이상의 파일은 지원하지 못한다.&lt;/li>
&lt;li>카산드라에 첨부 파일을 저장하면 첨부 파일이 너무 많은 메모리를 사용하게되어 레코드 캐시를 사용하기 어렵다.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="이메일-전송-절차">이메일 전송 절차&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_4.png"
width="1698"
height="1126"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_4_hu6c1accd62c346f29cf05623f72575dc4_306833_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_4_hu6c1accd62c346f29cf05623f72575dc4_306833_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이메일 전송 절차"
class="gallery-image"
data-flex-grow="150"
data-flex-basis="361px"
>&lt;/p>
&lt;ol>
&lt;li>사용자가 웹에서 메일을 정송하면 요청은 로드밸런서로 전송된다.&lt;/li>
&lt;li>로드벨런서가 처리율 제한 한도를 넘지 않는 선에서 요청을 웹 서버로 전달한다.&lt;/li>
&lt;li>웹 서버는 다음 역할을 담당한다.
&lt;ul>
&lt;li>기본적인 이메일 검증
&lt;ul>
&lt;li>이메일 크기 한도 같은 사전 미리 정의된 규칙을 사용하여 수신된 이메일을 검사한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>수신자 이메일 주소 도메인이 송신자 이메일 주소 도메인과 같은지 검사
&lt;ul>
&lt;li>이메일 내용의 스팸 여부와 바이러스 감염 여부를 검사&lt;/li>
&lt;li>검사를 통과한 이메일은 송신인의 보낸 편지함과 수신인의 받은 편지함에 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>수신인 측 클라이언트는 RESTful API를 사용하여 이메일을 바로 가져올 수 있어 4단계 이후는 수행할 필요가 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 큐
&lt;ol>
&lt;li>기본적인 검증을 통과한 이메일은 외부 전송 큐로 전달된다.
&lt;ul>
&lt;li>&lt;strong>첨부 파일의 크기가 너무 큰 이메일&lt;/strong>의 경우 &lt;strong>첨부 파일을 객체 저장소에 따로 저장&lt;/strong>하고 해당 &lt;strong>저장 위치에 대한 참조 정보만 저장&lt;/strong>한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>기본적인 검증에 실패한 이메일은 에러 큐에 보관한다.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>외부 전송 담당 SMTP 작엄 프로세스는 외부 전송 큐에서 메시지를 꺼내어 이메일의 스팸 및 바이러스 감염 여부를 확인한다.&lt;/li>
&lt;li>검증 절차를 통과한 이메일은 저장소 계층 내의 보낸 편지함에 저장된다.&lt;/li>
&lt;li>외부 전송 담당 SMTP 작업 프로세스가 수신자의 메일 서버로 메일을 전송한다.&lt;/li>
&lt;/ol>
&lt;p>외부 전송 큐에 보관되는 모든 메시지에는 &lt;strong>이메일을 생성하는 데 필요한 모든 메타데이터가 포함&lt;/strong>되어 있다.&lt;/p>
&lt;p>&lt;strong>분산 메시지 큐&lt;/strong>는 비동기적 메일 처리를 가능케 하는 핵심적 컴포넌트이다.&lt;/p>
&lt;ul>
&lt;li>웹 서버에서 외부 전송 담당 SMTP 프로세스를 분리함으로 전송용 SMTP 프로세스의 규모를 독립적으로 조정할 수 있게 된다.&lt;/li>
&lt;/ul>
&lt;p>외부 전송 큐의 크기를 모니터링 할 때 메일이 처리되지 않고 큐에 오랫동안 남아 있으면 그 이유를 분석해야한다.&lt;/p>
&lt;ul>
&lt;li>수신자 측 메일 서버에 장애 발생
&lt;ul>
&lt;li>나중에 메일을 다시 전송해야 한다.&lt;/li>
&lt;li>ex) 지수적 백오프(Exponential Backoff)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일을 보낼 큐의 소비자 수가 불충분
&lt;ul>
&lt;li>더 많은 소비자를 추가하여 처리 시간을 단축하는 방법을 생각해 볼 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="이메일-수신-절차">이메일 수신 절차&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_5.png"
width="1824"
height="946"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_5_hufa935ff62aaff4ec9a22919e7479ce7e_259381_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_5_hufa935ff62aaff4ec9a22919e7479ce7e_259381_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이메일 수신 절차"
class="gallery-image"
data-flex-grow="192"
data-flex-basis="462px"
>&lt;/p>
&lt;ol>
&lt;li>이메일이 SMTP 로드밸런서에 도착&lt;/li>
&lt;li>트래픽을 여러 SMTP 서버로 분산
&lt;ul>
&lt;li>SMTP 연결에는 이메일 수락 정책을 구성하여 적용 가능&lt;/li>
&lt;li>유효하지 않은 이메일은 방송하도록 하여 불필요한 이메일 처리를 피할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일의 첨부 파일이 큐에 들어가기 너무 큰 경우 첨부 파일 저장소(S3)에 보관&lt;/li>
&lt;li>이메일을 수신 이메일 큐에 넣는다
&lt;ul>
&lt;li>메일 처리 작업 프로세스와 SMTP 간 결합도를 낮추어 각자 독립적으로 규모 확장이 가능하도록 함&lt;/li>
&lt;li>수신 이메일이 폭증하는 경우 버퍼 역할도 하게됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메일 처리 작업 프로세스(worker)는 스팸 메일을 걸러내고 바이러스를 차단하는 등의 다양한 역할 담당
&lt;ul>
&lt;li>이후 처리는 검증 작업이 끝난 이메일을 대상으로 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일을 메일 저장소, 캐시, 객체 저장소 등에 보관&lt;/li>
&lt;li>수신자가 온라인 상태일 경우 실시간 서버로 전달&lt;/li>
&lt;li>실시간 서버는 수신자 클라이언트가 새 이메일을 실시간으로 받을 수 있도록 하는 웹소켓 서버&lt;/li>
&lt;li>오프라인 상태 사용자의 이메일은 저장소 계층에 보관
&lt;ul>
&lt;li>온라인 상태가 되면 클라이언트가 웹 서버에 RESTful API를 통해 열결됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>새로운 이메일을 저장소 계층에서 가져와 클라이언트에 반환&lt;/li>
&lt;/ol>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>몇 가지 핵심 요소에 대해 더 자세히 알아보고 규모 확장 방안을 점검한다.&lt;/p>
&lt;h3 id="메타데이터-데이터베이스">메타데이터 데이터베이스&lt;/h3>
&lt;p>이메일 메타데이터의 특성을 알아보고 올바른 데이터베이스와 데이터 모델을 고르는 문제, 이메일 스레드 지원 방안에 대해 알아본다.&lt;/p>
&lt;h4 id="이메일-메타데이터의-특성">이메일 메타데이터의 특성&lt;/h4>
&lt;ul>
&lt;li>이메일의 헤더는 일반적으로 작고, 빈번하게 이용&lt;/li>
&lt;li>이메일 본문의 크기는 다양하지만 사용 빈도는 낮음
&lt;ul>
&lt;li>일반적으로 한 번만 읽음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일 가져오기, 읽은 메일로 표시, 검색 등의 이메일 관련 작업은 사용자 별로 격리 수행되어야함
&lt;ul>
&lt;li>어떤 사용자의 이메일은 해당 사용자만 읽을 수 있어야함&lt;/li>
&lt;li>이메일에 대한 작업도 그 사용자만이 수행할 수 있어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 신선도는 데이터 사용 패턴에 영향을 미침
&lt;ul>
&lt;li>사용자는 보통 최근 메일만 읽음&lt;/li>
&lt;li>만들어진 지 16일 이하에 발생하는 읽기 질의 비율은 전체 질의의 82%에 달함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터의 높은 안정성이 보장되어야 함
&lt;ul>
&lt;li>&lt;strong>데이터 손실은 용납되지 않음&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="올바른-데이터베이스의-선정">올바른 데이터베이스의 선정&lt;/h4>
&lt;p>지메일이나 아웃룩 정도의 규모가 되면 시스템의 부하로 인해, 초당 입/출력 연산 빈도(Input/Output Operations Per Second, IOPS)를 낮추기 위한 맞춤 제장 데이터베이스를 사용한다.&lt;/p>
&lt;p>올바른 데이터베이스 선택은 쉽지 않은데, 가능한 모든 선택지를 미리 살펴보면 도움이 된다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>관계형 데이터베이스&lt;/strong>&lt;/p>
&lt;p>관계형 데이터베이스를 고르는 주된 동기는 이메일을 효율적으로 검색할 수 있다는 장점 때문이다.&lt;/p>
&lt;ul>
&lt;li>이메일 헤더와 본문에 대한 인덱스를 만들면 효율적으로 검색할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>하지만 관계형 데이터베이스는 데이터 크기가 작을 때 적합하다.&lt;/p>
&lt;ul>
&lt;li>이메일은 수 KB보다 크고 HTML이 포함되면 쉽게 100KB를 넘어간다.&lt;/li>
&lt;li>BLOB 자료형을 쓰면 큰 이메일도 처리할 수 있으나, 비정형 BLOB에 대한 검색 질의 성능은 좋지 않다.
&lt;ul>
&lt;li>BLOB이 고정된 크기 페이지를 연결하여 큰 데이터를 저장하도록 하고 있어 해당 컬럼의 데이터를 접근할 때마다 많은 디스크 I/O가 발생한다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>따라서 관계형 데이터베이스는 바람직하지 않다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>분산 객체 저장소&lt;/strong>&lt;/p>
&lt;p>이메일의 원시 데이터를 그대로 아마존 S3 같은 객체 저장소에 보관하는 방법도 고려할 수 있다.&lt;/p>
&lt;p>하지만 객체 저장소는 백업 데이터를 보관하기에는 좋지만 이메일의 읽음 표시, 키워드 검색, 이메일 스레드 드의 기능을 구현하기에 그다지 좋지 않다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>NoSQL 데이터베이스&lt;/strong>&lt;/p>
&lt;p>지메일은 구글 빅테이블을 저장소로 사용하는데 충분히 실현 가능한 방안이다.&lt;/p>
&lt;p>하지만 빅테이블은 오픈소스로 공개되어 있지 않고 이메일 검색을 빅테이블 위에서 어떻게 구현했는지는 공개되어있지않다.&lt;/p>
&lt;p>카산드라가 좋은 대안이 될 수도 있지만 대형 이메일 서비스 제공 업체 가운데 카산드라를 사용하는 곳은 아직 확인된 바가 없다.&lt;/p>
&lt;hr>
&lt;p>위 후보들을 봤을 때 본 설계안이 필요로 하는 기능을 완벽히 지원하는 데이터베이스는 없다고 봐도 좋을 것 같다.&lt;/p>
&lt;p>이러한 이유로 대형 이메일 서버스 업체는 대체로 독자적인 데이터베이스 시스템을 만들어 사용한다.&lt;/p>
&lt;p>이러한 데이터베이스를 설계하기엔 시간이 부족하므로, 해당 데이터베이스가 아래와 같은 조건을 충족해야 한다는 점을 설명할 수 있어야한다.&lt;/p>
&lt;ul>
&lt;li>어떤 단일 컬럼의 크기는 한 자리수의 MB 정도일 수 있다.&lt;/li>
&lt;li>강력한 데이터 일관성이 보장되어야 한다.&lt;/li>
&lt;li>디스크 I/O가 최소화되도록 설계되어야 한다.&lt;/li>
&lt;li>가용성이 아주 높아야 하고 일부 장애를 감내할 수 있어야 한다.&lt;/li>
&lt;li>증분 백업(incremental backup)이 쉬워야 한다.&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-모델">데이터 모델&lt;/h4>
&lt;p>데이터를 저장하는 한 가지 방법은 &lt;code>user_id&lt;/code>를 파티션 키로 사용하여 특정한 사용자의 데이터는 항상 같은 샤드에 보관하는 것이다.&lt;/p>
&lt;ul>
&lt;li>메시지를 여러 사용자와 공유할 수 없지만 요구사항과는 관계 없다.&lt;/li>
&lt;/ul>
&lt;p>기본 키는 파티션 키(partition key)와 클러스터 키(clustering key)의 두 가지 부분으로 구성된다.&lt;/p>
&lt;ul>
&lt;li>파티션 키
&lt;ul>
&lt;li>데이터를 여러 노드에 분산하는 기준&lt;/li>
&lt;li>데이터가 모든 노드에 균등하게 분산되도록 하는 파티션 키를 골라야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클러스터 키
&lt;ul>
&lt;li>파티션에 속한 데이터를 정렬하는 기준&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>개략적으로 이메일 서비스의 데이터 계층은 다음과 같은 질의를 지원해야 한다.&lt;/p>
&lt;ul>
&lt;li>주어진 사용자의 모든 폴더를 구한다.&lt;/li>
&lt;li>특정 폴더 내의 모든 이메일을 표시한다.&lt;/li>
&lt;li>메일을 생성, 삭제, 조회한다.&lt;/li>
&lt;li>읽은 메일 전부, 또는 읽지 않은 메일 전부를 가져온다.&lt;/li>
&lt;li>이메일 스레드를 전부 가져온다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_6.png"
width="856"
height="518"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_6_hu00ad76f03bcbd533c2a84dbc6e348eb4_89085_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_6_hu00ad76f03bcbd533c2a84dbc6e348eb4_89085_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="키 구성"
class="gallery-image"
data-flex-grow="165"
data-flex-basis="396px"
>&lt;/p>
&lt;p>&lt;strong>질의 1: 특정 사용자의 모든 폴더 질의&lt;/strong>&lt;/p>
&lt;p>파티션 키는 &lt;code>user_id&lt;/code>다. 따라서 어떤 사용자의 모든 폴더는 같은 파티션 안에 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_7.png"
width="872"
height="544"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_7_hu156bc7a2fc679faefe0f0978519d3cb5_79626_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_7_hu156bc7a2fc679faefe0f0978519d3cb5_79626_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="사용자 별 폴더 목록"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="384px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>질의 2: 특정 폴더에 속한 모든 이메일 표시&lt;/strong>&lt;/p>
&lt;p>사용자가 자기 메일 폴더를 열면 이메일은 가장 최근 이메일부터 오래된 것 순으로 정렬되어 표시된다.&lt;/p>
&lt;p>같은 폴더에 속한 모든 이메일이 같은 파티션에 속하도록 하려면 &lt;code>&amp;lt;user_id, foler_id&amp;gt;&lt;/code> 형태의 복합 파티션 키를 사용해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_9.png"
width="876"
height="982"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_9_hu41305bc042d3fec07ebe69ff8294aa6a_136085_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_9_hu41305bc042d3fec07ebe69ff8294aa6a_136085_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="폴더별 이메일"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="214px"
>&lt;/p>
&lt;p>&lt;code>email_id&lt;/code>의 자료형은 &lt;code>TIMEUUID&lt;/code>로 이메일을 시간순으로 정렬하는 데 사용되는 클러스터 키다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>질의 3: 이메일 생성/삭제/수신&lt;/strong>&lt;/p>
&lt;p>이메일 상세 정로를 가져오는 방법을 살펴본다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">emails_by_user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">email_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">123&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이 질의를 지원하기 위해 두 테이블이 필요하다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_10.png"
width="1328"
height="642"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_10_hucad2710252b37d32d309b4b9de9854c5_132150_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_10_hucad2710252b37d32d309b4b9de9854c5_132150_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="사용자별 이메일"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="496px"
>&lt;/p>
&lt;p>한 이메일에는 여러 첨부 파일이 있을 수 있으므로, &lt;code>email_id&lt;/code>, &lt;code>filename&lt;/code> 필드를 같이 사용하면 모든 첨부 파일을 질의할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>질의 4: 읽은, 또는 읽지 않은 모든 메일&lt;/strong>&lt;/p>
&lt;p>관계형 데이터베이스로 도메인 모델을 구현하는 경우, 읽은 메일 전부는 다음과 같이 질의할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">emails_by_folder&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">is_read&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">email_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>본 설계안의 데이터모델은 NoSQL로 보통 파티션 키와 클러스터 키에 대한 질의만 허용하므로 &lt;code>emails_by_folder&lt;/code> 테이블의 &lt;code>is_read&lt;/code> 필드는 이에 해당하지 않기 때문에 대부분의 NoSQL 데이터베이스에서는 위 쿼리를 실행할 수 없다.&lt;/p>
&lt;p>이 문제를 해결하기 위한 방법으로 &lt;strong>주어진 폴더에 속한 모든 메시지를 가져온 다음 애플리케이션 단에서 필터링&lt;/strong> 해줄 수 있다.&lt;/p>
&lt;ul>
&lt;li>대규모 서비스에는 적합하지 않다.&lt;/li>
&lt;/ul>
&lt;p>따라서 이런 문데는 NoSQL 데이터베이스 테이블을 비정규화(denormalization)하여 해결하는 것이 보통이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>emails_by_folder&lt;/code> 테이블을 두 테이블로 분할한다.&lt;/li>
&lt;li>&lt;code>read_emails&lt;/code>: 읽은 상태의 모든 이메일을 보관&lt;/li>
&lt;li>&lt;code>unread_eamils&lt;/code>: 읽지 않은 모든 이메일을 보관&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_11.png"
width="1288"
height="568"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_11_hueb1288bc525b10d750ab98ffc79e7b70_139881_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_11_hueb1288bc525b10d750ab98ffc79e7b70_139881_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비정규화"
class="gallery-image"
data-flex-grow="226"
data-flex-basis="544px"
>&lt;/p>
&lt;p>특정 폴더 안의 읽지 않은 모든 메일을 가져오는 질의는 다음과 같이 표현될 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">unread_mails&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">email_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이러한 비정규화는 흔한 관행으로, 애플리케이션 코드가 좀 더 복잡해지고 관리하기 까다로워지지만, 질의 성능은 대규모 서비스에 어울리는 수준으로 개선한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>보너스: 이메일 스레드 가져오기&lt;/strong>&lt;/p>
&lt;p>이메일 스레드는 많은 이메일 클라이언트가 지원하는 기능으로 모든 답장을 최초 메시지에 스레드로 엮어 보여주는 기능이다.&lt;/p>
&lt;p>사용자가 특정한 대화에 관련된 모든 메일을 한 번에 확인할 수 있게된다.&lt;/p>
&lt;ul>
&lt;li>전통적으로 &lt;strong>JWZ&lt;/strong> 같은 알고리즘을 통해 구현한다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;headers&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;Message-Id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;7BA04B2A-430C-4D12-8B57-862103C34501@gmail.com&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;In-Reply-To&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;CAEWTXuPfN=LzECjDJtgY9Vu03kgFvJnJUSHTt6TW@gmail.com&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;References&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;lt;7BA04B2A-430C-4D12-8B57-862103C34501@gmail.com&amp;gt;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>Message-Id&lt;/strong>
&lt;ul>
&lt;li>메시지 식별자&lt;/li>
&lt;li>메시지를 보내는 클라이언트가 생성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>In-Reply-To&lt;/strong>
&lt;ul>
&lt;li>어떤 메시지가 어떤 메시지에 대한 답신인지 나타내는 식별자&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>References&lt;/strong>
&lt;ul>
&lt;li>스레드에 관계된 메시지 식별자 목록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 필드들로 이메일 클라이언트는 타래 내의 모든 메시지가 사전에 메모리에 로드되어 있는 경우 전체 대화 스레드를 재구성해 낼 수 있게된다.&lt;/p>
&lt;h4 id="일관성-문제">일관성 문제&lt;/h4>
&lt;p>높은 가용성을 달성하기 위해 다중화에 의존하는 분산 데이터베이스는 데이터 일관성과 가용성 사이에서 타협적인 결정을 내릴 수 밖에 없다.&lt;/p>
&lt;p>이메일 시스템의 경우 &lt;strong>데이터의 정확성이 아주 중요&lt;/strong>하므로, 모든 메일함은 반드시 하나의ㅏ 주 사본을 통해 서비스된다고 가정해야한다.&lt;/p>
&lt;p>따라서 장애가 발생하면 클라이언트는 다른 사본을 통해 주 사본이 복원될 때까지 동기화/갱신 작업을 완료할 수 없다.&lt;/p>
&lt;ul>
&lt;li>일관성을 위해 가용성을 희생한다.&lt;/li>
&lt;/ul>
&lt;h3 id="이메일-전송-가능성">이메일 전송 가능성&lt;/h3>
&lt;p>메일 서버를 구성하고 이메일을 보내는 것은 쉽지만 특정 사용자의 메일함에 실제로 메일이 전달되도록 하는 것은 어려운 문제이다.&lt;/p>
&lt;p>이메일이 &lt;strong>스팸 폴더&lt;/strong>에 들어가 버리면 수신자가 메일을 읽을 가능성은 아주 낮아진다.&lt;/p>
&lt;ul>
&lt;li>연구에 따르면 메일 가운데 50%가 그팸으로 분류된다.&lt;/li>
&lt;/ul>
&lt;p>새로 구성한 메일 서버는 인터넷에서 좋은 평판을 쌓을 기회가 전혀 없었기 때문에 보내는 메일이 대부분 스팸 폴더로 떨어진다.&lt;/p>
&lt;p>따라서 이메일의 전송 가능성을 높이기 이ㅜ해서 다음과 같은 요소들을 고려한다.&lt;/p>
&lt;ul>
&lt;li>전용 IP
&lt;ul>
&lt;li>전용 IP 주소를 사용하라&lt;/li>
&lt;li>대부분의 이메일 서비스 사업자는 아무 이력이 없는 IP 새로운 IP 주소에서 온 메일을 무시한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>범주화
&lt;ul>
&lt;li>범주가 다른 이메일은 다른 IP 주소를 통해 보내라&lt;/li>
&lt;li>마케팅 목적의 메일을 중요한 이메일과 같은 서버에서 발송하면 ISP가 모든 이메일을 판촉 메일로 분류할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>발신인 평판
&lt;ul>
&lt;li>새로운 이메일 서버의 IP 주소는 사용 빈도를 서서히 올리는 것이 좋다.&lt;/li>
&lt;li>그래야 좋은 평판이 쌓여 해당 IP 주소에서 발송되는 메일을 스팸으로 분류할 가능성이 낮아진다.&lt;/li>
&lt;li>아마존 SES에 따르면 새로운 IP 주소를 메일 발송해 아무 문제 없이 쓸 수 있게 되는 데는 대략 2 ~ 6주가 소요된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>스팸 발송자의 신속한 차단
&lt;ul>
&lt;li>스팸을 뿌리는 사용자는 서버 평판을 심각하게 훼손하기 전에 시스템에서 신속히 차단한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>피드백 처리
&lt;ul>
&lt;li>불만 신고가 접수되는 비율을 낮추고 스팸 계정을 신속히 차단하기위해서는 ISP 측에서의 피드백을 쉽게 받아 처리할 수 있는 경로를 만드는 것이 중요하다.&lt;/li>
&lt;li>이메일이 전달되지 못하거나 사용자로부터 불만 신고가 접수된 경우 다음과 같은 일들이 벌어질 수 있다.
&lt;ul>
&lt;li>경성 반송(hard bounce)
&lt;ul>
&lt;li>수신인의 이메일 주소가 올바르지 않아 ISP가 전달을 거부한 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>연성 반송(soft bounce)
&lt;ul>
&lt;li>ISP 측의 이메일 처리 자원 부족 등의 이유로 일시적으로 이메일을 전달할 수 없었던 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>불만 신고(complaint)
&lt;ul>
&lt;li>수신인이 스팸으로 신고 버튼을 누르는 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일 인증
&lt;ul>
&lt;li>2018년도 데이터 유출 조사 보고서에 따르면 ㅍ피싱이나 프리텍스팅이 전체 유철 사고에서 차지하는 비중은 93%에 달한다.&lt;/li>
&lt;li>보편적으로 SPF(Sender Policy Framework), DKIM(DomainKeys Identified Mail), DMARC(Domain-based Message Authentication, Reporting and Conformance) 등으로 피싱에 대응한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>명심해야할 점은 이메일이 목적지에 성공적으로 도착하도록 하기 어렵다는 사실이다. 도메인 지식은 물론 ISP와 좋은 관계를 유지할 필요도 있다.&lt;/p>
&lt;h3 id="검색">검색&lt;/h3>
&lt;p>기본적인 이메일 검색은 보통 이메일 제목이나 본문에 특정 키워드가 포함되었는지 찾는 것을 뜻하며, 고급 기능에는 발신인, 제목, 읽지 않음 같이 메일 속성에 따른 필터링 기능이 포함된다.&lt;/p>
&lt;p>검색 기능을 제공하려면 이메일이 전송, 수신, 삭제 될 때마다 색인(indexing) 작업을 수행해야 한다.&lt;/p>
&lt;p>그에 반해 검색은 사용자가 검색 버튼을 누를 때만 실행되므로, 이메일 시스템의 검색 기능에서는 쓰기 연산이 읽기 연산보다 훨씬 많이 발생한다.&lt;/p>
&lt;p>검색 기능을 지원하기 위해 일래스틱서치(ElasticSearch)를 이용하는 방안과 데이터 저장소에 내장된 기본 검색 기능을 활용하는 방안의 두 가지 선택지를 비교해본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>방안 1: 일래스틱서치&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_12.png"
width="1210"
height="1224"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_12_hu3000d4f01569124c541bea50802fb702_56268_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_12_hu3000d4f01569124c541bea50802fb702_56268_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="일래스틱 서치"
class="gallery-image"
data-flex-grow="98"
data-flex-basis="237px"
>&lt;/p>
&lt;p>질의가 대부분 사용자의 이메일 서버에서 실행되므로 &lt;code>user_id&lt;/code>를 파티션 키로 사용하여 같은 사용자의 이메일은 같은 노드에 묶어 놓는다.&lt;/p>
&lt;ul>
&lt;li>사용자가 검색 버튼을 누른 다음 결과가 수신될 때 까지 기다리므로, 검색 요청은 동기 방식으로 처리되어야 한다.&lt;/li>
&lt;li>이메일 전송, 이메일 수신, 이메일 삭제 같은 이벤트는 처리 결과를 클라이언트로 전달할 필요는 없으며, 추가로 색인 작업이 필요하다.&lt;/li>
&lt;/ul>
&lt;p>본 설계안은 카프카를 활용하여 색인 작업을 시작하는 서비스와 실제로 색인을 수행할 서비스 사이의 결합도를 낮추는 방안을 채택한다.&lt;/p>
&lt;ul>
&lt;li>일래스틱서치는 2021년 6월 기준으로 가장 널리 사용되고 있는 검색 엔진 데이터베이스이며 이메일 검색에 필요한 텍스트 기반 검색을 잘 지원한다.&lt;/li>
&lt;/ul>
&lt;p>일래스틱서치를 사용할 경우 주 이메일 저장소와 동기화를 맞추는 부분이 까다롭다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>방안 2: 맞춤형 검색 솔루션&lt;/strong>&lt;/p>
&lt;p>대규모 이메일 서비스 사업자는 보통 자기 제품에 고유한 요구사항을 만족시키기 위해 검색 엔진을 자체적으로 개발해 사용한다.&lt;/p>
&lt;p>매우 어렵고 범위를 넘어서기 때문에 자체적으로 검색 솔루션을 구현하는 경우 마주하게 될 주요 과제인 디스크 I/O 병목 문제를 살펴본다.&lt;/p>
&lt;p>개략적 규모 추정 결과 메타 데이터와 첨부 파일은 매일 페타바이트 수준으로 저장소에 추가되며, 하나의 이메일 계정에 몇십 만개 넘는 이메일이 저장되는 것도 흔하다.&lt;/p>
&lt;ul>
&lt;li>따라서 메일 색인 서버의 주된 병복은 보통 디스크 I/O다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_13.png"
width="1926"
height="1002"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_13_hu495b352c0880296eb3398fcf25077ab9_380701_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_13_hu495b352c0880296eb3398fcf25077ab9_380701_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="LSM 트리"
class="gallery-image"
data-flex-grow="192"
data-flex-basis="461px"
>&lt;/p>
&lt;p>색인을 구축하는 프로세스는 다량의 쓰기 연산을 발생시킬 수 밖에 없으므로 LSM(Log-Structured Merge)트리를 사용하여 &lt;strong>디스크에 저장되는 색인을 구조화하는 것이 바람직한 전략&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>쓰기 경로는 순차적 쓰기 연산(sequential write)만 수행하도록 최적화 되어있다.&lt;/li>
&lt;li>빅테이블이나 카산드라, RocksDB 같은 데이터베이스의 핵심 자료 구조다.&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>새로운 이메일이 도착하면 우선 메모리 캐시로 구현되는 0번 계층에 저장된다.&lt;/li>
&lt;li>메모리에 보관된 데이터의 양이 사전에 정의된 임계치를 넘으면 데이터는 다음 계층에 병합된다.&lt;/li>
&lt;/ol>
&lt;p>자주 바뀌는 데이터를 그렇지 않은 데이터와 분리하는 효과도 얻을 수 있다.&lt;/p>
&lt;ul>
&lt;li>이메일 데이터는 보통 바뀌지 않지만 메일 폴더의 정보는 상이한 필터링 규칙들 때문에 자주 바뀌는 경향이 있다.&lt;/li>
&lt;li>데이터를 두 개 파트로 나누거 어떤 요청이 폴더 변경에 관한 것 이면 폴더 정보만 바꾸고 이메일 데이터는 내벼려둔다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>소규모의 이메일 시스템을 구축하는 경우 통합하기 쉽고 엔지니어링에 많은 노력이 필요하지 않은 일래스틱서치가 좋은 선택지이다.&lt;/p>
&lt;p>대규모 시스템을 구축하는 경에도 일래스틱서치를 사용할 수 있겠지만 이메일 검색 인프라를 개발하고 관리하는 전담 팀이 필요할 수 있다.&lt;/p>
&lt;p>지메일이나 아웃룩 규모의 이메일 시스템을 지원하려면 독립적인 검색 전용 시스템을 두기보다는 데이터베이스에 내장된 전용 검색 솔루션을 사용하는 것이 바람직할 수도 있다.&lt;/p>
&lt;h3 id="규모-확장성-및-가용성">규모 확장성 및 가용성&lt;/h3>
&lt;p>각 사용자의 데이터 접근 패턴은 다른 사용자와 무고나하므로, 시스템의 대부분 컴포넌트는 수평적으로 규모 확장이 가능할 것으로 기대할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_14.png"
width="1362"
height="1260"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_14_hu7aa95457bd45ad9d0fc44f5368731ee7_86292_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_14_hu7aa95457bd45ad9d0fc44f5368731ee7_86292_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="시스템 다중화"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="259px"
>&lt;/p>
&lt;p>가용성을 향상시키기 위해서는 데이터를 여러 데이터센터에 다중화하는 것이 필요하다.&lt;/p>
&lt;ul>
&lt;li>자신과 물리적으로 가까운 메일 서버와 통신한다.&lt;/li>
&lt;li>네트워크 파티션 발생시 다른 데이터센터에 보관된 메시지를 이용한다.&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>면접장에서 시간이 남는다면 추가로 논의해 볼 만한 주제로는 다음과 같은 것들이 있다.&lt;/p>
&lt;ul>
&lt;li>결함 내성
&lt;ul>
&lt;li>노드 장애, 네트워크 문제, 이벤트 전달 지연 등의 문제에 어떻게 대처할지 살펴보면 좋을 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규정 준수
&lt;ul>
&lt;li>전 세계 다양한 시스템과 연동해야 하고 각 나라에는 준수해야할 법규가 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>보안
&lt;ul>
&lt;li>민감한 정보가 포함되므로 보안이 매우 중요하다.&lt;/li>
&lt;li>피싱 방지, 안전 브라우징, 첨부 파일 사전 경고, 계정 안전, 기밀 모드, 이메일 암호화 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>최적화
&lt;ul>
&lt;li>같은 이메일이 여러 수신자에 전송되는 경우 동일한 첨부 파일이 있는지 확인하는 방식으로 최적화를 진행할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>7. 호텔 예약 시스템</title><link>https://codemario318.github.io/post/system-design-interview-2/7/</link><pubDate>Sat, 12 Oct 2024 14:59:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/7/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/cover.png" alt="Featured image of post 7. 호텔 예약 시스템" />&lt;p>이번 장에서는 호텔 체인의 예약 시스템을 설계한다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>호텔 예약 시스템은 복잡하고 그 컴포넌트는 시스템을 사업에 어떻게 이용할지에 따라 달라지므로 범위를 명확히 해야한다.&lt;/p>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>높은 수준의 동시성 지원
&lt;ul>
&lt;li>성수기, 대규모 이벤트 기간에는 일부 인기 호텔의 특정 객실을 예약하려는 고객이 많이 몰릴 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>적절한 지연 시간
&lt;ul>
&lt;li>사용자가 예약을 할 때는 응답 시간이 빠르면 이상적이겠으나 &lt;strong>예약 요청 처리&lt;/strong>에 &lt;strong>몇 초 정도&lt;/strong> 걸리는 것은 괜찮다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;ul>
&lt;li>총 5,000개 호텔, 100만 개의 객실이 있다고 가정&lt;/li>
&lt;li>평균 &lt;strong>객실의 70%가 사용 중&lt;/strong>, 평균 &lt;strong>투숙 기간은 3일&lt;/strong>이라고 가정&lt;/li>
&lt;li>&lt;code>일일 예상 예약 건수 = (1백만 * 0.7) / 3 ~= 240,000&lt;/code>&lt;/li>
&lt;li>&lt;code>초당 예약 건수 = 240,000 / 하루에 10^5초 ~= 3&lt;/code>
&lt;ul>
&lt;li>초당 예약 트랜잭션 수(TPS)는 높지 않다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>시스템 내 모든 페이지의 QPS를 계산해본다.&lt;/p>
&lt;p>호텔 예약 시스템은 일반적으로 고객이 아래와 같은 흐름을 거친다.&lt;/p>
&lt;ol>
&lt;li>호텔/객실 상세 페이지
&lt;ul>
&lt;li>사용자가 호텔/객실 정보를 확인한다.(조회)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예약 상세 정보 페이지
&lt;ul>
&lt;li>날짜, 투숙 인원, 결제 방법 등의 상세 정보를 예약 전에 확인한다.(조회)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객실 예약 페이지
&lt;ul>
&lt;li>사용자가 &amp;lsquo;예약&amp;rsquo; 버튼을 눌러 객실을 예약한다.(트랜잭션 발생)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img.png"
width="1290"
height="630"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_hudca757551e48c8d1d2e333630b9f6cbe_51951_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_hudca757551e48c8d1d2e333630b9f6cbe_51951_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="QPS 분포"
class="gallery-image"
data-flex-grow="204"
data-flex-basis="491px"
>&lt;/p>
&lt;p>대략 10%의 사용자가 간 단계에서 다음 단계를 진행한다고 가정하면 최종 예약 TPS는 3이므로, 예약 페이지의 QPS는 30, 객실 정보 확인 페이지의 QPS는 300이다.&lt;/p>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="api-설계">API 설계&lt;/h3>
&lt;p>호텔 예약 시스템의 가장 중요한 API만 RESTful 관례에 따라 표현하면 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>검색 기능 등의 직관적인 기능도 필요하나, 기술적으로 도전적이지는 않다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>호텔 관련 API&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/hotels/id&lt;/td>
&lt;td>호텔의 상세 정보 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST /v1/hotels&lt;/td>
&lt;td>신규 호텔 추가(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PUT /v1/hotels/id&lt;/td>
&lt;td>호텔 정보 갱신(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE /v1/hotels/id&lt;/td>
&lt;td>호텔 정보 삭제(관리자)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>객실 관련 API&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/hotels/:id/rooms/id&lt;/td>
&lt;td>객실 상세 정보 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST /v1/hotels/:id/rooms&lt;/td>
&lt;td>신규 객실 추가(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PUT /v1/hotels/:id/rooms/id&lt;/td>
&lt;td>객실 정보 갱신(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE /v1/hotels/:id/rooms/id&lt;/td>
&lt;td>객실 정보 삭제(관리자)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>예약 관련 API&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/reservations&lt;/td>
&lt;td>로그인 사용자의 예약 이력 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GET /v1/reservations/id&lt;/td>
&lt;td>특정 예약의 상세 정보 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST /v1/reservations&lt;/td>
&lt;td>신규 예약&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE /v1/reservations/id&lt;/td>
&lt;td>예약 취소&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>신규 예약 접수는 아주 중요한 기능으로, 새 예약을 만들 때 전달하는 인자의 형태는 아래와 같은데&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;startDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-28&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;endDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-30&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;hotelID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;245&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;roomID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;U12354673389&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;reservationID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;13422445&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>researvationID&lt;/code>는 &lt;strong>이중 예약을 방지하고 동일한 예약은 단 한 번만 이루어지도록 보증하는 멱등 키(idempotent key)다.&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>멱등성?&lt;/strong>
연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질&lt;/p>
&lt;/blockquote>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>어떤 데이터베이스를 사용할지 결정하기위해 데이터 접근 패턴을 확인해야한다.&lt;/p>
&lt;ol>
&lt;li>호텔 상세 정보 확인&lt;/li>
&lt;li>지정된 날짜 범위에 사용 가능한 객실 유형 확인&lt;/li>
&lt;li>예약 정보 기록&lt;/li>
&lt;li>예약 내역 또는 과거 예약 이력 정보 조회&lt;/li>
&lt;/ol>
&lt;p>시스템 규모가 크지 않지만 대규모 이벤트 등으로 인해 트래픽이 급증할 수도 있으니 대비가 필요하다.&lt;/p>
&lt;p>이런 요구사항을 종합적으로 고려하였을 때 &lt;strong>관계형 데이터베이스&lt;/strong>가 적절해보인다.&lt;/p>
&lt;ul>
&lt;li>읽기 빈도가 쓰기 연산에 비해 높은 작업 흐름을 잘 지원한다.
&lt;ul>
&lt;li>읽기 반도가 압도적인 작업 흐름은 충분히 잘 지원한다.&lt;/li>
&lt;li>NoSQL 데이터베이스는 대체로 쓰기 연산에 최적화되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ACID 속성(원자성, 일관성, 격리성, 영속성)을 보장한다.
&lt;ul>
&lt;li>예약이라는 도메인 특성으로 인해 ACID 속성은 매우 중요하다.&lt;/li>
&lt;li>ACID를 보장하지 않으면 잔액 마이너스 문제, 이중 청구 문제, 이중 예약 문제 등을 방지하기 어렵다.&lt;/li>
&lt;li>ACID 속성이 충족되는 데이터베이스를 사용하면 코드는 단순해지고 이해하기 쉬워진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터를 쉽게 모델링 할 수 있다.
&lt;ul>
&lt;li>비즈니스 데이터의 구조를 명확하게 표현할 수 있을 뿐 아니라 엔티티 간의 간계를 안정적으로 지원할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_1.png"
width="1622"
height="1138"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_1_hude4e50a98d4fd9adb0d8d3f89cda06c5_259967_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_1_hude4e50a98d4fd9adb0d8d3f89cda06c5_259967_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터베이스 스키마"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="342px"
>&lt;/p>
&lt;p>&lt;code>reservation&lt;/code> 테이블의 &lt;code>status&lt;/code> 필드는 &lt;code>Pending&lt;/code>, &lt;code>Paid&lt;/code>, &lt;code>Refunded&lt;/code>, &lt;code>Canceled&lt;/code>, &lt;code>Rejected&lt;/code> 다섯 상태 가운데 하나를 값으로 가질 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_2.png"
width="1320"
height="630"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_2_hu654fdd7d1e7937dbeca03f4655f81aa1_21966_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_2_hu654fdd7d1e7937dbeca03f4655f81aa1_21966_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="예약 상태"
class="gallery-image"
data-flex-grow="209"
data-flex-basis="502px"
>&lt;/p>
&lt;p>이 스키마에서 &lt;code>room_id&lt;/code>는 에어비엔비 같은 회사에는 적합하나, 특정 호텔의 특정 객실 유형을 예약하는 호텔에는 적절하지 않을 수 있다.&lt;/p>
&lt;ul>
&lt;li>객실 번호는 예약할 때가 아닌, 투숙객이 체크인 하는 시점에 부여된다.&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>이번 호텔 예약 시스템에는 마이크로서비스 아키텍처를 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_3.png"
width="1946"
height="1100"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_3_hu282c3b24ada39ab6809ed01eac989c4e_87808_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_3_hu282c3b24ada39ab6809ed01eac989c4e_87808_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="176"
data-flex-basis="424px"
>&lt;/p>
&lt;p>마이크로 서비스 간 상호작용을 나타내는 화살표 상당수를 생략하였다.&lt;/p>
&lt;p>실제 상업적으로 이용되는 시스템의 서비스 간 통신에는 gRPC와 같은 고성능 원격 프로세서 호출 프레임워크를 사용하곤 한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>gRPC?&lt;/strong>&lt;br>
gRPC는 Google에서 개발한 고성능, 오픈 소스 원격 프로시저 호출(Remote Procedure Call, RPC) 프레임워크이다.
클라이언트와 서버 간에 원격 프로시저를 호출할 수 있게 해 주며, 마치 로컬에서 함수를 호출하는 것처럼 네트워크를 통해 다른 시스템의 메서드를 실행할 수 있다.
주로 프로토콜 버퍼(Protocol Buffers, protobuf)라는 직렬화 방식을 사용해 데이터를 효율적으로 전송하며, HTTP/2를 기반으로 동작해 성능과 확장성을 높인다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="개선된-데이터-모델">개선된 데이터 모델&lt;/h3>
&lt;p>호텔 객실을 예약할 때는 특정 객실이 아니라 특정한 객실 유형을 예약하게 된다.&lt;/p>
&lt;p>이러한 특성을 반영하기 위해 예약 API의 경우 호출 인자 가운데 &lt;code>roomID&lt;/code>는 &lt;code>roomTypeID&lt;/code>로 변경한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;startDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-28&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;endDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-30&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;hotelID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;245&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;roomTypeID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;U12354673389&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;reservationID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;13422445&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>스키마는 아래와 같이 변경된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_4.png"
width="1366"
height="1028"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_4_hu481f8e14d20d4e775dd6afb82166b25a_281965_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_4_hu481f8e14d20d4e775dd6afb82166b25a_281965_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="갱신된 스키마"
class="gallery-image"
data-flex-grow="132"
data-flex-basis="318px"
>&lt;/p>
&lt;p>주요 변경 사항은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>room&lt;/code>: 객실에 관계된 정보&lt;/li>
&lt;li>&lt;code>room_type_rate&lt;/code>: 특정 객실 유형의 특정 일자 요금 정보&lt;/li>
&lt;li>&lt;code>reservation&lt;/code>: 투숙객 예약 정보&lt;/li>
&lt;li>&lt;code>room_type_inventory&lt;/code>: 호텔의 모든 객실 유형
&lt;ul>
&lt;li>&lt;code>hotel_id&lt;/code>: 호텔 식별자&lt;/li>
&lt;li>&lt;code>room_type_id&lt;/code>: 객실 유형 식별자&lt;/li>
&lt;li>&lt;code>date&lt;/code>: 일자&lt;/li>
&lt;li>&lt;code>total_inventory&lt;/code>: 총 객실 수에서 일시적으로 제외한 객실 수를 뺀 값
&lt;ul>
&lt;li>유지 보수를 위해 예약 가능 목록에서 제외할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>total_reserved&lt;/code>: 저정된 hotel_id, room_type_id, date에 예약된 모든 객실의 수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>날짜당 하나의 레코드를 사용하면 날짜 범위 내에서 예약을 쉽게 관리하고 질의할 수 있다.&lt;/p>
&lt;p>이 테이블의 기본키는 &lt;code>(hotel_id, room_type_id, date)&lt;/code>의 복합키로, 2년 이내 모든 미래 날짜에 대한 가용 객실 데이터 질의 결과를 토대로 미리 채워 놓고, 시간이 흐름에 따라 새로 추가해야 하는 객실 정보는 매일 한 번씩 일괄 작업을 돌려 반영한다.&lt;/p>
&lt;hr>
&lt;p>5,000개의 호텔이 있고 각 호텔에는 20개의 객실 유형이 있으므로 테이블에 저장해야 하는 레코드의 수는 &lt;code>5,000 * 20 * 2년 * 365일 = 7,300만 개&lt;/code> 정도이다.&lt;/p>
&lt;p>많은 데이터가 아니므로 데이터베이스 하나면 저장하기 충분하지만, 하나만 둔다면 SPOF 문제를 피할 수 없게된다.&lt;/p>
&lt;p>고가용성을 달성하려면 여러 지역, 또는 가용성 구역에 데이터베이스를 복제해 두어야 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;code>room_type_inventory&lt;/code> 테이블은 고객이 특정 유형의 객실을 예약할 수 있는지 여부를 확인할 때 사용한다.&lt;/p>
&lt;ul>
&lt;li>입력
&lt;ul>
&lt;li>&lt;code>startDate&lt;/code>&lt;/li>
&lt;li>&lt;code>endDate&lt;/code>&lt;/li>
&lt;li>&lt;code>roomTypeId&lt;/code>&lt;/li>
&lt;li>&lt;code>hotelId&lt;/code>&lt;/li>
&lt;li>&lt;code>numberOfRoomsToReserve&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>출력
&lt;ul>
&lt;li>해당 유형의 객실에 여유가 있고 예약 가능한 상태라면 &lt;code>True&lt;/code>, 아니면 &lt;code>False&lt;/code>를 반환한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>SQL 관점에서 두 절차를 거친다.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>주어진 기간에 해당하는 레코드를 구한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">date&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_inventory&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_reserved&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">room_type_inventory&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">room_type_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">roomTypeId&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">hotel_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">hotelId&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BETWEEN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">startDate&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">endDate&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>반환한 각 레코드마다 다음 조건을 확인한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">if ((total_reserved + ${numberOfRoomsToReserve}) &amp;lt;= total_inventory)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>레코드의 모든 행을 검사한 결과 &lt;code>True&lt;/code>가 반환되면 주어진 기간 내 모든 날짜에 충분한 객실이 있다는 뜻 이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>예약 데이터가 단을 데이터베이스에 담기에 너무 크다면 다음과 같은 방안을 생각해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>현재 및 향후 예약 데이터만 저장한다.
&lt;ul>
&lt;li>예약 이력은 자주 접근하지 않으므로 아카이빙 하거나 냉동 저장소로 옮길 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터베이스를 샤딩한다.
&lt;ul>
&lt;li>자주 사용되는 질의는 &lt;strong>예약&lt;/strong> 및 &lt;strong>예약 확인&lt;/strong>이므로, 두 질의에서 모두 먼저 알아야하는 &lt;code>hotel_id&lt;/code>를 샤딩키로 사용한다.&lt;/li>
&lt;li>데이터는 &lt;code>hash(hotel_id) % number_of_service&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="동시성-문제">동시성 문제&lt;/h3>
&lt;p>또 하나의 중요한 문제는 &lt;strong>이중 예약 방지&lt;/strong>이며, 이를 위해 두가지 문제를 해결해야한다.&lt;/p>
&lt;ul>
&lt;li>같은 사용자가 예약 요청을 여러번 시도할 수 있다.&lt;/li>
&lt;li>여러 사용자가 같은 객실을 동시에 예약하려 할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="같은-사용자가-같은-예약-요청을-시도하는-경우">&lt;strong>같은 사용자가 같은 예약 요청을 시도하는 경우&lt;/strong>&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_5.png"
width="1508"
height="986"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_5_hueb9926d5bdf21d1ae178c13f6ba855ec_83059_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_5_hueb9926d5bdf21d1ae178c13f6ba855ec_83059_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="같은 고객의 이중 예약"
class="gallery-image"
data-flex-grow="152"
data-flex-basis="367px"
>&lt;/p>
&lt;p>이 문제를 푸는 일반적인 접근법으로는 다음 두가지가 있다.&lt;/p>
&lt;ul>
&lt;li>클라이언트 측 구현
&lt;ul>
&lt;li>요청 전송 후 예약 버튼을 비활성화 한다.
&lt;ul>
&lt;li>클라이언트에서 우회 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>멱등 API
&lt;ul>
&lt;li>예약 API 요청에 멱등 키를 추가하는 방안&lt;/li>
&lt;li>&lt;code>reservation_id&lt;/code>를 멱등 키로 사용하여 이중 예약 문제를 해결하는 방안이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_6.png"
width="1130"
height="1066"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_6_hu48c6b4b2100602be71a6178ae06987e2_69862_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_6_hu48c6b4b2100602be71a6178ae06987e2_69862_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="유일성 조건"
class="gallery-image"
data-flex-grow="106"
data-flex-basis="254px"
>&lt;/p>
&lt;ol>
&lt;li>예약 주문서를 만든다.&lt;/li>
&lt;li>고객이 검토할 수 있도록 예약 주문서를 반환한다.&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>반환 결과에 &lt;code>reservation_id&lt;/code>를 넣는다.(전역적 유일성을 보증하는 ID, 예제에서는의 예약 테이블의 기본키)&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>검토가 끝난 예약을 전송한다.
&lt;ul>
&lt;li>요청에 &lt;code>reservation_id&lt;/code>를 포함한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예약 완료 버튼을 한 번 더 눌러 보내도 &lt;code>reservation_id&lt;/code>가 예약 테이블의 기본 키 이므로 유일성 조건에 위반되어 처리되지 않는다.&lt;/li>
&lt;/ol>
&lt;h4 id="여러-사용자가-하나뿐인-객실을-동시에-예약하는-경우">&lt;strong>여러 사용자가 하나뿐인 객실을 동시에 예약하는 경우&lt;/strong>&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_7.png"
width="1438"
height="1262"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_7_hu8a18da16175039b3cfa48b49d042fdf5_80735_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_7_hu8a18da16175039b3cfa48b49d042fdf5_80735_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="경쟁 조건"
class="gallery-image"
data-flex-grow="113"
data-flex-basis="273px"
>&lt;/p>
&lt;p>이 문제를 해결하려면 어떤 형태로든 락을 활용해야 한다.&lt;/p>
&lt;p>&lt;strong>비관적 락&lt;/strong>&lt;/p>
&lt;p>비관적 락은 비관적 동시성 제어 방안이라고도 불리며, 사용자가 &lt;strong>레코드를 갱신하려고 하는 순간 즉시 락을 걸어 동시 업데이트를 방지하는 기술&lt;/strong>이다.&lt;/p>
&lt;p>따라서 해당 레코드를 갱신하려는 다른 사용자는 락 해제를 기다려야 한다.&lt;/p>
&lt;ul>
&lt;li>MySQL 같은 경우는 &lt;code>SELECT ... FOR UPDATE&lt;/code> 문을 실행하면 &lt;code>SELECT&lt;/code>가 반환한 레코드에 락이 걸린다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_8.png"
width="1994"
height="1320"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_8_hu40fa4d62dd848fb68c0b889e46e94f87_126013_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_8_hu40fa4d62dd848fb68c0b889e46e94f87_126013_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비관적 락"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="362px"
>&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>변경 중이거나 변경이 끝난 데이터를 갱신하는 일을 막을 수 있다.&lt;/li>
&lt;li>구현이 쉽고 모든 갱신 연산을 직렬화하여 충돌을 막는다.&lt;/li>
&lt;li>데이터에 대한 경합이 심할 때 유용하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>여러 레코드에 락을 걸면 교착 상태가 발생할 수 있다.
&lt;ul>
&lt;li>교착 상태가 발생하지 않는 코드 작성은 어렵다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장성이 낮다.&lt;/li>
&lt;li>트랜잭션이 너무 오랫동안 락을 해제하지 않고 있으면 다른 트랜잭션은 락이 걸린 자원에 접근할 수 없어 트랜잭션 수명이 길거나 많은 엔티티에 관련된 경우 성능에 심각한 영향을 끼친다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 이유로 비관적 락 메커니즘은 군장하지 않는다.&lt;/p>
&lt;p>&lt;strong>낙관적 락&lt;/strong>&lt;/p>
&lt;p>낙관적 락은 &lt;strong>낙관적 동시성 제어&lt;/strong>라고도 불리는 방안으로 &lt;strong>여러 사용자가 동시에 같은 자원을 갱신하려 시도하는 것을 허용&lt;/strong>한다.&lt;/p>
&lt;p>일반적으로 버전 번호(version_number)와 타임스탬프(timestamp) 두 가지 방법으로 구현한다.&lt;/p>
&lt;ul>
&lt;li>서버 시계는 시간이 지남에 따라 부정확해질 수 있으므로 일반적으로는 버전 번호를 더 나은 선택지로 본다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_9.png"
width="1938"
height="1142"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_9_hu9411dd474af31fd86c2a43d5119b3270_97882_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_9_hu9411dd474af31fd86c2a43d5119b3270_97882_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="낙관적 락"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="407px"
>&lt;/p>
&lt;p>낙관적 락은 데이터베이스에 직접 락을 걸지 않으므로 일반적으로 비관적 락 보다 빠르지만 동시성 수준이 아주 높으면 성능이 급격히 나빠진다.&lt;/p>
&lt;p>예를 들어 설명하면 잔여 객실 수를 읽을 수 있는 클라이언트 수에는 제한이 없으므로, 모든 클라이언트는 같은 잔여 객실 수와 같은 버전 정보를 취득하게 될 수 있기 때문에 모든 클라이언트는 같은 잔여 객실 수와 같은 버전 번호 정보를 취득한다.&lt;/p>
&lt;p>하지만 실제로 버전 번호 갱신에 성공하는 클라이언트는 하나이므로, 다른 모든 클라이언트는 버전 번호 검사에 실패하게된다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>애플리케이션이 유효하지 않은 데이터를 편집하는 일을 막는다.&lt;/li>
&lt;li>데이터베이스 자원에 락을 걸 필요가 없다.(데이터베이스 관점에서 락은 없다.) 책임은 애플리케이션에 있다.&lt;/li>
&lt;li>데이터에 대한 경쟁이 치열하지 않은 상황에 적합하다.
&lt;ul>
&lt;li>락을 관리하는 비용 없이 트랜잭션을 실행할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>데이터에 대한 경쟁이 치열한 상황에서는 성능이 좋지 못하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>낙관적 락은 예약 QPS가 일반적으로 높지 않은 호텔 예약 시스템에서는 적합한 선택지이다.&lt;/p>
&lt;p>&lt;strong>데이터베이스 제약 조건&lt;/strong>&lt;/p>
&lt;p>낙관적 락과 아주 유사하게 동작한다.&lt;/p>
&lt;p>&lt;code>room_type_inventory&lt;/code> 테이블에 다음 제약 조건을 추가한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CONSTRAINT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">check_room_count&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">CHECK&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">total_inventory&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_reserved&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_10.png"
width="1478"
height="1368"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_10_hu8a54ba9888669d6b439cae205e8f7b91_81051_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_10_hu8a54ba9888669d6b439cae205e8f7b91_81051_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 베이스 제약 조건"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="259px"
>&lt;/p>
&lt;p>사용자가 객실을 예약하려면 &lt;code>total_reserved&lt;/code>의 값이 101으로 제약 조건을 위반하게되어 롤백된다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>구현이 쉽다.&lt;/li>
&lt;li>데이터에 대한 경쟁이 심하지 않을 때 잘 동작한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>데이터에 대한 경쟁이 심하면 실패하는 연산 수가 매우 늘어날 수 있다.&lt;/li>
&lt;li>데이터베이스 제약 조건은 애플리케이션 코드와 달라서 버전을 통제하기 어렵다.&lt;/li>
&lt;li>제약 조건을 허용하지 않는 데이터베이스도 있으므로 마이그레이션 등에 문제가 될 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="시스템-규모-확장">시스템 규모 확장&lt;/h3>
&lt;p>일반적으로 호텔 예약 시스템에 대한 부하는 높지 않지만, 유명한 여행 예약 웹 사이트와 연동이 되어야한다면 QPS는 매우 늘어날 수 있다.&lt;/p>
&lt;p>시스템 부하가 높을 때는 무엇이 병목이 될 수 있는지 이해해야한다.&lt;/p>
&lt;ul>
&lt;li>해당 시스템의 모든 서비스는 무상태 서비스이므로 서버를 추가하는 것으로 성능 문제는 해결할 수 있다.&lt;/li>
&lt;li>데이터베이스는 단순히 데이터베이스 서버를 늘리는 것만으로는 성능 문제를 해결할 수 없다.&lt;/li>
&lt;/ul>
&lt;h4 id="데이터베이스-샤딩">데이터베이스 샤딩&lt;/h4>
&lt;p>데이터베이스를 여러 대 두고, 각각에 데이터의 일부만 보관하도록 하는 방식이다.&lt;/p>
&lt;p>데이터베이스를 샤딩할 때는 데이터를 어떻게 분배할 지 먼저 정한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>hotel_id&lt;/code>를 필터링 조건으로 사용하므로 샤딩 조건으로 쓰면 좋다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_11.png"
width="1964"
height="1122"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_11_hu98af43fce089f7bbf6f6bf1fb85b60d6_147947_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_11_hu98af43fce089f7bbf6f6bf1fb85b60d6_147947_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터베이스 샤딩"
class="gallery-image"
data-flex-grow="175"
data-flex-basis="420px"
>&lt;/p>
&lt;p>위는 16개 샤드로 분산하는 사례로, QPS가 30,000이라면 샤딩 후에는 1875QPS 정도로 한 대의 MySQL 서버로도 감당할 수 있는 부하가 된다.&lt;/p>
&lt;h4 id="캐시">캐시&lt;/h4>
&lt;p>호텔 잔여 객실 데이터는 현재와 미래의 데이터만 중요하다는 특성이 있다.&lt;/p>
&lt;p>따라서 데이터를 보관할 때 낡은 데이터는 자동적으로 소멸되도록 TTL을 설정할 수 있다면 바람직하다.&lt;/p>
&lt;ul>
&lt;li>이력 데이터는 다른 데이터베이스를 통해 질의하도록 하면 된다.&lt;/li>
&lt;/ul>
&lt;p>이런 상황에 레디스는 매우 적합하다.&lt;/p>
&lt;hr>
&lt;p>데이터 로딩 속도와 데이터베이스 확장성이 문제가 되기 시작하면 데이터베이스 앞에 캐시 계층을 두고 잔여 객실 확인 및 객실 예약 로직이 해당 계층에서 실행되도록 할 수 있다.&lt;/p>
&lt;p>요청의 일부만 잔여 객실 데이터베이스가 처리하고 나머지는 캐시가 담당하도록 한다.&lt;/p>
&lt;ul>
&lt;li>레디스 캐시 데이터에는 잔여 객실이 충분해 보여도 실제 데이터베이스를 다시 한번 확인해야한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_12.png"
width="1094"
height="682"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_12_hu5d3b54b38dcf02612143f1622e8a715a_133204_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_12_hu5d3b54b38dcf02612143f1622e8a715a_133204_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="캐시"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="384px"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>예약 서비스&lt;/strong>: 다음과 같은 잔여 객실 관리 API를 제공한다.&lt;/p>
&lt;ul>
&lt;li>지정된 호텔과 객실 유형, 주어진 날짜 범위에 이용 가능한 객실의 수를 질의&lt;/li>
&lt;li>객실을 예약하고 &lt;code>total_reserved&lt;/code>의 값을 1 증가&lt;/li>
&lt;li>고객이 예약을 취소하면 잔여 객실 수를 갱신&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>잔여 객실 캐시&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>모든 잔여 객실 관리에 필요한 질의는 레디스로 구현되는 잔여 객실 캐시로 옮긴다.&lt;/li>
&lt;li>따라서 사전에 잔여 객실 정보를 캐시에 미리 저장해두어야 한다.&lt;/li>
&lt;li>캐시에 저장되는 데이터 형식
&lt;ul>
&lt;li>키: &lt;code>hotelID_roomTypeId_{날짜}&lt;/code>&lt;/li>
&lt;li>값
&lt;ul>
&lt;li>주어진 호텔 ID&lt;/li>
&lt;li>객실 유형 ID&lt;/li>
&lt;li>날짜에 맞는 잔여 객실 수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>호텔 예약 시스템은 잔여 객실 확인 작업 때문에 읽기 연산 빈도가 쓰기 연산보다 훨씬 많으므로 대부분의 읽기 연산을 캐시로 처리하면 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>잔여 객실 데이터베이스&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>잔여 객실 수에 대한 가장 믿을 만한 정보가 보관되는 장소&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>캐시가 주는 새로운 과제&lt;/strong>&lt;/p>
&lt;p>캐시 계층을 추가하면 시스템의 확장성과 처리량은 대폭 증가하지만 데이터베이스와 캐시 사이의 데이터 일관성 유지에 관한 새로운 문제가 생긴다.&lt;/p>
&lt;p>사용자가 객실을 예약할 때 아무 문제가 없는 경우에는 다음 두 가지 작업이 이루어진다.&lt;/p>
&lt;ol>
&lt;li>잔여 객실 수를 질의하여 충분한지 확인(캐시)&lt;/li>
&lt;li>잔여 객실 데이터를 갱신
&lt;ul>
&lt;li>데이터베이스 갱신 이후 캐시 갱신&lt;/li>
&lt;li>비동기적으로 실행&lt;/li>
&lt;li>변경 데이터 감지(CDC) 매커니즘을 활용할 수 있다.
&lt;ul>
&lt;li>데이터베이스에서 발생한 변화를 감지하여 해당 변경 내역을 다른 시스템에 적용할 수 있도록 하는 매커니즘&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>잔여 객실 데이터에 대한 변화를 데이터베이스에 먼저 반영하므로 캐시에는 최신 데이터가 없을 가능성이 있다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>이러한 불일치 문제는 데이터베이스가 최종적으로 잔여 객실 확인을 하도록 한다면 문제가 되지는 않는다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>장점&lt;/p>
&lt;ul>
&lt;li>읽기 질의를 캐시가 처리하므로 데이터베이스의 부하가 크게 줄어든다.&lt;/li>
&lt;li>읽기 질의를 메모리에서 실행하므로 높은 성능을 보장할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>단점&lt;/p>
&lt;ul>
&lt;li>데이터베이스와 캐시 사이의 데이터 일관성을 유지하는 것은 어렵다.
&lt;ul>
&lt;li>데이터 불일치가 사용자 경험에 끼치는 영향을 신중하게 살펴야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="서비스-간-데이터-일관성">서비스 간 데이터 일관성&lt;/h3>
&lt;p>모노리스 아키텍처의 경우 데이터의 일광성을 보장하기 위해 관계형 데이터베이스를 공유하는 것이 보통이지만, 해당 시스템은 예약 테이블과 잔여 객실 테이블만 동일한 관계형 데이터베이스에 저장하는 MSA 하이브리드 접근법을 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_13.png"
width="1920"
height="514"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_13_huc5f5e8f7744db63fc867cea3c0d26387_55893_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_13_huc5f5e8f7744db63fc867cea3c0d26387_55893_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="모노리스 vs 마이크로서비스"
class="gallery-image"
data-flex-grow="373"
data-flex-basis="896px"
>&lt;/p>
&lt;p>이를 통해 관계형 데이터베이스의 ACID 속성을 활용하여 동시성 문제를 효과적으로 대응할 수 있지만, MSA 순수 주의자라면 마이크로 서비스가 독자적인 데이터베이스를 갖추고 있어야 한다고 주장할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_15.png"
width="1362"
height="1150"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_15_hu1651b063c3947755463e1494fe52dabe_39875_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_15_hu1651b063c3947755463e1494fe52dabe_39875_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="모노리스 아키텍처"
class="gallery-image"
data-flex-grow="118"
data-flex-basis="284px"
>&lt;/p>
&lt;p>모노리스 아키텍처는 하나의 데이터베이스만 사용하므로 여러 연산을 하나의 트랜잭션으로 묶어 ACID 속성이 만족되도록 보장할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_14.png"
width="1748"
height="1062"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_14_hu657f4a94828478d72376098f027fabfa_59765_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_14_hu657f4a94828478d72376098f027fabfa_59765_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="마이크로서비스 아키텍처"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="395px"
>&lt;/p>
&lt;p>하지만 서비스가 독자적인 데이터베이스를 갖도록 하면, 논리적으로는 하나의 원자적 연산이 여러 데이터베이스에 걸쳐 실행되는 일을 피할 수 없다.&lt;/p>
&lt;ul>
&lt;li>하나의 트랜잭션으로 데이터 일관성을 보증하는 기법을 사용할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>이러한 데이터 일관성 문제를 해결하기 위해 널리 사용되는 방법은 2가지 정도가 있다.&lt;/p>
&lt;ul>
&lt;li>2단계 커밋(2-phase commit, 2PC)
&lt;ul>
&lt;li>여러 노드에 걸친 원자적 트랜잭션 실행을 보증하는 데이터베이스 프로토콜&lt;/li>
&lt;li>모든 노드가 성공하든 아니면 실패하든 둘 중 하나로 트랜잭션이 마무리되도록 보증&lt;/li>
&lt;li>비중단 실행이 가능한 프로토콜이 아니므로 어느 한 노드에 장애가 발생하면 해당 장애가 복구될 때까지 진행이 중단된다.(성능이 뛰어난 프로토콜은 아니다.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사가(Saga)
&lt;ul>
&lt;li>각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮는다.&lt;/li>
&lt;li>각각의 트랜잭션은 완료되면 다음 트랜잭션을 시작하는 트리거로 쓰일 메시지를 만드러 보낸다.&lt;/li>
&lt;li>한 트랜잭션이라도 실패하면 그 이전 트랜잭션의 결과를 전부 되될리는 트랜잭션들을 순차적으로 실행한다.&lt;/li>
&lt;li>2pc는 여러 노드에 걸친 하나의 트랜잭션을 통해 ACID 속성을 만족시키는 개념이지만 사가는 각 단계가 하나의 트랜잭션이라서 결과적 일관성에 의존하는 것으로 본다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>마이크로서비스 간의 데이터 불일치를 해결하기 위해 사용되는 복잡한 매커니즘은 시스템 전체 설계의 복잡성을 크게 증가시킨다.&lt;br>
증가한 복잡성이 그만한 가치가 있는 지 결정하는 것은 설계자의 몫이다.&lt;/p>
&lt;ul>
&lt;li>이번 설계안은 그만한 가치는 없다고 판단하여 예약 및 잔여 객실 정보를 동일한 관계형 데이터베이스에 저장하는 좀 더 실용적인 접근 방법을 선택했다.&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;ul>
&lt;li>경쟁 조건이 발생할 수 있는 시나리오
&lt;ul>
&lt;li>비관적 락&lt;/li>
&lt;li>낙관적 락&lt;/li>
&lt;li>데이터베이스 제약 조건&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규모 확장
&lt;ul>
&lt;li>데이터베이스 샤딩&lt;/li>
&lt;li>레디스 캐시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>마이크로아키텍처의 데이터 일관성 문제&lt;/li>
&lt;/ul></description></item><item><title>6. 광고 클릭 이벤트 집계</title><link>https://codemario318.github.io/post/system-design-interview-2/6/</link><pubDate>Sun, 06 Oct 2024 17:20:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/6/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/cover.png" alt="Featured image of post 6. 광고 클릭 이벤트 집계" />&lt;p>이번 장은 페이스북이나 구글 규모에 걸맞는 &lt;strong>광고 클릭 이벤트 집계 시스템&lt;/strong>(ad click event aggregation system)을 설계해본다.&lt;/p>
&lt;p>기술적인 세부사항을 깊이 살펴보기 전 온라인 광고의 핵심 개념부터 살펴본다.&lt;/p>
&lt;p>온라인 광고의 핵심적 혜택은 &lt;strong>실시간 데이터를 통해 광고 효과를 정량적으로 측정할 수 있다&lt;/strong>는 점이다.&lt;/p>
&lt;p>핵심 프로세스는 &lt;strong>RTB&lt;/strong>(Real-Time Bidding)으로, 이 &lt;strong>경매 절차를 통해 광고가 나갈 지면(inventory)을 거래&lt;/strong>한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
subgraph 지면수요자
direction LR
광고주 --> DSP[DSP: 수요자 플랫폼]
end
DSP --> 광고거래소
SSP --> 광고거래소
subgraph 지면공급자
direction RL
공급자 --> SSP[SSP: 공급자 플랫폼]
end
&lt;/pre>
&lt;ul>
&lt;li>속도
&lt;ul>
&lt;li>보통 1초 내에 모든 프로세스가 마무리되어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 정확성
&lt;ul>
&lt;li>광고 클릭 이벤트 집계는 온라인 광고가 얼마나 효율적이었는지 측정하는 데 결정적인 역할을 한다.
&lt;ul>
&lt;li>광고주가 얼마나 많은 돈을 지불할지에 영향을 끼친다.&lt;/li>
&lt;li>클릭 집계 결과에 따라 광고 캠페인 관리자는 예산을 조절할 수 있다.&lt;/li>
&lt;li>타깃이나 키워드를 변경하는 등 공고 전략을 수정할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CTR(Click-Through Rate, 클릭률), CVR(Conversion Rate, 전환률)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;h3 id="기능-요구사항">기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>지난 M분 동안의 &lt;code>ad_id&lt;/code> 클릭 수 집계&lt;/li>
&lt;li>매분 가장 많이 클릭된 상위 100개 광고 아이디를 반환&lt;/li>
&lt;li>다양한 속성에 따른 집계 필터링을 지원&lt;/li>
&lt;li>데이터의 양은 페이스북이나 구글 규모&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>집계 결과 정확성은 데이터가 RTB 및 광고 과금에 사용되므로 중요&lt;/li>
&lt;li>지연되거나 중복된 이벤트를 적절히 처리할 수 있어야 함&lt;/li>
&lt;li>견고성
&lt;ul>
&lt;li>부분적인 장애는 감내할 수 있어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지연 시간 요구사항
&lt;ul>
&lt;li>전체 처리 시간은 최대 수 분을 넘지 않아야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개력적-추정">개력적 추정&lt;/h3>
&lt;p>시스템 규모 및 풀어야 할 잠재적 문제점을 파악하기 이해 개략적인 규모를 추정해본다.&lt;/p>
&lt;ul>
&lt;li>DAU 10억&lt;/li>
&lt;li>각 사용자는 하루에 평균 1개 광고를 클릭한다 가정
&lt;ul>
&lt;li>따라서 하루에 10억 건의 광고 클릭 이벤트 발생&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>광고 클릭 QPS = 10^9 / 10^5 = 10,000&lt;/code>&lt;/li>
&lt;li>최대 광고 클릭 QPS는 평균 QPS의 5배로 가정(50,000)&lt;/li>
&lt;li>광고 클릭 이벤트 하나당 &lt;code>0.1KB&lt;/code> 용량이 필요하다고 가정
&lt;ul>
&lt;li>&lt;code>일일 저장소 요구량 = 0.1KB * 10억 = 100GB&lt;/code>&lt;/li>
&lt;li>월간 저장 용량 요구량은 대략 3TB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="질의-api-설계">질의 API 설계&lt;/h3>
&lt;p>API를 설계하는 목적은 클라이언트와 서버 간의 통신 규약을 만드는 것 이다.&lt;/p>
&lt;p>본 설계안의 클라이언트는 대시보드를 이용하는 데이터 과학자, 제품 관리자, 광고주 같은 사람으로, 대시보드를 이용하는 순간 집계 서비스에 질의가 발생한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>지난 M분간 각 &lt;code>ad_id&lt;/code>에 발생한 클릭 수 집계&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>용도&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/ads/{:ad_id}/aggregated_count&lt;/td>
&lt;td>주어진 ad_id에 발생한 이벤트 수를 집계하여 반환&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>
&lt;p>호출 인자&lt;/p>
&lt;ul>
&lt;li>from : 집계 시작 시간&lt;/li>
&lt;li>to: 집계 종료 시간&lt;/li>
&lt;li>filter: 필터링 전략 식별자&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>반환 응답&lt;/p>
&lt;ul>
&lt;li>ad_id: 광고 식별자&lt;/li>
&lt;li>count: 집계된 클릭 횟수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>지난 M분간 가장 많은 클릭이 발생한 상위 N개 ad_id 목록&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>용도&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/ads/popular_ads&lt;/td>
&lt;td>지난 M분간 가장 많은 클릭이 발생한 상위 N개 광고 목록 반환&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>호출 인자
&lt;ul>
&lt;li>count: 상위 몇 개의 광고를 반환할 것인가&lt;/li>
&lt;li>window: 분 단위로 표현된 집계 윈도 크기&lt;/li>
&lt;li>filter: 필터링 전략 식별자&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>ad_ids: 공고 식별자 목록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>이 시스템은 &lt;strong>원시 데이터&lt;/strong>와 &lt;strong>집계 결과 데이터&lt;/strong>를 다룬다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>원시 데이터&lt;/strong>&lt;/p>
&lt;p>로그 파일 등으로 저장된 가공되지 않은 데이터를 의미한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[AdClickEvent] ad001, 2021-01-01 00:00:01, user 1, 270.148.22.22, USA
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위와 같은 데이터가 여러 애플리케이션 서버에 산재해있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>집계 결과 데이터&lt;/strong>&lt;/p>
&lt;p>공고 클릭 이벤트가 매분 집계된다고 가정한다면 아래처럼 표현될 수 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>ad_id&lt;/th>
&lt;th>click_minute&lt;/th>
&lt;th>count&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ad001&lt;/td>
&lt;td>202101010000&lt;/td>
&lt;td>5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ad001&lt;/td>
&lt;td>202101010001&lt;/td>
&lt;td>7&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>광고 필터링을 지원하기 위해 &lt;code>filter_id&lt;/code>를 추가하고 같은 &lt;code>ad_id&lt;/code>와 &lt;code>click_minute&lt;/code> 값을 갖는 레코드를 &lt;code>filter_id&lt;/code>가 가리키는 필터 적용 결과에 따라 집계하면 아래와 같은 결과가 만들어진다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>ad_id&lt;/th>
&lt;th>click_minute&lt;/th>
&lt;th>filter_id&lt;/th>
&lt;th>count&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ad001&lt;/td>
&lt;td>2021010000&lt;/td>
&lt;td>0012&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ad001&lt;/td>
&lt;td>2021010000&lt;/td>
&lt;td>0023&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ad001&lt;/td>
&lt;td>2021010001&lt;/td>
&lt;td>0012&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ad001&lt;/td>
&lt;td>2021010001&lt;/td>
&lt;td>0023&lt;/td>
&lt;td>6&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>filter_id&lt;/th>
&lt;th>region&lt;/th>
&lt;th>ip&lt;/th>
&lt;th>user_id&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0012&lt;/td>
&lt;td>US&lt;/td>
&lt;td>0012&lt;/td>
&lt;td>*&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0013&lt;/td>
&lt;td>*&lt;/td>
&lt;td>0023&lt;/td>
&lt;td>123.1.2.3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>지난 M분 동안 가장 많이 클릭된 상위 N개의 광고를 반환하는 질의를 지원하기 위해서는 다음 구조를 사용한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
most_clicked_ads {
window_size integer
update_time_minute timestamp
most_clicked_ads array
}
&lt;/pre>
&lt;hr>
&lt;p>&lt;strong>비교&lt;/strong>&lt;/p>
&lt;p>원시 데이터를 저장하는 방안과 집계 결과 데이터만 보관하는 방안의 장점을 비교해보면 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>원시 데이터만 보관하는 방안
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>원본 데이터를 손실 없이 보관&lt;/li>
&lt;li>데이터 필터링 및 재계산 지원&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>막대한 데이터 용량&lt;/li>
&lt;li>낮은 질의 성능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>집계 결과 데이터만 보관하는 방안
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>데이터 용량 절감&lt;/li>
&lt;li>빠른 질의 기능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>데이터 손실
&lt;ul>
&lt;li>원본 데이터가 아닌 계산/유도된 데이터를 저정하는 데서 오는 결과임&lt;/li>
&lt;li>예시 &amp;gt; 10개의 원본 데이터는 1개의 집계 결과로 축약된다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>원시 데이터와 집계 결과 데이터의 특성으로 인해 모두 저장하는 것이 바람직하다.&lt;/p>
&lt;ul>
&lt;li>문제가 발생하면 디버깅에 활용할 수 있도록 원시 데이터도 보관하는 것이 좋다.
&lt;ul>
&lt;li>데이터가 손상되면 버그 수정 후에 원시 데이터에서 집계 결과를 다시 만들 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>원시 데이터는 양이 엄청나므로 직접 질의하는 것은 비효율적이다.
&lt;ul>
&lt;li>집계 결과 데이터를 질의한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>원시 데이터는 백업 데이터로 활용할 수 있다.
&lt;ul>
&lt;li>재계산을 하는 경우가 아니라면 굳이 원시 데이터를 질의할 필요는 없다.&lt;/li>
&lt;li>오래된 원시 데이터는 cold storage로 옮기면 비용을 절감할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>집계 결과 데이터는 활성 데이터 구실을 한다.
&lt;ul>
&lt;li>질의 성능을 높이기 위해 튜닝하는 것이 일반적이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="올바른-데이터베이스-선택">올바른 데이터베이스 선택&lt;/h3>
&lt;p>올바른 데이터베이스를 선택하기 위해 여러 사항을 고려해야한다.&lt;/p>
&lt;ul>
&lt;li>데이터는 어떤 모습인가?
&lt;ul>
&lt;li>관계형 데이터?, 문서 데이터?, 이진 대형 객체(BLOB)?&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작업 흐름이 읽기 중심인가 쓰기 중심인가?(아님 둘다?)&lt;/li>
&lt;li>트랜잭션을 지원해야 하는가?&lt;/li>
&lt;li>질의 과정에서 SUM, COUNT 같은 온라인 분석 처리 함수를 많이 활용해야 하는가?&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>원시 데이터&lt;/strong>&lt;/p>
&lt;p>일상적인 작업을 위해서라면 질의할 필요가 없지만, 데이터 과학자나 기계 학습 엔지니어가 연구등으로 활용될 수 있다.&lt;/p>
&lt;ul>
&lt;li>이 설계안이 다루는 시스템에서 발생하는 평균 쓰기 QPS는 10,000, 최대 50,000 이므로 &lt;strong>쓰기 중심 시스템&lt;/strong>이라고 볼 수 있다.&lt;/li>
&lt;li>원시 데이터는 백업과 재계산 용도로 활용하므로 읽기 연산 빈도는 낮다.&lt;/li>
&lt;/ul>
&lt;p>관계형 데이터베이스도 활용 가능하지만 큰 규모의 쓰기 연산이 가능하도록 구성하기 매우 어려우므로, 쓰기 및 시간 범위 질의에 최적화된 카산드라나 InfluxDB를 사용하는 것이 좀 더 바람직하다.&lt;/p>
&lt;ul>
&lt;li>칼럼형(columnar) 데이터 형식 가운데 하나를 사용하여 아마존 S3에 데이터를 저장하는 방법도 고려할 수 있다.
&lt;ul>
&lt;li>ORC, 파케이(Parquet), AVRO&lt;/li>
&lt;li>각 파일의 최대 크기를 제한하면 원시 데이터 기록 담당 스트림 프로세서가 새 파일을 만든다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>집계 데이터&lt;/strong>&lt;/p>
&lt;p>집계 데이터는 본질적으로 시계열 데이터이며, 이 데이터를 처리하는 워크 플로는 읽기 연산과 쓰기 연산 둘 다 많이 사용한다.&lt;/p>
&lt;p>집계 서비스가 데이터를 매 분 집계하고 그 결과 데이터를 저장하는 데는 같은 유형의 데이터베이스를 활용하는 것이 가능하다(카산드라).&lt;/p>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>실시간으로 빅데이터를 처리할 때 데이터는 보통 무제한으로 시스템에 흘러들어왔다가 나간다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart
subgraph 입력
logMonitor[로그모니터]
end
subgraph 프로세스
dataAgg[데이터 집계 서비스]
end
subgraph 출력
db[(데이터베이스)]
end
subgraph 표시
query[질의 서비스]
end
logMonitor --데이터 푸시--> dataAgg
dataAgg --광고 수--> db
dataAgg --가장 많이 클릭된 상위 100개 광고--> db
query --질의--> db
&lt;/pre>
&lt;hr>
&lt;p>&lt;strong>비동기 처리&lt;/strong>&lt;/p>
&lt;p>제시한 설계안은 동기식 처리를 기반으로 하지만, 생산자와 소비자의 용량이 항상 같을 수는 없기 때문에 좋지 않을 수 있다.&lt;/p>
&lt;ul>
&lt;li>트래픽이 갑자기 증가하여 발생하는 이벤트 수가 소비자의 처리 용량을 훨씬 넘어서는 경우 소비자는 메모리 부족 오류 등의 예기치 않은 문제를 겪게 될 수 있다.&lt;/li>
&lt;li>동기식 시스템의 경우 특정 컴포넌트의 장애는 전체 시스템의 장애로 이어진다.&lt;/li>
&lt;/ul>
&lt;p>이 문제를 해결하는 일반적인 방안은 카프카 같은 &lt;strong>메시지 큐를 도입하여 생산자와 소비자의 결함을 끊는 것&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>전체 프로세스가 비동기로 동작하게된다.&lt;/li>
&lt;li>비동기로 동작하므로 생산자와 소비자의 규모를 독립적으로 확장해 나갈 수 있게된다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img.png"
width="826"
height="468"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_hu308e0d8138a48f72649f62b8270e02b9_127555_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_hu308e0d8138a48f72649f62b8270e02b9_127555_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="176"
data-flex-basis="423px"
>&lt;/p>
&lt;p>로그 감시자, 집계 서비스, 데이터베이스는 두 개의 메시지 큐로 분리되어있다.&lt;/p>
&lt;p>데이터베이스 기록 프로세스는 메시지는 메시지 큐에서 데이터를 꺼내 데이터베이스가 지원하는 형식으로 변환 후 기록하는 역할을 수행한다.&lt;/p>
&lt;ul>
&lt;li>첫 번째 메시지 큐
&lt;ul>
&lt;li>광고 클릭 이벤트가 기록된다.&lt;/li>
&lt;li>ad_id, click_timestamp, user_id, ip, country&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>두 번째 메시지 큐
&lt;ul>
&lt;li>분 단위로 집게된 광고 클릭 수&lt;/li>
&lt;li>분 단위로 집계한, 가장 많이 클릭한 상위 N개 광고&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>집계 결과를 데이터베이스에 바로 기록하지 않는 이유는 정확하게 한 번(exactly once) 데이터를 처리하기 위해(atomic commit, 원자적 커밋) 카프카 같은 시스템을 두 번 째 메시지 큐로 도입해야 하기 때문이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_1.png"
width="805"
height="479"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_1_hu1c9282359cbbacf359a25482b125e71b_138566_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_1_hu1c9282359cbbacf359a25482b125e71b_138566_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="정확하게 한 번 처리하기 위한 메커니즘"
class="gallery-image"
data-flex-grow="168"
data-flex-basis="403px"
>&lt;/p>
&lt;h3 id="집계-서비스">집계 서비스&lt;/h3>
&lt;p>광고 클릭 이벤트를 집계하는 좋은 방안 하나는 &lt;strong>맵리듀스&lt;/strong>(MapReduce) 프레임워크를 사용하는 것 이다.&lt;/p>
&lt;p>맵리듀스 프레임워크에 좋은 모델은 유향 비순환 그래프(DAG) 모델이며, 시스템을 맵/집계/리듀스 노드 드으이 작은 컴퓨팅 단위로 세분화 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>각 노드는 한 가지 작업만 처리하며, 처리 결과를 다음 노드에 인계한다.&lt;/li>
&lt;/ul>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
data --데이터 입력-->
Map((Map)) --ad_id % 2 = 0--> node1((집계 노드 1))
Map --ad_id % 2 = 1--> node2((집계 노드 2))
&lt;/pre>
&lt;hr>
&lt;p>&lt;strong>맵 노드&lt;/strong>&lt;/p>
&lt;p>맵 노드는 데이터 출처에서 읽은 데이터를 필터링하고 변환하는 역할을 담당한다.&lt;/p>
&lt;ul>
&lt;li>카프카 파티션이나 태그를 구성한 후 집계 노드가 카프카를 직접 구독하도록 할 경우 맵 노드를 활용하지 않을 수 있지만, 입력 데이터를 정리하거나 정규화해야 하는 경우에는 맵 노드가 필요하다.&lt;/li>
&lt;li>데이터가 생성되는 방식에 대한 제어권이 없는 경우 동일한 ad_id를 갖는 이벤트가 서로 다른 카프카 파티션에 입력될 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>집계 노드&lt;/strong>&lt;/p>
&lt;p>집계 노드는 ad_id 별 광고 클릭 이벤트 수를 매 분 메모리에서 집계한다.&lt;/p>
&lt;p>맵리듀스 패러다임에서 사실 집계 노드는 리듀스 프로세스의 일부여서, &lt;strong>맵-집계-리듀스&lt;/strong> 프로세스는 &lt;strong>맵-리듀스-리듀스&lt;/strong> 프로세스라고도 할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>리듀스 노드&lt;/strong>&lt;/p>
&lt;p>리듀스 노드는 모든 집계 노드가 산출한 결과를 최종 결과로 축약한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_2.png"
width="664"
height="314"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_2_hu4f114adc039c7d0d8d1bf45626dddb0d_89514_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_2_hu4f114adc039c7d0d8d1bf45626dddb0d_89514_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="리듀스 노드"
class="gallery-image"
data-flex-grow="211"
data-flex-basis="507px"
>&lt;/p>
&lt;p>DAG는 맵리듀스 패러다임을 표현하기 위한 모델로, 빅데이터를 입력으로 받아 병렬 분산 컴퓨팅 자원을 활용하여 빅데이터를 작은(일반적) 크기 데이터로 변환할 수 있도록 설계된 모델이다.&lt;/p>
&lt;p>중간 데이터는 메모리에 저장될 수 있으며, 노드 간 통신은 서로 다른 프로세스에서 실행되는 경우 TCP, 서로 다른 스레드에서 실해오디는 경우 공유 메모리로 처리할 수도 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>주요 사용 사례&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>클릭 이벤트 수 집계
&lt;ul>
&lt;li>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_3.png"
width="834"
height="332"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_3_hu15a9c90a865279d5a482021e1c73ca05_120267_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_3_hu15a9c90a865279d5a482021e1c73ca05_120267_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클릭 이벤트 수 집계"
class="gallery-image"
data-flex-grow="251"
data-flex-basis="602px"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가장 많이 클릭된 상위 N개 광고 반환
&lt;ul>
&lt;li>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_4.png"
width="806"
height="453"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_4_hu9e0acdcb57074c8157c74737a33fe94e_193386_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_4_hu9e0acdcb57074c8157c74737a33fe94e_193386_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="가장 많이 클릭된 상위 N개 광고 반환"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="427px"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 필터링
&lt;ul>
&lt;li>필터링 기준을 사전에 정의한 후 해당 기준에 따라 집계한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>스타 스키마&lt;/strong>&lt;/p>
&lt;p>데이터 웨어하우스에서 널리 쓰이는 기법으로, 필터링에 사용되는 필드는 차원이라 부른다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>이해하기 쉽고 구축하기 간단하다.&lt;/li>
&lt;li>기존 집계 서비스를 재사용하여 스타 스키마에 더 많은 차원을 생성할 수 있다. 다른 추가 컴포넌트는 필요없다.&lt;/li>
&lt;li>결과를 미리 계산해 두는 방식이므로, 필터링 기준에 따라 데이터에 빠르게 접근할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>많은 버킷과 레코드가 생성된다. (필터링 기준이 많을 경우 더더욱)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="스트리밍-vs-일괄-처리">스트리밍 vs 일괄 처리&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>서비스(온라인 시스템)&lt;/th>
&lt;th>일괄 처리 시스템(오프라인 시스템)&lt;/th>
&lt;th>스트리밍 처리 시스템(실시간에 가깝게 처리하는 시스템)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>응답성&lt;/td>
&lt;td>클라이언트에게 빠르게 응답&lt;/td>
&lt;td>클라이언트에게 응답할 필요가 없음&lt;/td>
&lt;td>클라이언트에게 응답할 필요가 없음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>입력&lt;/td>
&lt;td>사용자의 요청&lt;/td>
&lt;td>유한한 크기를 갖는 입력. 큰 규모의 데이터&lt;/td>
&lt;td>입력에 경계가 없음(무한 스트림)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>출력&lt;/td>
&lt;td>클라이언트에 대한 응답&lt;/td>
&lt;td>구체화 뷰, 집계 결과 지표 등&lt;/td>
&lt;td>구체화 뷰, 집계 결과 지표 등&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>성능 측정 기준&lt;/td>
&lt;td>가용성, 지연 시간&lt;/td>
&lt;td>처리량&lt;/td>
&lt;td>처리량, 지연 시간&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사례&lt;/td>
&lt;td>온라인 쇼핑&lt;/td>
&lt;td>맵리듀스&lt;/td>
&lt;td>플링크&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>본 설계안은 스트림 처리와 일괄 처리 방식을 모두 사용한다.&lt;/p>
&lt;ul>
&lt;li>스트림 처리는 데이터를 오는 대로 처리하고 거의 실시간으로 집계된 결과를 생성하는 데 사용한다.&lt;/li>
&lt;li>일괄 처리는 이력 데이터를 백업하기 위해 활용한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_5.png"
width="874"
height="648"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_5_huc5dc5bec0ac92440f8db6a7292969bc9_305717_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_5_huc5dc5bec0ac92440f8db6a7292969bc9_305717_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="람다, 카파 아키첵처"
class="gallery-image"
data-flex-grow="134"
data-flex-basis="323px"
>&lt;/p>
&lt;p>&lt;strong>람다 아키텍처&lt;/strong>&lt;/p>
&lt;p>일괄 및 스트리밍 처리 경로를 동시에 지원하는 시스템의 아키텍처를 람다(lambda)라고 부른다.&lt;/p>
&lt;p>람다 아키텍처의 단점은 두 가지 처리 경로를 지원하므로 유지 관리 해야할 코드가 두 벌이라는 점이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>카파 아키텍처&lt;/strong>&lt;/p>
&lt;p>카파 아키텍처(Kappa architecture)는 일괄 처리와 스트리밍 처리 경로를 하나로 결합하여 람다 아키텍처의 단점을 해결한다.&lt;/p>
&lt;p>핵심 아이디어는 단일 스트림 처리 엔진을 사용하여 실시간 데이터 처리 및 끊임없는 데이터 재처리 문제를 모두 해결하는 것이다.&lt;/p>
&lt;hr>
&lt;p>본 시스템의 개략적 설계안은 카파 아키텍처를 따른다. 따라서 이력 데이터의 재처리도 실시간 집계 서비스를 거치게된다.&lt;/p>
&lt;h3 id="데이터-재계산">데이터 재계산&lt;/h3>
&lt;p>이미 집계한 데이터를 다시 계산해야 하는 경우가 있는데, 이를 &lt;strong>이력 데이터 재처리&lt;/strong>(historical data replay)라고도 부른다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_6.png"
width="846"
height="274"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_6_hu3a7f884ae78691745bb1093350943e0b_109182_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_6_hu3a7f884ae78691745bb1093350943e0b_109182_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="재계산 서비스"
class="gallery-image"
data-flex-grow="308"
data-flex-basis="741px"
>&lt;/p>
&lt;ol>
&lt;li>원시 데이터 저장소에서 데이터를 검색한다.&lt;/li>
&lt;li>추출된 데이터를 전용 집계 서비스로 전송한다.
&lt;ul>
&lt;li>전용 집계 서비스는 실시간 데이터 처리 과정이 과거 데이터 재처리 프로세스와 간섭하는 일을 막기 위해 추가한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>집계 결과는 두 번째 메시지 큐로 전송되어 집계 결과 데이터베이스에 반영된다.&lt;/li>
&lt;/ol>
&lt;p>재계산 프로세스는 데이터 집계 서비스를 재사용하기는 하지만 처리 대상 데이터는 다른 곳에서 읽는다(원시 데이터).&lt;/p>
&lt;h3 id="시간">시간&lt;/h3>
&lt;p>집계를 하려면 타임스탬프가 필요한데, 타임 스탬프는 두 가지 다른 위치에서 만들어질 수 있다.&lt;/p>
&lt;ul>
&lt;li>이벤트 시각: 광고 클릭이 발생한 시각&lt;/li>
&lt;li>처리 시각: 집계 서버가 이벤트를 처리한 시스템 시각&lt;/li>
&lt;/ul>
&lt;p>네트워크 지연이나 비동기 처리 환경(데이터가 메시지 큐를 거쳐야 하는 환경)때문에 이벤트가 발생한 시각과 처리 시각 사이의 간격이 커질 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_7.png"
width="669"
height="188"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_7_huf8002690287510900e2c2679f234f3b3_47016_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_7_huf8002690287510900e2c2679f234f3b3_47016_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="늦게 도착한 이벤트"
class="gallery-image"
data-flex-grow="355"
data-flex-basis="854px"
>&lt;/p>
&lt;p>이벤트가 발생한 시각을 집계에 사용하는 경우 지연된 이벤트 처리 문제를 잘 해결해야 하며, 처리 시각을 집계에 사용하는 경우 집계 결과가 부정확할 수 있다는 점을 고려해야 한다.&lt;/p>
&lt;p>완벽한 솔루션은 없으므로, 두 방은의 장단점을 고려하여 적절한 결정을 내린다.&lt;/p>
&lt;ul>
&lt;li>이벤트 발생 시각
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>광고 클릭 시점을 정확히 아는 것은 클라이언트이므로 집계 결과가 보다 정확&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>클라이언트가 생성한 타임스탬프에 의존하는 방식이므로 클라이언트에 설정된 시각이 잘못 되었거나 악성 사용자가 타임스탬프를 고의로 조작하는 문제에서 자유로울 수 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>처리 시각
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>서버 타임스탬프가 클라이언트 타임스탬프보다 안정적&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>이벤트가 시스템에 도착한 시각이 함참 뒤인 경우에는 집계 결과가 부정확해짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>데이터 정확도는 아주 중요하므로, 이벤트 발생 시각을 사용할 것을 추천한다.&lt;/p>
&lt;p>이러한 경우 시스템에 늦게 도착한 이벤트를 올바르게 처리하기 위해 &lt;strong>워터마크&lt;/strong>(watermark)라는 기술이 일반적으로 사용된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_8.png"
width="783"
height="245"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_8_huba72022b748b87378d5ddc854e8995cd_104439_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_8_huba72022b748b87378d5ddc854e8995cd_104439_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="집계 윈도에 누락되는 이벤트"
class="gallery-image"
data-flex-grow="319"
data-flex-basis="767px"
>&lt;/p>
&lt;p>이벤트 발생 시각을 기준으로 이벤트가 어떤 윈도에 속하는지 결정하면 이벤트가 집계 윈도가 끝나는 시점보다 살짝 늦게 도착하게되는 경우 집계에 실패하게된다.&lt;/p>
&lt;p>워터마크는 집계 윈도를 확장하여 집계 정확도를 높힐 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_9.png"
width="782"
height="236"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_9_huaa56781eaf1b8e81055800fd2830b619_103298_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_9_huaa56781eaf1b8e81055800fd2830b619_103298_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="워터마크"
class="gallery-image"
data-flex-grow="331"
data-flex-basis="795px"
>&lt;/p>
&lt;p>15초 워터마크를 윈도 마다 붙이면 윈도 1, 3이 누락된 이벤트를 집계할 수 있게 된다.&lt;/p>
&lt;p>워터마크의 크기는 비즈니스 요구사항에 따라 달리 잡는다.&lt;/p>
&lt;ul>
&lt;li>워터마크 구간이 길면 늦게 도착하는 이벤트도 포착할 수 있지만 시스템의 이벤트 처리 시간은 늘어난다.&lt;/li>
&lt;li>짧으면 데이터 정확도는 떨어지지만 시스템의 응답 지연은 낮아진다.&lt;/li>
&lt;/ul>
&lt;p>워터마크를 사용하더라도 시간이 한참 흐른 후에 시스템에 도달하는 이벤트는 처리할 수 없다.&lt;/p>
&lt;p>발생할 확률이 낮은 이벤트 처리를 위해 시스템을 복잡하게 설계하면 투자 대비 효능(ROI)는 떨어지고, 사소한 데이터 오류는 하루치 데이터 처리를 마감할 때 조정할 수 있으므로 워터마크 구간을 길게 가져갈 이유는 없다.&lt;/p>
&lt;h3 id="집계-윈도">집계 윈도&lt;/h3>
&lt;p>윈도에는 텀블링 윈도(tumbling window, 고정 윈도(fixed window) 라고도 함), 호핑 윈도(hopping window), 슬라이딩 윈도(sliding window), 세션 윈도(session window) 총 네 종류가 있다.&lt;/p>
&lt;p>이 가운데 텀플링 윈도와 슬라이딩 윈도가 설계안과 관련있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>텀블링 윈도&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_10.png"
width="773"
height="183"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_10_huceeb3723b2780057ddaa40743569e45d_66924_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_10_huceeb3723b2780057ddaa40743569e45d_66924_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="텀블링 윈도"
class="gallery-image"
data-flex-grow="422"
data-flex-basis="1013px"
>&lt;/p>
&lt;p>시간을 같은 크기의 겹치지 않는 구간으로 분할하므로, 매 분 발생한 클릭 이벤트를 집계하기 적합하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>슬라이딩 윈도&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_11.png"
width="795"
height="185"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_11_hu9468ea01e7b032fc68b0427be3506431_67457_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_11_hu9468ea01e7b032fc68b0427be3506431_67457_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="슬라이딩 윈도"
class="gallery-image"
data-flex-grow="429"
data-flex-basis="1031px"
>&lt;/p>
&lt;p>데이터 스트림을 미끄러져 나아가면서 같은 시간 구간 안에 있는 이벤트를 집계한다. 슬라이딩 윈도는 서로 겹칠 수 있어 시스템의 두 번째 요구사항인 지난 M분간 가장 많이 클릭된 상위 N개 광고를 알아내기 적합하다.&lt;/p>
&lt;h3 id="전달-보장">전달 보장&lt;/h3>
&lt;p>집계 결과는 과금 등에 활용될 수 있기 때문에 데이터의 정확성과 무결성이 아주 중요하다.&lt;/p>
&lt;ul>
&lt;li>이벤트의 중보 처리를 어떻게 피할 수 있는가?&lt;/li>
&lt;li>모든 이벤트의 처리를 어떻게 보장할 수 있는가?&lt;/li>
&lt;/ul>
&lt;p>카프카와 같은 메시지 큐는 보통 최대 한 번, 최소 한 번, 정확히 한 번 총 세 가지 유형의 전달 방식을 지원한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>어떤 전달 방식을 택할 것 인가?&lt;/strong>&lt;/p>
&lt;p>약간의 중복이 괜찮다면 대체로 &lt;strong>최 소 한번&lt;/strong>이 적절하나, 본 설계안은 데이터의 몇 퍼센트 차이가 수백만 달러 차이로 이어질 수 있으므로 &lt;strong>정확히 한 번&lt;/strong>방식을 권장한다.&lt;/p>
&lt;p>&lt;strong>데이터 중복 제거&lt;/strong>&lt;/p>
&lt;p>가장 흔한 데이터 품질 이슈 가운데 하나는 중복된 데이터이다.&lt;/p>
&lt;ul>
&lt;li>클라이언트측
&lt;ul>
&lt;li>한 클라이언트가 같은 이벤트를 여러 번 보내는 경우&lt;/li>
&lt;li>악의적인 의도로 전송되는 중복 이벤트를 처리하는 데는 &lt;strong>광고 사기/위험 제어 컴포넌트&lt;/strong>(ad fraud/risk controller)가 적합하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서버 장애
&lt;ul>
&lt;li>집계 도중에 집계 서비스 노드에서 장애가 발생하였고, 업 스트림 서비스가 이벤트 메시지에 대해 응답을 받지 못한경우, 같은 이벤트가 다시 전송되어 재차 집계될 가능성이 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_12.png"
width="593"
height="468"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_12_huede191de92b81be00b9a3ae48a395ffa_158639_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_12_huede191de92b81be00b9a3ae48a395ffa_158639_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="중복 데이터"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="304px"
>&lt;/p>
&lt;p>집계 서비스 노드에 장애가 생겨 6단계를 실행하지 못하면 100에서 110 까지의 이벤트는 이비 다운 스트림에 전송되었으나 새 오프셋은 업스트림 카프카에 반영되지 않아, 새로 북고된 집계 서비스 노드는 오프셋 100부터 이벤트를 다시 소비하려고 할 것이다, 그 결과로 데이터 중복이 발생한다.&lt;/p>
&lt;p>이 문제의 간단한 해결책으로 HDFS나 S3 같은 외부 파일 저장소에 오프셋을 기록하는 방법이 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_13.png"
width="768"
height="529"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_13_hu6b78f3cdb30d0caba5a7a8cd6c6b715e_161577_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_13_hu6b78f3cdb30d0caba5a7a8cd6c6b715e_161577_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="오프셋 기록"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="348px"
>&lt;/p>
&lt;p>집계 결과를 다운 스트림으로 전송하기 전에 오프셋을 외부에 저장하고 있는데, 만일 그 직후 집계 서비스 노드에 장애가 발생하여 4단계를 완료하지 못했다면, 외부 저장소에 저장된 오프셋은 110이므로 복구된 집계 서비스 노드는 100부터 110 까지의 이벤트를 다시 처리하지 않는다.&lt;/p>
&lt;p>따라서 데이터 손실을 막으려면 다운스트림에서 집계 결과 수신 확인 응답을 받은 후에 오프셋을 저장해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_14.png"
width="814"
height="573"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_14_hu2ab70a303052b4a2adad9c1e83700448_163160_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_14_hu2ab70a303052b4a2adad9c1e83700448_163160_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="수신 확인 후 오프셋 저장"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="340px"
>&lt;/p>
&lt;p>이벤트를 정확하게 한 번만 처리하고 싶다면 4단계부터 6단계가지의 작업을 하나의 분산 트랜잭션에 넣어야한다.&lt;/p>
&lt;p>분산 트랜잭션은 여러 노드에서 작동하는 트랜잭션으로 그 안에서 실행하는 작업 가운데 하나라도 실패하면 모든 작업의 상태를 실행 전으로 되돌린다.&lt;/p>
&lt;h3 id="시스템-규모-확장">시스템 규모 확장&lt;/h3>
&lt;p>본 설계안은 메시지 큐, 집계 서버, 데이터베이스의 세 가지 독립 구성 요소로 이루어져, 상호 결합도가 낮으므로 각기 독립적으로 규모를 늘릴 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>메시지 큐의 규모 확장&lt;/strong>&lt;/p>
&lt;p>메시지 큐의 규모 학장법에 대해서는 4장 분산 메시지 큐에서 광범위하게 설명했으므로 요점만 확인한다.&lt;/p>
&lt;ul>
&lt;li>생산자
&lt;ul>
&lt;li>생산자 인스턴스 수에는 제한을 두지 않으므로 따라서 확정성은 쉽게 달성할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>소비자
&lt;ul>
&lt;li>소비자 그룹 내의 재조정 매커니즘은 노드 추가/삭제를 통해 그 규모를 쉽게 조장할 수 있도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>수백 개 카프카 소비자가 있는 경우 재조정 작업 시간이 길어져서 수 분 이상 걸리게 될 수 있으므로 더 많은 소비자를 추가하는 작업은 시스템 사용량이 많지 않은 시간에 실행하여 영향을 최소화하는 것이 좋다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>브로커&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>해시 키
&lt;ul>
&lt;li>같은 ad_id를 갖는 이벤트를 같은 카프카 파티션에 저장하기 위해 ad_id를 해시 키로 사용한다.&lt;/li>
&lt;li>집계 서비스는 같은 ad_id를 갖는 이벤트를 전부 같은 파티션에서 구독할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파티션의 수
&lt;ul>
&lt;li>파티션의 수가 변하면 같은 ad_id르 ㄹ갖는 이벤트가 다른 파티션에 기록되는 일이 생길 수 있으므로 사전에 충분한 파티션을 확보하여 프로덕션 환경에서 파티션의 수가 동적으로 늘어나는 일을 피하는 것이 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>토픽의 물리적 샤딩
&lt;ul>
&lt;li>하나의 토픽만으로 충분한 경우는 거의 없다.&lt;/li>
&lt;li>지역에 따라, 사업 유형에 따라 여러 토픽을 둘 수 있다.&lt;/li>
&lt;li>장점
&lt;ul>
&lt;li>데이터를 여러 토픽으로 나누면 시스템의 처리 대역폭을 높일 수 있다.&lt;/li>
&lt;li>단일 토픽에 대한 소비자의 수가 줄면 소비자 그룹의 재조정 시간도 단축된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>복잡성이 증가하고 유지 관리 비용이 늘어난다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>집게 서비스의 규모 확장&lt;/strong>&lt;/p>
&lt;p>집계 서비스는 본질적으로 맵리듀스 연산으로 구현된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_15.png"
width="849"
height="546"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_15_hu20e8fafda3109e5f006bddac6e6ffbd9_270584_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_15_hu20e8fafda3109e5f006bddac6e6ffbd9_270584_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="집계 서비스"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="373px"
>&lt;/p>
&lt;p>집계 서비스의 규모는 노드의 추가/삭제를 통해 수평적으로 조정이 가능하다.&lt;/p>
&lt;p>집계 서비스의 처리 대역폭을 높이는 방법으로 두 가지 선택지가 있다.&lt;/p>
&lt;ul>
&lt;li>ad_id마다 별도의 처리 스레드를 두는 방식
&lt;ul>
&lt;li>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_16.png"
width="778"
height="632"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_16_hu9240b727125146b5187adbdd80d812ee_164979_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_16_hu9240b727125146b5187adbdd80d812ee_164979_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="다중 스레드"
class="gallery-image"
data-flex-grow="123"
data-flex-basis="295px"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>집계 서비스 노드를 아파치 하둡 YARN 같은 자원 공급자에 배포하는 방식&lt;/li>
&lt;/ul>
&lt;p>두 가지 방안 중 첫 번째가 더 구현하기 쉽고, 자원 공급자에 대한 의존 관계도 없다.&lt;/p>
&lt;p>하지만, 더 많은 컴퓨팅 자원을 추가하여 시스템의 규모를 확장할 수 있는 두 번째 방안이 많이 활용된다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>데이터베이스의 규모 확장&lt;/strong>&lt;/p>
&lt;p>카산드라는 안정 해시와 유사한 방식으로 수평적인 규모 확장을 기본적으로 지원한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_17.png"
width="626"
height="613"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_17_hu5415acd9f61d814ec2621993794f7a7c_402592_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_17_hu5415acd9f61d814ec2621993794f7a7c_402592_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="가상 노드"
class="gallery-image"
data-flex-grow="102"
data-flex-basis="245px"
>&lt;/p>
&lt;h3 id="핫스팟-문제">핫스팟 문제&lt;/h3>
&lt;p>다른 서비스나 샤드보다 더 많은 데이터를 수신하는 서비스나 샤드를 핫스팟이라 부른다.&lt;/p>
&lt;p>광고 클릭 집계 시스템은 큰 회사가 큰 광고예산을 집행하여 더 많은 노출을 하게 만들수 있고, 이로 인해 특정 광고에 더 많은 클릭이 발생할 수 있다.&lt;/p>
&lt;p>이벤트 파티션을 ad_id로 나누기 때문에 어떤 집계 서비스 노드는 다른 노드보다 더 많은 광고 클릭 이벤트를 수신하게 될 것이고, 그러다보면 서버 과부하 문제가 발생할 수 있다.&lt;/p>
&lt;p>이러한 문제는 더 많은 집계 서비스 노드를 할당하여 완화할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_18.png"
width="824"
height="646"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_18_hu7889c8879218e6422a2a8525761062d5_152491_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_18_hu7889c8879218e6422a2a8525761062d5_152491_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="추가 집계 서비스 노드의 할당"
class="gallery-image"
data-flex-grow="127"
data-flex-basis="306px"
>&lt;/p>
&lt;ol>
&lt;li>집계 서비스 노드에 300개 이벤트가 도착하여 노드가 감당할 수 있는 양을 초과 하였기 때문에 자원 관리자에게 추가 자원을 신청한다.&lt;/li>
&lt;li>자원 관리자는 해당 서비스 노드에 과부하가 걸리지 않도록, 추가 자원을 할당한다.(예시는 두 개의 집계 서비스 노드)&lt;/li>
&lt;li>원래 집계 서비스 노드는 각 서비스 노드가 100개씩의 이벤트를 처리할 수 있도록 이벤트를 세 개 그룹으로 분할한다.&lt;/li>
&lt;li>집계가 끝나 축약된 결과는 다시 원래 집계 서비스 노드에 기록한다.&lt;/li>
&lt;/ol>
&lt;p>전역-지역 집계(Global-Local Aggregation)나 분할 고유 집계(Split Distinct Aggregation) 같은 복잡한 방법도 고려할 수 있다.&lt;/p>
&lt;h3 id="결함-내성">결함 내성&lt;/h3>
&lt;p>집게는 메모리에서 이루어지므로 집계 노드에 장애가 생기면 집계 결과도 손실된다.&lt;/p>
&lt;p>하지만 업스트림 카프카 브로커에서 이벤트를 다시 받아오면 그 숫자를 다시 만들어 낼 수 있다.&lt;/p>
&lt;p>카프카 데이터를 원점 주터 다시 재생하여 집계하면 시간이 오래 걸리므로, 업스트림 오프셋 같은 시스템 상태를 스냅숏으로 저장하고 마지막으로 저장된 상태부터 복구해 나가는 것이 바람직하다.&lt;/p>
&lt;ul>
&lt;li>시스템 상태에 해당하는 정보는 업스트림 오프셋 뿐만 아니라 지난 M분간 가장 많이 클릭된 광고 N개 같은 데이터도 시스템 상태의 일부로 저장한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_19.png"
width="764"
height="247"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_19_hua2281ddfd0fa3d6e52ee3d7483f287c2_75340_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_19_hua2281ddfd0fa3d6e52ee3d7483f287c2_75340_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="스냅솟 데이터"
class="gallery-image"
data-flex-grow="309"
data-flex-basis="742px"
>&lt;/p>
&lt;p>스냅숏을 이용하면 집계 서비스의 복구 절차가 단순해진다.&lt;/p>
&lt;p>어떤 집계 서비스 노드 하나에 장애가 발생하면 해당 노드를 새 것으로 대체한 다음 마지막 스냅숏에서 데이터를 복구하면 된다.&lt;/p>
&lt;h3 id="데이터-모니터링-및-정확성">데이터 모니터링 및 정확성&lt;/h3>
&lt;p>집계 결과는 RTB 및 청구서 발행 목적으로 사용될 수 있으므로ㅓ 시스템이 정상적으로 동작하는 지 모니터링 하고 데이터 정확성을 보장하는 것은 아주 중요한 과제이다.&lt;/p>
&lt;p>&lt;strong>지속적 모니터링&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>지연 시간
&lt;ul>
&lt;li>데이터를 처리하는 각 단계마다 지연 시간이 추가될 수 있으므로, 시스템의 중요 부분마다 시각 추적이 가능하도록 해야한다.&lt;/li>
&lt;li>기록된 사각 사이의 차이를 지연 시간 지표로 변환해서 모니터링한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 큐 크기
&lt;ul>
&lt;li>큐의 크기가 갑자기 늘어난다면 더 많은 집계 서비스 노드를 추가해야 할 수 있다.&lt;/li>
&lt;li>카프카는 분산 커밋 로그 형태로 구현된 메시지 큐 이므로, 카프카를 사용하는 경우 레코드 처리 지연 지표를 대신 추적한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>집계 노드의 시스템 자원
&lt;ul>
&lt;li>CPU, 디스크, JVM 같은 것에 관계된 지표&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>조정&lt;/strong>&lt;/p>
&lt;p>조정(reconciliation)은 다양한 데이터를 비교하여 데이터 무결성을 보증하는 기법을 일컫는다.&lt;/p>
&lt;p>광고 클릭 집게 결과는 비교할 제 3자가 없으므로 매일 각 파이션에 기록된 클릭 이벤트를 이벤트 발생 시각에 따라 정렬한 결과를 일괄 처리하여 만들어낸 후, 실시간 집계 결과와 비교해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>더 높은 정확도가 필요하다면 더작은 집계 작은 집계 윈도를 사용한다.&lt;/li>
&lt;li>윈도 크기와 관계 없이 일부 이벤트는 늦게 도착할 수 있으므로 배치 작업 결과가 실시간 집계 결과와 정확히 일치하지 않을 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_20.png"
width="833"
height="346"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_20_hub35bf4c448d6cf0170ffb4ecf93d6924_122803_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_20_hub35bf4c448d6cf0170ffb4ecf93d6924_122803_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="최종 설계안"
class="gallery-image"
data-flex-grow="240"
data-flex-basis="577px"
>&lt;/p>
&lt;h3 id="대안적-설계안">대안적 설계안&lt;/h3>
&lt;p>다른 한 가지 가능한 설계안은 광고 클릭 데이터를 하이브에 저장한 다음 빠른 질의는 일래스틱서치 계층을 얹어서 처리할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_21.png"
width="833"
height="286"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_21_hu8585af607f9fff0160c43d5a0ee15e53_80257_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_21_hu8585af607f9fff0160c43d5a0ee15e53_80257_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="img_21.png"
class="gallery-image"
data-flex-grow="291"
data-flex-basis="699px"
>&lt;/p>
&lt;p>집계는 클릭하우스, 드루이드 같은 OLAP 데이터베이스를 통해 처리할 수 있다.&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>이번 장에서는 페이스북이나 구글 규모의 광고 클릭 이벤트 집계 시스템을 설계하는 프로세스를 다루어 보았다.&lt;/p>
&lt;ul>
&lt;li>데이터 모델 및 API 설계&lt;/li>
&lt;li>맵리듀스 데이터 처리 패러다임을 통해 광고 클릭 이벤트를 집계하는 방법&lt;/li>
&lt;li>메시지 큐, 집계 서비스, 데이터베이스의 규모 확장 방안&lt;/li>
&lt;li>핫스팟 문제를 해결하는 방안&lt;/li>
&lt;li>시스템의 지속적 모니터링&lt;/li>
&lt;li>데이터 조정을 통한 정확성 보증 방안&lt;/li>
&lt;li>결함 내성&lt;/li>
&lt;/ul>
&lt;p>광고 클릭 이벤트 집계 시스템은 전형적인 빅데이터 처리 시스템이다.&lt;/p>
&lt;p>아파치 카프카, 아파치 플링크, 아파치 스파크 같은 업계 표준 솔루션에 대한 사전 지식이나 경험이 있다면 이해하고 설계하기 쉬울 것이다.&lt;/p></description></item><item><title>5. 지표 모니터링 및 경보 시스템</title><link>https://codemario318.github.io/post/system-design-interview-2/5/</link><pubDate>Thu, 19 Sep 2024 14:13:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/5/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/5/cover.png" alt="Featured image of post 5. 지표 모니터링 및 경보 시스템" />&lt;p>이번 장에서는 &lt;strong>규모 확장이 용이한 지표 모니터링 및 경보 시스템&lt;/strong>의 설계안을 살펴본다.&lt;/p>
&lt;p>잘 서례된 지표 모니터링 및 경보 시스템은 &lt;strong>인프라의 상태를 선명하게 볼 수 있도록 하여 높은 가용성과 안정성을 달성하는 데 중추적 역할을 한다.&lt;/strong>&lt;/p>
&lt;p>대형 IT 업체에서 내부적으로 사용하는 것과 유사한 서비스를 설계해본다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>지표 모니터링 및 경소 비스템의 의미는 회사마다 다를 수 있으므로, 정확한 요구사항을 알아내는 것이 중요하다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>인프라 지표&lt;/strong>에 관심이 있다면 웹서버 &lt;strong>에러 로그&lt;/strong>나 &lt;strong>엑세스 로그&lt;/strong>에 초점을 맞춘 시스템을 만들면 곤란하다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Q. 시스템의 사용자는? 대형 IT 업체가 &lt;strong>내부에서 사용할 시스템&lt;/strong> 혹은 데이터독, 스플펑크 같은 &lt;strong>SasS&lt;/strong>?&lt;/p>
&lt;ul>
&lt;li>A. 회사 내부에서 사용할 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Q. 어떤 지표를 수집?&lt;/p>
&lt;ul>
&lt;li>A. 시스템 운영 지표(Operational system metrics) 수집. CPU 부하, 메모리 사용률, 디스크 사용량 같은 저수준 지표와 서버가 처리하는 초당 요청 수(Requests per second)나 웹 서버 프로세스 개수 같은 고차원적 개념 지표. 사업 지표(Business metrics)는 제외&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Q. 모니터링 할 인프라의 규모는?&lt;/p>
&lt;ul>
&lt;li>A. 일간 능동 사용자 수는 &lt;strong>1억 명&lt;/strong>, &lt;strong>1000개의 서버 풀&lt;/strong>이 있고, 풀마다 &lt;strong>100개의 서버 하드웨어&lt;/strong>를 유지하고 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Q. 지표 보관 기간&lt;/p>
&lt;ul>
&lt;li>A. 1년&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Q. 장기 보관 전영 저장소로 옮길 때 지표의 해상도(resolution)을 낮추어도 괜찮은가?&lt;/p>
&lt;ul>
&lt;li>A. 새로 수집한 데이터는 7일 보관, 7일 뒤에는 1분 단위로 30일, 그 뒤에는 1시간 단위로 변환하여 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Q. 경보 채널로 지원해야하는 것들&lt;/p>
&lt;ul>
&lt;li>A. 이메일, 전화, 페이저듀티(PagerDuty), 웹훅(Webhook, 즉 HTTP 프로토콜을 지원하는 엔드포인트) 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Q. 에러 로그나 엑세스 로그 등에 대한 수집 기능 제공?&lt;/p>
&lt;ul>
&lt;li>A. NO&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Q. 분산 시스템 추적(distributed system tracing) 기능 제공?&lt;/p>
&lt;ul>
&lt;li>A. NO&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-요구사항-및-가정">개략적 요구사항 및 가정&lt;/h3>
&lt;p>요구사항을 다시 정리하면 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>대규모 인프라를 모니터링 해야함
&lt;ul>
&lt;li>DAU 1억&lt;/li>
&lt;li>서버 풀 1,000개, 풀당 서버 수 100개, 서버당 100개의 운영 지표 수집한다면 모니터링 해야 하는 지표의 수는 &lt;strong>천만 개&lt;/strong> 수준&lt;/li>
&lt;li>데이터 보관 기간은 1년&lt;/li>
&lt;li>수집한 그대로 데이터를 보관하는 기간은 일주일, 그 뒤에는 1분 단위 데이터로 변호나 후에 30일 보관, 그 뒤에는 1시간 단위 데이터롤 변환한 뒤에 1년 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모니터링 해야하는 지표
&lt;ul>
&lt;li>CPU 사용률&lt;/li>
&lt;li>요청 수&lt;/li>
&lt;li>메모리 사용량&lt;/li>
&lt;li>메시지 큐 내의 메시지 수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>규모 확장성
&lt;ul>
&lt;li>시스템은 늘어나는 지표 수와 정보의 양에 맞게 확장될 수 있어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>낮은 응답 지연
&lt;ul>
&lt;li>대시보드(dashboard)와 경보(alert)을 신속하게 처리할 수 있도록, 질의(query)에 대한 낮은 응답 지연을 보장해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>안정성
&lt;ul>
&lt;li>높은 안정성을 제공하여 중요 정보를 놓치지 않도록 해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유연성
&lt;ul>
&lt;li>기술은 계속 변화하므로, 미래의 신기술을 쉽게 통합할 수 있도록 유연하게 변경 가능한 파이프라인을 이용해 구축한 시스템이어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>고려하지 않아도 괴는 요구사항은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>로그 모니터링(log monitoring)
&lt;ul>
&lt;li>엘라스틱서치, 로그스태시, 키바나 등이 로그 모니터링 용도록 널리 사용되는 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>분산 시스템 추적(distributed system tracing)
&lt;ul>
&lt;li>서비스에 대한 요청이 분산시스템 내부를 어떻게 흘러 다니는지 추적할 수 있도록 하는 시스템&lt;/li>
&lt;li>요청이 한 서비스에서 다른 서비스로 이동할 때마다 데이터를 수집&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>시스템 구축을 위한 &lt;strong>기본적 사항&lt;/strong>과 &lt;strong>데이터 모델&lt;/strong>, 그리고 &lt;strong>개략적 설계안&lt;/strong>을 논의한다.&lt;/p>
&lt;h3 id="기본적-사항">기본적 사항&lt;/h3>
&lt;p>지표 모니터링 및 경보 시스템은 일반적으로 다섯 가지 컴포넌트를 이용한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
mo[[지표 모니터링 및 경보 시스템]]
mo --> o[데이터 수집]
mo --> t[데이터 전송]
mo --> th[데이터 저장소]
mo --> f[경보]
mo --> ff[시각화]
&lt;/pre>
&lt;ul>
&lt;li>데이터 수집(data collection)
&lt;ul>
&lt;li>여러 출처로부터 지표 데이터를 수집&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 전송(data transmission)
&lt;ul>
&lt;li>지표 데이터를 지표 모니터링 시스템으로 전송&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 저장소(data storage)
&lt;ul>
&lt;li>전송되어 오는 데이터를 정리하고 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>경보(alerting)
&lt;ul>
&lt;li>데이터를 분석하고 이상 징후 감지하여 경보를 발생시킴&lt;/li>
&lt;li>다양한 통신 채널로 경보 발송 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>시각화(visualization)
&lt;ul>
&lt;li>데이터를 차트나 그래프 등으로 제공&lt;/li>
&lt;li>데이터를 시각적으로 황인하면 패턴, 추이, 문제점을 더 쉽게 파악할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>지표 데이터는 통상 &lt;strong>시계열(time series)&lt;/strong> 데이터 형태로 기록한다.&lt;/p>
&lt;ul>
&lt;li>값 집합에 타임스탬프가 붙은 형태&lt;/li>
&lt;li>각각에 고유한 이름이 붙고, 선택적으로 레이블(label)을 붙이기도 함&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>테이블로 표현한 데이터&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/5/img.png"
width="854"
height="221"
srcset="https://codemario318.github.io/post/system-design-interview-2/5/img_huc678e2a34ee556abcc1d0e6ca4c5382b_123819_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/5/img_huc678e2a34ee556abcc1d0e6ca4c5382b_123819_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="서버 부하 모니터링 사례"
class="gallery-image"
data-flex-grow="386"
data-flex-basis="927px"
>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>metric_name&lt;/th>
&lt;th>cpu.load&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>labels&lt;/td>
&lt;td>host:i631,env:prod&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>timestamp&lt;/td>
&lt;td>1613707265&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>value&lt;/td>
&lt;td>0.29&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>시계열 데이터&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">CPU.load host=webserver01,region=us-west 1613707265 50
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>이름&lt;/th>
&lt;th>자료형&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>지표 이름&lt;/td>
&lt;td>문자열&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>태그/레이블 집합&lt;/td>
&lt;td>&amp;lt;키:값&amp;gt; 쌍의 리스트&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>지표 값 및 그 타임스탬프의 배열&lt;/td>
&lt;td>&amp;lt;값, 타임스탬프&amp;gt; 쌍의 배열&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>데이터 접근 패턴&lt;/strong>&lt;/p>
&lt;p>y축에 붙은 레이블은 하나의 시계열 데이터를 나타내고(이름과 레이블을 통해 유일하게 식별되는 데이터), x축에 붙은 레이블은 시간이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/5/img_1.png"
width="760"
height="479"
srcset="https://codemario318.github.io/post/system-design-interview-2/5/img_1_hud1c090fe36757b28416ad0906c575c18_144927_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/5/img_1_hud1c090fe36757b28416ad0906c575c18_144927_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 접근 패턴"
class="gallery-image"
data-flex-grow="158"
data-flex-basis="380px"
>&lt;/p>
&lt;p>이 시스템에 대한 쓰기 부하는 시점을 막론하고 막대한 시계열 데이터가 기록될 수 있다.&lt;/p>
&lt;ul>
&lt;li>매일 천만 개 운영 지표 기록&lt;/li>
&lt;li>상당수의 지표는 발생 빈도도 높다.&lt;/li>
&lt;/ul>
&lt;p>반면 읽기 부하는 일시적으로 치솟핬다 사라지는(spiky)한 편이다.&lt;/p>
&lt;ul>
&lt;li>시각화와 경보 서비스는 데이터베이스에 대한 읽기 연산을 발생시키므로 그래프나 경보를 확인하는 패턴에 따라 일시적으로 증가하였다가 잠잠해진다.&lt;/li>
&lt;/ul>
&lt;p>다시 말하면 이 시스템은 &lt;strong>언제나 많은 양의 쓰기 연산 부하를 감당해야하지만, 읽기 연산의 부하는 감시 급등했다가 곧 사라지곤 한다는 것&lt;/strong>이다.&lt;/p>
&lt;h3 id="데이터-저장소-시스템">데이터 저장소 시스템&lt;/h3>
&lt;p>데이터 저장소 스스템은 설계안의 핵심이다.&lt;/p>
&lt;p>지표 모니터링 및 경보 시스템을 위한 저장소 시스템을 직접 설계하거나, MySQL 같은 범용 저장소 시스템을 사용하는 선택지 가운데 어떤 것도 추천하지 않는다.&lt;/p>
&lt;hr>
&lt;p>범용 데이터베이스는 이론적으로 시계열 데이터를 처리할 수 있지만, 설계안이 감당하려는 부하 규모에 맞추려면 전문가 수준의 튜닝이 필요하다.&lt;/p>
&lt;ul>
&lt;li>관계형 데이터베이스는 시계열 데이터를 대상으로 통상적으로 수행하는 연산에 최적화되어 있지 않다.
&lt;ul>
&lt;li>시계열 데이터의 지수 이동 평균(exponential moving average) 값을 지속적으로 갱신하는 것 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>태그/레이블에 대한 질의를 지원하려면 태그마다 인덱스를 지정해야한다.&lt;/li>
&lt;li>많은 양의 쓰기 연산이 저속적으로 발생하는 환경에서는 좋은 성능을 보이지 못한다.&lt;/li>
&lt;/ul>
&lt;p>설계안이 감당하려는 연산 규모에 맞추려면 데이터베이스 튜닝에 상당한 노력을 기울여야만 할 것이고, 설사 그렇게 하다러도 만족할 만한 성능이 나오지 않을 수 있다.&lt;/p>
&lt;hr>
&lt;p>카산드라, 빅테이블 처럼 시계열 데이터를 효율적으로 처리할 수 있다고 알려진 NoSQL 데이터베이스들이 나와있긴 하지만 여러 문제들이 있다.&lt;/p>
&lt;ul>
&lt;li>시계열 데이터를 효과적으로 저장하고 질의하기 위해서는 확장이 용이한 스키마를 설계해야하며, 그로인해 데이터베이스의 내부 구조에 대한 해박한 지식이 필요하다.&lt;/li>
&lt;li>시계열 데이터에 최적화된 저장소 시스템은 시장에 많고, 잘 최적화된 덕에 같은 양의 시계열 데이터를 더 적은 서버에 보관할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>시계열 데이터에 최적화된 저장소 시스템의 상당수는 시계열 데이터 분석에 적합하며 SQL보다 사용하기 쉬운 질의 인테페이스도 갖추고 있으며, 데이터 보관 기간을 설정하거나 데이터 집계(aggregation) 기능을 제공하는 제품도 나와있다.&lt;/p>
&lt;ul>
&lt;li>OpenTSDB, MetricsDB, Timestream, 등&lt;/li>
&lt;/ul>
&lt;p>시장에서 가장 인기있는 시계열 데이터베이스는 InfluxDB, Prometheus 이다.&lt;/p>
&lt;ul>
&lt;li>다량의 시계열 데이터를 저장하고 빠른 실시간 분석을 지원한다.&lt;/li>
&lt;li>메모리 캐시와 디스크 저장소를 함께 사용한다.
&lt;ul>
&lt;li>영속성 요건과 높은 성능 요구사항도 잘 만족한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>좋은 시계열 데이터베이스는 막대한 양의 시계열 데이터를 레이블(태그) 기준으로 집계하고 분석하는 기능을 제공한다.&lt;/p>
&lt;ul>
&lt;li>InfluxDB는 레이블 기반 신속한 데이터 질의를 위해 레이블별로 인덱스를 구축하며, 레이블을 이용할 때 데이터베이스 과부하를 피하는 지침도 제공한다.&lt;/li>
&lt;li>각 레이블이 가질 수 있는 값의 가짓수(cardinality)가 낮아야한다.&lt;/li>
&lt;li>데이터 시각화에 특히 중요하며, 범용 데이터베이스로 구축하기 매우 까다롭다.&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;pre class="mermaid" style="text-align: center;">flowchart
a[지표 출처] --> b[지표 수집기] --> c[(시계열 데이터 베이스)]
d[질의 시스템] --> c
e[경보 시스템] -.질의 전송.-> d
f[시각화 시스템] -.질의 전송.-> d
e --> g[이메일]
e --> h[단문 메시지]
e --> i[페이저듀티]
e --> j[HTTPS 서비스 엔드포인트]
&lt;/pre>
&lt;ul>
&lt;li>지표 출처(metrics source)
&lt;ul>
&lt;li>지표 데이터가 만들어지는 곳&lt;/li>
&lt;li>애플리케이션 서버, SQL 데이터베이스, 메시지 큐 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지표 수집기(metrics collector)
&lt;ul>
&lt;li>지표 데이터를 수집하고 시계열 데이터에 기록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>시계열 데이터베이스(time-series database)
&lt;ul>
&lt;li>지표 데이터를 시계열 데이터 형태로 보관&lt;/li>
&lt;li>다량의 시계열 데이터를 분석하고 요약하는 데 적합하도록 설계된 질의 인터페이스 제공&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>질의 서비스(query service)
&lt;ul>
&lt;li>시계열 데이터베이스에 보관된 데이터를 질의하고 가져오는 과정을 돕는 서비스&lt;/li>
&lt;li>좋은 시계열 데이터베이스를 골랐다면, 이 서비스는 많은 일을 하지 않아도됨(질의 인터페이스로 대체할 수도 있음)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>경보 시스템(alerting system)
&lt;ul>
&lt;li>경보를 받아야 하는 다양한 대상으로 경보 알림을 전송하는 역할 담당&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>시각화 시스템(visualization system)
&lt;ul>
&lt;li>지표를 다양한 형태의 그래프/차트로 시각화 하는 기능 제공&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>몇 가지 핵심적 컴포넌트나 처리 흐름에 대한 상세 설계안을 제시할 수 있어야 한다.&lt;/p>
&lt;h3 id="지표-수집">지표 수집&lt;/h3>
&lt;p>카운터(counter)나 CPU 사용량 같은 지표를 수집할 때는 때로 데이터가 소실되어도 아주 심각한 문제는 아니다.&lt;/p>
&lt;p>지표를 보내는 클라이언트는 성공적으로 데이터가 전송되었는지 신경 쓰지 않아도 상관 없다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
subgraph 지표 수집
a[지표 출처] --> b[지표 수집]
end
b --> c[(시계열 데이터베이스)]
&lt;/pre>
&lt;h4 id="풀-vs-푸시-모델">풀 vs 푸시 모델&lt;/h4>
&lt;p>지표 데이터를 수집 방법에는 두 가지 모델이 있다. 딱히 정답은 없다.&lt;/p>
&lt;p>&lt;strong>풀 모델&lt;/strong>&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
e[지표 수집기]
subgraph 지표 출처
a[웹 서버]
b[DB 클러스터]
c[큐 클러스터]
d[캐시 클러스터]
end
subgraph SDS
f[etcd]
g[주키퍼]
end
e --> SDS
e -."지표 수집 (pull)".-> a
e -."지표 수집 (pull)".-> b
e -."지표 수집 (pull)".-> c
e -."지표 수집 (pull)".-> d
&lt;/pre>
&lt;p>HTTP 기반 풀 모델을 이용하는 지표 수집 흐름으로, 실행 중인 애플리케이션에서 주기적으로 지표 데이터를 가져오는 지표 수집가가 이 흐름의 중심이다.&lt;/p>
&lt;p>이러한 접근법에서는 지표 수집기는 데이터를 가져올 서비스 목록을 알아야한다.&lt;/p>
&lt;ul>
&lt;li>지표 수집기 서버 안에 모든 서비스 엔드포인트의 DNS/IP 정보를 담은 파일을 두면 가장 간단하다.
&lt;ul>
&lt;li>서버가 수시로 추가/삭제되는 대규모 운영 환경에서는 적용하기 어렵다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>etcd나 아파치 주키퍼 같은 서비스 탐색(Service Discovery) 기술을 활용하면 이 문제는 해결할 수 있다.&lt;/p>
&lt;ul>
&lt;li>각 서비스는 자신의 가용성 관련 정보를 서비스 탐색 서비스(SDS)에 기록하고, SDS는 서비스 엔드포인터 목록에 변화가 생길 때마다 지표 수집기에 통보한다.&lt;/li>
&lt;li>SDS에는 언제 어디서 지표를 수집하면 되는지에 관한 설정 정보를 기록한다.&lt;/li>
&lt;/ul>
&lt;pre class="mermaid" style="text-align: center;">flowchart
metricsCollector[지표 수집기]
subgraph SDS
etcd[etcd]
zookeeper[주키퍼]
end
metricsCollector -- "1 > 지표 수집 대상 목록 확보" --> SDS
webServer[웹 서버]
metricsCollector -- "2 > /metrics 엔드포인트 제공" --> webServer
&lt;/pre>
&lt;ol>
&lt;li>지표 수집기는 SDS에서 서비스 엔드포인트 설정 메타데이터 목록을 가져온다.
&lt;ul>
&lt;li>지표 수집 주기(pulling interval), IP 주소, 타임아웃(timeout), 재시도 인자(retry parameter) 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지표 수집기는 사전 합의된 HTTP 엔드포인트(&lt;code>/metrics&lt;/code>) 지표 데이터를 가져온다.
&lt;ul>
&lt;li>엔드포인트를 수집기에 노출하기 위해, 통상 서비스에 특정 클라이언트 라이브러리를 추가한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지표 수집기는 서비스 엔드포인트 목록의 변화를 통지 받기 위한 변경 이벤트 알림(change event notification) 콜백을 서비스 탐색 컴포넌트에 등록할 수 있다.
&lt;ul>
&lt;li>주기적으로 서비스 탐색 컴포넌트에서 엔드포인트 목록을 다시 가져와도 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>수천 대 서버가 만들어내는 지표 데이터를 수집하려면 지표 수집기 서버 한대로는 부족하기 때문에 &lt;strong>지표 수집기 서버 풀&lt;/strong>을 만들어야 설계안에서 다루는 지표 데이터 규모를 감당할 수 있다.&lt;/p>
&lt;p>지표 수집기 서버를 여러 대 둘 때 &lt;strong>여러 서버가 같은 출처에서 데이터를 중복해서 가져올 가능성&lt;/strong>이 있으므로, &lt;strong>안정 해시 링&lt;/strong>(consistent hash ring)을 통해 지표 수집 서버간에 중재 매커니즘을 만든다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/5/img_2.png"
width="746"
height="516"
srcset="https://codemario318.github.io/post/system-design-interview-2/5/img_2_hu19df0509573056ae55682cc2dd294aef_83940_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/5/img_2_hu19df0509573056ae55682cc2dd294aef_83940_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="안정 해시"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="346px"
>&lt;/p>
&lt;p>해시 링 구간마다 해당 구간에 속한 서버로부터 생산되는 지표의 수집을 담당하는 수집기 서버를 지정하여 특정 서버의 지표 데이터가 항상 하나의 수집 서버가 처리함을 보장할 수 있다.&lt;/p>
&lt;p>&lt;strong>푸시 모델&lt;/strong>&lt;/p>
&lt;p>푸시 모델은 &lt;strong>지표 출처에 해당하는 서버가 직접 지표를 수집기에 전송&lt;/strong>하는 모델이다.&lt;/p>
&lt;ul>
&lt;li>웹서버, 데이터베이스 서버 등&lt;/li>
&lt;/ul>
&lt;p>푸시 모델의 경우, 모니터링 대상 서버에 통상 &lt;strong>수집 에이전트&lt;/strong>(Collection agent)라고 부르는 소프트웨어를 설치한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>수집 에이전트&lt;/strong>&lt;br>
해당 장비에서 실행되는 서비스가 생산하는 지표 데이터를 받아 모은 후 주기적으로 수집기에 전달한다.&lt;/p>
&lt;/blockquote>
&lt;p>간단한 카운터 지표는 수집기에 보내기 전 에이전트가 직접 데이터 집계 등의 작업을 처리할 수도 있다.&lt;/p>
&lt;p>데이터 집계(aggregation)는 &lt;strong>수집기에 보내는 데이터의 양을 줄이는 효과적인 방법&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>데이터 전송 트래픽의 양이 막대하여 수집가가 일시적으로 전송되는 데이터를 처리하지 못하게 되어 오류를 반환하면, 에이전트는 내부의 소규모 버퍼에 데이터를 일시적으로 보관한 다음 나중에 재전송 할 수 있다.&lt;/li>
&lt;li>에이전트가 위치한 서버 클러스터가 자동 규모 확장이 가능하도록 설정되어 있다면 서버가 동적으로 추가되거나 삭제되는 과정에서 해당 데이터는 소실될 수도 있다.&lt;/li>
&lt;/ul>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
subgraph 지표 출처
webServer[웹 서버]
subgraph agents
direction TB
metric1[지표 1] ~~~
metric2[지표 2] ~~~
metric3[지표 3]
end
webServer --> agents
end
agents --메시지 전송--> lb[로드벨런서]
lb --> metricsCollectorCluster[[지표 수집기 서버 클러스터]]
&lt;/pre>
&lt;p>푸시 모델을 채택한 지표 수집기가 밀려드는 지표 데이터를 제때 처리하지 못하는 일을 방지하려면, 지표 수집기 클러스터 자체도 자동 규모 확장이 가능하도록 구성하고 그 앞에 로드밸런서를 두는 것이 바람직하다.&lt;/p>
&lt;p>&lt;strong>풀 모델 vs 푸시 모델 장단점 비교&lt;/strong>&lt;/p>
&lt;p>상황에 적합한 모델이 무엇인지는 정답이 없으며, 실제로 이 두 모델은 구분 없이 널리 사용되고 있다.&lt;/p>
&lt;ul>
&lt;li>풀 모델: 프로메테우스&lt;/li>
&lt;li>푸시 모델: 아마존 클라우드 와치(CloudWatch), 그래파이트(Graphite)&lt;/li>
&lt;/ul>
&lt;p>두 모델의 장단점을 비교하여 적절히 이용한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>풀 모델&lt;/th>
&lt;th>푸시 모델&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>손쉬운 디버깅&lt;/td>
&lt;td>애플리케이션 서버에 &lt;code>/metrics&lt;/code> 엔드포인트를 두도록 강제하므로 필요하다면 언제든 지표 데이터를 볼 수 있다.&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>상태 진단(health check)&lt;/td>
&lt;td>애플리케이션 서버가 풀 요청에 응답하지 않으면 바로 해당 서버에 장애가 발생한 것으로 진단할 수 있다(더 쉽다)&lt;/td>
&lt;td>지표 수집기가 지표를 받지 못하면 네트워크 장애가 원인인지 서버 장애가 원인인지 알기 어렵다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>생존 기간이 짧은 프로세스&lt;/td>
&lt;td>&lt;/td>
&lt;td>생명 주기가 짧은 일괄 작업 프로세스의 경우 수집기가 미처 지표를 끌어가기도 전에 종료될 수 있다. 그런 점에서 푸시 모델이 조금더 낫다(풀 모델도 푸시 게이트웨이를 도입하면 해당 문제점을 해결할 수 있다&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>방화벽 등의 복잡한 네트워크 구성&lt;/td>
&lt;td>수집기 서버가 지표 데이터를 제대로 끌어가려면 모든 &lt;code>/metrics&lt;/code> 엔드포인트가 접근 가능하도록 구성되어야한다. 데이터센터를 여러 개 사용하는 경우에는 문제가 될 수 있으므로 네트워크 인프라를 세심히 설계해야한다.&lt;/td>
&lt;td>지표 수집기가 로드밸런서 및 자동 규모 확장 클러스터 형태로 구성되었다면 어디서 오는 지표라도 수집 가능하다.(더 낫다)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>성능&lt;/td>
&lt;td>풀 모델은 일반적으로 TCP를 사용한다.&lt;/td>
&lt;td>푸시 모델은 보통 UDP를 사용하여 지표 전송 지연이 더 낮다.(TCP보다 오버헤드가 낮으므로)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 신빙성&lt;/td>
&lt;td>지표 데이터를 가져올 애플리케이션 서버의 목록이 이미 정의된 상태이므로 해당 서버에서 수집한 데이터는 믿을 수 있다.&lt;/td>
&lt;td>아무나 지표 수집기에 데이터를 보낼 수 있어, 지표 전송을 허용할 서버의 목록을 수집기 측에 유지하거나 인증을 강제하면 문제를 해결할 수 있다.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>풀 모델과 푸시 모델 가운데 무엇이 나은지는 논쟁적인 주제이고 정답도 없다.&lt;/p>
&lt;p>서버리스(serverless) 기술이 각광 받음에 따라 많은 조직이 두 모델을 모두 지원하고 있다.&lt;/p>
&lt;ul>
&lt;li>지표 수집 에이전트를 설치할 서버가 마땅히 존재하지 않을 수도 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="지표-전송-파이프라인의-규모-확장">지표 전송 파이프라인의 규모 확장&lt;/h3>
&lt;p>지표 수집기와 시계열 데이터베이스를 좀 더 자세히 살펴보자.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
metricsOrigin[지표 출처] --> metricsCollector
subgraph " "
metricsCollector[지표 수집기] -->
timeseriesDB[(시계열 데이터베이스)]
end
querySystem[쿼리 시스템] --> timeseriesDB
&lt;/pre>
&lt;p>풀 모델과 푸시 모델 가운데 무엇을 채택할지 여부와 관계없이, &lt;strong>지표 수집기는 서버 클러스터 형태이며 엄청난 양의 데이터를 받아 처리&lt;/strong>해야한다.&lt;/p>
&lt;ul>
&lt;li>이 클러스터는 자동으로 규모 확장이 가능하도록 설정하여 언제나 데이터 처리에 충분한 수집기 서버가 존재하도록 해야한다.&lt;/li>
&lt;/ul>
&lt;p>하지만 시계열 데이터베이스에 장애가 생기면 데이터 손실이 발생할 가능성이 있는데, 큐를 두면 그런 문제들을 해소할 수 있다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
metricsOrigin[지표 출처] --> kafka
subgraph " "
kafka[[카프카]] -->
metricsCollector[지표 수집기] -->
timeseriesDB[(시계열 데이터베이스)]
end
querySystem[쿼리 시스템] --> timeseriesDB
&lt;/pre>
&lt;p>자료 수집기는 지표 데이터를 카프카와 같은 큐 시스템에 전송하면 &lt;strong>스트림 처리 서비스가 해당 데이터를 받아 시계열 데이터베이스에 저장&lt;/strong>한다.(아파치 스톰이나 플링크, 스파크 같은 소비자)&lt;/p>
&lt;p>이러한 구조는 몇 가지 장점이 있다.&lt;/p>
&lt;ul>
&lt;li>카프카는 고도로 안정적이고 규모 확장성이 뛰어난 분산 메시지 플랫폼이다.&lt;/li>
&lt;li>데이터 수집 컴포넌트와 처리 컴포넌트 사이의 결합도를 낮춘다.&lt;/li>
&lt;li>데이터베이스에 장애가 생겨도 카프카에 보관해 두면 되므로 데이터가 소실되지 않는다.&lt;/li>
&lt;/ul>
&lt;h4 id="카프카를-이용한-규모-확장">카프카를 이용한 규모 확장&lt;/h4>
&lt;p>카프카에 내장된 파티션 매커니즘을 활용하여 시스템의 규모를 다양한 방법으로 확장할 수 있다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart
metricsCollector[지표 수집기]
subgraph Kafka
partition0["파티션 0 (지표 1)"]
partition1["파티션 1 (지표 2)"]
partition2["파티션 2 (지표 3)"]
end
&lt;/pre>
&lt;ul>
&lt;li>대역폭 요구사항에 따라 파티션의 수를 결정한다.&lt;/li>
&lt;li>지표 이름에 따라 어떤 지표를 어느 파티션에 배치할 지 결정하면 소비자는 지표 이름에 따라 데이터를 집계할 수 있다.&lt;/li>
&lt;li>테그/레이블에 따라 지표 데이터를 더욱 세분화한 파티션으로 나눈다.&lt;/li>
&lt;li>중요 지표가 먼저 처리될 수 있도록 지표를 분류하고 우선순위를 지정한다.&lt;/li>
&lt;/ul>
&lt;h4 id="카프카의-대안">카프카의 대안&lt;/h4>
&lt;p>상용 구묘의 카프카 시스템 구축은 쉽지 않기 때문에 반대할 수도 있다.&lt;/p>
&lt;p>시장에는 큐 없이도 대규모 데이터 처리가 가능한 모니터링 시스템이 있다.&lt;/p>
&lt;ul>
&lt;li>페이스북의 메모리 기반 시계열 데이터베이스 시스템 &lt;strong>고릴라(Gorilla)&lt;/strong> 등&lt;/li>
&lt;/ul>
&lt;p>고릴라는 일부에 네트워크 장애가 발생해도 높은 수준의 쓰기 연산 가용성을 유지하는데, 이런 시스템을 쓴다면 카프카 같은 메시지 큐가 없어도 같은 수준의 안정성을 제공할 수 있다.&lt;/p>
&lt;h3 id="데이터-집계-지점">데이터 집계 지점&lt;/h3>
&lt;p>지표 집계는 다양한 지점에서 실행 가능하다.&lt;/p>
&lt;ul>
&lt;li>수집 에이전트(클라이언트 집계 방안)&lt;/li>
&lt;li>데이터 수집(ingestion) 파이프라인(저장소 기록 전에 집계 하는 방안)&lt;/li>
&lt;li>질의 시점(저장소 기록 후에 집계)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>수집 에이전트가 집계하는 방안&lt;/strong>&lt;/p>
&lt;p>클라이언트에 설치된 수집 에이전트는 복잡한 집계 로직은 지원하기 어렵다.&lt;/p>
&lt;ul>
&lt;li>어떤 카운터 값을 분 단위로 집계하여 지표 수집기에 보내는 정도는 가능&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>데이터 수집 파이프라인에서 집계하는 방안&lt;/strong>&lt;/p>
&lt;p>보통 플링크 같은 스트림 프로세싱 엔진이 필요하다.&lt;/p>
&lt;p>데이터베이스에는 계산 결과만 기록하므로, 실제로 기록되는 양은 업청나게 줄어든다.&lt;/p>
&lt;ul>
&lt;li>늦게 도착하는 지표 데이터의 처리가 어렵다.&lt;/li>
&lt;li>원본 데이터를 보관하지 않기 때문에 정밀도나 유연성 측변에서 손해를 보게된다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>질의 시에 집계하는 방안&lt;/strong>&lt;/p>
&lt;p>데이터를 날것 그대로 보관한 다음 질의할 때 필요한 시간 구간에 맞게 집계한다.&lt;/p>
&lt;ul>
&lt;li>데이터 손실 문제는 없으나 질의를 처리하는 순간에 전체 데이터세트를 대상으로 집게 결과를 계산해야 하므로 속도는 느릴 것이다.&lt;/li>
&lt;/ul>
&lt;h3 id="질의-서비스">질의 서비스&lt;/h3>
&lt;p>질의 서버 클러스터 형태로 구현되며, 시각화 또는 경보 시스템에서 접수된 요청을 시계열 데이터베이스를 통해 처리하는 역할을 담당한다.&lt;/p>
&lt;p>질의 처리 전담 서비스를 두면 &lt;strong>클라이언트(시각화 또는 경보 시스템)&lt;/strong> 와 시계열 데이터베이스 사이의 결합도를 낮출 수 있다.&lt;/p>
&lt;ul>
&lt;li>시계열 데이터베이스를 자유롭게 다른 제품으로 교체할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="캐시-계층">캐시 계층&lt;/h4>
&lt;pre class="mermaid" style="text-align: center;">flowchart
timeseriesDB[시계열 데이터 베이스]
subgraph " "
queryService[질의 서비스] -->
cache[캐시]
end
queryService --> timeseriesDB
alertSystem[경보 시스템] --> queryService
monitoringSystem[시각화 시스템] --> queryService
&lt;/pre>
&lt;p>질의 결과를 저장할 캐시 서버를 도입하면 시계열 데이터베이스에 대한 질의 부하를 낮추고 질의 서비스의 성능을 높일 수 있다.&lt;/p>
&lt;h4 id="질의-서비스를-두면-곤란한-경우">질의 서비스를 두면 곤란한 경우&lt;/h4>
&lt;p>대부분 상용 시각화 및 경보 시스템은 &lt;strong>시장에서 널리 사용되는 시계열 데이터베이스와의 연동을 처리하는 강력한 플러그인을 이미 갖추고 있는 경우가 많다.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>별도 캐시를 도입할 필요가 없는 시계열 데이터베이스를 고려할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="시계열-데이터베이스-질의어">시계열 데이터베이스 질의어&lt;/h4>
&lt;p>프로메테우스나 InfluxDB 같은 널리 사용되는 지표 모니터링 시스템들은 시계열 데이터가 SQL로는 질의하기가 까다롭다는 특성 때문에 &lt;strong>SQL이 아닌 독자 질의어를 제공&lt;/strong>한다.&lt;/p>
&lt;h3 id="저장소-계층">저장소 계층&lt;/h3>
&lt;h4 id="시계열-데이터베이스는-신중하게-선택할-것">시계열 데이터베이스는 신중하게 선택할 것&lt;/h4>
&lt;p>페이스북에서 내놓은 연구 논문에 다르면 &lt;strong>운영 데이터 저장소에 대한 질의의 80%는 지난 26시간 내에 수집된 데이터를 대상으로 한다.&lt;/strong>&lt;/p>
&lt;p>이 사실을 잘 활용하는 시계열 데이터베이스를 고르면 성능 측면에서 큰 이득을 볼 수 있다.&lt;/p>
&lt;h4 id="저장-용량-최적화">저장 용량 최적화&lt;/h4>
&lt;p>지표 모니터링 시스템에 저장할 데이터 야은 막대하므로, 이를 위한 몇 가지 전략이 있다.&lt;/p>
&lt;p>&lt;strong>데이터 인코딩 및 압축&lt;/strong>&lt;/p>
&lt;p>데이터를 인고딩하고 압축하면 크기를 상당히 줄일 수 있으며, 좋은 시계열 데이터베이스는 대부분 이 기능을 내장하고 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/5/img_3.png"
width="781"
height="258"
srcset="https://codemario318.github.io/post/system-design-interview-2/5/img_3_hu56036a484ad679241b4af54eee2f0b6a_59647_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/5/img_3_hu56036a484ad679241b4af54eee2f0b6a_59647_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 인코딩 - 이중-델타 인코딩"
class="gallery-image"
data-flex-grow="302"
data-flex-basis="726px"
>&lt;/p>
&lt;p>시계열 데이터는 특정 시간대에 연속적으로 수집된다는 특징을 가진다.&lt;/p>
&lt;p>따라서 1610087371과 1610087381은 10초 만큼만 다른 값이므로 값의 차이를 저장한다면 용량을 크게 아낄 수 있다.&lt;/p>
&lt;ul>
&lt;li>데이터를 완전한 형태가 아닌 기준 값과 차이를 저장한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>다운 샘플링&lt;/strong>&lt;/p>
&lt;p>데이터의 해상도를 낮춰 저장소 요구량을 줄이는 기법이다.&lt;/p>
&lt;p>요구된 데이터 보관 기간은 1년이므로, 낡은 데이터는 해상도를 줄일 수 있다.&lt;/p>
&lt;p>&lt;strong>냉동 저장소&lt;/strong>&lt;/p>
&lt;p>냉동 저장소(cold storage)는 잘 사용되지 않는 비활성 상태 데이터를 보관하는 곳으로 일반 저장소에 비해 비용이 훨씬 싸다.&lt;/p>
&lt;h3 id="경보-시스템">경보 시스템&lt;/h3>
&lt;p>대체적으로 시각화와 경보 시스템은 직접 만들기보다 사용품을 가져다 쓰는 편이 훨씬 낫지만 경보 시스템의 구성 방법을 살펴보면 좋다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/5/img_4.png"
width="852"
height="291"
srcset="https://codemario318.github.io/post/system-design-interview-2/5/img_4_hu0d21b347337e0c4ab1ec37425a58c14b_102706_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/5/img_4_hu0d21b347337e0c4ab1ec37425a58c14b_102706_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="경보 시스템"
class="gallery-image"
data-flex-grow="292"
data-flex-basis="702px"
>&lt;/p>
&lt;ol>
&lt;li>설정 파일을 가져와 캐시 서버에 보관한다.&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>경보 규칙은 디스크에 파일 상태로 보관하며, YAML이 널리 사용된다.&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>경보 관리자(alert manager)는 정보 설정 내역을 캐시에서 가져온다.&lt;/li>
&lt;li>설정된 규칙에 근거하여 경보 관리자는 지정된 시간마다 질의 서비스를 호출하고, 질의 결과가 설정된 임계값을 위반하면 경보 이벤트를 생성한다.
&lt;ul>
&lt;li>경보 필터링 , 병합, 중복 제거
&lt;ul>
&lt;li>짧은 시간 동안 같은 인스턴스에서 발생한 경보를 병합한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>접근 제어
&lt;ul>
&lt;li>특정한 경보 관리 작업은 방드시 특정한 개인만이 수행할 수 있도록 제한해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>재시도
&lt;ul>
&lt;li>경보 상태를 확인하고 알림이 최소 한번은 전달됨을 보장해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>경보 저장소는 카산드라 같은 형태의 키-값 저장소로, 모든 경보의 상태(비활성, 응답 대기, 경보 발령, 문제 해결 등)가 보관되어, 알람이 적어도 한 번 이상 전달되도록 보장하는데 쓰인다.&lt;/li>
&lt;li>경보 이벤트를 카프카에 전달한다.&lt;/li>
&lt;li>경보 소비자는 카프카에서 경보 이벤트를 읽는다.&lt;/li>
&lt;li>경보 소비자는 카프카에서 읽은 경보 이벤트를 처리하여 이메일, 단문 메시지, 페이저듀티, HTTP 서비스 엔드포인트 드으이 다양한 채널로 알림을 전송한다.&lt;/li>
&lt;/ol>
&lt;h4 id="만들-것인가-구매할-것인가">만들 것인가 구매할 것인가&lt;/h4>
&lt;p>기업이 필요로하는 규모를 바로 지원 가능한 경보 시스템은 시장에 많으며, 대부분 유명 시계열 데이터베이스와 통합되어 있고, 다양한 알림 채널을 지원한다.&lt;/p>
&lt;p>따라서 실무에서는 경보 시스템을 밑바닥부터 구현하겠다는 아이디어는 수용되기 어렵다.&lt;/p>
&lt;h3 id="시각화-시스템">시각화 시스템&lt;/h3>
&lt;p>시각화 시스템은 데이터 계층 위에 만들어진다.&lt;/p>
&lt;p>지표 대시보드에는 다양한 시간 범위로 표시하고, 경보 대시보드에는 다양한 경보의 상태를 표시한다.&lt;/p>
&lt;p>품질 좋은 시각화 시스템은 구현하기 어려우므로, 상용품을 구입해서 쓰자고 주장하는 것이 바람직하다.&lt;/p>
&lt;ul>
&lt;li>그라파나 등&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>지표 모니터링 경보 시스템에 대한 설계안을 살펴보았다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/5/img_5.png"
width="835"
height="362"
srcset="https://codemario318.github.io/post/system-design-interview-2/5/img_5_hu7475e8ccf38dbe0aaf1a5ea62e5bf8df_98216_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/5/img_5_hu7475e8ccf38dbe0aaf1a5ea62e5bf8df_98216_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="최종 설계안"
class="gallery-image"
data-flex-grow="230"
data-flex-basis="553px"
>&lt;/p>
&lt;ul>
&lt;li>지표 데이터 수집 모델: 풀 모델 VS 푸시 모델&lt;/li>
&lt;li>카프카를 활용한 규모 확장 방안&lt;/li>
&lt;li>최적 시계열 데이터베이스의 선정&lt;/li>
&lt;li>다운샘플링을 통한 데이터 크기 절감&lt;/li>
&lt;li>경보/시각화 시스템: 구현할 것인가 구입할 것인가&lt;/li>
&lt;/ul></description></item><item><title>4. 분산 메시지 큐</title><link>https://codemario318.github.io/post/system-design-interview-2/4/</link><pubDate>Sat, 07 Sep 2024 15:12:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/4/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/cover.png" alt="Featured image of post 4. 분산 메시지 큐" />&lt;p>현대적 소프트웨어 아키텍처를 따르는 시스템은 &lt;strong>잘 정의된 인테피이스를 경계로 나뉜 작고 독립적인 블록들로 구성&lt;/strong>된다.&lt;/p>
&lt;p>메시지 큐는 이 &lt;strong>블록 사이의 통신과 조율을 담당&lt;/strong>하며, 아래와 같은 이득을 얻을 수 있다.&lt;/p>
&lt;ul>
&lt;li>결합도 완화(decoupling)
&lt;ul>
&lt;li>메시지 큐를 사용하면 컴포넌트 사이의 강한 결합이 사라지므로 각각을 독립적으로 갱신할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규모 확장성 개선
&lt;ul>
&lt;li>메시지 큐에 데이터를 생산하는 생산자와 큐에서 메시지를 소비하는 소비자 시스템 규모를 트래픽 부하에 맞게 독립적으로 늘릴 수 있다.&lt;/li>
&lt;li>ex) 트래픽이 많이 몰리는 시간에는 더 많은 소비자를 추가하여 처리 용량을 늘릴 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성 개선
&lt;ul>
&lt;li>시스템의 특정 컴포넌트에 장애가 발생해도 다른 컴포넌트는 큐와 계속 상호작용을 이어갈 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>성능 개선
&lt;ul>
&lt;li>비동기 통신이 쉽게 가능하다.&lt;/li>
&lt;li>생산자는 응답을 기다리지 않고도 메시지를 보낼 수 있고, 소비자는 읽을 메시지가 있을 때만 해당 메시지를 소비한다.
&lt;ul>
&lt;li>서로 기다릴 필요가 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>메시지 큐 VS 이벤트 스트리밍 플랫폼&lt;/strong>&lt;/p>
&lt;p>엄밀하게 따지면 카프카나 펄사는 메시지 큐가 아니라 이벤트 스트리밍 플랫폼이다.&lt;/p>
&lt;p>하지만 메시키 큐와 이벤트 스트리밍 플랫폼 사이의 차이는 지원하는 기능이 서로 수렴하면서 점차 희미해지고 있다.&lt;/p>
&lt;ul>
&lt;li>전형적인 메시지 큐 RabbitMQ는 옵션으로 제공되는 스트리밍 기능을 추가하면 메시지를 반복적으로 소비할 수 있는 동시에 장기 보관도 가능하다.
&lt;ul>
&lt;li>그 기능은 이벤트 스트리밍 플랫폼처럼 데이터 추가만 가능한 로그를 통해 구현되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이번 장에서는 &lt;strong>데이터 장기 보관(long data retention)&lt;/strong>, &lt;strong>메시지 반복 소비(repeated consumption of messages)&lt;/strong> 등의 &lt;strong>부가 기능을 갖춘 분산 메시지 큐를 설계&lt;/strong>한다.&lt;/p>
&lt;p>통상적으로 언급한 부가 기능은 이벤트 스트리밍 플랫폼에서만 이용 가능하며 좀 더 까다롭다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>메시지 큐는 생산자는 메시지를 큐에 보내고, 소비자는 큐에서 메시지를 꺼낼 수 있으면 된다.&lt;/p>
&lt;p>하지만 이 기본 기능 외에도 성능, 메시지 전달 방식, 데이터 보관 기간 등 고려할 사항은 다양하다.&lt;/p>
&lt;ul>
&lt;li>Q. 메시지의 형태와 평균 크기는?
&lt;ul>
&lt;li>A. 텍스트 형태 메시지만 지원, 크기는 수 킬로바이트 수준&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 메시지는 반복적으로 소비될 수 있어야 하는가?
&lt;ul>
&lt;li>A. Y, 하나의 메시지를 여러 소비자가 수신하는 것이 가능(부가 기능)
&lt;ul>
&lt;li>전통적인 분산 메시지 큐는 한 소비자라도 받아간 메시지는 지워버리므로 반복해서 전달할 수 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 메시지 큐에 전달된 순서대로 소비되어야 하는가?
&lt;ul>
&lt;li>A. Y
&lt;ul>
&lt;li>전통적인 메시지 큐는 보통 소비 순서는 보증하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 데이터의 지속성 보장?
&lt;ul>
&lt;li>A. 2주
&lt;ul>
&lt;li>전통적인 메시지 큐는 메시지의 지속성 보관을 보증하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 지원해야 하는 생산자와 소비자 수
&lt;ul>
&lt;li>A. 많을 수록 좋음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 어떤 메시지 전달 방식을 지원?
&lt;ul>
&lt;li>A. &lt;strong>최소 한번&lt;/strong> 방식은 반드시 지원, 이상적으로는 모든 전송방식 지원 및 선택 가능
&lt;ul>
&lt;li>최대 한 번, 최소 한 번, 정확히 한 번&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 목표 대역폭과 단대단 지연 시간은?
&lt;ul>
&lt;li>A. 로그 수집 등을 위해 사용할 수도 있어야 하므로 높은 수준의 대역폭을 제공해야함, 일반적인 메시지 큐가 지원하는 정통적 방법도 지원해야 하므로 낮은 전송 지연도 필수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="기능-요구사항">기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>생산자는 메시지 큐에 메시지를 보낼 수 있어야 함&lt;/li>
&lt;li>소비자는 메시지 큐를 통해 메시지를 수신할 수 있어야 함.&lt;/li>
&lt;li>메시지는 반복적으로 수신할 수도 있어야 하고, 단 한 번만 수신하도록 설정될 수도 있어야 함.&lt;/li>
&lt;li>오래된 이력 데이터는 삭제될 수 있음&lt;/li>
&lt;li>메시지 크기는 킬로바이트 수준&lt;/li>
&lt;li>메시지가 생산된 순서대로 소비자에게 전달할 수 있어야 함&lt;/li>
&lt;li>메시지 전달 방식은 최소 한 번, 최대 한 번, 정확히 한 번 가운데 설정할 수 있어야 함.&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>높은 대역폭과 낮은 전송 지연 가운데 하나를 설정으로 선택 가능하게 하는 기능&lt;/li>
&lt;li>규모 확장성
&lt;ul>
&lt;li>시스템 특성상 분산 시스템일 수 밖에 없으므로 메시지 양이 급증해도 처리 가능해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지속성 및 내구성(persistency and durability)
&lt;ul>
&lt;li>데이터는 디스크에 지속적으로 보관되어야 하며 여러 노드에 복제되어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="전통적인-메시지-큐와-다른점">전통적인 메시지 큐와 다른점&lt;/h3>
&lt;p>RabbitMQ와 같은 전통적인 메시지 큐는 이벤트 스트리밍 플랫폼처럼 메시지 보관문제를 중요하게 다루지 않고, 메시지 소비 순서도 보존하지 않는다(생산 순서와 소비 순서가 다를 수 있다).&lt;/p>
&lt;ul>
&lt;li>전통적인 메시지 큐는 메시지가 소비자에 전달되기 충분한 기간 동안만 메모리에 보관한다.&lt;/li>
&lt;li>처리 용량을 넘어선 메시지는 디스크에 보관하기도 하지만 아주 낮은 수준이다.&lt;/li>
&lt;/ul>
&lt;p>이러한 차이를 감안하면 설계는 크게 단순해질 수 있다.&lt;/p>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>메시지 큐의 기본 기능부터 살펴본다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img.png"
width="796"
height="93"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_hud3c73ae83a383271eeea8d3b288e965d_27768_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_hud3c73ae83a383271eeea8d3b288e965d_27768_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="메시지 큐의 핵심 컴포넌트"
class="gallery-image"
data-flex-grow="855"
data-flex-basis="2054px"
>&lt;/p>
&lt;ul>
&lt;li>생산자는 메시지를 메시지 큐에 발행&lt;/li>
&lt;li>소비자는 큐를 구독하고, 구독한 메시지를 소비&lt;/li>
&lt;li>메시지 큐는 생산자와 소비자 사이의 결합을 느슨하게 하는 서비스로, 생산자와 소비자의 독립적인 운영 및 규모 확장을 가능하게 하는 역할 담당&lt;/li>
&lt;li>생산자와 소비자는 모두 클라이언트/서버 모델 관점에서 클라이언트고 서비 역할을 하는 것은 메시지큐이며 이 클라이언트와 서버는 네트워크를 통해 통신&lt;/li>
&lt;/ul>
&lt;h3 id="메시지-모델">메시지 모델&lt;/h3>
&lt;p>가장 널리 쓰이는 메시지 모델은 &lt;strong>일대일&lt;/strong>과 &lt;strong>발행-구독&lt;/strong> 모델이다.&lt;/p>
&lt;p>&lt;strong>일대일 모델&lt;/strong>&lt;/p>
&lt;p>전통적인 메시지 큐에서 흔히 발견되는 모델로, 전송된 메시지는 오직 한 소비자만 가져갈 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_1.png"
width="719"
height="252"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_1_hu6243c8cf95b1f74f2b4ae180825e53e8_76030_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_1_hu6243c8cf95b1f74f2b4ae180825e53e8_76030_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="일대일 모델"
class="gallery-image"
data-flex-grow="285"
data-flex-basis="684px"
>&lt;/p>
&lt;ul>
&lt;li>어떤 소비자가 메시지를 가져갔다는 사실을 큐에 알리면 해당 미시지는 큐에서 삭제된다.&lt;/li>
&lt;li>데이터 보관을 지원하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>요구하는 설계안은 메시지르 ㄹ두 주 동안은 보관할 수 있도록 하는 지속성 계층을 포함하고, 해당 계층을 통해 메시지가 반복적으로 소비될 수 있도록 한다.&lt;/p>
&lt;p>일대일 모델도 지원할 수 있기는 하지만, 그 기능은 발행 구독 모델 쪽에 좀 더 자연스럽게 부합한다.&lt;/p>
&lt;p>&lt;strong>발행-구독 모델&lt;/strong>&lt;/p>
&lt;p>밸행-구독 모델을 설명하려면 &lt;strong>토픽&lt;/strong>이라는 새로운 개념을 도입해야한다.&lt;/p>
&lt;p>토픽은 메시지를 주제별로 정리하는 데 사용하며, 각 토픽은 메시지 큐 서비스 전반에 고유한 이름을 가진다.&lt;/p>
&lt;ul>
&lt;li>메시지를 보내고 받을 때는 토픽에 보내고 받게 된다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_2.png"
width="713"
height="249"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_2_hu2b876e024ea5ccc2f05fba9fb104dbda_50063_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_2_hu2b876e024ea5ccc2f05fba9fb104dbda_50063_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="발행 구독 모델"
class="gallery-image"
data-flex-grow="286"
data-flex-basis="687px"
>&lt;/p>
&lt;p>토픽에 전달된 메시지는 해당 토픽을 구독하는 모든 소비자에게 전달된다.&lt;/p>
&lt;h3 id="토픽-파티션-브로커">토픽, 파티션, 브로커&lt;/h3>
&lt;p>토픽에 보관되는 데이터의 양이 커져서 서버 한 대로 감당하기 힘등 상황을 해결하기 위한 방법으로 파티션(partition), 즉 샤딩(sharding) 기법을 활용할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_3.png"
width="664"
height="114"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_3_huce8fd381ea066eed08d42899755ce49a_46411_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_3_huce8fd381ea066eed08d42899755ce49a_46411_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="파티션"
class="gallery-image"
data-flex-grow="582"
data-flex-basis="1397px"
>&lt;/p>
&lt;p>토픽을 여러 파티션으로 분할한 다음, 메시지를 모든 파티션에 균등하게 나눠 보낸다.&lt;/p>
&lt;ul>
&lt;li>토픽에 보낼 메시지의 작은 부분집합으로 생각하면 좋다.&lt;/li>
&lt;/ul>
&lt;p>파티션을 메시지 큐 클러스터 내의 서버에 고르게 분산 배치하는데, 이 때 파티션을 유지하는 서버는 보통 브로커라 부른다.&lt;/p>
&lt;ul>
&lt;li>파티션을 브로커에 분산하는 것이 높은 규모 확장성을 달성하는 비결이다. 토픽의 용량을 확장하고 싶으면 파티션 개수를 늘린다.&lt;/li>
&lt;/ul>
&lt;p>각 토픽 파티션은 FIFO 큐처럼 동작하며, 파티션 내에서의 메시지 위치는 오프셋(offset)이라고 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_4.png"
width="791"
height="138"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_4_hu3cf93e0b7544d405aa6d70143e0a360a_47706_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_4_hu3cf93e0b7544d405aa6d70143e0a360a_47706_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="메시지 큐 클러스터"
class="gallery-image"
data-flex-grow="573"
data-flex-basis="1375px"
>&lt;/p>
&lt;p>생산자가 보낸 메시지는 해당 토픽의 파티션 가운데 하나로 보내지며, 메시지에는 사용자 ID 같은 키를 붙일 수 있는데, 같은 키를 가진 모든 메시지는 같은 파티션으로 보내지고, 없는 메시지는 무작위로 산택된 파티션으로 전송된다.&lt;/p>
&lt;hr>
&lt;p>토픽을 구독하는 소비자는 하나 이상의 파티션에서 데이터를 가져오게 되는데, 토픽을 구독하는 소비자가 여럿인 경우, 각 구독자는 해당 토픽을 구성하는 파티션의 일부를 담당하게 된다.&lt;/p>
&lt;p>이 소비자들을 해당 토픽의 소비자 그룹이라 부른다.&lt;/p>
&lt;h3 id="소비자-그룹">소비자 그룹&lt;/h3>
&lt;p>소비자 그룹 내 소비자는 토픽에서 메시지를 소비하기 위해 서로 협력한다.&lt;/p>
&lt;p>하나의 소비자 그룹은 여러 토픽을 구독할 수 있고 오프셋을 별도로 관리하며, 같은 그룹 내의 소비자는 메시지를 병렬로 소비할 수 있다.&lt;/p>
&lt;ul>
&lt;li>과금(billing)용 그룹, 회계(accounting)용 그룹 등&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_5.png"
width="643"
height="294"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_5_hu1c9434fd43963d97c2725b4ec9376291_145540_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_5_hu1c9434fd43963d97c2725b4ec9376291_145540_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="소비자 그룹"
class="gallery-image"
data-flex-grow="218"
data-flex-basis="524px"
>&lt;/p>
&lt;ul>
&lt;li>소비자 그룹 1은 토픽 A를 구독한다.&lt;/li>
&lt;li>소비자 그룹 2는 토픽 A와 토픽 B를 구독한다.&lt;/li>
&lt;li>토픽 A는 그룹-1과 그룹-2가 구독하므로, 해당 토픽 내 메시지는 그룹-1과 그룹-2 내의 소비자에게 전달된다.
&lt;ul>
&lt;li>발행-구독 모델을 지원한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>데이터르 병렬로 읽으면 대역폭 측면에서는 좋지만 같은 파티션 안에 있는 메시지를 순서대로 소비할 수는 없다.&lt;/p>
&lt;p>예를 들어 소비자-1과 소비자-2가 같은 파티션-1의 메시지를 읽어야 한다고 가정하면, 파티션-1 내의 메시지 소비 순서를 보장할 수 없게 된다(최종 처리 순서)&lt;/p>
&lt;p>따라서 어떤 &lt;strong>파티션의 메시지&lt;/strong>는 &lt;strong>한 그룹 안에서는 오직 한 소비자&lt;/strong>만 읽을 수 있도록 하면(토픽은 병렬로 처리되지만 파티션은 직렬로 처리된다.) 최종 처리 순서를 보장할 수 있게된다.&lt;/p>
&lt;p>그룹 내 소비자의 수가 구독하는 토픽의 파티션 수보다 크면, 어떤 소비자는 해당 토픽에서 데이터를 읽지 못하게 된다.&lt;/p>
&lt;ul>
&lt;li>토픽-B의 경우 파티션 하나이므로, 소비자 그룹 중 한 소비자만 담당할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이 제약사항을 도입한 후 모든 소비자를 같은 소비자 그룹에 두면 같은 파티션의 메시지는 오직 한 소비자만 가져갈 수 있으므로 결국 일대일 모델에 수렴하게 된다.&lt;/p>
&lt;p>파티션은 가장 작은 저장 단위이므로 &lt;strong>미리 충분한 파티션을 할당&lt;/strong>해 두면파티션의 수를 동적으로 늘리는 일은 피할 수 있다.&lt;/p>
&lt;ul>
&lt;li>처리 용량을 늘리려면 단순히 소비자를 더 추가하면 된다.&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_6.png"
width="800"
height="356"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_6_hudca1eecd3fd48e92a1dbd2173b098881_116817_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_6_hudca1eecd3fd48e92a1dbd2173b098881_116817_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="224"
data-flex-basis="539px"
>&lt;/p>
&lt;p>&lt;strong>클라이언트&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>생산자
&lt;ul>
&lt;li>메시지를 특정 토픽으로 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>소비자 그룹
&lt;ul>
&lt;li>토픽을 구독하고 메시지를 소비한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>핵심 서비스 및 저장소&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>브로커
&lt;ul>
&lt;li>파티션들을 유지한다.&lt;/li>
&lt;li>하나의 파티션은 특정 토픽에 대한 메시지의 부분 집합을 유지한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>저장소
&lt;ul>
&lt;li>데이터 저장소
&lt;ul>
&lt;li>메시지는 파티션 내 데이터 저장소에 보관된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>상태 저장소
&lt;ul>
&lt;li>소비자 상태는 이 저장소에 유지된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 저장소
&lt;ul>
&lt;li>토픽 설정, 토픽 속성 등은 이 저장소에 유지된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>조정 서비스(coordination service)
&lt;ul>
&lt;li>서비스 탐색(service discovery)
&lt;ul>
&lt;li>어떤 브로커가 살아있는지 알려준다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>리더 선출(leader election)
&lt;ul>
&lt;li>브로커 가운데 하나는 컨트롤러 역할을 담당해야 하며, 한 클러스터에는 반드시 활성 상태 컨트롤러가 하나 있어야한다.&lt;/li>
&lt;li>이 컨트롤러가 파티션 배치를 책임진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>아파치 주키퍼(Apache ZooKeeper)나 etcd가 보통 컨트롤러 선출을 담당하는 컴포넌트로 널리 이용된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>&lt;strong>데이터의 장기 보관&lt;/strong> 요구사항을 만족하면서 &lt;strong>높은 대역폭&lt;/strong>을 제공하기 위해 세가지 중요한 결정을 내려야한다.&lt;/p>
&lt;ul>
&lt;li>회전 디스크(rotational disk)의 &lt;strong>높은 순차 탐색 성능&lt;/strong>과 현대적 운영체제가 제공하는 **적극적 디스크 캐시 전략(aggressive disk caching strategy)**을 잘 이용하는 &lt;strong>디스크 기반 자료 구조(on-disk data structure)&lt;/strong> 를 활용한다.&lt;/li>
&lt;li>메시지가 생산자로부터 소비자에게 전달되는 순간까지 &lt;strong>아무 수정 없이도 전송이 가능하도록 하는 메시지 자료 구조&lt;/strong>를 설계하고 활용할 것이다.
&lt;ul>
&lt;li>전송 데이터의 양이 막대한 경우에 메시지 복사에 드는 비용을 최소화한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>일괄 처리(batching)&lt;/strong> 를 우선하는 시스템을 설계한다.
&lt;ul>
&lt;li>소규모의 I/O가 많으면 높은 대역폭을 지원하기 어렵다.&lt;/li>
&lt;li>생산자는 메시지를 일괄 전송하고, 메시지 큐는 그 메시지들을 더 큰 단위로 묶어 보관한다.&lt;/li>
&lt;li>소비자도 가능하면 메시지를 일괄 수신하도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="데이터-저장소">데이터 저장소&lt;/h3>
&lt;p>가장 좋은 메시지 저장 방법을 선택하기 위해 메시지 큐의 트래픽 패턴을 분석해봐야한다.&lt;/p>
&lt;ul>
&lt;li>읽기와 쓰기가 빈번하게 일어난다.&lt;/li>
&lt;li>갱신/삭제 연산은 발생하지 않는다.
&lt;ul>
&lt;li>전통적인 메시지 큐는 메시지가 신속하게 전달되지 못해 큐가 제때 비워지지 않는 경우를 제외하면 메시지를 지속적으로 보관하지 않는다.&lt;/li>
&lt;li>큐에서 메시지가 제때 소비되기 시작하면 저장된 메시지에 대한 삭제 연산이 발생하기는 할 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>순차적인 읽기/쓰기가 대부분이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>선택지 1: 데이터베이스&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>관계형 데이터베이스
&lt;ul>
&lt;li>토픽별로 테이블을 만든다.&lt;/li>
&lt;li>토픽에 보내는 메시지는 해당 테이블에 새로운 레코드로 추가한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>NoSQL 데이터베이스
&lt;ul>
&lt;li>토픽별로 컬렉션(collection)을 만든다.&lt;/li>
&lt;li>토픽에 보내는 메시지는 하나의 문서가 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>데이터베이스라면 데이터 저장 요구사항을 맞출수는 있으나, 읽기 연산과 쓰기 연산이 동시에 대규모로 빈번하게 발생하는 상황을 잘 처리하는 데이터베이스는 설계하기 매우 어렵다.&lt;/p>
&lt;p>데이터베이스는 오히려 시스템 병목이 될 수 있으므로 고려할 수 없다.&lt;/p>
&lt;p>&lt;strong>선택지 2: 쓰기 우선 로그(Write-Ahead Log, WAL)&lt;/strong>&lt;/p>
&lt;p>WAL은 새로운 항목이 추가되기만 하는(append-only) 일반 파일을 의미한다.&lt;/p>
&lt;ul>
&lt;li>MySQL의 리두 로그, 아파치 주키퍼 등에서 활용한다.&lt;/li>
&lt;/ul>
&lt;p>WAL에 대한 접근 패턴은 읽기/쓰기 모두 순차적이며, 디스크는 접근 패턴이 순차적일 때 아주 좋은 성능을 보인다.&lt;/p>
&lt;ul>
&lt;li>회전식 디스크 기반 저장장치는 큰 용량을 저렴한 가격에 구매할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_7.png"
width="848"
height="170"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_7_hub33e63d77387077d4f2174f1aa5478c0_78215_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_7_hub33e63d77387077d4f2174f1aa5478c0_78215_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="새로운 메시지 추가"
class="gallery-image"
data-flex-grow="498"
data-flex-basis="1197px"
>&lt;/p>
&lt;p>새로운 메시지는 파티션 꼬리 부분에 추가되며, 오프셋은 그 결과로 점진저긍로 증가한다.&lt;/p>
&lt;p>가장 쉬운 방법은 로그 파일 줄 번호(line number)를 오프셋으로 사용하는 것 인데, 파일의 크기도 무한정 커질 수 없으니, 세그먼트(segment) 단위로 나누는 것이 바람직하다.&lt;/p>
&lt;p>세그먼트를 사용하는 경우 새 메시지는 활성 상태의 세그먼트 파일에만 추가되며, 해당 세그먼트의 크기가 일정 한계에 도달하면 새 활성 세그먼트 파일이 만들어져 새로운 메시지를 수용하고, 종전까지 활성 상태였던 세그먼트 파일은 다른 나머지 세그먼트 파일과 마찬가지로 비활성 상태로 바뀐다.&lt;/p>
&lt;ul>
&lt;li>비활성 세그먼트 파일은 읽기 요청만 처리한다.&lt;/li>
&lt;li>낡은 비활성 세그먼트 파일은 보관 기한이 만료되거나 용량 한계에 도달하면 삭제해버릴 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_8.png"
width="509"
height="169"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_8_hu5bf82b188277228248c30eb11c97039a_45371_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_8_hu5bf82b188277228248c30eb11c97039a_45371_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="토픽 파티션에 분산된 데이터 세그먼트 파일"
class="gallery-image"
data-flex-grow="301"
data-flex-basis="722px"
>&lt;/p>
&lt;p>같은 파티션에 속한 세그먼트 파일은 &lt;code>Partition-{:partition_id}&lt;/code> 폴도 아래에 저장된다.&lt;/p>
&lt;p>&lt;strong>디스크 성능 관련 유의사항&lt;/strong>&lt;/p>
&lt;p>데이터 장기 보관에 대한 요구사항 때문에 본 설계안은 디스크 드라이브를 활용하여 다량의 데이터를 보관한다.&lt;/p>
&lt;p>회전식 디스크가 정말로 느려지는 것은 데이터 접근 패턴이 무작위일 때인데, 순차적 데이터 접근 패턴을 적극 활용하는 디스크 기반 자료 구조를 사용하면, RAID로 구성된 현대적 디스크 드라이브에서 수백 MB/s 수준의 읽기/쓰기 성능을 달성하는 것은 어렵지 않다.&lt;/p>
&lt;p>또한 현대적 운영체제는 디스크 데이터를 메모리에 아주 적극적으로 캐시하므로, 가용한 메모리 전부를 디스크 데이터를 캐시하는 데 활용할 수 있다.&lt;/p>
&lt;h3 id="메시지-자료-구조">메시지 자료 구조&lt;/h3>
&lt;p>메시지 구조는 &lt;strong>높은 대역폭 달성의 열쇠&lt;/strong>이다.&lt;/p>
&lt;p>메시지 자료 구조는 생산자, 메시지 큐, 소비자 사이의 &lt;strong>계약(contract)&lt;/strong> 이다.&lt;/p>
&lt;p>메시지가 큐를 거쳐 소비자에게 전달되는 과정에서 &lt;strong>불필요한 복사&lt;/strong>가 일어나지 않도록 함으로 높은 대역폭을 달성할 수 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>필드 이름&lt;/th>
&lt;th>데이터 자료형&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>key&lt;/td>
&lt;td>byte[]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>value&lt;/td>
&lt;td>byte[]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>topic&lt;/td>
&lt;td>string&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>partition&lt;/td>
&lt;td>integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>offset&lt;/td>
&lt;td>long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>timestamp&lt;/td>
&lt;td>long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>size&lt;/td>
&lt;td>integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>crc&lt;/td>
&lt;td>integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>시스템의 컴포넌트 가운데 이 &lt;strong>계약을 있는 그대로 받아들이지 못하는 것&lt;/strong>이 있으면 메시지는 변경되어야하기 때문에, 변경되는 과정에서 값비싼 복사가 발생하게되고, 그로 인해 전밙거인 성능이 심각하게 낮아질 수 있다.&lt;/p>
&lt;p>&lt;strong>메시지의 키&lt;/strong>&lt;/p>
&lt;p>메시지의 키는 파티션을 정할 때 사용된다.&lt;/p>
&lt;ul>
&lt;li>키가 주어지지 않은 메시지의 파티션은 무작위적으로 결정된다.&lt;/li>
&lt;li>키가 주어진 경우 파티션은 &lt;code>hash(key) % numPartitions&lt;/code>로 결정된다.&lt;/li>
&lt;li>더 유연한 설계가 필요하다면 생산자는 파티션 설정 매커니즘을 직접 정의할 수도 있다.&lt;/li>
&lt;li>메시지 키는 파티션의 번호가 아니다.&lt;/li>
&lt;/ul>
&lt;p>키는 문자열 일 수도 있고 숫자일 수도 있다. 보통 비즈니스 관련 정보가 담긴다.&lt;/p>
&lt;p>파티션 번호는 메시지 큐 내부적으로 사용되는 개념이므로 클라이언트에게 노출되어서는 안된다.&lt;/p>
&lt;p>키를 파티션에 대앙시키는 알고리즘을 적절히 정의해놓으면 파티션의 수가 달라져도 모든 파티션에 메시지가 계속 균등히 분산되도록 할 수 있다.&lt;/p>
&lt;p>&lt;strong>메시지 값&lt;/strong>&lt;/p>
&lt;p>메시지 값(message value)는 메시지의 내용, 즉 페이로드를 말한다.&lt;/p>
&lt;p>메시지 값은 일반 텍스트일 수도 있고 압축된 이진 블록(block)일 수도 있다.&lt;/p>
&lt;blockquote>
&lt;p>메시지의 키과 값은 키-값 저장소에서 이야기하는 키나 값과는 다르다.&lt;br>
키-값 저장소의 경우 키는 고유하므로 원하는 값은 키를 통해 찾을 수 있지만, 메시지의 키는 메시지마다 고유할 필요가 없다.
메시지에 반드시 키를 두어야 하는 것도 아니고 키를 사용해 값을 찾을 필요도 없다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>메시지의 기타 필드&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>토픽
&lt;ul>
&lt;li>메시지가 속한 토픽의 이름&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파티션
&lt;ul>
&lt;li>메시지가 속한 파티션의 ID&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오프셋
&lt;ul>
&lt;li>파티션 내 메시지의 위치&lt;/li>
&lt;li>토픽, 파티션, 오프셋 세 가지 정보를 알면 찾을 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>타임스탬프
&lt;ul>
&lt;li>메시지가 저장된 시각&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>크기
&lt;ul>
&lt;li>메시지의 크기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CRC(Cyclic Redundancy Check)
&lt;ul>
&lt;li>데이터의 무결성을 보장하는데 이용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 외에도 더 많은 기능을 지원하기 위한 선택적 필드가 있을 수 있다.&lt;/p>
&lt;ul>
&lt;li>tags 필드가 있다면 메시지를 태그를 사용해 필터링 하는 등&lt;/li>
&lt;/ul>
&lt;h3 id="일괄-처리">일괄 처리&lt;/h3>
&lt;p>이번 설계에서는 생산자, 소비자, 메시지 큐는 메시지를 가급적 일괄 처리한다.&lt;/p>
&lt;p>일괄 처리가 성능 개선에 중요한 이유는 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>여러 메시지르 한 번의 네트워크 요청으로 전송할 수 있기 때문에 값비싼 네트워크 왕복 비용을 제거할 수 있다.&lt;/li>
&lt;li>브로커가 여러 메시지를 한 번에 로그에 기록하면 더 큰 규모의 순차 쓰기 연산이 발생하고, 운영체제가 관리하는 디스크 매시에서 더 큰 규모의 연속된 공간을 점유하여 더 높은 디스크 접근 대역폭을 달성할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>높은 대역폭과 낮은 응답 지연은 동시에 달성하기 어려운 목표이다.&lt;/p>
&lt;p>시스템이 낮은 응답 지연이 중요한 전통적 메시지 큐로 이용된다면 디스크 성능은 다소 낮아질 수 있으나 일괄 처리 메시지 양을 낮춰야한다.&lt;/p>
&lt;p>처리량을 높여야 한다면 토픽 당 파티션의 수는 늘려 낮아진 순차 쓰기 연산 대역폭을 벌충할 수 있다.&lt;/p>
&lt;h3 id="생산자-측-작업-흐름">생산자 측 작업 흐름&lt;/h3>
&lt;p>라우팅 계층을 도입하여 생산자 적절한 브로커에 메시지를 보낼 수 있도록 한다.&lt;/p>
&lt;ul>
&lt;li>브로커를 여러 개로 복제하여 운용하는 경우에 메시지를 받을 적절한 브로커는 리더 브로커이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_9.png"
width="484"
height="363"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_9_hu682f5586b862f452ea7e931840c3195c_79133_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_9_hu682f5586b862f452ea7e931840c3195c_79133_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="라우팅 계층"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="320px"
>&lt;/p>
&lt;ol>
&lt;li>생산자는 메시지를 라우팅 계층으로 보낸다.&lt;/li>
&lt;li>라우팅 계층은 메타데이터 저장소에서 사본 분산 계획(replica distribution plan)을 읽어 자기 캐시에 보관한다.
&lt;ul>
&lt;li>메시지가 도착하면 라우팅 계층은 파티션-1의 리더 사본에 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>리더 사본이 우선 메시지를 받고 해당 리더를 따르는 다른 사본은 해당 리더로부터 데이터를 받는다.&lt;/li>
&lt;li>충분한 수의 사본이 동기화되면 리더는 데이터를 디스크에 기록한다.
&lt;ul>
&lt;li>데이터가 소비 가능 상태가 된다.&lt;/li>
&lt;li>기록이 끝나면 생산자에게 회신을 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>리더와 사본은 장애 감내가 가능한 시스템을 만들기 위해 필요하다.&lt;/p>
&lt;hr>
&lt;p>이러한 라우팅 계층 활용은 동작하지만 몇가지 단점이 있다.&lt;/p>
&lt;ul>
&lt;li>라우팅 계층을 도입하면 거쳐야 할 네트워크 노드가 하나 더 늘어나게 되므로 오버헤드가 발생하여 네트워크 전송 지연이 늘어난다.&lt;/li>
&lt;li>일괄 처리가 고려되지 않은 설계이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_10.png"
width="507"
height="358"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_10_hu2c25722b044080ce5de76ff2546d60df_97659_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_10_hu2c25722b044080ce5de76ff2546d60df_97659_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="생산자 측 버퍼 및 라우팅"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="339px"
>&lt;/p>
&lt;p>위 설계안은 생산자 클라이언트 라이브러리(producer client library)의 일부로 생산자에 설치하는 방법으로 생산자 내부로 라우팅 계층을 편입 시키고 버퍼를 도입한다.&lt;/p>
&lt;ul>
&lt;li>네트워크를 거칠 필요가 줄어들기 때문에 전송 지연도 줄어든다.&lt;/li>
&lt;li>생산자는 메시지를 어느 파티션에 보낼 지 결정하는 자신만의 로직을 가질 수 있다.&lt;/li>
&lt;li>전송할 메시지를 버퍼 메모리에 보관했다가 목적지로 일괄 전송하여 대역폭을 높일 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>일괄 처리하는 메시지의 양을 결정하는 것은 대역폭과 응답 지연 사이에서 타협접을 찾는 문제이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_11.png"
width="669"
height="461"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_11_huae1fa3968af168a994b53fd3910f54d4_49538_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_11_huae1fa3968af168a994b53fd3910f54d4_49538_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="일괄 처리 메시지 양 선택"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="348px"
>&lt;/p>
&lt;p>메시지의 양을 늘리면 대역폭은 늘어나지만 일괄 처리가 가능할 양의 메시지가 쌓이길 기다려야 하므로 응답 속도는 느려진다.&lt;/p>
&lt;p>양을 줄이면 메시지를 더 빨리 보낼 수 있어 지연은 줄어들지만 대역폭은 손해를 보게된다.&lt;/p>
&lt;p>따라서 생산자는 메시지 큐의 용도를 감안하여 일괄 처리 메시지 양을 조절해야한다.&lt;/p>
&lt;h3 id="소비자-측-작업-흐름">소비자 측 작업 흐름&lt;/h3>
&lt;p>소비자는 특정 파티션의 오프셋을 주고 해당 위치에서부터 이벤트를 묶어 가져온다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_12.png"
width="762"
height="216"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_12_huabc33028cbe25541b3a80429ecc16432_89945_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_12_huabc33028cbe25541b3a80429ecc16432_89945_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="소비자 측 메시지 흐름"
class="gallery-image"
data-flex-grow="352"
data-flex-basis="846px"
>&lt;/p>
&lt;h3 id="푸시-vs-풀">푸시 vs 풀&lt;/h3>
&lt;p>브로커가 데이터를 소비자에게 보낼 것인지, 소비자가 브로커에서 가져갈 것인지 결정하는 것은 중요한 문제이다.&lt;/p>
&lt;p>&lt;strong>푸시 모델&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>낮은 지연: 브로커는 메시지르 받는 즉시 소비자에게 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>소비자가 메시지를 처리하는 속도가 생산자가 메시지를 만드는 속도보다 느릴 경우, 소비자에게 큰 부하가 걸린다.&lt;/li>
&lt;li>생산자가 데이터 전송 속도를 좌우하므로, 소비자는 항상 그에 맞는 처리가 가능한 컴퓨팅 자원을 준비해 두어야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>풀 모델&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>메시지를 소비하는 속도는 소비자가 알아서 결정하므로 어떤 소비자는 실시간으로, 어떤 소비자는 일괄로 가져가는 등의 구성이 가능하다.&lt;/li>
&lt;li>메시지를 소비하는 속도가 생산 속도보다 느려지면 소비자를 늘려 해결할 수 있고, 생산 속도를 따라잡을 때 까지 기다려도 된다.&lt;/li>
&lt;li>일괄 처리에 적합하다.
&lt;ul>
&lt;li>푸시 모델은 브로커가 소비자의 여건을 할 수 없으므로 제 때 처리하지 못한 메시지는 버퍼에 쌓여 처리를 기다리게된다.&lt;/li>
&lt;li>반면 풀 모델은 소비자가 지난번 마지막으로 가져간 로그 위치 다음에 오는 모든 메시지를 가져갈 수 있다.&lt;/li>
&lt;li>공격적인 일괄 처리에 좀 더 적합하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>브로커에 메시지가 없어도 소비자는 계속 데이터를 끌어가려 시도하여 컴퓨팅 자원이 낭비된다.
&lt;ul>
&lt;li>롱 폴링 모드를 지원하여 당장 가져갈 메시지가 없더라도 일정 시간은 기다린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 이유들로 대부분의 메시지 큐는 푸시 모델 대신 풀 모델을 지원한다.&lt;/p>
&lt;h3 id="소비자-재조정">소비자 재조정&lt;/h3>
&lt;p>소비자 재조정(consumer rebalancing)은 어떤 소비자가 어떤 파티션을 책임지는지 다시 정하는 프로세스로 아래와 같은 상황에 발생할 수 있다.&lt;/p>
&lt;ul>
&lt;li>새로운 소비자가 합류&lt;/li>
&lt;li>기존 소비자가 그룹을 이탈&lt;/li>
&lt;li>어떤 소비자에 장애가 발생&lt;/li>
&lt;li>파티션들이 조정&lt;/li>
&lt;/ul>
&lt;p>이 절차에 &lt;strong>코디네이터&lt;/strong>가 중요한 역할을 하게된다.&lt;/p>
&lt;p>&lt;strong>코디네이터&lt;/strong>&lt;/p>
&lt;p>코디네이터는 &lt;strong>소비자 재조정을 위해 소비자들과 통신하는 브로커 노드&lt;/strong>로 소비자로 부터 오는 박동(heartbeat) 메시지를 살펴 각 소비자의 파티션 내 오프셋 정보를 관리한다.&lt;/p>
&lt;p>&lt;strong>코디네이터와 소비자의 상호작용&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_13.png"
width="1360"
height="616"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_13_hu24cbfeb4b1c798006e6153fbaff3b8b2_57699_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_13_hu24cbfeb4b1c798006e6153fbaff3b8b2_57699_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="220"
data-flex-basis="529px"
>&lt;/p>
&lt;ul>
&lt;li>같은 그룹의 모든 소비자는 같은 코디네이터에 연결한다.
&lt;ul>
&lt;li>소비자는 특정 그룹에 속하며, 새당 그룹 전담 코디네이터는 그룹 이름을 해싱하여 찾을 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>코디네이터는 자신에 연결한 소비자 목록을 유지한다.
&lt;ul>
&lt;li>목록에 변화가 생기면 코디네이터는 해당 그룹의 새로운 리더를 선출한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>새 리더는 새 파티션 배치 계획(partition dispatch plan)을 만들고 코디네이터에게 전달한다.
&lt;ul>
&lt;li>코디네이터는 해상 계획을 그룹 내 다른 모든 소비자에게 알린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>분산 시스템이므로 소비자는 네트워크 이슈를 비롯한 다양한 장애를 겪을 수 있다.&lt;/p>
&lt;p>코디네이터는 박동 신호가 사라지는 현상을 통해 소비자에게 발생한 장애를 감지할 수 있다.&lt;/p>
&lt;p>소비자의 장애를 감지하면 코디네이터가 재조정 프로세스를 시작하여 파티션을 재배치한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_14.png"
width="781"
height="482"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_14_hu3040dd236ada7e3d9279896ed998b74d_164489_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_14_hu3040dd236ada7e3d9279896ed998b74d_164489_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="재조정 시나리오 - 새로운 소비자 합류"
class="gallery-image"
data-flex-grow="162"
data-flex-basis="388px"
>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_15.png"
width="800"
height="490"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_15_hu9d2b8f9b37fff9f5b29f06699c525f6a_160195_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_15_hu9d2b8f9b37fff9f5b29f06699c525f6a_160195_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="재조정 시나리오 - 기존 소비자 이탈"
class="gallery-image"
data-flex-grow="163"
data-flex-basis="391px"
>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_16.png"
width="767"
height="478"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_16_hu75378ad62a32d64e2ec0020ea6667922_146955_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_16_hu75378ad62a32d64e2ec0020ea6667922_146955_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="재조정 시나리오 - 기존 소비자 장애 발생"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="385px"
>&lt;/p>
&lt;h3 id="상태-저장소">상태 저장소&lt;/h3>
&lt;p>메시지 큐 브로커의 상태 저장소(state storage)에는 다음과 같은 정보가 저장된다.&lt;/p>
&lt;ul>
&lt;li>소비자에 대한 파티션의 배치 관계&lt;/li>
&lt;li>각 소비자 그룹이 각 파티션에서 마지막으로 가져간 메시지의 오프셋&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_17.png"
width="1112"
height="470"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_17_hucf9712152cd51944aef5c8d0743e4d4e_55614_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_17_hucf9712152cd51944aef5c8d0743e4d4e_55614_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="236"
data-flex-basis="567px"
>&lt;/p>
&lt;p>소비자에 장애가 생기면 같은 그룹의 새로운 소비자가 이어받아 해당 위치부터 다음 메시지를 읽어간다.&lt;/p>
&lt;p>소비자 상태 정보 데이터가 이용되는 패턴은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>읽기와 쓰기가 빈번하게 발생하지만 양은 많지 않다.&lt;/li>
&lt;li>데이터 갱신은 빈번하게 일어나지만 삭제되는 일은 거의 없다.&lt;/li>
&lt;li>읽기와 쓰기 연산은 무작위적 패턴을 보인다.&lt;/li>
&lt;li>데이터의 일관성(consistency)가 중요하다.&lt;/li>
&lt;/ul>
&lt;p>이러한 데이터 일관성 및 높은 읽기/쓰기 속도에 대한 요구사항을 고려하였을 때, 아파치 주키퍼(Apache ZooKeeper) 같은 기-값 저장소를 사용하는 것이 바람직 할 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>카프카는 오프셋 저장소로 주키퍼를 사용하다가 카프카 브로커로 이전하였다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="메타데이터-저장소">메타데이터 저장소&lt;/h3>
&lt;p>메타데이터 저장소에는 토픽 설정이나 속성 정보를 보관한다.&lt;/p>
&lt;ul>
&lt;li>파티션 수, 메시지 보관 기간, 사본 배치 정보 등&lt;/li>
&lt;/ul>
&lt;p>메타데이터는 자주 변경되지 않으며 양도 적지만 높은 일관성을 요구한다.&lt;/p>
&lt;p>이러한 데이터 보관에는 주키퍼가 적절하다.&lt;/p>
&lt;h3 id="주키퍼">주키퍼&lt;/h3>
&lt;p>주키퍼는 계층적 키-값 저장소 기능을 제공하는 분산 시스템에 필수적인 서비스이다.&lt;/p>
&lt;p>보통 분산 설정 서비스(distributed configuration service), 동기화 서비스(synchronization service), 이름 레지스트리(naming registry) 등으로 이용된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_18.png"
width="737"
height="308"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_18_hu90fa82f22cf60b50eaf21e4fa4006d02_55640_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_18_hu90fa82f22cf60b50eaf21e4fa4006d02_55640_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="주키퍼"
class="gallery-image"
data-flex-grow="239"
data-flex-basis="574px"
>&lt;/p>
&lt;ul>
&lt;li>메타데이터와 상태 저장소는 주키퍼를 이용해 구현&lt;/li>
&lt;li>브로커는 이제 메시지 데이터 저장소만 유지함&lt;/li>
&lt;li>주키퍼가 브로커 클러스터의 리더 선출 과정을 도움&lt;/li>
&lt;/ul>
&lt;h3 id="복제">복제&lt;/h3>
&lt;p>분산 시스템에서 하드웨어 장애는 흔한 일이므로 무시해서는 안 된다.&lt;/p>
&lt;p>디스크에 손상이나 영구적 장애가 발생하면 데이터는 사라지는데, 이런 문제를 해결하고 높은 가용성을 보장하기 위해 전통적으로 많이 사용된 방법이 복제(replication)다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_19.png"
width="1450"
height="600"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_19_hue931ac2e5cb001645a892d19201e2d77_109852_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_19_hue931ac2e5cb001645a892d19201e2d77_109852_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="241"
data-flex-basis="580px"
>&lt;/p>
&lt;p>짙은 색으로 강조한 사본은 해당 파티션의 리더이고, 나머지는 단순 사본이다.&lt;/p>
&lt;p>생산자는 파티션에 메시지를 보낼 때 리더에게만 보내며, 다른 사본은 리더에서 새 메시지를 지속적으로 가져와 동기화한다.&lt;/p>
&lt;p>메시지를 환전히 동기화한 사본의 개수가 지정된 임계값을 넘으면 리더는 생산자에게 메시지를 잘 받았다는 응답을 보낸다.&lt;/p>
&lt;p>사본을 파티션에 어떻게 분산할 지 기술하는 것을 사본 분산 계획(replica distribution plan)이라고 하며 조정 서비스의 도움으로 브로커 노드 가운데 하나가 리더로 선출되면 해당 리더 브로커 노드가 사본 분산 계획을 만드록 메타데이터 저장소에 보관하게된다.&lt;/p>
&lt;h3 id="사본-동기화">사본 동기화&lt;/h3>
&lt;p>어떤 한 노드의 장애로 메시지가 소실되는 것을 막기 위해 메시지는 여러 파티션에 두며, 각 파티션은 다시 여러 사본으로 복제한다.&lt;/p>
&lt;p>메시지는 리더로만 보내고 다른 단순 사본은 리더에서 메시지를 가져가 동기화 하는데, 그 모두를 어떻게 동기화 시킬 것 인지가 중요하다.&lt;/p>
&lt;p>동기화된 사본(In-Sync Replicas, ISR)은 리더와 동기화된 사본을 일컫는 용어로, &lt;strong>동기화되었다&lt;/strong>는 것이 무엇을 의미하느냐는 토픽의 설정에 따라 달라진다.&lt;/p>
&lt;p>예를 들면 &lt;code>replica.lag.max.messages&lt;/code>의 값이 4로 설정되어 있다면, 단순 사본에 보관된 메시지 개수와 리더 사이의 차이가 3이라면 해당 사본은 여전히 ISR이다(리더는 항상 ISR).&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_20.png"
width="574"
height="441"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_20_hue79f5998456d6ee5bbb016967d9923d2_94011_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_20_hue79f5998456d6ee5bbb016967d9923d2_94011_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="ISR의 동작 원리"
class="gallery-image"
data-flex-grow="130"
data-flex-basis="312px"
>&lt;/p>
&lt;p>ISR은 성능과 영속성 사이의 타협점이다.&lt;/p>
&lt;p>생산자가 보낸 어떤 메시지도 소실하지 않는 가장 안전한 방법은 생산자에게 메시지를 잘 받았다는 응답을 보내기 전에 모든 사본을 동기화하는 것 이다.&lt;/p>
&lt;p>하지만 어느 사본 하나라도 동기화를 신속하게 처리하지 못하게 되면 파티션 전부가 느려지거나 아예 못 쓰게 되는 일이 발생할 수 있다.&lt;/p>
&lt;p>&lt;strong>ACK=all&lt;/strong>&lt;/p>
&lt;p>&lt;code>ACK=all&lt;/code>로 설정된 경우 생산자는 모든 ISR이 메시지를 수신한 뒤에 ACK 응답을 받는다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_21.png"
width="795"
height="432"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_21_hu2ea44a0ceef07650f341f77a4a9a920c_93394_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_21_hu2ea44a0ceef07650f341f77a4a9a920c_93394_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="ACK=all"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="441px"
>&lt;/p>
&lt;p>느린 ISR의 응답을 기다려야 하므로 메시지를 보내기 위한 시간이 길어지지만, 영속성 측면에서는 가장 좋은 구성이다.&lt;/p>
&lt;p>&lt;strong>ACK=1&lt;/strong>&lt;/p>
&lt;p>리더가 메시지를 저장하고 나면 바로 ACK 응답을 받는다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_22.png"
width="795"
height="427"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_22_hu46cba1bc30512512288c80e0145df945_144131_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_22_hu46cba1bc30512512288c80e0145df945_144131_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="ACK=1"
class="gallery-image"
data-flex-grow="186"
data-flex-basis="446px"
>&lt;/p>
&lt;p>데이터가 동기화될 때까지 기다리지 않으므로 응답 지연은 개선되지만, 메시지 ACK을 보낸 직후 리더에 장애가 생기면 해당 메시지는 다른 사본에 반영되지 못하였으므로 소실된다.&lt;/p>
&lt;p>이런 구성은 &lt;strong>데이터가 사라져도 상관없는 대신 낮은 응답 지연을 보장해야 하는 시스템에 적합&lt;/strong>하다.&lt;/p>
&lt;p>&lt;strong>ACK=0&lt;/strong>&lt;/p>
&lt;p>보낸 메시지에 대한 수신 확인 메시지를 기다리지 않고 계속 메시지를 전송하며 어떤 재시도도 하지 않는다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_23.png"
width="762"
height="426"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_23_hu4b1fd6178d17accfc9f3e08a31796b97_117457_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_23_hu4b1fd6178d17accfc9f3e08a31796b97_117457_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="ACK=0"
class="gallery-image"
data-flex-grow="178"
data-flex-basis="429px"
>&lt;/p>
&lt;p>낮은 응답 지연을 달성하기 위해 메시지 손실은 감수하는 구성으로, 지표 수집이나 데이터 로깅 등 처리해야하는 메시지의 양이 많고 때로 데이터 손실이 밸생해도 상관 없는 경우 사용된다.&lt;/p>
&lt;hr>
&lt;p>이처럼 ACK 설정을 변경 가능하도록 해 두면 성능을 높여야 할 경우 영속성을 다소 희생할 수도 있게 된다.&lt;/p>
&lt;p>소비자 측면에서 가장 쉬운 구성은 소비자로 하여금 리더에서 메시지를 읽어가도록 하는 것이다.&lt;/p>
&lt;p>ISR 요건을 만족하는 사보넹서는 메시지를 가져가지 않는 이유는 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>설계 및 운영이 단순하다.&lt;/li>
&lt;li>특정 파티션의 메시지는 같은 소비자 그룹 안에서는 오직 한 소비자만 읽어갈 수 있으므로 리더 사본에 대한 연결은 많지 않다.&lt;/li>
&lt;li>아주 인기 있는 토픽이 아니라면 리더 사본에 대한 연결의 수는 그렇게 많지 않다.&lt;/li>
&lt;li>아주 인기 있는 토픽의 경우에는 파티션 및 소비자 수를 늘려 규모를 확장하면 된다.&lt;/li>
&lt;/ul>
&lt;p>하지만 소비자가 리더 사본에서 메시지를 가져올 때 비용이 훨씬 더 크다면 다른 ISR 사본을 사용하는 방법을 고려할 수 있다.&lt;/p>
&lt;hr>
&lt;p>ISR은 아주 중요한데, 어떤 사본이 ISR인지는 어떻게 판별할 수 있을까?&lt;/p>
&lt;p>보통 각 파티션 담당 리더는 자기 사본들이 어느 메시지가지 가져갔는지 추적하여 ISR 목록을 관리한다.&lt;/p>
&lt;h3 id="규모-확장성">규모 확장성&lt;/h3>
&lt;p>주요 시스템 컴포넌트의 규모 확장성을 알아본다.&lt;/p>
&lt;p>&lt;strong>생산자&lt;/strong>&lt;/p>
&lt;p>그룹 단위의 조정에 가담할 필요가 전혀 없으므로 소비자에 비해 개념적으로는 훨씬 간단하다.&lt;/p>
&lt;p>새로운 생산자를 추가하거나 삭제함으로써 쉽게 달성할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>소비자&lt;/strong>&lt;/p>
&lt;p>소비자 그룹은 서로 독립적이므로 새 소비자 그룹은 쉽게 추가하고 삭제할 수 있다.&lt;/p>
&lt;p>같은 소비자 그룹 내의 소비자가 새로 추가/삭제 되거나 장애로 제거되어야 하는 경우 &lt;strong>재조정(rebalancing) 매커니즘&lt;/strong>이 맡아 처리한다.&lt;/p>
&lt;p>소비자 측의 규모 확장성과 결함 내성을 보장하는 것은 바로 &lt;strong>소비자 그룹&lt;/strong>과 &lt;strong>재조정 매커니즘&lt;/strong>이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>브로커&lt;/strong>&lt;/p>
&lt;p>브로커의 규모 확장성을 살펴보기 전에 브로커의 결함 내성에 대해 먼저 확인해볼 필요가 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_24.png"
width="900"
height="754"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_24_hu7dba5ff09423fbf7a358f5bbbcce9707_378518_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_24_hu7dba5ff09423fbf7a358f5bbbcce9707_378518_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="브로커 노드의 장애"
class="gallery-image"
data-flex-grow="119"
data-flex-basis="286px"
>&lt;/p>
&lt;p>특정 브로커 노드에 장애가 발생하여 해당 노드의 모든 파티션이 소실되었다면 파티션 계획이 변경되고, 브로커 컨트롤러가 브로커 노드가 사라졌음을 감지한 후 새로운 파티션 분산 계획을 만들어내며, 새로 추가된 사본은 단순 사본으로 리더에 보관된 메시지를 따라잡는 동작을 개시하게된다.&lt;/p>
&lt;p>브로커의 결함 내성을 높이기 위해 다음과 같은 사항을 추가 고려해야한다.&lt;/p>
&lt;ul>
&lt;li>메시지가 성공적으로 합의 되었다고 판단하려면 얼마나 만은 사본에 메시지가 반영되어야하는가
&lt;ul>
&lt;li>높을수록 안전하지만 응답 지연이 발생한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파티션의 모든 사본이 같은 브로커 노드에 있으면 해당 노드에 장애가 발생할 경우 해당 파티션은 완전히 소실된다.
&lt;ul>
&lt;li>같은 노드에 데이터를 복제하는 것은 자원 낭비이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파티션의 모든 사본에 문제가 생기면 해당 파티션의 데이터는 영원히 사라진다.
&lt;ul>
&lt;li>여러 데이터 센터에 분산하는 것이 안전하다.&lt;/li>
&lt;li>데이터 미러링을 도입하여 데이터 센터 간 데이터 복사를 용이하게 할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>브로커의 규모 확정성의 가장 간단한 해법은 &lt;strong>브로커 노드가 추가되거나 삭제될 때 사본을 재배치하는 것&lt;/strong>이다.&lt;/p>
&lt;p>더 나은 방법은 &lt;strong>브로커 컨트롤러로 하여금 한시적으로 시스템에 설정된 사본 수보다 많은 사본을 허용하도록 하는 것&lt;/strong>이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_25.png"
width="822"
height="587"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_25_hu3e4307ede215c73c092ff52f854da68b_300452_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_25_hu3e4307ede215c73c092ff52f854da68b_300452_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="새 브로커 노드의 추가"
class="gallery-image"
data-flex-grow="140"
data-flex-basis="336px"
>&lt;/p>
&lt;p>새로 추가된 브로커 노드가 기존 브로커 상태를 따라잡고 나면 더 이상 필요없는 노드는 제거한다.&lt;/p>
&lt;p>이러한 절차를 통해 브로커를 추가하는 도중 발생할 수 있는 데이터 손실을 피할 수 있다. (제거할 때도 비슷한 방법을 적용하면 안전하게 제거할 수 있다.)&lt;/p>
&lt;h3 id="파티션">파티션&lt;/h3>
&lt;p>운영상의 이유로 파티션의 수를 조정해야 하는 일이 생길 수 있다.&lt;/p>
&lt;ul>
&lt;li>토픽의 규모를 늘린다.&lt;/li>
&lt;li>대역폭을 조정한다.&lt;/li>
&lt;li>가용성과 대역폭 사이의 균형을 맞춘다. 등&lt;/li>
&lt;/ul>
&lt;p>생산자는 브로커와 통신할 때 그 사실을 통지 받으며, 소비자는 재조정을 시행한다.&lt;/p>
&lt;p>따라서 파티션 수의 조정은 생산자와 소비자의 안전성에는 영향을 끼치지 않는다.&lt;/p>
&lt;p>그러니 파티션의 수가 달라지면 데이터 저장 계층에는 변화를 살펴본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>파티션 추가&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_26.png"
width="617"
height="303"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_26_hu66853cbe1681a457578fa72d7205fe64_66657_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_26_hu66853cbe1681a457578fa72d7205fe64_66657_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="파티션 추가"
class="gallery-image"
data-flex-grow="203"
data-flex-basis="488px"
>&lt;/p>
&lt;ul>
&lt;li>지속적으로 보관된 메시지는 여전히 기존 파티션에 존재하며 해당 데이터는 이동하지 않는다.&lt;/li>
&lt;li>새로운 파티션이 추가되면 그 이후 오는 메시지는 3개 파티션 전부에 지속적으로 보관되어야 한다.&lt;/li>
&lt;/ul>
&lt;p>따라서 파티션을 늘리면 간단히 토픽의 규모를 늘릴 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>파티션 삭제&lt;/strong>&lt;/p>
&lt;p>파티션 삭제 절차는 좀 더 까다롭다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_27.png"
width="575"
height="284"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_27_hub7aceadd98b0fd0d12299b2adc1860dc_112613_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_27_hub7aceadd98b0fd0d12299b2adc1860dc_112613_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="파티션 삭제"
class="gallery-image"
data-flex-grow="202"
data-flex-basis="485px"
>&lt;/p>
&lt;ul>
&lt;li>파티션을 퇴역 시킨다는 결정이 내려지면 새로운 메시지는 다른 파티션에만 보관된다.&lt;/li>
&lt;li>퇴역된 파티션은 바로 제거하지 않고 일정 시간 동안 유지한다.
&lt;ul>
&lt;li>해당 파티션의 데이터를 읽고 있는 소비자가 있을 수 있기 때문&lt;/li>
&lt;li>유지 기간이 지나고 나면 데이터를 삭제하고 저장 공간을 반환한다.&lt;/li>
&lt;li>파티션을 줄요도 저장 용량은 바로 늘지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파티션 퇴역 후 실제로 제거가 이루어지는 시점까지 생산자는 메시지를 남은 두 파티션으로만 보내지만 소비자는 세 파티션 모두에서 메시지를 읽는다.
&lt;ul>
&lt;li>실제로 파티션이 제거되는 시점이 오면 생산자 그룹은 재조정 작업을 개시해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="메시지-전달-방식">메시지 전달 방식&lt;/h3>
&lt;p>분산 메시지 큐가 지원해야 하는 다양한 메시지 전달 방식을 살펴본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>최대 한 번&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_28.png"
width="734"
height="89"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_28_huf3810f0a17ca0835cfe78b52b0dd077e_35741_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_28_huf3810f0a17ca0835cfe78b52b0dd077e_35741_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="최대 한 번"
class="gallery-image"
data-flex-grow="824"
data-flex-basis="1979px"
>&lt;/p>
&lt;p>메시지를 &lt;strong>최대 한 번(at-most once)&lt;/strong> 만 전달하는 방식으로 메시지가 전달 과정에서 소실되더라도 다시 전달되는 일은 없다.&lt;/p>
&lt;ul>
&lt;li>생산자는 토픽에 비동기적으로 메시지를 보내고 수신 응답을 기다리지 않는다.(ACK=0)
&lt;ul>
&lt;li>재시도 X&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>소비자는 메시지를 읽고 처리하기 전에 오프셋부터 갱신한다.
&lt;ul>
&lt;li>오프셋이 갱신된 직후에 소비자가 장애로 죽으면 메시지는 다시 소비될 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>최소 한 번&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_29.png"
width="825"
height="95"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_29_hudf42c4b9d0c9e871861fa602c69e702c_30939_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_29_hudf42c4b9d0c9e871861fa602c69e702c_30939_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="최소 한 번"
class="gallery-image"
data-flex-grow="868"
data-flex-basis="2084px"
>&lt;/p>
&lt;p>같은 메시지가 한 번 이상 전달될 수는 있으나 메시지 소실은 발생하지 않는 전달 방식이다.&lt;/p>
&lt;ul>
&lt;li>생산자는 메시지를 동기적/비동기적으로 보낼 수 있으며, &lt;code>ACK=1&lt;/code> 또는 &lt;code>ACK=all&lt;/code>의 구성을 이용한다.
&lt;ul>
&lt;li>메시지가 브로커에게 전달되었음을 반드시 확인한다.&lt;/li>
&lt;li>메시지 전달이 실패하거나 타임아웃이 발생한 경우 계속 재시도한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>소비자는 데이터를 성공적으로 처리한 뒤에만 오프셋을 갱신한다.
&lt;ul>
&lt;li>메시지 처리가 실패한 경우에는 메시지를 다시 가져오므로 데이터가 손실되는 일은 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지는 브로커나 소비자에게 한 번 이상 전달될 수 있다.
&lt;ul>
&lt;li>메시지를 처리한 소비자가 미처 오프셋을 갱신하지 못하고 죽었다가 다시 시작하면 메시지는 중복 처리된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>정확히 한 번&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/4/img_30.png"
width="831"
height="91"
srcset="https://codemario318.github.io/post/system-design-interview-2/4/img_30_hu6cc94579eea89128ec5ed3e9911f6f15_40121_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/4/img_30_hu6cc94579eea89128ec5ed3e9911f6f15_40121_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="정확히 한 번"
class="gallery-image"
data-flex-grow="913"
data-flex-basis="2191px"
>&lt;/p>
&lt;p>구현하기 가장 까다로운 전송 방식으로, 사용자 입장에서는 편리하지만, 시스템의 성능 및 구현 복잡도 측면에서는 큰 대가를 지불해야한다.&lt;/p>
&lt;ul>
&lt;li>지불, 매매, 회계 등 금융 관련 응용에는 이 전송 방식이 적합하다.&lt;/li>
&lt;/ul>
&lt;p>중복을 허용하지 않으며, 구현에 이용할 서비스나 제3자 제품이 같은 입력에 항상 같은 결과를 내 놓도록 구현되어 있지 않은 애플리케이션에 특히 중요한 방식이다.&lt;/p>
&lt;h3 id="고급-기능">고급 기능&lt;/h3>
&lt;p>메시지 필터링, 지연 전송, 예약 전송 등의 고급 기능을 살펴본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>메시지 필터링&lt;/strong>&lt;/p>
&lt;p>토픽은 같은 유형의 메시지를 담아 처리하기 위해 도입된 논리적 개념(abstraction)이다.&lt;/p>
&lt;p>어떤 소비자 그룹은 그 가운데서도 특정한 세부/하위 유형의 메시지에만 관심이 있는데, 특정 토픽을 만들어 분리하는 것은 아래와 같은 우려가 있을 수 있다.&lt;/p>
&lt;ul>
&lt;li>비슷한 요구사항마다 전용 토픽을 만들 것 인가?&lt;/li>
&lt;li>같은 메시지를 여러 토픽에 저장하는 것은 자원 낭비이다.&lt;/li>
&lt;li>새로운 소비차 측 요구사항이 등장할 때마다 생산자 구현을 바꿔야할 수 있다.
&lt;ul>
&lt;li>생산자와 소비자의 결합이 높아졌으므로&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>메시지 필터링을 사용하면 이런 문제를 피할 수 있다.&lt;/p>
&lt;p>가장 쉬운 방법은 소비자가 일단 모든 메시지를 받은 다음 필요없는 메시지를 버리는 방법인데, 유연성이 높지만 불필요한 트래픽이 발생하여 시스템 성능이 저하되는 문제가 있을 수 있다.&lt;/p>
&lt;p>더 나은 방법은 브로커에서 메시지를 필터링하여 소비자는 원하는 메시지만 받을 수 있도록 하는 것이며, 이를 위해 세심하게 살펴야할 것들이 많다.&lt;/p>
&lt;ul>
&lt;li>복호화와 역직렬화가 필요하다면 브로커 성능은 저하되므로, 브로커에 구현할 필터링 로직은 메시지의 내용을 추출해서는 안된다.&lt;/li>
&lt;li>필터링에 사용될 데이터는 메시지의 메타데이터 영역에 두어 브로커로 하여금 효율적으로 읽어갈 수 있도록 해야한다.&lt;/li>
&lt;/ul>
&lt;p>메시지마다 태그를 두면 소비자는 어떤 태그를 가진 메시지를 구독할지 지정할 수 있게 된다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>메시지의 지연 전송 및 예약 전송&lt;/strong>&lt;/p>
&lt;p>소비자에게 보낼 메시지를 일정 시간만큼 지연시켜야 하는 일이 있을 수 있다.&lt;/p>
&lt;p>발송 즉시 전달되는 메시지와는 달리, 이런 메시지는 토픽에 바로 저장하지 ㅇ낳고 브로커 내부의 임시 저장소에 넣어 두었다가 시간이 되면 토픽으로 옮긴다.&lt;/p>
&lt;p>이 시스템의 핵심 컴포넌트는 임시 저장소 및 타이밍 기능이다.&lt;/p>
&lt;ul>
&lt;li>하나 이상의 특별 메시지 토픽을 임시 저장소로 활용할 수 있다.&lt;/li>
&lt;li>타이밍 기능은 두 범주의 기술이 널리 활용되고 있다
&lt;ul>
&lt;li>메시지 지연 전송 전용 메시지 큐를 사용
&lt;ul>
&lt;li>특정 메시지 큐는 임의 시간 동안 메시지 전송을 지연하는 기능을 가지고 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>계층적 타이밍 휠&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>메시지 예약 전송은 지정된 시간에 소비자에게 메시지를 보낼 수 있도록 하는 기능으로, 메시지 지연 전송 시스템과 유사하다.&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>이번 장에서는 데이터 스트리밍 플랫폼에서 흔히 발견되는 고급 기능을 지원하는 분산 메시지 큐 시스템 설계안을 살펴보았다.&lt;/p>
&lt;p>실제 면접 시 시간이 조금 남는다면 면접관과 다음 사항에 대해 이야기해보면 좋을 것 이다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>프로토콜&lt;/p>
&lt;ul>
&lt;li>노드 사이에 오고 가는 데이터에 대한 규칙, 문법, API로 분산 메시지 큐 시스템의 경우 프로토콜은 다음 사항을 기술해야한다.
&lt;ul>
&lt;li>메시지 생산과 소비, 박동 메시지 교환 드으이 모든 활동&lt;/li>
&lt;li>대용량 데이터를 효과적으로 전송할 방법&lt;/li>
&lt;li>데이터의 무결성을 검증할 방법&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>AMQP, 카프카 프로토콜 등이 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>메시지 소비 재시도&lt;/p>
&lt;ul>
&lt;li>재대로 받아 처리하지 못한 메시지는 일정 시간 뒤에 다시 처리를 시도해야한다.
&lt;ul>
&lt;li>실패한 메시지는 재시도 전용 토픽에 보낸 다음 나중에 다시 소비 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이력 데이터 아카이브
&lt;ul>
&lt;li>시간 기반 혹은 용량 기반 로그 보관 메커니즘이 있다고 가정할 때 이미 삭제된 메시지를 다시 처리하길 원하는 사용자가 있다면, HDFS같은 대용량 저장소 시스템이나 객체 저장소에 보관해둘 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>3. 구글 맵</title><link>https://codemario318.github.io/post/system-design-interview-2/3/</link><pubDate>Sat, 24 Aug 2024 16:38:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/3/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/cover.png" alt="Featured image of post 3. 구글 맵" />&lt;p>구글 맵은 위성 이미지, 거리 뷰, 실시간 교통 상항, 경로 계획 등 다양한 서비스를 제공하고 있다.&lt;/p>
&lt;p>엄청나게 복잡한 제품이므로, 설계에 앞서 어떤 기능에 초점을 맞추어야 하는지 확인해야 한다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;ul>
&lt;li>Q. 일간 능동 사용자 수는?
&lt;ul>
&lt;li>A. 10억 DAU&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 초점을 두어야하는 기능은?
&lt;ul>
&lt;li>A. 위치 갱신, 경로 안내, ETA, 지도 표시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 도로 데이터는 어느정도, 데이터는 확보 되었다고 가정?
&lt;ul>
&lt;li>A. 도로 데이터는 다양한 결로로 확보해 두었다고 가정, 수 TB 수준의 가공되지 않은 데이터&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 교통 상황도 고려해야하는가?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 여러 이동 수단 고려?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 경유지 선택 가능?
&lt;ul>
&lt;li>A. N&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 사업장 정보도 포함?
&lt;ul>
&lt;li>A. N&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="기능-요구사항">기능 요구사항&lt;/h3>
&lt;p>이번 장에서는 3가지 기능에 집중 할 것이며, 지원할 주 단말은 스마트폰이다.&lt;/p>
&lt;ul>
&lt;li>사용자 위치 갱신&lt;/li>
&lt;li>경로 안내 서비스(ETA 포함)&lt;/li>
&lt;li>지도 표시&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항-및-제약사항">비기능 요구사항 및 제약사항&lt;/h3>
&lt;ul>
&lt;li>정확도
&lt;ul>
&lt;li>사용자에게 잘못된 경로를 안내하면 안됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>부드러운 경로 표시
&lt;ul>
&lt;li>제공되는 경로는 화면에 부드럽게 표시되고 갱신되어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 및 배터리 사용량
&lt;ul>
&lt;li>클라이언트가 최소한의 데이터와 배터리를 사용해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>일반적으로 널리 통용되는 가용성 및 규모 확장성 요구사항을 만족해야함&lt;/li>
&lt;/ul>
&lt;h3 id="지도-101">지도 101&lt;/h3>
&lt;p>&lt;strong>측위 시스템&lt;/strong>&lt;/p>
&lt;p>측위 시스템은 구 표면상의 위치를 표현하는 체계를 말한다.&lt;/p>
&lt;p>위경도 기반 측위 시스템의 경우, 최상단에는 북극이 있고 최하단에는 남극이 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img.png"
width="469"
height="460"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_hu4ecfd35b0eaef394414174e94c849f4b_312747_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_hu4ecfd35b0eaef394414174e94c849f4b_312747_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="위도와 경도"
class="gallery-image"
data-flex-grow="101"
data-flex-basis="244px"
>&lt;/p>
&lt;ul>
&lt;li>위도(Latitude, Lat.)
&lt;ul>
&lt;li>주어진 위치가 얼마나 남/북쪽인지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>경도(Longitude)
&lt;ul>
&lt;li>얼마나 동/서 쪽인지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>3차원 위치를 2차원 변환&lt;/strong>&lt;/p>
&lt;p>3차원 구 위의 위치를 2차원 평면에 대응시키는 절차를 &lt;strong>지도 투영법&lt;/strong>(map projection)또는 &lt;strong>도법&lt;/strong>이라 부른다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_1.png"
width="1920"
height="1108"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_1_hu6679b85ef3a54a92f40f68b74cd7f354_2863712_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_1_hu6679b85ef3a54a92f40f68b74cd7f354_2863712_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="지도 투영법 사이의 차이점"
class="gallery-image"
data-flex-grow="173"
data-flex-basis="415px"
>&lt;/p>
&lt;p>여러 도법이 있으며 각각 차별되는 장점이 있으나 공통적으로 실제 지형의 기하학적 틍성을 왜곡한다는 공통점을 갖는다.&lt;/p>
&lt;p>구글 맵은 메르카토르 도법을 조금 변경한 &lt;strong>웹 메르카토르&lt;/strong>(WebMercator) 도법을 사용한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>지오코딩&lt;/strong>&lt;/p>
&lt;p>지오코딩은 주소를 지리적 측위 시스템의 좌표로 변환하는 프로세스이다.&lt;/p>
&lt;p>지오 코딩을 수행하는 한 가지 방법은 GIS와 같은 다양한 시스템이 제공하는 데이터를 결합하는 인터폴레이션(interpolation)이 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>GIS - Geographic Information System&lt;/strong>&lt;br>
도로망을 지리적 좌표 공간에 대응시키는 방법을 제공하는 시스템들 중 하나&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>&lt;strong>지오해싱&lt;/strong>&lt;/p>
&lt;p>지도 위 특정 영역을 영문자와 숫자로 구성된 짧은 문자열에 대응시키는 인코딩 체계이다.&lt;/p>
&lt;p>2차원의 평면 공간으로 표현된 지리적 영역 위의 격자를 더 작은 격자로 재귀적으로 분할해나간다.&lt;/p>
&lt;ul>
&lt;li>각 격자는 정사각형, 사각형 일 수 있다.&lt;/li>
&lt;/ul>
&lt;p>격자를 재귀적으로 분할한 결과로 생성된 더 작은 격자에는 0~3의 번호를 부여한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_2.png"
width="623"
height="365"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_2_hue1d5f8bcb8e879d614ad41727ff0e80a_250766_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_2_hue1d5f8bcb8e879d614ad41727ff0e80a_250766_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="지오해싱"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="409px"
>&lt;/p>
&lt;p>이번 설계에서는 &lt;strong>맵 타일&lt;/strong>관리를 위해 지오해싱을 활용한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>지도 표시&lt;/strong>&lt;/p>
&lt;p>지도를 화면에 표시하는 데 가장 기본이 되는 개념은 &lt;strong>타일&lt;/strong>(Tile)이다.&lt;/p>
&lt;ul>
&lt;li>지도 전부를 하나의 이미지로 표시하는 대신, 작은 타일로 쪼개어 표현한다.&lt;/li>
&lt;li>클라이언트는 보려는 영역에 관계된 타일만 다운받아 모자이크처럼 이어 붙인 다음 화면에 뿌린다.&lt;/li>
&lt;/ul>
&lt;p>확대/축소를 지원하기 위해 확대 수준에 따라 다른 종류의 타일을 준비한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>경로 안내 알고리즘을 위한 도로 데이터 처리&lt;/strong>&lt;/p>
&lt;p>대부분의 경로 탐색 알고리즘은 &lt;strong>데이크스트라 알고리즘&lt;/strong>이나 &lt;strong>A* 알고리즘&lt;/strong>의 변종이다.(그래프 기반 최단거리 탐색)&lt;/p>
&lt;p>따라서 모든 경로 탐색 알고리즘은 교차로를 노드, 도로를 간선으로 표현하는 그래프 자료 구조를 가정한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_3.png"
width="1400"
height="639"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_3_hu7451bd66519cb9a67ca931e55612e325_1658967_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_3_hu7451bd66519cb9a67ca931e55612e325_1658967_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="그래프로 표현한 지도"
class="gallery-image"
data-flex-grow="219"
data-flex-basis="525px"
>&lt;/p>
&lt;p>대부분 경로 탐색 알고리즘은 주어진 그래프 크기에 성능이 좌우된다.&lt;/p>
&lt;p>따라서 성능을 위해 전 세계 도로망을 하나의 그래프로 표현하는 것이 아닌 &lt;strong>관리 가능 단위로 분할&lt;/strong>해야한다.&lt;/p>
&lt;p>타일 기반 분할법을 적용하여 세계를 작은 격자로 나누고, 각 격자 안의 도로망을 노드와 간선으로 구성된 그래프 자료구조로 변환한다.&lt;/p>
&lt;ul>
&lt;li>경로 안내 타일로 분할한다.&lt;/li>
&lt;li>각 타일은 도로로 연결된 다른 타일에 대한 참조를 유지한다.&lt;/li>
&lt;/ul>
&lt;p>도로망을 언제든 불러올 수 있는 경로 안내 타일로 분할해 놓으면 여러 장점이 있다.&lt;/p>
&lt;ul>
&lt;li>경로 탐색 알고리즘이 동ㅈ가하는 데 필요한 메모리 요구량을 낮출 수 있다.&lt;/li>
&lt;li>한 번에 처리해야 하는 경로의 양이 준다.&lt;/li>
&lt;li>필요한 만큼 만 불러오면 되므로 경로 탐색 성능도 좋아진다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>경로 안내 타일은 지도와 다르게 도로 데이터로 이루어진 이진 파일(binary file)이다.&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>&lt;strong>계층적 경로 안내 타일&lt;/strong>&lt;/p>
&lt;p>경로 안내가 효과적으로 동작하려면 &lt;strong>필요한 수준의 구체성&lt;/strong>을 갖춘 도로 데이터가 필요하다.&lt;/p>
&lt;p>보통 구체성 정도를 상, 중, 하로 구분하여 세 가지 종류의 경로 안내 타일을 준비한다.&lt;/p>
&lt;ul>
&lt;li>상
&lt;ul>
&lt;li>지방도(local roads) 데이터를 둔다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>중
&lt;ul>
&lt;li>규모가 비교적 큰 관할구(district)를 잇는 간선 도로 데이터를 둔다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>하
&lt;ul>
&lt;li>도시와 주를 연결하는 주요 고속도로 데이터만 둔다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_4.png"
width="1109"
height="910"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_4_hu07eab4d6f4ef51d47536904f92e584d5_498010_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_4_hu07eab4d6f4ef51d47536904f92e584d5_498010_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="크기가 서로 다른 경로 안내 타일"
class="gallery-image"
data-flex-grow="121"
data-flex-basis="292px"
>&lt;/p>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;p>설계 초점이 모바일 단말이므로, 데이터 사용량과 배터리 효율을 중요하게 따져 봐야 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>저장소 사용량 - 세계 지도&lt;/strong>&lt;/p>
&lt;p>지원하는 확대 수준(Zoom level)별로 지도 타일을 한 벌씩 두어야 한다.&lt;/p>
&lt;p>지도를 확대할 때 마다 하나의 타일을 네 장의 타일로 펼친다고 가정하면, 세계 지도를 21번 확대하여 볼 수 있으려면 최대 확대 수준을 대산으로 하였을 때 약 &lt;strong>4.4조&lt;/strong>개의 타일이 필요하다.&lt;/p>
&lt;ul>
&lt;li>한 장의 타일이 &lt;code>256 * 256&lt;/code> PNG 파일이라면 장당 100KB의 저장 공간이 필요하므로 440PB 만큼의 저장 공간이 필요하다.&lt;/li>
&lt;/ul>
&lt;p>하지만 지구 표면 가운데 90%는 인간이 살지 않는 자연 그대로의 바다, 사막, 호수, 산간 지역이라 아주 높은 비유롤 압축할 수 있다.&lt;/p>
&lt;p>보수적으로 80% ~ 90% 저장 용량을 절감할 수 있다고 가정하면, 50PB 정도 필요하다.&lt;/p>
&lt;p>1 ~ 21 까지 수준을 지원하기 위해 &lt;code>50 + (50/4) + (50/16) ... = ~ 67PB&lt;/code> 정도로 대충 100PB 정도가 소요된다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>서버 대역폭&lt;/strong>&lt;/p>
&lt;p>서버 대역폭을 추정하기 위해서는 어떤 유형의 요청을 처리해야 하는지 살펴 봐야 한다.&lt;/p>
&lt;ul>
&lt;li>경로 안내 요청
&lt;ul>
&lt;li>클라이언트가 경로 안내 세션을 시작할 때 전송하는 메시지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>위치 갱신 요청
&lt;ul>
&lt;li>클라이언트가 경로 안내를 진행하는 동안 변경된 사용자 위치를 전송하는 메시지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>경로 안내 요청을 처리하기 위한 대역폭을 계산해본다.&lt;/p>
&lt;ul>
&lt;li>DAU 10억, 평균 주당 35분 사용한다고 가정
&lt;ul>
&lt;li>하루에 50억 분&lt;/li>
&lt;li>요청을 클라이언트 쪽에 모아두었다가 덜 자주보내도록 하면 QPS를 낮출 수 있다.&lt;/li>
&lt;li>15초마다 한 번씩 보낸다고 가정하면 QPS는 20만&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_5.png"
width="710"
height="489"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_5_hu4e7e3e07d71836bb687df78814d2fbb6_116709_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_5_hu4e7e3e07d71836bb687df78814d2fbb6_116709_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="348px"
>&lt;/p>
&lt;ul>
&lt;li>위치 서비스&lt;/li>
&lt;li>경로 안내 서비스&lt;/li>
&lt;li>지도 표시&lt;/li>
&lt;/ul>
&lt;h3 id="위치-서비스">위치 서비스&lt;/h3>
&lt;p>사용자의 위치를 기록하는 역할을 담당한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart TD
mobile([모바일 사용자]) -->
loadBalancer[로드밸런서] -->
location[위치 서비스] -->
db[(사용자 위치 DB)]
&lt;/pre>
&lt;p>클라이언트가 &lt;strong>t&lt;/strong>초마다 자기 위치를 전송한다고 가정하는데, 주기적으로 위치 정보를 전송하면 몇 가지 좋은 점이 있다.&lt;/p>
&lt;ul>
&lt;li>해당 데이터 스트림을 활용하여 시스템을 점차 개선할 수 있다.
&lt;ul>
&lt;li>실시간 교통 상황 모니터링&lt;/li>
&lt;li>새로 만들어진 도로나 폐쇄된 도로 탐지&lt;/li>
&lt;li>사용자 행동 양태를 분석하여 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클라이언트가 보내는 위치 정보가 실시간 정보에 가까우므로 ETA를 좀 더 정확하게 산출할 수 있다.
&lt;ul>
&lt;li>교통 상황에 따라 다른 경로를 안내할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위치 이력을 클라이언트에 버퍼링해 두었다가 일괄 요청하면 전송 빈도를 줄일 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_6.png"
width="768"
height="230"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_6_hu4c9106ced49971975257ab1b7be74bab_135532_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_6_hu4c9106ced49971975257ab1b7be74bab_135532_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="일괄 요청"
class="gallery-image"
data-flex-grow="333"
data-flex-basis="801px"
>&lt;/p>
&lt;p>위치 갱신 요청 빈도를 줄여도 여전히 많은 쓰기 요청을 처리해야하므로 아주 높은 쓰기 요청 빈도에 최적화되어 있고 규모 확장이 용이한 카산드라같은 데이터베이스가 필요하다.&lt;/p>
&lt;p>카프카 같은 스트림 처리 엔진을 활용하여 위치 데이터를 로깅해야 할 수도 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">POST /v1/locations
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">body:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> locs: JSON으로 인코딩한 (위도, 경도, 시각) 순서쌍 배열
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="경로-안내-서비스">경로 안내 서비스&lt;/h3>
&lt;p>A에서 B 지점으로 가는 합리적으로 빠른 경로를 찾아 주는 역할을 담당한다.&lt;/p>
&lt;ul>
&lt;li>결과를 얻는 데 드는 시간 지연은 어느 정도 감내할 수 있다.&lt;/li>
&lt;li>최단 시간 경로일 필요는 없으나 정확도는 보장되어야 한다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GET /v1/nav?origin=1355+market+street,SF&amp;amp;destination=Disneyland
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="지도-표시">지도 표시&lt;/h3>
&lt;p>확대 수준별로 한 벌씩 지도 타일을 저장하려면 수백 PB가 필요하므로, 그 모두를 클라이언트가 가지고 있는 것은 실용적이지 않다.&lt;/p>
&lt;p>클라이언트의 위치 및 현재 클라이언트가 보는 확대 수준에 따라 필요한 타을을 서버에서 가져오는 접근법이 바람직하다.&lt;/p>
&lt;ul>
&lt;li>사용자가 지도를 확대 또는 이동시키며 주변을 탐색&lt;/li>
&lt;li>경로 안내가 진행되는 동안 사용자의 위치가 현재 지도 타일을 벗어나 인접한 타일로 이동&lt;/li>
&lt;/ul>
&lt;p>다량의 지도 타일 데이터를 효과적으로 가져오기 위해 아래와 같은 방법들을 고려할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>선택지 1&lt;/strong>&lt;/p>
&lt;p>클라이언트가 보는 지도의 확대 수준에 근거하여 필요한 지도 타일을 즉석에서 만든다.&lt;/p>
&lt;p>사용자 위치 및 확대 수준의 조합이 무한하므로 몇 가지 심각한 문제가 있다.&lt;/p>
&lt;ul>
&lt;li>모든 지도 타일을 동적으로 만들어야 하는 서버 클러스터에 심각한 부하가 걸린다.&lt;/li>
&lt;li>캐시를 활용하기 어렵다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>선택지 2&lt;/strong>&lt;/p>
&lt;p>미리 만들어 둔 지도 타일을 클라이언트에 전달하기만 한다.&lt;/p>
&lt;p>지도 타일이 담당하는 지리적 영역은 지오해싱 같은 분할법을 사용해 만든 고정된 사각형의 격자로 표현되어 정적이다.&lt;/p>
&lt;ul>
&lt;li>지도 타일이 필요할 경우 현재 확대 수준에 근거하여 필요한 지도 타일 집합을 결정하고, 각 위치를 지오해시 URL로 변환하여 보낸다.&lt;/li>
&lt;li>미리 만들어 둔 정적 이미지를 CDN을 통해 서비스한다.&lt;/li>
&lt;/ul>
&lt;p>이 접근법은 규모 확장이 용이하고 성능 측면에서도 유리하다.&lt;/p>
&lt;ul>
&lt;li>가장 가까운 POP에서 파일을 서비스한다.&lt;/li>
&lt;li>지도 타일은 정적이므로 캐시를 통해 서비스하기 아주 적합하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_7.png"
width="659"
height="633"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_7_hu95af23d21653015c716fa288ebdc0b72_148322_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_7_hu95af23d21653015c716fa288ebdc0b72_148322_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="CDN 기반 서비스 구조의 강점"
class="gallery-image"
data-flex-grow="104"
data-flex-basis="249px"
>&lt;/p>
&lt;p>지도 타일은 이미 정의된 격자에 맞게 확대 수준별로 한 벌식 미리 만들어 둔 것을 사용하게 된다.&lt;/p>
&lt;p>지오해시를 사용해 격자를 나누므로 모든 격자는 고유한 지오해시 값을 갖는다.&lt;/p>
&lt;p>따라서 위도/경도로 표현된 클라이언트의 위치 및 현재 지도 확대 수준을 입력으로 화면에 표시할 지도 타일에 대응되는 지오해시는 아주 쉽게 계산해 낼 수 있다.&lt;/p>
&lt;p>이 계산은 클라이언트가 수행하며, 해당 지오해시 및 URL로 CDN에서 지도 타일을 가져오면 된다.&lt;/p>
&lt;hr>
&lt;p>지오해시 계산은 클라이언트가 수행해되 괜찮지만, 알고리즘을 클라이언트 단에 구현할 경우 지원해야 할 플랫폼이 많을 때 문제가 될 수 있다.&lt;/p>
&lt;p>모바일 앱 업데이트 배포는 시간도 많이 걸리고 때로는 위험하므로 앞으로 오랫동안 맵 타일 인코딩에는 지오해싱을 사용해야한다는 전제가 있어야 한다.&lt;/p>
&lt;ul>
&lt;li>다른 방식으로 변경이 필요하다면 많은 노력과 위험이 따른다.&lt;/li>
&lt;/ul>
&lt;p>이에따라 주어진 위도/경도 및 확대 수준을 타일 URL로 변환하는 알고리즘 구현을 &lt;strong>별도 서비스&lt;/strong>에 두는 방법을 고려할 수 있다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart
user([user])
lb[로드밸런서]
service[지도 타일 서비스&lt;br/> 3. 타일 URL들을 생성]
cdn((CDN))
user---|'1. 타일 URL 집합 요청'| lb
lb---|'2. 요청 전달'| service
user---|'4. 타일 다운로드'| cdn
&lt;/pre>
&lt;p>새로운 위치로 이동하거나 확대 수준을 변경하면 지도 타일 서비스는 어떤 타일이 필요한지 결정하여 해당 타일들을 가져오는 데 필요한 URL 집합을 계산하여 응답한다.&lt;/p>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;h4 id="경로-안내-타일">경로 안내 타일&lt;/h4>
&lt;p>확보한 도로 데이터는 가공되지 않았기 때문에 &lt;strong>경로 안내 타일 처리 서비스&lt;/strong>라 불리는 오프라인 데이터 가공 파이프라인을 주기적으로 실행하여 경로 안내 타일로 변환해야한다.&lt;/p>
&lt;ul>
&lt;li>도로 데이터에 발생한 새로운 변경사항을 반영하기 위해 주기적으로 실행한다.&lt;/li>
&lt;/ul>
&lt;p>경로 안내 타일을 만들 때는 해당도를 달리 하여 세 벌(상, 중, 하) 만든다.&lt;/p>
&lt;ul>
&lt;li>그래프의 노드와 간선으로 표현된 해당 지역 내 교차로와 도로 정보&lt;/li>
&lt;li>다른 타일의 도로와 연결되는 경우 해당 타일에 대한 참조 정보 포함&lt;/li>
&lt;/ul>
&lt;p>경로 안내 알고리즘은 이들 타일이 모인 결과로 만들어지는 도로망 데이터를 점진적으로 소비한다.&lt;/p>
&lt;p>가공 결과로 만들어진 타일은 어디에 저장해야 할까?&lt;/p>
&lt;p>일반적으로 그래프 데이터는 메모리에 인접 리스트 형태로 보관하나, 메모리에 두기에는 양이 너무 많다.&lt;/p>
&lt;p>그래프의 노드와 간선을 데이터베이스 레코드로 저장하는 것 도 방법이겠지만 비용이 많이 들 것이며, 경로 안내 타일의 경우 데이터베이스가 제공하는 기능이 필요 없다.&lt;/p>
&lt;p>따라서 &lt;strong>S3 같은 객체 저장소에 파일을 보관&lt;/strong>하고 그 파일을 이용할 &lt;strong>경로 안내 서비스에서 적극적으로 캐싱&lt;/strong>하는 방법을 고려할 수 있다.&lt;/p>
&lt;p>위도와 경도가 주어졌을 때 타일을 신속하게 찾기 위해 지오해시 기준으로 분류해 두는 것이 좋다.&lt;/p>
&lt;h4 id="사용자-위치-데이터">사용자 위치 데이터&lt;/h4>
&lt;p>사용자의 위치 정보는 아주 값진 데이터다.&lt;/p>
&lt;ul>
&lt;li>도로 데이터 및 경로 안내 타일을 갱신하는데 이용된다.&lt;/li>
&lt;li>실시간 교통 상황 데이터나 교통 상황 이력 데이터베이스를 구축하는 데도 활용된다.&lt;/li>
&lt;li>데이터 스트림 프로세싱 서비스는 이 위치 데이터를 처리하여 지도 데이터를 갱신한다.&lt;/li>
&lt;/ul>
&lt;p>사용자 위치 데이터를 저장하려면 엄청난 양의 쓰기 연산을 잘 처리할 수 있으면서 수평적 규모 확장이 가능한 데이터베이스가 필요하다.&lt;/p>
&lt;ul>
&lt;li>카산드라&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>user_id&lt;/th>
&lt;th>timestamp&lt;/th>
&lt;th>user_mode&lt;/th>
&lt;th>driving_mode&lt;/th>
&lt;th>location&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>101&lt;/td>
&lt;td>1635740977&lt;/td>
&lt;td>active&lt;/td>
&lt;td>driving&lt;/td>
&lt;td>(20.0, 30.5)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="지오코딩-데이터베이스">지오코딩 데이터베이스&lt;/h4>
&lt;p>주소를 위도/경도 쌍으로 변환하는 정보를 보관한다.&lt;/p>
&lt;p>읽기 연산은 빈번한 반면 쓰기 연산은 드물게 발생하는 특성으로 레디스와 같이 빠른 읽기 연산을 제공하는 키-값 저장소가 적합하다.&lt;/p>
&lt;p>출발지와 목적지 주소는 경로 계획 서비스에 전달하기 전 이 데이터베이스를 통해 위도/경도 쌍으로 변환된다.&lt;/p>
&lt;h4 id="미리-만들어-둔-지도-이미지">미리 만들어 둔 지도 이미지&lt;/h4>
&lt;p>단말이 특정 영역의 지도를 요청하면 인근 도로 정보를 취합하여 모든 도로 및 관련 상세 정보가 포함된 이미지를 만들어 내야 한다.&lt;/p>
&lt;ul>
&lt;li>계산 자원을 많이 사용한다.&lt;/li>
&lt;li>같은 이미지를 중복 요청하는 경우가 많다.&lt;/li>
&lt;/ul>
&lt;p>이미지느 ㄴ한 번만 계산하고 그 결과는 캐시해 두는 전략을 쓰는 것이 좋다.&lt;/p>
&lt;p>이미지는 지도 표시에 사용하는 확대 수준 별로 미리 만들어 두고 CDN을 통해 전송한다.&lt;/p>
&lt;h3 id="서비스">서비스&lt;/h3>
&lt;h4 id="위치-서비스-1">위치 서비스&lt;/h4>
&lt;p>데이터베이스 설계 및 사용자 위치 정보가 이용되는 방식에 초점을 맞추어 상세 설계를 진행해본다.&lt;/p>
&lt;p>사용자 위치 데이터 저장에는 키-값 저장소를 활용한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart TD
mobile([모바일 사용자]) -->
loadBalancer[로드밸런서] -->
location[위치 서비스] -->
db[(사용자 위치 DB)]
&lt;/pre>
&lt;ul>
&lt;li>초당 백만 건의 위치 정보 업데이트가 발생한다는 점을 감안하면 쓰기 연산 지원에 탁월한 데이터베이스가 필요하다.&lt;/li>
&lt;li>사용자 위치는 계속 변화하며, 일단 변경되고 나면 이전 정보는 바로 무용해지므로, 데이터 일관성 보다는 가용성이 더 중요하다.
&lt;ul>
&lt;li>CAP 정리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 요구사항에는 &lt;strong>NoSQL 키-값 데이터베이스&lt;/strong>나 &lt;em>&lt;em>열-중심&lt;/em> 데이터베이스&lt;/em>(column-oriented database)가 적합하며, 이 중 가용성과 분할 내성 두가지를 만족 시키는 데이터베이스에는 &lt;strong>카산드라&lt;/strong>가 있다.&lt;/p>
&lt;hr>
&lt;p>데이터 베이스 키로는 &lt;code>(user_id, timestamp)&lt;/code> 조합을 사용하며, 해당 키에 매달리는 값으로 &lt;code>위도/경도&lt;/code> 쌍을 저장한다.&lt;/p>
&lt;ul>
&lt;li>user_id는 파티션 키
&lt;ul>
&lt;li>같은 파티션 키를 갖는 데이터는 함께 저장됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>timestamp는 클러스터링 키
&lt;ul>
&lt;li>클러스터링 키 값에 따라 정렬된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이렇게 해 두면 특정 사용자의 특정 기간 내 위치도 효율적으로 읽어낼 수 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>key(uesr_id)&lt;/th>
&lt;th>timestamp&lt;/th>
&lt;th>lat&lt;/th>
&lt;th>long&lt;/th>
&lt;th>user_mode&lt;/th>
&lt;th>navigation_mode&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>51&lt;/td>
&lt;td>132053000&lt;/td>
&lt;td>21.9&lt;/td>
&lt;td>89.8&lt;/td>
&lt;td>active&lt;/td>
&lt;td>driving&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="사용자-위치-데이터는-어떻게-이용되는가">사용자 위치 데이터는 어떻게 이용되는가&lt;/h4>
&lt;p>사용자 위치는 쓰임새가 다양한 중요 데이터다.&lt;/p>
&lt;ul>
&lt;li>새로 개설되었거나 폐쇄된 도로를 감지할 수 있다.&lt;/li>
&lt;li>지도 데이터의 정확성을 점차로 개선하는 입력으로 활용될 수 있다.&lt;/li>
&lt;li>실시간 교통 현황을 파악하는 입력이 될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이러한 용례를 지원하기 위해 사용자 위치를 데이터베이스에 기록하는 것과 별도로 &lt;strong>카프카&lt;/strong>와 같은 메시지 큐에 로깅한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_8.png"
width="802"
height="437"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_8_hu7e5de397c61cacf1f854f32e04691977_149242_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_8_hu7e5de397c61cacf1f854f32e04691977_149242_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="여러 서비스에 위치 데이터 제공"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="440px"
>&lt;/p>
&lt;p>개별 서비스들은 카프카를 통해 전달되는 사용자 위치 데이터 스트림을 각자 용도에 맞게 활용할 수 있다.&lt;/p>
&lt;h3 id="지도-표시-1">지도 표시&lt;/h3>
&lt;p>지도 타일을 미리 만들어 놓는 방법과 지도 표시 최적화 기법을 살펴본다.&lt;/p>
&lt;h4 id="지도-타일-사전-계산">지도 타일 사전 계산&lt;/h4>
&lt;p>사용자가 보는 지도 크기나 확대 수준에 맞는 세부사항을 보여주기 위해 확대 수준별 지도 타일을 미리 만들어 둘 필요가 있다.&lt;/p>
&lt;ul>
&lt;li>구글맵은 21단계로 지도를 확대할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>확대 수준 0은 세계 전부를 256 * 256 픽셀짜리 타일 하나로 표현하며, 1단계 올릴 때마다 동서, 남북 방향으로 2배 씩 늘어난다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_9.png"
width="623"
height="365"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_9_hufe332efd68ce7553509f6a6bfaaa3fd6_248243_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_9_hufe332efd68ce7553509f6a6bfaaa3fd6_248243_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="확대 수준별 지도"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="409px"
>&lt;/p>
&lt;p>따라서 해상도도 4배 증가하게 된다.&lt;/p>
&lt;p>이렇게 늘어난 해상도 덕에 사용자에게 더 상세한 정보를 제공할 수 있으며, 클라이언트는 해당 정보를 제공하기 위한 타을을 다운 받는 데 많은 네트워크 대역폭을 소진하지 않고도 클라이언트에 설정된 확대 수준에 최적인 크기의 지도를 표시할 수 있다.&lt;/p>
&lt;h4 id="최적화-벡터-사용">최적화: 벡터 사용&lt;/h4>
&lt;p>지도 표시에 WebGL 기술을 채택하여 이미지 대신 경로와 다각형 등의 벡터 정보를 보낸다.&lt;/p>
&lt;ul>
&lt;li>벡터 타일은 이미지에 비해 월등한 압축률을 가지므로 네트워크 대역폭을 많이 아낄 수 있다.&lt;/li>
&lt;li>레스터 방식 이미지(Rasterized image)는 확대 수준을 높이는 순간 이미지가 늘어지고 픽셀이 도드라져 보이는 것과 달리 벡터화 된 이미지는 이러한 단점이 없다.&lt;/li>
&lt;/ul>
&lt;h3 id="경로-안내-서비스-1">경로 안내 서비스&lt;/h3>
&lt;p>경로 안내 서비스는 가장 빠른 경로를 안내하는 역할을 담당한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart
ac(모바일 사용자)
lb[로드밸런서]
ns[경로 안내 서비스]
gs[지오코딩 서비스]
nps[경로 계획 서비스]
rnks[순위 결정 서비스]
fsns[최단 경로 서비스]
arrs[예상 도착 서비스]
pss[실시간 교통 상황 서비스]
gdb(지오코딩 DB)
ndb(경로 안내 타일 DB)
pdb(교통량 DB)
udb(사용자 위치 DB)
ac-->lb
lb-->ns
ns-->gs
ns-->nps
gs-->gdb
nps-->fsns
nps-->rnks
nps-->arrs
fsns-->ndb
arrs-->pdb
pss-->pdb
pss-->udb
&lt;/pre>
&lt;h4 id="지오코딩-서비스">지오코딩 서비스&lt;/h4>
&lt;p>주소를 위도와 경도 쌍으로 바꾸어준다.&lt;/p>
&lt;p>주소의 표현 방식은 다양할 수 있다는 점을 고려해야한다.&lt;/p>
&lt;ul>
&lt;li>장소 이름으로 나타낸 주소&lt;/li>
&lt;li>지번 형태로 나타낸 주소 등&lt;/li>
&lt;/ul>
&lt;p>경로 안내 서비스는 이 서비스를 호출하여 출발지와 목적지 주소를 위도/경도 쌍으로 변환한 뒤 추후 다른 서비스 호출에 이용한다.&lt;/p>
&lt;h4 id="경로-계획-서비스">경로 계획 서비스&lt;/h4>
&lt;p>경로 계획 서비스(route planner service)는 현재 교통 상황과 도로 상태에 입각하여 이동 시간 측면에서 최적화된 경로를 제안한다.&lt;/p>
&lt;h4 id="최단-경로-서비스">최단 경로 서비스&lt;/h4>
&lt;p>최단 경로 서비스(shortest path service)는 출발지와 목적지 위도/경도를 입력으로 받아 k개의 최단 경로를 반환하는 서비스이다.&lt;/p>
&lt;p>이때 교통이나 도로 상황은 고려하지 않고, 도로 구조에만 의존하여 계산을 수행한다.&lt;/p>
&lt;ul>
&lt;li>도로망 그래프는 거의 정적이므로 캐시해 두면 좋다.&lt;/li>
&lt;/ul>
&lt;p>최단 경로 서비스는 객체 저장소에 저장된 경로 안내 타일에 대해 A* 경로 탐색 알고리즘의 한 형태를 실행한다.&lt;/p>
&lt;ol>
&lt;li>입력으로 출발지와 목적지의 위도/경도를 받는다.
&lt;ul>
&lt;li>이 위치 정보를 지오해시로 변호나한 다음 출발지와 목적지 경로 안내 타일을 얻는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>출발지 타일에서 시작하여 그래프 자료 구조를 탐색해 나간다.
&lt;ul>
&lt;li>탐색 범위를 넓히는 과정에서 필요한 주변 타일은 객체 저장소(캐시)에서 가져온다.&lt;/li>
&lt;li>같은 지역의 다른 확대 수준 타일로도 연결이 존재할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>최단 경로가 충분히 확보될 때까지 알고리즘은 검색 범위를 계속 확대해 나가면서 필요한 만큼 타일을 가져오는 작업을 반복한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_11.png"
width="1080"
height="458"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_11_huf7f7afc7caa46f16dc28ef7b8c08d390_800218_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_11_huf7f7afc7caa46f16dc28ef7b8c08d390_800218_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="그래프 탐색"
class="gallery-image"
data-flex-grow="235"
data-flex-basis="565px"
>&lt;/p>
&lt;h4 id="예상-도착-시간-서비스">예상 도착 시간 서비스&lt;/h4>
&lt;p>경로 계획 서비스는 최단 경로 목록을 수신하면 예상 도착 시간 서비스를 호출하여 그 경로 각각에 대한 소요 시간 추정치를 구한다.&lt;/p>
&lt;p>기계 학습을 활용해 현재 교통 상황 및 과거 이력에 근거하여 예상 도착 시간을 계산한다.&lt;/p>
&lt;p>이 때 실시간 교통 상황 데이터 뿐만 아니라 앞으로 10분에서 20분 뒤의 교통 상황이 어떻게 달라질지도 예측해야한다.&lt;/p>
&lt;h4 id="순위-결정-서비스">순위 결정 서비스&lt;/h4>
&lt;p>ETA 예상치를 구하고 나면 순위 결정 서비스(ranker)에 관련 정보를 모두 전달하여 사용자가 정의한 필터링 조건을 적용한다.&lt;/p>
&lt;ul>
&lt;li>유료 도로 제외, 고속도로 제외 등&lt;/li>
&lt;/ul>
&lt;p>필터링이 끝나고 남은 경로를 소요 시간 순으로 정렬하여 최단 시간 경로 k개를 구한 후 경로 안내 서비스에 결과를 반환한다.&lt;/p>
&lt;h4 id="중요-정보-갱신-서비스들">중요 정보 갱신 서비스들&lt;/h4>
&lt;p>이 부류의 서비스는 &lt;strong>카프카 위치 데이터 스트림&lt;/strong>을 구독하고 있다가 중요 데이터를 비동기적으로 업데이트하여 그 상태를 항상 최신으로 유지하는 역할을 담당한다.&lt;/p>
&lt;ul>
&lt;li>실시간 교통 정보 데이터베이스
&lt;ul>
&lt;li>활성화 상태 사용자가 보내는 위치 데이터 스트림에서 교통 상황 정보를 추출&lt;/li>
&lt;li>실시간 교통 상황 데이터베이스에 반영되어 예상 도착 시간 서비스가 더욱 정확한 결과를 내는데 쓰인다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>경로 안내 타일
&lt;ul>
&lt;li>도로 데이터에 새로 발견된 도로, 폐쇄되었음이 확인된 도로 정보를 반영하여 경로 안내 타일을 지속적으로 갱신&lt;/li>
&lt;li>최단 경로 서비스는 더 정확한 결과를 낼 수 있게 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="적응형-eta와-경로-변경">적응형 ETA와 경로 변경&lt;/h4>
&lt;p>이 문제를 해결하려면 서버는 현재 경로 안내를 받고 있는 모든 사용자를 추적하면서 교통 상황이 달라질 때마다 각 사용자의 ETA를 변경해 주어야 한다.&lt;/p>
&lt;ul>
&lt;li>현재 경로 안내를 받고 있는 사용자는 어떻게 추적하나?&lt;/li>
&lt;li>수백만 경로 가운데 교통 상황 변화에 영향을 받는 경로와 사용자를 효율적으로 가려낼 방법은?&lt;/li>
&lt;/ul>
&lt;p>사용자 &lt;code>user_1&lt;/code>이 안내받은 경로가 경로 안내 타일 &lt;code>r_1&lt;/code> &amp;hellip; &lt;code>r_7&lt;/code> 구성되어 있다고 가정한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_12.png"
width="460"
height="179"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_12_hu280e0708fed9cf1f12a8aef8bbdf84a8_41297_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_12_hu280e0708fed9cf1f12a8aef8bbdf84a8_41297_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="안내된 경로"
class="gallery-image"
data-flex-grow="256"
data-flex-basis="616px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>효율적이지 않은 방법&lt;/strong>&lt;/p>
&lt;p>사용자와 경로 정보를 데이터 베이스에 저장한다고 하면 아래와 같을 것 이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">user_1: r_1, r_2 ..., r_k
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">user_2: r_1, r_2 ..., r_n
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">user_3: r_2, r_3 ..., r_m
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">user_4: r_3, r_10 ..., r_l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이 때 r_2에서 교통 사고가 발생했다면, 어떤 사용자가 영향을 받는지 알아내기 위해 레코드를 전수 조사해야한다.&lt;/p>
&lt;p>테이블에 보관된 레코드 수가 n이고 안내되는 경로의 평균 길이가 m이라면 모든 사용자 검색의 시간 복잡도는 &lt;code>O(n * m)&lt;/code>이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>개선된 방법&lt;/strong>&lt;/p>
&lt;p>경로 안내를 받는 사용자 각가의 현재 경로 안내 타일, 그 타일을 포함하는 상위 타일(확대 수준이 더 낮은 타일), 그 상위 타일의 상위 타일을 출발지와 목적지가 모두 포함된 타일을 찾을 때까지 재귀적으로 더하여 보관한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">user_1, r_1, super(r_1), super(super(r_1)), ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_13.png"
width="626"
height="576"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_13_hue7d0c9d50a34906b9535c0723874c0aa_123912_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_13_hue7d0c9d50a34906b9535c0723874c0aa_123912_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="재귀적인 경로 타일 수집"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="260px"
>&lt;/p>
&lt;p>어떤 타일의 교통 상황이 변했을 때 경로 안내 ETA가 달라지는 사용자는, 해당 사용자의 데이터베이스 레코드 마지막 타일에 그 타일이 속하는 사용자가 된다.&lt;/p>
&lt;p>그 이외의 사용자에게는 아무런 영향이 없으므로 검색 시간 복잡도가 &lt;code>O(n)&lt;/code>으로 줄어들어 좀 더 효율적이다.&lt;/p>
&lt;p>그러나 이 접근법은 교통 상황이 개선되었을 때 해야 하는 일까지 해결해 주지는 않는다.&lt;/p>
&lt;p>예를 들어 타일 2의 교통 상황이 회복되어서 사용자가 옛날 경로로 돌아가도 된다고 할 때 경로 재설정이 가능하다는 사실을 감지하고 알려야한다.&lt;/p>
&lt;p>한 가지 방안은 현재 경로 안내를 받는 사용자가 이용 가능한 경로의 ETA를 주기적으로 재계산하여 더 짧은 ETA를 간즞 경로가 발견되면 알리는 것 이다.&lt;/p>
&lt;h4 id="전송-프로토콜">전송 프로토콜&lt;/h4>
&lt;p>경로 안내 중에 경로 상황이 변경될 수 있으므로, 데이터를 모바일 클라이언트에 전송할 안정적인 방법이 필요하다.&lt;/p>
&lt;p>이 경우 서버에서 클라이언트로 데이터를 보내는 데 활용할 수 있는 프로토콜로는 모바일 푸시 알림, 롱 폴링, 웹소켓, 서버 전송 이벤트 등이 있다.&lt;/p>
&lt;ul>
&lt;li>모바일 푸시 알림
&lt;ul>
&lt;li>메시지 크기가 매우 제한적이므로 사용하지 않는 게 바람직하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹소켓
&lt;ul>
&lt;li>서버에 주는 부담이 크지 않아 일반적으로 롱 폴링보다 좋은 방안으로 본다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>웹소켓 SSE 모두 괜찮은 방법이지만 본 설계안에서는 웹소켓을 사용한다.&lt;/p>
&lt;ul>
&lt;li>양방향 통신을 지원하여 패키지나 상품이 목적지에 가까워졌을 때는 실시간 양방향 통신이 필요한 경우도 있기 때문&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_10.png"
width="1540"
height="1240"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_10_huef52c7d9d52a678b3a7058ace4c6f3a8_129189_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_10_huef52c7d9d52a678b3a7058ace4c6f3a8_129189_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="최종 설계안"
class="gallery-image"
data-flex-grow="124"
data-flex-basis="298px"
>&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>시스템의 확장에 관심이 있다면, 기업 고객 대상으로 중간 경유지 설정 기능을 제공하는 것을 고려해보면 좋다.&lt;/p>
&lt;ul>
&lt;li>하나가 아닌 여러 목적지를 입력으로 하면 그 모두를 어떤 순서로 방문해야 가장 빨리 경유할 수 있을지 실시간 교통 상황을 고려하여 안내&lt;/li>
&lt;li>도어대시, 우버, 리프트 같은 배달 서비스에 유용&lt;/li>
&lt;/ul></description></item><item><title>2. 주변 친구</title><link>https://codemario318.github.io/post/system-design-interview-2/2/</link><pubDate>Sun, 18 Aug 2024 15:59:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/2/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/cover.png" alt="Featured image of post 2. 주변 친구" />&lt;p>이번 장에서는 &lt;strong>주변 친구&lt;/strong>(&lt;strong>nearby friends&lt;/strong>)라는 모바일 앱 기능을 지원하는 규모 확장이 용이한 백엔드 시스템을 설계해본다.&lt;/p>
&lt;blockquote>
&lt;p>앱 사용자 가운데 본인 위치 정보 접근 권한을 허락한 사용자에 한에 인근의 친구 목록을 보여주는 시스템&lt;/p>
&lt;/blockquote>
&lt;p>1장 &lt;strong>근접성 서비스&lt;/strong>와 &lt;strong>주변 친구&lt;/strong> 는 비슷해 보이지만 큰 차이가 있다.&lt;/p>
&lt;ul>
&lt;li>근접성 서비스의 사업장 주소는 정적이다.&lt;/li>
&lt;li>주변 친구 위치는 자주 바뀐다.&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>페이스북 규모를 지원하는 백엔드 시스템은 복잡하다. 따라서 설계 시작 전 질문을 통해 설계 범위를 좁혀야한다.&lt;/p>
&lt;ul>
&lt;li>Q. 지리적으로 얼마나 가까워야 &lt;strong>주변에 있다&lt;/strong>고 할 수 있는가?
&lt;ul>
&lt;li>A. 5마일. 이 수치는 설정 가능해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 두 사용자 사이의 직선 거리라고 가정?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 얼마나 많은 사용자가 이 앱을 사용하는가? 10억명을 가넝하고, 그 가운데 10% 정도가 이 기능을 활용한다고 생각해도 괜찮은가?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 사용자의 이동 이력을 보관해 둬야하는가?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 친구 관계에 있는 사용자가 10분 이상 비활성 상태면 해당 사용자를 주변 친구 목록에서 사라지도록 해야하는가? 마지막 확인 위치를 표시하는가?
&lt;ul>
&lt;li>A. 사라지게 할 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. GDPR, CCPA 같은 사생활 및 데이터 보호법도 고려해야하는가?
&lt;ul>
&lt;li>A. 과정이 너무 복잡해질 수 있으므로 배제&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="기능-요구사항">기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>사용자는 모바일 앱에서 &lt;strong>주변 친구를 확인&lt;/strong>할 수 있어야 한다.
&lt;ul>
&lt;li>&lt;strong>해당 친구까지의 거리&lt;/strong> 표시&lt;/li>
&lt;li>정보가 &lt;strong>마지막으로 갱신된 시간&lt;/strong>이 함께 표시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이 친구 목록은 &lt;strong>몇 초마다 한번 씩 갱신&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>낮은 지연 시간&lt;/strong>(low latency)
&lt;ul>
&lt;li>주변 친구의 위치 변화가 반영되는 데 너무 오랜 시간이 걸리지 않아야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>안정성&lt;/strong>
&lt;ul>
&lt;li>전반적으로 안정적이어야 하지만, 가끔 몇 개 데이터가 유실되는 것 정도는 용인 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>결과정 일관성&lt;/strong>
&lt;ul>
&lt;li>위치 데이터를 저장하기 위해 강한 일관성을 지원하는 데이터 저장소를 사용할 필요는 없다.&lt;/li>
&lt;li>복제본의 데이터가 원본과 동일하게 변경되기까지 몇 초 정도 걸리는 것은 용인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;p>제시할 솔루션이 풀어야 할 도전적 과제를 결정하기 위해, 개략적으로 문제 규모를 추정한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>주변 친구&lt;/strong>는 5마일(8km) 반경 이내 친구로 정의&lt;/li>
&lt;li>위치 정보는 &lt;strong>30초&lt;/strong> 주기로 갱신
&lt;ul>
&lt;li>사람의 걷는 속도가 &lt;code>4-6km/h&lt;/code> 정도로 느림&lt;/li>
&lt;li>30초 주기라면 주변 친구 검색 결과가 크게 달라지지는 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>평균적으로 매일 주변 친구 검색 기능을 활용하는 사용자는 &lt;strong>1억명&lt;/strong>으로 가정&lt;/li>
&lt;li>동시 접속 사용자의 수는 **DAU의 10%**로 가정
&lt;ul>
&lt;li>&lt;strong>천만명&lt;/strong>이 동시에 시스템을 이용한다고 가정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>평균적으로 한 사용자는 &lt;strong>400명&lt;/strong>의 친구를 갖는다고 가정&lt;/li>
&lt;li>모든 친구가 주변 친구 검색 기능을 활용한다고 가정&lt;/li>
&lt;li>이 기능을 제공하는 앱은 한 페이지당 20명의 주변 친구를 표시&lt;/li>
&lt;li>사용자의 요청이 있다면 더 많은 주변 친구를 노출&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>QPS 계산&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>1억 DAU&lt;/li>
&lt;li>동시 접속 사용자: &lt;code>10% * 1억 = 천만&lt;/code>&lt;/li>
&lt;li>사용자는 30초마다 자기 위치를 시스템에 전송&lt;/li>
&lt;li>&lt;code>위치 정보 갱신 QPS = 천만 / 30 = ~334,000&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>위치 정보를 모든 친구에게 전송해야 한다는 요구사항으로 인해 클라이언트와 서버 사이의 통신 프로토콜로 단순한 HTTP 프로토콜을 사용하지 못하게 될 수 있음을 감안해야한다.&lt;/p>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>이번 문제는 &lt;strong>메시지의 효과적 전송을 가능케 할 설계얀&lt;/strong>을 요구한다.&lt;/p>
&lt;p>개념적으로 보면 사용자는 근방의 모든 활성 상태 친구의 새 위치 정보를 수신하고자 한다. 이론적으로 순수한 P2P(peer-to-peer) 방식으로도 해결 가능한 문제이다.&lt;/p>
&lt;p>다시 말해, &lt;strong>활성 상태인 근방 모든 친구와 항구적 통신 상태를 유지&lt;/strong>하면 되는 것이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img.png"
width="898"
height="582"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_hudccc12625b6529e9eab4e26e4b039577_67180_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_hudccc12625b6529e9eab4e26e4b039577_67180_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="154"
data-flex-basis="370px"
>&lt;/p>
&lt;p>P2P 통신은 실용적인 아이디어는 아니지만 &lt;strong>추구해야 할 설계 방향에 대한 통찰&lt;/strong>은 얻을 수 있다.&lt;/p>
&lt;p>이보다 조금 더 실용적인 설계안은 &lt;strong>공용 백엔드&lt;/strong>를 사용하는 것이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_1.png"
width="1184"
height="552"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_1_hu5459bc5b3622841e964dbbf3c2d834b0_49710_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_1_hu5459bc5b3622841e964dbbf3c2d834b0_49710_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="214"
data-flex-basis="514px"
>&lt;/p>
&lt;p>백엔드는 다음과 같은 역할을 담당한다.&lt;/p>
&lt;ul>
&lt;li>모든 활성 상태 사용자의 위치 변화 내역을 수신&lt;/li>
&lt;li>사용자 위치 변경 내역을 수신할 때마다 해당 사용자의 모든 활성 상태 친구를 찾아 그 친구들의 단말로 변경 내역을 전달
&lt;ul>
&lt;li>두 사용자 사이의 거리가 특정 임계치보다 먼 경우 변경 내역을 전송하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>간단해 보이지만 문제의 가정이 활성 상태의 동시 접속 사용자 천만 명이므로 &lt;strong>큰 규모에 적용하기가 쉽지 않다&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>천만명이 자기 위치 정보를 30초마다 갱신하면 &lt;strong>334,000번&lt;/strong>의 위치 정보 갱신 처리가 필요하다.&lt;/li>
&lt;li>사용자 1명은 400명의 친구를 가지고, 그 중 10%가 인근에서 활성화 상태라면, 초당 &lt;code>334,000 * 400 * 10% = 1400만&lt;/code> 건의 위치 정보 갱신 요청을 처리해야한다.&lt;/li>
&lt;li>엄청난 양의 갱신 내역을 사용자 단말로 보내야한다.&lt;/li>
&lt;/ul>
&lt;h3 id="설계안">설계안&lt;/h3>
&lt;p>우선 소규모 백엔드를 위한 개략적 설계안에서 시작하여 더 큰 규모에 맞게 확장해나간다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_2.png"
width="1422"
height="1266"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="269px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>로드 밸런서&lt;/strong>&lt;/p>
&lt;p>&lt;strong>RESTful API&lt;/strong> 서버 및 양방향 유상태 웹소켓 서버 앞단에 위치한다.&lt;/p>
&lt;p>부하를 고르게 분산하기 위해 &lt;strong>트래픽을 서버들에 배분&lt;/strong>하는 역할을 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>RESTful API 서버&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>무상태 API 서버의 클러스터&lt;/li>
&lt;li>통상적인 요청/응답 트래픽을 처리&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>친구를 추가/삭제&lt;/strong>하거나 &lt;strong>사용자 정보를 갱신&lt;/strong>하는 등의 부가적인 작업을 처리한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>웹소켓 서버&lt;/strong>&lt;/p>
&lt;p>친구 위치 정보 변경을 거의 실시간에 가깝게 처리하는 &lt;strong>유상태 서버 클러스터&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>각 클라이언트는 클러스터 내 한 대 서버와 웹소켓 연결은 지속적으로 유지&lt;/li>
&lt;li>검색 반경 내 친구 위치가 변경되면 해당 내역은 이 연결을 통해 클라이언트로 전송&lt;/li>
&lt;li>주변 친구 기능을 이용하는 클라이언트의 초기화 담당
&lt;ul>
&lt;li>온라인 상태인 모든 주변 친구 위치를 해당 클라이언트로 전송&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>레디스 위치 정보 캐시&lt;/strong>&lt;/p>
&lt;p>활성 상태 사용자의 가장 최근 위치 정보를 캐시하는 데 사용한다.&lt;/p>
&lt;ul>
&lt;li>레디스에 보관하는 캐시 항목에는 TTL(Time-To-Live) 필드가 있어, 설정한 기간이 지나면 해당 사용자는 비활성으로 바뀌고 위치 정보는 캐시에서 삭제된다.&lt;/li>
&lt;li>캐시에 보관된 정보를 갱신할 때 TTL도 갱신한다.&lt;/li>
&lt;/ul>
&lt;p>레디스가 아니더라도 TTL을 지원하는 키-값 저장소는 캐시로 활용될 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>사용자 데이터 베이스&lt;/strong>&lt;/p>
&lt;p>&lt;strong>사용자 데이터&lt;/strong> 및 &lt;strong>사용자의 친구 관계 정보를 저장&lt;/strong>한다.&lt;/p>
&lt;p>관계형 데이터베이스, NoSQL 어느 쪽이든 사용 가능하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>위치 이동 이력 데이터베이스&lt;/strong>&lt;/p>
&lt;p>사용자의 위치 변동 이력을 보관한다.&lt;/p>
&lt;p>주변 친구 표시와 직접 관계된 기능은 아니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>레디스 펍/섭 서버&lt;/strong>&lt;/p>
&lt;p>레디스 펍/섭은 &lt;strong>초경량 메시지 버스&lt;/strong>(message bus)다.&lt;/p>
&lt;ul>
&lt;li>레디스 펍/섭에 새로운 채널을 생성하는 것은 아주 값싼 연결이다.&lt;/li>
&lt;li>기가바이트급 메모리를 갖춘 최신 레디스 서버에는 수백만 개의 채널(토픽)을 생성할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_4.png"
width="1380"
height="740"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_4_hu84b0294fda6052ece73743e1e4417308_92336_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_4_hu84b0294fda6052ece73743e1e4417308_92336_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="186"
data-flex-basis="447px"
>&lt;/p>
&lt;ol>
&lt;li>웹소켓 서버를 통해 수신한 &lt;strong>특정 사용자의 위치 정보 변경 이벤트&lt;/strong>는 &lt;strong>해당 사용자에게 배정된 펍/섭 채널에 발행&lt;/strong>한다.
&lt;ul>
&lt;li>해당 사용자의 친구 각각과 연결된 웹소켓 연결 핸들러는 해당 채널의 구독자로 설정되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>특정 사용자의 위치가 바뀌면 해당 사용자의 모든 친구의 웹소켓 연결 핸들러가 호출된다.&lt;/li>
&lt;li>핸들러는 위치 변경 이벤트를 수신할 친구가 활성 상태면 거리를 다시 계산한다.
&lt;ul>
&lt;li>검색 반경 이내면 갱신된 위치와 갱신 시간을 웹소켓 연결을 통해 해당 친구의 클라이언트 앱으로 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>다른 메시지 버스 기술도 경량의 통신 채널만 제공한다면 같은 형태로 사용 가능하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>주기적 위치 갱신&lt;/strong>&lt;/p>
&lt;p>모바일 클라이언트는 항구적으로 유지되는 웹소켓 연결을 통해 주기적으로 위치 변경 내역을 전송한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_2.png"
width="1422"
height="1266"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="269px"
>&lt;/p>
&lt;ol>
&lt;li>모바일 클라이언트가 위치가 변경된 사실을 로드밸런서에 전송&lt;/li>
&lt;li>로드밸런서는 그 위치 변경 내역을 해당 클라이언트와 웹소켓 서버 사이에 설정된 연결을 통해 웹소켓 서버로 보냄&lt;/li>
&lt;li>아래 작업을 병렬로 수행
&lt;ul>
&lt;li>웹소켓 서버는 해당 이벤트를 위치 이동 이력 데이터베이스에 저장&lt;/li>
&lt;li>웹소켓 서버는 새 위치를 위치 정보 캐시에 보관
&lt;ul>
&lt;li>TTL도 새롭게 갱신&lt;/li>
&lt;li>웹소켓 연결 핸들러 안의 변수에 해당 위치를 반영(거리 계산에 활용)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹소켓 서버는 레디스 펍/섭 서버의 해당 사용자 채널에 새 위치를 발행&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>레디스 펍/섭 채널에 발행된 새로운 위치 변경 이벤트는 모든 구독자(웹소켓 이벤트 핸들러)에게 브로드캐스트된다.
&lt;ul>
&lt;li>구독자는 위치 변경 이벤트를 보낸 사용자의 온라인 상태 친구들&lt;/li>
&lt;li>구독자의 웹소켓 연결 핸들러는 친구의 위치 변경 이벤트를 수신&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지를 받는 웹 소켓 서버, 즉 웹 소켓 연결 핸들러가 위치한 웹 소켓 서버는 새 위치를 보낸 사용자와 메시지를 받은 사용자 사이의 거리를 새로 계산
&lt;ul>
&lt;li>검색 반경을 넘지 않는다면 새 위치 및 해당 위치로의 이동이 발생한 시각을 나타내는 타임스탬프를 해당 구독자의 클라이언트 앱으로 전송&lt;/li>
&lt;li>넘은 경우에는 보내지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_5.png"
width="1362"
height="1182"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_5_huf8fa9909ecee52bd94a35a1416186d93_155836_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_5_huf8fa9909ecee52bd94a35a1416186d93_155836_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="276px"
>&lt;/p>
&lt;ol>
&lt;li>사용자 1의 위치가 변경되면 그 변경 내역은 사용자 1과의 연결을 유지하고 있는 웹소켓 서버에 전송됨&lt;/li>
&lt;li>해당 변경 내역은 레디스 펍/섭 서버 내의 사용자 1 전용 채널로 발행&lt;/li>
&lt;li>레디스 펍/섭 서버는 해당 변경 내역을 모든 구독자에게 브로드캐스트한다.
&lt;ul>
&lt;li>구독자는 사용자 1과 친구 관계에 있는 모든 웹소켓 연결 핸들러&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>위치 변경 내역을 보낸 사용자와 구독자 사이의 거리(사용자 1과 2 사이의 거리)가 검색 반경을 넘지 않을 경우 새로운 위치는 사용자 2의 클라이언트로 전송&lt;/li>
&lt;/ol>
&lt;p>이 계산 과정은 해당 채널의 모든 구독자에게 반복 적용된다.&lt;/p>
&lt;ul>
&lt;li>한 사용자의 위치가 바뀔 때마다 이치 정보 전송은 40건 정도 발생할 것이다.&lt;/li>
&lt;/ul>
&lt;h3 id="api-설계">API 설계&lt;/h3>
&lt;p>필요한 API를 나열해본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>웹소켓&lt;/strong>&lt;/p>
&lt;p>사용자는 웹소켓 프로토콜을 통해 위치 정보 변경 내역을 전송하고 수신하므로, 최소한 다음 API는 구비되어야 한다.&lt;/p>
&lt;ul>
&lt;li>[서버 API] 주기적인 위치 정보 갱신
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>위도, 경도, 시각 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[클라이언트 API] 클라이언트가 갱신된 친구 위치를 수신하는 데 사용할 API
&lt;ul>
&lt;li>전송되는 데이터
&lt;ul>
&lt;li>친구 위치 데이터와 변경된 시각을 나타내는 타임스탬프&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[서버 API] 웹소켓 초기화 API
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>위도, 경도, 시각 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>자기 친구들의 위치 데이터&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[클라이언트 API] 새 친구 구독 API
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>친구 ID&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>가장 최근의 위도, 경도, 시각 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[클라이언트 API] 구독 해지 API
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>친구 ID&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>HTTP 요청&lt;/strong>&lt;/p>
&lt;p>API 서버는 친구를 추가/삭제하거나 사용자 정보를 갱신하는 드으이 작업을 처리할 수 있어야 한다.&lt;/p>
&lt;p>아주 흔한 종류의 API이므로 상세한 내용은 다루지 않는다.&lt;/p>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>살펴봐야하는 중요한 주제중 하나는 데이터 모델이다.&lt;/p>
&lt;p>위치 정보 캐시와 위치 이동 이력 데이터베이스만 살펴본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>위치 정보 캐시&lt;/strong>&lt;/p>
&lt;p>위치 정보 캐시는 &lt;strong>주변 친구&lt;/strong>기능을 켠 활성 상태 친구의 가장 최근 위치를 보관한다.&lt;/p>
&lt;p>설계안에서는 레디스를 사용해 이 키새를 구현하며, 해당 캐시에 보관될 키/값 쌍은 아래와 같다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>키&lt;/th>
&lt;th>값&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>사용자 ID&lt;/td>
&lt;td>{위도, 경도, 시각}&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;p>&lt;strong>위치 정보 저장에 데이터베이스를 사용하지 않는 이유는?&lt;/strong>&lt;/p>
&lt;p>주변 친구 기능은 사용자의 &lt;strong>현재 위치&lt;/strong>만 사용하므로, 사용자 위치는 하나만 보관하면 충분하다.&lt;/p>
&lt;ul>
&lt;li>읽기 및 쓰기 연산 속도가 매우 빠르다.&lt;/li>
&lt;li>TTL을 지원하여 활성 상태가 아닌 사용자 정보를 자동으로 제거할 수 있다.&lt;/li>
&lt;li>활용하는 위치 정보는 영속성을 보장할 필요가 없다.&lt;/li>
&lt;li>장애 발생시 새 서버로 바꾼 후 갱신된 위치 정보가 캐시에 채워지기만 하면 충분하다.
&lt;ul>
&lt;li>캐시가 데워질 동안은 갱신 주기가 한두 번 정도 경과하여 변경 내역을 놓칠 수도 있지만 수용 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>위치 이동 이력 데이터베이스&lt;/strong>&lt;/p>
&lt;p>위치 이동 이력 데이터베이스는 사용자의 위치 정보 변경 이력을 다음 스키마를 따르는 테이블에 저장한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>user_id&lt;/th>
&lt;th>latitude&lt;/th>
&lt;th>longitude&lt;/th>
&lt;th>timestamp&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>필요로 하는 것은 &lt;strong>막대한 쓰기 연산 부하를 감당&lt;/strong>할 수 있고, &lt;strong>수평적 규모 확장이 가능&lt;/strong>한 데이터베이스다.&lt;/p>
&lt;p>&lt;strong>카산드라&lt;/strong>(Cassandra)는 이러한 요구에 잘 부합한다.&lt;/p>
&lt;ul>
&lt;li>관계형 데이터 베이스도 사용할 수는 있으나 &lt;strong>이력 데이터의 양이 서버 한 대에 보관하기에는 너무 많을 수 있으므로 샤딩이 필요하다&lt;/strong>.
&lt;ul>
&lt;li>사용자 ID를 기준 삼는 샤딩 방안이 가장 기본&lt;/li>
&lt;li>부하를 모든 샤드에 고르게 분산시킬 수 있고, 데이터베이스 운영 관리도 간편하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>개략적 설계안은 대부분의 경우 통하지만, 주어진 문제의 규모를 감당하기는 어려울 것이다.&lt;/p>
&lt;p>이번 절에서는 규모를 늘려 나가면서 병목 및 해결책을 찾는데 집중한다.&lt;/p>
&lt;h3 id="중요-구성요소별-규모-확장성">중요 구성요소별 규모 확장성&lt;/h3>
&lt;h4 id="api-서버">API 서버&lt;/h4>
&lt;p>RESTful API 서버의 규모 확장 방법은 널리 알려져있다.&lt;/p>
&lt;p>본 설계안의 API 서버는 무상태로 이런 서버로 구성된 클러스터의 규모를 CPU 사용률이나 부하, I/O 상태에 따라 자동으로 늘리는 방법은 다양하다.&lt;/p>
&lt;h4 id="웹소켓-서버">&lt;strong>웹소켓 서버&lt;/strong>&lt;/h4>
&lt;p>웹소켓 클러스터도 사용률에 따라 규모를 자동으로 늘리는 것은 그다지 어렵지 않다.&lt;/p>
&lt;p>하지만 웹소켓 서버는 &lt;strong>유상태&lt;/strong> 서버라 기존 서버를 제거할 때는 주의가 필요하다.&lt;/p>
&lt;ul>
&lt;li>노드를 제거하기 전 기존 연결부터 종료될 수 있도록 해야한다.
&lt;ul>
&lt;li>로드 밸런서가 인식하는 노드 상태를 **연결 종료 중(draining)**으로 변경해둔다.&lt;/li>
&lt;li>해당 서버로는 새로운 웹소켓 연결이 만들어지지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모든 연결이 종료되면(충분한 시간이 흐른 후) 서버를 제거한다.&lt;/li>
&lt;/ul>
&lt;p>웹소켓 서버에 새로운 버전의 애플리케이션 소프트웨어를 설치할 때도 마찬가지로 유의해야한다.&lt;/p>
&lt;blockquote>
&lt;p>유상태 서버 클러스터의 규모를 자동으로 확장하려면 좋은 로드밸런서가 있어야한다.&lt;/p>
&lt;/blockquote>
&lt;p>대부분의 클라우드 로드밸런서는 이런 일을 잘 처리한다.&lt;/p>
&lt;h4 id="클라이언트-초기화">&lt;strong>클라이언트 초기화&lt;/strong>&lt;/h4>
&lt;p>모바일 클라이언트는 기동되면 웹소켓 클러스터 내의 서버 가운데 하나와 지속성 웹소켓 연결을 맺는다.&lt;/p>
&lt;ul>
&lt;li>연결이 오랜 시간 유지된다.&lt;/li>
&lt;li>현대적 프로그래밍 언어는 이런 연결 유지에 많은 메모리를 필요로 하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>웹소켓 연결이 초기화되면 클라이언트는 해당 모바일 단말의 위치, 즉 해당 단말을 이용중인 사용자의 위치 정보를 전송한다.&lt;/p>
&lt;p>그 정보를 받은 웹 소켓 연결 핸들러는 다음 작업을 수행한다.&lt;/p>
&lt;ol>
&lt;li>위치 정보 캐시에 보관된 해당 사용자의 위치를 갱신
&lt;ul>
&lt;li>해당 위치 정보는 뒤이은 계산 과정에 이용되므로, 연결 핸들러 내의 변수에 저장해둔다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자 데이터베이스를 뒤져 해당 사용자의 모든 친구 정보를 조회&lt;/li>
&lt;li>위치 정보 캐시에 일괄(batch) 요청을 보내 모든 친구의 위치를 한번에 조회
&lt;ul>
&lt;li>비활성화 친구의 위치는 캐시에 없을 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>친구 위치 각각에 대해, 해당 친구와 사용자 사이의 거리를 계산
&lt;ul>
&lt;li>검색 반경 이내면 해당 친구의 상세 정보, 위치, 마지막으로 확인된 사각을 웹소켓 연결을 통해 클라이언트에 반환&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 친구의 레디스 서버 펍/섭 채널을 구독
&lt;ul>
&lt;li>채널 생성 및 구독 비용이 저렴하므로 활성 상태에 관계없이 모든 친구 채널을 구독할 수 있음&lt;/li>
&lt;li>비활성화 친구의 채널을 유지하기 위해 메모리가 필요하지만 매우 적고, 활성 전까지 CPU나 I/O를 전혀 이용하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자의 현재 위치를 레디스 펍/섭 서버의 전용 채널을 통해 모든 친구에게 전송&lt;/li>
&lt;/ol>
&lt;h4 id="사용자-데이터베이스">&lt;strong>사용자 데이터베이스&lt;/strong>&lt;/h4>
&lt;p>사용자 데이터베이스에는 두 가지 종류의 데이터가 보관된다.&lt;/p>
&lt;ul>
&lt;li>사용자 ID, 사용자명, 프로파일 이미지의 URL 등 사용자 상세 정보(프로필 데이터)&lt;/li>
&lt;li>친구 관계 데이터&lt;/li>
&lt;/ul>
&lt;p>이번 장에서 다루는 설계안의 규모를 감안하면 한 대의 관계형 데이터베이스 서버로는 감당할 수 없으나, 사용자 ID를 기준으로 데이터를 샤딩하면 관계형 데이터베이스라 해도 수평적 규모 확장이 가능하다.&lt;/p>
&lt;p>설계하고 있는 규모의 시스템을 실제로 운영하려면 사용자 및 친구 데이터를 관리하는 팀이 따로 필요할 것이다.&lt;/p>
&lt;p>웹소켓 서버는 데이터베이스를 직접 질의하는 대신 API를 호출하여 사용자 및 친구 관계 데이터를 가져와야 한다.&lt;/p>
&lt;h4 id="위치-정보-캐시">&lt;strong>위치 정보 캐시&lt;/strong>&lt;/h4>
&lt;p>활성화 상태 사용자의 위치 정보를 캐시하기 위해 레디스를 활용한다.&lt;/p>
&lt;ul>
&lt;li>각 항목의 키에는 TTL을 설정한다.
&lt;ul>
&lt;li>사용자의 위치 정보가 갱신될 때마다 초기화된다.&lt;/li>
&lt;li>따라서 최대 메모리 사용량은 일정 한도 아래로 유지된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>하지만 천 만명의 활성 사용자가 대략 30초마다 변경된 위치 정보를 전송한다고 가정하면 레디스 서버가 감당해야 하는 갱신 연산의 수는 초당 334K에 달하게되는데, 최신 고사양 서버를 쓴다 해도 부담되는 수치이다.&lt;/p>
&lt;p>다행히도 각 사용자의 위치 정보는 서로 독립적인 데이터이므로 사용자 ID를 기준으로 여러 서버에 샤딩하면 부하 또한 고르게 분배할 수 있다.&lt;/p>
&lt;ul>
&lt;li>가용성을 높이려면 각 샤드에 보고나하는 위치 정보를 대기(standby) 노드에 복제해 두면 된다.&lt;/li>
&lt;/ul>
&lt;h4 id="레디스-펍섭-서버">&lt;strong>레디스 펍/섭 서버&lt;/strong>&lt;/h4>
&lt;p>본 설계안에서 펍/섭 서버를 모든 온라인 친구에게 보내는 위치 변경 내역 메시지의 라우팅(routing)계층으로 활용한다.&lt;/p>
&lt;p>레디스 펍/섭 서버를 사용하는 이유는 채널을 만들고 유지하는 비용이 매우 저렴하기 때문이다.&lt;/p>
&lt;ul>
&lt;li>새 채널은 구독하려는 채널이 없을 때 생성한다.&lt;/li>
&lt;li>구독자가 없는 채널로 전송되 메시지는 그대로 버려지는데, 서버에 가해지는 부하는 거의 없다.&lt;/li>
&lt;li>채널 하나를 유지하기 위해서는 구독자 관계를 추적하기 위한 해시 테이블과 연결 리스트가 필요한데 아주 소량의 메모리만 사용한다.&lt;/li>
&lt;li>오프라인 사용자라 어떤 변경도 없는 채널의 경우에는 생성된 이후에 CPU 자원은 전혀 사용하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>본 설계안은 그 점을 활용하여 주변 친구 기능을 활용하는 모든 사용자에 채널 하나씩을 부여한다.&lt;/p>
&lt;ul>
&lt;li>해당 기능을 사용하는 사용자의 앱은 초기화 시에 모든 친구의 채널과 구독 관계를 설정한다.(친구가 비활성이라도)&lt;/li>
&lt;/ul>
&lt;p>활성화 상태로 바뀐 친구의 채널을 구독하거나 비활성 상태가 된 친구의 채널을 구독 중단하는 작업이 필요 없어지므로 설계가 간단해진다.&lt;/p>
&lt;p>더 많은 메모리를 사용하게 되지만, 메모리가 병목이 될 가능성은 매우 낮다. 아키텍처를 단순하게 만들 수 잇다면 더 많은 메모리를 투입할 가치는 충분하다.&lt;/p>
&lt;h4 id="얼마나-많은-레디스-펍섭-서버가-필요한가">&lt;strong>얼마나 많은 레디스 펍/섭 서버가 필요한가?&lt;/strong>&lt;/h4>
&lt;p>&lt;strong>메모리 사용량&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>주변 친구 찾기를 사용하는 모든 사용자에게 채널 하나씩 할당하면 채널 수는 &lt;strong>1억&lt;/strong>개&lt;/li>
&lt;li>구독자 한 명을 추적하기 위해 내부 해시 테이블과 연결 리스트에 20바이트 상당의 포인터들을 저장해야함
&lt;ul>
&lt;li>&lt;code>1억 * 20바이트 * 100명 친구 / 10^9 = 200GB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>100GB 메모리 서버 2대로 충분하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>CPU 사용량&lt;/strong>&lt;/p>
&lt;p>펍/섭 서버가 구독자에게 전송해야하는 위치 정보 업데이트 양은 초당 1400만 건에 달한다.&lt;/p>
&lt;p>최신 레디스 서버 한 대로 얼마나 많은 메시지를 전송할 수 있는지 정확히 알 수는 없지만, 서버 한 대로는 곤란할것이다.&lt;/p>
&lt;ul>
&lt;li>보수적으로 기가비트 네트워크 카드를 탑재한 현대적 아키텍처의 서버 한 대로 감당 가능한 구독자의 수는 100,000이라고 가정&lt;/li>
&lt;/ul>
&lt;p>이 추정치에 따르면 필요한 레디스 서버의 수는 &lt;code>1400만 / 100,000 = 140&lt;/code>이다.&lt;/p>
&lt;hr>
&lt;p>위 계산 결과를 통해 다음과 같은 결론을 내릴 수 있다.&lt;/p>
&lt;ul>
&lt;li>레디스 펍/섭 서버의 병목은 메모리가 아니라 CPU 사용량이다.&lt;/li>
&lt;li>문제의 규모를 감당하려면 분산 레디스 펍/섭 클러스터가 필요하다.&lt;/li>
&lt;/ul>
&lt;h4 id="분산-레디스-펍섭-서버-클러스터">분산 레디스 펍/섭 서버 클러스터&lt;/h4>
&lt;p>모든 채널을 서로 독립적이므로, 메시지를 발행할 사용자 ID를 기준으로 펍/섭 서버들을 샤딩한다.&lt;/p>
&lt;p>하지만 현실적으로는 수백 대의 펍/섭 서버가 관련된 문제이므로 동작 방식을 상세하게 집어볼 필요가 있다.&lt;/p>
&lt;ul>
&lt;li>서버에는 필연적으로 장애가 생기게 마련이므로, 매끄러운 운영을 위해 필요하다.&lt;/li>
&lt;/ul>
&lt;p>본 설계안에서는 &lt;strong>서비스 탐색&lt;/strong>(Service discovery) 컴포넌트를 도입하여 이 문제를 푼다.&lt;/p>
&lt;ul>
&lt;li>etcd&lt;/li>
&lt;li>주키퍼(ZooKeeper)&lt;/li>
&lt;/ul>
&lt;p>서비스 탐색 컴포넌트의 아래 기능을 활용한다.&lt;/p>
&lt;ul>
&lt;li>가용한 서버 목록을 유지하는 기능 및 해당 목록을 갱신하는 데 필요한 UI나 API
&lt;ul>
&lt;li>서비스 탐색 소프트웨어는 설정 데이터를 보관하기 위한 소규모의 키-값 저장소라고 보면 된다.&lt;/li>
&lt;li>키: &lt;code>/config/pub_sub_ring&lt;/code>&lt;/li>
&lt;li>값: &lt;code>[&amp;quot;p_1&amp;quot;, &amp;quot;p_2&amp;quot;, &amp;quot;p_3&amp;quot;, &amp;quot;p_4&amp;quot;]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클라이언트(웹소켓 서버)로 하여금 값에 명시된 레디스 펍/섭 서버에서 발생한 변경 내역을 구독할 수 있도록 하는 기능&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_7.png"
width="1096"
height="1254"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_7_hufa309bd8978651d9dab23e4c65bb98ec_107318_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_7_hufa309bd8978651d9dab23e4c65bb98ec_107318_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="87"
data-flex-basis="209px"
>&lt;/p>
&lt;p>키에 매달린 값에는 &lt;strong>활성 상태의 모든 레디스 펍/섭 서버&lt;/strong>로 구성된 &lt;strong>해시 링&lt;/strong>을 보관한다.&lt;/p>
&lt;p>레디스 펍/섭 서버는 메시지를 발행할 채널이나 구독할 채널을 정해야 할 때 이 해시링을 참조한다.&lt;/p>
&lt;hr>
&lt;p>웹소켓 서버가 특정 사용자 채널에 위치 정보 변경 내역을 발행하는 과정은 아래와 같다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_6.png"
width="1236"
height="1358"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_6_hue0f6159084a4fbd8c7b86af586fea184_111737_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_6_hue0f6159084a4fbd8c7b86af586fea184_111737_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="91"
data-flex-basis="218px"
>&lt;/p>
&lt;ol>
&lt;li>해시 링을 참조하여 메시지를 발행할 레디스 펍/섭 서버를 선정한다.
&lt;ul>
&lt;li>정확한 정보는 서비스 탐색 컴포넌트에 보관되어 있으나 해시 링 사본을 웹소켓 서버에 캐시한다면 성능을 높힐 수 있다.&lt;/li>
&lt;li>그 경우 웹소켓 서버는 해시 링 원본에 구독 관례를 설정하여 사본을 원본과 동일하게 유지하도록 해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹소켓 서버는 해당 서버가 관리하는 사용자 채널에 위치 정보 변경 내역을 발행한다.&lt;/li>
&lt;/ol>
&lt;p>구독할 채널이 존재하는 레디스 펍/섭 서버를 찾는 과정도 이와 동일하다.&lt;/p>
&lt;h4 id="레디스-펍섭-서버-클러스터의-규모-확장-고려사항">레디스 펍/섭 서버 클러스터의 규모 확장 고려사항&lt;/h4>
&lt;p>무상태 서버라면 트래픽 피턴에 따라 크기를 늘리거나 줄이는 방법이 위험성이 낮고 비용을 절감하기도 좋아 널리 활용되지만, 레디스 펍/섭 서버 클러스터 특성으로 인해 고려하기 어렵다.&lt;/p>
&lt;p>펍/섭 채널에 전송되는 메시지는 메모리나 디스크에 지속적으로 보관되지않지만, 채널에 대한 상태 정보를 보관한다.(각 채널의 구독자 목록)&lt;/p>
&lt;p>따라서 특정한 채널을 담당하던 펍/섭 서버를 교체하거나 해시 링에서 제거하는 경우 기존 채널에 대한 구독 관계를 해지하고 새 서버에 마련된 대체 채널을 다시 구독하기 위해 &lt;strong>채널을 다른 서버로 이동&lt;/strong>시켜야 하고, &lt;strong>해당 채널의 모든 구독자에게 그 사실을 알려야한다&lt;/strong>.&lt;/p>
&lt;p>유상태 서버 클러스터의 규모를 늘리거나 줄이는 것은 운영 부담과 위험이 큰 작업이므로 주의 깊게 계획하고 진행해야한다.&lt;/p>
&lt;ul>
&lt;li>유상태 서버 클러스터는 혼잡 시간대 트래픽을 무리 없이 감당하고 불필요한 크기 변화를 피할 수 있도록 어느 정도 여유를 두고 오버 프로비저닝(over provisioning)하는 것이 일반적이다.&lt;/li>
&lt;/ul>
&lt;p>불가피하게 규모를 늘려야 할 때는 다음과 같은 문제가 발생할 수 있음에 유의하여야 한다.&lt;/p>
&lt;ul>
&lt;li>클러스터의 크기를 조정하면 많은 채널이 같은 해시 링 위의 다른 여러 서버로 이동한다.
&lt;ul>
&lt;li>서비스 탐색 컴포넌트가 모든 웹소켓 서버에 해시 링이 갱신되었음을 알리면 &lt;strong>엄청난 재구독&lt;/strong> 요청이 발생할 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>재구독 요청을 처리하다 보면 &lt;strong>클라이언트가 보내는 위치 정보 변경 메시지의 처리가 누락&lt;/strong>될 수 있다.
&lt;ul>
&lt;li>어느 정도는 허용할 수 있으나 빈도는 반드시 최소화해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서비스의 상태가 불안정해질 가능성이 있으므로 클러스터 크기 조정은 하루 중 시스템 부하가 가장 낮은 시간을 골라 시행한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>클러스터의 크기 조정 자체는 꽤 간단하다.&lt;/p>
&lt;ul>
&lt;li>새로운 링 크기를 계산한다.
&lt;ul>
&lt;li>크기가 늘어난다면 새 서버를 준비한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>해시 링의 키에 매달린 값을 새로운 내용으로 갱신한다.&lt;/li>
&lt;li>대시보드를 모니터링한다.
&lt;ul>
&lt;li>웹소켓 클러스터의 CPU 사용량이 어느 정도 튀는 것이 보여야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>p_5&lt;/code>, &lt;code>p_6&lt;/code> 두 노드가 추가된다면 해시 링은 다음과 같이 바뀐다.&lt;/p>
&lt;ul>
&lt;li>변경 전
&lt;ul>
&lt;li>&lt;code>[p_1, p_2, p_3, p_4]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>변경 후
&lt;ul>
&lt;li>&lt;code>[p_1, p_2, p_3, p_4, p_5, p_6]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="운영-고려사항">운영 고려사항&lt;/h4>
&lt;p>기존 레디스 펍/섭 서버를 새 서버로 교체할 때는 교체되는 서버의 채널만 처리하므로 운영 문제가 발생할 가능성은 클러스터 크기를 조정할 때보다 훨씬 낮다.&lt;/p>
&lt;p>펍/섭 서버에 장애가 발생하면 &lt;strong>모니터링 소프트웨어&lt;/strong>는 온콜(on-call) 엔지니어에게 경보를 발송하며, 온콜 담당자는 아래와 같은 처리를 수행한다.&lt;/p>
&lt;ol>
&lt;li>서비스 탐색 컴포넌트의 해시 링 키에 매달린 값을 갱신하여 장애가 발생한 노드를 대기 중인 노드와 교체&lt;/li>
&lt;li>교체 사실은 모든 웹소켓 서버에 통지되고, 각 웹소켓 서버는 실행 중인 연결 핸들러에게 새 펍/섭 서버의 채널을 다시 구독하라고 알림&lt;/li>
&lt;li>각 연결 핸들러는 구독 중인 채널의 목록을 유지하고 있으므로, 모든 채널을 해시 링과 대조하여 새 서버로 구독 관계를 다시 설정해야 하는지 검토&lt;/li>
&lt;/ol>
&lt;h3 id="친구-추가삭제">친구 추가/삭제&lt;/h3>
&lt;p>새 친구를 추가하면 해당 클라이언트에 연결된 웹소켓 서버의 연결 핸들러에 그 사실을 알려 새 친구의 펍/섭 채널을 구독할 수 있도록 해야한다.&lt;/p>
&lt;ul>
&lt;li>주변 친구 기능은 큰 앱의 일부로, 새 친구가 추가되면 호출될 콜백을 해당 앱에 등록해 둘 수 있다.&lt;/li>
&lt;li>콜백이 호출되면 웹소켓 서버로 새 친구의 펍/섭 채널을 구독하라는 메시지를 보낸다.&lt;/li>
&lt;li>이 메시지를 처리한 웹소켓 서버는 해당 친구가 활성화 상태인 경우 가장 최근 위치 및 시각 정보를 응답 메시지에 담아 보낸다.&lt;/li>
&lt;/ul>
&lt;p>마찬가지로 친구가 삭제되면 호출될 콜백도 앱에 등록해 둘 수 있다.&lt;/p>
&lt;ul>
&lt;li>콜백이 호출되면 해당 친구의 펍/섭 채널 구독을 취소하라는 메시지를 웹소켓 서버로 보낸다.&lt;/li>
&lt;/ul>
&lt;p>친구가 위치 정보 정보 전성을 허가/취소하는 경우의 처리에도 활용될 수 있다.&lt;/p>
&lt;h3 id="친구가-많은-사용자">친구가 많은 사용자&lt;/h3>
&lt;p>친구가 많은 사용자가 시스템 성능 문제를 야기할 가능성이 있는지 논의해볼 만한 주제이다.&lt;/p>
&lt;ul>
&lt;li>친구 수의 상한이 있다고 가정(페이스북은 5,000명)&lt;/li>
&lt;li>친구 관계는 양방향&lt;/li>
&lt;li>팔로워 모델 같은 단방향 관계는 배제&lt;/li>
&lt;/ul>
&lt;p>수천 명의 친구를 구독하는 데 필요한 펍/섭 구독 관계는 클러스터 내의 많은 웹소켓 서버에 분산되어 있을 것이다.&lt;/p>
&lt;ul>
&lt;li>따라서 친구들의 위치 변경에서 오는 부하는 각 웹소켓 서버가 나누어 처리하므로 핫스팟 문제는 발생하지 않을 것 이다.&lt;/li>
&lt;/ul>
&lt;p>다만 많은 친구를 둔 사용자의 채널이 존재하는 펍/섭 서버의 경우는 조금 더 많은 부하를 감당하게 될 수 있지만, 클러스터 안에 100대가 넘는 펍/섭 서버가 있고, 그런 헤비 유저들의 채널들이 모든 펍/섭 서버에 분산된다는 점을 감안하면, 특정 서버에 막대한 부담을 줄 일은 없을 것이다.&lt;/p>
&lt;h3 id="주변의-임의-사용자">주변의 임의 사용자&lt;/h3>
&lt;p>정보 공유에 동의한 주변 사용자를 무작위로 보여줄 수 있도록 한다면 어떻게 해야할까?&lt;/p>
&lt;p>기존 설계안을 크게 훼손하지 않으면서 해당 기능을 지원하는 한 가지 방법은 &lt;strong>지오해시에 따라 구축된 펍/섭 채널 풀&lt;/strong>을 두는 것 이다.&lt;/p>
&lt;ul>
&lt;li>지오 해시 격자로 나눈 다음 격자 마다 채널을 하나씩 만들어 둔다.&lt;/li>
&lt;/ul>
&lt;p>해당 격자 내의 모든 사용자는 해당 격자에 할당된 채널을 구독한다.&lt;/p>
&lt;ol>
&lt;li>사용자의 위치가 변경되면 웹소켓 연결 핸들러는 해당 사용자의 지오해시 ID를 계산한 후, 해당 지오해시 ID를 담당하는 채널에 새 위치를 전송한다.&lt;/li>
&lt;li>근방에 있는 사용자 가운데 해당 채널을 구독하고 있는 사용자는 사용자 2의 위치가 변겨오디었다는 메시지를 수신한다.&lt;/li>
&lt;/ol>
&lt;p>경계에 위치한 사용자를 잘 처리하기 위해 모든 클라이언트는 사용자가 위치한 지오해시 뿐 아니라 주변 지오해시 격자를 담당하는 채널도 구독한다.&lt;/p>
&lt;h3 id="레디스-펍섭-외의-대안">레디스 펍/섭 외의 대안&lt;/h3>
&lt;p>얼랭(Erlang)은 이문제에 특히 유용한 해결책이 될 수 있다.&lt;/p>
&lt;ul>
&lt;li>오히려 더 좋은 솔루션이 될 수 있다.&lt;/li>
&lt;li>얼랭은 사용자가 적어 좋은 개발자를 구하기 어렵다&lt;/li>
&lt;li>얼랭 전문가가 있다면 좋은 선택지가 될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>얼랭&lt;/strong>은 고도로 분산된 병렬 애플리케이션을 위해 고안된 프로그래밍 언어이자 런타임 환경이다.&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>개념적으로 보자면 어떤 사용자의 위치 정보 변경 내역을 그 친구에게 효율적으로 전달하는 시스템을 설계했다.&lt;/p>
&lt;p>설계안의 핵심 컴포넌트는 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>웹소켓
&lt;ul>
&lt;li>클라이언트와 서버 사이의 실시간 통신을 지원한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>레디스
&lt;ul>
&lt;li>위치 데이터의 빠른 읽기/쓰기를 지원한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>레디스 펍/섭
&lt;ul>
&lt;li>한 사용자의 위치 정보 변경 내역을 모든 온라인 친구에게 전달하는 라우팅 계층&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>소규모 트래픽에 적합한 개략적 설계안부터 시작하여, 규모가 커짐에 따라 발생 가능한 도전적 문제들을 살펴보았다.&lt;/p>
&lt;ul>
&lt;li>RESTful API 서버&lt;/li>
&lt;li>웹소켓 서버&lt;/li>
&lt;li>데이터 계층&lt;/li>
&lt;li>레디스 펍/섭 서버 클러스터&lt;/li>
&lt;li>레디스 펍/섭 서버의 대안&lt;/li>
&lt;/ul>
&lt;p>친구가 많은 사용자에게 발생할 수 있는 잠재적 성능 병목문제와, 주변의 임의 사용자를 보여주는 기능의 설계안도 살펴보았다.&lt;/p>
&lt;h2 id="요약">요약&lt;/h2>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
nearby(주변 친구) --> first((1단계))
nearby --> second((2단계))
nearby --> third((3단계))
first --> giyogu[기능적 요구사항]
giyogu --> display[주변 친구 목록 표시]
giyogu --> update[주변 친구 목록 갱신]
first --> biyogu[비 기능적 요구사항]
biyogu --> low_latenty[낮은 지연 시간]
first --> choo[추정]
choo --> mile[5마일 검색 반경]
choo --> interval[위치 갱신 주기: 30초]
choo --> updatedata[위치 정보 갱신 QPS: 334k/s]
second --> rufh[개략적 설계안]
rufh --> rest[RESTful API 서버]
rufh --> websocket[웹소켓 서버]
rufh --> redis[레디스 위치 정보 캐시]
rufh --> casandra[위치 이동 이력 데이터베이스]
rufh --> pubsub[레디스 펍/섭 서버]
second --> intervalpos[주기적 위치 갱신]
second --> api[API 설계]
second --> datamodel[데이터 모델]
datamodel --> position[위치 정보 캐시]
datamodel --> positionlog[위치 이동 이력 데이터베이스]
third --> components[각 컴포넌트의 규모 확장]
components --> apiComponent[API 서버]
components --> websocket_cluster[웹소켓 서버 클러스터]
components --> userDB[사용자 정보 데이터베이스]
components --> positionCache[위치 정보 캐시]
components --> pubsubCluster[레디스 펍/섭 서버 클러스터]
components --> erlang[레디스 펍/섭 외 대안]
third --> friendUD[친구 추가/삭제]
third --> manyFriend[친구가 많은 사용자]
third --> random[주변 임의 사용자]
&lt;/pre></description></item><item><title>1. 근접성 서비스</title><link>https://codemario318.github.io/post/system-design-interview-2/1/</link><pubDate>Sun, 04 Aug 2024 20:08:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/1/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/cover.png" alt="Featured image of post 1. 근접성 서비스" />&lt;p>근접성 서비스는 음식점, 호텔, 극장, 박물관 등 현재 위치에서 가까운 시설을 찾는 데 이용된다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;ul>
&lt;li>Q. 검색 반경을 지정할 수 있어야하는가?
&lt;ul>
&lt;li>A. 주어진 반경 내의 사업장만 대상, 이후 확장 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 최대 허용 반경?
&lt;ul>
&lt;li>A. 20km&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 검색 반경 변경 가능?
&lt;ul>
&lt;li>A. 0.5km, 1km, 2km, 5km, 20km&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 사업장 정보 CRUD는 어떻게?
&lt;ul>
&lt;li>A. 사업장 소유주가 직접 정보를 시스템에 CRUD, 새로 추가하거나 갱신된 정보는 다음날까지 반영&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 사용자 현재 위치 기준으로 자동 갱신?
&lt;ul>
&lt;li>A. 상시적으로 페이지를 갱신할 필요는 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="기능-요구사항">기능 요구사항&lt;/h3>
&lt;p>다음 세 가지 핵심 기능을 추려낼 수 있다.&lt;/p>
&lt;ul>
&lt;li>사용자 위치와 검색 반경 정보에 매치되는 사업장 목록 반환&lt;/li>
&lt;li>사업장 소유주가 사업장 정보를 추가, 삭제, 갱신할 수 있음
&lt;ul>
&lt;li>정보가 검색 결과에 실시간으로 반영될 필요는 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>고객은 사업장의 상세 정보를 살필 수 있어야함&lt;/li>
&lt;/ul>
&lt;h3 id="비기능적-요구사항">비기능적 요구사항&lt;/h3>
&lt;p>기능 요구사항을 통해 다음과 같은 비기능 요구사항을 도출할 수 있다.&lt;/p>
&lt;ul>
&lt;li>낮은 응담 지연
&lt;ul>
&lt;li>사용자는 주변 사업장을 빠르게 검색할 수 있어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 보호
&lt;ul>
&lt;li>사용자 위치는 민감한 정보이므로 위치 기반 서비스(LBS)를 설계할 때는 사용자의 정보를 보호할 방법을 고려해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>고가용성 및 규모 확장성
&lt;ul>
&lt;li>인구 밀집 지역에서 이용자가 집중되는 시간에 트래픽이 급증해도 감당할 수 있도록 시스템을 설계해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;p>시스템의 규모가 어느정도이며 어떤 수준의 도전적 과제를 해결해야 하는지 결정하기 위해, 개략적인 추정을 수행해본다.&lt;/p>
&lt;p>DAU는 1억명, 등록된 사업장의 수는 2억개라고 가정한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>1일 = 24시간 * 60분 * 60초 = 약 10^5&lt;/code>&lt;/li>
&lt;li>한 사용자는 하루에 5회 검색 시도한다고 가정&lt;/li>
&lt;li>&lt;code>QPS = (1억 * 5) / 10^5 = 5000&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략절-설계안-제시-및-동의-구하기">2단계: 개략절 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="api-설계">API 설계&lt;/h3>
&lt;p>&lt;strong>RESTful API&lt;/strong> 관례를 따르는 간단한 API를 만든다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/search/nearby&lt;/code>&lt;/strong>&lt;/p>
&lt;p>특정 검색 기준에 맞는 사업장 목록을 반환&lt;/p>
&lt;ul>
&lt;li>인자
&lt;ul>
&lt;li>&lt;code>latitude&lt;/code>: 위도&lt;/li>
&lt;li>&lt;code>longitude&lt;/code>: 경도&lt;/li>
&lt;li>&lt;code>radius(optional)&lt;/code>: 반경, 기본값은 5000m&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;total&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;businesses&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[{&lt;/span>&lt;span class="err">business&lt;/span> &lt;span class="err">object&lt;/span>&lt;span class="p">}]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>{business object}&lt;/code>는 각 사업장을 표현하는 객체로, 검색 결과 페이지에 표시될 모든 정보를 포함한다.&lt;/p>
&lt;p>사업장의 상세 정보 페이지에서는 추가 정보가 필요할 수 있으므로, 또 다른 API를 호출하여 &lt;strong>사업장 상세 정보&lt;/strong>를 조회해야한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>사업장 관련 API&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>GET /v1/businesses/:id&lt;/code>
&lt;ul>
&lt;li>특정 사업장의 상세 정보 반환&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>POST /v1/businesses&lt;/code>
&lt;ul>
&lt;li>새로운 사업장 추가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>PUT /v1/businesses/:id&lt;/code>
&lt;ul>
&lt;li>사업장 상세 정보 갱신&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>DELETE /v1/businesses/:id&lt;/code>
&lt;ul>
&lt;li>특정 사업장 정보 삭제&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>&lt;strong>읽기/쓰기 비율&lt;/strong>&lt;/p>
&lt;p>아래의 기능으로 인해 읽기 연산은 굉장히 자주 수행된다.&lt;/p>
&lt;ul>
&lt;li>주변 사업장 검색&lt;/li>
&lt;li>사업장 정보 확인&lt;/li>
&lt;/ul>
&lt;p>쓰기 연산은 사업장 정보를 추가, 삭제, 편집할 때만 발생하므로 실행 빈도가 매우 낮을 수 있다.&lt;/p>
&lt;p>이렇게 읽기 연산이 압도적인 시스템에서는 MySQL 같은 &lt;strong>관계형 데이터베이스&lt;/strong>가 바람직할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>데이터 스키마&lt;/strong>&lt;/p>
&lt;p>이 시스템의 핵심이 되는 테이블은 &lt;code>business&lt;/code> 테이블과 &lt;code>위치 색인 테이블(geospatial index table)&lt;/code>이다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
business {
id business_id pk
string address
string city
string state
string country
float latitude
float longitude
}
&lt;/pre>
&lt;hr>
&lt;p>&lt;strong>지리적 위치 색인 테이블&lt;/strong>&lt;/p>
&lt;p>지리적 위치 색인 테이블은 위치 정보 관련 연산의 효율성을 높이는데 쓰이는데, 지오해시(Geohash)에 대한 지식이 필요하므로 이후 논의한다.&lt;/p>
&lt;h3 id="개략적-설계">개략적 설계&lt;/h3>
&lt;p>이 시스템은 위치 기반 서비스와 사업장 관련 서비스 두 부분으로 구성된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/img.png"
width="604"
height="601"
srcset="https://codemario318.github.io/post/system-design-interview-2/1/img_hu6c73e6aa1fcd1095a416f091bed72765_134387_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/1/img_hu6c73e6aa1fcd1095a416f091bed72765_134387_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="100"
data-flex-basis="241px"
>&lt;/p>
&lt;ul>
&lt;li>로드 밸런서
&lt;ul>
&lt;li>유입 트래픽을 자동으로 여러 서비스에 분산시키는 컴포넌트&lt;/li>
&lt;li>로드밸런서에 단일 DNS 진입점을 지정하고, URL 경로를 분석하여 어느 서비스에 트래픽을 전달할 지 결정한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>위치 기반 서비스(LBS)
&lt;ul>
&lt;li>시스템의 핵심으로 주어진 위치와 반경 정보를 이용해 주변 사업장을 검색한다.&lt;/li>
&lt;li>쓰기 요청이 없는, 읽기 요청만 빈번하게 발생한다.&lt;/li>
&lt;li>QPS가 높음, 특히 특정 시간대의 인구 밀집 지역일수록 그 경향이 심해진다.&lt;/li>
&lt;li>무상태 서비스이므로 수평적 규모 확장이 쉽다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사업장 서비스
&lt;ul>
&lt;li>쓰기
&lt;ul>
&lt;li>사업장 소유주가 사업장 정보를 생성, 갱신, 삭제한다.&lt;/li>
&lt;li>QPS가 높지 않다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>읽기
&lt;ul>
&lt;li>고객이 사업장 정보를 조회한다.&lt;/li>
&lt;li>특정 시간대에 QPS가 높아진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>데이터베이스 클러스터&lt;/strong>&lt;/p>
&lt;p>데이터베이스 클러스터는 주-부 데이터베이스 형태로 구성할 수 있다.&lt;/p>
&lt;ul>
&lt;li>주 데이터베이스는 쓰기 요청을 처리한다.&lt;/li>
&lt;li>부 데이터베이스, 즉 사본 데이터베이스는 읽기 요청을 처리한다.&lt;/li>
&lt;/ul>
&lt;p>데이터가 주 데이터베이스에 기록된 후 사본 데이터베이스로 복제되기 때문에 지연으로 인해 두 데이터베이스에 차이가 있을 수 있다.&lt;/p>
&lt;p>그렇더라도 사업장 정보는 실시간으로 갱신 될 필요는 없기 때문에 문제가 되지는 않는다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>사업장 서비스와 LBS의 규모 확장성&lt;/strong>&lt;/p>
&lt;p>사업장 서비스와 LBS 둘 다 무상태 서비스이므로 점심시간 같은 특정 시간대에 집중적으로 몰리는 트래픽에는 자동으로 서버를 추가하여 대응하고, 야간 등 유휴 시간대에는 서버를 삭제하도록 구성할 수 있다.&lt;/p>
&lt;p>시스템을 클라우드에 둔다면 여러 지역, 여러 가용성 구역에 서버를 두어 시스템의 가용성을 높일 수 있다.&lt;/p>
&lt;h3 id="주변-사업장-검색-알고리즘">주변 사업장 검색 알고리즘&lt;/h3>
&lt;p>실제로는 많은 회사가 &lt;strong>레디스 지오해시&lt;/strong>(Geohash in Redis)나 &lt;strong>PostGIS&lt;/strong> 확장을 설치한 &lt;strong>포스트그레스(Postgres) 데이터베이스&lt;/strong>를 활용한다.&lt;/p>
&lt;p>면접관은 이런 데이터베이스의 내부 구조를 알 거라고 기대하지 않으므로 데이터베이스 이름을 나열하기 보다는 &lt;strong>지리적 위치 색인&lt;/strong>이 어떻게 동작하는지 설명함으로써 문제 풀이 능력과 기술적 지식을 갖추었음을 보이는 것이 좋다.&lt;/p>
&lt;h4 id="2차원-검색">2차원 검색&lt;/h4>
&lt;p>주어진 반경으로 그린 원 안에 놓인 사업장을 검색하는 방법이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/img_1.png"
width="420"
height="424"
srcset="https://codemario318.github.io/post/system-design-interview-2/1/img_1_hu28aaeced189dd5bd938ca37a2e071a5b_306369_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/1/img_1_hu28aaeced189dd5bd938ca37a2e071a5b_306369_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="2차원 검색"
class="gallery-image"
data-flex-grow="99"
data-flex-basis="237px"
>&lt;/p>
&lt;p>가장 직관적이지만 지나치게 단순하다는 문제가 있다.&lt;/p>
&lt;p>이 절차를 유사 SQL 질의문으로 옮기면 다음과 같다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">business_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">latitude&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">longitude&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">business&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">latitude&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BETWEEN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">{&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">my_lat&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">radius&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">{&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">my_lat&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">radius&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">longitude&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BETWEEN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">{&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">my_lon&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">radius&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">{&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">my_lon&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">radius&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위와 같은 질의는 테이블 전부를 읽어야 하므로 효율적이지 않다.&lt;/p>
&lt;p>위도, 경도 컬럼에 인덱스를 만든다면 &lt;strong>데이터 집합 1&lt;/strong>과 &lt;strong>데이터 집합 2&lt;/strong>는 빠르게 추출할 수 있지만, 주어진 반경 내 사업장을 얻으려면 이 두집합의 교집합을 구해야한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/img_2.png"
width="661"
height="629"
srcset="https://codemario318.github.io/post/system-design-interview-2/1/img_2_hu40eaf7e43af948bc3acd0796b3c5f500_646398_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/1/img_2_hu40eaf7e43af948bc3acd0796b3c5f500_646398_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="두 데이터 집합의 교집합"
class="gallery-image"
data-flex-grow="105"
data-flex-basis="252px"
>&lt;/p>
&lt;p>그럴 경우 각 집합에 속한 데이터양이 많기 때문에 효율적일 수 없다.&lt;/p>
&lt;p>따라서 2차원 데이터를 한 차원에 대응시킬 방법을 적용해야하며, 지리적 정보에 색인을 만드는 방법은 두 종류이다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart
index[인덱스]
hash[해시]
evenGrid[균등 격자]
geohash[지오해시]
cartesianTiers[카르테시안 계층]
tree[트리]
quadTree[쿼드트리]
s2[구글 S2]
rtree[R 트리]
index --> hash
index --> tree
hash --> evenGrid
hash --> geohash
hash --> cartesianTiers
tree --> quadTree
tree --> s2
tree --> rtree
&lt;/pre>
&lt;ul>
&lt;li>해시 기반 방안
&lt;ul>
&lt;li>균등 격자(even grid), 지오해시(geohash), 카르테시안 계층(cartesian tiers) 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>트리 기반 방안
&lt;ul>
&lt;li>쿼드트리(quadtree), 구글 S2, R 트리(R-tree) 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>각 색인법의 구현 방법은 서로 다르지만 모두 지도를 작은 영역으로 분할하고 고속 검색이 가능하도록 색인을 만든다.&lt;/p>
&lt;ul>
&lt;li>지오해시, 쿼드트리, 구글 S2는 실제로 가장 널리 사용되는 방안이다.&lt;/li>
&lt;/ul>
&lt;h4 id="균등-격자">균등 격자&lt;/h4>
&lt;p>지도를 작은 격자 또는 구획으로 나누는 단순한 접근법이다.&lt;/p>
&lt;p>하나의 격자는 여러 사업장을 담을 수 있고, 하나의 사업장은 오직 한 격자 안에만 속하게 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/img_3.png"
width="641"
height="358"
srcset="https://codemario318.github.io/post/system-design-interview-2/1/img_3_hu362895ba995ff86ccb1db11274640f8a_214139_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/1/img_3_hu362895ba995ff86ccb1db11274640f8a_214139_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="세계 지도"
class="gallery-image"
data-flex-grow="179"
data-flex-basis="429px"
>&lt;/p>
&lt;ul>
&lt;li>사업장 분포가 균등하지 않기 때문에, 전 세계를 동일한 크기의 격자로 나누면 데이터 분포는 전혀 균등하지 않다.&lt;/li>
&lt;li>주어진 격자의 인접 격자를 찾기가 까다로울 수 있다.
&lt;ul>
&lt;li>격자 식별자 할당에 명확한 체계가 없기 때문&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="지오해시geohash">지오해시(Geohash)&lt;/h4>
&lt;p>2차원의 위도 경도 데이터를 1차원의 문자열로 변환한다.&lt;/p>
&lt;p>지오해시 알고리즘은 비트를 하나씩 늘려가면서 재귀적으로 세계를 더 작은 격자로 분할해 나간다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/img_4.png"
width="625"
height="519"
srcset="https://codemario318.github.io/post/system-design-interview-2/1/img_4_hufacfa873ada24596b4892bc8b0fb3bf9_375857_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/1/img_4_hufacfa873ada24596b4892bc8b0fb3bf9_375857_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="지오해시"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="289px"
>&lt;/p>
&lt;ul>
&lt;li>위도 범위 [-90, 0]은 0에 대응&lt;/li>
&lt;li>위도 범위 [0, 90]은 1에 대응&lt;/li>
&lt;li>경도 범위 [-180, 0]은 0에 대응&lt;/li>
&lt;li>경도 범위 [0, 180]은 1에 대응&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/img_5.png"
width="341"
height="536"
srcset="https://codemario318.github.io/post/system-design-interview-2/1/img_5_hu903260c7889129d2af5496540c3da4de_327438_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/1/img_5_hu903260c7889129d2af5496540c3da4de_327438_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="격자 분할"
class="gallery-image"
data-flex-grow="63"
data-flex-basis="152px"
>&lt;/p>
&lt;p>이 절차를 원하는 정밀도(precision)를 얻을 때까지 반복하며, Base32 표현법으로 바꾼다.&lt;/p>
&lt;ul>
&lt;li>구글 본사 지오해시 (길이 = 6)
&lt;ul>
&lt;li>1001 10110 01001 10000 11011 11010 → 9q9hvu&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타 본사 지오해시 (길이 = 6)
&lt;ul>
&lt;li>1001 10110 01001 10001 10000 10111 → 949jhr&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>지오해시는 12단계 정밀도를 낮는데, 이 정밀도가 격자의 크기를 결정한다.&lt;/p>
&lt;p>지오해시의 길이가 6보가 길어지면 한 격자가 너무 작아지고, 4보다 작으면 격자가 너무 커진다.&lt;/p>
&lt;p>따라서 최적 정밀도는 사용자가 지정한 반경으로 그린 원을 덮는 최소 크기 격자를 만드는 지오해시 길이를 구해야한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>반경(km)&lt;/th>
&lt;th>지오해시 길이&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0.5km&lt;/td>
&lt;td>6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1km&lt;/td>
&lt;td>5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2km&lt;/td>
&lt;td>5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5km&lt;/td>
&lt;td>4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>20km&lt;/td>
&lt;td>4&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>이 접근법은 대체로 잘 동작하지만, 격자 가장자리 처리 방식에 관한 경계 조건(edge case)이 몇 가지 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>격자 가장자리 이슈 1&lt;/strong>&lt;/p>
&lt;p>해시값의 곹통 접두어(prefix)가 긴 격자들이 서로 더 가깝게 놓이도록 보장하지만, 그 역은 참이 아니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/img_6.png"
width="538"
height="329"
srcset="https://codemario318.github.io/post/system-design-interview-2/1/img_6_huab9c559e085f9df894e550dd54ea808a_327384_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/1/img_6_huab9c559e085f9df894e550dd54ea808a_327384_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="공통 접두어"
class="gallery-image"
data-flex-grow="163"
data-flex-basis="392px"
>&lt;/p>
&lt;p>아주 가까운 두 위치가 어떤 공통 접두어도 갖지 않는 일이 발생할 수 있다.&lt;/p>
&lt;ul>
&lt;li>두 지점이 적도의 다른 쪽에 놓이는 경우&lt;/li>
&lt;li>자오선상의 다른 반쪽에 놓이는 경우&lt;/li>
&lt;/ul>
&lt;p>이 문제점으로 인해 단순한 접두어 기반 SQL 질의문을 사용하면 주변 모든 사업장을 가져올 수 없다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">geohash_index&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">geohash&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;9q8zn%&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>격자 가장자리 이슈 2&lt;/strong>&lt;/p>
&lt;p>공통 접두어 길이는 길지만 서로 다른 격자에 놓이는 경우가 존재할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/img_7.png"
width="516"
height="317"
srcset="https://codemario318.github.io/post/system-design-interview-2/1/img_7_hu1ec4e92240f08b219cd6ced755e2174d_347604_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/1/img_7_hu1ec4e92240f08b219cd6ced755e2174d_347604_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="격자 가장자리 이슈"
class="gallery-image"
data-flex-grow="162"
data-flex-basis="390px"
>&lt;/p>
&lt;p>가장 흔히 사용되는 해결책은 현재 격자를 비롯한 인접한 모든 격자의 모든 사업장 정보를 가져오는 것이다.&lt;/p>
&lt;ul>
&lt;li>특정 지오해시의 주변 지오해시를 찾는 것은 상수 시간에 가능한 연산이다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>표시할 사업장이 충분하지 않은 경우&lt;/strong>&lt;/p>
&lt;p>현재 격자와 주변 격자를 다 살펴보아도 표시할 사업장을 충분히 발견할 수 없는 경우는 2가지 방법을 고려할 수 있다.&lt;/p>
&lt;ul>
&lt;li>주어진 반경 내 사업장만 반환
&lt;ul>
&lt;li>사용자가 만족할만한 수의 사업장 정보를 반환하지 못한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>검색 반경 키우기
&lt;ul>
&lt;li>지오해시 값의 마지막 비트를 삭제하여 얻은 새 지오해시 값을 사용해 주변 사업장을 검색한다.&lt;/li>
&lt;li>만족할만한 수를 채울 때 까지 지워 범위를 다시 확장할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="쿼드트리">쿼드트리&lt;/h4>
&lt;p>쿼드트리는 격자의 내용이 특정 기준을 만족할 때가지 2차원 공간을 재귀적으로 사분면 분할하는 데 흔히 사용되는 자료구조이다.&lt;/p>
&lt;ul>
&lt;li>ex) 격자에 담긴 사업장 수가 100이하가 될 때가지 분할한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/img_8.png"
width="818"
height="228"
srcset="https://codemario318.github.io/post/system-design-interview-2/1/img_8_hu4541cdbdba4b6c2f45ed6a19df4e099d_62200_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/1/img_8_hu4541cdbdba4b6c2f45ed6a19df4e099d_62200_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="쿼드트리"
class="gallery-image"
data-flex-grow="358"
data-flex-basis="861px"
>&lt;/p>
&lt;p>이 자료구조는 각각의 LBS 서버에 존재해야 하며, 서버가 시작하는 시점에 구축된다.&lt;/p>
&lt;ul>
&lt;li>쿼드 트리는 메모리 안에 놓이는 자료 구조일 뿐, 데이터베이스가 아님에 유의하자.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/img_9.png"
width="814"
height="544"
srcset="https://codemario318.github.io/post/system-design-interview-2/1/img_9_hudfd79b9274f06537f3a452d7b383faee_138505_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/1/img_9_hudfd79b9274f06537f3a452d7b383faee_138505_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="쿼드트리 구축"
class="gallery-image"
data-flex-grow="149"
data-flex-basis="359px"
>&lt;/p>
&lt;p>트리의 루트 노드는 세계 전체 지도를 나타내며, 이 루트 노드를 사분면 각각을 나타내는 하위노드를 통해 어떤 노드의 사업장도 100개를 넘지 않을 때 까지 재귀적으로 분할한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>쿼드트리 전부를 저장하는 데 얼마나 많은 메모리가 필요한가?&lt;/strong>&lt;/p>
&lt;p>어떤 데이터가 쿼드트리에 보관되는지 살펴봐야한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>말단 노드에 수록되는 데이터&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>이름&lt;/th>
&lt;th>크기&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>격자를 식별하는 데 사용될 좌상단과 우하단 꼭지점 좌표&lt;/td>
&lt;td>32바이트 (8바이트 * 4)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>격자 내부 사업장 ID 목록&lt;/td>
&lt;td>ID당 8바이트 * 100(한 격자에 허용되는 최대 사업장 수)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>합계&lt;/td>
&lt;td>832바이트&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;p>&lt;strong>내부 노드에 수록되는 데이터&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>이름&lt;/th>
&lt;th>크기&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>격자를 식별하는 데 사용될 좌상단과 우하단 꼭지점 좌표&lt;/td>
&lt;td>32바이트 (8바이트 * 4)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>하위 노드 4개를 가리킬 포인터&lt;/td>
&lt;td>32바이트 (8바이트 * 4)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>합계&lt;/td>
&lt;td>64바이트&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>트리 구축 프로세스가 한 격자에 허용되는 사업장 수의 초댓값에 좌우되기는 하지만 데이터베이스 레코드가 이미 최댓값을 고려하여 분할되어 있으므로 트리 안에 저장하지 않아도 된다.&lt;/p>
&lt;hr>
&lt;p>총 메모리 요구량은 대략 1.71GB으로 꽤 작은 것을 알 수 있다.&lt;/p>
&lt;p>쿼드 트리 인덱스는 메모리를 많이 잡아먹지 않으므로 서버 한 대에 충분히 올릴 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>전체 쿼드트리 구축에 소요되는 시간은?&lt;/strong>&lt;/p>
&lt;p>각 말단 노드에는 대략 100개 사업장 ID가 저장된다.&lt;/p>
&lt;p>전체 사업장 수를 &lt;code>n&lt;/code>이라고 하였을 때 트리를 구축하는 시간 복잡도는 &lt;code>n/100 log n/100&lt;/code>이다.&lt;/p>
&lt;p>200m 개의 사업장 정보를 인덱싱하는 쿼드트리 구축에는 몇 분 정도 소요될 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>쿼드트리로 주변 사업장을 검색하려면?&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>메모리에 쿼드트리 인덱스를 구축한다.&lt;/li>
&lt;li>검색 시작점이 포함된 말단 노드를 만날 때가지, 트리의 루트 노드로부터 탐색한다.
&lt;ul>
&lt;li>해당 노드에 100개 사업장이 있는 경우에는 해당 노드만 반환&lt;/li>
&lt;li>그렇지 않은 경우 충분한 사업장 수가 확보될 때까지 인접 노드도 추가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>&lt;strong>쿼드트리 운영 시 고려사항&lt;/strong>&lt;/p>
&lt;p>200m개 사업장을 갖는 쿼드트리를 구축하는 데 몇 분이 소요된다.&lt;/p>
&lt;p>따라서 서버를 시작하는 순간에 트리를 구축하면 서버 시작 시간이 길어질 수 있다는 점을 따져봐야 한다.&lt;/p>
&lt;ul>
&lt;li>쿼드트리를 만들고 있는 동안 서버는 트래픽을 처리할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>새로운 버전의 서버 소프트웨어를 릴리스 할 때는 동시에 너무 많은 서버에 배포하지 않도록 조심해야 한다.&lt;/p>
&lt;ul>
&lt;li>새 서버 소프트웨어를 테스트 환경의 모든 서버에 동시 배포하면 200m개 사업장 정보를 데이터베이스에서 동시에 읽게 되어 시스템에 큰 부하가 가해질 수 있다.&lt;/li>
&lt;/ul>
&lt;p>사업장이 추가/삭제 되었을 때 쿼드 트리를 갱신하는 문제도 고려해야한다.&lt;/p>
&lt;ul>
&lt;li>점진적 갱신
&lt;ul>
&lt;li>점진석으로 서버 중 몇 개씩만 갱신한다.&lt;/li>
&lt;li>짧은 시간 동안이지만 낡은 데이터가 반환될 수 있다.&lt;/li>
&lt;li>요구사항이 엄격하지 않다면 일반적으로 용인할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>밤사이에 일괄 갱신
&lt;ul>
&lt;li>수많은 키가 한번에 무효화되어 캐시 서버에 막대한 부하가 가해질 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>실시간 갱신
&lt;ul>
&lt;li>설계가 복잡해진다.&lt;/li>
&lt;li>여러 스레드가 쿼드트리 자료 구조를 동시에 접근하는 경우 락 매커니즘을 사용해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>실제 쓰이는 쿼드트리 사례&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/img_10.png"
width="778"
height="492"
srcset="https://codemario318.github.io/post/system-design-interview-2/1/img_10_hu2dc1b935aaab456c08ca4ae535717d09_628941_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/1/img_10_hu2dc1b935aaab456c08ca4ae535717d09_628941_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="실제 쿼드트리 사례"
class="gallery-image"
data-flex-grow="158"
data-flex-basis="379px"
>&lt;/p>
&lt;p>인구 밀집 지역에는 작은 격자를, 그렇지 않은 지역에는 큰 격자를 사용하고 있다.&lt;/p>
&lt;h4 id="구글-s2">구글 S2&lt;/h4>
&lt;p>구글 S2 기하 라이브러리는 아주 유명한 솔루션이다.&lt;/p>
&lt;p>쿼드트리와 마찬가지로 메모리 기반이다.&lt;/p>
&lt;p>지구를 힐베르트 곡선(Hilbert curve)라는 공간 채움 곡선을 사용하여 1차원 색인화 하는 방안이다.&lt;/p>
&lt;p>힐베르트 곡선은 곡선 상에서 인접한 두 지점은 색인화 이후 1차원 공간 내에서도 인접한 위치에 존재한다는 특징이 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/img_11.png"
width="468"
height="511"
srcset="https://codemario318.github.io/post/system-design-interview-2/1/img_11_hucae915331abfd9b51266254260a54e07_267359_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/1/img_11_hucae915331abfd9b51266254260a54e07_267359_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="힐베르트 곡선"
class="gallery-image"
data-flex-grow="91"
data-flex-basis="219px"
>&lt;/p>
&lt;ul>
&lt;li>지오펜스(geofence) 구현에 적합하다.
&lt;ul>
&lt;li>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/img_12.png"
width="441"
height="300"
srcset="https://codemario318.github.io/post/system-design-interview-2/1/img_12_hu5fc670ad65b6ab7c4e04b9dba4591411_278051_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/1/img_12_hu5fc670ad65b6ab7c4e04b9dba4591411_278051_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="지오펜스"
class="gallery-image"
data-flex-grow="147"
data-flex-basis="352px"
>&lt;/li>
&lt;li>지오펜스: 실제 지리적 영역에 설정한 가상의 경계&lt;/li>
&lt;li>임의 지역에 다양한 수준의 영역 지정이 가능하다.&lt;/li>
&lt;li>특정 지점 반경 몇 km, 스쿨 존, 동네 경계 등&lt;/li>
&lt;li>관심 있는 영역의 경계를 정한 다음 벗어난 사용자에게 알림을 보낼 수 있게된다.&lt;/li>
&lt;li>풍부한 기능을 제공할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>영역 지정 알고리즘
&lt;ul>
&lt;li>지오해시처럼 고정된 정밀도를 사용하는 대신 최소 수준, 최고 수준, 최대 셀 개수 등을 지정할 수 있다.&lt;/li>
&lt;li>셀 크기를 유연하게 조정할 수 있으므로 좀 더 상세한 결과를 반환한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="추천">추천&lt;/h4>
&lt;p>면접 시에는 지오해시나 쿼드트리 가운데 하나를 선택하는 것이 좋다.&lt;/p>
&lt;ul>
&lt;li>S2는 면접 시간 내에 분명히 설명하기 어렵다.&lt;/li>
&lt;/ul>
&lt;h3 id="지오해시-vs-쿼드트리">지오해시 vs 쿼드트리&lt;/h3>
&lt;hr>
&lt;p>&lt;strong>지오해시&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>구현과 사용이 쉽다.&lt;/li>
&lt;li>트리를 구축할 필요가 없다.&lt;/li>
&lt;li>지정 반경 이내 사업장 검색을 지원한다.&lt;/li>
&lt;li>정밀도를 고정하면 격자 크기도 고정된다.
&lt;ul>
&lt;li>인구 밀도에 따라 동적으로 격자 크기를 조장할 수는 없다.&lt;/li>
&lt;li>반영하려면 복잡한 논리를 적용해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>색인 갱신이 쉽다.
&lt;ul>
&lt;li>사업장 하나를 삭제하려면, 지오해시 값과 사업장 식별자가 같은 열 하나만 제거하면 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>쿼드트리&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>트리 구축으로 인해 구현하기가 살짝 더 까다롭다.&lt;/li>
&lt;li>k번째로 가까운 사업장까지의 목록을 구할 수 있다.
&lt;ul>
&lt;li>반경에 상관없이 내 위치에서 가까운 사업장 k개&lt;/li>
&lt;li>하위 노드 분할 과정이 숫자 k에 기반하고, 사업장을 찾을 때까지 검색 범위를 자동으로 조정할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>인구 밀도에 따라 격자 크기를 동적으로 조정할 수 있다.&lt;/li>
&lt;li>지오해시보다 색인 갱신은 까다롭다.
&lt;ul>
&lt;li>사업자 장보를 삭제하려면 루트 노드부터 말단 노드까지 트리를 순회해야 한다.(&lt;code>O(log n)&lt;/code>)&lt;/li>
&lt;li>다중 스레드를 지원하는 경우 락을 사용해야하므로 더욱 복잡해질 수 있다.&lt;/li>
&lt;li>리밸런싱이 필요하다면 구현은 더욱 복잡해진다.
&lt;ul>
&lt;li>말단 노드에 새로운 사업장을 추가할 수 없는 경우 필요함(꽉 찼을때)&lt;/li>
&lt;li>구간의 크기를 필요한 양보다 크게 잡으면 예방할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="데이터베이스의-규모-확장성">데이터베이스의 규모 확장성&lt;/h3>
&lt;p>사업장 테이블과 지리정보 색인 테이블의 규모 확장성을 살펴본다.&lt;/p>
&lt;h4 id="사업장-테이블">사업장 테이블&lt;/h4>
&lt;p>사업장 테이블 데이터는 한 서버에 담을 수 없을수도 있다.&lt;/p>
&lt;ul>
&lt;li>샤딩을 적용하기 좋은 후보이다.&lt;/li>
&lt;/ul>
&lt;p>가장 간단한 방법은 사업장 ID를 기준으로 샤딩하는 것으로 모든 샤드에 부하를 고르게 분산할 수 있을 뿐 아니라 운영적 측면에서도 관리하기 쉽다.&lt;/p>
&lt;h4 id="지리-정보-색인-테이블">지리 정보 색인 테이블&lt;/h4>
&lt;p>지오해시 테이블 구성 방법은 두가지이다.&lt;/p>
&lt;ol>
&lt;li>각각의 지오해시에 연결되는 모든 사업장 ID를 JSON 배열로 만들어 같은 열에 저장&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>사업장 정보를 갱신하려면 JSON 배열을 읽은 다음 갱신할 사업장 ID를 찾아야한다.&lt;/li>
&lt;li>사업장을 등록해야 하는 경우 같은 사업장 정보가 이미 있는지 확인을 위해 데이터를 전부 살펴야한다.&lt;/li>
&lt;li>병렬적으로 실행되는 갱신 연산 결과로 데이터가 소실되는 경우를 막기 위해 락을 사용해야한다.&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>같은 지오해시에 속한 사업장 ID 각각을 별도 열로 저장
&lt;ul>
&lt;li>지오해시와 사업장 ID 컬럼을 합친 &lt;code>(geohash, business_id)&lt;/code>를 복합키로 사용하면 사업장 정보를 추가, 삭제하기 쉽다.(락이 필요 없다)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="지리-정보-색인의-규모-확장">지리 정보 색인의 규모 확장&lt;/h4>
&lt;p>쿼드트리 색인을 전부 보관하는데 1.71G의 메모리가 필요하므로 색인 전부를 최신 데이터베이스 서버 한 대에 충분히 수용할 수 있다.&lt;/p>
&lt;p>하지만 읽기 연산의 빈도가 높다면 서버 한 대의 CPU와 네트워크 대역폭으로는 요청 전부를 감당하지 못할 수 있다.&lt;/p>
&lt;p>이러한 상황에서는 여러 데이터베이스 서버로 부하를 분산해야한다.&lt;/p>
&lt;p>관계형 데이터베이스 서버의 경우 부하 분산에는 두 가지 전략이 흔히 사용된다.&lt;/p>
&lt;ul>
&lt;li>읽기 연산을 지원할 사본 데이터베이스 서버를 늘린다.&lt;/li>
&lt;li>샤딩을 적용한다.
&lt;ul>
&lt;li>지오해시 테이블은 샤딩 로직을 애플리케이션 계층에서 구현해야하기 때문에 까다롭다.&lt;/li>
&lt;li>데이터 전부를 서버 한 대에 담을 수 있으므로 여러 서버로 샤딩해야 할 강한 기술적 필요성은 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>따라서 이번 설계안에서는 읽기 부하를 나눌 사본 데이터베이스 서버를 두는 방법이 더 좋다.&lt;/p>
&lt;h3 id="캐시">캐시&lt;/h3>
&lt;p>캐시 계층 도입 전에는 정말 필요한지 고민해야한다.&lt;/p>
&lt;ul>
&lt;li>처리 부하가 읽기 중심이고 데이터베이스 크기는 상대적으로 작아 모든 데이터는 한 대 데이터베이스 서버에 수용 가능
&lt;ul>
&lt;li>이 경우 질의문 처리 성능은 I/O에 좌우되지 않으므로 메모리 캐시를 사용할 때와 비슷하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>읽기 성능이 병목이라면 사본 데이터베이스를 증설해서 읽기 대역폭을 늘릴 수 있다.&lt;/li>
&lt;/ul>
&lt;p>캐시 도입을 의논할 때 벤치마킹과 비용 분석에 각별히 주의해야 한다는 사실을 유념해야한다.&lt;/p>
&lt;p>캐시가 사업적 요구사항을 만족하는 데 주용한 역할을 하리라는 확신이 들면 실제 캐시 전략 논의를 진행해도 좋다.&lt;/p>
&lt;h4 id="캐시-키">캐시 키&lt;/h4>
&lt;p>가장 직관적인 캐시 키는 사용자 위치의 위도 경도 정보이지만 몇가지 문제가 있다.&lt;/p>
&lt;ul>
&lt;li>사용자의 핸드폰에서 반환되는 위치 정보는 추정치일 뿐 정확하지 않다.
&lt;ul>
&lt;li>전혀 움직이지 않는다고 해도 측정할 때마다 조금씩 달라진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이동하면 위도 경도 정보도 미세하게 변경된다.&lt;/li>
&lt;/ul>
&lt;p>따라서 사용자 위치 정보는 캐시 키로는 적절치 않으며, 지오해시나 쿼드트리는 같은 격자 내 모든 사업장이 같은 해시값을 갖도록 만들 수 있기 때문에 캐시 키로 적합하다.&lt;/p>
&lt;h4 id="캐시-데이터-유형">캐시 데이터 유형&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>키&lt;/th>
&lt;th>값&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>지오해시&lt;/td>
&lt;td>해당 격자 내의 사업장 ID 목록&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사업장 ID&lt;/td>
&lt;td>사업장 정보 객체&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>위 데이터는 캐시에 보고나하면 시스템의 성능을 전반적으로 향상시킬 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>격자 내 사업장 ID&lt;/strong>&lt;/p>
&lt;p>사업장 정보는 상대적으로 안정적이라 자주 변경되지 않는다.&lt;/p>
&lt;p>따라서 특정 지오해시에 해당하는 사업장 ID 목록을 미리 계산한 다음 레디스 같은 키-값 저장소에 캐시할 수 있다.&lt;/p>
&lt;ol>
&lt;li>주어진 지오해시에 대응되는 사업장 목록을 가져온다.
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">business_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">geohash_index&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">geohash&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="err">{&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">geohash&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>주어진 지오해시에 대응되는 사업장 목록을 요청받으면 캐시를 먼저 조회하고 없으면 위의 질의를 사용하여 캐시에 보관 후 반환한다.&lt;/li>
&lt;/ol>
&lt;p>새로운 사업장을 추가하거나, 기존 사업장 정보를 편집하거나, 아예 삭제하는 경우에는 데이터베이스를 갱신하고 캐시에 보관된 항목은 무효화(invalidate) 한다.&lt;/p>
&lt;ul>
&lt;li>연산의 빈도가 상대적으로 낮아 락을 사용할 필요가 없어 구현하기 쉽다.&lt;/li>
&lt;/ul>
&lt;p>요구사항에서 사용자가 4가지 검색 반경 가운데 하나를 고를 수 있는데, 이 검색 반경은 각각 지오해시 길이 4, 5, 5, 6에 해당한다.&lt;/p>
&lt;p>따라서 주변 사업장 검색 결과를 신속하게 제공하려면 세가지 정밀도(4, 5, 6) 전부에 대한 검색 결과를 레디스에 캐시해야한다.&lt;/p>
&lt;ul>
&lt;li>레디스 저장소에 값을 저장하기 위한 필요 공간
&lt;ul>
&lt;li>&lt;code>8qkdlxm * 200m * 3가지 정밀도 = ~5GB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>레디스 저장소에 키를 저장하기 위핸 필요 공간
&lt;ul>
&lt;li>무시할 만한 수준&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>전체 메모리 요구량은 대략 5GB&lt;/li>
&lt;/ul>
&lt;p>메모리 요구량으로 봤을 때 서버 한 대로도 충분할 것 같지만, 고가용성을 보장하고 대륙 경계를 넘는 트래픽의 전송 지연을 방지하기 위해 &lt;strong>레디스 클러스터를 전 세계에 각 지역별로 두고, 동일한 데이터를 각 지역에 중복해서 저장&lt;/strong>해 두어야 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>클라이언트 애플리케이션에 표시할 사업장 정보&lt;/strong>&lt;/p>
&lt;p>&lt;code>business_id&lt;/code>를 키로 사용하고 이름, 주소, 사진 드으이 정보를 담는다.&lt;/p>
&lt;h3 id="지역-및-가용성-구역">지역 및 가용성 구역&lt;/h3>
&lt;p>지금까지 설펴본 위치 기반 서버스는 &lt;strong>여러 지역과 가용성 구역에 설치&lt;/strong>한다.&lt;/p>
&lt;ul>
&lt;li>사용자와 시스템 사이의 물리적 거리를 최소한으로 줄일 수 있다.&lt;/li>
&lt;li>트래픽을 인구에 따라 고르게 분산하는 유연성을 확보할 수 있다.
&lt;ul>
&lt;li>인구 밀도가 아주 높은 국가는 별도 지역으로 빼거나, 아예 한 지역 안에서도 여러 가용성 구역을 활용하여 부하를 분산시키는 것이 바람직할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>그 지역의 사생활 보호법(privacy law)에 맞는 운영이 가능하다.&lt;/li>
&lt;/ul>
&lt;h3 id="시간대-혹은-사업장-유형별-검색">시간대, 혹은 사업장 유형별 검색&lt;/h3>
&lt;p>지오해시나 쿼드트리 같은 메커니즘을 통해 전 세계를 작은 격자들로 분할하면 검색 결과로 얻어지는 사업장 수는 상대적으로 적다.&lt;/p>
&lt;p>일단은 근처 사업장 ID부터 전부 확보한 다음 사업장 정보를 전부 추출해서 영업시간이나 사업장 유형에 따라 필터링한다.&lt;/p>
&lt;h3 id="최종-설계도">최종 설계도&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/img_13.png"
width="798"
height="548"
srcset="https://codemario318.github.io/post/system-design-interview-2/1/img_13_hubc23af0bc58b4886e737580b3528b6eb_150645_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/1/img_13_hubc23af0bc58b4886e737580b3528b6eb_150645_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="최종 설계도"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="349px"
>&lt;/p>
&lt;h4 id="주변-사업장-검색">주변 사업장 검색&lt;/h4>
&lt;ol>
&lt;li>클라이언트앱은 사용자의 우치와 검색 반경을 로드밸런서로 전송&lt;/li>
&lt;li>해당 요청을 LBS로 보냄&lt;/li>
&lt;li>LBS는 검색 요건을 만족할 지오해시 길이를 계산(예시에선 6)&lt;/li>
&lt;li>LBS는 인접한 지오해시를 계산한 후 목록에 추가
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">list_of_geohashes = [my_geohash, neigbor1_geohash ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>list_of_geohashes&lt;/code> 내에 있는 지오해시 각가에 대해 지오해시 레디스 서버를 호출하여 해당 지오해시에 대응하는 모든 사업장 ID를 추출
&lt;ul>
&lt;li>가져오는 연산을 병렬적으로 수행하면 검색 결과를 내는 지연시간을 줄일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>반환된 사업장 ID들을 가지고 사업장 정보 레디스 서버를 조회하여 각 사업장의 상세 정보를 취득
&lt;ul>
&lt;li>상세 정보에 의거하여 사업장과 사용자 간 거리를 계산하고, 우선순위를 매긴 다음 클라이언트앱에 반환&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="사업장-정보-조회-갱신-추가-그리고-삭제">사업장 정보 조회, 갱신, 추가 그리고 삭제&lt;/h4>
&lt;p>모든 사업장 정보 관련 API는 분리되어 있다.&lt;/p>
&lt;ul>
&lt;li>사업장 상세정보를 확인하기 위해 사업장 정보 서비스는 우선 해당 데이터가 사업장 정보 레디스 서버에 기록되어 있는지 살핀다.
&lt;ul>
&lt;li>캐시되어 있는 경우 해당 데이터를 읽어 클라이언트로 반환한다.&lt;/li>
&lt;li>없는 경우 데이터베이스 클러스터에서 사업장 정보를 읽어 캐시에 저장한 다음 반환&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>새로 추가하거나 갱신한 정보는 다음날 반영된다는 정책으로 인해 캐시에 보관된 정보 갱신은 밤 사이 작업을 돌려 처리할 수 있다.&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>주변 검색 기능의 핵심인 근접성 서비스를 설계해 보았다.&lt;/p>
&lt;p>지리 정보 색인 기법을 활용하는 전형적인 LBS 서비스다.&lt;/p>
&lt;ul>
&lt;li>색인 방안
&lt;ul>
&lt;li>2차원 검색&lt;/li>
&lt;li>균등 분할 격자&lt;/li>
&lt;li>지오해시&lt;/li>
&lt;li>쿼드트리&lt;/li>
&lt;li>구글 S2&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지오해시를 사용한 지리정보 색인 동작 원리&lt;/li>
&lt;li>캐시를 활용한 지연 시간 감소 방법&lt;/li>
&lt;li>캐시 대상 정보&lt;/li>
&lt;li>바르게 주변 사업장을 검색하기 위한 캐시 활용법&lt;/li>
&lt;li>복제와 샤딩을 통한 데이터베이스 규모 확장법&lt;/li>
&lt;li>LBS를 여러 지역과 가용성 구역에 설치
&lt;ul>
&lt;li>가용성 상승&lt;/li>
&lt;li>사용자와 서버 사이 통신 지연 감소&lt;/li>
&lt;li>각 지역 별 사생활 보호법 준수하는 방법&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="요약">요약&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/1/img_14.png"
width="701"
height="1207"
srcset="https://codemario318.github.io/post/system-design-interview-2/1/img_14_hu6714b850b52f80eaff9bcd05f8c595a9_271468_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/1/img_14_hu6714b850b52f80eaff9bcd05f8c595a9_271468_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="1장 요약"
class="gallery-image"
data-flex-grow="58"
data-flex-basis="139px"
>&lt;/p></description></item><item><title>Git 객체로 살펴보는 add와 commit</title><link>https://codemario318.github.io/post/git/add-commit/</link><pubDate>Wed, 31 Jul 2024 13:17:42 +0900</pubDate><guid>https://codemario318.github.io/post/git/add-commit/</guid><description>&lt;img src="https://codemario318.github.io/post/git/add-commit/cover.png" alt="Featured image of post Git 객체로 살펴보는 add와 commit" />&lt;p>&lt;strong>Git&lt;/strong>은 분산형 버전 관리 시스템(Distributed Version Control System, DVCS)으로, 소스 코드와 파일의 변경 이력을 관리하는 도구입니다.&lt;/p>
&lt;p>&lt;strong>Git&lt;/strong>을 활용하려면 원하는 디렉토리 경로에 &lt;code>git init&lt;/code> 명령을 실행하게되는데, 이때 &lt;code>.git&lt;/code> 디렉토리가 만들어집니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/git/add-commit/img_1.png"
width="471"
height="311"
srcset="https://codemario318.github.io/post/git/add-commit/img_1_hu2a5eb33a792f1a5359f11c4937882c21_37732_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/git/add-commit/img_1_hu2a5eb33a792f1a5359f11c4937882c21_37732_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt=".git 내부 구조"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="363px"
>&lt;/p>
&lt;p>이 때 만들어지는 &lt;code>.git&lt;/code> 디렉토리는 저장소(repository)의 &lt;strong>메타데이터&lt;/strong>와 &lt;strong>Git 객체&lt;/strong>들을 저장하는 장소이며, 그 중 &lt;strong>Git 객체&lt;/strong>는 저장소의 데이터를 관리하고 추적하는데 핵심입니다.&lt;/p>
&lt;p>&lt;strong>Git&lt;/strong>은 &lt;strong>Git 객체&lt;/strong>와 워킹 디렉토리의 파일들을 기준으로 변경을 감지하고, &lt;code>Git 객체&lt;/code>의 정보를 통해 코드의 버전들을 관리하고 추적하게됩니다.&lt;/p>
&lt;p>이를 조금 더 자세히 살펴보겠습니다.&lt;/p>
&lt;h2 id="git-객체">Git 객체&lt;/h2>
&lt;p>&lt;code>.git&lt;/code> 디렉토리 아래에 있는 &lt;code>/objects&lt;/code> 디렉토리에 파일로 저장되는 &lt;strong>Git 객체&lt;/strong>는 Git의 핵심으로, 모든 데이터의 내용과 실제 저장 위치를 의미하게 됩니다.&lt;/p>
&lt;p>실제 &lt;code>/objects&lt;/code>의 경로를 확인하면 아래와 같은 구조를 확인할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">/objects
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── 0d
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── df0ae059b771e502af67931f9f8a4a17632661
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── 24
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── 643cc37449b4bde54411a80b8ed61258225e34
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── 35
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── eb1ddfbbc029bcab630581847471d7f238ec53
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── 6c
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── 435e543633035641c810e97681b078d627a946
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── a6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── d422786b4daf0d8cbd7466a02e4a4fa9fd8570
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── b1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── 7d46df496e1a6aef89fc6d67937a2ba47b5d33
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── info
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">└── pack
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── pack-15a971ce7fbb8c9997e7e167347a23bbfe438d71.idx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> └── pack-15a971ce7fbb8c9997e7e167347a23bbfe438d71.pack
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>파일의 경로가 &lt;strong>2글자로 시작하는 디렉토리&lt;/strong> 아래에 &lt;strong>불특정한 38자 이름&lt;/strong>을 가진 파일이 저장되어있는데, 이 저장된 파일이 &lt;strong>Git 객체&lt;/strong>입니다.&lt;/p>
&lt;h3 id="git-객체의-이름-상태가">Git 객체의 이름 상태가&amp;hellip;?&lt;/h3>
&lt;p>저장되는 파일 이름을 보시면 어느정도 눈치 채셨을 것 같은데요.&lt;/p>
&lt;p>&lt;code>Git&lt;/code> 객체가 위치와 이름은 총 40자, 16진수 문자열로 파일의 전체 내용을 &lt;code>SHA-1&lt;/code> 함수로 해싱한 결과입니다.&lt;/p>
&lt;p>이로인해 파일 내용의 무결성을 보장함은 물론 파일을 거의 유일하게 식별할 수 있습니다.&lt;/p>
&lt;p>해시값을 사용하는 이유는 파일의 내용이 변경되면 아예 다른 결과가 반환되는 해시 함수의 특징을 활용해 &lt;strong>파일의 변경&lt;/strong>을 간편하게 확인하기 위함입니다.&lt;/p>
&lt;p>파일 내용이 &lt;code>e69de29bb2d1d6434b8b29ae775ad8c2e48c5391&lt;/code> 해시 값을 가진다면, &lt;code>.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391&lt;/code>에 저장됩니다.&lt;/p>
&lt;p>앞에 2자를 분리해 굳이 디렉토리로 만든 이유는 2가지 정도로 확인됩니다.&lt;/p>
&lt;ul>
&lt;li>성능 최적화
&lt;ul>
&lt;li>한 디렉토리 내에 너무 많은 파일을 저장하면 성능이 저하됨&lt;/li>
&lt;li>수천 개 또는 수십만 개 파일을 하나의 디렉토리에 저장하면 검색, 파일 생성 및 접근 속도가 느려질 수 있음&lt;/li>
&lt;li>객체들을 고르게 분산하여 저장할 수 있어 성능 저하를 방지할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>관리 용이
&lt;ul>
&lt;li>디렉토리 구조로 나눔으로써 객체 파일을 관리하고 탐색하는 것이 더 쉬워짐(2자로 디렉터리를 바로 찾을 수 있음)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="내용물은">내용물은?&lt;/h3>
&lt;p>문서 혹은 파일의 내용으로 만들어지는 해시값을 경로로 저장되는 Git 객체 파일에는 해시값을 만드는데 사용하기도 했던 파일의 전체 내용을 압축하여 저장합니다.&lt;/p>
&lt;h3 id="git-객체의-종류">Git 객체의 종류&lt;/h3>
&lt;p>&lt;strong>Git 객체&lt;/strong>는 3가지 유형이 존재합니다.&lt;/p>
&lt;ul>
&lt;li>파일의 저장 경로와 파일의 내용은 모두 위와 동일하게 만들어집니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>블롭(&lt;code>Blob&lt;/code>)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>파일의 내용 자체를 저장&lt;/li>
&lt;li>파일의 이름이나 메타데이터는 저장하지 않고 파일의 원본 내용만 저장함&lt;/li>
&lt;/ul>
&lt;p>블롭 유형의 파일은 데이터 원본의 내용만을 압축하여 저장합니다.&lt;/p>
&lt;p>압축하여 저장된 원본 데이터는 복구 등의 처리에서 활용됩니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>트리(&lt;code>Tree&lt;/code>)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>디렉터리의 구조를 저장&lt;/li>
&lt;li>디렉터리의 파일 및 하위 디렉터리와 그에 대한 블롭 객체 객체의 참조를 포함(트리는 블롭과 또 다른 트리로 구성됨)&lt;/li>
&lt;/ul>
&lt;p>트리 객체를 통해 디렉토리 구조를 관리할 수 있게 됩니다.&lt;/p>
&lt;p>트리 객체가 의미하는 디렉토리의 존재하는 모든 &lt;strong>파일&lt;/strong>, &lt;strong>디렉토리&lt;/strong>들의 경로(파일 주소)를 Git 객체의 값으로 압축하여 저장하게 됩니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>커밋(&lt;code>Commit&lt;/code>)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>커밋 정보를 저장&lt;/li>
&lt;li>커밋 메시지, 작성자, 날짜 및 커밋 시점의 트리 객체를 포함&lt;/li>
&lt;/ul>
&lt;p>직전 루트 트리 객체의 주소(파일 경로), 현재 루트 트리 객체의 주소(파일 경로)와 커밋 메시지 등 메타데이터를이 압축되어 저장됩니다.&lt;/p>
&lt;h2 id="git-add">&lt;code>git add&lt;/code>&lt;/h2>
&lt;p>&lt;code>git add&lt;/code> 명령어는 작업 디렉토리에서 변경된 파일들을 스테이징 영역에 추가하여 다음 커밋에 포함될 파일들을 준비하게됩니다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>작업 디렉토리&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>사용자가 작업 중인 실제 파일들이 존재하는 디렉토리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>인덱스(스테이징 영역)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>커밋을 준비하기 위해 변경된 파일들이 추가되는 영역&lt;/li>
&lt;li>인덱스는 &lt;code>.git/index&lt;/code> 파일에 저장됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>먼저 변경된 파일들을 어떻게 관리하는지 확인해보겠습니다.&lt;/p>
&lt;h3 id="파일의-추적-상태">파일의 추적 상태&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/git/add-commit/img.png"
width="800"
height="330"
srcset="https://codemario318.github.io/post/git/add-commit/img_hu0d2cd540fc510e4ec1c1a61158d3600f_25950_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/git/add-commit/img_hu0d2cd540fc510e4ec1c1a61158d3600f_25950_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="파일 상태 변화"
class="gallery-image"
data-flex-grow="242"
data-flex-basis="581px"
>&lt;/p>
&lt;p>Git은 작업 디렉토리의 파일을 4가지 상태로 추적, 관리합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>UnTracked&lt;/code>: 추적되지 않는 파일
&lt;ul>
&lt;li>Git에 등록되지않아 추적되지 않는 상태&lt;/li>
&lt;li>Git이 버전 관리하고 있지 않은 파일&lt;/li>
&lt;li>새로 생성된 파일이거나, 추적되지 않도록 명시적으로 설정된 파일(.gitignore)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Unmodified&lt;/code>: 수정되지 않은 파일
&lt;ul>
&lt;li>Git이 추적하고 있는 파일이지만, 마지막 커밋 이후 변경되지 않은 상태&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Modified&lt;/code>: 수정된 파일
&lt;ul>
&lt;li>Git이 추적하고 있는 파일이지만, 마지막 커밋 이후로 파일의 내용이 변경된 상태&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Staged&lt;/code>: 스테이징된 파일
&lt;ul>
&lt;li>&lt;code>git add&lt;/code> 명령을 통해 스테이징 영역에 추가된 상태&lt;/li>
&lt;li>다음 커밋에 포함될 준비가 되었다는 의미&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>&lt;code>Untracked&lt;/code> -&amp;gt; &lt;code>Staged&lt;/code>&lt;/strong>&lt;/p>
&lt;p>Git으로 관리되고 있는 프로젝트에 처음 생성된 파일은 &lt;code>UnTracked&lt;/code> 상태입니다. 즉 Git이 추적하고 있지 않은 상태임을 의미합니다.&lt;/p>
&lt;p>&lt;code>git add&lt;/code> 명령을 수행하면 해당 파일이 스태이징 영역에 추가되며 &lt;code>Staged&lt;/code> 상태로 변경됩니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>Unmodified&lt;/code> -&amp;gt; &lt;code>Modified&lt;/code>&lt;/strong>&lt;/p>
&lt;p>Git을 통해 추적하고 있지만, 마지막 변경 이후 수정되지 않았다면 &lt;code>Unmodifed&lt;/code> 상태입니다.&lt;/p>
&lt;p>&lt;code>Unmodifed&lt;/code> 상태의 파일에 변경이 발생하면(이전과 다른 부분이 발생하면) &lt;code>Modifed&lt;/code> 상태가 됩니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>Modified&lt;/code> -&amp;gt; &lt;code>Staged&lt;/code>&lt;/strong>&lt;/p>
&lt;p>&lt;code>Unmodified&lt;/code> 상태인 파일에 변경이 발생하여 &lt;code>Modifed&lt;/code> 상태가 되었을 때 &lt;code>git add&lt;/code> 명령로 스테이징 영역에 추가할 수 있습니다.&lt;/p>
&lt;h3 id="git에서-일어나는-일">&lt;code>.git&lt;/code>에서 일어나는 일&lt;/h3>
&lt;p>이제는 &lt;code>.git&lt;/code> 내부에 어떤 일들이 발생하는지 살펴보겠습니다.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>변경된 파일의 해시 계산&lt;/strong>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;code>git add&lt;/code> 명령어가 실행되면, Git은 현재 인덱스 파일(&lt;code>.git/index&lt;/code>)의 기록된 정보를 활용하여 작업 디렉토리에서 변경된 파일의 내용을 찾아 읽습니다.
&lt;ul>
&lt;li>&lt;code>Untracked&lt;/code>, &lt;code>Modified&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>변경된 파일의 내용을 기반으로 SHA-1 해시를 계산하여 고유한 해시 값을 생성합니다.(Git 객체의 이름, 저장될 경로)&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>&lt;strong>객체 생성 및 저장&lt;/strong>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>생성된 해시값을 이용하여 파일의 내용을 Git 객체로 저장합니다.(Blob)
&lt;ul>
&lt;li>Blob 객체는 파일의 바이너리 데이터를 담고 있으며, &lt;code>.git/obects&lt;/code> 디렉토리에 저장&lt;/li>
&lt;li>저장 경로는 해시값의 처음 두자리를 디렉토리 이름으로 사용하고, 나머지 38자리를 파일 이름으로 사용하여 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>&lt;strong>인덱스 업데이트&lt;/strong>
&lt;ul>
&lt;li>Blob 객체가 생성되고 저장된 후, Git은 인덱스 파일(&lt;code>.git/index&lt;/code>)을 업데이트합니다.
&lt;ul>
&lt;li>파일의 모드, 해시 값, 파일 이름 등을 기록합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="index">&lt;strong>&lt;code>index&lt;/code>&lt;/strong>&lt;/h3>
&lt;p>&lt;code>index&lt;/code> 파일은 &lt;code>stage&lt;/code> 영역에 있는 파일들 즉 작업 디렉토리 내 추적중인 파일을 의미하며, 다음 &lt;code>commit&lt;/code>에 포함될 파일의 정보들을 의미하게됩니다.&lt;/p>
&lt;p>만약 &lt;code>git init&lt;/code> 명령을 수행하고 &lt;code>README.md&lt;/code>와 &lt;code>src/index.js&lt;/code>를 추가한 후 &lt;code>git add&lt;/code> 명령을 수행했다면 &lt;code>.git/index&lt;/code> 파일의 내용은 아래와 같이 수정됩니다.(해시 값은 임의로 설정하였습니다.)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0 README.md
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">100644 24643cc37449b4bde54411a80b8ed61258225e34 0 src/index.js
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>띄어쓰기로 구분되는 각 요소는 &lt;code>파일 모드&lt;/code>, &lt;code>해시값&lt;/code>, &lt;code>스테이지 번호&lt;/code>, &lt;code>파일 경로&lt;/code>를 의미합니다.&lt;/p>
&lt;p>여기서 주의해야할 점은 &lt;code>.git/index&lt;/code>에는 &lt;code>Blob&lt;/code> 객체만 저장된다는 점 입니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>파일 모드&lt;/strong>&lt;/p>
&lt;p>맨 앞의 &lt;code>100644&lt;/code>는 파일 식별자로 흔히 알려진 파일의 권한을 포함하게됩니다.&lt;/p>
&lt;p>그 역할은 아래와 같습니다.&lt;/p>
&lt;ul>
&lt;li>읽기, 쓰기 파일(블롭): &lt;code>100644&lt;/code> (&lt;code>chmod 644&lt;/code>)&lt;/li>
&lt;li>실행 파일(블롭): &lt;code>100755&lt;/code> (&lt;code>chmod 755&lt;/code>)&lt;/li>
&lt;li>디렉터리(트리): &lt;code>040000&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>.git/index&lt;/code>는 &lt;code>Blob&lt;/code> 객체 정보만 관리하므로 읽기 파일, 실행 파일만 저장됩니다.&lt;/p>
&lt;p>&lt;code>Tree&lt;/code> 객체를 를 의미하는 &lt;code>040000&lt;/code>는 이후 커밋에 활용됩니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>스테이지 번호&lt;/strong>&lt;/p>
&lt;p>스테이지 번호는 병합 충돌 시 사용되는 필드입니다. 파일이 정상적으로 추가되었을 때는 &lt;code>0&lt;/code> 입니다.&lt;/p>
&lt;ul>
&lt;li>0: 기본 스테이지. 충돌이 없는 파일이 여기에 위치합니다.&lt;/li>
&lt;li>1: 공통 조상 (ancestor) 버전.&lt;/li>
&lt;li>2: 현재 브랜치 (our) 버전.&lt;/li>
&lt;li>3: 병합하려는 브랜치 (their) 버전.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>&lt;code>.git/index&lt;/code>의 역할&lt;/strong>&lt;/p>
&lt;p>인덱스 파일의 역할을 정리해보면 아래와 같습니다.&lt;/p>
&lt;ul>
&lt;li>인덱스 파일은 다음 커밋에 포함될 파일들을 추적합니다.&lt;/li>
&lt;li>인덱스에 추가된 파일들은 다음 &lt;code>git commit&lt;/code> 명령어가 실행될 때 커밋 히스토리에 포함됩니다.&lt;/li>
&lt;/ul>
&lt;h2 id="git-commit">&lt;code>git commit&lt;/code>&lt;/h2>
&lt;p>&lt;code>git commit&lt;/code> 명령어가 실행되었을 때 어떤 흐름이 발생하는지 확인해보겠습니다.&lt;/p>
&lt;ol>
&lt;li>&lt;code>Tree&lt;/code> 객체 생성
&lt;ul>
&lt;li>인덱스 파일에 기록된 내용을 바탕으로 트리 객체가 생성됩니다.&lt;/li>
&lt;li>트리 객체는 디렉토리 구조와 파일 정보를 담고 있으며, 각 파일은 &lt;code>Blob&lt;/code> 객체와 &lt;code>Tree&lt;/code> 객체를 가리킵니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Commit&lt;/code> 객체 생성
&lt;ul>
&lt;li>트리 객체가 생성된 후, 커밋 객체가 생성됩니다.
&lt;ul>
&lt;li>트리 객체의 해시 값&lt;/li>
&lt;li>부모 커밋(이전 커밋)의 해시 값(최초 커밋인 경우 제외)&lt;/li>
&lt;li>커밋 메시지&lt;/li>
&lt;li>작성자와 커미터 정보(이름, 이메일, 타임스탬프 등)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객체 저장 및 참조 업데이트
&lt;ul>
&lt;li>객체 저장
&lt;ul>
&lt;li>생성된 커밋 객체와 트리 객체는 &lt;code>.git/objects&lt;/code> 디렉토리에 저장됩니다.&lt;/li>
&lt;li>&lt;code>Blob&lt;/code> 객체와 마찬가지로 각 객체는 해시값을 기반으로 저장됩니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>참조 업데이트
&lt;ul>
&lt;li>새로운 커밋 객체가 생성되면, 현재 브랜치의 참조가 새로운 커밋을 가리키도록 업데이트 합니다.
&lt;ul>
&lt;li>현재 브랜치의 참조는 &lt;code>.git/refs/heads/&amp;lt;브랜치 이름&amp;gt;&lt;/code> 파일에 저장&lt;/li>
&lt;li>&lt;code>main&lt;/code>인 경우 &lt;code>.git/refs/heads/main&lt;/code> 파일의 내용이 새로운 커밋의 해시값으로 업데이트&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>새 커밋이 생성되면서 Git은 버전 히스토리를 관리합니다.&lt;/p>
&lt;p>각 커밋 객체는 이전 커밋 객체(부모 객체)를 가르키며, 이를 통해 커밋 히스토리가 마치 &lt;strong>연결 리스트&lt;/strong> 형태로 구성됩니다.&lt;/p>
&lt;h3 id="tree-객체의-구성">&lt;code>Tree&lt;/code> 객체의 구성&lt;/h3>
&lt;p>처음 &lt;code>git commit&lt;/code> 명령이 수행되면 작업 디렉토리를 기반으로 트리 객체를 만들게됩니다.&lt;/p>
&lt;p>트리 객체는 특정 디렉터리 내부에 포함되는 모든 파일(&lt;code>Blob&lt;/code> 객체), 디렉토리(&lt;code>Tree&lt;/code> 객체)의 해시값을 내용으로 가지며, 작업 디렉토리가 아래와 같은 구조를 가진다고 가정하고 내부 구조를 확인해보겠습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">project/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── README.md
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">└── src/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> └── index.js
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>작업 디렉터리의 루트 &lt;code>Tree&lt;/code> 객체는 아래와 같은 내용을 가지게됩니다.(해시값은 임의로 작성하였습니다.)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 README.md
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea0ea1e1 src
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>src&lt;/code> 디렉토리를 의미하는 &lt;code>Tree&lt;/code> 객체는 아래와 같은 내용을 가집니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">100644 24643cc37449b4bde54411a80b8ed61258225e34 index.js
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>각 내용들이 디렉토리를 구성하는 &lt;code>Git&lt;/code> 객체의 주소값을 가르키게됩니다.&lt;/p>
&lt;h3 id="commit-객체의-구성">&lt;code>Commit&lt;/code> 객체의 구성&lt;/h3>
&lt;p>&lt;code>Tree&lt;/code> 객체가 만들어지면 작업 디렉토리의 &lt;code>Tree&lt;/code> 객체(루트 &lt;code>Tree&lt;/code> 객체)의 주소를 이용하여 &lt;code>Commit&lt;/code> 객체를 만들게됩니다.&lt;/p>
&lt;p>&lt;code>Commit&lt;/code> 객체의 내용에는 작업 디렉토리의 루트 &lt;code>Tree&lt;/code> 객체의 해시값, 부모 커밋의 해시값, 커밋 메시지, 작성자와 커밋터의 정보가 담깁니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">tree &amp;lt;작업 디렉토리의 Tree 객체의 해시 값&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">parent &amp;lt;이전 커밋의 해시 값(첫 커밋이라면 생략)&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">author John Doe &amp;lt;john.doe@example.com&amp;gt; 1609459200 +0000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">committer John Doe &amp;lt;john.doe@example.com&amp;gt; 1609459200 +0000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;lt;커밋 메시지&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="요약">요약&lt;/h3>
&lt;ul>
&lt;li>&lt;code>git commit&lt;/code> 명령어는 스테이징 영역의 파일들을 기반으로 트리 객체를 생성하고, 이를 참조하는 커밋 객체를 생성합니다.&lt;/li>
&lt;li>생성된 커밋 객체는 &lt;code>.git/objects&lt;/code> 디렉토리에 저장되며, 현재 브랜치의 참조가 새로운 커밋 객체를 가리키도록 업데이트됩니다.&lt;/li>
&lt;li>이 과정은 Git의 분산 버전 관리 시스템이 효율적으로 파일의 변경 이력을 관리하고 추적할 수 있게 합니다.&lt;/li>
&lt;/ul>
&lt;h2 id="마무리">마무리&lt;/h2>
&lt;p>이전부터 &lt;code>.git&lt;/code>의 존재는 알았지만, 왜 존재하는지, 어떻게 구성되어있는지, 역할이 뭔지 등에 대해서는 큰 관심이 없었습니다.&lt;/p>
&lt;p>이번 기회를 통해 &lt;code>.git&lt;/code>의 내부 파일들(&lt;code>Git&lt;/code> 객체)의 상태 변화를 확인하면서 &lt;code>add&lt;/code>와 &lt;code>commit&lt;/code> 명령이 어떻게 수행되는지 더 깊이 이해할 수 있어 좋은 경험이었네요 😁&lt;/p>
&lt;p>읽어보시고 잘못된 정보나, 이해가 어려운 부분이 있다면 댓글 남겨주세요!&lt;/p>
&lt;p>틀린 내용이 있다면 빠르게 반영하고, 이해가 어려운 부분은 같이 다시 고민해볼 기회가 될 수 있을것 같습니다🔥&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다.😊&lt;/p></description></item><item><title>Jest를 활용한 유닛 테스트</title><link>https://codemario318.github.io/post/jest-unit-test/</link><pubDate>Tue, 23 Jul 2024 13:53:35 +0900</pubDate><guid>https://codemario318.github.io/post/jest-unit-test/</guid><description>&lt;img src="https://codemario318.github.io/post/jest-unit-test/cover.png" alt="Featured image of post Jest를 활용한 유닛 테스트" />&lt;h2 id="소프트웨어-테스트란">소프트웨어 테스트란?&lt;/h2>
&lt;p>소프트웨어 테스트는 소프트웨어가 요구사항을 충족하는지, 결함이 없는지, 의도한 대로 작동하는지를 확인하는 것을 목표로 수행됩니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/jest-unit-test/img.png"
width="1024"
height="680"
srcset="https://codemario318.github.io/post/jest-unit-test/img_hu34b341a957e0c9749c8004b23f93334d_19212_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/jest-unit-test/img_hu34b341a957e0c9749c8004b23f93334d_19212_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="TDD"
class="gallery-image"
data-flex-grow="150"
data-flex-basis="361px"
>&lt;/p>
&lt;p>예를 들면 &lt;strong>TDD&lt;/strong>에서 파생된 &lt;strong>BDD&lt;/strong>(행위 주도 개발)는 테스트 코드를 작성할 때 수행할 행위에 대한 명세를 &lt;strong>비 기술적인&lt;/strong> 방식으로 작성하여 명세상의 요구사항을 만족하고 있는지 파악하는데 큰 도움을 주기도합니다.&lt;/p>
&lt;p>이러한 이유로 어떤 회사에서는 개발을 시작하기 전 기획서를 기반으로 요구사항을 테스트 코드에 옮겨놓는 작업부터 하는 곳도 있다고 들었습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/jest-unit-test/img_1.png"
width="640"
height="463"
srcset="https://codemario318.github.io/post/jest-unit-test/img_1_hu8a95588ee7e37a1467ddf58bf0d04b87_277163_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/jest-unit-test/img_1_hu8a95588ee7e37a1467ddf58bf0d04b87_277163_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="138"
data-flex-basis="331px"
>&lt;/p>
&lt;p>그리고 최근 접했던 &lt;strong>개발자 원칙&lt;/strong>이라는 책에서 &lt;strong>탁월한 성과를 내는 조직의 공통점&lt;/strong>은 &lt;strong>심리적 안정감&lt;/strong>이라는 내용이 있었습니다.&lt;/p>
&lt;p>&lt;strong>심리적 안정감&lt;/strong>은 &lt;strong>실수가 드러났을 때에도 처벌받거나 놀림 받지 않을 것 이라는 믿음&lt;/strong>이라고 하는데, 테스트는 조금 다른 관점에서 &lt;strong>실수가 발생하지 않을 것 이라는 믿음&lt;/strong>을 통해 &lt;strong>안정감&lt;/strong>을 느끼게되어 도전적인 시도를 많이하게 되었다는 의견이 많은 것 같습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/jest-unit-test/img_2.png"
width="1024"
height="768"
srcset="https://codemario318.github.io/post/jest-unit-test/img_2_huf4fe4d3807eda6911a791cff0f5cfe22_449498_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/jest-unit-test/img_2_huf4fe4d3807eda6911a791cff0f5cfe22_449498_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="V 모델"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="320px"
>&lt;/p>
&lt;p>이처럼 테스트는 소프트웨어가 단순히 요구사항을 충족하는지, 결함이 없는지, 의도하는 대로 작동하는지 확인하는 것을 넘어서 &lt;strong>안정감&lt;/strong> 같은 부과적인 효과를 위해서라도 현재 가장 중요한 프로세스라는 평가도 있을 정도입니다.&lt;/p>
&lt;h2 id="unit-test란">Unit Test란?&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/jest-unit-test/img_3.png"
width="1076"
height="1092"
srcset="https://codemario318.github.io/post/jest-unit-test/img_3_hub49cc3aa594321fb7e04a428f3a9147d_349149_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/jest-unit-test/img_3_hub49cc3aa594321fb7e04a428f3a9147d_349149_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="테스트 피라미드"
class="gallery-image"
data-flex-grow="98"
data-flex-basis="236px"
>&lt;/p>
&lt;p>테스트의 시작점이라고도 할 수 있는 단위 테스트는 프로그래밍의 최소 단위(함수, 메서드, 객체)를 테스트하는 방법 입니다.&lt;/p>
&lt;p>주요 목적은 각 단위가 예상대로 작동하는지 확인하는 것이며, 소프트웨어 개발 과정에서 매우 중요한 단계로, 코드의 결함을 조기에 발견하고 수정할 수 있도록 도와줍니다.&lt;/p>
&lt;h3 id="주요-특징">주요 특징&lt;/h3>
&lt;p>단위 테스트의 주요 특징은 아래와 같습니다.&lt;/p>
&lt;ul>
&lt;li>빠른 피드백(Quickly)
&lt;ul>
&lt;li>코드를 수정한 직후에 피드백을 받을 수 있도록 빠르게 수행되어야 함&lt;/li>
&lt;li>단위 테스트는 매우 작은 코드 단위를 테스트하기 때문에 빠르게 실행됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>독립성(Isolation)
&lt;ul>
&lt;li>각 테스트는 다른 테스트와 독립적으로 실행되어 테스트 간의 상호작용이나 의존성을 최소화해야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작은 검증 단위(Veridate)
&lt;ul>
&lt;li>작은 단위를 검증해야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>자동화 가능성(Automatic)
&lt;ul>
&lt;li>자동화되어 개발 과정에서 지속적으로 실행되어야 함&lt;/li>
&lt;li>따라서 반복적인 테스트 작업을 효율적으로 수행 가능해야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개발자 주도
&lt;ul>
&lt;li>개발자가 작성하고 유지 관리함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="좋은-단위-테스트의-특징">좋은 단위 테스트의 특징&lt;/h3>
&lt;p>좋은 단위 테스트는 다음과 같은 특징들을 갖습니다.&lt;/p>
&lt;ul>
&lt;li>독립적
&lt;ul>
&lt;li>각 테스트는 다른 테스트와 독립적으로 실행되어야 함&lt;/li>
&lt;li>테스트가 서로에게 의존하게 되면 문제를 파악하기 어려워짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>자동화 가능
&lt;ul>
&lt;li>단위 테스트는 자동으로 실행될 수 있어야 함&lt;/li>
&lt;li>자동화된 테스트는 반복적으로 실행할 수 있어 지속적인 피드백을 제공할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>반복 가능
&lt;ul>
&lt;li>테스트는 언제든지 반복해서 실행할 수 있어야 하며, 실행할 때마다 동일한 결과를 제공해야 함&lt;/li>
&lt;li>외부 요인에 의한 변동이 없어야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>빠른 실행
&lt;ul>
&lt;li>단위 테스트는 빠르게 실행되어야 함&lt;/li>
&lt;li>테스트 실행 시간이 길어지면 개발자가 자주 실행하기 어려워지고 피드백 속도가 느려짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>명확한 목적
&lt;ul>
&lt;li>각 테스트는 특정 기능이나 동작을 검증하는 명확한 목적을 가져야 함&lt;/li>
&lt;li>무엇을 테스트하는지 분명히 알 수 있어야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가독성
&lt;ul>
&lt;li>테스트 코드는 읽기 쉬워야 함&lt;/li>
&lt;li>다른 개발자가 테스트 코드를 보고 쉽게 이해할 수 있어야 하며, 테스트의 의도를 명확히 파악할 수 있어야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>설정 및 정리
&lt;ul>
&lt;li>테스트 실행 전후에 필요한 설정(setup)과 정리(teardown) 작업이 명확히 정의되어 있어야 함&lt;/li>
&lt;li>이는 테스트 환경을 일관되게 유지하는 데 중요함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단일 검증
&lt;ul>
&lt;li>각 테스트는 하나의 동작이나 기능을 검증해야 함&lt;/li>
&lt;li>어떤 테스트가 실패했을 때 그 원인을 쉽게 파악할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>신뢰성
&lt;ul>
&lt;li>테스트는 항상 일관된 결과를 제공해야 함&lt;/li>
&lt;li>테스트 결과가 불안정하면 테스트의 신뢰성이 떨어짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>의존성 최소화
&lt;ul>
&lt;li>외부 시스템이나 데이터베이스와 같은 외부 의존성에 최소한으로 의존해야 함&lt;/li>
&lt;li>필요하다면 목(Mocks)이나 스텁(Stubs) 같은 테스트 대역을 사용하여 외부 의존성을 격리할 수 있어야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>요약하면 좋은 단위 테스트는 소프트웨어 개발 프로세스의 효율성을 높이고, 코드의 신뢰성을 강화하며, 유지 보수성을 향상시키는 데 중요한 역할을 합니다. 참 어렵군요..😂&lt;/p>
&lt;h2 id="jest란">Jest란?&lt;/h2>
&lt;p>JS진영에서 많이 활용되는 테스트 도구로 &lt;code>Jest&lt;/code>, &lt;code>Mocha&lt;/code> 등이 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/jest-unit-test/img_4.png"
width="484"
height="484"
srcset="https://codemario318.github.io/post/jest-unit-test/img_4_hu6667362b1aeecce3369b167bd4546191_67465_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/jest-unit-test/img_4_hu6667362b1aeecce3369b167bd4546191_67465_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Jest"
class="gallery-image"
data-flex-grow="100"
data-flex-basis="240px"
>&lt;/p>
&lt;p>그 중 &lt;code>Jest&lt;/code>는 &lt;code>Nest.js&lt;/code>, &lt;code>React&lt;/code>에서도 표준으로 사용되고 있을 만큼 활용도가 높은 뿐만 아니라, 단위 테스트, 통합 테스트, 스냅샷 테스트 등 다양한 테스트 유형을 지원하며, 많은 기능들을 지원하고 있으므로 선택하였습니다.&lt;/p>
&lt;h3 id="환경-준비">환경 준비&lt;/h3>
&lt;p>&lt;code>Node.js&lt;/code> 환경에서 &lt;code>Jest&lt;/code>를 사용해보겠습니다. 이를 위해 환경부터 구성해야합니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>node&lt;/code>, &lt;code>npm&lt;/code>는 설치되어 있다고 가정하고 진행합니다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>프로젝트 초기화&lt;/strong>&lt;/p>
&lt;p>새 프로젝트 디렉토리를 만들고, 만들어진 디렉토리에 프로젝트 초기화를 수행합니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">mkdir my-project
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> my-project
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">npm init
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>타입 스크립트는 &lt;code>npm tsc --init&lt;/code> 명령을 수행하면 됩니다.&lt;/p>
&lt;p>&lt;strong>Jest 설치&lt;/strong>&lt;/p>
&lt;p>프로젝트에 &lt;code>Jest&lt;/code>를 개발 의존성(dev dependency)으로 설치합니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">npm install --save-dev jest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>설치가 완료되면 &lt;code>package.json&lt;/code> 파일에 &lt;code>Jest&lt;/code> 관련 설정을 추가합니다.&lt;/p>
&lt;p>&lt;code>scripts&lt;/code> 섹션에 테스트 스크립트를 추가하여 &lt;code>Jest&lt;/code>를 실행할 수 있게 합니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;scripts&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;test&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;jest&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="동작-확인">동작 확인&lt;/h3>
&lt;p>실제 코드를 실행하여 동작을 확인해봅니다.&lt;/p>
&lt;p>&lt;strong>operations.js&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">add&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">module&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">exports&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">add&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>operations.test.js&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">add&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">require&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;./operations&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">test&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;adds 1 + 2 to equal 3&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>실행 결과&lt;/strong>&lt;/p>
&lt;p>명령을 실행하여 테스트를 수행해보겠습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">npm &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>정상적으로 수행되는 것을 확인할 수 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/jest-unit-test/img_5.png"
width="264"
height="260"
srcset="https://codemario318.github.io/post/jest-unit-test/img_5_hu60f9a2aa71392d50cb7cbf55bbc5d494_27548_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/jest-unit-test/img_5_hu60f9a2aa71392d50cb7cbf55bbc5d494_27548_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="실행 결과"
class="gallery-image"
data-flex-grow="101"
data-flex-basis="243px"
>&lt;/p>
&lt;h2 id="jest-기본-함수">Jest 기본 함수&lt;/h2>
&lt;p>&lt;code>Jest&lt;/code>를 사용하기위한 기본적인 함수들을 확인해보겠습니다.&lt;/p>
&lt;h3 id="테스트-함수">테스트 함수&lt;/h3>
&lt;p>&lt;strong>&lt;code>test&lt;/code>, &lt;code>it&lt;/code>&lt;/strong>&lt;/p>
&lt;p>단위 테스트를 정의하는 함수로, 두 함수 모두 동일하게 동작하여 편한 것을 사용하면 되겠습니다.&lt;/p>
&lt;p>테스트를 설명할 문자열과 테스트 본문을 포함하는 콜백 함수를 인자로 받습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">test&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;함수 설명을 입력해주세요&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">someFunction&lt;/span>&lt;span class="p">()).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">expectedValue&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;함수 설명을 입력해주세요&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">someFunction&lt;/span>&lt;span class="p">()).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">expectedValue&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>&lt;code>describe&lt;/code>&lt;/strong>&lt;/p>
&lt;p>테스트를 그룹화 하는 합수입니다.&lt;/p>
&lt;p>관련된 테스트를 하나의 블록으로 묶어 정리할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">describe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;MyComponent&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">test&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;renders correctly&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">test&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;another test&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="기대값-설정-함수">기대값 설정 함수&lt;/h3>
&lt;p>테스트 본문에서 사용하며, 결과가 특정 값임을 확인하는 하게됩니다.&lt;/p>
&lt;p>&lt;strong>&lt;code>expect&lt;/code>&lt;/strong>&lt;/p>
&lt;p>테스트의 기대값을 설정하여, 다양한 매처(Matcher)와 함께 사용되어 값을 검증하게됩니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">value&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">expectedValue&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">array&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toContain&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">item&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">object&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toHaveProperty&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;propertyName&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">function&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toThrow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">error&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>주요 매처&lt;/strong>&lt;/p>
&lt;p>기본적으로 많이 활용되는 매처들은 아래와 같습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>toBe&lt;/code>
&lt;ul>
&lt;li>기본적인 일치 검사를 수행합니다. (엄격한 일치)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>toEqual&lt;/code>
&lt;ul>
&lt;li>객체나 배열의 값을 비교합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>toBeNull&lt;/code>
&lt;ul>
&lt;li>값이 null인지 확인합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>toBeDefined&lt;/code>
&lt;ul>
&lt;li>값이 정의되었는지 확인합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>toBeUndefined&lt;/code>
&lt;ul>
&lt;li>값이 정의되지 않았는지 확인합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>toBeTruthy&lt;/code>
&lt;ul>
&lt;li>값이 true로 평가될 수 있는지 확인합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>toBeFalsy&lt;/code>
&lt;ul>
&lt;li>값이 false로 평가될 수 있는지 확인합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>toContain&lt;/code>
&lt;ul>
&lt;li>배열이나 문자열에 특정 값이 포함되어 있는지 확인합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>toHaveLength&lt;/code>
&lt;ul>
&lt;li>배열이나 문자열의 길이를 확인합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>toHaveProperty&lt;/code>
&lt;ul>
&lt;li>객체가 특정 프로퍼티를 가지고 있는지 확인합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>toMatch&lt;/code>
&lt;ul>
&lt;li>문자열이 정규 표현식과 일치하는지 확인합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>toThrow&lt;/code>
&lt;ul>
&lt;li>함수가 호출될 때 예외를 던지는지 확인합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="모킹-및-스파이">모킹 및 스파이&lt;/h3>
&lt;p>&lt;strong>&lt;code>jest.fn&lt;/code>&lt;/strong>&lt;/p>
&lt;p>모킹 함수 생성에 사용됩니다.&lt;/p>
&lt;p>함수 호출 여부, 호출 횟수, 인자 등을 추적할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">mockFunction&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">jest&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">fn&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">mockFunction&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;arg1&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;arg2&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mockFunction&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toHaveBeenCalled&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mockFunction&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toHaveBeenCalledWith&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;arg1&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;arg2&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>&lt;code>jest.mock&lt;/code>&lt;/strong>&lt;/p>
&lt;p>모듈을 모킹하여 외부 의존성을 대체할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">jest&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;axios&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">axios&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">require&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;axios&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">axios&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">get&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mockResolvedValue&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">data&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;mocked data&amp;#39;&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>&lt;code>jest.spyOn&lt;/code>&lt;/strong>&lt;/p>
&lt;p>객체의 메서드를 감시하여 호출 여부, 호출 횟수, 인자 등을 추적할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">obj&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">method&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="s1">&amp;#39;real implementation&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">spy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">jest&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">spyOn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;method&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">obj&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">method&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;arg1&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">spy&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toHaveBeenCalledWith&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;arg1&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="훅-hooks">훅 Hooks&lt;/h3>
&lt;p>&lt;strong>&lt;code>beforeAll&lt;/code>, &lt;code>afterAll&lt;/code>&lt;/strong>&lt;/p>
&lt;p>각 테스트 블록 전후에 한 번씩 실행됩니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">beforeAll&lt;/span>&lt;span class="p">(()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 모든 테스트 전에 한 번 실행
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">afterAll&lt;/span>&lt;span class="p">(()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 모든 테스트 후에 한 번 실행
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>&lt;code>beforeEach&lt;/code>, &lt;code>afterEach&lt;/code>&lt;/strong>&lt;/p>
&lt;p>각 테스트 전후에 실행됩니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">beforeEach&lt;/span>&lt;span class="p">(()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 각 테스트 전에 실행
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">afterEach&lt;/span>&lt;span class="p">(()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 각 테스트 후에 실행
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="타임아웃-및-기타-설정">타임아웃 및 기타 설정&lt;/h3>
&lt;p>&lt;strong>&lt;code>jest.setTimeout&lt;/code>&lt;/strong>&lt;/p>
&lt;p>테스트의 타임아웃 시간을 설정합니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">jest&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">setTimeout&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10000&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 10초로 타임아웃 설정
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>&lt;code>test.only&lt;/code>&lt;/strong>&lt;/p>
&lt;p>해당 테스트만 실행합니다. 주로 디버깅 용도로 사용됩니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">test&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">only&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;only this test will run&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>&lt;code>test.skip&lt;/code>&lt;/strong>&lt;/p>
&lt;p>해당 테스트를 건너뜁니다. 임시로 테스트를 제외하고자 할 때 사용됩니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">test&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">skip&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;this test will be skipped&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="기타">기타&lt;/h3>
&lt;p>찾아보니 유용해 보이는 다른 기능들도 추가합니다.&lt;/p>
&lt;p>&lt;strong>커버리지 확인&lt;/strong>&lt;/p>
&lt;p>테스트 커버리지를 확인할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">npx jest --coverage
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="마무리">마무리&lt;/h2>
&lt;p>사실 이전 직장에서 테스트 코드의 부재로 인한 고통을 뼈져리게 느꼈었기 때문에 테스트의 중요성은 너무나 잘 알고 있습니다.&lt;/p>
&lt;p>꼭 필요하다고 생각하고 있지만, 습관화가 안되어 아직까지는 잘 활용하지 못하고 있었는데 이번 기회를 시작으로 테스트를 잘 적용해보려고 노력해야겠습니다.&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다.😁&lt;/p></description></item><item><title>14. 유튜브 설계</title><link>https://codemario318.github.io/post/system-design-interview/14/</link><pubDate>Thu, 11 Jul 2024 11:07:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/14/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/cover.png" alt="Featured image of post 14. 유튜브 설계" />&lt;p>유튜브 시스템을 설계하는 방식은 넷플릭스나 훌루 같은 &lt;strong>비디오 플랫폼&lt;/strong>을 설계하는 문제에도 적용 가능하다.&lt;/p>
&lt;p>유튜브 시스템에서 제공하는 기능들은 단순해보이지만, 엄청난 트래픽으로 인해 매우 복잡한 수많은 기술들이 숨어있다.&lt;/p>
&lt;ul>
&lt;li>MAU: 20억&lt;/li>
&lt;li>매일 재생되는 비디오 수: 50억&lt;/li>
&lt;li>5천만명의 창작자&lt;/li>
&lt;li>광고 수입은 2019년 기중 150억 달러&lt;/li>
&lt;li>전체 모바일 트래픽 중 37%는 유튜브&lt;/li>
&lt;li>80개 언어로 사용 가능&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>유튜브에서는 비디오를 보는 것 말고도 많은 일을 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>댓글&lt;/li>
&lt;li>비디오 공유&lt;/li>
&lt;li>좋아요&lt;/li>
&lt;li>재생 목록 저장&lt;/li>
&lt;li>구독&lt;/li>
&lt;/ul>
&lt;p>모든 내용을 설계 면접 동안 만들 수 없으므로, 요구하는 핵심 기능만을 찾아 범위를 제한해야한다.&lt;/p>
&lt;ul>
&lt;li>Q. 가장 중요한 기능은?
&lt;ul>
&lt;li>A. 비디오를 올리는 기능과 시청하는 기능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 지원 클라이언트는?
&lt;ul>
&lt;li>A. 모바일 앱, 웹 브라우저, 스마트 TV&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 일간 능동 사용자 수?
&lt;ul>
&lt;li>A. 5백만&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 이 제품에 평균적으로 소비하는 시간
&lt;ul>
&lt;li>A. 30분&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 다국어 지원?
&lt;ul>
&lt;li>A. 어떤 언어로도 사용 가능해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 비디오 해상도 지원 범위?
&lt;ul>
&lt;li>A. 현존하는 비디오 종류와 해상도를 대부분 지원해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 암호화?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 비디오 파일 크기에 제한?
&lt;ul>
&lt;li>A. 1GB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 클라우드 서비스 사용 가능 여부?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위 질문을 통해 찾아낸 요구사항과 비디오 스트리밍 서비스에 필요한 항목들을 정리하면 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>빠른 비디오 업로드&lt;/li>
&lt;li>원활한 비디오 재생&lt;/li>
&lt;li>재생 품질 선택 가능(대부분의 종류와 해상도 지원)&lt;/li>
&lt;li>낮은 인프라 비용&lt;/li>
&lt;li>높은 가용성과 규모 확장성, 안정성(DAU 5백만)&lt;/li>
&lt;li>지원 클라이언트(모바일 앱, 브라우저, 스마트 TV)&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;p>시스템이 처리해야하는 트래픽 규모를 추정하여 어떤 기술들을 어디까지 활용해야야하는지 파악한다.&lt;/p>
&lt;p>도메인에 대해 정확히 파악할 수 없을 때는 상식적인 범위 내에서 조건을 가정한다.&lt;/p>
&lt;ul>
&lt;li>DAU 5백만&lt;/li>
&lt;li>한 사용자가 하루 평균 5개 비디오 시청&lt;/li>
&lt;li>10%의 사용자가 하루에 비디오 1개 업로드&lt;/li>
&lt;li>비디오의 평균 크기는 300MB&lt;/li>
&lt;li>비디오 저장을 위해 매일 새로 요구되는 저장 용량
&lt;ul>
&lt;li>&lt;code>500만 * 10% * 300MB = 150TB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CDN 비용
&lt;ul>
&lt;li>클라우드 CDN 사용시 나가는 데이터의 양에 따라 과금된다.&lt;/li>
&lt;li>아마존 클라우드 프론트를 사용할 경우, 미국 기준 1GB당 $0.02&lt;/li>
&lt;li>비디오 스트리밍 기준 &lt;code>5백만 * 5 비디오 * 0.3GB * $0.02 = $150,000&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>추정 결과에 따르면 CDN을 통해 비디오를 서비스할 경우 비용이 엄청나다.&lt;/p>
&lt;p>따라서 CDN으로 인한 비용을 줄이는 방법들까지 고민해야한다.&lt;/p>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>이번 설계안은 &lt;strong>CDN&lt;/strong>과 &lt;strong>BLOB 스토리지&lt;/strong>의 경우 기존 클라우드 서비스를 활용한다.&lt;/p>
&lt;ul>
&lt;li>시스템 설계 면접은 모든 것을 밑바닥부터 만드는 것과는 큰 관계는 없다.
&lt;ul>
&lt;li>주어진 시간 안에 적절한 기술을 골라 설계를 마치는 것이 핵심&lt;/li>
&lt;li>모든 세부 컴포넌트에 대해 설계를 제시하는 것은 지나치다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규모 확장이 쉬운 BLOB 저장소, CDN을 만드는 것은 복잡하며, 비용이 많이 든다.
&lt;ul>
&lt;li>넷플릭스, 페이스북 같은 회사들도 클라우드 서비스를 이용할 정도로&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>개략적으로 보면 이 시스템은 세가지 컴포넌트로 구성된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img.png"
width="593"
height="389"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_hu4cce8c795583504b2953e667e22fdfeb_101903_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_hu4cce8c795583504b2953e667e22fdfeb_101903_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="152"
data-flex-basis="365px"
>&lt;/p>
&lt;ul>
&lt;li>사용자 단말&lt;/li>
&lt;li>CDN
&lt;ul>
&lt;li>비디오가 저장되며 재생 버튼을 누르면 CDN으로부터 스트리밍이 이루어진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>API 서버
&lt;ul>
&lt;li>비디오 스트리밍을 제외한 모든 요청은 API 서버가 처리한다.&lt;/li>
&lt;li>피드 추천, 비디오 업로드 URL 생성, 메타데이터 데이터베이스와 캐시 갱신, 사용자 가입 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>핵심 영역인 &lt;strong>비디오 업로드 절차&lt;/strong>와 &lt;strong>비디오 스트리밍 절차&lt;/strong>를 설계한다.&lt;/p>
&lt;h3 id="비디오-업로드-절차">비디오 업로드 절차&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_1.png"
width="656"
height="831"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_1_hu70082ea2eaddf8f402958853a376db04_212338_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_1_hu70082ea2eaddf8f402958853a376db04_212338_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비디오 업로드 절차 설계안"
class="gallery-image"
data-flex-grow="78"
data-flex-basis="189px"
>&lt;/p>
&lt;ul>
&lt;li>API 서버
&lt;ul>
&lt;li>비디오 스트리밍을 제외한 모든 요청 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 DB
&lt;ul>
&lt;li>비디오의 메타데이터 보관&lt;/li>
&lt;li>샤딩과 다중화를 적용하여 성능 및 가용성 요구사항을 충족시킨다고 가정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 캐시
&lt;ul>
&lt;li>비디오 메타데이터와 사용자 객체를 캐싱&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>원본 저장소
&lt;ul>
&lt;li>원본 비디오를 보관할 대형 이진 파일 저장소&lt;/li>
&lt;li>BLOB(Binary Large Object storage)
&lt;ul>
&lt;li>이진 데이터를 하나의 개체로 보관하는 데이터베이스 관리 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>트랜스코딩 서버
&lt;ul>
&lt;li>비디오의 포맷을 변호나하는 절차를 수행하는 서버&lt;/li>
&lt;li>단말, 대역폭 요구사항에 맞는 최적의 비디오 스트림을 제공하기 위해&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>트랜스코딩 비디오 저장소
&lt;ul>
&lt;li>트랜스코딩이 완료된 비디오를 저장하는 BLOB 저장소&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CDN
&lt;ul>
&lt;li>비디오를 캐싱&lt;/li>
&lt;li>비디오 스트리밍은 CDN을 통해 이루어짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>트랜스코딩 완료 큐
&lt;ul>
&lt;li>비디오 트랜스코딩 완료 이벤트를 보관할 메시지 큐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>트랜스코딩 완료 핸들러
&lt;ul>
&lt;li>트랜스코딩 완료 큐에서 이벤트 데이터를 꺼내어 메타데이터 캐시와 데이터베이스를 갱신할 작업 서버들&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_2.png"
width="747"
height="940"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_2_hu7b8c4341cb5ee562e65ac270a4fefc87_253761_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_2_hu7b8c4341cb5ee562e65ac270a4fefc87_253761_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비디오 업로드 절차"
class="gallery-image"
data-flex-grow="79"
data-flex-basis="190px"
>&lt;/p>
&lt;p>비디오 업로드는 &lt;strong>비디오 업로드&lt;/strong>와 &lt;strong>비디오 메타데이터 갱신&lt;/strong>이 병렬적으로 수행된다.&lt;/p>
&lt;p>&lt;strong>프로세스 a: 비디오 업로드&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>비디오를 원본 저장소에 업로드&lt;/li>
&lt;li>트랜스 코딩 서버가 원본 저장소에서 해당 비디오를 가져와 트랜스코딩을 시작&lt;/li>
&lt;li>완료 후 아래 절차가 병렬적으로 수행
&lt;ul>
&lt;li>트랜스코딩 비디오 저장소로 업로드&lt;/li>
&lt;li>트랜스코딩 완료 이벤트를 트랜스코딩 완료 큐에 넣음
&lt;ol>
&lt;li>트랜스코딩이 끝난 비디오를 CDN에 올림&lt;/li>
&lt;li>완료 핸들러가 이벤트 데이터를 큐에서 꺼냄&lt;/li>
&lt;li>완료 핸들러가 메타데이터 데이터베이스와 캐시를 갱신&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비디오 업로드가 끝나 스트리밍 준비가 되었음을 알림&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>프로세스 b: 메타데이터 갱신&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_3.png"
width="316"
height="578"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_3_hudff31fcb22044dbd74a52c9078466beb_87582_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_3_hudff31fcb22044dbd74a52c9078466beb_87582_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="메타데이터 갱신"
class="gallery-image"
data-flex-grow="54"
data-flex-basis="131px"
>&lt;/p>
&lt;p>원본 저장소에 파일이 업로드 되는 동안, 병렬적으로 비디오 메타데이터 갱신 요청을 API 서버에 보내 처리한다.&lt;/p>
&lt;ul>
&lt;li>파일 이름, 크기, 포맷 등&lt;/li>
&lt;/ul>
&lt;h3 id="비디오-스트리밍-절차">비디오 스트리밍 절차&lt;/h3>
&lt;p>스트리밍은 사용자의 장치가 원격지의 비디오로부터 지속적으로 비디오 스트림을 전송받아 영상을 재생하는 것을 말한다.&lt;/p>
&lt;p>&lt;strong>스트리밍 프로토콜&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>비디오 스트리밍을 위해 데이터를 전송할 때 쓰이는 표준화된 통신 방법&lt;/p>
&lt;ul>
&lt;li>MPEG-DASH(Moving Picture Experts Group-Dynamic Adaptive Streaming over HTTP)&lt;/li>
&lt;li>Apple HLS(HTTP Live Streaming)&lt;/li>
&lt;li>MS Smooth Streaming&lt;/li>
&lt;li>어도비 HDS(HTTP Dynamic Streaming) 등&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>프로토콜마다 지원하는 비디오 인코딩이 다르기 때문에 플레이어도 다르다.&lt;/p>
&lt;p>따라서 비디오 스트리밍 서비스를 설계할 때는 서비스 용례에 맞는 프로토콜을 잘 골라 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_4.png"
width="316"
height="395"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_4_hu87113ebea9cc3d063b24dd7ea8977935_50216_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_4_hu87113ebea9cc3d063b24dd7ea8977935_50216_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="스트리밍 절차"
class="gallery-image"
data-flex-grow="80"
data-flex-basis="192px"
>&lt;/p>
&lt;p>비디오는 CDN에서 바로 스트리밍된다. 사용자의 단말에 가장 가까운 CDN 에지 서버가 비디오 전송을 담당할 것이다.&lt;/p>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>비디오 업로드를 담당하는 부분과 비디오 스트리밍을 담당하는 부분을 최적화 방안을 통해 다듬고, 요류 처리 매커니즘을 반영한다.&lt;/p>
&lt;h3 id="비디오-트랜스코딩">비디오 트랜스코딩&lt;/h3>
&lt;p>비디오를 녹화하면 특정 포맷으로 저장되는데, 다른 단말에서도 잘 재생되려면 호환되는 비트레이트 포맷으로 저장되어야 한다.&lt;/p>
&lt;p>비디오 트랜스코딩은 다음과 같은 이유로 중요하다.&lt;/p>
&lt;ul>
&lt;li>원본 비디오는 저장 공간을 많이 차지한다.&lt;/li>
&lt;li>대부분 클라이언트는 특정 종류의 비디오 포맷만 지원한다.
&lt;ul>
&lt;li>하나의 비디오를 여러 포맷으로 인코딩 해놓아야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>끊김 없는 재생을 보장하기위해 사용자에게 맞는 화질의 비디오를 제공하는 것이 좋다.
&lt;ul>
&lt;li>대역폭 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모바일의 경우 네트워크 상황이 실시간으로 달라질 수 있는데 이에 맞추어 화질이 자동으로 변경되거나 변경할 수 있게 해야한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>인코딩 포멧&lt;/strong>&lt;/p>
&lt;p>대부분의 인코딩 포멧은 다음 두 부분으로 구성되어있다.&lt;/p>
&lt;ul>
&lt;li>컨테이너
&lt;ul>
&lt;li>비디오 파일, 오디오, 메타데이터를 담는 바구니&lt;/li>
&lt;li>컨테이너 포맷은 확장자를 통해 확인할 수 있다(.avi, .mov, .mp4 등)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>코덱
&lt;ul>
&lt;li>비디오 화질을 보존하며 파일 크기를 줄일 목적으로 고안된 압축 및 해제 알고리즘&lt;/li>
&lt;li>H.264, VP9, HEVC 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="유향-비순환-그래프dag-모델">유향 비순환 그래프(DAG) 모델&lt;/h3>
&lt;p>비디오를 트랜스코딩하는 것은 컴퓨터 자원을 많이 소모할 뿐 아니라 시간도 많이 든다.&lt;/p>
&lt;p>또한 콘텐츠 창작자가 각자 가기만의 비디오 프로세싱 요구사항을 가지고있다.&lt;/p>
&lt;ul>
&lt;li>워터마크&lt;/li>
&lt;li>커스텀 섬네일 이미지&lt;/li>
&lt;li>화질 등&lt;/li>
&lt;/ul>
&lt;p>이러한 각기 다른 유형의 비디오 프로세싱 파이프라인을 지원하는 한편 처리 과정의 병렬성을 높히기 위해 적절한 수준의 추상화를 도입하여 클라이언트 프로그래머로 하여금 실행할 작업을 손수 정의할 수 있도록 해야한다.&lt;/p>
&lt;p>페이스북의 스트리밍 비디오 엔진은 DAG 프로그래밍 모델을 도입하여 해당 작업들이 순차적, 병렬적으로 실행될 수 있도록 하고있다.&lt;/p>
&lt;ul>
&lt;li>DAG 모델을 도입하면 유연성과 병렬성을 달성할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_5.png"
width="781"
height="544"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_5_hu7cc05f01956a08985411c34766a925ae_91407_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_5_hu7cc05f01956a08985411c34766a925ae_91407_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비디오 트랜스코딩을 위한 DAG 모델"
class="gallery-image"
data-flex-grow="143"
data-flex-basis="344px"
>&lt;/p>
&lt;p>원본 비디오는 비디오, 오디오, 메타데이터 세 부분으로 나뉘어 처리된다.&lt;/p>
&lt;p>&lt;strong>비디오&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>검사(inspection)
&lt;ul>
&lt;li>좋은 품질의 비디오인지, 손상은 없는지 확인한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비디오 인코딩(video encoding)
&lt;ul>
&lt;li>비디오를 다양한 해상도, 코덱, 비트레이트 조함으로 인코딩한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>섬네일(thumbnail)
&lt;ul>
&lt;li>사용자가 업로드한 이미지나 비디오에서 자동으로 추출된 이미지로 섬네일을 만든다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>워터마크(watermark)
&lt;ul>
&lt;li>비디오데 대한 식별정보를 이미지 위에 오버레이 형태로 띄워 표시한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="비디오-트랜스코딩-아키텍처">비디오 트랜스코딩 아키텍처&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_6.png"
width="819"
height="284"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_6_hu0b01e363c29d39f2e82de0b1928b742d_47551_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_6_hu0b01e363c29d39f2e82de0b1928b742d_47551_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클라우드 서비스를 활용한 비디오 트랜스코딩 아키텍처"
class="gallery-image"
data-flex-grow="288"
data-flex-basis="692px"
>&lt;/p>
&lt;p>클라우드 서비스를 활용한 비디오 트랜스코딩 아키텍처는 다섯 개의 주요 컴포넌트로 구성된다.&lt;/p>
&lt;ul>
&lt;li>전처리기(preprocessor)&lt;/li>
&lt;li>DAG 스케줄러&lt;/li>
&lt;li>자원 관리자(resource manager)&lt;/li>
&lt;li>작업 실행 서버(resource worker)&lt;/li>
&lt;li>임시 저장소(temporary storage)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>전처리기&lt;/strong>&lt;/p>
&lt;p>전처리기는 3가지 작업을 수행한다.&lt;/p>
&lt;ul>
&lt;li>비디오 분할(video spliting)
&lt;ul>
&lt;li>비디오 스트림을 GOP(Group of Pictures)라고 불리는 단위로 쪼갠다.&lt;/li>
&lt;li>오래된 단말이나 브라우저는 GOP 단위의 비디오 분할을 제공하지 않기 때문에 전처리기가 대신 수행한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>GOP&lt;br>
특정 순서로 배열된 프레임(frame) 그룹으로 하나의 GOP는 독립적으로 재생 가능하며, 길이는 보통 몇 초 정도다.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>DAG 생성
&lt;ul>
&lt;li>작성한 설정 파일에 따라 DAG를 만들어낸다.
&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_7.png"
width="451"
height="83"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_7_hude8451aecf6802d6db73c3e028a66766_14090_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_7_hude8451aecf6802d6db73c3e028a66766_14090_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="2개 노드와 1개 연결선으로 구성된 DAG"
class="gallery-image"
data-flex-grow="543"
data-flex-basis="1304px"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_8.png"
width="724"
height="265"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_8_hu4636aecea695599046327b39949966d6_113859_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_8_hu4636aecea695599046327b39949966d6_113859_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="DAG 설정 파일"
class="gallery-image"
data-flex-grow="273"
data-flex-basis="655px"
>&lt;/p>
&lt;ul>
&lt;li>데이터 캐시
&lt;ul>
&lt;li>전처리기는 분할된 비디오의 캐시 역할도 수행한다.&lt;/li>
&lt;li>안정성을 높이기 위해 GOP와 메타데이터를 임시 저장소에 보관한다.&lt;/li>
&lt;li>인코딩 실패시 보관된 데이터를 활용해 인코딩을 재개한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>DAG 스케줄러&lt;/strong>&lt;/p>
&lt;p>DAG 그래프를 몇 개 단계(stage)로 분할한 다음 그 각각을 자원 관리자의 작업 큐에 집어넣는다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_9.png"
width="837"
height="499"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_9_hud8ab1112f1b56f8a3a48350b48cfacc7_104927_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_9_hud8ab1112f1b56f8a3a48350b48cfacc7_104927_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="DAG 스케줄러 동작 사례"
class="gallery-image"
data-flex-grow="167"
data-flex-basis="402px"
>&lt;/p>
&lt;p>하나의 DAG를 2개 작업 단계로 쪼갠 사례이다.&lt;/p>
&lt;ol>
&lt;li>비디오, 오디오, 메타데이터를 분리&lt;/li>
&lt;li>비디오 파일을 인코딩, 섬네일을 추출, 오디오 파일 인코딩&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>자원 관리자&lt;/strong>&lt;/p>
&lt;p>자원 배분을 효과적으로 수행하는 역할을 담당한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_10.png"
width="837"
height="271"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_10_hu4aa1c323e6c007863c84ae483ffa21b4_150318_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_10_hu4aa1c323e6c007863c84ae483ffa21b4_150318_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="자원 관리자 구조"
class="gallery-image"
data-flex-grow="308"
data-flex-basis="741px"
>&lt;/p>
&lt;p>세 개의 큐와 작업 스케줄러(Task scheduler)로 구성된다.&lt;/p>
&lt;ul>
&lt;li>작업 큐(task queue)
&lt;ul>
&lt;li>실행할 작업이 보관되어 있는 우선순위 큐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작업 서버 큐(worker queue)
&lt;ul>
&lt;li>작업 서버의 가용 상태 정보가 보관되어 있는 우선순위 큐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>실행 큐(runner quere)
&lt;ul>
&lt;li>현재 실행 중인 작업 및 작업 서버 정보가 보관되어 있는 뷰&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작업 스케줄러
&lt;ul>
&lt;li>최적의 작업/서버 조합을 골라 해당 작업 서버가 작업을 수행하도록 지시한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>작업 관리자는 다음과 같이 동작한다.&lt;/p>
&lt;ol>
&lt;li>작업 큐에서 가장 높은 우선순위의 작업을 꺼낸다.&lt;/li>
&lt;li>해당 작업을 실행하기 적합한 작업 서버를 고른다.&lt;/li>
&lt;li>해당 작업 서버에게 작업 실행을 지시한다.&lt;/li>
&lt;li>해당 작업이 어떤 서버에게 할당되었는지에 관한 정보를 실행 큐에 넣는다.&lt;/li>
&lt;li>작업이 완료되면 해당 작업을 생행 큐에서 제거한다.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>작업 서버&lt;/strong>&lt;/p>
&lt;p>DAG에 정의된 작업을 수행한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_11.png"
width="366"
height="386"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_11_hubefd9dbcf64d01874bab57f6c01a654d_108389_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_11_hubefd9dbcf64d01874bab57f6c01a654d_108389_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="작업 서버"
class="gallery-image"
data-flex-grow="94"
data-flex-basis="227px"
>&lt;/p>
&lt;p>작업 종류에 따라 작업 서버도 구분하여 관리한다.&lt;/p>
&lt;p>&lt;strong>임시 저장소&lt;/strong>&lt;/p>
&lt;p>임시 저장소 구현에는 여러 저장소 시스템을 활용할 수 있으며, 저장할 데이터의 유형, 크기, 이용 빈도, 데이터 유효기간 등에 따라 선택한다.&lt;/p>
&lt;ul>
&lt;li>메타데이터
&lt;ul>
&lt;li>작업 서버가 빈번히 참조하는 정보, 크기가 작으므로 메모리에 캐시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비디오/오디오
&lt;ul>
&lt;li>BLOB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>임시 저장소에 보관한 데이터는 비디오 프로세싱이 완료되면 삭제한다.&lt;/p>
&lt;p>&lt;strong>인코딩된 비디오&lt;/strong>&lt;/p>
&lt;p>인코딩 파이프라인의 초종 결과물이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>funny_720p.mp4&lt;/code> 와 같은 이름을 짓는다.&lt;/li>
&lt;/ul>
&lt;h3 id="시스템-최적화">시스템 최적화&lt;/h3>
&lt;p>속도, 안정성 비용 측면에서 시스템을 최적화한다.&lt;/p>
&lt;h4 id="속도-최적화">속도 최적화&lt;/h4>
&lt;p>&lt;strong>비디오 병렬 업로드&lt;/strong>&lt;/p>
&lt;p>비디오 전부를 한 번의 업로드로 올리는 것은 비효율적이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_12.png"
width="811"
height="89"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_12_hu98c98eb0efb908039c9faccf2e82e918_18252_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_12_hu98c98eb0efb908039c9faccf2e82e918_18252_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="GOP 분할"
class="gallery-image"
data-flex-grow="911"
data-flex-basis="2186px"
>&lt;/p>
&lt;p>하나의 비디오는 작은 GOP로 분할할 수 있으며, 분할한 GOP를 병렬적으로 업로드하면 일부가 식패해도 빠르게 업로드를 재개할 수 있다.&lt;/p>
&lt;p>따라서 비디오를 GOP 경계에 맞춰 분할하는 작업을 단말이 수행하면 업로드 속도를 높일 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_13.png"
width="809"
height="197"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_13_huc530dc4036dc5a7fd8cff38f1c766090_71440_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_13_huc530dc4036dc5a7fd8cff38f1c766090_71440_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클라이언트 처리 후 병렬 업로드"
class="gallery-image"
data-flex-grow="410"
data-flex-basis="985px"
>&lt;/p>
&lt;p>&lt;strong>업로드 센터를 사용자 근거리에 지정&lt;/strong>&lt;/p>
&lt;p>업로드 센터를 여로 곳에 두고 가까운 센터로 업로드 하도록 한다.&lt;/p>
&lt;ul>
&lt;li>이를 위해 이번 설계안은 CDN을 업로드 센터로 이용한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>모든 절차를 병렬화&lt;/strong>&lt;/p>
&lt;p>느슨하게 결합된 시스템을 만들어서 병렬성을 높이면 낮은 응답지연에 도움이된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_14.png"
width="824"
height="277"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_14_hu11dc666d77b317ede5fc5fe9aa5e5c0a_131083_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_14_hu11dc666d77b317ede5fc5fe9aa5e5c0a_131083_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="기존 설계안"
class="gallery-image"
data-flex-grow="297"
data-flex-basis="713px"
>&lt;/p>
&lt;p>기존 설계안의 비디오를 원본 저장소에서 CDN으로 옮기는 절차를 보면, 어떤 단계의 결과물은 이전 단계의 결과물을 입력으로 사용하여 만들어지는데, 이러한 의존성이 있다면 병렬성을 높이기 어렵다.&lt;/p>
&lt;p>이러한 결합은 메시지 큐를 도입하여 개선할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_15.png"
width="817"
height="491"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_15_hu921f1cca05a7c8b3b0638c3d5cfa32c6_187733_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_15_hu921f1cca05a7c8b3b0638c3d5cfa32c6_187733_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="메시지 큐를 도입한 설계안"
class="gallery-image"
data-flex-grow="166"
data-flex-basis="399px"
>&lt;/p>
&lt;ul>
&lt;li>메시지 큐를 도입하기 전
&lt;ul>
&lt;li>인코딩 모듈은 다운로드 모듈의 작업이 끝나기를 기다려야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 큐를 도입한 후
&lt;ul>
&lt;li>인코딩 모듈은 다운로드 모듈의 작업이 끝나기를 기다리는 것이 아닌, &lt;strong>메시지 큐에 보관된 이벤트&lt;/strong> 각각을 인코딩 모듈이 병렬적으로 처리할 수 있게된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="안전성-최적화">안전성 최적화&lt;/h4>
&lt;p>&lt;strong>미리 사인된 업로드 URL&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>미리 사인된 URL?&lt;br>
아마존 S3에서 쓰이는 용어로, 접근 공유 시그니처 라고도 부른다.&lt;/p>
&lt;/blockquote>
&lt;p>허가받은 사용자만이 올바른 장소에 비디오를 업로드할 수 있도록 하기 위해 미리 사인된(pre-signed) 업로드 URL을 이용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_16.png"
width="728"
height="397"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_16_hu179b158cca764a11906c4a36151aea61_77187_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_16_hu179b158cca764a11906c4a36151aea61_77187_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="미리 사인된 업로드 사용"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="440px"
>&lt;/p>
&lt;ol>
&lt;li>클라이언트는 HTTP 서버에 POST 요청을 통해 미리 사인된 URL을 받는다.
&lt;ul>
&lt;li>해당 URL이 가르키는 객체에 대한 접근 권한이 이미 주어져 있는 상태&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>미리 사인된 URL을 돌려준다.&lt;/li>
&lt;li>클라이언트는 해당 URL이 가리키는 위치에 비디오를 업로드한다.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>비디오 보호&lt;/strong>&lt;/p>
&lt;p>많은 콘텐츠 제작자가 비디오 원본을 도난당할까 우려하여 인터넷에 비디오를 업로드하기를 주저한다.&lt;/p>
&lt;p>이러한 저작권 보호를 위해 다음 세가지 선택지 중 하나를 채택할 수 있다.&lt;/p>
&lt;ul>
&lt;li>디지털 저작권 관리(DRM: Digital Rights Management) 시스템 도입
&lt;ul>
&lt;li>애플의 페어플레이, 구글 와이드바인, MS의 플레이레디 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>AES 암호화
&lt;ul>
&lt;li>비디오를 암호화하고 접근 권한을 설정하는 방식&lt;/li>
&lt;li>재생 시에만 복호화하며, 허락된 사용자만 암호화된 비디오를 시청할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>워터마크
&lt;ul>
&lt;li>비디오 위에 소유자 정보를 포함하는 이미지 오베리이를 올린다.&lt;/li>
&lt;li>회사 로고, 이름 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="비용-최적화">비용 최적화&lt;/h4>
&lt;p>비디오 데이터 제공을 위한 CDN은 이번 설계한 시스템의 핵심이다.&lt;/p>
&lt;p>하지만 CDN은 비싸고, 데이터 크기가 클 수록 더욱 비싸다.&lt;/p>
&lt;p>연구 결과에 따르면, 유트브의 비디오 스트리밍은 롱테일 분포를 따른다.&lt;/p>
&lt;ul>
&lt;li>인기 있는 비디오가 대부분 재생의 대부분을 차지한다.&lt;/li>
&lt;/ul>
&lt;p>이러한 점을 이용하여 몇 가지 최적화를 시도할 수 있다.&lt;/p>
&lt;ul>
&lt;li>인기 비디오는 CDN으로 재생하되 다른 비디오는 비디오 서버를 통해 재생한다.&lt;/li>
&lt;li>비인기 비디오는 인코딩 할 필요가 없을 수 있으며, 짧은 비디오라면 필요할 때 인코딩하여 재생할 수 있다.&lt;/li>
&lt;li>특정 비디오는 특정 지역에서만 인기가 높다. 이런 비디오는 다른 지역으로 옮길 필요가 없다.&lt;/li>
&lt;li>CDN을 직접 구축하고 인터넷 서비스 제공자와 제유한다.
&lt;ul>
&lt;li>CDN을 직접 구축하는 것은 초대형 프로젝트이지만 대규모 스트리밍 사업자라면, 비용을 줄이고 사용자 경험을 향상시킬 수 있어 시도할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 최적화는 콘텐츠의 인기도, 이용 패턴, 비디오 크기 등 데이터에 근거한 것으로, 최적화를 시도하기 전 시청 패턴을 분석하는 것이 매우 중요하다.&lt;/p>
&lt;h3 id="오류처리">오류처리&lt;/h3>
&lt;p>대형 시스템에서 오류는 불가피하다.&lt;/p>
&lt;p>장애를 아주 잘 감내하는(highly fault-tolerant) 시스템을 만들려면 오류들을 우아하게 처리하고 빠르게 회복해야한다.&lt;/p>
&lt;ul>
&lt;li>회복 불가능 오류(recoverable error)
&lt;ul>
&lt;li>특정 비디오 세그먼트 트랜스코딩 실패 같은 오류는 회복 가능한 오류이다.&lt;/li>
&lt;li>몇 번 재시도하면 해결되는 경우가 많다.&lt;/li>
&lt;li>계속해서 실패하고, 복구가 어렵다 판단되면 클라이언트에게 적절한 오류 코드를 반환해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>회복 불가능 오류(non-recoverable error)
&lt;ul>
&lt;li>비디오 포맷이 잘못되었다거나 하는 회복 불가능한 오류가 발견되면 해당 비디오에 대한 작업을 중단하고 클라이언트에게 적절한 오류를 반환해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>시스템 컴포넌트 각각에 발생할 수 있는 오류에 대한 전형적 해결 방법 요약하면 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>업로드 오류
&lt;ul>
&lt;li>몇 회 재시도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비디오 분할 오류
&lt;ul>
&lt;li>클라이언트가 분할하지 못하는 경우라면, 전체 비디오를 서버로 전송하고 서버가 해당 비디오 분할을 처리하도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>트랜스코딩 오류
&lt;ul>
&lt;li>재시도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>전처리 오류
&lt;ul>
&lt;li>DAG 그래프 재생성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DAG 스케줄러 오류
&lt;ul>
&lt;li>작업을 다시 스케줄링&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>자원 관리자 큐에 장애 발생
&lt;ul>
&lt;li>사본을 이용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작업 서버 장애
&lt;ul>
&lt;li>다른 서버에서 해당 작업 재시도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>API 서버 장애
&lt;ul>
&lt;li>API를 무상태로 관리하여 신규 요청을 다른 API로 우회&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 캐시 서버 장애
&lt;ul>
&lt;li>데이터 다중화를 통해 다른 노드에서 데이터를 가져올 수 있다.&lt;/li>
&lt;li>장애가 난 캐시 서버는 새로운 것으로 교체&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 데이터베이스 장애
&lt;ul>
&lt;li>주 서버: 부 서버 가운데 하나를 주 서버로 교체&lt;/li>
&lt;li>부 서버: 다른 부 서버를 통해 읽기 연산 처리 및 죽은 서버 교체&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>이외에 중요할 수 있는 내용들은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>API 계층 규모 확정성 확보 방안
&lt;ul>
&lt;li>무상태 서버이므로 수평 규모 확장이 가능하다는 사실을 언급하면 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터베이스 계층의 규모 확장성 확보 방안
&lt;ul>
&lt;li>다중화와 샤딩 방법에 대해 언급&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>라이브 스트리밍
&lt;ul>
&lt;li>라이브 스트리밍은 비디오를 실시간으로 녹화하고 방송하는 절차를 말한다.&lt;/li>
&lt;li>가장 중요한 차이는 다음과 같다.
&lt;ul>
&lt;li>응답지연이 좀 더 낮아야 한다.
&lt;ul>
&lt;li>스트리밍 프로토콜 선정에 유의해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작은 단위의 데이터를 실시간으로 빨리 처리해야하므로 병렬화 필요성은 떨어진다.&lt;/li>
&lt;li>너무 많은 시간이 걸리는 오류 처리 방안은 활용할 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비디오 삭제
&lt;ul>
&lt;li>저작권 위반, 선정성, 불법 행위에 관계된 비디오는 내려야한다.&lt;/li>
&lt;li>업로드 과정에서 식별&lt;/li>
&lt;li>사용자의 신고 절차 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>15. 구글 드라이브 설계</title><link>https://codemario318.github.io/post/system-design-interview/15/</link><pubDate>Tue, 09 Jul 2024 15:46:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/15/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/cover.png" alt="Featured image of post 15. 구글 드라이브 설계" />&lt;p>클라우드 저장소 서비스는 최근 높은 인기를 누리게 된 대표적 클라우드 서비스다.&lt;/p>
&lt;p>그 가운데 구글 드라이브 서비스를 설계해 본다.&lt;/p>
&lt;p>구글 드라이브는 &lt;strong>파일 저장 및 동기화 서비스&lt;/strong>로, 문서, 사진, 비디오, 기타 피일을 &lt;strong>클라우드에 보관&lt;/strong>할 수 있도록 한다.&lt;/p>
&lt;ul>
&lt;li>이 파일은 컴퓨터, 스마트폰, 태블릿 등 어떤 단말에서도 이용 가능해야한다.&lt;/li>
&lt;li>보관된 파일은 친구, 가족, 동료 들과 손쉽게 공유할 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;ul>
&lt;li>Q. 지원해야할 기능?
&lt;ul>
&lt;li>A. 파일 업로드/다운로드, 파일 동기화, 알림&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 모바일 앱, 웹 앱 중 지원 범위
&lt;ul>
&lt;li>A. 웹, 앱 둘다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 파일 암호화 처리?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 파일 크기 제한?
&lt;ul>
&lt;li>A. 10GB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 사용자는?
&lt;ul>
&lt;li>A. DAU 천만명&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이번 장에서는 다음 기능의 설계에 집중한다.&lt;/p>
&lt;ul>
&lt;li>파일 추가
&lt;ul>
&lt;li>가장 쉬운 방법은 파일을 구글 드라이브 안으로 떨구는 것(Drag-and-drop)이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파일 다운로드&lt;/li>
&lt;li>여러 단말에 파일 동기화
&lt;ul>
&lt;li>한 단말에서 파일을 추가하면 다른 단말에도 자동 동기화되어야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파일 갱신 이력 조회&lt;/li>
&lt;li>파일 공유&lt;/li>
&lt;li>파일 편집, 삭제, 새롭게 공유 되었을 때 알림 표시&lt;/li>
&lt;/ul>
&lt;p>기능적 요구사항 외, 비-기능적 요구사항을 이해하는 것도 중요하다.&lt;/p>
&lt;ul>
&lt;li>안정성
&lt;ul>
&lt;li>저장소 시스템의 안정성은 아주 중요하다.&lt;/li>
&lt;li>데이터 손실이 발생하면 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>빠른 동기화
&lt;ul>
&lt;li>동기화 사긴이 너무 많이 걸리면 인내심을 읽고 제품을 더 이상 사용하지 않을 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>네트워크 대역폭
&lt;ul>
&lt;li>네트워크 대역폭을 불필요하게 많이 소모한다면 사용자가 좋아하지 않을 것&lt;/li>
&lt;li>모바일 데이터 플랜이라면 더욱더&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규모 확장성
&lt;ul>
&lt;li>아주 많은 양의 트래픽도 처리 가능해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>높은 가용성
&lt;ul>
&lt;li>일부 서버의 장애, 지연, 네트워크 이슈가 발생해도 계속 사용 가능해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-추정치">개략적 추정치&lt;/h3>
&lt;ul>
&lt;li>가입 사용자는 오천만명, 천만명의 DAU 가정&lt;/li>
&lt;li>모든 사용자에게 10GB 무료 저장공간 할당&lt;/li>
&lt;li>매일 각 사용자가 평균 2개의 파일을 업로드 한다고 가정&lt;/li>
&lt;li>파일 크기 평균 500KB 가정&lt;/li>
&lt;li>읽기, 쓰기 비율은 1:1&lt;/li>
&lt;li>&lt;code>필요한 저장공간 총량 = 5천만 사용자 * 10GB = 500PB&lt;/code>&lt;/li>
&lt;li>&lt;code>업로드 API QPS = 1천만 사용자 * 2회 / 24시간 /3600초 = 240&lt;/code>&lt;/li>
&lt;li>&lt;code>최대 QPS = QPS * 2 = 480&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>모든 것을 담은 한 대 서버에서 출발해 점진적으로 천만 사용자 지원이 가능한 시스템으로 발전시켜 나간다.&lt;/p>
&lt;ul>
&lt;li>파일을 올리고 다운로드 하는 과정을 처리할 웹서버&lt;/li>
&lt;li>사용자 데이터, 로그인 정보, 파일 정보 등의 메타데이터를 보관할 데이터베이스&lt;/li>
&lt;li>파일을 저장할 저장소 시스템.
&lt;ul>
&lt;li>1TB 사용 예정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>웹 서버, 데이터베이스 설치 후, 파일이 저장될 &lt;code>drive/&lt;/code> 디렉터리를 준비한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img.png"
width="688"
height="311"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_hub24c5a9894590f2559d10c8a4efc626c_63107_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_hub24c5a9894590f2559d10c8a4efc626c_63107_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="파일 저장 예시"
class="gallery-image"
data-flex-grow="221"
data-flex-basis="530px"
>&lt;/p>
&lt;ul>
&lt;li>디렉터리 안에는 네임스페이스라 불리는 하위 디렉터리를 둔다.&lt;/li>
&lt;li>각 네임스페이스 안에는 특정 사용자가 올린 파일이 보관된다.&lt;/li>
&lt;li>파일들은 원래 파일과 같은 이름을 갖는다.&lt;/li>
&lt;li>각 파일과 폴더는 그 상대 경로를 네임스페이스 이름과 결합하면 유일하게 식별할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="api">API&lt;/h3>
&lt;p>이 시스템은 3가지 API가 필요하다.&lt;/p>
&lt;h4 id="파일-업로드-api">파일 업로드 API&lt;/h4>
&lt;p>&lt;strong>단순 업로드&lt;/strong>&lt;/p>
&lt;p>파일 크기가 작을 때 사용한다.&lt;/p>
&lt;p>&lt;strong>이어 올리기(resumable upload)&lt;/strong>&lt;/p>
&lt;p>파일 사이즈가 크고 네트워크 문제로 업로드가 중단될 가능성이 높다고 생각되면 사용한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">https://api.example.com/files/upload?uploadType=resumable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>인자
&lt;ul>
&lt;li>&lt;code>uploadType=resumable&lt;/code>&lt;/li>
&lt;li>&lt;code>data&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이어올리기는 다음 세 단계 절차로 이루어진다.&lt;/p>
&lt;ol>
&lt;li>이어 올리기 URL을 받기 위한 최초 요청 전송&lt;/li>
&lt;li>데이터를 업로드하고 업로드 상태 모니터링&lt;/li>
&lt;li>업로드에 장애가 발생하면 장애 발생시점부터 업로드를 재시작&lt;/li>
&lt;/ol>
&lt;h4 id="파일-다운로드-api">파일 다운로드 API&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">https://api.example.com/files/download
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>인자&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>path&lt;/code>
&lt;ul>
&lt;li>다운로드할 파일의 경로&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;path&amp;#34;: &amp;#34;/recipes/soup/best_soup.txt&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="파일-갱신-히스토리">파일 갱신 히스토리&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">https://api.exmaple.com/files/list_revisions
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>인자&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>path&lt;/code>: 갱신 히스토리를 가져올 파일의 경로&lt;/li>
&lt;li>&lt;code>limit&lt;/code>: 히스토리 길이의 최대치&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;path&amp;#34;: &amp;#34;/recipes/soup/best_soup.txt&amp;#34;,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;limit&amp;#34;: 20
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>나열한 모든 API는 사용자 인증을 필요로 하고, 클라이언트와 백엔드 서버가 주고받는 데이터를 보호하기 위해 &lt;code>HTTPS&lt;/code> 프로토콜을 사용해야한다.&lt;/p>
&lt;h3 id="한-대-서버의-제약-극복">한 대 서버의 제약 극복&lt;/h3>
&lt;p>파일이 많아지면 결국 가득 차게되어 더 이상 파일을 올릴 수 없으므로 긴급히 문제를 해결해야한다.&lt;/p>
&lt;p>쉬운 해결책으로 &lt;strong>샤딩&lt;/strong>을 통해 데이터를 여러 서버에 나누어 저장하는 방법을 고려할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_1.png"
width="549"
height="382"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_1_hue1f43ec1f6b9cd6c37e81cda8b5995c5_45245_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_1_hue1f43ec1f6b9cd6c37e81cda8b5995c5_45245_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="샤딩"
class="gallery-image"
data-flex-grow="143"
data-flex-basis="344px"
>&lt;/p>
&lt;p>서버를 직접 관리했을 때, 장애가 생기면 데이터를 잃게될 수 있으므로 불안하다.&lt;/p>
&lt;p>넷플릭스, 에어비엔비 같은 시장 주도 기업들은 저장소로 &lt;strong>아마존 S3&lt;/strong>를 사용한다.&lt;/p>
&lt;ul>
&lt;li>업계 최고 수준의 규모 확장성, 가용성, 보안, 성능을 제공하는 객체 저장소 서비스&lt;/li>
&lt;li>같은 지역 안에서 다중화, 여러 지역에 걸쳐 다중화가 가능하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_2.png"
width="820"
height="269"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_2_hufcdd6e06324f9d7c9cd88babfdc6839a_145452_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_2_hufcdd6e06324f9d7c9cd88babfdc6839a_145452_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="다중화"
class="gallery-image"
data-flex-grow="304"
data-flex-basis="731px"
>&lt;/p>
&lt;p>따라서 S3를 사용을 결정한다. 하지만 미래에 비슷한 문제(사용자 증가로 인해 발생하는 문제)가 벌어지는 것을 막기 위해, 개선할 부분을 더 찾아보면 아래와 같다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_3.png"
width="498"
height="682"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_3_hu7c8b4e63be5e874ab6c187e11a695377_134558_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_3_hu7c8b4e63be5e874ab6c187e11a695377_134558_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="수정한 설계안"
class="gallery-image"
data-flex-grow="73"
data-flex-basis="175px"
>&lt;/p>
&lt;ul>
&lt;li>로드밸런서
&lt;ul>
&lt;li>트래픽을 고르게 분산할 수 있다.&lt;/li>
&lt;li>특정 웹 서버에 장애가 발생하면 자동으로 해당 서버를 우회한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 서버
&lt;ul>
&lt;li>로드밸런서를 추가하고 나면 더 많은 웹 서버를 손쉽게 추가할 수 있다.&lt;/li>
&lt;li>트래픽이 폭증해도 쉽게 대응 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 데이터베이스
&lt;ul>
&lt;li>데이터베이스를 파일 저장 서버에서 분리하여 SPOF를 회피한다.&lt;/li>
&lt;li>다중화 및 샤딩 정책을 정용하여 가용성과 규모 확장성 요구사항에 대응한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파일 저장소
&lt;ul>
&lt;li>S3를 파일 저장소로 사용하고 가용성과 데이터 무손실을 보장하기 위해 두 개 이상의 지역에 데이터를 다중화한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="동기화-충돌">동기화 충돌&lt;/h3>
&lt;p>구글 드라이브 같은 대형 저장소 시스템의 경우 동기화 충돌이 발생할 수 있다.&lt;/p>
&lt;ul>
&lt;li>두 명 이상의 사용자가 같은 파일이나 폴더를 동시에 업데이트하려고 하는 경우&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_4.png"
width="835"
height="188"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_4_hu342e61e0409206514e14b35844cf2592_55317_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_4_hu342e61e0409206514e14b35844cf2592_55317_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="충돌 해소 전략"
class="gallery-image"
data-flex-grow="444"
data-flex-basis="1065px"
>&lt;/p>
&lt;p>먼저 처리되는 변경은 성공한 것으로 보고, 나중에 처리되는 변경은 충돌이 발생한 것으로 표시하는 전략을 사용할 수 있다.&lt;/p>
&lt;ol>
&lt;li>사용자 1과 2는 같은 파일을 동시에 갱신을 시도한다.&lt;/li>
&lt;li>사용자 1의 요청이 먼저 처리된다.&lt;/li>
&lt;li>사용자 2는 동기화 충돌 오류가 발생한다.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>충돌 오류 해소&lt;/strong>&lt;/p>
&lt;p>오류가 발생한 시점에 이 시스템에는 같은 파일의 두가지 버전이 존재하게 된다.&lt;/p>
&lt;ul>
&lt;li>사용자 2가 가지고 있는 로컬 사본과 서버에 있는 최신 버전&lt;/li>
&lt;/ul>
&lt;p>이 상태에서는 &lt;strong>두 파일을 하나로 합칠지&lt;/strong> 아니면 &lt;strong>둘 중 하나를 다른 파일로 대체할지&lt;/strong>를 결정해야한다.&lt;/p>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_5.png"
width="762"
height="578"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_5_hu0a421274c901a4c9b3c387104fb85a94_147635_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_5_hu0a421274c901a4c9b3c387104fb85a94_147635_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="316px"
>&lt;/p>
&lt;ul>
&lt;li>사용자 단말
&lt;ul>
&lt;li>사용자가 이용하는 웹 브라우저 또는 모바일 앱 등의 클라이언트&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>블록 저장소 서버(block server, block-level storage)
&lt;ul>
&lt;li>파일 블록을 클라우드 저장소에 업로드하는 서버&lt;/li>
&lt;li>클라우드 환경에서 데이터 파일을 저장하는 기술&lt;/li>
&lt;li>파일을 여러개의 블록으로 나눠 저장하며, 각 블록에는 고유한 해시값을 할당&lt;/li>
&lt;li>해시값은 메타데이터 데이터베이스에 저장됨&lt;/li>
&lt;li>각 블록은 독립적인 객체로 취급되어 클라우드 저장소 시스템에 보관(여기서는 s3)&lt;/li>
&lt;li>파일 재구성 시 블록들을 원래 순서대로 합친다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클라우드 저장소
&lt;ul>
&lt;li>파일을 블록 단위로 나눠 클라우드 저장소에 보관한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>아카이빙 저장소(cold storage)
&lt;ul>
&lt;li>오랫동안 사용되지 않은 비활성 데이터를 저장한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>로드밸런서
&lt;ul>
&lt;li>요청을 모든 API 서버에 고르게 분산한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>API 서버
&lt;ul>
&lt;li>파일 업로드 외 거의 모든 것을 담당&lt;/li>
&lt;li>사용자 인증, 사용자 프로파일 관리, 파일 메타데이터 갱신 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 데이터베이스
&lt;ul>
&lt;li>사용자, 파일, 블록, 버전 등의 메타데이터 정보를 관리&lt;/li>
&lt;li>실제 파일은 클라우드에 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 캐시
&lt;ul>
&lt;li>성능을 높이기 위해 자주 쓰이는 메타데이터를 캐시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 서비스
&lt;ul>
&lt;li>특정 이벤트가 발생했음을 클라이언트에게 알리는 발생/구독 프로토콜 기반 시스템&lt;/li>
&lt;li>파일 추가, 편집, 삭제 되었음을 알린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오프라인 사용자 백업 큐(offline backup queue)
&lt;ul>
&lt;li>클라이언트가 접속 중이 아니라서 파일의 최신 상태를 확인할 수 없을 때는 해당 정보를 이 큐에 두어 나중에 클라이언트가 접속했을 때 동기화한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="블록-저장소-서버">블록 저장소 서버&lt;/h3>
&lt;p>정기적으로 갱신되는 큰 파일들은 업데이트가 일어날 때마다 전체 파일을 서버로 보내면 네트워크 대역폭을 많이 사용하게된다.&lt;/p>
&lt;p>이를 최적화하는 방법으로 두 가지 정도를 생각해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>델타 동기화(delta sync)
&lt;ul>
&lt;li>파일이 수정되면 전체 파일 대신 수정이 일어난 블록만 동기화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>압축(compression)
&lt;ul>
&lt;li>블록 단위로 압축해 두면 데이터 크기를 많이 줄일 수 있다.&lt;/li>
&lt;li>압축 알고리즘은 파일 유형에 따라 정한다.&lt;/li>
&lt;li>텍스트: gzip, bzip2 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_6.png"
width="831"
height="451"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_6_hud8fbf54a2a35c27ffe337a1e218c26a0_109645_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_6_hud8fbf54a2a35c27ffe337a1e218c26a0_109645_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="블록 저장소 동작"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/p>
&lt;p>블록 저장소 서버는 &lt;strong>파일 업로드에 관계된 힘든 일을 처리하는 컴포넌트&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>클라이언트가 보낸 파일을 블록 단위로 나눈다.&lt;/li>
&lt;li>각 블록에 압축 알고리즘을 적용한다.&lt;/li>
&lt;li>암호화한다.&lt;/li>
&lt;li>전체 파일을 저장소 시스템으로 보내는 대신 수정된 블록만 전송한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_7.png"
width="699"
height="561"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_7_hu2ea83530cb1f2bac8670a57a1cacd1e2_91495_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_7_hu2ea83530cb1f2bac8670a57a1cacd1e2_91495_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="델타 동기화 전략 동작"
class="gallery-image"
data-flex-grow="124"
data-flex-basis="299px"
>&lt;/p>
&lt;p>갱신된 부분만 동기화해야 하므로 이 두 블록만 클라우드 저장소에 업로드한다.&lt;/p>
&lt;p>블록 저장소 서버에 델타 동기화 전략과 압축 알고리즘을 도입하면, 네트워크 대역폭 사용량을 절감할 수 있다.&lt;/p>
&lt;h3 id="높은-일관성-요구사항">높은 일관성 요구사항&lt;/h3>
&lt;p>구글 드라이브 시스템은 &lt;strong>강한 일관성&lt;/strong>(string consistency) 모델을 기본으로 지원해야한다.&lt;/p>
&lt;ul>
&lt;li>같은 파일이 단말이나 사용자에 따라 다르게 보이는 것을 허용할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>메모리 캐시는 보통 &lt;strong>결과적 일관성&lt;/strong>(eventual consistency) 모델은 지원하기 때문에 강한 일관성을 달성하려면 다음 사항을 보장해야한다.&lt;/p>
&lt;ul>
&lt;li>캐시에 보관된 사본과 데이터베이스에 있는 원본이 일치한다.&lt;/li>
&lt;li>데이터베이스에 보관된 원본에 변경이 발생하면 캐시에 있는 사본을 무효화한다.&lt;/li>
&lt;/ul>
&lt;p>관계형 데이터베이스는 ACID를 보장하므로 강한 일관성을 보장하기 쉽다.&lt;/p>
&lt;p>하지만 NoSQL 데이터베이스는 이를 기본으로 지원하지 않으므로, 동기화 로직 안에 프로그램해 넣어야 한다.&lt;/p>
&lt;p>이번 설계안에는 관계형 데이터베이스를 채택하여 높은 일관성 요구사항에 대응한다.&lt;/p>
&lt;h3 id="메타데이터-데이터베이스">메타데이터 데이터베이스&lt;/h3>
&lt;p>중요한 것만 간추린 스키마를 그려보면 아래와 같다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_8.png"
width="815"
height="552"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_8_hu4f4697bf0a6ca547432e300010d24d9d_152870_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_8_hu4f4697bf0a6ca547432e300010d24d9d_152870_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="스키마 설계안"
class="gallery-image"
data-flex-grow="147"
data-flex-basis="354px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;code>user&lt;/code>
&lt;ul>
&lt;li>이름, 이베일 프로파일 사진 등 사용자에 관계된 기본적인 정보들이 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>device&lt;/code>
&lt;ul>
&lt;li>단말 정보가 보관&lt;/li>
&lt;li>&lt;code>push_id&lt;/code>는 모바일 푸시 알림을 보내고 받기 위한 것&lt;/li>
&lt;li>한 사용자가 여러 대의 단말을 가질 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>namespace&lt;/code>
&lt;ul>
&lt;li>사용자의 루트 디렉터리 정보가 보관된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>file&lt;/code>
&lt;ul>
&lt;li>파일의 최신 정보가 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>file_version&lt;/code>
&lt;ul>
&lt;li>파일의 갱신 이력이 보관&lt;/li>
&lt;li>보관되는 레코드는 전부 읽기 전용&lt;/li>
&lt;li>갱신 이력이 회손되는 것을 막는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>block&lt;/code>
&lt;ul>
&lt;li>파일 블록에 대한 정보를 보관&lt;/li>
&lt;li>특정 버전의 파일은 올바른 순서로 조합하기만 하면 복원할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="업로드-절차">업로드 절차&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_9.png"
width="833"
height="483"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_9_hua0a53d0668d6e7e3b8f1258d11bcb681_72670_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_9_hua0a53d0668d6e7e3b8f1258d11bcb681_72670_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="업로드 절차"
class="gallery-image"
data-flex-grow="172"
data-flex-basis="413px"
>&lt;/p>
&lt;p>사용자가 파일을 올리면 두 개의 요청이 병렬적으로 수행되어야 한다.&lt;/p>
&lt;ul>
&lt;li>파일 메타데이터를 추가
&lt;ol>
&lt;li>새 파일의 메타데이터를 추가하기 위한 요청 전송&lt;/li>
&lt;li>새 파일의 메타 데이터를 데이터베이스에 저장하고 업로드 상태를 대기중(pending)으로 변경&lt;/li>
&lt;li>새 파일이 추가되었음을 알림 서비스에 통지&lt;/li>
&lt;li>관련된 클라이언트(여기서는 클라이언트 2)에게 파일이 업로드되고 있음을 알림&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>파일을 클라우드 저장소로 업로드
&lt;ol>
&lt;li>파일을 블록 저장소 서버에 업로드&lt;/li>
&lt;li>파일을 블록 단위로 쪼갠 다음 압축, 암호화 후 클라우드 저장소에 전송&lt;/li>
&lt;li>업로드 완료시 클라이드 스토리지는 완료 콜백 호출&lt;/li>
&lt;li>메타데이터 DB에 기록된 해당 파일의 상태를 완료(uploaded)로 변경&lt;/li>
&lt;li>알림 서비스에 파일 업로드가 끝났음을 통지&lt;/li>
&lt;li>알림 서비스가 관련 클라이언트(2)에게 파일 업로드가 끝났음을 알림&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>수정도 이와 거의 동일하다.&lt;/p>
&lt;h3 id="다운로드-절차">다운로드 절차&lt;/h3>
&lt;p>파일 다운로드는 파일이 새로 추가되거나 편집되면 자동으로 시작된다.&lt;/p>
&lt;p>다른 클라이언트가 파일을 편집하거나 추가했다는 사실은 두 가지 방법을 통해 이루어진다.&lt;/p>
&lt;ul>
&lt;li>클라이언트 A가 접속 중
&lt;ul>
&lt;li>다른 클라이언트가 파일을 변경하면 알림 서비스가 클라이언트 A에게 변경이 발생했으니 새 버전을 끌어가야 한다고 알림&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클라이언트 A가 접속중이 아님
&lt;ul>
&lt;li>데이터는 캐시에 보관&lt;/li>
&lt;li>해당 클라이언트 상태가 접속 중으로 바뀌면 그때 해당 클라이언트가 새 버전을 가져감&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>파일이 변경되었음을 감지한 클라이언트는&lt;/p>
&lt;ol>
&lt;li>API 서버를 통해 메타데이터를 새로 가져가야한다.&lt;/li>
&lt;li>블록들을 다운받아 파일을 재구성해야 한다.&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_10.png"
width="833"
height="420"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_10_hu6a208727cbba91ca136cb143ce08ef99_65538_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_10_hu6a208727cbba91ca136cb143ce08ef99_65538_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="파일 재구성 흐름"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="476px"
>&lt;/p>
&lt;ol>
&lt;li>알림 서비스가 클라이언트 2에게 파일을 변경했음을 알림&lt;/li>
&lt;li>클라이언트 2는 새로운 메타데이터를 요청&lt;/li>
&lt;li>API 서버는 메타데이터 데이터베이스에게 새 메타데이터 요청&lt;/li>
&lt;li>API 서버에게 새 메타데이터 반환&lt;/li>
&lt;li>클라이언트 2에게 새 메타데이터가 반환&lt;/li>
&lt;li>클라이언트 2는 새 메타데이터를 맏는 즉시 블록 다운로드 요청&lt;/li>
&lt;li>블록 저장소 서버는 클라우드 저장소에서 블록 다운로드&lt;/li>
&lt;li>클라우드 저장소는 블록 서버에 요청된 블록 반환&lt;/li>
&lt;li>블록 저장소 서버는 클라이언트에게 요청된 블록 반환.&lt;/li>
&lt;li>클라이언트 2는 전송된 블록으로 파일 재구성&lt;/li>
&lt;/ol>
&lt;h3 id="알림-서비스">알림 서비스&lt;/h3>
&lt;p>알림 서비스는 파일의 일관성 유지를 위해 사용된다.&lt;/p>
&lt;ul>
&lt;li>클라이언트가 로컬에서 파일이 수정되었음을 감지하는 순간 다른 클라이언트에 그 사실을 알려 충돌 가능성을 줄여야한다.&lt;/li>
&lt;/ul>
&lt;p>단순히 보면 알림 서비스는 &lt;strong>이벤트 데이터를 클라이언트들로 보내는 서비스&lt;/strong>이다.&lt;/p>
&lt;p>따라서 두 가지 정도 선택지가 있다.&lt;/p>
&lt;ul>
&lt;li>롱 폴링: 드롭박스가 채택하고있음&lt;/li>
&lt;li>웹소켓
&lt;ul>
&lt;li>클라이언트와 서버 사이에 지속적인 통신 채널을 제공하므로 양방향 통신이 가능함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>둘 다 좋은 방안이지만 이번 설계안에서는 롱 폴링을 사용한다.&lt;/p>
&lt;ul>
&lt;li>구글 드라이브 시스템은 알림 서비스와 양방향 통신이 필요하지 않다.
&lt;ul>
&lt;li>서버만 파일이 변경된 사실을 클라이언트에게 알린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹소켓은 실시간 양방향 통신이 요구되는 채팅과 같은 응용에 적합하다.
&lt;ul>
&lt;li>구글 드라이브의 경우 알림을 보낼 일이 그렇게 자주 발생하지 않는다.&lt;/li>
&lt;li>알림을 보내야 하는 경우에도 단시간에 많은 데이터를 보낼 일은 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>따라서 롱 폴링을 채택하며, 아래와 같은 절차가 반복된다.&lt;/p>
&lt;ol>
&lt;li>각 클라이언트는 알림 서버와 롱 폴링용 연결을 유지한다.&lt;/li>
&lt;li>특정 파일에 대한 변경을 감지하면 해당 연결을 끊는다&lt;/li>
&lt;li>메타데이터 서버와 연결해 파일의 최신 내역을 다운로드한다.&lt;/li>
&lt;li>다운로드 작업이 끝났거나 타임아웃 시간에 도달한 경우 즉시 새요청을 보내 롱 폴링 연결을 복원하고 유지한다.&lt;/li>
&lt;/ol>
&lt;h3 id="저장소-공간-절약">저장소 공간 절약&lt;/h3>
&lt;p>파일 갱신 이력을 보존하고 안정성을 보장하기 위해서 파일의 여러 버전을 데이터센터에 보관할 필요가 있다.&lt;/p>
&lt;p>이 때 모든 버전을 자주 백업하면 저장 용량이 너무 빨리 소진될 가능성이 있으므로 아래와 같은 방식을 활용한다.&lt;/p>
&lt;ul>
&lt;li>중복 제거(de-dupe)
&lt;ul>
&lt;li>중복된 파일 블록을 계정 차원에서 제거한다.&lt;/li>
&lt;li>해시 값을 비교해서 판다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지능적 백업 전략 도입
&lt;ul>
&lt;li>한도 설정
&lt;ul>
&lt;li>파일 버전 개수에 상한을 둔다.&lt;/li>
&lt;li>제일 오래된 버전은 버린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>중요한 버전만 보관
&lt;ul>
&lt;li>특정 파일은 단기간에 자주 변경되므로 업데이트될 때마다 새로운 버전으로 관리하는 것이 아닌, 중요한 것만 골라내어 보관한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>아카이빙 저장소(cold storage) 활용
&lt;ul>
&lt;li>자주 쓰이지 않는 데이터는 아카이빙 저장소로 옮긴다.&lt;/li>
&lt;li>아마존 S3 글래지어 같은 아카이빙 저장소 이용료는 매우 저렴하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="장애-처리">장애 처리&lt;/h3>
&lt;p>장애는 대규모 시스템이라면 피할 수 없으므로, 설계 시 그 점을 반드시 고려해야한다.&lt;/p>
&lt;ul>
&lt;li>로드밸런서 장애
&lt;ul>
&lt;li>부(Secondary) 로드밸런서가 활성화되어 트래픽을 이어받아야한다.&lt;/li>
&lt;li>로드밸런서끼리 박동 신호를 주기적으로 보내 상태를 모니터링한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>블록 저장소 서버 장애
&lt;ul>
&lt;li>다른 서버가 미완료 상태 또는 대기 상태인 작업을 이어받아야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클라우드 저장소 장애
&lt;ul>
&lt;li>S3 버킷은 여러 지역에 다중화 할 수 있으므로, 한 지역에서 장애가 발생하였다면 다른 지역에서 파일을 가져온다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>API 서버 장애
&lt;ul>
&lt;li>API 서버는 무상태로, 로드밸런서가 해당 서버에 요청을 보내지 않음으로 장애 서버와 격리한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 캐시 장애
&lt;ul>
&lt;li>다중화하여 다른 노드에서 데이터를 가져온다.&lt;/li>
&lt;li>장애가 발생한 서버는 새 서버로 교체한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 데이터베이스 장애
&lt;ul>
&lt;li>주 데이터베이스 장애
&lt;ul>
&lt;li>부 데이터베이스 서버 가운데 하나를 주 데이터베이스로 바꾼 후, 부 데이터베이스를 추가한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>부 데이터베이스 장애
&lt;ul>
&lt;li>다른 부 데이터베이스 서버가 읽기 연산을 처리하도록 한다.&lt;/li>
&lt;li>부 데이터베이스 서버를 새로 하나 추가한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 서비스 장애
&lt;ul>
&lt;li>접속중인 모든 사용자가 알림 서버와 롱 폴링 연결을 하나씩 유지하므로, 많은 사용자와의 연결을 유지하고 관리해야한다.&lt;/li>
&lt;li>따라서 장애가 발생하면 롱 폴링 연결을 다시 만들어야 하므로 복구하는 것이 상대적으로 느릴 수 있다.&lt;/li>
&lt;li>유지는 쉽지만, 연결을 새로 만드는 것은 오래걸린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오프라인 사용자 백업 큐 장애
&lt;ul>
&lt;li>다중화를 통해 구독 중인 클라이언트들은 백업 큐로 구독 관게를 재설정해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>높은 수준의 일관성, 낮은 네트워크 지연, 빠른 동기화가 요구된다는 점이 핵심이었다.&lt;/p>
&lt;ul>
&lt;li>구글 드라이브 시스템은 크게 두 가지 부분으로 구성된다.
&lt;ul>
&lt;li>파일의 메타데이터를 관리&lt;/li>
&lt;li>파일 동기화를 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 서비스는 이 두 부분과 변존하는 또 하나의 중요 컴포넌트
&lt;ul>
&lt;li>롱 폴링을 사용하여 클라이언트로 하여금 파일의 상태를 최신으로 유지할 수 있도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>설계안에 어떤 다른 선택지가 있었는지 살펴보면 좋다.&lt;/p>
&lt;ul>
&lt;li>블록 저장소 서버를 거치지 않고 파일을 클라우드 저장소에 직접 업로드한다면?
&lt;ul>
&lt;li>업로드 시간이 빨라질 수 있다.&lt;/li>
&lt;li>분할, 압축, 암호화 로직이 클라이언트에서 처리되어야한다.&lt;/li>
&lt;li>따라서 플랫폼별로 따로 구현해야한다.&lt;/li>
&lt;li>클라이언트가 해킹 당할 가능성이 있으므로 암호화 로직이 클라이언트에 두는 것이 적절치 않을 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>접속상태 관리 로직을 별도 서비스로 옮기는것은?
&lt;ul>
&lt;li>관련 조릭을 알림 서비스에서 분리하면, 다른 서비스에서도 쉽게 활용할 수 있게될 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>13. 검색어 자동완성 시스템</title><link>https://codemario318.github.io/post/system-design-interview/13/</link><pubDate>Tue, 09 Jul 2024 13:22:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/13/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/cover.png" alt="Featured image of post 13. 검색어 자동완성 시스템" />&lt;p>검색어 자동 완성(Autocomplete, Typeahead, Search-as-you-type, Incremental Search)은 입력 중인 글자에 맞는 검색어가 자동으로 완성하여 표시되는 기능이다.&lt;/p>
&lt;p>검색어 자동완성은 많은 제품에 중요하게 사용되는 기능으로 이번 장에서는 가장 많이 이용된 검색어 K개를 자동완성하여 출력하는 시스템을 설계한다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;ul>
&lt;li>Q. 사용자의 입력 단어가 자동완성 될 검색어의 어느 부분인가?(첫, 뒷)
&lt;ul>
&lt;li>A. 첫 부분으로 한정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 몇 개의 자동완성 검색어가 표시?
&lt;ul>
&lt;li>A. 5개&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 자동완성 검색어 5개를 고르는 기준은?
&lt;ul>
&lt;li>A. 질의 빈도에 따라 정해지는 인기 순위&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 맞춤법 검사 기능 제공?
&lt;ul>
&lt;li>A. N&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 질의는 영어?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 대문자나 특수문자도 처리?
&lt;ul>
&lt;li>A. 모든 질의는 영어 소문자만&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 얼마나 많은 사용자를 지원?
&lt;ul>
&lt;li>A. DAU 천만&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="요구사항">요구사항&lt;/h3>
&lt;p>위 질의응답을 통해 정리한 요구사항은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>빠른 응답 속도
&lt;ul>
&lt;li>사용자가 검색어를 입력합에 따라 자동완성 검색어도 충분히 빨리 표시되어야한다.&lt;/li>
&lt;li>페이스북은 응답속도 100ms 이내를 기준으로 한다.&lt;/li>
&lt;li>자동 완성은 실시간으로 빠르게 처리되는 특성으로 느리면 사용이 매우 불편해진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>연관성
&lt;ul>
&lt;li>자동완성 결과는 사용자가 입력한 단어와 연관된 것 이어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>정렬
&lt;ul>
&lt;li>계산 결과는 인기도(Populatiry) 등의 순위 모델(Ranking Model)에 의해 정렬되어 있어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규모 확장성
&lt;ul>
&lt;li>많은 트래픽을 감당할 수 있도록 확장 가능해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>고가용성
&lt;ul>
&lt;li>시스템의 일부에 장애, 지연, 네트워크 문제가 생겨도 계속 사용 가능해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;ul>
&lt;li>DAU는 천만 명으로 가정&lt;/li>
&lt;li>사용자는 평균적으로 매일 10건의 검색을 수행한다고 가정&lt;/li>
&lt;li>질의 마다 평균적으로 20바이트 데이터를 입력한다고 가정
&lt;ul>
&lt;li>ASCII 사용한다고 가정(&lt;code>1문자 = 1바이트&lt;/code>)&lt;/li>
&lt;li>질의문은 평균적으로 4개 단어, 각 단어는 다섯 글자로 구성된다고 가정&lt;/li>
&lt;li>질의당 평균 &lt;code>4 * 5 = 20바이트&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>검색창에 글자를 입력할 때마다 클라이언트는 검색어 자동완성 백엔드에 요청을 보낸다.
&lt;ul>
&lt;li>평균적으로 1회 검색당 20건의 요청이 백엔드로 전달된다.&lt;/li>
&lt;li>&lt;strong>&amp;ldquo;dinner&amp;rdquo;&lt;/strong> 입력 예시
&lt;ol>
&lt;li>&lt;code>search?q=d&lt;/code>&lt;/li>
&lt;li>&lt;code>search?q=di&lt;/code>&lt;/li>
&lt;li>&lt;code>search?q=din&lt;/code>&lt;/li>
&lt;li>&lt;code>search?q=dinn&lt;/code>&lt;/li>
&lt;li>&lt;code>search?q=dinne&lt;/code>&lt;/li>
&lt;li>&lt;code>search?q=dinner&lt;/code>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>대략 &lt;strong>초당 24,000건 질의&lt;/strong>(QPS)
&lt;ul>
&lt;li>&lt;code>10,000,000 사용자 * (10 질의/일) * 20자 / 24시간 / 3,600초&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>최대 QPS = QPS * 2 = 대략 48,000&lt;/code>&lt;/li>
&lt;li>질의 중 20%는 신규 검색어라 가정.
&lt;ul>
&lt;li>&lt;code>10,000,000 사용자 * (10 질의/일 * 20자 * 20%) = 일 0.4GB&lt;/code>&lt;/li>
&lt;li>0.4GB의 신규 데이터가 시스템에 추가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>검색어 자동완성 시스템은 개략적으로 두 부분으로 나뉜다.&lt;/p>
&lt;ul>
&lt;li>데이터 수집 서비스(Data gathering service)
&lt;ul>
&lt;li>사용자가 입력한 질의를 실시간로 수집하는 시스템&lt;/li>
&lt;li>데이터가 많은 시스템에 실시간으로 수집하는건 바람직하지 않기 때문에 진행하며 현실적인 안으로 교체한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>질의 서비스(Query Service)
&lt;ul>
&lt;li>주어진 질의에 다섯 개의 인기 검색어를 정렬해 내놓는 서비스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="데이터-수집-서비스">데이터 수집 서비스&lt;/h3>
&lt;p>데이터 수집 서비스의 동작을 간단한 예제로 살펴본다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img.png"
width="813"
height="248"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_hu094d2fe86b78a26a1e7a8068730185af_51914_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_hu094d2fe86b78a26a1e7a8068730185af_51914_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 수집 서비스 동작 예"
class="gallery-image"
data-flex-grow="327"
data-flex-basis="786px"
>&lt;/p>
&lt;p>질의문과 사용 빈도를 저장하는 빈도 테이블(frequency table)이 있다고 가정하면, 처음 이 테이블은 비어있지만, 사용자가 검색하면 그 상태가 바뀌어 나가게 된다.&lt;/p>
&lt;h3 id="질의-서비스">질의 서비스&lt;/h3>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
Frequency {
query varchar
freuqency bigint
}
&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>query&lt;/th>
&lt;th>freuqency&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>twitter&lt;/td>
&lt;td>35&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>twitch&lt;/td>
&lt;td>29&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>twilight&lt;/td>
&lt;td>25&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>twin peak&lt;/td>
&lt;td>21&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>twitch prime&lt;/td>
&lt;td>18&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>twitter search&lt;/td>
&lt;td>14&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>twillo&lt;/td>
&lt;td>10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>twin peak sf&lt;/td>
&lt;td>8&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>위와 같은 상태에서 사용자가 &lt;code>tw&lt;/code>를 검색창에 입력하면 &amp;ldquo;top 5&amp;rdquo; 검색어가 표시되어야 한다.&lt;/p>
&lt;ul>
&lt;li>twitter&lt;/li>
&lt;li>twitch&lt;/li>
&lt;li>twilight&lt;/li>
&lt;li>twin peak&lt;/li>
&lt;li>twitch prime&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">frequency&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">prefix&lt;/span>&lt;span class="o">%`&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">frequency&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이러한 방법은 데이터 양이 적을 때는 나쁘지 않지만, 데이터가 아주 많아지면 데이터베이스가 병목이 될 수 있다.&lt;/p>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>개략적 설계안은 출발점으로 나쁘진 않지만 최적화가 이루어지지 않아 장기적으로 발전이 필요한 구조였다.&lt;/p>
&lt;p>이번 절에서는 컴포넌트를 몇 개 골라 보다 상세히 설계하고 다음 순서로 최적화 방안을 논의한다.&lt;/p>
&lt;ul>
&lt;li>트라이(Trie) 자료구조&lt;/li>
&lt;li>데이터 수집 서비스&lt;/li>
&lt;li>질의 서비스&lt;/li>
&lt;li>규모 확장이 가능한 저장소&lt;/li>
&lt;li>트라이 연산&lt;/li>
&lt;/ul>
&lt;h3 id="트라이-자료구조">트라이 자료구조&lt;/h3>
&lt;p>개략적 설계안에서는 관계형 데이터베이스를 저장소로 사용했었지만, 관계형 데이터베이스를 이용해 가장 인기 있었던 다섯 개 질의문을 골라내는 방법은 비교적 효율적이지 않다.&lt;/p>
&lt;p>이 문제는 트라이(Trie, 접두어 트리, Prefix tree)를 사용해 성능을 끌어올릴 수 있다.&lt;/p>
&lt;p>트라이는 &lt;strong>문자열들을 간략하게 저장할 수 있는 자료구조&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>트리 형태의 자료 구조다.&lt;/li>
&lt;li>루트 노드는 빈 문자열을 나타낸다.&lt;/li>
&lt;li>각 노드는 글자 하나를 저장하며, 이 설계에서는 26개의 자식 노드를 가질 수 있다.
&lt;ul>
&lt;li>자식 노드는 해당 글자 다음에 등장할 수 있는 모든 글자의 개수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 트리 노드는 하나의 &lt;strong>단어&lt;/strong>, 또는 &lt;strong>접두어 문자열&lt;/strong>을 나타낸다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_1.png"
width="832"
height="497"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_1_hu96baf2f881fae79a8806ed5884aa8fc0_62176_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_1_hu96baf2f881fae79a8806ed5884aa8fc0_62176_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="기본 트라이 구조"
class="gallery-image"
data-flex-grow="167"
data-flex-basis="401px"
>&lt;/p>
&lt;p>기본 트라이 자료구조는 노드에 문자들을 저장한다.&lt;/p>
&lt;p>이를 이용 빈도에 따라 정렬된 결과를 위해 노드에 빈도 정보까지 함께 저장해야한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>query&lt;/th>
&lt;th>frequency&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>tree&lt;/td>
&lt;td>10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>try&lt;/td>
&lt;td>29&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>true&lt;/td>
&lt;td>35&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>toy&lt;/td>
&lt;td>14&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>wish&lt;/td>
&lt;td>25&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>win&lt;/td>
&lt;td>50&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_2.png"
width="704"
height="423"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_2_hue80ee0274c415f5b7e1ad093e0402423_53720_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_2_hue80ee0274c415f5b7e1ad093e0402423_53720_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="빈도수가 포함된 트라이"
class="gallery-image"
data-flex-grow="166"
data-flex-basis="399px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;code>p&lt;/code>: 접두어 길이&lt;/li>
&lt;li>&lt;code>n&lt;/code>: 트라이 안에 있는 노드 개수&lt;/li>
&lt;li>&lt;code>c&lt;/code>: 주어진 노드의 자식 노드 개수&lt;/li>
&lt;/ul>
&lt;p>가장 많이 사용된 질의어 k개는 다음과 같이 찾을 수 있다.&lt;/p>
&lt;ol>
&lt;li>해당 접두어를 표현하는 노드를 찾는다. &lt;code>O(p)&lt;/code>&lt;/li>
&lt;li>해당 노드부터 시작하는 하위 트리를 탐색하여 모든 유효 노드를 찾는다. &lt;code>O(c)&lt;/code>
&lt;ul>
&lt;li>유효한 검색 문자열을 구성하는 노드가 유효 노드&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유효 노드들을 정렬하여 가장 인기 있는 검색어 k개를 찾는다. &lt;code>O(clogc)&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_3.png"
width="723"
height="500"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_3_hu8518561d22de585d1d9daae8066e51dc_100613_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_3_hu8518561d22de585d1d9daae8066e51dc_100613_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="k = 2, &amp;ldquo;be&amp;rdquo; 입력 예시"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;p>이 알고리즘의 시간 복잡도는 위의 각 단계에 소요된 시간의 합이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>O(p) + O(c) + O(clogc)&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>직관적이지만 최악의 경우 k개 결과를 얻으려고 전체 트라이를 다 검색해야 하는 일이 생길 수 있다.&lt;/p>
&lt;p>이러한 문제를 해결할 방법으로 두 가지 정도를 꼽을 수 있다.&lt;/p>
&lt;ul>
&lt;li>접두어의 최대 길이 제한&lt;/li>
&lt;li>각 노드에 인기 검색어 캐시&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>접두어 최대 길이 제한&lt;/strong>&lt;/p>
&lt;p>사용자가 검색창에 긴 검색어를 입력하는 일은 거의 없다는 것을 이용한 방식으로, &lt;code>p&lt;/code>값을 작은 정숫값으로 가정한다.&lt;/p>
&lt;ul>
&lt;li>접두어 노드를 찾는 단계의 시간 복잡도가 &lt;code>O(p)&lt;/code>에서 &lt;code>O(작은 상수값) = O(1)&lt;/code>로 바뀐다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>노드에서 인기 검색어 캐시&lt;/strong>&lt;/p>
&lt;p>각 노드에 k개의 인기 검색어를 저장해 두면 전체 트라이를 검색하는 일을 방지할 수 있다.&lt;/p>
&lt;ul>
&lt;li>5 ~ 10개 정도의 자동완성 제안을 표시하면 충분하므로, k는 충분히 작은 값이다.&lt;/li>
&lt;/ul>
&lt;p>이러한 방법은 검색어를 질의하는 시간 복잡도를 매우 낮출 수 있으나, 각 노드에 질의어를 저장할 공간이 많이 필요하게된다.&lt;/p>
&lt;p>하지만 빠른 응답속도의 우선순위가 매우 높은 경우 저장공간을 희생할 만한 가치는 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_4.png"
width="832"
height="422"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_4_hu52decc19d8be7f33438032912b874586_137079_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_4_hu52decc19d8be7f33438032912b874586_137079_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="캐시가 적용된 트라이"
class="gallery-image"
data-flex-grow="197"
data-flex-basis="473px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>접두어 최대 길이 제한&lt;/strong>과 &lt;strong>인기 검색어 캐시&lt;/strong>를 추가하면 아래와 같이 최적화 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>접두어 노드를 찾는 시간 복잡도가 &lt;code>O(1)&lt;/code>로 바뀐다.&lt;/li>
&lt;li>최고 인기 검색어 5개를 찾는 질의의 시간 복잡도도 &lt;code>O(1)&lt;/code>로 바뀐다.&lt;/li>
&lt;/ul>
&lt;p>각 단계의 시간 복잡도가 &lt;code>O(1)&lt;/code>로 처리되므로, 최고 인기 검색어 k개를 찾는 전체 알고리즘의 복잡도도 &lt;code>O(1)&lt;/code>이다.&lt;/p>
&lt;h3 id="데이터-수집-서비스-1">데이터 수집 서비스&lt;/h3>
&lt;p>사용자가 검색창에 타이핑을 할 때마다 실시간으로 데이터를 수정하는 방식은 아래와 같은 문제점이 있다.&lt;/p>
&lt;ul>
&lt;li>매일 수천만 건의 질의가 입력될 텐데, 그 때마다 트라이를 갱신하면 질의 서비스는 심각하게 느려진다.&lt;/li>
&lt;li>트라이가 만들어지고 나면 인기 검색어는 그다지 자주 바뀌지 않을 것이다.
&lt;ul>
&lt;li>트라이는 자주 갱신할 필요가 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이를 위한 &lt;strong>규모 확장&lt;/strong>이 쉬운 데이터 수집 서비스를 만들려면 &lt;strong>데이터가 어디서 오고 어떻게 이용되는지&lt;/strong>를 살펴야 한다.&lt;/p>
&lt;ul>
&lt;li>트위터 같은 실시간 애플리케이션
&lt;ul>
&lt;li>제안되는 검색어를 항상 신선하게 유지할 필요가 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>구글 검색 같은 애플리케이션
&lt;ul>
&lt;li>그렇게 자주 바꿔줄 이유는 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_5.png"
width="832"
height="284"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_5_hua9039b8861a31be5feff85427b2db289_102806_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_5_hua9039b8861a31be5feff85427b2db289_102806_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 분석 서비스의 수정된 설계안"
class="gallery-image"
data-flex-grow="292"
data-flex-basis="703px"
>&lt;/p>
&lt;p>트라이를 만드는 데 쓰는 데이터는 보통 &lt;strong>분석 서비스&lt;/strong>(Analytics)나 &lt;strong>로깅 서비스&lt;/strong>(Logging service)를 이용하므로, 실시간으로 반영하지 않더라도 기본 구조는 바뀌지 않는다.&lt;/p>
&lt;p>&lt;strong>데이터 분석 서비스 로그&lt;/strong>&lt;/p>
&lt;p>검색창에 입력된 질의에 관한 원본 데이터가 보관된다.&lt;/p>
&lt;p>새로운 데이터가 추가될 뿐 수정은 이루어지지 않으며, 로그 데이터에는 인덱스를 걸지 않는다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>query&lt;/th>
&lt;th>time&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>tree&lt;/td>
&lt;td>2019-10-01 22:01:01&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&lt;/td>
&lt;td>&amp;hellip;&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>로그 취합 서버&lt;/strong>&lt;/p>
&lt;p>로그는 보통 그 양이 엄청나고 데이터 형식도 제각각인 경우가 많다.&lt;/p>
&lt;p>따라서 이 데이터를 잘 취합하여 우리 시스템이 쉽게 소비할 수 있도록 해야한다.&lt;/p>
&lt;p>데이터 취합 방식은 자동완성 서비스의 제공 방식에 따라 달라질 수 있다.&lt;/p>
&lt;ul>
&lt;li>실시간 애플리케이션
&lt;ul>
&lt;li>데이터 취합 주기를 짧게 가져간다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>대부분의 경우
&lt;ul>
&lt;li>일주일에 한 번 정도 로그를 취합해도 충분&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>취합된 데이터&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>query&lt;/th>
&lt;th>time&lt;/th>
&lt;th>frequency&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>tree&lt;/td>
&lt;td>2019-10-01&lt;/td>
&lt;td>12000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&lt;/td>
&lt;td>&amp;hellip;&lt;/td>
&lt;td>&amp;hellip;&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>작업 서버&lt;/strong>&lt;/p>
&lt;p>주기적으로 비동기적 작업을 실행하는 서버 집합으로, 트라이 자료구조를 만들고 트라이 데이터베이스에 저장하는 역할을 담당한다.&lt;/p>
&lt;p>&lt;strong>트라이 캐시&lt;/strong>&lt;/p>
&lt;p>분산 캐시 시스템으로 트라이 데이터를 메모리에 유지하여 읽기 연산 성능을 높이는 역할을 한다.&lt;/p>
&lt;ul>
&lt;li>매주 트라이 데이터베이스의 스냅샷을 떠서 갱신한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>트라이 데이터베이스&lt;/strong>&lt;/p>
&lt;p>지속성 저장소로 트라이 데이터베이스로 사용할 수 있는 선택지로는 다음의 두 가지가 있다.&lt;/p>
&lt;ul>
&lt;li>문서 저장소(Document store)
&lt;ul>
&lt;li>새 트라이를 매주 만들 것이므로, 주기적으로 트라이를 직렬화하여 데이터베이스에 저장할 수 있다.&lt;/li>
&lt;li>몽고디비(MongoDB) 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>키-값 저장소
&lt;ul>
&lt;li>트라이는 해시 테이블 형태로 변환 가능하다.
&lt;ul>
&lt;li>트라이에 보관된 모든 접두어를 해시 테이블 키로 변환&lt;/li>
&lt;li>각 트라이 노드에 보관된 모든 데이터를 해시 테이블 값으로 변환&lt;/li>
&lt;li>트라이 노드는 하나의 &lt;code>&amp;lt;키, 값&amp;gt;&lt;/code> 쌍으로 변환된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_6.png"
width="818"
height="435"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_6_hua95a8a6c746aca929abb2d260afaf51a_125121_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_6_hua95a8a6c746aca929abb2d260afaf51a_125121_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="트라이를 해시 테이블로"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="451px"
>&lt;/p>
&lt;h3 id="질의-서비스-1">질의 서비스&lt;/h3>
&lt;p>개략적 설계안에서의 데이터베이스를 활용한 방식에서 개선된 새 설계안이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_7.png"
width="540"
height="766"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_7_hu1b3b4c00c9a15e24d680cf68ec588414_134975_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_7_hu1b3b4c00c9a15e24d680cf68ec588414_134975_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="새 설계안"
class="gallery-image"
data-flex-grow="70"
data-flex-basis="169px"
>&lt;/p>
&lt;ol>
&lt;li>검색 질의가 로드밸런서로 전송된다.&lt;/li>
&lt;li>로드밸런서는 해당 질의를 API 서버로 보낸다.&lt;/li>
&lt;li>트라이 캐시에서 데이터를 가져와 해당 요청에 대한 자동완성 검색어 제안 응답을 구성한다.&lt;/li>
&lt;li>데이터가 트라이 캐시에 없는 경우 데이터를 데이터베이스에서 가져와 캐시에 채운다.
&lt;ul>
&lt;li>다음에 같은 접두어에 대한 질의가 올 것을 대비하여 캐시를 갱신&lt;/li>
&lt;li>캐시 미스는 캐서 서버의 메모리가 부족하거나 캐시 서버에 장애가 있어도 발생 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>질의 서비스는 번개처럼 빨라야 한다. 이를 위해 다음과 같은 최적화 방안을 생각해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>AJAX
&lt;ul>
&lt;li>비동기로 결과를 받아오므로, 페이지를 새로고침 할 필요가 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>브라우저 캐싱
&lt;ul>
&lt;li>자동완성 검색어 제안 결과는 짧은 시간에 바뀌지 않으므로, 제안된 검색어들을 브라우저 캐시에 넣어두면 후속 결과는 캐시에서 가져갈 수 있다.&lt;/li>
&lt;li>구글은 제안된 검색어를 한 시간 동안 캐시해둔다.&lt;/li>
&lt;li>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_8.png"
width="834"
height="393"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_8_hu8b0378fb2b4e7998d2c93295e38b4b34_180503_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_8_hu8b0378fb2b4e7998d2c93295e38b4b34_180503_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="system design interview 응답 결과"
class="gallery-image"
data-flex-grow="212"
data-flex-basis="509px"
>
&lt;ul>
&lt;li>&lt;code>cache-control&lt;/code>헤더 값의 &lt;code>private&lt;/code>는 요청을 보낸 사용자의 캐시에만 보관된다는 의미(공용은 불가)&lt;/li>
&lt;li>&lt;code>max-age=3600&lt;/code> 한시간동안 유효&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 샘플링
&lt;ul>
&lt;li>모든 질의 결과를 로깅하도록 하면 CPU 자원과 저장공간을 많이 소진하므로, N개의 요청 가운데 1개만 로깅한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="트라이-연산">트라이 연산&lt;/h3>
&lt;p>트라이는 검색어 자동완성 시스템의 핵심이다.&lt;/p>
&lt;p>&lt;strong>트라이 생성&lt;/strong>&lt;/p>
&lt;p>트라이를 갱신하는데는 두 가지 방법이 있다.&lt;/p>
&lt;ul>
&lt;li>매주 한 번 갱신
&lt;ul>
&lt;li>새로운 트라이를 만든 후 기존 트라이를 대체&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 노드를 개별적으로 갱신
&lt;ul>
&lt;li>성능이 좋지 않다.&lt;/li>
&lt;li>트라이가 작을경우 고려할 수 있다.&lt;/li>
&lt;li>트라이 노드는 상위 노드에도 인기 검색어 질의 결과가 보관되므로 갱신시 모든 상위 노드도 갱신해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_9.png"
width="826"
height="390"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_9_hu73f4c20ed932e2b08c4d01884590a6ef_137820_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_9_hu73f4c20ed932e2b08c4d01884590a6ef_137820_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="트라이 노드 갱신"
class="gallery-image"
data-flex-grow="211"
data-flex-basis="508px"
>&lt;/p>
&lt;p>&lt;strong>검색어 삭제&lt;/strong>&lt;/p>
&lt;p>부적절한 질의어를 자동완성 결과에서 제거해야할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_10.png"
width="826"
height="183"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_10_huf2ca44c4db3538feab14802c19a51e64_69611_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_10_huf2ca44c4db3538feab14802c19a51e64_69611_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="필터 레이어 추가"
class="gallery-image"
data-flex-grow="451"
data-flex-basis="1083px"
>&lt;/p>
&lt;p>이를 위한 좋은 방법은 트라이 캐시 앞에 &lt;strong>필터 계층&lt;/strong>(filter layer)를 두고 부적절한 질의어가 반환되지 않도록 하는 것이다.&lt;/p>
&lt;ul>
&lt;li>필터 규칙에 따라 검색 결과를 자유롭게 변경할 수 있다.&lt;/li>
&lt;li>데이터베이스에서 해당 검색어를 물리적으로 삭제하는 것은 다음 업데이트 사이클에 비동기적으로 진행한다.&lt;/li>
&lt;/ul>
&lt;h3 id="저장소-규모-확장">저장소 규모 확장&lt;/h3>
&lt;p>트라이의 크기가 한 서버에 넣기 힘든 경우에 대응할 수 있도록 규모 확장성 문제를 고려해야한다.&lt;/p>
&lt;p>간단하게 첫 글자를 기준으로 &lt;strong>샤딩&lt;/strong>하는 방법을 생각해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>두 대 서버가 필요하다면 &lt;code>a&lt;/code> ~ &lt;code>m&lt;/code>까지 글자로 시작하는 검색어는 1번 서버, 나머지는 2번 서버에 저장 하는 식으로 &amp;hellip;&lt;/li>
&lt;li>사용 가능한 서버는 최대 26대(영어 알파벳 개수)로 제한되므로, 그 이상 늘리려면 &lt;strong>계층적인 샤딩&lt;/strong>이 필요하다.
&lt;ul>
&lt;li>&lt;code>aa&lt;/code> ~ &lt;code>ag&lt;/code>, &lt;code>ah&lt;/code> ~ &lt;code>an&lt;/code> &amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이렇게 단순한 사딩은 단어의 알파벳 빈도수 문제(특정 알파벳으로 시작되는 단어가 몰려있다.)로 인해 데이터를 각 서버에 균등하게 배분하는것이 불가능하다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_11.png"
width="688"
height="478"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_11_hu659a97cc810b612463efb5f205eeeb0b_119879_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_11_hu659a97cc810b612463efb5f205eeeb0b_119879_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="빈도수 반영"
class="gallery-image"
data-flex-grow="143"
data-flex-basis="345px"
>&lt;/p>
&lt;p>따라서 과거 질의 데이터의 패턴을 분석하여 알바벳 빈도수를 파악하고, 빈도수를 통해 샤딩하는 방식을 고려해야한다.&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;ul>
&lt;li>다국어 지원이 가능하도록 하려면?
&lt;ul>
&lt;li>트라이에 유니코드 데이터를 저장한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>국가별로 인기 검색어 순위가 다르다면?
&lt;ul>
&lt;li>국가별로 다른 트라이를 사용하도록 한다.&lt;/li>
&lt;li>트라이를 CDN에 저장하여 응답속도를 높이는 방식도 고려할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>실시간으로 변하는 검색어의 추이를 반영하려면?
&lt;ul>
&lt;li>현제 설계는 위와 같은 처리가 적절치 않다.
&lt;ul>
&lt;li>작업 서버가 매주 한 번 씩만 돈다.&lt;/li>
&lt;li>때 맟춰 서버가 실행되어도, 트라이 구성에 많은 시간이 소요된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>샤딩을 통해 작업 대상 데이터의 양을 줄인다.&lt;/li>
&lt;li>순위 모델을 바꾸어 최근 검색어에 보다 높은 가중치를 준다.&lt;/li>
&lt;li>데이터가 스트림 형태로 올 수 있다는 점, 즉 한번에 모든 데이터를 동시에 사용할 수 없을 가능성이 있다는 점을 고려해야한다.
&lt;ul>
&lt;li>데이터가 지속적으로 생성된다는 뜻으로 스트림 프로세싱을 위한 특별한 시스템이 필요하다.
&lt;ul>
&lt;li>아파치 하둡 맵리듀스, 아파치 스파크 스트리밍, 아파치 스톰, 아파치 카프가 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>12. 채팅 시스템 설계</title><link>https://codemario318.github.io/post/system-design-interview/12/</link><pubDate>Fri, 05 Jul 2024 10:02:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/12/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/cover.png" alt="Featured image of post 12. 채팅 시스템 설계" />&lt;p>이번 장에서는 채팅 시스템을 설계해본다.&lt;/p>
&lt;p>채팅 앱은 중점적으로 다뤄야하는 문제에 따라 방향성이 달라질 수 있으므로, 요구사항을 확실히 파악하는것이 매우 중요하기 때문에, 어떤 채팅 앱을 설계하려는지 확실히 해 두는것이 중요하다.&lt;/p>
&lt;ul>
&lt;li>1:1 채팅 중점
&lt;ul>
&lt;li>페이스북 메신저, 위챗, 왓츠앱 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>그룹 채팅 중점
&lt;ul>
&lt;li>슬랙 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>대규모 그룹의 소통과 음성 채팅
&lt;ul>
&lt;li>디스코드 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>질문을 통해 의도를 파악한다.&lt;/p>
&lt;ul>
&lt;li>Q. 1:1 채팅, 그룹 채팅?
&lt;ul>
&lt;li>A. 둘 다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 모바일? 웹?
&lt;ul>
&lt;li>A. 둘 다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 트래픽 규모는?
&lt;ul>
&lt;li>A. DAU 5천만&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 그룹 채팅의 인원 제한?
&lt;ul>
&lt;li>A. 최대 100명&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 중요 기능으로는?
&lt;ul>
&lt;li>A. 1:1 채팅, 그룹 채팅, 사용자 접속 상태 표시, 텍스트 메시지만 허용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 메시지 길이 제한은?
&lt;ul>
&lt;li>A. 100,000자 이하&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 종단 간 암호화(end-to-end encryption) 지원?
&lt;ul>
&lt;li>A. 현재로서는 불필요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 채팅 이력은 얼마나 보관?
&lt;ul>
&lt;li>A. 영원히.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위와 같은 질의응답을 통해 아래와 같은 요구사항을 찾을 수 있다.&lt;/p>
&lt;ul>
&lt;li>응답지연이 낮은 일대일 채팅기능(DAU)&lt;/li>
&lt;li>최대 100명까지 참여할 수 있는 그룹 채팅 기능&lt;/li>
&lt;li>사용자의 접속상태 표시 기능&lt;/li>
&lt;li>다양한 단말 지원, 하나의 계정으로 여러 단말에 동시 접속 지원(웹, 앱 둘다 고려)&lt;/li>
&lt;li>푸시 알림&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>채팅 시스템의 경우 클라이언트는 모바일 앱이거나 웹 애필리케이션이다.&lt;/p>
&lt;p>클라이언트는 서로 직접 통신하지 않는 대신, 각 클라이언트는 위에 나열한 모든 기능을 지우너하는 채팅 서비스와 통신한다.&lt;/p>
&lt;p>따라서 채팅 서비스는 아래 기능을 제공해야 한다.&lt;/p>
&lt;ul>
&lt;li>클라이언트들로부터 메시지 수진&lt;/li>
&lt;li>메시지 수신자(recipient) 결정 및 전달&lt;/li>
&lt;li>수신자가 접속 상태가 아닌 경우 접속할 때까지 해당 메시지 보관&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img.png"
width="831"
height="141"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_hu846a4193e09f6599f67011f5f29692cb_42945_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_hu846a4193e09f6599f67011f5f29692cb_42945_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클라이언트와 채팅 서비스 관계"
class="gallery-image"
data-flex-grow="589"
data-flex-basis="1414px"
>&lt;/p>
&lt;p>채팅을 시작하려는 클라이언트는 네트워크 통신 프로토콜을 사용하여 서비스에 접속하므로, 어떤 통신 프로토콜을 사용할 것인가도 중요한 문제다.&lt;/p>
&lt;p>대부분의 클라이언트/서버 애플리케이션에서 요청을 보내는 것은 클라이언트이며, 채팅 시스템도 마찬가지다.&lt;/p>
&lt;p>위 예시에서는 송신 클라이언트가 수신 클라이언트에게 전달 할 메시지를 보낼 때, 오랜 세월 검증된 &lt;strong>HTTP 프로토콜&lt;/strong>을 사용한다.&lt;/p>
&lt;p>HTTP를 사용한다면, 채팅 서비스에서는 클라이언트가 지속적으로 메시지를 보낸다는 특성을 고려하여, &lt;code>keep-alive&lt;/code> 헤더를 사용해 서버와 클라이언트가 연결을 끊지 않고 유지하는 것이 좋다.&lt;/p>
&lt;p>하지만 메시지 발신에 비해 수신 시나리오는 이것보다 복잡하기 때문에 HTTP가 적절치 않을 수 있다.&lt;/p>
&lt;ul>
&lt;li>서버가 채팅 발신 요청을 받게 되면, 서버가 수신자에게 메시지를 전달해야한다.&lt;/li>
&lt;li>HTTP는 클라이언트가 연결을 만드는 특성으로, 서버에서 클라이언트로 임의 시점에 메시지를 보내는 데 쉽게 쓰일 수 없다.&lt;/li>
&lt;/ul>
&lt;p>이러한 문제를 개선하기위해 서버가 연결을 만드는 것처럼 동작하는 많은 기법이 제안되었다.&lt;/p>
&lt;ul>
&lt;li>폴링, 롱폴링, 웹소켓&lt;/li>
&lt;/ul>
&lt;h3 id="폴링">폴링&lt;/h3>
&lt;p>폴링은 클라이언트가 주기적으로 서버에게 새 메시지가 있는냐고 물어보는 방법이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_1.png"
width="831"
height="879"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_1_huaa79ccbd5858bc013d0c473ceded0490_112044_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_1_huaa79ccbd5858bc013d0c473ceded0490_112044_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="폴링"
class="gallery-image"
data-flex-grow="94"
data-flex-basis="226px"
>&lt;/p>
&lt;p>폴링 비용은 폴링을 자주하면 할수록 올라가므로, 답해줄 메시지가 없는 경우에는 서버 자원이 불필요하게 낭비된다.&lt;/p>
&lt;h3 id="롱-폴링">롱 폴링&lt;/h3>
&lt;p>폴링의 비효율성을 개선하기위해 롱 폴링이 제안되었다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_2.png"
width="831"
height="746"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_2_hu9446a286a0026c1d57706962c9f7b24e_79065_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_2_hu9446a286a0026c1d57706962c9f7b24e_79065_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="롱 폴링"
class="gallery-image"
data-flex-grow="111"
data-flex-basis="267px"
>&lt;/p>
&lt;ul>
&lt;li>클라이언트는 새 메시지가 반환되거나 타임아웃 될 때가지 연결을 유지한다.&lt;/li>
&lt;li>새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내 모든 절차를 다시 시작한다.&lt;/li>
&lt;/ul>
&lt;p>이 방법은 다음과 같은 약점이 있다.&lt;/p>
&lt;ul>
&lt;li>메시지를 보내는 클라이언트가 수신하는 클라이언트가 같은 채팅 서버에 접속하지 않을 수 있다.
&lt;ul>
&lt;li>HTTP 서버들은 보통 무상태이다. 즉 로드 밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우(요청을 무작위로 분산하는 경우), 메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와의 롱 폴링 연결을 가지고 있지 않은 서버일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서버는 클라이언트가 연결을 해제했는지 알 수 있는 좋은 방법이 없다.&lt;/li>
&lt;li>여전히 비효율적이다.
&lt;ul>
&lt;li>메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 때마다 주기적으로 서버에 다시 접속한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="웹소켓">웹소켓&lt;/h3>
&lt;p>웹소켓은 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_3.png"
width="821"
height="498"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_3_huebfcb5cdfaf26f40aef3085b89b61c7b_77060_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_3_huebfcb5cdfaf26f40aef3085b89b61c7b_77060_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="웹소켓"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="395px"
>&lt;/p>
&lt;ul>
&lt;li>웹소켓 연결은 클라이언트가 시작하며, 한번 맺어진 연결은 항구적이며(변하지않고 오래가며) 양방향이다.&lt;/li>
&lt;li>처음에는 HTTP 연결이지만 특정 핸드셰이크 절차를 거져 웹소켓 연결로 업그레이드된다.
&lt;ul>
&lt;li>일반적으로 방화벽이 있는 환경에서도 잘 동작한다.&lt;/li>
&lt;li>HTTP, HTTPS 가 쓰는 포트를 그대로 활용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>연결이 만들어지고 나면, 서버는 클라이언트에게 비동기적으로 메시지를 전송할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>웹소켓은 메시지를 보내려는 클라이언트에게 준수한 HTTP 프로토콜의 특징에 더해 양방향 메시지 전송까지 가능하게 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_4.png"
width="607"
height="355"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_4_huc6205357ded82087fb2f30ab5b292d46_55256_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_4_huc6205357ded82087fb2f30ab5b292d46_55256_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="웹소켓 활용 예시"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="410px"
>&lt;/p>
&lt;ul>
&lt;li>웹소켓을 이용하면 메시지를 보낼 때나 받을 때 동일한 프로토콜을 사용할 수 있으므로, 설계와 구현이 단순하고 직관적이다.&lt;/li>
&lt;li>단, 웹소켓 연결은 항구적으로 유지되어야 하기 때문에 서버 측에서 연결 관리를 효율적으로 해야한다.&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>클라이언트와 서버 사이의 주 통신 프로토콜로 웹소켓을 사용하지만, 다른 부분에서는 굳이 웹소켓을 쓸 필요는 없다.&lt;/p>
&lt;p>대부분의 기능인 회원가입, 로그인, 사용자 프로파일 등은 기존 HTTP상에서 구현하는 것이 더 좋다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_5.png"
width="644"
height="853"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_5_hu3b37951fbb1bf15ccce6fcd26ff957e5_234991_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_5_hu3b37951fbb1bf15ccce6fcd26ff957e5_234991_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="75"
data-flex-basis="181px"
>&lt;/p>
&lt;p>채팅 시스템은 세 부분으로 나눠볼 수 있다.&lt;/p>
&lt;h4 id="무상태-서비스">무상태 서비스&lt;/h4>
&lt;p>이 설계안에서 무상태 서비스는 로그인, 회원가입, 사용자 프로파일 표시 등을 처리하는 &lt;strong>전통적인 요청/응답&lt;/strong> 서비스다.&lt;/p>
&lt;ul>
&lt;li>일반적인 웹과 앱이 제공하는 기능들&lt;/li>
&lt;/ul>
&lt;p>무상태 서비스는 로드밸런서 뒤에 위치한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>서비스 탐색(sevice discovery) 서비스&lt;/strong>
&lt;ul>
&lt;li>클라이언트가 접속할 채팅 서버의 DNS 호스트명을 클라이언트에게 알려주는 역할을 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="상태-유지-서비스">상태 유지 서비스&lt;/h4>
&lt;p>채팅 서비스는 각 클라이언트는 채팅 서버와 독립적인 네트워크를 유지해야한다.&lt;/p>
&lt;ul>
&lt;li>클라이언트는 보통 다른 서버로 연결을 변경하지 않는다.&lt;/li>
&lt;li>서비스 탐색 서비스가 채팅 서버스와 긴밀히 협력하여 특정 서버에 부하가 몰리지 않도록 한다.&lt;/li>
&lt;/ul>
&lt;h4 id="써드파티-서비스-연동">써드파티 서비스 연동&lt;/h4>
&lt;p>채팅 앱에서 가장 중요한 써드파티 서비스는 푸시 알림이다.&lt;/p>
&lt;ul>
&lt;li>새 메시지 수신시 앱이 실행중이지 않더라도 알림을 받아야한다.&lt;/li>
&lt;/ul>
&lt;p>따라서 푸시 알림 서비스와의 통합은 아주 중요하다.&lt;/p>
&lt;h4 id="규모-확장성">규모 확장성&lt;/h4>
&lt;p>이번 장에서 다루는 시스템은 동시 접속자가 1M 이라고 가정하는데, 접속당 10K 서버 메모리가 필요하다면, 10GB 메모리만으로도 처리 가능하다.&lt;/p>
&lt;p>하지만 이정도 규모의 트래픽을 서버 한대로 처리하는 것은 &lt;strong>SPOF&lt;/strong> 등의 이유로 적절치 않다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_6.png"
width="797"
height="872"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_6_hu2f66c0a05c004fc0f4d257e106c12a84_230686_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_6_hu2f66c0a05c004fc0f4d257e106c12a84_230686_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안 최종"
class="gallery-image"
data-flex-grow="91"
data-flex-basis="219px"
>&lt;/p>
&lt;p>유의할 것은 실시간으로 메시지를 주고받기 위해 클라이언트는 채팅 서버와 웹소켓 연결을 끊지 않고 유지한다는 것이다.&lt;/p>
&lt;ul>
&lt;li>채팅 서버
&lt;ul>
&lt;li>클라이언트 사이에 메시지를 중계하는 역할 담당&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>접속 상태 서버(Presence server)
&lt;ul>
&lt;li>사용자의 접속 여부 관리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>API 서버
&lt;ul>
&lt;li>로그인, 회원가입, 프로파일 변경 등 그 외 나머지를 전부 처리(무상태)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 서버
&lt;ul>
&lt;li>푸시 알림을 보냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>키-값 저장소
&lt;ul>
&lt;li>채팅 이력을 보관&lt;/li>
&lt;li>시스템에 접속한 사용자는 이전 채팅 이력을 전부 보게된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="저장소">저장소&lt;/h4>
&lt;p>채팅 시스템의 기술 스택중 가장 중요한 부분 중 하나는 데이터 계층으로, 이 계층을 올바르게 만드는 데는 노력이 필요하다.&lt;/p>
&lt;p>중요한 선택 중 하나는 어떤 데이터베이스를 쓰는가(관계형, NoSQL 등)이며, 고려해야 할 핵심 요인은 &lt;strong>데이터의 유형&lt;/strong>과 &lt;strong>읽기/쓰기 연산의 패턴&lt;/strong> 이다.&lt;/p>
&lt;p>채팅 시스템에서는 보통 두 가지다.&lt;/p>
&lt;p>&lt;strong>사용자 프로파일, 설정, 친구 목록과 같은 일반적인 데이터&lt;/strong>&lt;br>
안정성을 보장하는 관계형 데이터베이스가 적절하다.&lt;/p>
&lt;ul>
&lt;li>다중화(replication)와 샤딩(sharding)으로 이러한 데이터의 가용성과 규모확장성을 보증할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>채팅 시스템에 고유한 데이터(채팅 이력)&lt;/strong>&lt;br>
이러한 유형의 데이터를 어떻게 보관할 지 결정하려면 읽기/쓰기 연산 패턴을 이해해야한다.&lt;/p>
&lt;ul>
&lt;li>채팅 이력 데이터 양은 엄청나다.
&lt;ul>
&lt;li>페이스북 메신저나 왓츠앱은 매일 600억개 메시지를 처리함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>빈번하게 사용되는 것은 주로 최근에 주고받은 메시지이다.
&lt;ul>
&lt;li>대부분 사용자는 오래된 메시지는 확인하지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>검색 기능, 언급(mention)된 메시지, 특정 메시지로 점프 하는 등 무작위적인 데이터 접근을 하는 경우도 있다.&lt;/li>
&lt;li>1:1 채팅 앱의 경우 읽기:쓰기 비율은 대략 1:1&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>키-값 저장소&lt;/strong>가 이러한 패턴을 지원할 수 있는 데이터베이스이다.&lt;/p>
&lt;ul>
&lt;li>수평적 규모 확장이 쉽다.&lt;/li>
&lt;li>데이터 접근 지연시간이 낮다.&lt;/li>
&lt;li>관계형 데이터베이스는 롱 테일에 해당하는(넓고 적게 분포하는) 데이터를 잘 처리하지 못하는 경향이 있다.
&lt;ul>
&lt;li>인덱스가 커지면 무작위 접근을 처리하는 비용이 늘어난다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이미 많은 안정적인 채팅 시스템이 키-값 저장소를 채택하고있다.
&lt;ul>
&lt;li>페이스북: Hbase, 디스코드: 카산드라 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>롱테일 효과란?&lt;br>
&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_7.png"
width="487"
height="360"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_7_hub3d79bb345ad1bef179816c28fd060f6_45686_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_7_hub3d79bb345ad1bef179816c28fd060f6_45686_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="롱테일 효과"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="324px"
>&lt;br>
파레토 법칙에 의한 80:20 집중 현상을 그래프에 나타냈을 때 꼬리처림 긴 부분을 형성하는 80%의 부분&lt;/p>
&lt;/blockquote>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;h4 id="11-채팅을-위한-메시지-테이블">1:1 채팅을 위한 메시지 테이블&lt;/h4>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
Message {
message_id bigint
message_from bigint
message_to bigint
content text
created_at timestamp
}
&lt;/pre>
&lt;p>&lt;code>Message&lt;/code> 테이블의 기본키는 &lt;code>message_id&lt;/code>로, 메시지 순서를 쉽게 정할 수 있도록 하는 역할도 담당한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>created_at&lt;/code>은 메시지가 동시에 만들어 질 수 있으므로 순서를 정할 수 없다.&lt;/li>
&lt;/ul>
&lt;h4 id="그룹-채팅을-위한-메시지-테이블">그룹 채팅을 위한 메시지 테이블&lt;/h4>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
GroupMessage {
channel_id bigint
message_id bigint
message_to bigint
content text
created_at timestamp
}
&lt;/pre>
&lt;p>&lt;code>(channel_id, message_id)&lt;/code> 복합키를 기본 키로 사용한다.&lt;/p>
&lt;ul>
&lt;li>채널은 채팅 그룹과 같은 뜻&lt;/li>
&lt;li>그룹 채팅에 적용될 모든 질의는 특정 채널을 대상으로 하기 때문에 &lt;code>channel_id&lt;/code>는 파티션 키로 사용할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="메시지-id">메시지 ID&lt;/h4>
&lt;p>위에서 언급한 것 처럼 메시지 ID는 메시지들의 순서도 표현할 수 있어야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>messege_id&lt;/code>는 고유해야한다.&lt;/li>
&lt;li>ID는 정렬 가능해하하며, 시간 순서와 일치해야한다.
&lt;ul>
&lt;li>새로운 ID는 이전 ID 보다 큰 값이어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>RDMBS라면 &lt;code>auto_increment&lt;/code>가 대안이 될 수 있지만 NoSQL은 보통 해당 기능을 제공하지 않는다.&lt;/p>
&lt;ul>
&lt;li>스노 플레이크 같은 전역적 순서 번호 생성기를 이용한다.&lt;/li>
&lt;li>지역적 순서 번호 생성기를 이용한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>지역적 순서 번호 생성기(Local sequence number generator)&lt;/strong>
유일성은 같은 그룹 안에서만 보증하면 충분하다는 의미이다.&lt;/p>
&lt;ul>
&lt;li>채팅 서비스의 특징에 따라 메시지의 순서는 같은 채널, 혹은 1:1 채팅 세션 안에서만 유지되면 충분하다.&lt;/li>
&lt;li>전역적 ID 생성기에 비해 구현이 쉽다.&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>채팅 시스템의 &lt;strong>서비스 탐색&lt;/strong>(service discovery), 메시지 전달 흐름, 사용자 접속 상태 표시하는 법 정도가 세부적으로 살펴보기 적절하다.&lt;/p>
&lt;h3 id="서비스-탐색">서비스 탐색&lt;/h3>
&lt;p>서비스 탐색 기능의 주된 역할은 &lt;strong>클라이언트에게 가장 적합한 채팅 서버를 추천&lt;/strong>하는 것으로 아래의 기준을 활용하여 추천하게된다.&lt;/p>
&lt;ul>
&lt;li>클라이언트의 위치(Geographical location)&lt;/li>
&lt;li>서버의 용량 등&lt;/li>
&lt;/ul>
&lt;p>서비스 탐색 기능을 구현하는 데 널리 쓰이는 오픈 소스 솔루션으로 &lt;strong>아파치 주키퍼&lt;/strong>같은 것이 있다.&lt;/p>
&lt;ul>
&lt;li>사용 가능한 모든 채팅 서버를 등록시켜 두고, 클라이언트가 접속을 시도하면 사전에 정한 기준에 따라 최적의 채팅 서버를 골라준다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_8.png"
width="718"
height="698"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_8_hu68029a52e7e091c75ea09add17c7232a_109024_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_8_hu68029a52e7e091c75ea09add17c7232a_109024_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="주키퍼로 구현한 서비스 탐색 흐름"
class="gallery-image"
data-flex-grow="102"
data-flex-basis="246px"
>&lt;/p>
&lt;ol>
&lt;li>사용자 A가 시스템에 로그인 시도&lt;/li>
&lt;li>로드밸런서가 로그인 요청을 API 서버들 가운데 하나로 보냄&lt;/li>
&lt;li>API 서버가 사용자 인증을 처리하고 나면 서비스 탐색 기능이 동작하여 최적의 채팅 서버를 찾음&lt;/li>
&lt;li>찾은 서버와 웹소켓 연결&lt;/li>
&lt;/ol>
&lt;h3 id="메시지-흐름">메시지 흐름&lt;/h3>
&lt;p>채팅 시스템에 있어서 종단 간 메시지 흐름을 이해하는 것은 흥미로운 주제이다.&lt;/p>
&lt;p>1:1 채팅 메시지의 처리 흐름과 여러 단말 간 메시지 동기화 과정을 살펴본 후, 그룹 채팅 메시지의 처리 흐름을 살펴본다.&lt;/p>
&lt;h4 id="11-채팅-메시지-처리-흐름">1:1 채팅 메시지 처리 흐름&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_9.png"
width="675"
height="721"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_9_hu69fa1b06e4a527bf42d264a7bc16f467_126368_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_9_hu69fa1b06e4a527bf42d264a7bc16f467_126368_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="1:1 채팅 메시지 처리 흐름"
class="gallery-image"
data-flex-grow="93"
data-flex-basis="224px"
>&lt;/p>
&lt;ol>
&lt;li>사용자 A가 채팅 서버 1로 메시지 전송&lt;/li>
&lt;li>채팅 서버 1은 ID 생성기를 사용해 해당 메시지의 ID 결정&lt;/li>
&lt;li>채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송&lt;/li>
&lt;li>메시지가 키-값 저장소에 보관됨&lt;/li>
&lt;li>
&lt;ol>
&lt;li>사용자 B가 접속 중인 경우 메시지는 접속 중인 채팅 서버로 전송&lt;/li>
&lt;li>사용자가 B가 접속 중이 아닌 경우 푸시 알림 메시지를 푸시 알림 서버로 보냄&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>채팅 서버는 웹소켓 연결을 통해 메시지를 사용자 B에게 전송.&lt;/li>
&lt;/ol>
&lt;h4 id="여러-단말-사이의-메시지-동기화">여러 단말 사이의 메시지 동기화&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_10.png"
width="827"
height="601"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_10_hu237dc5988b99c0258bbc96b3a092c068_95136_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_10_hu237dc5988b99c0258bbc96b3a092c068_95136_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="메시지 동기화"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="330px"
>&lt;/p>
&lt;p>각 단말은 관측된 가장 최신 메시지의 ID를 추적하기 위한 &lt;code>cur_max_message_id&lt;/code> 라는 변수를 유지한다.&lt;/p>
&lt;ul>
&lt;li>수신자 ID가 현재 로그인한 사용자 ID와 같다.&lt;/li>
&lt;li>키-값 저장소에 보관된 메시지로서, 그 ID가 &lt;code>cur_max_message_id&lt;/code>보다 크다.&lt;/li>
&lt;/ul>
&lt;p>위 조건을 만족하는 메시지는 새 메시지로 간주된다.&lt;/p>
&lt;p>&lt;code>cur_max_message_id&lt;/code>는 단말마다 별도로 유지 관리하면 되는 값이라 키-값 저장소에서 새 메시지를 가져오는 동기화 작업도 쉽게 구현할 수 있다.&lt;/p>
&lt;h4 id="소규모-그룹-채팅에서의-메시지-흐름">소규모 그룹 채팅에서의 메시지 흐름&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_11.png"
width="747"
height="649"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_11_hu3912c41ccdd5c95c734f65d055df6d26_117861_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_11_hu3912c41ccdd5c95c734f65d055df6d26_117861_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="소규모 그룹 채팅 메시지 흐름"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="276px"
>&lt;/p>
&lt;p>1:1 채팅에 비해 조금 더 복잡하다.&lt;/p>
&lt;p>사용자 A가 그룹 채팅방에서 메시지를 보내면, 사용자 B, C의 &lt;strong>메시지 동기화 큐&lt;/strong>에 복사된다.&lt;/p>
&lt;p>이러한 설계는 소규모 그룹 채팅에 적합하다.&lt;/p>
&lt;ul>
&lt;li>새로운 메시지가 왔는지 확인하려면 자기 큐만 보면 되므로 메시지 동기화 플로가 단순하다.&lt;/li>
&lt;li>그룹이 크지 않으면 메시지를 수신자별로 복사해서 큐에 넣는 작업 비용이 문제되지 않는다.&lt;/li>
&lt;/ul>
&lt;p>많은 사용자를 지원해야 하는 경우라면 똑같은 메시지를 모든 사용자의 큐에 복사하는 게 바람직하지 않다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_12.png"
width="716"
height="620"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_12_hub1a8d58b86737e6dabf10d70f993bb1d_101204_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_12_hub1a8d58b86737e6dabf10d70f993bb1d_101204_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="수신자 관점 메시지 흐름"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="277px"
>&lt;/p>
&lt;p>위와 같은 흐름을 &lt;strong>메시지 수신자&lt;/strong> 관점에서 살펴보면, 한 수신자는 여러 사용자로부터 오는 메시지를 수신할 수 있어야 한다.&lt;/p>
&lt;h3 id="접속-상태-표시">접속 상태 표시&lt;/h3>
&lt;p>사용자 접속 상태를 표시하는 것은 상당수 채팅 애플리케이션의 핵심 기능이다.&lt;/p>
&lt;p>개략적 설계안의 &lt;strong>접속 상태 서버&lt;/strong>(presense server)를 통해 사용자의 상태를 관리하는데, 접속상태 서버는 클라이언트와 웹소켓으로 통신하는 실시간 서비스의 일부라는 점에 유의해야한다.&lt;/p>
&lt;p>&lt;strong>사용자 로그인&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_13.png"
width="766"
height="206"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_13_hub37db33c8b8c4205291185c196c0ce06_57084_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_13_hub37db33c8b8c4205291185c196c0ce06_57084_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="로그인"
class="gallery-image"
data-flex-grow="371"
data-flex-basis="892px"
>&lt;/p>
&lt;p>클라이언트와 실시간 서비스 사이에 웹소켓 연결이 맺어지고 나면 접속상태 서버는 A의 상태와 &lt;code>last_active_at&lt;/code> 타임스탬프 값을 키-값 저장소에 보관한다.&lt;/p>
&lt;p>이 절차가 끝나면 해당 사용자는 접속 중인 것으로 표시될 것이다.&lt;/p>
&lt;p>&lt;strong>로그아웃&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_14.png"
width="830"
height="167"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_14_huc82ec414ab58d2aa81718a978ef2720f_65884_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_14_huc82ec414ab58d2aa81718a978ef2720f_65884_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="로그아웃"
class="gallery-image"
data-flex-grow="497"
data-flex-basis="1192px"
>&lt;/p>
&lt;p>키-값 저장소에 보관된 사용자 상태가 &lt;code>online&lt;/code>에서 &lt;code>offline&lt;/code>으로 바뀐다.&lt;/p>
&lt;p>&lt;strong>접속 장애&lt;/strong>&lt;/p>
&lt;p>인터넷 연결이 끊어지는 상황에 대응할 수 있는 설계를 준비해야한다.&lt;/p>
&lt;p>사용자의 인터넷 연결이 끊어지면 클라이언트와 서버 사이에 맺어진 웹소켓 같은 지속성 연결도 끊어진다.&lt;/p>
&lt;p>이러한 경우 &lt;strong>사용자를 오프라인 상태로 표시하고 연결이 복구되면 온라인 상태로 변경&lt;/strong>하는 방법을 고려할 수 있지만, 짧은 시간 동안 인터넷 연결이 끊어졌다 복귀되는 현상이 흔하기 때문에 적절하지 않다.&lt;/p>
&lt;ul>
&lt;li>이런 현상마다 사용자의 접속 상태를 변경하는 것은 지나치며, 사용자 경험 측면에서도 바람직하지 않다.&lt;/li>
&lt;/ul>
&lt;p>이에 따라 &lt;strong>박동(heartbeat) 검사&lt;/strong>를 통해 이 문제를 해결한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_15.png"
width="753"
height="620"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_15_hu870405f6db98088b77813163c0a21c89_78387_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_15_hu870405f6db98088b77813163c0a21c89_78387_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="박동 검사"
class="gallery-image"
data-flex-grow="121"
data-flex-basis="291px"
>&lt;/p>
&lt;ol>
&lt;li>온라인 상태의 클라이언트로 하여금 주기적으로 박동 이벤트를 접속상태 서버로 보낸다.&lt;/li>
&lt;li>마지막 이벤트를 받은 지 x초 이내에 또 다른 박동 이벤트 메시지를 받으면 해당 사용자의 접속 상태를 계속 온라인으로 유지한다.&lt;/li>
&lt;/ol>
&lt;h3 id="상태-정보의-전송">상태 정보의 전송&lt;/h3>
&lt;p>상태정보 서버는 각각의 친구관게마다 채널을 하나씩 두는 발행-구독 모델을 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_16.png"
width="844"
height="399"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_16_huda3d97a35351d5c19e5533f1c287c481_139268_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_16_huda3d97a35351d5c19e5533f1c287c481_139268_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="상태 정보 전송"
class="gallery-image"
data-flex-grow="211"
data-flex-basis="507px"
>&lt;/p>
&lt;p>이러한 구조를 통해 친구 관계에 있는 사용자가 상태정보 변화를 쉽게 통지 받을 수 있게 된다(웹소켓 사용).&lt;/p>
&lt;p>이러한 방안은 그룹의 크기가 커지면 비용이나 시간이 많이 들게되므로 좋지 않다.&lt;/p>
&lt;ul>
&lt;li>그룹 하나의 100,000명이 있다면, 상태변화 1건당 100,000개의 이벤트 메시지가 발생한다.&lt;/li>
&lt;/ul>
&lt;p>이런 성능 문제를 해소하는 방법은&lt;/p>
&lt;ul>
&lt;li>사용자가 그룹 채팅에 입장하는 순간에만 상태 정보를 읽어가게 만든다.&lt;/li>
&lt;li>친구 리스트에 있는 사용자의 접속상태를 갱신하고 싶으면 수동으로 하도록 유도한다.&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>1:1 채팅과 그룹 채팅을 전부 지원하는 채팅 시스템의 아키텍처를 살펴보았다.&lt;/p>
&lt;ul>
&lt;li>클라이언트와 서버 사이의 통신을 가능하도록 하기 위해 웹소켓을 사용했다.&lt;/li>
&lt;li>주요 컴포넌트
&lt;ul>
&lt;li>실시간 메시징을 지원하는 채팅 서버&lt;/li>
&lt;li>접속 상태 서버&lt;/li>
&lt;li>푸시 알림 서버&lt;/li>
&lt;li>채팅 이력을 보관할 키-값 저장소&lt;/li>
&lt;li>이를 제외한 나머지 기을을 구현하는 데 쓰을 API 서버 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>시간이 남는다면 다음과 같은 내용을 논의해도 좋다.&lt;/p>
&lt;ul>
&lt;li>사진이나 비디오 등의 미디어를 지원하도록 하는 방법
&lt;ul>
&lt;li>압축 방식, 클라우드 저장소, 섬네일 생성 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>종단 간 암호화&lt;/li>
&lt;li>캐시
&lt;ul>
&lt;li>이미 읽은 메시지를 캐시해 두면 서버와 주고받는 데이터 양을 줄일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>로딩 속도 개선
&lt;ul>
&lt;li>슬랙은 사용자의 데이터, 채널 등을 지역적으로 분산하는 네트워크를 구축하여 앱 로딩 속도를 개선하였다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오류 처리
&lt;ul>
&lt;li>채팅 서버 오류
&lt;ul>
&lt;li>서버 하나가 죽으면 서비스 탐색 기능이 동작하여 클라이언트에게 새로운 서버를 배정하고 다시 접속할 수 있도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 재전송
&lt;ul>
&lt;li>재시도나 큐는 메시지의 안정적 전송을 보장하기 위해 흔히 사용되는 기법이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>11. 뉴스 피드 시스템 설계</title><link>https://codemario318.github.io/post/system-design-interview/11/</link><pubDate>Thu, 04 Jul 2024 22:51:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/11/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/11/cover.png" alt="Featured image of post 11. 뉴스 피드 시스템 설계" />&lt;h2 id="뉴스-피드란">뉴스 피드란?&lt;/h2>
&lt;p>페이스북의 도움말 페이지에서는 아래와 같이 뉴스 피드를 설명하고 있다.&lt;/p>
&lt;blockquote>
&lt;p>홈 페이지 중앙에 지속적으로 업데이트되는 스토리와 사용자 상태 정보 업데이트, 사진, 비디오, 링크, 앱 활동 팔로우하는 사람들, 페이지, 그룹으로부터 나오는 좋아요 등을 포함한다.&lt;/p>
&lt;/blockquote>
&lt;p>뉴스 피드 시스템 설계는 아주 유명한 면접 문제이다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;ul>
&lt;li>Q. 모바일 앱, 웹 어떤걸 지원해야하는가?
&lt;ul>
&lt;li>A. 둘다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 주요 기능은?
&lt;ul>
&lt;li>A. 사용자는 뉴스 피드 페이지에 새로운 스토리를 올릴 수 있어야함
&lt;ul>
&lt;li>친구들이 올리는 스토리를 볼 수도 있어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 어떤 순서로 스토리가 표시되는가? 최신 포스트? 토픽 점수 기반?
&lt;ul>
&lt;li>A. 시간 흐름 역순으로 표시(Reverse chronological order)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 한 명의 사용자는 최대 몇 명의 친구를 가질 수 있는가?
&lt;ul>
&lt;li>A. 5,000명&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 트래픽 규모는?
&lt;ul>
&lt;li>A. 매일 천만 명 방문한다고 가정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 피드에 이미지나 비디오 스토리도 올라올 수 있는가?
&lt;ul>
&lt;li>A. 이미지나 비디오 등 미디어 파일이 포함될 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="개략적-설계안-제시-및-동의-구하기">개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>뉴스 피드 시스템 설계는 &lt;strong>피드 발행&lt;/strong>(Feed publishing)과 &lt;strong>뉴스 피드 생성&lt;/strong>(News feed building) 두 가지 구분으로 나눌 수 있다.&lt;/p>
&lt;ul>
&lt;li>피드 발행
&lt;ul>
&lt;li>사용자가 스토리를 포스팅하면 해당 데이터를 캐시와 데이터베이스에 기록한다.&lt;/li>
&lt;li>새 포스팅은 친구의 뉴스 피드에도 전송된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>뉴스 피드 생성
&lt;ul>
&lt;li>뉴스 피드는 모든 친구의 포스팅을 시간 흐름 역순으로 모아서 만든다고 가정한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="뉴스-피드-api">뉴스 피드 API&lt;/h3>
&lt;p>뉴스 피드 API는 HTTP 프로토콜 기반으로 클라이언트가 서버와 통신하기 위해 사용하는 수단이다.&lt;/p>
&lt;ul>
&lt;li>상태 정보를 업데이트 할 때&lt;/li>
&lt;li>뉴스 피드를 가져올 때&lt;/li>
&lt;li>친구를 추가하는 등 다양한 작업 수행&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>피드 발행 API&lt;/strong>&lt;/p>
&lt;p>새 스토리를 포스팅하기 위한 API다.&lt;/p>
&lt;p>HTTP POST 형태로 요청을 보낸다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">POST /v1/me/feed
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>인자
&lt;ul>
&lt;li>body: 포스트 내용&lt;/li>
&lt;li>Authorization 헤더: API 호출을 인증하기 위해 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>피드 읽기 API&lt;/strong>&lt;/p>
&lt;p>뉴스 피드를 가져오는 API다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GET /v1/me/feed
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>인자
&lt;ul>
&lt;li>Authorization 헤더: API 호출을 인증하기 위해 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="피드-발행">피드 발행&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/11/img.png"
width="537"
height="818"
srcset="https://codemario318.github.io/post/system-design-interview/11/img_hu891d2a45b04e66955eabc83b2e6d7650_139382_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/11/img_hu891d2a45b04e66955eabc83b2e6d7650_139382_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="피드 발행 구조"
class="gallery-image"
data-flex-grow="65"
data-flex-basis="157px"
>&lt;/p>
&lt;ul>
&lt;li>사용자
&lt;ul>
&lt;li>모바일 앱이나 브라우저에서 새 포스팅을 올리는 주체&lt;/li>
&lt;li>&lt;code>POST /v1/me/feed&lt;/code> API를 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>로드밸런서(load balancer)
&lt;ul>
&lt;li>트래픽을 웹 서버들로 분산&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 서버
&lt;ul>
&lt;li>HTTP 요청을 내부 서비스로 중계하는 역할을 담당&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>포스팅 저장 서비스(Post service)
&lt;ul>
&lt;li>새 포스팅을 데이터베이스와 캐시에 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>포스팅 전송 서비스(Fanout service)
&lt;ul>
&lt;li>새 포스팅을 친구의 뉴스피드에 푸시(push)&lt;/li>
&lt;li>뉴스 피드 데이터는 캐시에 보관하여 빠르게 읽어갈 수 있도록 해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 서비스(notification service)
&lt;ul>
&lt;li>친구들에게 새 포스팅이 올라왔음을 알림&lt;/li>
&lt;li>푸시 알림을 보냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="뉴스-피드-생성">뉴스 피드 생성&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/11/img_1.png"
width="425"
height="634"
srcset="https://codemario318.github.io/post/system-design-interview/11/img_1_hu69fcfbc2dbdf50bdcc685e78596b2bbb_88291_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/11/img_1_hu69fcfbc2dbdf50bdcc685e78596b2bbb_88291_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="뉴스 피드 생성 구조"
class="gallery-image"
data-flex-grow="67"
data-flex-basis="160px"
>&lt;/p>
&lt;ul>
&lt;li>사용자
&lt;ul>
&lt;li>뉴스 피드를 읽는 주체&lt;/li>
&lt;li>&lt;code>GET /v1/me/feed&lt;/code>를 이용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>로드 밸런서
&lt;ul>
&lt;li>트래픽을 웹 서버들로 분산&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 서버
&lt;ul>
&lt;li>트래픽을 뉴스 피드 서비스로 보냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>뉴스 피드 서비스(news feed service)
&lt;ul>
&lt;li>캐시에서 뉴스 피드를 가져오는 서비스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>뉴스 피드 캐시(news feed cache)
&lt;ul>
&lt;li>랜더링할 때 필요한 피드ID를 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="피드-발행-흐름-상세-설계">피드 발행 흐름 상세 설계&lt;/h3>
&lt;p>웹 서버와 포스팅 전송 서비스에 초점을 두고 확인한다.&lt;/p>
&lt;p>&lt;strong>웹 서버&lt;/strong>&lt;/p>
&lt;p>클라이언트와 통신할 뿐 아니라 인증이나 처리율 제한 기능도 수행한다.&lt;/p>
&lt;ul>
&lt;li>올바른 인증 토큰을 Authorization 헤더에 넣고 API를 호출하는 사용자만 포스팅 할 수 있어야 한다.&lt;/li>
&lt;li>스팸을 막고 유해한 콘텐츠가 자주 올라오는 것을 방지하기 위해 사용자가 올리 수 있는 포스팅 수를 제한을 둬야한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>포스팅 전송(팬아웃) 서비스&lt;/strong>&lt;/p>
&lt;p>포스팅 전송, 즉 팬아웃(fanout)은 어떤 사용자의 새 포스팅을 그 사용자와 친구 관계에 있는 모든 사용자에게 전달하는 과정이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/11/img_2.png"
width="863"
height="952"
srcset="https://codemario318.github.io/post/system-design-interview/11/img_2_huda53be8af4aa5fdd5c6f7a22043667e4_267454_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/11/img_2_huda53be8af4aa5fdd5c6f7a22043667e4_267454_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="포스팅 전송 서비스"
class="gallery-image"
data-flex-grow="90"
data-flex-basis="217px"
>&lt;/p>
&lt;p>두 가지 유형이 존재하며 각기 장단점을 가진다.&lt;/p>
&lt;p>&lt;strong>푸시 모델(push model)&lt;/strong>&lt;/p>
&lt;p>새로운 포스팅을 기록하는 시점(쓰기 시점)에 뉴스피드를 갱신하게 된다.&lt;/p>
&lt;p>다시 말해, 포스팅이 완료되면 바로 해당 사용자의 캐시에 해당 포스팅을 기록한다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>뉴스피드가 실시간으로 갱신되며 친구 목록에 있는 사용자에게 &lt;strong>즉시 전송&lt;/strong>&lt;/li>
&lt;li>새 포스팅이 기록되는 순간에 뉴스 피드가 이미 갱신되므로(pre-computed) 뉴스 피드를 읽는 데 드는 시간이 짧아짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>친구가 많은 사용자의 경우 뉴스 피드를 갱신하는 데 많은 시간이 소요될 수도 있음
&lt;ul>
&lt;li>핫키(Hotkey) 문제&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서비스를 자주 이용하지 않는 사용자의 피드까지 갱신해야 하므로 자원 낭비&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>풀 모델(pull model)&lt;/strong>&lt;/p>
&lt;p>피드를 읽어야 하는 시점에 뉴스 피드를 갱신한다.&lt;/p>
&lt;p>따라서 &lt;strong>요청 기반&lt;/strong>(on-demand) 모델이며, 사용자가 본인 홈페이지나 타임 라인을 로딩하는 시점에 새로운 포스트를 가져오게 된다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>로그인하기까지는 어떤 컴퓨팅 자원도 소모하지 않으므로 비활성화된 사용자는 이 모델이 유리하다.&lt;/li>
&lt;li>데이터를 친구 각각에 푸시하는 작업이 필요 없으므로 핫키 문제도 생기지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>뉴스 피드를 읽는 데 많은 시간이 소요될 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이번 설계안은 두 가지 방법을 결합하여 장점은 취하고 단점은 버린다.&lt;/p>
&lt;ul>
&lt;li>뉴스피드를 빠르게 가져올 수 있도록 하는 것은 아주 중요하므로 대부분의 사용자에 대해서 푸시 모델 사용&lt;/li>
&lt;li>친구, 팔로워가 아주 많은 사용자의 경우는 해당 사용자의 포스팅을 필요할 때 가져가도록 하는 풀 모델을 사용&lt;/li>
&lt;li>안정 해시(consistent hashing)을 통해 요청과 데이터를 고르게 분산하여 핫 키 문제를 완화&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/11/img_3.png"
width="643"
height="597"
srcset="https://codemario318.github.io/post/system-design-interview/11/img_3_hua09b20c3092217fe155cb7d5889b4e53_145261_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/11/img_3_hua09b20c3092217fe155cb7d5889b4e53_145261_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="107"
data-flex-basis="258px"
>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>그래프 데이터베이스&lt;/strong>에서 친구 ID 목록을 가져온다.
&lt;ul>
&lt;li>그래프 데이터베이스는 친구 관계나 친구 추천을 관리하기 적합하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자 정보 캐시에서 친구들의 정보를 가져온후, 설정에 따라 일부 걸러낸다.
&lt;ul>
&lt;li>차단 등 이유로&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>친구 목록과 새 스토리의 포스팅 ID를 메시키 큐에 넣는다.&lt;/li>
&lt;li>팬아웃 작업 서버가 메시지 큐에서 데이터를 꺼내 뉴스 피드 데이터를 뉴스 피드 캐시에 넣는다.
&lt;ul>
&lt;li>뉴스 피드 캐시: &lt;code>&amp;lt;포스팅 ID, 사용자 ID&amp;gt;&lt;/code>&lt;/li>
&lt;li>모든 데이터를 포함하면 메모리 요구량이 지나치게 늘어날 수 있다.&lt;/li>
&lt;li>어떤 사용자가 뉴스 피드에 올라온 수천 개의 스토리를 볼 확률은 지극히 낮다.(캐시 미스 확률이 낮다.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="피드-읽기-흐름-상세-설계">피드 읽기 흐름 상세 설계&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/11/img_4.png"
width="724"
height="728"
srcset="https://codemario318.github.io/post/system-design-interview/11/img_4_hufb1b28fc20f324cce39c94a4369c34ac_210247_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/11/img_4_hufb1b28fc20f324cce39c94a4369c34ac_210247_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="피드 읽기 흐름"
class="gallery-image"
data-flex-grow="99"
data-flex-basis="238px"
>&lt;/p>
&lt;p>이미지나 비디오와 같은 미디어 콘텐츠는 CDN에 저장하여 빨리 읽어갈 수 있도록 한다.&lt;/p>
&lt;ol>
&lt;li>사용자가 뉴스 피드 읽기 요청을 보냄&lt;/li>
&lt;li>로드밸런서가 요청을 웹 서버 가운데 하나로 보냄&lt;/li>
&lt;li>피드를 가져오기 위해 뉴스 피드 서비스 호출&lt;/li>
&lt;li>뉴스 피드 캐시에서 포스팅 ID 목록을 조회&lt;/li>
&lt;li>사용자 이름, 사용자 사진 등을 사용자 캐시와 포스팅 캐시에서 가져와 완전한 뉴스 피드 생성&lt;/li>
&lt;li>JSON 형태로 응답&lt;/li>
&lt;/ol>
&lt;h3 id="캐시-구조">캐시 구조&lt;/h3>
&lt;p>캐시는 &lt;strong>뉴스 피드 시스템의 핵심 컴포넌트&lt;/strong>이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/11/img_5.png"
width="831"
height="461"
srcset="https://codemario318.github.io/post/system-design-interview/11/img_5_hu7a050117f609eaff8b50eedec13da585_109520_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/11/img_5_hu7a050117f609eaff8b50eedec13da585_109520_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="5계층 캐시 구조"
class="gallery-image"
data-flex-grow="180"
data-flex-basis="432px"
>&lt;/p>
&lt;ul>
&lt;li>뉴스피드
&lt;ul>
&lt;li>뉴스 피드의 ID 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>콘텐츠
&lt;ul>
&lt;li>포스팅 데이터를 보관&lt;/li>
&lt;li>인기 콘텐츠는 따로 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>소셜 그래프
&lt;ul>
&lt;li>사용자 간 관계 정보를 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>행동(action)
&lt;ul>
&lt;li>포스팅에 대한 사용자의 행위에 관한 정보를 보관&lt;/li>
&lt;li>좋아요, 답글 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>횟수(counter)
&lt;ul>
&lt;li>좋아요 횟수, 응답 수, 팔로워 수, 팔로잉 수 등 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>이번 설계안은 &lt;strong>뉴스 피드 발행&lt;/strong>, &lt;strong>뉴스 피드 생성&lt;/strong> 두 부분으로 구성되어 있다.&lt;/p>
&lt;p>설계를 진행하고 기술을 선택할 때는 그 배경에 어떤 타협적 결정들이 있었는지 잘 이해하고 설명할 수 있어야 한다.&lt;/p>
&lt;p>시간이 남는다면 &lt;strong>규모 확장성 이슈&lt;/strong>를 논의하는 것이 좋을 수 있다.&lt;/p>
&lt;h3 id="데이터베이스-규모-확장">데이터베이스 규모 확장&lt;/h3>
&lt;ul>
&lt;li>수직적 규모 확장 vs 수평적 규모 확장&lt;/li>
&lt;li>SQL vs NoSQL&lt;/li>
&lt;li>master-slave 다중화&lt;/li>
&lt;li>복제본(replica)에 대한 읽기 연산&lt;/li>
&lt;li>일관성 모델(consistency model)&lt;/li>
&lt;li>데이터베이스 샤딩&lt;/li>
&lt;/ul>
&lt;h3 id="그-외">그 외&lt;/h3>
&lt;ul>
&lt;li>웹 계층을 무상태로 운영하기&lt;/li>
&lt;li>가능한 한 많은 데이터를 캐시할 방법&lt;/li>
&lt;li>여러 데이터 센터를 지원할 방법&lt;/li>
&lt;li>메시지 큐를 사용하여 컴포넌트 사이의 결합도 낮추기&lt;/li>
&lt;li>핵심 메트릭에 대한 모니터링
&lt;ul>
&lt;li>트래픽이 몰리는 시간대의 QPS&lt;/li>
&lt;li>사용자가 뉴스 피드를 새로고침 할 때 지연 시간 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>10. 알람 시스템 설계</title><link>https://codemario318.github.io/post/system-design-interview/10/</link><pubDate>Thu, 27 Jun 2024 21:43:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/10/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/cover.png" alt="Featured image of post 10. 알람 시스템 설계" />&lt;p>알림 시스템은 최근 많은 프로그램들이 채택한 인기 있는 기능이다.&lt;/p>
&lt;p>고객에게 중요할 만한 정보를 &lt;strong>비동기적&lt;/strong>으로 제공한다.&lt;/p>
&lt;ul>
&lt;li>모마일 푸시 알림&lt;/li>
&lt;li>SMS 메시지&lt;/li>
&lt;li>이메일&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>하루에 백만 건 이상의 알림을 처리하는 확장성 높은 시스템을 구축하는건 쉬운 과제가 아니다.&lt;/p>
&lt;p>알림 시스템이 어떻게 구현되는지에 대한 깊은 이해가 필요하다.&lt;/p>
&lt;ul>
&lt;li>Q. 어떤 종류의 알림을 지원해야하는가?
&lt;ul>
&lt;li>A. 푸시 알림, SMS 메시지, 이메일&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 실시간 시스템?
&lt;ul>
&lt;li>A. 연성 실시간 시스템 &amp;gt; 빨리 전달해야하지만 시스템의 부하가 심할 때 약간의 지연은 무방함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 지원 단말?
&lt;ul>
&lt;li>A. IOS, 안드로이드, 랩톱/데스크톱&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 알림은 누가 만들 수 있는가?
&lt;ul>
&lt;li>A. 클라이언트 애플리케이션, 서버측 스케쥴링&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 알림 거부 가능?
&lt;ul>
&lt;li>A. 예&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 하루 몇 건의 알림 처리?
&lt;ul>
&lt;li>A. 천만 건 푸시 알림, 백만 건 SMS, 5백만 건 이메일&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="알림-유형-별-지원-방안">알림 유형 별 지원 방안&lt;/h3>
&lt;p>유형에 따라 동작하는 알림 메커니즘에 차이가 있다.&lt;/p>
&lt;p>&lt;strong>IOS 푸시 알림&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img.png"
width="575"
height="126"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_hu740000bab3f30bdd0a1a67ae3b5eabd1_20508_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_hu740000bab3f30bdd0a1a67ae3b5eabd1_20508_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="ios 푸시 알림 컴포넌트"
class="gallery-image"
data-flex-grow="456"
data-flex-basis="1095px"
>&lt;/p>
&lt;p>IOS에서 푸시 알림을 보내기 위해서는 3가지 컴포넌트가 필요하다.&lt;/p>
&lt;ul>
&lt;li>일림 제공자(provider)
&lt;ul>
&lt;li>알림 요청을 만들어 &lt;strong>애플 푸시 알림 서비스&lt;/strong>(APNS)로 보내는 주체로 두개의 정보가 필요하다.&lt;/li>
&lt;li>&lt;strong>단말 토큰&lt;/strong>: 알림 요청을 보내는 데 필요한 고유 식별자&lt;/li>
&lt;li>&lt;strong>페이로드&lt;/strong>: 알림 내용을 담은 JSON 딕셔너리&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;aps&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;alert&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;title&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Game Request&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;body&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Bob wants to play chess&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;action-loc-key&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;PLAY&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;badge&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>APNS
&lt;ul>
&lt;li>애플이 제공하는 원격 서비스&lt;/li>
&lt;li>푸시 알림을 IOS 장치로 보내는 역할을 담당.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>IOS 단말
&lt;ul>
&lt;li>푸시 알림을 수신하는 사용자의 단말&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>안드로이드 푸시 알림&lt;/strong>&lt;/p>
&lt;p>APNS를 사용하는 IOS와 달리 FCM(Firebase Cloud Messaging)을 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_1.png"
width="634"
height="142"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_1_hu230abd40214ac2cc9d4d6ae33273b666_22808_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_1_hu230abd40214ac2cc9d4d6ae33273b666_22808_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="AOS 푸시 알림 컴포넌트"
class="gallery-image"
data-flex-grow="446"
data-flex-basis="1071px"
>&lt;/p>
&lt;p>&lt;strong>SMS 메시지&lt;/strong>&lt;/p>
&lt;p>트윌리오(Twilio), 넥스모(Nexmo)같은 제3 사업자의 서비스를 많이 이용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_2.png"
width="645"
height="166"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_2_hua9b34508436b686eb916dc3bc2dce64b_27617_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_2_hua9b34508436b686eb916dc3bc2dce64b_27617_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="SMS 메시지 컴포넌트"
class="gallery-image"
data-flex-grow="388"
data-flex-basis="932px"
>&lt;/p>
&lt;p>&lt;strong>이메일&lt;/strong>&lt;/p>
&lt;p>대부분 고유 이메일 서버를 구축할 역량을 가지고 있지만, 상용 이메일 서비스를 이용한다.&lt;/p>
&lt;ul>
&lt;li>센드그리드, 메일침프&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_3.png"
width="635"
height="137"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_3_hu87f4edfcf86cd64dbb4cab74e62a2243_26432_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_3_hu87f4edfcf86cd64dbb4cab74e62a2243_26432_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이메일 컴포넌트"
class="gallery-image"
data-flex-grow="463"
data-flex-basis="1112px"
>&lt;/p>
&lt;hr>
&lt;p>지금까지의 언급한 모든 알림 유형을 한 시스템으로 묶어면 아래와 같다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_4.png"
width="405"
height="767"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_4_hu994f53c88cb3013bc3a97423d78ab8b7_76258_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_4_hu994f53c88cb3013bc3a97423d78ab8b7_76258_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="최종"
class="gallery-image"
data-flex-grow="52"
data-flex-basis="126px"
>&lt;/p>
&lt;h3 id="연락처-정보-수집-절차">연락처 정보 수집 절차&lt;/h3>
&lt;p>알림을 보내기 위해 &lt;strong>모바일 단말 토큰&lt;/strong>, &lt;strong>전화번호&lt;/strong>, &lt;strong>이메일 주소&lt;/strong> 등 정보가 필요하다.&lt;/p>
&lt;p>사용자가 앱을 설치하거나 처음으로 계정을 등록할 때 API 서버는 해당 사용자의 정보를 수집하여 데이터베이스에 저장한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_5.png"
width="834"
height="202"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_5_huad049bab1460305989d0ac3f2e4bbf4b_85105_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_5_huad049bab1460305989d0ac3f2e4bbf4b_85105_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="연락처 정보 수집 절차"
class="gallery-image"
data-flex-grow="412"
data-flex-basis="990px"
>&lt;/p>
&lt;p>필수적인 정보만 포함한 스키마는 아래와 같다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
USER {
bigint user_id
varchar email
integer coutry_code
integer phone_number
timestamp created_at
}
DEVICE {
bigint id
varchar device_token
bigint user_id
timestamp last_logged_in_at
}
&lt;/pre>
&lt;ul>
&lt;li>이메일 주소와 전화번호는 &lt;code>USER&lt;/code> 테이블에 저장하고, 단말 토큰은 &lt;code>DEVICE&lt;/code> 테이블에 저장한다.&lt;/li>
&lt;li>한 사용자가 여러 단말을 가질 수 있다.&lt;/li>
&lt;li>알림은 모든 단말에 전송되어야 한다.&lt;/li>
&lt;/ul>
&lt;h3 id="알림-전송-및-수신-절차">알림 전송 및 수신 절차&lt;/h3>
&lt;p>개략적으로 설계하고 점차적으로 최적화한다.&lt;/p>
&lt;p>&lt;strong>개략적 설계안(초안)&lt;/strong>&lt;/p>
&lt;p>서버를 1대만 사용하는 시스템이라 가정한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_6.png"
width="836"
height="624"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_6_hu79685c192455f85017d1b07942a95c3d_90148_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_6_hu79685c192455f85017d1b07942a95c3d_90148_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안(초안)"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="321px"
>&lt;/p>
&lt;ul>
&lt;li>Service 1 ~ N
&lt;ul>
&lt;li>마이크로서비스, 크론잡, 분산 시스템 컴포넌트 일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 시스템
&lt;ul>
&lt;li>알림 전송/수신 처리의 핵심&lt;/li>
&lt;li>Service 1 ~ N에 알림 전송을 위한 *&lt;em>API 제공&lt;/em>&lt;/li>
&lt;li>제3자 서비스에 전달할 &lt;strong>알림 페이로드 생성&lt;/strong>&lt;/li>
&lt;li>확장성을 유의해야함, 쉽게 새로운 서비스를 통합하거나 기존 서비스를 제거할 수 있어야함&lt;/li>
&lt;li>어떤 서비스는 다른 시장에서는 사용할 수 없을 수도 있다. (FCM은 중국서 사용불가)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단말&lt;/li>
&lt;/ul>
&lt;p>위와 같은 설계에는 몇 가지 문제가 있다.&lt;/p>
&lt;ul>
&lt;li>SPOF
&lt;ul>
&lt;li>알림 서비스에 서버가 하나 뿐이라 서버 장애 발생시 전체 서비스 장애로 이어진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규모 확장성
&lt;ul>
&lt;li>한 대 서비스로 푸시 알림에 관계된 모든 것을 처리하므로, 데이터베이스나 캐시 등 중요 컴포넌트의 규모를 개별적으로 늘릴 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>성능 병목
&lt;ul>
&lt;li>알림을 처리하고 보내는 것은 자원을 많이 필요로할 수 있어, 트래픽이 몰리면 과부하 상태에 빠질 수 있다.
&lt;ul>
&lt;li>HTML 페이지 생성&lt;/li>
&lt;li>제3자 서비스의 응답 대기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>개략적 설계안(개선)&lt;/strong>&lt;/p>
&lt;p>최초 개략적 설계안에서 다음과 같은 문제를 개선했다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>데이터베이스&lt;/strong>와 &lt;strong>캐시&lt;/strong>를 알림 시스템에서 분리&lt;/li>
&lt;li>&lt;strong>알림 서버 증설&lt;/strong> 및 &lt;strong>자동 수평 규모 확장&lt;/strong> 추가&lt;/li>
&lt;li>&lt;strong>메시지 큐&lt;/strong>를 이용해 시스템 컴포넌트 사이의 강한 결합을 끊는다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_7.png"
width="788"
height="495"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_7_huc5bb10796dc5d83e13d2174837213014_204960_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_7_huc5bb10796dc5d83e13d2174837213014_204960_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안(개선)"
class="gallery-image"
data-flex-grow="159"
data-flex-basis="382px"
>&lt;/p>
&lt;ul>
&lt;li>서비스(1~N)
&lt;ul>
&lt;li>알림 시스템 서버의 API를 통해 알림을 보낼 서비스들&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 서버
&lt;ul>
&lt;li>알림 전송 API
&lt;ul>
&lt;li>스팸 방지를 위해 사내 서비스 또는 인증된 클라이언트만 이용 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 검증
&lt;ul>
&lt;li>이메일, 전화번호 등 기본적 검증 수행&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터베이스 또는 캐시 질의
&lt;ul>
&lt;li>알림에 포함시킬 데이터를 가져온다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 전송
&lt;ul>
&lt;li>알림 데이터를 메시지 큐에 넣는다.&lt;/li>
&lt;li>하나 이상의 메시지 큐를 이용하면 병렬적으로 처리할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>캐시
&lt;ul>
&lt;li>사용자 정보, 단말 정보, 알림 템플릿 등을 캐시한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DB
&lt;ul>
&lt;li>사용자, 알림, 설정 등 다양한 정보 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 큐
&lt;ul>
&lt;li>시스템 컴포넌트 간 의존성을 제거한다.&lt;/li>
&lt;li>다량의 알림이 전송되어야 하는 경우 버퍼 역할도 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작업 서버
&lt;ul>
&lt;li>메시지 큐에서 전송할 알림을 꺼내 제3자 서비스로 전달한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="안정성">안정성&lt;/h3>
&lt;p>분산 환경에서 운영될 알림 시스템을 설계할 때는 안정성을 확보하기 위한 사앙 몇 가지를 반드시 고려해야한다.&lt;/p>
&lt;p>&lt;strong>데이터 손실 방지&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_8.png"
width="544"
height="319"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_8_hucbd178a7d97384a0a3abf8183f284e96_66785_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_8_hucbd178a7d97384a0a3abf8183f284e96_66785_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 손실 방지"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="409px"
>&lt;/p>
&lt;p>알림 전송 시스템의 가장 중요한 요구사항 가운데 하나는 &lt;strong>어떤 상황에서도 알림이 소실되면 안된다&lt;/strong>는 것이다.&lt;/p>
&lt;ul>
&lt;li>지연되거나 순서가 달라도 사라지면 안된다&lt;/li>
&lt;/ul>
&lt;p>이를 위해 알림 데이터를 데이터베이스에 보관하고 재시도하는 메커니즘을 구현해야 한다.&lt;/p>
&lt;p>&lt;strong>알림 중복 전송 방지&lt;/strong>&lt;/p>
&lt;p>같은 알림이 여러 번 반복되는 것을 완전히 막는 것은 불가능하다.&lt;/p>
&lt;p>그 빈도를 줄이기 위해 중복을 탐지하는 매커니즘을 도입하고, 오류를 신중하게 처리해아한다.&lt;/p>
&lt;ul>
&lt;li>보내야 할 알림이 도착하면 그 이벤트 ID를 검사하여 이전에 본 적이 있는 이벤트인지 살핀다.&lt;/li>
&lt;li>중복된 이벤트면 버리고, 그렇지 않으면 알림을 발송한다.&lt;/li>
&lt;/ul>
&lt;h3 id="추가로-필요한-컴포넌트-및-고려사항">추가로 필요한 컴포넌트 및 고려사항&lt;/h3>
&lt;p>&lt;strong>알림 템플릿&lt;/strong>&lt;/p>
&lt;p>알림 메시지 대부분은 형식이 비슷하다.&lt;/p>
&lt;p>알림 템플릿은 이런 유사성을 고려하여, 알림 메시지의 모든 부분을 처음부터 다시 만들 필요 없도록 한다.&lt;/p>
&lt;ul>
&lt;li>사전에 지정한 형식에 맞춰 알람을 만들어 내는 틀이다.&lt;/li>
&lt;li>전송될 알림들의 형식을 일관성 있게 유지할 수 있다.&lt;/li>
&lt;li>오류 가능성뿐 아니라 알림 작성에 드는 시간도 줄일 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>알림 설정&lt;/strong>&lt;/p>
&lt;p>사용자가 알림 설정을 상세히 조정할 수 있도록 한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
OPT {
bigint user_id
varchar channel
boolean opt_in
}
&lt;/pre>
&lt;p>이와 같은 설정을 도입했다면 알람을 보내기 전 반드시 해당 사용자가 알림을 켜 두었는지 확인해야한다.&lt;/p>
&lt;p>&lt;strong>전송률 제한&lt;/strong>&lt;/p>
&lt;p>한 사용자가 받을 수 있는 알림의 빈도를 제한하여 사용자에게 많은 알림을 보내지 않도록 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>알림을 너무 많이 보내기 시작하면 사용자가 알림 기능을 꺼버릴 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>재시도 방법&lt;/strong>&lt;/p>
&lt;p>써드 파티 서비스가 알림 전송에 실패하면, 해당 알림을 재시도 전용 큐에 넣고 같은 문제가 계속해서 발생하면 개발자에게 통지한다.&lt;/p>
&lt;p>&lt;strong>푸시 알림과 보안&lt;/strong>&lt;/p>
&lt;p>IOS와 안드로이드 앱의 경우, 알림 전송 API는 appKey와 appSecret을 사용하여 보안을 유지한다.&lt;/p>
&lt;p>이러한 방식으로 인증된 혹은 승인된 클라이언트만 해당 API를 사용할 수 있다.&lt;/p>
&lt;p>&lt;strong>큐 모니터링&lt;/strong>&lt;/p>
&lt;p>큐에 쌓인 알림의 개수를 보고 작업 서버들의 처리량을 쉽게 모니터링 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>너무 크면 이벤트를 빠르게 처리하지 못하고있다는 뜻&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>이벤트 추적&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_9.png"
width="769"
height="409"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_9_hud2dbc79b7de8b0aa132399e5d3082a08_62119_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_9_hud2dbc79b7de8b0aa132399e5d3082a08_62119_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이벤트 추적"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="451px"
>&lt;/p>
&lt;p>알림 확인율, 클릭율, 실제 앱 사용으로 이어지는 비율 같은 메트릭은 사용자를 이해하는데 중요하다.&lt;/p>
&lt;p>보통 알림 시스템을 만들면 데이터 분석 서비스와도 통합하는 경우가 많다.&lt;/p>
&lt;p>&lt;strong>수정된 설계안&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_10.png"
width="841"
height="514"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_10_huf8cbea8348c39c7ce30b64e29ad9daf9_149286_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_10_huf8cbea8348c39c7ce30b64e29ad9daf9_149286_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="수정된 설계안"
class="gallery-image"
data-flex-grow="163"
data-flex-basis="392px"
>&lt;/p>
&lt;p>이전 설계안과의 차이점은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>알림 서버에 인증과 전송률 제한 기능이 추가&lt;/li>
&lt;li>전송 실패에 대응하기 위한 재시도 기능 추가
&lt;ul>
&lt;li>다시 큐에 넣고 지정된 횟수만큼 재시도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>전송 템플릿을 사용하여 알림 생성 과정을 단순화하고 알림 내용의 일관성을 유지&lt;/li>
&lt;li>모니터링과 추적 시스템 추가&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>규모 확장이 쉬울 뿐 아니라 푸시 알림, SMS 메시지, 이메일 등 다양한 정보 전달 방식을 지원하는 알림 시스템을 구축했다.&lt;/p>
&lt;p>시스템 컴포넌트 사이의 결함도를 낮추기 위해 메시지 큐를 적극적으로 사용하였다.&lt;/p>
&lt;ul>
&lt;li>안정성
&lt;ul>
&lt;li>메시지 전송 실패율을 낮추기 위해 안정적인 재시도 메커니즘을 도입&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>보안
&lt;ul>
&lt;li>인징된 클라이언트만이 알림을 보낼 수 있도록 보안 매커니즘 추가(appKey, appSecret)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이벤트 추적 및 모니터링&lt;/li>
&lt;li>사용자 설정
&lt;ul>
&lt;li>사용자가 알림 수신 설정을 조정할 수 있도록 함&lt;/li>
&lt;li>알람을 보내기 전 해당 설정을 확인하도록 스스템 설계를 변경&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>전송률 제한
&lt;ul>
&lt;li>사용자에게 알림을 보내는 빈도를 제한할 수 있도록 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>9. 웹 크롤러 설계</title><link>https://codemario318.github.io/post/system-design-interview/9/</link><pubDate>Tue, 18 Jun 2024 13:54:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/9/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/cover.png" alt="Featured image of post 9. 웹 크롤러 설계" />&lt;h2 id="웹-크롤러">웹 크롤러?&lt;/h2>
&lt;p>웹 크롤러는 로봇(Robot) 또는 스파이더(Spider)라고도 부르는 검색 엔진에서 널리 쓰는 기술로, &lt;strong>웹에 새로 올라오거나 갱신된 콘텐츠를 찾아내는 것이 주된 목적&lt;/strong>이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img.png"
width="690"
height="746"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_hu8939a220c98e9690727ad8216a0decb0_158151_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_hu8939a220c98e9690727ad8216a0decb0_158151_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="웹 크롤링 동작 예시"
class="gallery-image"
data-flex-grow="92"
data-flex-basis="221px"
>&lt;/p>
&lt;p>몇 개 웹 페이지에서 시작하여 그 링크를 따라 나가면서 새로운 콘텐츠를 수집한다.&lt;/p>
&lt;ul>
&lt;li>검색 엔진 인덱싱(Search engine indexing)
&lt;ul>
&lt;li>가장 보편적인 용례로 웹 페이지를 모아 검색 엔진을 위한 로컬 인덱스를 만든다.&lt;/li>
&lt;li>Googlebot&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 아카이빙(Web Archiving)
&lt;ul>
&lt;li>장기보관을 목적으로 웹에서 정보를 모으는 절차를 말한다.&lt;/li>
&lt;li>국립 도서관 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 마이닝(Web mining)
&lt;ul>
&lt;li>인터넷에서 유용한 지식을 도출해 낼 수 있다.&lt;/li>
&lt;li>금융 기업들의 기업 분석용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 모니터링(Web monitoring)
&lt;ul>
&lt;li>인터넷에서 저작권이나 상표권이 침해되는 사례를 모니터링 할 수 있다.&lt;/li>
&lt;li>디지마크(Digimarc)사는 크롤러를 통해 해적판 저작물을 찾아내 보고한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>웹 크롤러의 복잡도는 웹 크롤러가 처리해야 하는 데이터의 규모에 따라 달라지므로 설계할 웹 크롤러가 감당해야 하는 데이터의 규모와 기능들을 알아내야한다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>웹 크롤러의 기본 알고리즘은 간단하다.&lt;/p>
&lt;ol>
&lt;li>URL 집합이 입력으로 주어지면, 해당 URL들이 가르키는 모든 웹 페이지를 다운로드한다.&lt;/li>
&lt;li>다운받은 웹 페이지에서 URL들을 추출한다.&lt;/li>
&lt;li>추출된 URL들을 다운로드할 URL 목록에 추가하고 위 과정을 처음부터 반복한다.&lt;/li>
&lt;/ol>
&lt;p>하지만 엄청난 규모 확장성을 갖는 웹 크롤러를 설계하는 것은 매우 어려운 작업이다.&lt;/p>
&lt;p>질문을 던져 요구사항을 알아내고 설계 범위를 좁힌다.&lt;/p>
&lt;ul>
&lt;li>Q. 주된 용도는?
&lt;ul>
&lt;li>A. 검색 엔진 인덱싱&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 매달 수집해야하는 웹 페이지 수
&lt;ul>
&lt;li>A. 약 10억개&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 새로 만들어진 웹 페이지나 수정된 웹 페이지도 고려해야하는가?
&lt;ul>
&lt;li>A. 예&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 수집한 웹 페이지는 저장해야하는가?
&lt;ul>
&lt;li>A. 5년간 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 중복된 콘텐츠는?
&lt;ul>
&lt;li>A. 무시해도 괜찮음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>질문을 통해 알아낸 요구사항을 명확히 하면서도 좋은 웹 크롤러가 만족시켜야 할 다음과 같은 속성에 주의를 기울여야한다.&lt;/p>
&lt;ul>
&lt;li>규모 확장성
&lt;ul>
&lt;li>웹은 수십억 개의 페이지가 존재하는 것으로 알려진 만큼 매우 거대하므로, &lt;strong>병행성(Parallelism)을 활용&lt;/strong>하면 보다 효과적으로 웹 크롤링을 수행할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>안정성(Robustness)
&lt;ul>
&lt;li>비정상적인 입력이나 황경에 잘 대응할 수 있어야 한다.&lt;/li>
&lt;li>잘못 작성된 HTML, 반응 없는 서버, 장애, 악성 코드가 붙어있는 링크 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예절(Politeness)
&lt;ul>
&lt;li>짧은 시간 동안 너무 많은 요청을 보내어 서버에 무리를 주면 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장성(Extensibility)
&lt;ul>
&lt;li>새로운 형태의 콘텐츠를 지원하기 쉬워야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;ul>
&lt;li>매달 10억 개의 웹 페이지 다운로드
&lt;ul>
&lt;li>&lt;code>QPS = 10억 / 30일 / 24시간 / 3600초 = 약 400페이지/s&lt;/code>&lt;/li>
&lt;li>&lt;code>최대(peak) QPS = 2 x QPS = 800&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 페이지의 평균 크기는 500k로 가정
&lt;ul>
&lt;li>&lt;code>10억 페이지 * 500k = 500TB/월&lt;/code>&lt;/li>
&lt;li>&lt;code>1개월치 = 500TB * 12개월 * 5년 = 30PB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="개략적인-설계안-제시-및-동의-구하기">개략적인 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_1.png"
width="845"
height="607"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_1_huc28c39ee12ec2f7699c2ff04ca5e2694_53266_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_1_huc28c39ee12ec2f7699c2ff04ca5e2694_53266_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="크롤러의 작업 흐름"
class="gallery-image"
data-flex-grow="139"
data-flex-basis="334px"
>&lt;/p>
&lt;p>&lt;strong>시작 URL 집합&lt;/strong>&lt;/p>
&lt;p>시작 URL 집합은 &lt;strong>웹 크롤러가 크롤링을 시작하는 출발점&lt;/strong>이다.&lt;/p>
&lt;p>전체 웹을 크롤링해야 하는 경우 시작 URL을 고를 때 가능한 한 많은 링크를 탐색할 수 있도록 하는 URL을 고르는 것이 바람직하다.&lt;/p>
&lt;ul>
&lt;li>일반적으로 전체 URL 공간을 작은 부분집합으로 나누는 전략을 사용
&lt;ul>
&lt;li>지역적인 특색, 즉 지역별로 인기 있는 웹 사이트가 다르다는 점에 착안&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>주제별로 다른 시작 URL을 사용
&lt;ul>
&lt;li>쇼핑, 스포츠, 건강 등의 주제별로 세분화하고 그 각각에 다른 시작 URL 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>시작 URL로 무엇을 쓸 것이냐는 질문에 정담은 없으므로 의도가 무엇인지만 정확히 전달해도 충분하다.&lt;/p>
&lt;p>&lt;strong>미수집 URL 저장소&lt;/strong>&lt;/p>
&lt;p>대부분의 현대적 웹 크롤러는 크롤링 상태를 &lt;strong>다운로드할 URL&lt;/strong>, &lt;strong>다운로드된 URL&lt;/strong> 두 가지로 나눠 관리한다.&lt;/p>
&lt;p>다운로드할 URL을 저장 관리하는 컴포넌트를 미수집 URL 저장소(URL Frontier)라고 부른다.&lt;/p>
&lt;p>&lt;strong>HTML 다운로더&lt;/strong>&lt;/p>
&lt;p>HTML 다운로더는 &lt;strong>인터넷에서 웹 페이지를 다운로드하는 컴포넌트&lt;/strong>이다.&lt;/p>
&lt;p>다운로드할 페이지의 URL은 미수집 URL 저장소가 제공한다.&lt;/p>
&lt;p>&lt;strong>도메인 이름 변환기&lt;/strong>&lt;/p>
&lt;p>웹 페이지를 다운받으려면 URL을 IP로 변환하는 절차가 필요하므로, HTML 다운로더는 도메인 이름 변환기를 이용하여 &lt;strong>URL에 대응되는 IP 주소를 알아낸다.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>콘텐츠 파서&lt;/strong>&lt;/p>
&lt;p>웹 페이지를 다운로드하면 &lt;strong>파싱&lt;/strong>과 &lt;strong>검증&lt;/strong>절차를 거쳐야한다.&lt;/p>
&lt;p>크롤링 서버 안에 콘텐츠 파서를 구현하면 크롤링 과정이 느려지게 될 수 있으므로 독립된 컴포넌트로 만드는 것이 좋다.&lt;/p>
&lt;p>&lt;strong>중복 콘텐츠인가?&lt;/strong>&lt;/p>
&lt;p>연구 결과에 따르면, 29% 가량의 웹 페이지 콘텐츠는 중복이다.&lt;/p>
&lt;p>따라서 &lt;strong>같은 콘텐츠를 여러 번 저장&lt;/strong>하게 될 수 있으므로 중복을 해결하기 위한 자료 구조를 도입하여 &lt;strong>데이터 중복을 줄이고&lt;/strong> 데이터 처리에 소요되는 시간을 줄일 수 있다.&lt;/p>
&lt;p>두 HTML 문서를 비교하는 가장 간단한 방법은 문서를 문자열로 보고 비교하는 방법을 고려할 수 있지만, 문서의 수가 매우 많은 경우 느리고 비효율적이므로, 대부분 웹 페이지의 해시 값을 비교하여 처리한다.&lt;/p>
&lt;p>&lt;strong>콘텐츠 저장소&lt;/strong>&lt;/p>
&lt;p>&lt;strong>HTML 문서를 보관하는 시스템&lt;/strong>이다.&lt;/p>
&lt;p>저장소를 구현하는 데 쓰일 구술을 고를 때는 &lt;strong>저장할 데이터의 유형&lt;/strong>, &lt;strong>크기&lt;/strong>, &lt;strong>저장소 접근 빈도&lt;/strong>, &lt;strong>데이터의 유효 기간&lt;/strong> 등을 종합적으로 고려한다.&lt;/p>
&lt;p>본 설계안은 디스크와 메모리를 동시에 사용하는 저장소를 선택할 것이다.&lt;/p>
&lt;ul>
&lt;li>데이터 양이 너무 많으므로 대부분의 콘텐츠는 디스크에 저장한다.&lt;/li>
&lt;li>인기 있는 콘텐츠는 메모리에 두어 접근 지연시간을 줄인다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>URL 추출기&lt;/strong>&lt;/p>
&lt;p>HTML 페이지를 파싱하여 링크들을 골라내는 역할을 수행한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_2.png"
width="821"
height="430"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_2_hu04f4fd4b9507be952f6ff4565090f5b3_203231_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_2_hu04f4fd4b9507be952f6ff4565090f5b3_203231_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="링크 추출 사례"
class="gallery-image"
data-flex-grow="190"
data-flex-basis="458px"
>&lt;/p>
&lt;ul>
&lt;li>상대 경로를 모두 절대 경로로 변환한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>URL 필터&lt;/strong>&lt;/p>
&lt;p>특정 URL을 크롤링 대상에서 배제한다.&lt;/p>
&lt;ul>
&lt;li>특정한 콘텐츠 타입이나 파일 확장자를 갖는 URL&lt;/li>
&lt;li>접속 시 오류가 발생하는 URL&lt;/li>
&lt;li>접근 제외 목록(deny list)에 포함된 URL 등&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>이미 방문한 URL?&lt;/strong>&lt;/p>
&lt;p>이미 방문한 URL이나 미수집 URL 저장소에 보관된 URL을 추적할 수 있도록 하는 자료 구조를 활용하여 구현한다.&lt;/p>
&lt;ul>
&lt;li>URL 방문 여부를 추적하여 같은 URL을 여러번 처리하는 일을 방지할 수 있다.&lt;/li>
&lt;li>서버 부하를 줄이고 무한 루프에 빠지는 일을 방지할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>해시 테이블이나 블룸 필터가 널리 쓰인다.&lt;/p>
&lt;p>&lt;strong>URL 저장소&lt;/strong>&lt;/p>
&lt;p>이미 방문한 URL을 보관하는 저장소다.&lt;/p>
&lt;h3 id="웹-크롤러-작업-흐름">웹 크롤러 작업 흐름&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_3.png"
width="840"
height="592"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_3_hufd385b60137cff9b9db1e88901bb7b7d_62024_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_3_hufd385b60137cff9b9db1e88901bb7b7d_62024_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="웹 크롤러 작업 흐름"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="340px"
>&lt;/p>
&lt;ol>
&lt;li>시작 URL들을 미수집 URL 저장소에 저장&lt;/li>
&lt;li>HTML 다운로더는 미수집 URL 저장소에서 URL 목록을 가져옴&lt;/li>
&lt;li>HTML 다운로더는 도메인 이름 변환기를 사용하여 URL의 IP 주소를 알아내고, 웹 페이지를 다운로드&lt;/li>
&lt;li>콘텐츠 파서는 다운된 HTML 페이지를 파싱하여 올바른 형식을 갖춘 페이지인지 검증&lt;/li>
&lt;li>콘텐츠 파싱과 검증이 끝나면 중복 콘텐츠인지 확인 절차 시작&lt;/li>
&lt;li>해당 페이지가 이미 저장소에 있는지 확인
&lt;ul>
&lt;li>이미 저장소에 있는 경우 처리하지 않고 버린다.&lt;/li>
&lt;li>저장소에 없는 콘텐츠인 경우 저장소에 저장한 뒤 URL 추출기로 전달&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>URL 추출기는 해당 HTML 페이지에서 링크를 추출함&lt;/li>
&lt;li>추출한 링크를 URL 필터로 전달&lt;/li>
&lt;li>필터링이 끝나고 남은 URL만 중복 URL 판별 단계로 전달&lt;/li>
&lt;li>URL 저장소에 보관된 URL인지 살피고 이미 있는 URL은 버린다.&lt;/li>
&lt;li>저장소에 없는 URL은 URL 저장소에 저장하고, 미수집 URL 저장소에 전달&lt;/li>
&lt;/ol>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>가장 중요한 컴포넌트와 그 구현 기술을 심도있게 살펴본다.&lt;/p>
&lt;h3 id="dfs-vs-bfs">DFS vs BFS&lt;/h3>
&lt;p>웹은 유향 그래프(directed graph)와 같으며, 크롤링 프로세스는 이 유향 그래프를 탐색하는 과정이다.&lt;/p>
&lt;p>그래프 탐색에 널리 사용되는 알고리즘은 DFS, BFS 두 가지 알고리즘인데 그래프의 크기가 얼마나 클지 가늠할 수 없으므로 BFS를 주로 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_4.png"
width="745"
height="599"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_4_hua510aa57a9e56ad00992b50a10e4d6b2_76959_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_4_hua510aa57a9e56ad00992b50a10e4d6b2_76959_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="BFS"
class="gallery-image"
data-flex-grow="124"
data-flex-basis="298px"
>&lt;/p>
&lt;p>&lt;strong>BFS의 문제점&lt;/strong>&lt;/p>
&lt;p>BFS는 FIFO 큐에 탐색할 URL를 추가하는 방식인데, 이러한 구현법에는 두 가지 문제점이 있다.&lt;/p>
&lt;ul>
&lt;li>한 페이지에서 나오는 링크의 상당수는 같은 서버로 되돌아간다.
&lt;ul>
&lt;li>같은 호스트에 속한 많은 링크를 다운받게 되는데, 병렬로 처리하게 된다면 수집 대상 서버는 수많은 요청으로 과부하에 걸린다.&lt;/li>
&lt;li>예의 없는 크롤러로 간주&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>URL에 우선순위를 두지 않는다.
&lt;ul>
&lt;li>모든 웹 페이지가 같은 수준의 품질, 중요성을 갖지는 않는다.&lt;/li>
&lt;li>페이지 순위, 트래픽의 양, 업데이트 빈도 등 여러가지 척도에 따라 우선순위를 구별하는 것이 좋을 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="미수집-url-저장소">미수집 URL 저장소&lt;/h3>
&lt;p>미수집 저장소를 잘 구현하면 예의를 갖춘 크롤러, URL 사이의 우선순위와 신선도를 구별하는 크롤러를 구현할 수 있다.&lt;/p>
&lt;p>&lt;strong>예의&lt;/strong>&lt;/p>
&lt;p>웹 크롤러는 &lt;strong>수집 대상 서버로 짧은 시간 안에 너무 많은 요청을 보내는 것을 삼가&lt;/strong>야 한다.&lt;/p>
&lt;ul>
&lt;li>동일 웹 사이트에 대해서는 한 번에 한 페이지만 요청한다.
&lt;ul>
&lt;li>같은 웹 사이트의 페이지를 다운받는 태스크는 시간차를 두고 실행한다.&lt;/li>
&lt;li>호스트명과 다운로드를 수행하는 작업 스레드 사이의 관계를 유지한다.&lt;/li>
&lt;li>각 다운로드 스레드는 별도의 큐를 통해 해당 큐에서 꺼낸 URL만 다운로드한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_5.png"
width="694"
height="684"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_5_hu9b21d490c5125653d38c7ab94cc56cb6_123801_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_5_hu9b21d490c5125653d38c7ab94cc56cb6_123801_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="예의 있는 크롤러 설계 예시"
class="gallery-image"
data-flex-grow="101"
data-flex-basis="243px"
>&lt;/p>
&lt;ul>
&lt;li>큐 라우터
&lt;ul>
&lt;li>같은 호스트에 속한 URL은 언제나 같은 큐로 가도록 보장한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>매핑 테이블
&lt;ul>
&lt;li>호스트 이름과 큐 사이의 관계를 보관한다.&lt;/li>
&lt;li>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>호스트&lt;/th>
&lt;th>큐&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>wikipedia.com&lt;/td>
&lt;td>b1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>apple.com&lt;/td>
&lt;td>b2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&lt;/td>
&lt;td>&amp;hellip;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>nike.com&lt;/td>
&lt;td>bn&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>FIFO 큐
&lt;ul>
&lt;li>같은 호스트에 속한 URL은 언제나 같은 큐에 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>큐 선택기
&lt;ul>
&lt;li>큐들을 순회하면서 큐에서 URL을 꺼내어 해당 큐에서 나온 URL을 다운로드하도록 지정된 작업 스레드에 전달한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작업 스레드
&lt;ul>
&lt;li>전달된 URL을 다운로드한다.&lt;/li>
&lt;li>순차적으로 처리되며, 작업 사이에 일정한 지연시간을 둘 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>우선순위&lt;/strong>&lt;/p>
&lt;p>유용성에 따라 URL의 우선순위를 나눌 때는 페이지랭크(PageRank), 트래픽 양, 갱신 빈도(Update Frequency) 등 다양한 척도를 사용할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_6.png"
width="679"
height="682"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_6_hu2b81a326b445fb63ed389467d8b1a40b_64739_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_6_hu2b81a326b445fb63ed389467d8b1a40b_64739_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="우선순위를 고려하는 크롤러 설계 예시"
class="gallery-image"
data-flex-grow="99"
data-flex-basis="238px"
>&lt;/p>
&lt;ul>
&lt;li>순위결정장치
&lt;ul>
&lt;li>URL을 입력으로 받아 우선순위를 계산한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>큐
&lt;ul>
&lt;li>우선순위별로 큐가 하나씩 할당된다.&lt;/li>
&lt;li>우선순위가 높으면 선택될 확률도 올라간다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>큐 선택기
&lt;ul>
&lt;li>임의 큐에서 처리할 URL을 꺼낸다.&lt;/li>
&lt;li>순위가 높은 큐에서 더 자주 꺼낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>전체 설계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_7.png"
width="624"
height="1120"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_7_hua7682a46c4831907399b700105278b58_160845_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_7_hua7682a46c4831907399b700105278b58_160845_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="전체 설계"
class="gallery-image"
data-flex-grow="55"
data-flex-basis="133px"
>&lt;/p>
&lt;ul>
&lt;li>전면 큐(front queue)
&lt;ul>
&lt;li>우선순위 결과 과정을 처리한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>후면 큐(back queue)
&lt;ul>
&lt;li>크롤러가 예의 바르게 동작하도록 보증한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>신선도&lt;/strong>&lt;/p>
&lt;p>웹 페이지는 수시로 추가되고, 삭제되고, 변경되므로 &lt;strong>데이터의 신선함을 유지하기 위해 이미 다운로드한 페이지라고 해도 주기적으로 재수집&lt;/strong>할 필요가 있다.&lt;/p>
&lt;p>모든 URL을 재수집하는 것은 많은 시간과 자원이 필요한 작업이므로, 이 작업을 최적화하기 위한 전략으로 다음과 같은 것들이 있다.&lt;/p>
&lt;ul>
&lt;li>웹 페이지의 변경 이력 활용&lt;/li>
&lt;li>우선순위를 활용하여, 중요한 페이지는 좀 더 자주 재수집&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>미수집 URL 저장소를 위한 지속성 저장장치&lt;/strong>&lt;/p>
&lt;p>검색엔진을 위한 크롤러는 처리해야하는 URL이 수억 개에 달한다.&lt;/p>
&lt;p>따라서 모두 메모리에 보관하는 것은 안정성이나 규모 확장성 측면에서 바람직하지 않고, 전부 디스크에 저장하는 것도 성능 병목으로 인해 적절치 않다.&lt;/p>
&lt;p>따라서 절충안을 택하여, &lt;strong>대부분의 URL은 디스크에 두고 IO 비용을 줄이기 위해 메모리 버퍼에 큐를 두는 것&lt;/strong>을 고려한다.&lt;/p>
&lt;p>버퍼에 있는 데이터는 주기적으로 디스크에 기록된다.&lt;/p>
&lt;h3 id="html-다운로더">HTML 다운로더&lt;/h3>
&lt;p>HTML 다운로더는 HTTP 프로토콜을 통해 웹 페이지를 내려받는다.&lt;/p>
&lt;p>&lt;strong>Robots.txt&lt;/strong>&lt;/p>
&lt;p>로봇 제외 프로토콜이라고도 부르는 Robots.txt는 웹사이트가 크롤러와 소통하는 표준적 방법이다.&lt;/p>
&lt;p>Robots.txt 파일에는 크롤러가 수집해되 되는 페이지 목록이 들어있다.&lt;/p>
&lt;p>따라서 웹 사이트를 크롤링 하기 전 해당 파일에 나열된 규칙을 먼저 확인해야 한다.&lt;/p>
&lt;p>Robots.txt 파일을 거푸 다운로드하는 것을 피하기 위해, 이 파일은 주기적으로 다운받아 캐시에 보관한다.&lt;/p>
&lt;p>&lt;strong>성능 최적화&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>분산 크롤링&lt;/p>
&lt;ul>
&lt;li>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_8.png"
width="610"
height="495"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_8_hu4704f60e777f14cba6bfd4009fcd3078_47203_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_8_hu4704f60e777f14cba6bfd4009fcd3078_47203_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="분산 크롤링 예시"
class="gallery-image"
data-flex-grow="123"
data-flex-basis="295px"
>&lt;/li>
&lt;li>성능을 높이기 위해 크롤링 작업을 여러 서버에 분산하는 방법이다.&lt;/li>
&lt;li>각 서버는 여러 스레드를 돌려 다운로드 작업을 처리한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>도메인 이름 변호나 결과 캐시&lt;/p>
&lt;ul>
&lt;li>도메인 이름 변환기는 DNS 요청을 보내고 결과를 받는 작업의 동기적 틍성으로 인해 크롤러 성능의 변목 중 하나이다.&lt;/li>
&lt;li>DNS 조회 결과로 얻어진 도메인 이름과 IP 주소 사이의 관계를 캐시에 보관해 놓고 크론 잡 등을 돌려 주기적으로 갱신하도록 해놓으면 성능을 효과적으로 높힐 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>지역성&lt;/p>
&lt;ul>
&lt;li>크롤링 작업을 수행하는 서버를 지역별로 분산하는 방법이다.&lt;/li>
&lt;li>크롤링 서버가 대상 서버와 지역적으로 가까우면 페이지 다운로드 시간을 줄일 수 있다.&lt;/li>
&lt;li>이러한 전략은 크롤 서버, 캐시, 큐, 저장소 등 대부분의 컴포넌트에 적용 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>짧은 타임아웃&lt;/p>
&lt;ul>
&lt;li>응답이 느리거나 하지 않는 서버에 대한 요청은 대기시간이 길어지므로, 최대 얼마나 기다릴지를 미리 정해 다운로드를 빨리 중단하여 다음 차례로 넘어간다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>안정성&lt;/strong>&lt;/p>
&lt;p>시스템 안정성을 향상하기 위한 접근법 가운데 중요한 몇가지는 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>안정 해시
&lt;ul>
&lt;li>다운로더 서버들에 부하를 분산할 때 적용 가능&lt;/li>
&lt;li>다운로더 서버를 쉽게 추가하고 삭제할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>크롤링 상태 및 수집 데이터 저장
&lt;ul>
&lt;li>장애가 발생한 경우에도 쉽게 복구할 수 있도록 크롤링 상태와 수집된 데이터를 지속적 저장장치에 기록해 두는 것이 바람직하다.&lt;/li>
&lt;li>크롤링을 쉽게 재시작할 수 있을 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예외 처리
&lt;ul>
&lt;li>대규모 시스템에서 에러는 불가피할 뿐 아니라 흔하게 벌어진다.&lt;/li>
&lt;li>전체 시스템이 중단되는 일 없이 그 작업을 우아하게 이어나갈 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 검증
&lt;ul>
&lt;li>시스템 오류를 방지하기 위한 종요 수간 가운데 하나이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>확정성&lt;/strong>&lt;/p>
&lt;p>새로운 형태의 콘텐츠를 쉽게 지원할 수 있도록 신경 써야 한다.&lt;/p>
&lt;p>새로운 모듈을 끼워 넣음으로써 새로운 형태의 콘텐츠를 지원할 수 있도록 설계할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_9.png"
width="844"
height="555"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_9_hu6bd6fe39d4fb6e162d1d6c362b2e20a7_81130_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_9_hu6bd6fe39d4fb6e162d1d6c362b2e20a7_81130_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="확장 모듈 반영 설계"
class="gallery-image"
data-flex-grow="152"
data-flex-basis="364px"
>&lt;/p>
&lt;ul>
&lt;li>PNG 다운로더
&lt;ul>
&lt;li>PNG 파일을 다운로드하는 플러그인 모듈&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 모니터
&lt;ul>
&lt;li>웹을 모니터링하여 저작권이나 상표권이 침해되는 일을 막는 모듈&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>문제 있는 콘텐츠 감지 및 회피&lt;/strong>&lt;/p>
&lt;p>중복이거나 의미 없는, 또는 유해한 콘텐츠를 감지하고 차단해야한다.&lt;/p>
&lt;ul>
&lt;li>중복 콘텐츠
&lt;ul>
&lt;li>해시나 체크섬을 사용하면 중복 콘텐츠를 쉽게 탐지할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>거미 덫
&lt;ul>
&lt;li>크롤러를 무한 루프에 빠드리도록 설계한 웹 페이지다.
&lt;ul>
&lt;li>&lt;code>www.spidertrapexample.com/foo/bar/foo/bar/foo/bar/...&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>만능 해결책은 없지만 몇가지 방법이 있다.
&lt;ul>
&lt;li>URL 최대 길이를 제한&lt;/li>
&lt;li>수작업으로 덫을 확인하고 착아낸 후 탐색 대상에서 제외하거나 필터 목록에 추가한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 노이즈
&lt;ul>
&lt;li>가치가 없는 콘텐츠는 제외한다.&lt;/li>
&lt;li>광고, 스크립트 코드, 스팸 URL 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>좋은 크롤러는 &lt;strong>규모 확정성&lt;/strong>, &lt;strong>예의&lt;/strong>, &lt;strong>확장성&lt;/strong>, &lt;strong>안정성&lt;/strong> 등을 고려해야한다.&lt;/p>
&lt;p>웹이 방대하고, 수없이 많은 덫이 도사리고 있기 때문에 규모 확장성이 뛰어난 웹 크롤러 설계는 단순하지 않다.&lt;/p>
&lt;ul>
&lt;li>서버 측 렌더링
&lt;ul>
&lt;li>비동기를 통해 동적으로 생성되는 링크는 페이지를 파싱하기 전에 서버 측 렌더링을 적용하면 해결할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>윈치 않는 페이지 필터링
&lt;ul>
&lt;li>스팸 방지 컴포넌트를 두어 품질이 조악하거나 스팸성인 페이지를 걸러내도록 하면 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터베이스 다중화 및 샤딩
&lt;ul>
&lt;li>다중화나 샤딩 같은 기법을 적용하면 데이터 계층의 가용성, 규모 확장성, 안정성이 향상된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>수평적 규모 확장성
&lt;ul>
&lt;li>대규모 크롤링을 위해 다운로스 서버가 수천 대 필요하게 될 수 있으므로, 수평적 규모 확장을 위해 무상태 서버로 만드는 것이 중요하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성, 일관성, 안정성
&lt;ul>
&lt;li>대형 시스템을 만들기 위해 필수적으로 고려해야한다. (1장 복습)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 분석 솔루션
&lt;ul>
&lt;li>데이터르 수집하고 분석하는 것은 어느 시스템에게나 중요하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>8. URL 단축기 설계</title><link>https://codemario318.github.io/post/system-design-interview/8/</link><pubDate>Tue, 04 Jun 2024 15:18:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/8/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/cover.png" alt="Featured image of post 8. URL 단축기 설계" />&lt;h2 id="1단계-문제-이해-및-설게-범위-확정">1단계: 문제 이해 및 설게 범위 확정&lt;/h2>
&lt;ul>
&lt;li>Q. URL 단축기 동작 예시
&lt;ul>
&lt;li>A. &lt;code>https://tinyurl.com/y7ke-ocwj&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 트래픽 규모는?
&lt;ul>
&lt;li>A. 매일 1억개의 단축 URL 생성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 단축 URL의 길이는?
&lt;ul>
&lt;li>A. 짧을수록 좋음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 단축 URL에 포함될 문자제한은?
&lt;ul>
&lt;li>A. 숫자(0~9), 영문자(A~z) 사용 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 단축된 URL을 지우거나 갱신 가능?
&lt;ul>
&lt;li>A. 시스템 단순화를 위해 삭제나 갱신은 할 수 없다 가정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 시스템의 기본적 기능은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>URL 단축
&lt;ul>
&lt;li>주어진 긴 URL을 훨씬 짧게 줄인다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>URL 리디렉션(redirection)
&lt;ul>
&lt;li>축약된 URL로 HTTP 요청이 오면 원래 URL로 안내&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>높은 가용성과 규모 확장성, 장애 감내 요구됨&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-추정">개략적 추정&lt;/h3>
&lt;ul>
&lt;li>쓰기 연산: 매일 1억 개의 단축 URL 생성&lt;/li>
&lt;li>초당 쓰기 연산: &lt;code>1억 / 24 / 3600 = 1160&lt;/code>&lt;/li>
&lt;li>읽기 연산:
&lt;ul>
&lt;li>읽기 연산과 쓰기 연산의 비율은 &lt;strong>10:1&lt;/strong>로 가정&lt;/li>
&lt;li>대략 초당 11,600회 발생&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>URL 단축 서비스를 10년간 운영한다고 가정하면 &lt;code>1억 * 365 * 10 = 3650억&lt;/code>개 레코드 보관&lt;/li>
&lt;li>축약 전 URL의 평균 길이는 100
&lt;ul>
&lt;li>필요한 저장 용량은 &lt;code>3650억 * 100바이트 = 36.5TB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="api-엔드포인트">API 엔드포인트&lt;/h3>
&lt;p>클라이언트는 서버가 제공하는 API 엔드포인트를 통해 서버와 통신한다.&lt;/p>
&lt;p>RESTful API로 설계한다고 가정하면, 기본적으로 두 개의 엔드포인트를 필요로 한다.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>URL 단축용 엔드포인트&lt;/strong>
&lt;ul>
&lt;li>새 단축 URL을 생성하고자 하는 클라이언트는 이 엔드포인트에 단축할 URL을 인자로 담아 POST 요청을 보내야한다.&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">POST /api/v1/data/shorten
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>인자: &lt;code>{longUrl: longURLstring}&lt;/code>&lt;/li>
&lt;li>반환: 단축 URL&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>URL 리디렉션용 엔드포인트&lt;/strong>
&lt;ul>
&lt;li>단축 URL에 대해 HTTP 요청이 오면 원래 URL로 보내주기 위한 용도의 엔드포인트&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GET /api/v1/shortUrl
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>반환: HTTP 리디렉션 목적지가 될 원래 URL&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="url-리디렉션">URL 리디렉션&lt;/h3>
&lt;p>단축 URL을 받은 서버는 그 URL을 원래 URL로 바꾸어 &lt;strong>301 응답&lt;/strong>의 &lt;strong>Location 헤더&lt;/strong>에 넣어 반환한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/img.png"
width="362"
height="363"
srcset="https://codemario318.github.io/post/system-design-interview/8/img_hu4a278bdc249e7e3e9a78362cdb2bf14f_44204_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/8/img_hu4a278bdc249e7e3e9a78362cdb2bf14f_44204_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클라이언트와 서버 사이의 통신 절차"
class="gallery-image"
data-flex-grow="99"
data-flex-basis="239px"
>&lt;/p>
&lt;p>유의할 점은 301 응답과 302 응답의 차이로, 둘 다 리디렉션 응답이지만 차이가 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>301 Permanently Moved&lt;/code>
&lt;ul>
&lt;li>URL에 대한 HTTP 요청의 처리 책임이 &lt;strong>영구적으로 Location 헤더에 반환된 URL로 이전&lt;/strong>됨&lt;/li>
&lt;li>영구적인 이전이므로 브라우저는 이 응답을 &lt;strong>캐싱&lt;/strong>한다.&lt;/li>
&lt;li>따라서 같은 단축 URL로 재요청시 캐시된 원래 URL로 요청을 보낸다.&lt;/li>
&lt;li>서버 부하를 줄이는 것이 중요할 때 사용될 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>302 Found&lt;/code>
&lt;ul>
&lt;li>URL로의 요청이 &lt;strong>일시적으로 Location 헤더의 URL에 의해 처리&lt;/strong>되어야함&lt;/li>
&lt;li>클라이언트의 요청은 &lt;strong>캐싱되지 않으므로&lt;/strong>, 언제나 단축 URL 서버에 먼저 보내짐&lt;/li>
&lt;li>트래픽 분석 같이 클릭 발생률이나 발생 위치를 파악해야할 때 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>URL 리디렉션을 구현하는 가장 직관적인 방법은 &lt;strong>해시 테이블&lt;/strong>을 사용하는 것으로 &lt;code>&amp;lt;단축 URL: 원래 URL&amp;gt;&lt;/code> 형식으로 구현될 수 있다.&lt;/p>
&lt;h3 id="url-단축">URL 단축&lt;/h3>
&lt;p>단축 URL이 &lt;code>&amp;lt;www.tinyurl.com/{hashValue}&amp;gt;&lt;/code> 같은 형태로 만들어진다면, 긴 URL을 이 해시 값으로 대응시킬 &lt;strong>해시 함수 &lt;code>fx&lt;/code>&lt;/strong> 를 찾는 것이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/img_1.png"
width="263"
height="205"
srcset="https://codemario318.github.io/post/system-design-interview/8/img_1_hu28fdb81906c71ae40d2947e410c83904_16249_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/8/img_1_hu28fdb81906c71ae40d2947e410c83904_16249_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="해시 함수 fx"
class="gallery-image"
data-flex-grow="128"
data-flex-basis="307px"
>&lt;/p>
&lt;p>해시 함수는 다음과 같은 요구사항을 만족해야 한다.&lt;/p>
&lt;ul>
&lt;li>입력으로 주어지는 긴 URL이 다른 값이면 해시 값도 달라야한다.&lt;/li>
&lt;li>계산된 해시 값은 원래 입력으로 주어졌던 긴 URL로 복원될 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>개략적 설계에서는 모든 것을 해시 테이블에 두었지만, 이 방식은 메모리는 유한하고 비싸기 때문에 실제 시스템에서 사용되기 어렵다.&lt;/p>
&lt;p>더 나은 방식은 &lt;code>&amp;lt;단축 URL, 원래 URL&amp;gt;&lt;/code>의 순서쌍을 RDB에 저장하는 것이다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
URL {
number id pk
string shortURL
string longURL
}
&lt;/pre>
&lt;h3 id="해시-함수">해시 함수&lt;/h3>
&lt;p>해시 함수는 &lt;strong>원래 URL을 단축 URL로 변환&lt;/strong>하는 데 쓰인다.&lt;/p>
&lt;p>&lt;strong>해시 값 길이&lt;/strong>&lt;br>
hashValue는 &lt;code>[0-9, a-z, A-Z]&lt;/code>의 문자들로 구성된다.&lt;/p>
&lt;ul>
&lt;li>사용할 수 있는 문자의 개수는 &lt;code>10 + 26 + 26 = 62&lt;/code>개이다.&lt;/li>
&lt;li>hashValue의 길이를 정하기 위해서는 &lt;code>62^n &amp;gt;= 3650억&lt;/code>을 만드는 n의 최소값을 찾아야한다.
&lt;ul>
&lt;li>n = 7, 약 3.5조 개&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>해시후 충돌 해소&lt;/strong>&lt;br>
긴 URL을 줄이려면, 원래 URL을 7글자 문자열로 줄이는 해시 함수가 필요하다.&lt;/p>
&lt;p>가장 쉬운 방법은 CRC32, MD5, SHA-1 같이 잘 알려진 해시 함수를 이용하는 것이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/img_2.png"
width="403"
height="141"
srcset="https://codemario318.github.io/post/system-design-interview/8/img_2_hu130b2b42d1534b4e7248d03256cabfb1_16625_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/8/img_2_hu130b2b42d1534b4e7248d03256cabfb1_16625_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="&amp;ldquo;https://en.wikipedia.org/wiki/Systems_design&amp;#34;의 해시값"
class="gallery-image"
data-flex-grow="285"
data-flex-basis="685px"
>&lt;/p>
&lt;p>잘 알려진 해시 함수를 사용한 결과가 계산한 가장 짧은 해시값조차도 7보다는 길이가 긴데, 이 문제를 해결하기 위한 첫 번째 방법으로 처음 7개 문자만 사용하는 방법을 고려할 수 있다.&lt;/p>
&lt;ul>
&lt;li>해시 결과가 충돌할 확률이 높아진다.&lt;/li>
&lt;li>충돌이 발생한 경우, 충돌이 해소될 때까지 사전에 정한 문자열을 해시값에 덧붙인다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/img_3.png"
width="527"
height="318"
srcset="https://codemario318.github.io/post/system-design-interview/8/img_3_hub0df4858afff8df13008d5e526aeee01_35083_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/8/img_3_hub0df4858afff8df13008d5e526aeee01_35083_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="해시 후 충돌 해소"
class="gallery-image"
data-flex-grow="165"
data-flex-basis="397px"
>&lt;/p>
&lt;ul>
&lt;li>단축 URL을 생성할 때 한 번 이상 데이터베이스 질의를 해야 하므로 오버헤드가 크다.&lt;/li>
&lt;li>데이터베이스 대신 블룸 필터를 사용하면 성능을 높일 수 있다.
&lt;ul>
&lt;li>어떤 집합에 특정 원소가 있는 지 검사할 수 있도록 하는, 확률론에 기초한 공간 효율이 좋은 기술&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>base-62 변환&lt;/strong>&lt;br>
진법 변환(base conversion)은 URL 단축기를 구현할 때 흔히 사용되는 접근법이다.&lt;/p>
&lt;ul>
&lt;li>수의 표현 방식이 다른 두 시스템이 같은 수를 공유하여야 하는 경우 유용하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/img_4.png"
width="460"
height="209"
srcset="https://codemario318.github.io/post/system-design-interview/8/img_4_hua0543d5a53f0486c3860430ba71667b3_17218_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/8/img_4_hua0543d5a53f0486c3860430ba71667b3_17218_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="62 진법 변환"
class="gallery-image"
data-flex-grow="220"
data-flex-basis="528px"
>&lt;/p>
&lt;p>&lt;strong>두 접근법 비교&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>해시 후 충돌 해소&lt;/th>
&lt;th>62 진법 변환&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>단축 URL 길이가 고정됨&lt;/td>
&lt;td>단축 URL 길이가 가변적, ID 값이 커지면 길어짐&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>유일성이 보장되는 ID 생성기가 필요하지 않음&lt;/td>
&lt;td>유일성 보장 ID 생성기 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>충돌이 해소 전략 필요&lt;/td>
&lt;td>ID 유일성이 보장되어야 적용 가능한 전략이라 충돌 불가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ID로 부터 단축 URL을 계산하는 방식이 아니므로 다음에 쓸 수 있는 URL을 알아내는 것이 불가능&lt;/td>
&lt;td>ID가 1씩 증가하는 값이라고 가정하면 다음에 쓸 수 있는 단축 URL이 무엇인지 쉽게 알아낼 수 있어 보안상 문제 소지가 될 수 있음&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="url-단축기-상세-설계">URL 단축기 상세 설계&lt;/h3>
&lt;p>URL 단축기는 시스템의 핵심 컴포넌트이므로, 그 처리흐름이 논리적으로는 단순해야 하고, 기능적으로는 언제나 동작하는 상태로 유지되어야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/img_5.png"
width="463"
height="348"
srcset="https://codemario318.github.io/post/system-design-interview/8/img_5_hud414c15ad06fec3825b6f1e5e69c33f5_33072_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/8/img_5_hud414c15ad06fec3825b6f1e5e69c33f5_33072_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="URL 단축 처리 흐름"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="319px"
>&lt;/p>
&lt;p>해당 ID 생성기의 주된 용도는, 단축 URL을 만들 때 사용할 ID를 만드는 것이고, 이 &lt;strong>ID는 전역적 유일성이 보장&lt;/strong>되는 것 이어야 한다.&lt;/p>
&lt;p>고도로 분산된 환경에서 이런 생성기를 만드는 것은 무척 어려운 일로 필요하다면 &lt;strong>7장 내용을 응용하여 분산 환경에 사용될 유일한 ID를 만들 수 있다&lt;/strong>.&lt;/p>
&lt;h3 id="url-리디렉션-상세-설계">URL 리디렉션 상세 설계&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/img_6.png"
width="526"
height="167"
srcset="https://codemario318.github.io/post/system-design-interview/8/img_6_hu33c2d1982d9952264698b9ef2bfc0ff5_38702_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/8/img_6_hu33c2d1982d9952264698b9ef2bfc0ff5_38702_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="URL 리디렉션 상세 설계"
class="gallery-image"
data-flex-grow="314"
data-flex-basis="755px"
>&lt;/p>
&lt;p>쓰기보다 읽기를 더 자주하는 시스템의 특성에 맞추어, &lt;code>&amp;lt;단축 URL, 원래 URL&amp;gt;&lt;/code>의 쌍을 &lt;strong>캐싱&lt;/strong>하여 성능을 높힐 수 있다.&lt;/p>
&lt;h2 id="마무리">마무리&lt;/h2>
&lt;p>설계를 마친 후 시간이 좀 남는다면 다음과 같은 것을 면접관과 이야기 할 수 있을것이다.&lt;/p>
&lt;ul>
&lt;li>처리율 제한 장치
&lt;ul>
&lt;li>엄청난 양은 단축 요청이 들어올 경우 무력화될 수 있다는 잠재적 보안 결함을 갖고 있다.&lt;/li>
&lt;li>처리율 제한 장치를 통해 요청을 걸러낼 수 있다. 4장 참조&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 서버의 규모 확장
&lt;ul>
&lt;li>설계에 포함된 웹 계층은 무상태 계층이므로, 웹 서버를 자유롭게 증설, 삭제 할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터베이스 규모 확장
&lt;ul>
&lt;li>데이터베이스를 다중화하거나 샤딩하여 규모 확장성을 달성할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 분석 솔루션
&lt;ul>
&lt;li>URL 단축기에 데이터 분석 솔루션을 통합해 두면 어떤 링크를 얼마나 많은 사용자가 클릭했는지, 언제 주로 클릭했는지 등 중요한 정보를 알아낼 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성, 데이터 일관성, 안정성
&lt;ul>
&lt;li>1장 참조&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>7. 분산 시스템을 위한 유일 ID 생성기 설계</title><link>https://codemario318.github.io/post/system-design-interview/7/</link><pubDate>Tue, 04 Jun 2024 14:26:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/7/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/7/cover.png" alt="Featured image of post 7. 분산 시스템을 위한 유일 ID 생성기 설계" />&lt;p>서비스의 규모가 작을때는 &lt;code>auto_increment&lt;/code> 속성이 설정된 관계형 데이터 베이스의 기본키를 사용하는 방법을 고려할 수 있지만, &lt;strong>분산 환경&lt;/strong>에서는 이러한 방법을 사용할 수 없다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스 서버(master) 한 대로는 요구를 감당할 수 없다.&lt;/li>
&lt;li>여러 데이터베이스 서버를 쓰는 경우 지연 시간을 낮추기 매우 힘들다.&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-설정">1단계: 문제 이해 및 설계 범위 설정&lt;/h2>
&lt;ul>
&lt;li>Q. ID는 어떤 특성을 낮는가?
&lt;ul>
&lt;li>A. ID는 &lt;strong>유일&lt;/strong>해야 하고, &lt;strong>정렬 가능&lt;/strong>해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 새로운 레코드에 붙일 ID는 항상 1만큼 큰 값이어야 하는가?
&lt;ul>
&lt;li>A. &lt;strong>시간에 따라 커지지만&lt;/strong>, 언제나 &lt;strong>1씩 증가하지는 않아도 괜찮다&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. &lt;strong>ID는 숫자로만&lt;/strong> 구성되는가?
&lt;ul>
&lt;li>A. 예&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 시스템의 규모는 어느 정도 인가?
&lt;ul>
&lt;li>A. &lt;strong>초당 10,000 ID 생성&lt;/strong> 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위 질의응답을 통해 요구 사항을 정리하면 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>ID는 &lt;strong>유일&lt;/strong>해야함&lt;/li>
&lt;li>ID는 &lt;strong>숫자로만&lt;/strong> 구성되어야 함.&lt;/li>
&lt;li>ID는 &lt;strong>64비트로 표현&lt;/strong>될 수 있는 값이어야 한다.&lt;/li>
&lt;li>ID는 발급 날짜에 따라 &lt;strong>정렬 가능&lt;/strong>해야 한다.&lt;/li>
&lt;li>&lt;strong>초당 10,000개&lt;/strong>의 ID를 만들 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>분산 시스템에서 유일성이 보장되는 ID를 만드는 방법은 여러 가지다.&lt;/p>
&lt;h3 id="다중-마스터-복제">다중 마스터 복제&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/7/img.png"
width="405"
height="203"
srcset="https://codemario318.github.io/post/system-design-interview/7/img_hu9014d3795a5b6c4cab16daba760b0bfa_48519_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/7/img_hu9014d3795a5b6c4cab16daba760b0bfa_48519_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="다중 마스터 복제 구조"
class="gallery-image"
data-flex-grow="199"
data-flex-basis="478px"
>&lt;/p>
&lt;p>이 접근법은 데이터베이스의 &lt;strong>&lt;code>auto_increment&lt;/code>&lt;/strong> 기능을 활용한다.&lt;/p>
&lt;ul>
&lt;li>다음 ID의 값을 구할 때 1만큼 증가시켜 얻는 것이 아니라, &lt;strong>k만큼 증가&lt;/strong>시킨다.
&lt;ul>
&lt;li>&lt;strong>&lt;code>k = 현재 사용중인 데이터베이스 서버 대수&lt;/code>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 방식을 통해 규모 확장성 문제를 어느정도 해결할 수 있지만, 중대한 단점이 있다.&lt;/p>
&lt;ul>
&lt;li>여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.&lt;/li>
&lt;li>ID의 유일성을 보장되지만, 그 값이 시간 흐름에 맞추어 커지도록 보장할 수 없다.
&lt;ul>
&lt;li>더 많은 ID를 생성한 데이터베이스의 ID가 덜 생성한 데이터베이스의 ID보다 늦게 생성되었어도 큰 값을 가질 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다.&lt;/li>
&lt;/ul>
&lt;h3 id="uuid">UUID&lt;/h3>
&lt;p>UUID는 유일성이 보장되는 ID를 만드는 또 하나의 간단한 방법이다.&lt;/p>
&lt;ul>
&lt;li>컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수&lt;/li>
&lt;li>충돌 가능성이 지극히 낮다.
&lt;ul>
&lt;li>중복 UUID가 1개 생길 확률을 50%로 끌어 올리려면 초당 10억 개의 UUID를 100년동안 계속해서 만들어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>09c93e62-50b4-468d-bf8a-c07e1040bfb2&lt;/code> 와 같은 형태를 띈다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/7/img_1.png"
width="523"
height="136"
srcset="https://codemario318.github.io/post/system-design-interview/7/img_1_hu6256ca36668288eeedaf0076978f50bb_33014_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/7/img_1_hu6256ca36668288eeedaf0076978f50bb_33014_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="UUID를 사용하는 시스템의 구조"
class="gallery-image"
data-flex-grow="384"
data-flex-basis="922px"
>&lt;/p>
&lt;p>이러한 특성으로 UUID는 서버 간 조율 없이 독립적으로 생성 가능하므로, 각 서버가 별도의 ID 생성기를 사용해 독립적으로 ID를 만들어낸다.&lt;/p>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>UUID를 만드는 것은 단순하다.&lt;/li>
&lt;li>서버 사이의 조율이 필요 없으므로 동기화 이슈도 없다.&lt;/li>
&lt;li>각 서버가 자기가 쓸 ID를 알아서 만드는 구조이므로 규모 확장도 쉽다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>ID가 128비트로 길다.
&lt;ul>
&lt;li>요구사항은 64비트&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ID를 시간순으로 정렬할 수 없다.
&lt;ul>
&lt;li>임의의 중복이 힘든 문자열로 생성됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ID에 숫자가 아닌 값이 포함될 수 있다.
&lt;ul>
&lt;li>요구사항은 숫자로만 구성되어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="티켓-서버">티켓 서버&lt;/h3>
&lt;p>티켓 서버는 &lt;code>auto_increment&lt;/code> 기능을 낮춘 데이터베이스 서버, 즉 티켓 서버를 중앙 집중형으로 하나만 사용하는 방식으로 유일성이 보장되는 ID를 만든다.&lt;/p>
&lt;ul>
&lt;li>플리커(Flickr)는 분산 기본 키(Distributed primary key)를 만들어 내기 위해 이 기술을 이용&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/7/img_2.png"
width="514"
height="192"
srcset="https://codemario318.github.io/post/system-design-interview/7/img_2_hu35af303bc81c90e1e9d062a2cc6f0084_34398_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/7/img_2_hu35af303bc81c90e1e9d062a2cc6f0084_34398_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="티켓 서버 동작 방식"
class="gallery-image"
data-flex-grow="267"
data-flex-basis="642px"
>&lt;/p>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.&lt;/li>
&lt;li>구현하기 쉽고, 중소 구모 애플리케이션에 적합하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>티켓 서버가 SPOF가 된다.
&lt;ul>
&lt;li>티켓 서버에 장애가 발생하면 해당 서버를 이용하는 모든 시스템이 영향을 받는다.&lt;/li>
&lt;li>티켓 서버를 여러 대 준비한다면 데이터 동기화 같은 새로운 문제가 발생한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="트위터-스노플레이크-접근법">트위터 스노플레이크 접근법&lt;/h3>
&lt;p>스노플레이크 접근법은 생성해야하는 ID를 여러 절로 분할하여 독립적인 ID를 만든다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/7/img_3.png"
width="517"
height="65"
srcset="https://codemario318.github.io/post/system-design-interview/7/img_3_hu359222468aa455e79718e3251ca7189d_7642_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/7/img_3_hu359222468aa455e79718e3251ca7189d_7642_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="생성해야 하는 ID 구조"
class="gallery-image"
data-flex-grow="795"
data-flex-basis="1908px"
>&lt;/p>
&lt;ul>
&lt;li>사인(sign) 비트: 항상 0으로 설정되어 양수로 유지한다.
&lt;ul>
&lt;li>특별한 의미는 없는듯&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>타임스탬프(timestamp): 기원 시간 이후로 몇 밀리초가 경과했는지를 나타내는 값
&lt;ul>
&lt;li>41비트로 약 69년 동안의 시간을 표현할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터센터 ID: 데이터센터 ID
&lt;ul>
&lt;li>5비트로 32개 데이터 센터를 구분할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서버 ID: 서버 ID
&lt;ul>
&lt;li>5비트로 32개의 서버 구분 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>일련번호: 각 서버에서 ID를 생성할 때마다 일련번호를 1만큼 증가시킴
&lt;ul>
&lt;li>1밀리초가 경과될 때마다 0으로 초기화됨(TS가 1ms 간격으로 증가하므로)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>트위터 스노플레이크 접근법을 사용하여 보다 상세한 설계를 진행한다.&lt;/p>
&lt;ul>
&lt;li>데이터센터 ID와 서버 ID는 시스템이 시작될 때 결정되며, 일반적으로 시스템 운영중에는 바뀌지 않는다.
&lt;ul>
&lt;li>데이터센터 ID, 서버 ID를 잘못 변경하게 되면 충돌이 발생할 수 있으므로, 신중하게 해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>타임 스탬프나 일련번호는 ID 생성기가 돌고 있는 중에 만들어진다.&lt;/li>
&lt;/ul>
&lt;h3 id="타임스탬프">타임스탬프&lt;/h3>
&lt;p>타임스탬프는 시간이 흐름에 따라 점점 큰 값을 갖게 되므로, 결국 ID는 시간 순으로 정렬 가능하게 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/7/img_4.png"
width="511"
height="404"
srcset="https://codemario318.github.io/post/system-design-interview/7/img_4_hue8e03313e3458bff2af6b82679f89a78_43392_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/7/img_4_hue8e03313e3458bff2af6b82679f89a78_43392_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="타임스탬프를 이용한 UTC 추출"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="303px"
>&lt;/p>
&lt;p>41비트로 표현할 수 있는 타임스탬프 최대값은 &lt;code>2^41 - 1 = 2,199,023,255,551&lt;/code> 밀리초 이므로 대략 69년 표현할 수 있다.&lt;/p>
&lt;p>따라서 이 ID 생성기는 69년동안만 정상 동작하므로 &lt;strong>69년이 지나면 기원 시각을 바꾸거나 ID 체계를 다른 것으로 이전&lt;/strong>(migration)하여햐한다.&lt;/p>
&lt;h3 id="일련번호">일련번호&lt;/h3>
&lt;p>일련번호는 12비트이므로,&lt;code>2^12 - 1 = 4096&lt;/code>개의 값을 가질 수 있다.&lt;/p>
&lt;p>어떤 서버가 &lt;strong>같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값&lt;/strong>을 갖게 된다.&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;ul>
&lt;li>시계 동기화(Clock synchronization)
&lt;ul>
&lt;li>기존 설계는 하나의 서버가 여러 코어에서 실행될 경우 유효하지 않을 수 있다.&lt;/li>
&lt;li>물리적으로 독립된 여러 장비에서 실행되는 경우 유효하지 않을 수 있다.&lt;/li>
&lt;li>NTP(Network Time Protocol)은 이 문제를 해결하는 가장 보편적인 수단이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 절(Section)의 길이 최적화
&lt;ul>
&lt;li>동시성이 낮고 수명이 긴 애플리케이션이라면 일련번호 절의 길이를 줄이고 타임스탬프 절의 길이를 늘리는 것이 효과적일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>고가용성
&lt;ul>
&lt;li>ID 생성기는 필수 불가결(mission critical) 컴포넌트이므로 아주 높은 가용성을 제공해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>6. 키-값 저장소 설계</title><link>https://codemario318.github.io/post/system-design-interview/6/</link><pubDate>Mon, 27 May 2024 11:59:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/6/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/cover.png" alt="Featured image of post 6. 키-값 저장소 설계" />&lt;p>키-값 저장소(key-value store)는 키-값 데이터베이스라고도 불리는 비 관계형(non-relational) 데이터베이스이다.&lt;/p>
&lt;ul>
&lt;li>이 저장소에 저장되는 값은 &lt;strong>고유 식별자&lt;/strong>를 키로 가져야한다.&lt;/li>
&lt;li>키와 값 사이의 이런 연결 관계를 &lt;strong>키-값 쌍&lt;/strong>(key-value pair)이라고 지칭한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>키&lt;/strong>&lt;br>
키-값 쌍에서의 키는 &lt;strong>유일&lt;/strong>해야 하며 해당 키에 매달린 값은 &lt;strong>키를 통해서만 접근&lt;/strong>할 수 있다.&lt;/p>
&lt;p>키는 일반 텍스트일 수도 있고 해시 값일 수도 있지만, 성능상의 이유로 짧을수록 좋다.&lt;/p>
&lt;ul>
&lt;li>일반 텍스트 키: &amp;ldquo;last_logged_in_at&amp;rdquo;&lt;/li>
&lt;li>해시 키: 253DDEC4&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>값&lt;/strong>&lt;br>
키-값 저장소는 보통 &lt;strong>값으로 무엇이 오든 상관하지 않는다&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>문자열, 리스트, 객체 등&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>키-값 저장소로 널리 알려진 것은 아마존 다이나모, memcached, 레디스 같은 것들이 있다.&lt;/p>
&lt;p>또한 기본적으로 아래와 같은 연산을 지원해야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>put(key, value)&lt;/code>: 키-값 쌍을 저장소에 저장한다.&lt;/li>
&lt;li>&lt;code>get(key)&lt;/code>: 인자로 주어진 키에 매달린 값을 꺼낸다.&lt;/li>
&lt;/ul>
&lt;h2 id="문제-이해-및-설계-범위-확정">문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>완벽한 설계란 없다.&lt;/p>
&lt;p>읽기, 쓰기 그리고 메모리 사용량 사이에 어떤 균형을 찾고, 데이터의 일관성과 가용성 사이에서 타협적 결정을 내린 설계를 만들었다면 충분히 쓸만한 답이다.&lt;/p>
&lt;p>이번 장에서는 다음 특성을 갖는 키-값 저장소를 설계해본다.&lt;/p>
&lt;ul>
&lt;li>키-값 쌍의 크기는 10KB 이하이다.&lt;/li>
&lt;li>큰 데이터를 저장할 수 있어야 한다.&lt;/li>
&lt;li>높은 가용성을 제공해야한다.
&lt;ul>
&lt;li>시스템은 장애가 있더라도 빨리 응답해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>높은 규모 확장성을 제공해야 한다.
&lt;ul>
&lt;li>트래픽 양에 따라 자동적으로 서버 증설/삭제가 이루어져야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 일관성 수준은 조정이 가능해야 한다.&lt;/li>
&lt;li>응답 지연시간(latency)이 짧아야 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="단일-서버-키-값-저장소">단일 서버 키-값 저장소&lt;/h2>
&lt;p>한 대 서버만 사용하는 키-값 저장소는 설계가 쉽다.&lt;/p>
&lt;p>가장 직관적인 방법은 키-값 쌍 전부를 메모리에 해시 테이블로 저장하는 것이다.&lt;/p>
&lt;p>이 방법은 빠른 속도를 보장하지만 &lt;strong>모든 데이터를 메모리안에 두는 것이 불가능&lt;/strong>할 수도 있다.&lt;/p>
&lt;p>이 문제의 개선책은 다음과 같은 것들이 있다.&lt;/p>
&lt;ul>
&lt;li>데이터 압축&lt;/li>
&lt;li>자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장&lt;/li>
&lt;/ul>
&lt;p>이렇게 개선한다고 해도, 한 대 서버로 부족한 때가 찾아오며, 많은 데이터를 저장하기 위해서 &lt;strong>분산 키-값 저장소&lt;/strong>를 만들어야한다.&lt;/p>
&lt;h2 id="분산-키-값-저장소">분산 키 값 저장소&lt;/h2>
&lt;p>분산 키 값 저장소는 키-값 쌍을 여러 서버에 분산시키므로 &lt;strong>분산 해시 테이블&lt;/strong>이라고도 불린다.&lt;/p>
&lt;p>분산 시스템을 설계할 때는 &lt;strong>CAP 정리&lt;/strong>(Consistency, Availability, Partition Tolerance theorem)를 이해하고 있어야 한다.&lt;/p>
&lt;h3 id="cap-정리">CAP 정리&lt;/h3>
&lt;p>CAP 정리는 &lt;strong>데이터 일관성(consistency), 가용성(availability), 파티션 감내(partition tolerance)라는 세가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다&lt;/strong>는 정리이다.&lt;/p>
&lt;ul>
&lt;li>데이터 일관성
&lt;ul>
&lt;li>분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성
&lt;ul>
&lt;li>분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파티션 감내
&lt;ul>
&lt;li>파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다.&lt;/li>
&lt;li>네트워크에 파티션(분할)이 생기더라도 시스템은 계속 동작하여야 한다는 것을 뜻한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>네트워크 파티션?&lt;/strong>&lt;br>
테이터베이스 시스템의 일부 노드들이 서로 통신할 수 없는 상황으로 인해 각 노드들(파티션)이 독립적으로 동작하게 되어 각 파티션이 서로 다른 상태나 데이터를 가지게 되는 상황&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img.png"
width="828"
height="608"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_hu8399b985eaaab4d8c3cc5e2bfd3651de_149592_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_hu8399b985eaaab4d8c3cc5e2bfd3651de_149592_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="326px"
>&lt;/p>
&lt;p>따라서 이들 가운데 &lt;strong>어떤 두 가지를 충족하려면 나머지 하나는 반드시 희생되어야 한다&lt;/strong>는 것을 의미한다.&lt;/p>
&lt;p>키 값 저장소는 세 가지 요구사항 가운데 어느 두 가지를 만족하느냐에 따라 다음과 같이 분류할 수 있다.&lt;/p>
&lt;ul>
&lt;li>CP: 일관성과 파티션 감내를 지원(가용성 희생)&lt;/li>
&lt;li>AP: 가용성과 파티션 감내를 지원(데이터 일관성 희생)&lt;/li>
&lt;li>CA: 일관성과 가용성을 지원(파티션 감내 지원 안함)
&lt;ul>
&lt;li>통상 네트워크 장애는 피할 수 없는 일로 여겨지므로, 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야 한다.&lt;/li>
&lt;li>실세계에서 CA 시스템은 존재하지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="구체적-사례">구체적 사례&lt;/h3>
&lt;p>분산 시스템에서 데이터는 보통 여러 노드에 복제되어 보관된다.&lt;/p>
&lt;h4 id="이상적-상태">이상적 상태&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_1.png"
width="840"
height="592"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_1_hua0faa9aa952f92ab7c5a2fe27ee0e7c0_91753_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_1_hua0faa9aa952f92ab7c5a2fe27ee0e7c0_91753_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="340px"
>&lt;/p>
&lt;p>이상적인 환경이라면 &lt;strong>네트워크가 파티션되는 상황은 절대로 일어나지 않을 것&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>n1&lt;/strong>에 기록된 데이터는 자동적으로 &lt;strong>n2&lt;/strong>, &lt;strong>n3&lt;/strong>에 복제되며 데이터 일관성과 가용성도 만족한다.&lt;/li>
&lt;/ul>
&lt;h4 id="실세계의-분산-시스템">실세계의 분산 시스템&lt;/h4>
&lt;p>분산 시스템은 파티션 문제를 피할 수 없다.&lt;/p>
&lt;p>파티션 문제가 발생하면 &lt;strong>일관성과 가용성 사이에서 하나를 선택&lt;/strong>해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_2.png"
width="839"
height="605"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_2_hud8043c96815985a7c6b0f4ed2ff33b87_103442_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_2_hud8043c96815985a7c6b0f4ed2ff33b87_103442_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="138"
data-flex-basis="332px"
>&lt;/p>
&lt;p>&lt;strong>n3&lt;/strong>에 장애가 발생하여 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>와 통신 할 수 없는 상황에서&lt;/p>
&lt;ul>
&lt;li>클라이언트가 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>에 기록한 데이터는 &lt;strong>n3&lt;/strong>에 전달되지 않는다.&lt;/li>
&lt;li>&lt;strong>n3&lt;/strong>에 기록되었으나 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>로 전달되지 않은 데이터가 있다면 오래된 사본을 갖고 있을 것이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>CP 시스템&lt;/strong>&lt;/p>
&lt;p>가용성 대신 일관성을 선택한다면 세 서버 사이에 생길 수 있는 데이터 불일치 문제를 피하기 위해 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>에 대해 &lt;strong>쓰기 연산을 중단&lt;/strong>시켜야한다.&lt;/p>
&lt;p>이러한 경우 일부 노드가 장애가 발생하여도 동작해야 한다는 가용성이 깨진다.&lt;/p>
&lt;p>데이터 일관성을 양보할 수 없는 시스템은 이렇게 처리되어 상황이 해결될 때 까지 오류를 반환해야 한다.&lt;/p>
&lt;ul>
&lt;li>온라인 뱅킹 등&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>AP 시스템&lt;/strong>&lt;/p>
&lt;p>일관성 대신 가용성을 선택한 시스템은 &lt;strong>낡은 데이터를 반환할 위험이 있더라도 계속 읽기 연산을 허용&lt;/strong>해야한다.&lt;/p>
&lt;p>&lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>는 계속 쓰기 연산을 허용하고, 파티션 문제가 해결된 뒤 새 데이터를 &lt;strong>n3&lt;/strong>에 전송해야한다.&lt;/p>
&lt;hr>
&lt;p>분산 키-값 저장소를 만들 때는 그 요구사항에 맞도록 CAP 정리를 적용해야 한다.&lt;/p>
&lt;p>면접 상황에서는 이 문제에 대해 면접관과 상의하고, 그 결론에 따라 시스템을 설계하도록 하자.&lt;/p>
&lt;h3 id="시스템-컴포넌트">시스템 컴포넌트&lt;/h3>
&lt;p>키-값 저장소 구형에 사용되는 핵심 컴포넌트들 및 기술을 살펴본다.&lt;/p>
&lt;ul>
&lt;li>데이터 파티션&lt;/li>
&lt;li>데이터 다중화&lt;/li>
&lt;li>일관성&lt;/li>
&lt;li>일관성 불일치 해소&lt;/li>
&lt;li>장애 처리&lt;/li>
&lt;li>시스템 아키텍처 다이어그램&lt;/li>
&lt;li>쓰기 경로&lt;/li>
&lt;li>읽기 경로&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-파티션">데이터 파티션&lt;/h4>
&lt;p>대규모 애플리케이션의 경우 전체 데이터를 한 대 서버에 욱여넣는 것은 불가능하다.&lt;/p>
&lt;p>가장 단순한 해결책은 &lt;strong>데이터를 작은 파티션들로 분할한 다음 여러 대 서버에 저장하는 것&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>데이터를 여러 서버에 고르게 분산할 수 있는가&lt;/li>
&lt;li>노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가&lt;/li>
&lt;/ul>
&lt;p>5장에서 다룬 안정 해시는 이런 문제를 푸는 데 적합한 기술로 활용될 수 있다.&lt;/p>
&lt;p>안정 해시를 사용하여 데이터를 파티션하면 몇가지 장점이 있다.&lt;/p>
&lt;ul>
&lt;li>규모 확장 자동화(automatic scaling)
&lt;ul>
&lt;li>시스템 부하에 따라 서버가 자동으로 추가되거나 삭제되도록 만들 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다양성(heterogeneity)
&lt;ul>
&lt;li>각 서버의 용량에 맞게 가상 노드의 수를 조정할 수 있다.&lt;/li>
&lt;li>고성능 서버는 더 많은 가상노드를 갖도록&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-다중화">데이터 다중화&lt;/h4>
&lt;p>높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있다.&lt;/p>
&lt;p>어떤 키를 해시 링 위에 배치한 수, 그 지점으로부터 시계 방향으로 링을 순회하면서 만나는 첫 N개 서버에 데이터 사본을 보관한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_3.png"
width="843"
height="685"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_3_hu0675f294d26db8b4acf424a88b68b693_77163_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_3_hu0675f294d26db8b4acf424a88b68b693_77163_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="123"
data-flex-basis="295px"
>&lt;/p>
&lt;p>하지만 가상 노드를 사용한다면 선택한 N개의 노드가 대응될 실제 물리 서버의 개수가 N보다 작아질 수 있다.&lt;/p>
&lt;p>이 문제를 피하려면 노드를 선택할 때 같은 물리 서버를 중복으로 선택하지 않도록 해야한다.&lt;/p>
&lt;p>같은 데이터 센터에 속한 노드는 정전, 네트워크 이슈, 자연 재해 등의 문제를 동시에 같이 겪을 가능성이 있으므로, 안정성을 담보하기 위해 데이터의 사본은 다른 센터의 서버에 보관하고, 센터들은 고속 네트워크로 연결한다.&lt;/p>
&lt;h4 id="데이터-일관성">데이터 일관성&lt;/h4>
&lt;p>여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 한다.&lt;/p>
&lt;p>&lt;strong>정족수 합의&lt;/strong>(Quorum Consensus) 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>N&lt;/code>: 사본의 개수&lt;/li>
&lt;li>&lt;code>W&lt;/code>: 쓰기 연산에 대한 정족수
&lt;ul>
&lt;li>쓰기 연산이 성공한 것으로 간주되려면 적어도 &lt;code>W&lt;/code>개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R&lt;/code>: 읽기 연산에 대한 정족수
&lt;ul>
&lt;li>읽기 연산이 성공한 것으로 간주되려면 적어도 &lt;code>R&lt;/code>개의 서버로부터 응답을 받아야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>일반적으로 &lt;code>N = R + W &amp;gt; N&lt;/code> 조건을 만족하도록 설정하며, 읽기와 쓰기 요청이 적어도 하나의 공통 노드를 통해 일관성을 유지하도록 보장한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_4.png"
width="839"
height="579"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_4_huec6b456c1e9a98e57b711c077ef003c7_99493_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_4_huec6b456c1e9a98e57b711c077ef003c7_99493_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="N = 3"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;p>&lt;code>W = 1&lt;/code>는 쓰기 연산이 성공했다고 판단하기 위해 중재자(coordinator)는 최소 한 대 서버로부터 쓰기 성공 응답을 받아야한다는 뜻이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>s1&lt;/strong>으로 부터 성공 응답을 받았다면, 나머지 응답은 기다릴 필요가 없다.&lt;/li>
&lt;/ul>
&lt;p>중재자는 클라이언트와 노드 사이에서 프락시(proxy)역할을 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;code>W&lt;/code>, &lt;code>R&lt;/code>, &lt;code>N&lt;/code>의 값을 정하는 것은 응답 지연과 데이터 일관성 사이의 타협점을 찾는 전형정인 과정이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>W = 1&lt;/code> or &lt;code>R = 1&lt;/code>
&lt;ul>
&lt;li>중재자는 한 대 서버로부터의 응답만 받으면 되므로 응답속도는 빠르다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>W &amp;gt; 1&lt;/code> or &lt;code>R &amp;gt; 1&lt;/code>
&lt;ul>
&lt;li>데이터 일관성의 수준은 향상되지만 중재자의 응답 속도는 가장 느린 서버로부터의 응답을 기다려야 하므로 느려진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>따라서 &lt;code>W + R &amp;gt; N&lt;/code>인 경우에는 일관성을 보증할 최신 데이터를 가진 노드가 최소 하나는 겹치므로 강한 일관성이 보장된다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>R = 1&lt;/code>, &lt;code>W = N&lt;/code>
&lt;ul>
&lt;li>빠른 읽기 연산에 최적화된 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R = N&lt;/code>, &lt;code>W = 1&lt;/code>
&lt;ul>
&lt;li>빠른 쓰기 연산에 최적화된 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R + W &amp;gt; N&lt;/code>
&lt;ul>
&lt;li>강한 일관성이 보장됨
&lt;ul>
&lt;li>보통 &lt;code>N = 3&lt;/code>, &lt;code>W = R = 2&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R + W &amp;lt;= N&lt;/code>
&lt;ul>
&lt;li>강한 일관성이 보장되지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>요구되는 일관성 수준에 따라 &lt;code>W&lt;/code>, &lt;code>R&lt;/code>, &lt;code>N&lt;/code> 값을 조정한다.&lt;/p>
&lt;p>&lt;strong>일관성 모델&lt;/strong>&lt;/p>
&lt;p>일관성 모델(consistency model)은 키-값 저장소를 설계할 때 고려해야 할 요소로 데이터 일관성 수준을 결정한다.&lt;/p>
&lt;ul>
&lt;li>강한 일관성
&lt;ul>
&lt;li>모든 읽기 연산은 최신 결과를 반환한다.&lt;/li>
&lt;li>클라이언트는 절대로 낡은 데이터를 볼 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>약한 일관성
&lt;ul>
&lt;li>읽기 연산은 최신 결과를 반환하지 못할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>결과적 일관성
&lt;ul>
&lt;li>약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영(동기화)된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>강한 일관성&lt;/strong>을 달성하는 일반적인 방법은, &lt;strong>모든 사본에 현재 쓰기 연산의 결과가 반영될 때까지 해당 데이터에 대한 읽기/쓰기를 금지&lt;/strong>하는 것이다.&lt;/p>
&lt;ul>
&lt;li>새로운 요청의 처리가 중단되므로 고 가용성 시스템에는 적합하지 않다.&lt;/li>
&lt;/ul>
&lt;p>다이나모 또는 카산드라 같은 저장소는 결과적 일관성 모델을 택하고 있다.&lt;/p>
&lt;ul>
&lt;li>결과적 일관성 모델을 따를 경우 &lt;strong>쓰기 연산이 병렬적으로 발생하면 시스템에 저장된 값의 일관성이 깨어질 수 있는데&lt;/strong>, 이 문제는 클라이언트가 해결해야한다.&lt;/li>
&lt;li>클라이언트 측에서 데이터의 버전 정보를 활용해 일관성이 깨진 데이터를 읽지 않도록 해야한다.&lt;/li>
&lt;/ul>
&lt;p>데이터를 다중화하면 가용성은 높아지지만 사본 간 일관성이 깨질 가능성은 높아진다.&lt;/p>
&lt;p>&lt;strong>비 일관성 해소 기법: 데이터 버저닝&lt;/strong>&lt;/p>
&lt;p>버저닝은 데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만든다.&lt;/p>
&lt;ul>
&lt;li>각 버전은 변경 불가능하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_5.png"
width="838"
height="387"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_5_hu314294c50ed1dac3bf6da051bfbc696c_78353_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_5_hu314294c50ed1dac3bf6da051bfbc696c_78353_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="충돌하는 두 값"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="519px"
>&lt;/p>
&lt;p>서버 1, 2가 다른 노드의 같은&lt;code>name&lt;/code>의 값을 동시에 변경하여 충돌이 발생했다고 가정했을 때 각각을 버전 &lt;strong>v1&lt;/strong>, &lt;strong>v2&lt;/strong>로 볼 수 있다.&lt;/p>
&lt;p>이러한 충돌 문제를 해결하려면, 충돌을 발견하고 자동으로 해결해 낼 버저닝 시스템이 필요하다.&lt;/p>
&lt;p>&lt;strong>백터 시계&lt;/strong>(vector clock)는 &lt;strong>&lt;code>[서버, 버전]&lt;/code>의 순서 쌍을 데이터에 매단 것&lt;/strong>으로 충돌 문제를 푸는데 보편적으로 사용된다.&lt;/p>
&lt;ul>
&lt;li>어떤 버전이 선행 버전인지, 후행 버전인지, 충돌이 있는지 판별하는 데 쓰인다.&lt;/li>
&lt;/ul>
&lt;p>데이터 D를 서버 &lt;strong>Si&lt;/strong>에 기록하려면 아래 작업 가운데 하나를 수행해야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>[Si, Vi]&lt;/code>가 있으면 &lt;code>Vi&lt;/code>를 증가시킨다.&lt;/li>
&lt;li>그렇지 않다면 새 항목 &lt;code>[Si, 1]&lt;/code>을 만든다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_6.png"
width="717"
height="798"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_6_hu4d508b5e0485ac8ed5a6f6afc4aa05b9_112910_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_6_hu4d508b5e0485ac8ed5a6f6afc4aa05b9_112910_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="백터 시계"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="215px"
>&lt;/p>
&lt;ol>
&lt;li>클라이언트가 &lt;code>D1&lt;/code>을 시스템에 기록한다.
&lt;ul>
&lt;li>처리한 서버는 &lt;code>Sx&lt;/code>이므로 백터 시계는 &lt;code>D1[Sx, 1]&lt;/code>으로 변한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다른 클라이언트가 &lt;code>D1&lt;/code>을 읽고 &lt;code>D2&lt;/code>로 업데이트한 다음 기록한다.
&lt;ul>
&lt;li>&lt;code>D2&lt;/code>는 &lt;code>D1&lt;/code>의 변경이므로 덮어쓴다.&lt;/li>
&lt;li>&lt;code>Sx&lt;/code>가 처리했으므로 벡터 시계를 &lt;code>D2[Sx, 2]&lt;/code>로 변경한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다른 클라이언트가 &lt;code>D2&lt;/code>를 읽어 &lt;code>D3&lt;/code>로 갱신한 다음 기록한다.
&lt;ul>
&lt;li>&lt;code>Sy&lt;/code>가 처리했으므로 백터 시계 상태는 &lt;code>D3([Sx, 2], [Sy, 1])&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>또 다른 클라이언트가 &lt;code>D2&lt;/code>를 읽고 &lt;code>D4&lt;/code>로 갱신한 후 기록한다.
&lt;ul>
&lt;li>&lt;code>Sz&lt;/code>가 처리했으므로 백터 시계 상태는 &lt;code>D4([Sx, 2], [Sz, 1])&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>어떤 클라이언트가 D3과 D4를 읽으면 데이터 간 충돌이 있다는 것을 알게 되므로, 클라이언트가 해소한 후 서버에 기록한다.
&lt;ul>
&lt;li>&lt;code>Sx&lt;/code>가 처리했으므로 백터 시계는 &lt;code>D5([Sx, 3], [Sy, 1], [Sz, 1])&lt;/code>로 바뀐다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>벡터 시계를 이용하면 버전 Y에 포함된 모든 구성 요소의 값이 X에 포함된 모든 구성요소 값보다 같거나 큰지만 확인하면 어떤 버전 X가 버전 Y의 이전 버전인지 쉽게 판단할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>D([s0, 1], [s1, 1])&lt;/code>은 &lt;code>D([s0, 1], [s1, 2])&lt;/code>보다 이전 버전이다.(충돌 X)&lt;/li>
&lt;/ul>
&lt;p>어떤 버전 X와 Y 사이에 충돌이 있는지 보려면 &lt;strong>Y의 벡터 시계 구성 요소 가운데 X의 벡터 시계 동일 서버 구성요소보다 작은 값을 갖는 것이 있는지 확인&lt;/strong>한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>D([s0, 1], [s1, 2])&lt;/code>, &lt;code>D([s0, 2], [s1, 1])&lt;/code>는 서로 충돌한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>벡터 시계를 통해 충돌 감지하고 해소하는 방법에는 두 가지 단점이 있다.&lt;/p>
&lt;ul>
&lt;li>충돌 감지 및 해소 로직이 클라이언트에 들어가야 하므로, 클라이언트 구현이 복잡해진다.&lt;/li>
&lt;li>&lt;code>[서버: 버전]&lt;/code>의 순서쌍 개수가 굉장히 빨리 늘어난다.
&lt;ul>
&lt;li>순서쌍 개수에 임계치를 설정하고, 임계치 이상으로 길이가 길어지면 오래된 순서쌍을 백터 시계에서 제거한다.&lt;/li>
&lt;li>버전 간 선후 관계가 정확하게 결정될 수 없으므로 충돌 해소 과정의 효율성이 낮아질 수 있다.&lt;/li>
&lt;li>실제 서비스에서 그런 문제는 거의 발생하지 않으므로, 대부분 기업에서 괜찮다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="장애-처리">장애 처리&lt;/h4>
&lt;p>대규모 시스템에서 장애는 아주 흔하게 벌어지므로 장애를 어떻게 처리할 것이냐 하는 것은 굉장히 중요한 문제이다.&lt;/p>
&lt;h4 id="장애-감지">장애 감지&lt;/h4>
&lt;p>분산 시스템에서는 서버 A에 문제가 생겼을 때 바로 장애를 처리하지 않고, 보통 두 대 이상의 서버가 똑같이 서버 A에 대해 장애를 보고해야 해당 서버에 실제로 장애가 발생했다고 간주한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_7.png"
width="838"
height="636"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_7_hu135f183e800718526af99039ce9e186b_156879_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_7_hu135f183e800718526af99039ce9e186b_156879_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="멀티캐스팅 채널 구축"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="316px"
>&lt;/p>
&lt;p>모든 노드 사이에 멀티캐스팅 채널을 구축하는 것이 서버 장애를 감지하는 손쉬운 방법이나, 이 방법은 서버가 많을 때 비효율적이다.&lt;/p>
&lt;p>따라서 &lt;strong>가십 프로토콜&lt;/strong>(gossip protocol) 같은 분산형 장애 감지 솔루션을 채택하는 편이 보다 효율적이다.&lt;/p>
&lt;ul>
&lt;li>각 노드는 맴버십 목록을 유지한다.
&lt;ul>
&lt;li>맴버십 목록: 각 맴버 ID와 그 박동 카운터(heartbeat counter) 쌍의 목록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 노드는 주기적으로 자신의 박동 카운터를 증가시킨다.&lt;/li>
&lt;li>각 노드는 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터 목록을 보낸다.&lt;/li>
&lt;li>박동 카운터 목록을 받은 노드는 맴버십 목록을 최신 값으로 갱신한다.&lt;/li>
&lt;li>어떤 맴버의 박동 카운터 값이 지정된 시간 동안 갱신되지 않으면 해당 멤버는 장애 상태인 것으로 간주한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_8.png"
width="839"
height="382"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_8_hu90da88e3e0d0b1a6937865c76380943d_88593_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_8_hu90da88e3e0d0b1a6937865c76380943d_88593_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="가십 프로토콜"
class="gallery-image"
data-flex-grow="219"
data-flex-basis="527px"
>&lt;/p>
&lt;h4 id="일시적-장애-처리">일시적 장애 처리&lt;/h4>
&lt;p>장애를 감지한 시스템은 가용성을 보장하기 위해 필요한 조치를 해야한다.&lt;/p>
&lt;ul>
&lt;li>엄격한 정족수 접근법은 읽기와 쓰기 연산을 금지한다.&lt;/li>
&lt;li>느슨한 정족수 접근법은 쓰기 연산을 수행할 W개의 건강한 서버와 읽기 연산을 수행할 R개의 건강한 서버를 해시 링에서 고른다.(장애 서버는 무시)&lt;/li>
&lt;li>장애 상태인 서버로 가는 요청은 다른 서버가 잠시 맡아 처리한다.&lt;/li>
&lt;li>그동안 발생한 변경 사항은 장애 서버가 복구 되었을 때 일괄 반영하여 데이터 일관성을 보존한다.
&lt;ul>
&lt;li>임시로 쓰기 연산을 처리한 서버에는 그에 관한 단서를 남겨둔다.&lt;/li>
&lt;li>단서 후 임시 위탁(hinted handoff)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_9.png"
width="834"
height="718"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_9_hu115bfa1d5fe40c44de379ba88e53d6c2_127770_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_9_hu115bfa1d5fe40c44de379ba88e53d6c2_127770_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="116"
data-flex-basis="278px"
>&lt;/p>
&lt;p>장애 상태인 s2에 대한 읽기 및 쓰기 연산은 일시적으로 s3가 처리하며, s2가 복구되면 s3는 갱신된 데이터를 s2로 인계한다.&lt;/p>
&lt;h4 id="영구-장애-처리">영구 장애 처리&lt;/h4>
&lt;p>영구적인 노드의 장애 상태는 반-엔트로피(anti-entropy) 프로토콜을 구현하여 사본들을 동기화한다.&lt;/p>
&lt;p>반-엔트로피 프로토콜은 &lt;strong>사본들을 비교하여 최신 버전으로 갱신하는 과정을 포함&lt;/strong>한다.&lt;/p>
&lt;p>사본 간의 일관성이 망가진 상태를 탐지하고 전송 데이터의 양을 줄이기 위해서 머클(Merkle) 트리를 사용한다.&lt;/p>
&lt;blockquote>
&lt;p>머클 트리?&lt;br>
해시 트리라고 불리는 머클 트리는 각 노드에 그 자식 노드들의 보관된 값의 해시(자식 노드가 leaf인 경우) 또는 자식 노드들의 레이블로부터 계산된 해시 값을 레이블로 붙여두는 트리&lt;/p>
&lt;/blockquote>
&lt;p>해시 트리를 사용하면 &lt;strong>대규모 자료 구조의 내용을 효과적이면서도 보안상 안전한 방법으로 검증&lt;/strong>할 수 있다.&lt;/p>
&lt;p>&lt;strong>1 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_10.png"
width="844"
height="330"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_10_hu458e95c99f7dfcfac03b6157ee8c6e5b_44753_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_10_hu458e95c99f7dfcfac03b6157ee8c6e5b_44753_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="255"
data-flex-basis="613px"
>&lt;/p>
&lt;p>키 공간을 버킷으로 나눈다.&lt;/p>
&lt;p>&lt;strong>2 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_11.png"
width="842"
height="182"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_11_hu5646976f70d14d2033d017e53694f064_41493_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_11_hu5646976f70d14d2033d017e53694f064_41493_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="462"
data-flex-basis="1110px"
>&lt;/p>
&lt;p>버킷에 포함된 각각의 키에 균등 분포 해시 함수를 적용하여 해시 값을 계산한다.&lt;/p>
&lt;p>&lt;strong>3 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_12.png"
width="839"
height="260"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_12_hu38a58b95ad281add1c37ca9db00d3b58_73545_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_12_hu38a58b95ad281add1c37ca9db00d3b58_73545_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="322"
data-flex-basis="774px"
>&lt;/p>
&lt;p>버킷 별로 해시값을 계산한 후, 해당 해시 값을 레이블로 갖는 노드를 만든다.&lt;/p>
&lt;p>&lt;strong>4 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_13.png"
width="840"
height="445"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_13_hu8894cdbe47f2eb2880a4148ac1861de4_101648_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_13_hu8894cdbe47f2eb2880a4148ac1861de4_101648_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;p>자식 노드의 레이블로부터 새로운 해시값을 계산하여, 이진 트리를 상향식으로 구성해 나간다.&lt;/p>
&lt;hr>
&lt;p>두 머클 트리의 비교는 루트 노드의 해시값을 비교하는 것으로 시작하며, 다른 데이터를 갖는 버킷을 찾을 경우 그 버킷들만 동기화한다.&lt;/p>
&lt;p>머클 트리를 사용하면 동기화해야 하는 데이터 양은 실제로 존재하는 차이의 크기에 비례할 뿐, 두 서버에 보관된 데이터의 총량과는 무관해진다.&lt;/p>
&lt;ul>
&lt;li>실제로 쓰이는 시스템의 경우 버킷 하나의 크기가 꽤 크다.&lt;/li>
&lt;li>10억(1B) 개의 키를 백만(1M) 개의 버킷으로 관리하면, 하나의 버킷은 1,000개 키를 관리한다.&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-센터-장애-처리">데이터 센터 장애 처리&lt;/h4>
&lt;p>데이터 센터 장애는 정전, 네트워크 장애, 자연재해 등 다양한 이유로 발생할 수 있다.&lt;/p>
&lt;p>데이터 센터의 장애에 대응할 수 있는 시스템을 만드려면 데이터를 여러 데이터 센터에 다중화하는 것이 중요하다.&lt;/p>
&lt;h3 id="시스템-아키텍처-다이어그램">시스템 아키텍처 다이어그램&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_14.png"
width="842"
height="525"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_14_hu3a1f1cde060e244af1e3932a5858e642_94830_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_14_hu3a1f1cde060e244af1e3932a5858e642_94830_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="384px"
>&lt;/p>
&lt;ul>
&lt;li>클라이언트는 키-값 저장소가 제공하는 두 가지 단순한 API, &lt;code>get(key)&lt;/code>, &lt;code>put(key, value)&lt;/code>와 통신한다.&lt;/li>
&lt;li>중재자는 클라이언트에게 키-값 저장소에 대한 프락시 역할을 하는 노드다.&lt;/li>
&lt;li>노드는 안정 해시의 해시 링 위에 분포한다.&lt;/li>
&lt;li>노드를 자동으로 추가 또는 삭제할 수 있도록, 시스템은 완전히 분산된다.&lt;/li>
&lt;li>데이터는 여러 노드에 다중화된다.&lt;/li>
&lt;li>모든 노드가 같은 책임을 지므로, SPOF(Single Point of Failure)는 존재하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_15.png"
width="830"
height="656"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_15_hud90111428b56169725aae5ee0bdfc804_100802_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_15_hud90111428b56169725aae5ee0bdfc804_100802_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="303px"
>&lt;/p>
&lt;p>완전히 분산된 설계를 채택하였으므로 모든 노드는 제시된 기능을 전부 지원해야한다.&lt;/p>
&lt;h3 id="쓰기-경로">쓰기 경로&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_16.png"
width="845"
height="458"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_16_hu216694585a97b0bfbb508eaee3fd8e8a_77802_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_16_hu216694585a97b0bfbb508eaee3fd8e8a_77802_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="카산드라의 사례"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/p>
&lt;ol>
&lt;li>쓰기 요청이 커밋 로그 파일에 기록된다.&lt;/li>
&lt;li>데이터가 메모리 캐시에 기록된다.&lt;/li>
&lt;li>메모리 캐시가 가득 차거나 사전에 정의된 임계치에 도달하면 데이터는 디스크에 있는 SSTable에 기록된다.
&lt;ul>
&lt;li>SSTable: Sorted-String Table의 약어로 &amp;lt;키, 값&amp;gt; 의 순서쌍을 정렬된 리스트로 관리하는 테이블이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="읽기-경로">읽기 경로&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_17.png"
width="845"
height="446"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_17_huaac619f90ef719991892748c739fd616_71124_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_17_huaac619f90ef719991892748c739fd616_71124_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="189"
data-flex-basis="454px"
>&lt;/p>
&lt;p>읽기 요청을 받은 노드는 데이터가 메모리 캐시에 있는지부터 살핀 후 데이터를 클라이언트에게 반환한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_18.png"
width="843"
height="425"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_18_hub84a0c909dfc6b10b41bdf7efd5bb775_89775_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_18_hub84a0c909dfc6b10b41bdf7efd5bb775_89775_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="476px"
>&lt;/p>
&lt;p>데이터가 메모리에 없는 경우 디스크에서 가져온다.&lt;/p>
&lt;p>어느 SSTable에 찾는 키가 있는지 효율적으로 찾기 위해 블룸 필터(Bloom filter)가 흔히 사용된다.&lt;/p>
&lt;ol>
&lt;li>데이터가 메모리에 있는지 검사하고 있다면 반환한다.&lt;/li>
&lt;li>데이터가 메모리에 없으므로 블룸 필터를 검사한다.&lt;/li>
&lt;li>블룸 필터를 통해 어떤 SSTable에 키가 보관되어 있는지 알아낸다.&lt;/li>
&lt;li>SSTable에서 데이터를 가져온다.&lt;/li>
&lt;li>해당 데이터를 클라이언트에게 반환한다.&lt;/li>
&lt;/ol>
&lt;h2 id="요약">요약&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>목표/문제&lt;/th>
&lt;th>기술&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>대규모 데이터 저장&lt;/td>
&lt;td>안정 해시를 사용해 서버들에 부하 분산&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>읽기 연산에 대한 높은 가용성 보장&lt;/td>
&lt;td>데이터를 여러 데이터센터에 다중화&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>쓰기 연산에 대한 높은 가용성 보장&lt;/td>
&lt;td>버저닝 및 백터 시계를 사용한 충돌 해소&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 파티션&lt;/td>
&lt;td>안정 해시&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>점진적 규모 확장성&lt;/td>
&lt;td>안정 해시&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>다양성(heterogeneity)&lt;/td>
&lt;td>안정 해시&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>조절 가능한 데이터 일관성&lt;/td>
&lt;td>정족수 합의(quorum consensus)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>일시적 장애 처리&lt;/td>
&lt;td>느슨한 정족수 프로토콜(sloppy quorum)과 단서 후 임시 위탁(hinted handoff)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>영구적 장애 처리&lt;/td>
&lt;td>머클 트리(Merkle tree)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 센터 장애 대응&lt;/td>
&lt;td>여러 데이터 센터에 걸친 데이터 다중화&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>5. 안정 해시 설계</title><link>https://codemario318.github.io/post/system-design-interview/5/</link><pubDate>Thu, 23 May 2024 12:04:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/5/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/cover.png" alt="Featured image of post 5. 안정 해시 설계" />&lt;p>&lt;strong>수평적 규모 확장성&lt;/strong>을 달성하기 위해서는 요청 또는 데이터를 서버에 &lt;strong>균등하게 나누는 것&lt;/strong>이 중요하다.&lt;/p>
&lt;p>&lt;strong>안정 해시&lt;/strong>는 이 목표를 달성하기 위해 보편적으로 사용하는 기술이다.&lt;/p>
&lt;h2 id="해시-키-재배치rehash-문제">해시 키 재배치(rehash) 문제&lt;/h2>
&lt;p>N개의 캐시 서버가 있을 때, 부하를 균등하게 나누는 보편적 방법은 해시 함수를 사용하는 것이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">serverIndex = hash(key) % N
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>총 4대의 서버를 사용한다면, 주어진 각각의 키에 대해 아래와 같이 계산될 수 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>키&lt;/th>
&lt;th>해시&lt;/th>
&lt;th>해시 % 4(서버 인덱스)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>key0&lt;/td>
&lt;td>18358617&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key1&lt;/td>
&lt;td>26143584&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key2&lt;/td>
&lt;td>18131146&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key3&lt;/td>
&lt;td>35863496&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key4&lt;/td>
&lt;td>34085809&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key5&lt;/td>
&lt;td>27581703&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key6&lt;/td>
&lt;td>38164978&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key7&lt;/td>
&lt;td>22530351&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>키 값을 해싱한 값에 나머지 연산을 하여 저장될 서버가 결정된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img.png"
width="597"
height="323"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_hu8ecb82b93ef83548a97acf28dacc70e3_47080_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_hu8ecb82b93ef83548a97acf28dacc70e3_47080_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="443px"
>&lt;/p>
&lt;p>이 방식은 &lt;strong>서버 풀의 크기가 고정되어 있을 때&lt;/strong>, &lt;strong>데이터 분포가 균등할 때&lt;/strong> 잘 동작한다.&lt;/p>
&lt;p>하지만 서버가 추가되거나, 기존 서버가 삭제되면 나머지 연산 결과 값이 변하기 때문에 문제가 발생한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>키&lt;/th>
&lt;th>해시&lt;/th>
&lt;th>해시 % 3(서버 인덱스)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>key0&lt;/td>
&lt;td>18358617&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key1&lt;/td>
&lt;td>26143584&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key2&lt;/td>
&lt;td>18131146&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key3&lt;/td>
&lt;td>35863496&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key4&lt;/td>
&lt;td>34085809&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key5&lt;/td>
&lt;td>27581703&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key6&lt;/td>
&lt;td>38164978&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key7&lt;/td>
&lt;td>22530351&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>따라서 아래와 같은 형태로 키의 분포가 바뀐다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_1.png"
width="595"
height="375"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_1_hu221148814a934c0ed66cfef734ebb8e4_56907_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_1_hu221148814a934c0ed66cfef734ebb8e4_56907_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="158"
data-flex-basis="380px"
>&lt;/p>
&lt;p>장애가 발생한 1번 서버에 보관되어 있는 키 뿐만 아닌 대부분의 키가 재분배되어, 대부분 캐시 클라이언트가 데이터가 없는 서버에 접속하게된다.&lt;/p>
&lt;p>이로 인해 대규모 캐시 미스가 발생하게되는데, &lt;strong>안정 해시&lt;/strong>는 이러한 문제를 효과적으로 해결하는 방식이다.&lt;/p>
&lt;h2 id="안정-해시">안정 해시&lt;/h2>
&lt;p>안정 해시는 &lt;strong>해시 테이블 크기가 조정될 때 평균적으로 &lt;code>k/n&lt;/code>개의 키만 재비치하는 해시 기술&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>k&lt;/code>: 키의 개수&lt;/li>
&lt;li>&lt;code>n&lt;/code>: 슬롯의 개수&lt;/li>
&lt;/ul>
&lt;p>이와는 달리 대부분의 전통적인 해시 테이블은 슬롯의 수가 바뀌면 거의 대부분 키를 재배치한다.&lt;/p>
&lt;h3 id="해시-공간과-해시-링">해시 공간과 해시 링&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>SHA-1&lt;/strong> 해시함수를 사용하며, 출력 값의 범위는 &lt;code>x0, x1 ... xn&lt;/code>이라고 가정한다.&lt;/li>
&lt;li>&lt;strong>SHA-1&lt;/strong>의 해시 공간(hash space) 범위는 &lt;strong>0 부터 &lt;code>2^160 - 1&lt;/code>&lt;/strong> 까지라고 알려져 있다.&lt;/li>
&lt;/ul>
&lt;p>따라서 &lt;code>x0 = 0&lt;/code>, &lt;code>xn -1 = 2^160 - 1&lt;/code>이며, 두 수 사이의 값을 갖게 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_2.png"
width="239"
height="284"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_2_huf4d0b3acc8d8378f9f6d7202b468ee24_14360_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_2_huf4d0b3acc8d8378f9f6d7202b468ee24_14360_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="84"
data-flex-basis="201px"
>&lt;/p>
&lt;p>이 해시 공간의 양쪽을 연결하변 해시 링이 만들어진다.&lt;/p>
&lt;h3 id="해시-서버">해시 서버&lt;/h3>
&lt;p>해시 함수 &lt;code>f&lt;/code>를 사용하면 서버(IP, 이름 등)를 링 위의 어딘가에 대응시킬 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_3.png"
width="607"
height="421"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_3_hu0bc48cf4515b95e87de880bf1aab9c60_55336_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_3_hu0bc48cf4515b95e87de880bf1aab9c60_55336_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="346px"
>&lt;/p>
&lt;h3 id="해시-키">해시 키&lt;/h3>
&lt;blockquote>
&lt;p>안정 해시에서 사용되는 해시 함수는 전통적인 해시 키 방식에서 언급된 방식과 다르며, 만들어질 수 있는 모든 해시 공간 &lt;code>x0 ... xn&lt;/code>을 연결한 형태이므로 나머지 연산을 사용하지 않는다.&lt;/p>
&lt;/blockquote>
&lt;p>캐시할 키 또한 서버와 함께 해시 링 위의 어느 지점에 배치할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_4.png"
width="606"
height="390"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_4_hu2fcefd9766a218d8cface53baa2bca15_61260_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_4_hu2fcefd9766a218d8cface53baa2bca15_61260_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="372px"
>&lt;/p>
&lt;h3 id="서버-조회">서버 조회&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_5.png"
width="606"
height="390"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_5_hu2fcefd9766a218d8cface53baa2bca15_61260_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_5_hu2fcefd9766a218d8cface53baa2bca15_61260_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="372px"
>&lt;/p>
&lt;p>어떤 키가 저장되는 서버는 &lt;strong>해당 키의 위치로부터 시계 방향으로 링을 탐색해 나가면서 만나는 첫번 째 서버&lt;/strong>이다.&lt;/p>
&lt;p>따라서 &lt;strong>k0&lt;/strong>는 &lt;strong>s0&lt;/strong> 에 저장된다.&lt;/p>
&lt;h3 id="서버-추가">서버 추가&lt;/h3>
&lt;p>키가 저장되는 서버가 키의 위치로부터 시계 방향으로 링을 돌면서 만나는 첫 서버이므로, 서버를 추가하더라도 키 가운데 일부만 재배치하면 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_6.png"
width="615"
height="465"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_6_huc8545933ab2d8774b07636da6ebf7ea2_77279_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_6_huc8545933ab2d8774b07636da6ebf7ea2_77279_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="132"
data-flex-basis="317px"
>&lt;/p>
&lt;p>위 그림처럼 s4가 추가되면, k0만 재배치하면 되며, 나머지 키들은 같은 서버에 남게된다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>k0&lt;/strong>가 만나는 첫 서버가 &lt;strong>s4&lt;/strong>로 바뀌기 때문&lt;/li>
&lt;/ul>
&lt;h3 id="서버-제거">서버 제거&lt;/h3>
&lt;p>마찬가지로 한 서버가 제거되면 &lt;strong>키 일부만 재배치&lt;/strong>된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_7.png"
width="609"
height="450"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_7_hu76c16055e4220cf0e1509508dbdc7e60_68728_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_7_hu76c16055e4220cf0e1509508dbdc7e60_68728_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="324px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>s1&lt;/strong>이 삭제되었을 때 &lt;strong>k1&lt;/strong>의 첫 서버만 &lt;strong>s2&lt;/strong>로 바뀌므로 &lt;strong>k1&lt;/strong>만 &lt;strong>s2&lt;/strong>로 재배치된다.&lt;/li>
&lt;/ul>
&lt;h3 id="기존-구현법의-두-가지-문제">기존 구현법의 두 가지 문제&lt;/h3>
&lt;p>안정 해시 알고리즘은 MIT에서 처음 제안되었는데, 기본 절차는 아래와 같다.&lt;/p>
&lt;ol>
&lt;li>서버와 키를 &lt;strong>균등 분포 해시 함수&lt;/strong>를 사용해 해시 링에 배치한다.&lt;/li>
&lt;li>키의 위치에서 링을 시계방향으로 탐색하다 만나는 최초의 서버가 키가 저장될 서버이다.&lt;/li>
&lt;/ol>
&lt;p>안정 해시는 근본적으로 최소한의 추가/삭제에 대해 최소한의 재배치를 고려한다. 따라서 이러한 방식에는 두 가지 문제가 발생한다.&lt;/p>
&lt;p>&lt;strong>파티션 크기 문제&lt;/strong>&lt;/p>
&lt;p>서버가 추가되거나 삭제되는 상황을 감안하면 사용하더라도 파티션의 크기를 균등하게 유지하는 게 불가능하다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_8.png"
width="610"
height="371"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_8_hufb05e65c37497f753e3a366dbfe6320e_67873_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_8_hufb05e65c37497f753e3a366dbfe6320e_67873_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;ul>
&lt;li>파티션의 크기는 시계 방향으로 제일 가까운 서버 사이와의 거리만큼의 해시 공간으로, 서버의 해시 공간이 균등하지 않다.
&lt;ul>
&lt;li>추가 삭제될 때 시계 방향으로 제일 가까운 서버에 키들이 집중된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>키의 균등 분포 문제&lt;/strong>&lt;/p>
&lt;p>균등 분포 해시 함수는 충돌을 최소화하며 입력 키들이 해시 공간 전체에 고르게 분포되어 특정 영역에 물리지 않도록 구현되지만 완전하지는 않다.&lt;/p>
&lt;ul>
&lt;li>데이터의 비균등한 본질:
&lt;ul>
&lt;li>실제 데이터는 해시 함수의 이상적인 균등 분포를 따르지 않을 수 있다.&lt;/li>
&lt;li>특정 패턴이나 값들이 특정 해시 영역에 몰리는 경우가 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>해시 함수의 한계:
&lt;ul>
&lt;li>모든 해시 함수는 완벽한 균등 분포를 보장할 수 없다.&lt;/li>
&lt;li>특히 입력 키의 분포가 고르지 않을 경우, 해시 값의 분포도 고르지 않을 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_9.png"
width="611"
height="409"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_9_hu5257857a45f5f8de50581f3a0c6d2841_61763_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_9_hu5257857a45f5f8de50581f3a0c6d2841_61763_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="149"
data-flex-basis="358px"
>&lt;/p>
&lt;p>따라서 키의 균등 분포가 매우 달성하기 어려워 위와 같은 상황이 발생하게된다.&lt;/p>
&lt;p>&lt;strong>+ 실제 서버의 처리 능력 차이&lt;/strong>&lt;/p>
&lt;p>노드(서버)마다 처리 능력이나 저장 용량이 다를 경우, 파티션 크기의 균등성이 실제 부하의 균등성을 의미하지 않을 수 있다.&lt;/p>
&lt;h3 id="가상-노드">가상 노드&lt;/h3>
&lt;p>가상 노드는 &lt;strong>실제 노드 또는 서버를 가리키는 노드&lt;/strong>로서 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_10.png"
width="603"
height="458"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_10_hua3bd50f3317f65ef075362e2b74282e1_85776_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_10_hua3bd50f3317f65ef075362e2b74282e1_85776_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="315px"
>&lt;/p>
&lt;p>서버들의 비슷한 해시 공간을 가질 수 있도록 하는 기법으로 해시 링 위에 실제 서버를 가르키는 가상 노드들을 분포시킨 후 가상 노드에 할당되는 해시 영역을 가상 노드가 가르키는 서버가 처리하도록 한다.&lt;/p>
&lt;ul>
&lt;li>따라서 각 서버는 하나가 아닌 여러 개의 파티션을 관리해야 한다.&lt;/li>
&lt;/ul>
&lt;p>가상 노드의 개수를 늘리면 표준 편차가 작아져 데이터가 고르게 분포되므로, 키위 분포는 점점 더 균등해지지만&lt;/p>
&lt;p>가상 노드 데이터를 저장할 공간이 더 많이 필요해지므로, 시스템 요구사항에 맞도록 가상 노드 개수를 적절히 조정하는 트레이드오프가 필요하다.&lt;/p>
&lt;h3 id="재배치할-키-결정">재배치할 키 결정&lt;/h3>
&lt;p>서버가 추가되거나 제거되면 데이터의 일부는 재배치해야 한다.&lt;/p>
&lt;p>&lt;strong>서버가 추가되었을 때&lt;/strong>&lt;/p>
&lt;p>&lt;strong>s4&lt;/strong>가 추가되었다고 가정하면, 영향을 받는 위는 &lt;strong>s4&lt;/strong> 부터 그 반시계 방향에 있는 &lt;strong>s3&lt;/strong> 까지이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_11.png"
width="611"
height="463"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_11_hu56d8da2926a0ef9a8f4dcf5986502707_77091_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_11_hu56d8da2926a0ef9a8f4dcf5986502707_77091_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="316px"
>&lt;/p>
&lt;p>따라서 &lt;strong>s3&lt;/strong> 부터 &lt;strong>s4&lt;/strong> 사이에 있는 키들을 &lt;strong>s4&lt;/strong>로 재배치해야한다.&lt;/p>
&lt;p>&lt;strong>서버가 삭제되었을 때&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_12.png"
width="608"
height="449"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_12_hu33149acfb6f53d9b638ddb2443c387f3_70058_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_12_hu33149acfb6f53d9b638ddb2443c387f3_70058_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="324px"
>&lt;/p>
&lt;p>&lt;strong>s1&lt;/strong>이 삭제되면 &lt;strong>s1&lt;/strong> 부터 그 반시계 방향에 있는 최초 서버 &lt;strong>s0&lt;/strong> 사이에 있는 키들이 &lt;strong>s2&lt;/strong>로 재배치되어야 한다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>안정 해시의 이점은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>서버가 추가되거나 삭제될 때 재배치되는 키의 수가 최소화된다.&lt;/li>
&lt;li>데이터가 보다 균등하게 분포하게 되므로 수평적 규모 확장성을 달성하기 쉽다.&lt;/li>
&lt;li>핫스팟 키 문제를 줄인다.
&lt;ul>
&lt;li>특정한 샤드에 대한 접근이 지나치게 빈번하면 서버 과부화 문제가 생길 수 있는데(유명인사 문제), 데이터를 좀 더 균등하게 분배하므로 문제 발생 가능성을 줄인다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>안정해시는 실제로 널리 쓰이는 기술이다.&lt;/p>
&lt;ul>
&lt;li>아마존 다이나모 데이터베이스의 파티셔닝 관련 컴포넌트&lt;/li>
&lt;li>아파치 카산드라 클러스터에서 데이터 파티셔닝&lt;/li>
&lt;li>디스코드 채팅 어플리케이션&lt;/li>
&lt;li>아카마이 CDN&lt;/li>
&lt;li>매그레프 네트워크 부하 분산기 등&lt;/li>
&lt;/ul></description></item><item><title>4. 처리율 제한 장치의 설계</title><link>https://codemario318.github.io/post/system-design-interview/4/</link><pubDate>Wed, 15 May 2024 12:22:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/4/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/cover.png" alt="Featured image of post 4. 처리율 제한 장치의 설계" />&lt;h2 id="처리율-제한-장치rate-limiter">처리율 제한 장치(Rate limiter)?&lt;/h2>
&lt;p>클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치이다.&lt;/p>
&lt;p>HTTP의 경우 &lt;strong>특정 기간 내에 전송되는 클라이언트의 요청 횟수를 제한&lt;/strong>한다.&lt;/p>
&lt;ul>
&lt;li>사용자는 초당 2회 이상 새 글을 올릴 수 없다.&lt;/li>
&lt;li>같은 IP 주소로는 하루 10개 이상의 계정을 생성할 수 없다.&lt;/li>
&lt;li>같은 디바이스로는 주당 5회 이상 리워드(reward)를 요청할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;p>대형 IT 기업들이 공개한 거의 대부분의 API는 어떤 형태로든 처리율 제한 장치를 갖고 있으며, 아래와 같은 장점이 있다.&lt;/p>
&lt;ul>
&lt;li>DoS(Denial of Service) 공격에 의한 자원 고갈을 방지할 수 있다.&lt;/li>
&lt;li>자원 절약
&lt;ul>
&lt;li>추가 요청에 대한 처리율을 제한하면 서버를 많이 두지 않아도된다.&lt;/li>
&lt;li>우선순위가 높은 API에 더 많은 자원을 할당할 수 있다.&lt;/li>
&lt;li>3rd 파티 API를 사용하는 경우 요청 횟수만큼 과금이 된다면, 사용자가 처리율을 제한하여 비용을 절약할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서버 과부하 방지
&lt;ul>
&lt;li>봇에서 오는 트래픽이나 사용자의 잘못된 이용 패턴으로 유발된 트래픽을 걸러내는 데 처리율 제한 장치를 활용할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>처리율 제한 장치를 구현하는 데는 여러 가지 알고리즘을 고려할 수 있으며, 각각 고유한 장단점을 가지고 있다.&lt;/p>
&lt;p>따라서 면접관과 서통하며 어떤 제한 장치를 구현해야 하는 지 분명하게 파악해야한다.&lt;/p>
&lt;ul>
&lt;li>Q. 클라이언트 측 제한장치? 서버 측 제한장치?
&lt;ul>
&lt;li>A. 서버측 API를 위한 제한 장치&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 어떠한 기준으로? IP 주소 or 사용자 ID 등
&lt;ul>
&lt;li>A. 다양한 형태의 제어 규칙을 정의할 수 있도록 하는 유연한 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 시스템의 규모는? 스타트업 or 대기업
&lt;ul>
&lt;li>A. 대규모 요청 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 분산 환경에서 동작해야 하는가?
&lt;ul>
&lt;li>A. 예&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 처리율 제한 장치가 독립적인 서비스인가? 코드에 포함할 수 있는가?
&lt;ul>
&lt;li>A. 알아서&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 처리율 제한에 막힌 상황에 사용자에게 알려하하는가?
&lt;ul>
&lt;li>A. 예&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="요구사항">요구사항&lt;/h3>
&lt;p>질문을 통해 파악한 시스템의 요구사항은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>설정된 처리율을 초과하는 요청은 정확하게 제한&lt;/li>
&lt;li>낮은 응답시간
&lt;ul>
&lt;li>HTTP 응답시간에 나쁜 영향을 주어서는 곤란하다. (대규모 처리 허용 등)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가능한 적은 메모리&lt;/li>
&lt;li>분산형 처리율 제한
&lt;ul>
&lt;li>하나의 처리율 제한 장치를 여러 서버나 프로세스에서 공유할 수 있어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예외 처리
&lt;ul>
&lt;li>요청 제한시 사용자에게 분명하게 보여주어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>높은 결함 감내성
&lt;ul>
&lt;li>제한 장치에 장애가 생기더라도 전체 시스템에 영향을 주어서는 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계-제시-및-동의-구하기">2단계 개략적 설계 제시 및 동의 구하기&lt;/h2>
&lt;p>기본적인 &lt;strong>클라이언트-서버 통신 모델&lt;/strong>을 사용하여 문제를 간단하게 만든다.&lt;/p>
&lt;h3 id="어디에-둘-것인가">어디에 둘 것인가?&lt;/h3>
&lt;p>기본적인 &lt;strong>클라이언트-서버 통신 모델&lt;/strong>에서는 처리율 제한 장치는 클라이언트, 서버 측에 둘 수 있다.&lt;/p>
&lt;p>&lt;strong>클라이언트&lt;/strong>&lt;/p>
&lt;p>클라이언트 요청은 쉽게 위변조가 가능하므로 처리율 제한을 안정적으로 걸 수 있는 장소가 아니다.&lt;/p>
&lt;ul>
&lt;li>모든 클라이언트의 구현을 통제하는 것도 어려울 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>서버&lt;/strong>&lt;/p>
&lt;p>큰 틀에서 처리율 제한 장치를 API 서버와 함께 두는 방식, 미들웨어로 만드는 방식 2가지를 고려할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img.png"
width="560"
height="141"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_hu95f96bf133f868fe94b526818cbf6220_35669_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_hu95f96bf133f868fe94b526818cbf6220_35669_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="API 서버에 두는 방식"
class="gallery-image"
data-flex-grow="397"
data-flex-basis="953px"
>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_2.png"
width="549"
height="218"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_2_hu46848255408feea17de861814d1271d1_42946_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_2_hu46848255408feea17de861814d1271d1_42946_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="미들웨어 동작 예시"
class="gallery-image"
data-flex-grow="251"
data-flex-basis="604px"
>&lt;/p>
&lt;p>처리율 제한 장치를 미들웨어로 만들어 API 서버로 가는 요청을 통제하는 방식은 제한된 요청을 API 서버로 보내지 않고, HTTP 상태코드 429를 반환한다.&lt;/p>
&lt;p>마이크로서비스의 경우 보통 API 게이트웨이라고 불리는 컴포넌트에 구현된다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>API 게이트웨이?&lt;/strong>&lt;br>
처리율 제한, SSL 종단 사용자 인증, IP 허용 목록 관리등을 지원하는 완전 위탁 관리형 서비스&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>처리율 제한 장치는 회사의 현재 기술 스택이나 엔지니어링 인력, 우선순위, 목표에 따라 어디에 둘 지 결정한다.&lt;/p>
&lt;ul>
&lt;li>프로그래밍 언어, 캐시 서비스 등 현재 사용하고 있는 기술 스택을 점검한다.&lt;/li>
&lt;li>사업에 필요에 맞는 처리율 제한 알고리즘을 찾는다.
&lt;ul>
&lt;li>직접 구현시 자유롭게 선택 가능하지만, 서드파티 게이트웨이를 사용하기로 했다면 제한될 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>설계가 마이크로서비스에 기반하고 있다면, 사용자 인증이나 IP 화이트리스트 관리 등을 처리하기 위해 API 게이트웨이를 이미 포함했다면 처리율 제한 기능 또한 포함시켜야 할 수 있다.&lt;/li>
&lt;li>직접 만드는 데는 시간이 들기 때문에 인력이 충분하지 않다면 상용 API 게이트웨이를 쓰는 것이 바람직하다.&lt;/li>
&lt;/ul>
&lt;h3 id="처리율-제한-알고리즘">처리율 제한 알고리즘&lt;/h3>
&lt;p>처리율 제한을 실현하는 알고리즘은 여러가지이며, 각기 다른 장단점을 가지고 있다.&lt;/p>
&lt;ul>
&lt;li>토큰 버킷, 누출 버킷, 고정 윈도 카운터, 이동 윈도 로그, 이동 윈도 카운터 등&lt;/li>
&lt;/ul>
&lt;h4 id="토큰-버킷-알고리즘">토큰 버킷 알고리즘&lt;/h4>
&lt;p>토큰 버킷 알고리즘은 처리율 제한에 폭 넓게 이용되고 있다.&lt;/p>
&lt;p>간단하고, 알고리즘에 대한 이해도가 높아 인터넷 기업들이 보편적으로 사용하고 있다.&lt;/p>
&lt;ul>
&lt;li>아마존, 스트라이프 등&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_4.png"
width="529"
height="492"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_4_hud272ad2e7ce6d0192e191aa981cc5e7d_63798_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_4_hud272ad2e7ce6d0192e191aa981cc5e7d_63798_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="107"
data-flex-basis="258px"
>&lt;/p>
&lt;p>&lt;strong>토큰 버킷&lt;/strong>은 지정된 용량을 갖는 컨테이너로, 사전 설정된 양의 토큰이 주기적으로 채워진다.&lt;/p>
&lt;p>토큰이 꽉 찬 버킷에는 더 이상의 토큰은 추가되지 않고 버려진다.&lt;/p>
&lt;ul>
&lt;li>각 요청은 처리될 때마다 하나의 토큰을 사용한다.&lt;/li>
&lt;li>요청이 도착하면 버킷에 충분한 토큰이 있는지 검사하게 된다.&lt;/li>
&lt;li>토큰이 있는 경우 버킷에서 토큰 하나를 꺼낸 후 요청을 시스템에 전달한다.&lt;/li>
&lt;li>없는 경우 버려진다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_5.png"
width="469"
height="547"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_5_hu470c561bcff0a77f741d71f0c2c45165_78035_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_5_hu470c561bcff0a77f741d71f0c2c45165_78035_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="버킷 크기 = 4, 공급률 = 분당 4"
class="gallery-image"
data-flex-grow="85"
data-flex-basis="205px"
>&lt;/p>
&lt;p>토큰 버킷 알고리즘은 2가지 인자를 받는다.&lt;/p>
&lt;ul>
&lt;li>버킷 크기: 버킷에 담을 수 있는 토큰의 최대 개수&lt;/li>
&lt;li>토큰 공급률: 초당 몇개의 토큰이 버킷에 공급되는가&lt;/li>
&lt;/ul>
&lt;p>적절한 버킷의 개수는 공급 제한 규칙에 따라 결정된다.&lt;/p>
&lt;ul>
&lt;li>통상적으로, API 엔드포인트마다 벌도의 버킷을 둔다.
&lt;ul>
&lt;li>포스팅 1번, 친구 150명 추가 가능, 좋아요 5번 이라면 사용자마다 3개 필요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>IP 주소별 처리율 제한 필요시 IP 주소마다 버킷을 하나씩 할당해야 한다.&lt;/li>
&lt;li>시스템의 처리율을 초당 10,000개 요청으로 제한하고 싶다면, 모든 요청이 하나의 버킷을 공유하도록 한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>구현이 쉽다.&lt;/li>
&lt;li>메모리 사용 측면에서도 효율적이다.&lt;/li>
&lt;li>짧은 시간에 집중되는 트래픽도 처리 가능하다.
&lt;ul>
&lt;li>버킷에 남은 토큰이 있다면 요청은 전달된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>파라미터를 적절하게 튜닝하는 것이 까다롭다.&lt;/li>
&lt;/ul>
&lt;h4 id="누출-버킷-알고리즘">누출 버킷 알고리즘&lt;/h4>
&lt;p>누출 버킷 알고리즘은 토큰 버킷 알고리즘과 비슷하지만 &lt;strong>요청 처리율이 고정되어 있다는 점&lt;/strong>이 다르다.&lt;/p>
&lt;p>보통 FIFO 큐로 구현하며 동작 원리는 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>요청이 도착하면 큐가 가득 차 있는지 본다.
&lt;ul>
&lt;li>빈자리가 있다면 큐에 요청을 추가한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>큐가 가득 차 있는 경우에는 새 요청을 버린다.&lt;/li>
&lt;li>지정된 시간마다 큐에서 요청을 꺼내어 처리한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_6.png"
width="599"
height="221"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_6_hu20c9bad42732607dad0a83639f3502f8_30101_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_6_hu20c9bad42732607dad0a83639f3502f8_30101_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="누출 버킷 알고리즘"
class="gallery-image"
data-flex-grow="271"
data-flex-basis="650px"
>&lt;/p>
&lt;p>누출 버킷 알고리즘은 다음의 두 인자를 사용한다.&lt;/p>
&lt;ul>
&lt;li>버킷 크기: 처리될 항목들이 보관될 큐의 사이즈&lt;/li>
&lt;li>처리율: 지정된 시간당 몇 개의 항목을 처리할지 지정하는 값.(보통 초단위)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>큐의 크기가 제한되어 있어 메모리 사용량 측면에서 효율적이다.&lt;/li>
&lt;li>고정된 처리율을 가지므로 안정된 출력(Stable outflow rate)이 필요한 경우에 적합하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>단시간에 많은 트래픽이 몰리는 경우 큐에는 오래된 요청들이 쌓이고, 그 요청들을 제때 처리 못하면 최신 요청들은 버려진다.&lt;/li>
&lt;li>파라미터를 올바르게 튜닝하기 까다로울 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="고정-윈도-카운터-알고리즘">고정 윈도 카운터 알고리즘&lt;/h4>
&lt;p>고정 윈도 카운터 알고리즘은 다음과 같이 동작한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_7.png"
width="601"
height="355"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_7_huacea6638a786d893354d0e089d7abe1d_35784_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_7_huacea6638a786d893354d0e089d7abe1d_35784_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="406px"
>&lt;/p>
&lt;ol>
&lt;li>타임라인을 고정된 간격의 윈도로 나누고, 각 윈도마다 카운터를 붙인다.&lt;/li>
&lt;li>요청이 접수될 때마다 이 카운터의 값을 1씩 증가시킨다.&lt;/li>
&lt;li>카운터의 값이 사전에 설정된 임계치에 도달하면 새로운 요청은 새 윈도가 열릴 때 까지 버려진다.&lt;/li>
&lt;/ol>
&lt;p>고정 윈도 카운터 알고리즘의 가장 큰 문제는 윈도의 경계 부근에 순간적으로 많은 트래픽이 집중될 경우 윈도에 할당된 양보다 더 많은 요청이 처리될 수 있다는 점이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_8.png"
width="604"
height="296"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_8_hu06e9b333628f278fe9f5a17c951f72ed_27698_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_8_hu06e9b333628f278fe9f5a17c951f72ed_27698_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="204"
data-flex-basis="489px"
>&lt;/p>
&lt;p>분당 최대 5개 요청을 허용하는 시스템에서 &lt;code>2:00:00 ~ 2:01:00&lt;/code>, &lt;code>2:01:00 ~ 2:02:00&lt;/code> 윈도우에 각각 5개 요청을 처리하였으나, 윈도우를 30초 옮겨 &lt;code>2:00:30 ~ 2:01:30&lt;/code>를 살펴보면 총 10개의 요청을 처리하게되어 설정된 최대 처리량 5개를 초과하게 된다.&lt;/p>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>메모리 효율이 좋다.&lt;/li>
&lt;li>이해하기 쉽다.&lt;/li>
&lt;li>윈도가 닫히는 시점에 카운터를 초기화하는 방식은 특정한 트래픽 패턴을 처리하기에 적합하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>윈도 경계 부근에서 일시적으로 많은 트래픽이 몰려드는 경우, 기대했던 시스템의 처리 한도보다 많은 양의 요청을 처리하게 된다.&lt;/li>
&lt;/ul>
&lt;h4 id="이동-윈도-로깅-알고리즘">이동 윈도 로깅 알고리즘&lt;/h4>
&lt;p>고정 윈도 카운터 알고리즘의 문제를 해결한 방식이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_9.png"
width="582"
height="400"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_9_hu98c0a7c61c2865bfd0748184396a4361_43992_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_9_hu98c0a7c61c2865bfd0748184396a4361_43992_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="349px"
>&lt;/p>
&lt;ul>
&lt;li>요청의 타임 스탬프를 추적한다.
&lt;ul>
&lt;li>보통 레디스의 정렬 집합 같은 캐시에 보관한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>새 요청이 오면 만료된 타임스탬프는 제거한다.
&lt;ul>
&lt;li>타임스탬프 값이 현재 윈도의 시작 지점보다 오래된 타임 스탬프&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>새 요청의 타임스탬프 로그에 추가한다.&lt;/li>
&lt;li>로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달한다. 아닐경우 처리를 거부한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>어느 순간 윈도를 보더라도, 허용되는 요청의 개수는 시스템의 처리율 한도를 넘기지 않는다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>거부된 요청의 타임스탬프도 보관하기 때문에 다량의 메모리를 사용하게된다.&lt;/li>
&lt;/ul>
&lt;h4 id="이동-윈도-카운터-알고리즘">이동 윈도 카운터 알고리즘&lt;/h4>
&lt;p>이동 윈도 카운터 알고리즘은 고정 윈도 카운터 알고리즘과 이동 윈도 로깅 알고리즘을 결합한 것이다.&lt;/p>
&lt;p>&lt;code>현재 1분간의 요청 수 + 직전 1분간의 요청 수 * 이동 윈도와 직전 1분이 겹치는 비율&lt;/code>을 계산하여 현재 윈도에 몇개의 요청이 왔는지를 구한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_10.png"
width="581"
height="343"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_10_hu4227282d9657e7f968e2cd18b876213b_41691_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_10_hu4227282d9657e7f968e2cd18b876213b_41691_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="406px"
>&lt;/p>
&lt;p>분당 7개 요청으로 설정되어 있고, 이전 1분동안 5개의 요청이, 그리고 1분 동안 3개의 요청이 왔다면&lt;/p>
&lt;p>&lt;code>3 + 5 * 70%&lt;/code>를 계산하여 현재 6.5개의 요청이 있다고 계산하고, 분당 7개의 요청보다 적으므로 전달된다.&lt;/p>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>이전 시간대의 평균 처리율에 따라 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응한다.&lt;/li>
&lt;li>메모리 효율이 좋다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>직전 시간대에 도착한 요청이 균등하게 분포되어 있다고 가정한 상태에서 추정치를 계산하기 때문에 다소 느슨하다.
&lt;ul>
&lt;li>생각만큼은 심각한 문제는 아니다.&lt;/li>
&lt;li>클라우드플레어가 실시했던 실험에 따르면 40억 개의 요청 가운데 스템의 실제 상태와 맞지 않게 허용되거나 버려진 요청은 0.003%에 불과하였다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적인-아키텍처">개략적인 아키텍처&lt;/h3>
&lt;p>처리율 제한 알고리즘은 얼마나 많은 요청이 접수되었는지를 추적할 수 있는 카운터를 추적 대상별로 두고(사용자 or IP or API 엔드포인트) 이 카운터의 값이 어떤 한도를 넘어서면 도착한 요청을 거부하는 것이다.&lt;/p>
&lt;p>이러한 카운터는 읽기 쓰기 작업이 빈번하고, 빠르게 지워져야 하는 특성으로 인해 빠른데다 시간에 기반한 만료 정책을 지원하는 메모리 캐시가 적절하다.&lt;/p>
&lt;p>대표적으로 레디스가 많이 활용되며 이에 적합한 &lt;code>INCR&lt;/code>, &lt;code>EXPIRE&lt;/code> 명령을 제공한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>INCR&lt;/code>: 메모리에 저당된 카운터의 값을 1만큼 증가시킨다.&lt;/li>
&lt;li>&lt;code>EXPIRE&lt;/code>: 카운터에 타임아웃 값을 설정한다. 시간이 지나면 자동 삭제된다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_11.png"
width="593"
height="260"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_11_hua0ec6a8fedf59bf7e19688bf87bdb91a_52761_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_11_hua0ec6a8fedf59bf7e19688bf87bdb91a_52761_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적인 아키텍처"
class="gallery-image"
data-flex-grow="228"
data-flex-basis="547px"
>&lt;/p>
&lt;ol>
&lt;li>클라이언트가 처리율 제한 미들웨어에게 요청을 보낸다.&lt;/li>
&lt;li>처리율 제한 미들웨어는 레디스의 지정 버킷에서 카운터를 가져와 한도에 도달했는지 검사한다.
&lt;ul>
&lt;li>한도에 도달했다면 요청은 거부됨&lt;/li>
&lt;li>한도에 도달하지 않았다면 API로 요청을 전달하고, 카운터의 값을 증가시켜 레디스에 저장한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="상세-설계">상세 설계&lt;/h2>
&lt;p>개략적 설계만 봐서는 다음과 같은 사항은 알 수가 없다.&lt;/p>
&lt;ul>
&lt;li>처리율 제한 규칙은 어떻게 만들어지고 어디에 저장되는가?&lt;/li>
&lt;li>처리가 제한된 요청들은 어떻게 처리되는가?&lt;/li>
&lt;/ul>
&lt;h3 id="처리율-제한-규칙">처리율 제한 규칙&lt;/h3>
&lt;p>리프트(lyft)는 처리율 제한에 오픈 소스를 사용하고 있는데, 이 컴포넌트를 통해 어떤 처리율 제한 규칙이 사용되고 있는지 살펴볼 수 있다.&lt;/p>
&lt;p>이러한 규칙들은 보통 설정 파일 형태로 디스크에 저장된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">domain&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">messaging&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">descriptors&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">message_type&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">Value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">marketing&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rate_limit&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">unit&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">day&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">requests_per_unit&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">5&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>마케팅 메시지의 최대치를 하루 5개로 제한&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">domain&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">auth&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">descriptors&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">auth_type&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">Value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">login&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rate_limit&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">unit&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">minute&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">requests_per_unit&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">5&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>클라이언트가 분당 5회 이상 로그인 할 수 없도록 제한&lt;/li>
&lt;/ul>
&lt;h3 id="처리율-한도-초과-트래픽의-처리">처리율 한도 초과 트래픽의 처리&lt;/h3>
&lt;p>어떤 요청이 한도 제한에 걸리면 HTTP 429 응답을 보내거나, 한도 제한에 걸린 메시지를 나중에 처리하기 위해 큐에 보관할 수도 있다.&lt;/p>
&lt;p>&lt;strong>처리율 제한 장치가 사용하는 HTTP 헤더&lt;/strong>&lt;/p>
&lt;p>클라이언트가 요청이 제한에 관련된 정보들을 HTTP 응답 헤더를 확인하면 알 수 있다.&lt;/p>
&lt;p>처리율 제한 장치는 다음 HTTP 헤더를 클라이언트에 보내 제한에 걸렸음을 알린다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>X-Ratelimit-Remaining&lt;/code>: 윈도 내에 남은 처리 가능 요청 수&lt;/li>
&lt;li>&lt;code>X-Ratelimit-Limit&lt;/code>: 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수&lt;/li>
&lt;li>&lt;code>X-Ratelimit-Retry-After&lt;/code>: 한도 제한에 걸리지 않기 위해 몇초 뒤에 요청을 다시 보내야 하는지&lt;/li>
&lt;/ul>
&lt;p>사용자가 너무 많은 요청을 보내면 &lt;strong>429 too many requests&lt;/strong>오류를 &lt;code>X-Ratelimit-Retry-After&lt;/code> 헤더와 함께 반환하도록 한다.&lt;/p>
&lt;h3 id="상세-설계-1">상세 설계&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_12.png"
width="616"
height="504"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_12_hue300fb2d822881a8aa53d8fa5a83713d_105530_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_12_hue300fb2d822881a8aa53d8fa5a83713d_105530_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="122"
data-flex-basis="293px"
>&lt;/p>
&lt;ul>
&lt;li>처리율 제한 규칙은 디스크에 보관한다.
&lt;ul>
&lt;li>작업 프로세스는 수시로 규칙을 읽어 캐시에 저장한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>클라이언트가 요청을 서버에 보내면 요청은 먼저 처리율 제한 미들웨어에 도달한다.&lt;/li>
&lt;li>처리율 제한 미들웨어는 제한 규칙을 캐시에서 가져온다. 아울러 카운터 및 마지막 요청의 타임스탬프를 레디스 캐시에서 가져온다.
&lt;ul>
&lt;li>요청이 제한에 걸리지 않은 경우 API 서버로 보낸다.&lt;/li>
&lt;li>처리율 제한에 걸렸다면 에러를 클라이언트에 보낸다.
&lt;ul>
&lt;li>요청은 버리거나 메시지 큐에 보관한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="분산-환경에서의-처리율-제한-장치의-구현">분산 환경에서의 처리율 제한 장치의 구현&lt;/h3>
&lt;p>여러 대의 서버와 병렬 스레드를 지원하려면 &lt;strong>경쟁 조건&lt;/strong>과 &lt;strong>동기화&lt;/strong> 문제를 고려해야 한다.&lt;/p>
&lt;h4 id="경쟁-조건">경쟁 조건&lt;/h4>
&lt;p>처리율 제한 장치는 다음과 같이 동작한다.&lt;/p>
&lt;ol>
&lt;li>레디스에서 카운터의 값을 읽는다.&lt;/li>
&lt;li>카운터의 값이 임계치를 넘는지 본다.&lt;/li>
&lt;li>넘지 않는다면 레디스에 보관된 카운터 값을 1만큼 증가시킨다.&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_13.png"
width="602"
height="340"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_13_hu25f5b8ce1e5471668532889a2cb0e3bf_33618_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_13_hu25f5b8ce1e5471668532889a2cb0e3bf_33618_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="424px"
>&lt;/p>
&lt;p>병행성이 심한 환경에서는 위와 같이 보관될 값이 달라질 수 있는 이슈가 존재한다.&lt;/p>
&lt;p>이러한 경쟁 조건 문제를 해결하는 가장 널리 알려진 해결책은 **락(Lock)**이지만, 락은 시스템의 성능을 상당히 떨어뜨린다는 문제가 있다.&lt;/p>
&lt;p>위와 같은 설계의 경우 락 대신 **루아 스크립트(Lua script)**와 **정렬 집합(Sorted set)**이라 불리는 레디스 자료구조를 사용하여 해결할 수 있다.&lt;/p>
&lt;h4 id="동기화-이슈">동기화 이슈&lt;/h4>
&lt;p>수백만 사용자를 지원하려면 한 대의 처리율 제한 장치 서버로는 충분하지 않을 수 있어 처리율 제한 장치 서버를 여러 대 두게 되면 동기화가 필요해진다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_14.png"
width="612"
height="219"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_14_hud5d811b010ac2a69e5217967669d0f69_74199_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_14_hud5d811b010ac2a69e5217967669d0f69_74199_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="279"
data-flex-basis="670px"
>&lt;/p>
&lt;p>웹은 무상태이므로 클라이언트는 다음 요청을 다른 처리율 제한 장치로 보내게 될 수 있다.&lt;/p>
&lt;p>이때 동기화를 하지 않는다면 제한 장치 1은 클라이언트 2에 대해서는 아무것도 모르므로 처리율 제한이 올바르게 적용되지 않을 수 있다.&lt;/p>
&lt;p>이러한 문제를 해결하기 위해 같은 클라이언트로부터의 요청은 항상 같은 처리율 제한 장치로 보내는 &lt;strong>고정 세션&lt;/strong> 방식을 고려할 수 있다.&lt;/p>
&lt;p>하지만 이러한 방식은 확장 불가능, 뻣뻣하다는 단점을 가진다.&lt;/p>
&lt;p>따라서 레디스와 같은 중앙 집중형 데이터 저장소를 사용하여 해결하는 것이 좋다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_15.png"
width="559"
height="252"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_15_hub3172bc6f37be502955916b9482777c8_60583_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_15_hub3172bc6f37be502955916b9482777c8_60583_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="221"
data-flex-basis="532px"
>&lt;/p>
&lt;h4 id="성능-최적화">성능 최적화&lt;/h4>
&lt;p>성능 최적화는 시스템 설계 면접의 단골 주제이며, 지금까지 살펴본 설계는 두 가지 지점에서 개선이 가능하다.&lt;/p>
&lt;ul>
&lt;li>여러 데이터센터를 지원하는 문제
&lt;ul>
&lt;li>멀리 떨어진 사용자를 지원하기 위해 지연시간이 증가할 수 밖에 없는데, 대부분의 클라우드 서비스 사업자는 세계 곳곳에 에지 서버를 심어두어 성능을 끌어올린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>제한 장치 간에 데이터를 동기화할 때 최종 일관성 모델을 사용하는 것&lt;/li>
&lt;/ul>
&lt;h4 id="모니터링">모니터링&lt;/h4>
&lt;p>처리율 제한 장치를 설치한 이후에는 효과적으로 동작하는지 확인하기 위해 데이터를 모을 필요가 있다.&lt;/p>
&lt;ul>
&lt;li>채택된 처리율 제한 알고리즘이 효과적인지 확인하기 위해
&lt;ul>
&lt;li>이벤트 같은 이슈로 트래픽이 급증할 때 처리율 제한 장치가 비효율적으로 동작한다면 트래픽 패턴을 고려하여 알고리즘 변경을 고려한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>정의한 처리율 제한 규칙이 효과적인지 확인하기 위해
&lt;ul>
&lt;li>제한 규칙이 너무 엄격하다면 많은 유효 요청이 처리되지 못하고 버려질 경우 완화한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="마무리">마무리&lt;/h2>
&lt;p>시간이 허락된다면 다음 부분을 언급해보면 좋다.&lt;/p>
&lt;ul>
&lt;li>경성 또는 연성 처리율 제한
&lt;ul>
&lt;li>경성 처리율 제한: 요청의 개수는 임계치를 절대 넘어설 수 없다.&lt;/li>
&lt;li>연성 처리율 제한: 요청의 개수는 잠시동안은 임계치를 넘어설 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다양한 계층에서의 처리율 제한
&lt;ul>
&lt;li>애플리케이션 계층 외 다른 계층에서도 처리율 제한이 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>처리율 제한을 회피하는 방법. 클라이언트를 어떻게 설계하는 것이 최선인가?
&lt;ul>
&lt;li>클라이언트 측 캐시를 사용하여 API 호출 횟수를 줄인다.&lt;/li>
&lt;li>임계치를 이해하고, 짧은 시간 동안 너무 많은 메시지를 보내지 않도록 한다.&lt;/li>
&lt;li>예외나 에러를 처리하는 코드를 도입하여 예외적 상황을 우아하게 복구될 수 있도록 한다.&lt;/li>
&lt;li>재시도 로직을 구현할 때는 충분한 백오프 시간을 둔다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>3. 시스템 설계 면접 공략법</title><link>https://codemario318.github.io/post/system-design-interview/3/</link><pubDate>Tue, 07 May 2024 16:01:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/3/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/3/cover.png" alt="Featured image of post 3. 시스템 설계 면접 공략법" />&lt;blockquote>
&lt;p>&lt;strong>시스템 설계 면접&lt;/strong>은 두 명의 동료가 모호한 문제를 풀기 위해 협력하여 그 해결책을 찾아내는 과정에 대한 시뮬레이션이다.&lt;/p>
&lt;/blockquote>
&lt;p>시스템 설계 먼접은 특정 제품을 설계해보라는 식으로 막연하고, 넓은 범위로 인해 당황스러울 때가 많다.&lt;/p>
&lt;p>하지만 실세계에서 많은 엔지니어들이 참여하여 개발한 제품은 극도로 복잡하기 때문에 한 시간 안에 설계하는 것은 불가능 할 뿐더러, 완벽한 설계를 요구하지 않는다.&lt;/p>
&lt;ul>
&lt;li>시스템 설계 면접은 정해진 결말, 정답이 없다.
&lt;ul>
&lt;li>최종적으로 도출될 설계안은 설계 과정에서 들인 노력에 비하면 그다지 중요하지 않다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>설계 기술을 시연하는 자리이다.&lt;/li>
&lt;li>설계 과정에서 내린 결정들에 대한 방어 능력을 보이는 자리이다.&lt;/li>
&lt;li>면접관의 피드백을 건설적인 방식으로 처리할 자질이 있음을 보이는 자리이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>면접관의 의도&lt;/strong>&lt;/p>
&lt;p>시스템 설계 면접은 지원자의 설계 능력의 기술적인 측면 뿐만 아니라 여러 시그널을 수집한다.&lt;/p>
&lt;ul>
&lt;li>협력에 적합한 사람인가?&lt;/li>
&lt;li>압박이 심한 상황도 잘 헤쳐 나갈 자질이 있는가?&lt;/li>
&lt;li>모호한 문제를 건설적으로 해결할 능력이 있는가?&lt;/li>
&lt;li>설계의 순수성에 집착한 나머지, 타협정 결정(trade off)를 도외시하는가?&lt;/li>
&lt;li>완고함, 편협함 등&lt;/li>
&lt;/ul>
&lt;h2 id="효과적인-면접을-위한-4단계-접근법">효과적인 면접을 위한 4단계 접근법&lt;/h2>
&lt;p>시스템 설계 면접은 제각각이다.&lt;/p>
&lt;p>훌륭한 설계 면접은 정해진 결말도 없고 정답도 없지만, 절차나 범위에는 &lt;strong>공통적인 부분&lt;/strong>이 존재한다.&lt;/p>
&lt;h3 id="문제-이해-및-설계-범위-확정">문제 이해 및 설계 범위 확정&lt;/h3>
&lt;p>요구사항을 완전히 이해하지 않고 답을 내놓는 행위는 아주 엄청난 부정적 신호이다.&lt;/p>
&lt;p>따라서 깊이 생각하고 질문하여 요구사항과 가정들을 분명히 해야한다.&lt;/p>
&lt;p>적절한 설계를 위해 엔지니어가 가져야 할 중요한 기술은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>올바른 질문을 하는 것&lt;/li>
&lt;li>적절한 가정을 하는 것&lt;/li>
&lt;li>시스템 구축에 필요한 정보를 모으는 것&lt;/li>
&lt;/ul>
&lt;p>따라서 올바른 질문을 통해 적절한 가정과 정보를 모아야하며, 요구사항을 정확히 이해하기 위한 질문은 아래와 같은 유형이 있다.&lt;/p>
&lt;ul>
&lt;li>구체적으로 어떤 기능을 만들어야 하나?&lt;/li>
&lt;li>제품 사용자 수는 얼마나 되나?&lt;/li>
&lt;li>회사의 규모는 얼마나 빨리 커지리라 예상하나?&lt;/li>
&lt;li>회사가 주로 사용하는 기술 스택은 무엇인가?&lt;/li>
&lt;li>설계를 단순화하기 위해 활용할 수 있는 기존 서비스로는 어떤 것들이 있는가?&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>뉴스 피드(news feed) 시스템 설계 질문 예제&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Q. 모바일 앱과 웹 앱 가운데 어느쪽을 지원해야 하는가?
&lt;ul>
&lt;li>A. 둘다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 가장 중요한 기능은?
&lt;ul>
&lt;li>A1. 새로운 포스트 올리기&lt;/li>
&lt;li>A2. 다른 친구의 뉴스 피드 조회하기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 정렬 기준은?
&lt;ul>
&lt;li>A. 시간 역순으로&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 한 사용자의 최대 친구 수
&lt;ul>
&lt;li>A. 5,000명&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 트래픽 규모는?
&lt;ul>
&lt;li>A. 일간 능동 사용자(DAU) 천만 명&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 피드는 텍스트로만 구성되는가?
&lt;ul>
&lt;li>A. 이미지나 비디오 같은 미디어 파일도 포스트 할 수 있어야함.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적인-설계안-제시-및-동의-구하기">개략적인 설계안 제시 및 동의 구하기&lt;/h3>
&lt;p>개략적인 설계안을 제시하고 면접관의 동의를 구할 때 면접관과 협력하며 진행하면 좋다.&lt;/p>
&lt;ul>
&lt;li>설계안에 대한 최초 청사진을 제시하고 의견을 구하라.
&lt;ul>
&lt;li>면접관을 마치 팀원인 것 처럼&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>화이트보드나 종이에 핵심 컴포넌트를 포함하는 다이어그램을 그려라.
&lt;ul>
&lt;li>클라이언트, API, 웹 서버, 데이터 저장소, 캐시, CDN, 메시지 큐 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>최초 설계안이 시스템 규모에 관계된 제약사항들을 만족하는지를 개략적으로 계산한다.
&lt;ul>
&lt;li>계산 과정은 소리 내어 설명한다.&lt;/li>
&lt;li>개략적 추정이 필요한지는 면접관에게 미리 물어본다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>가능하다면 시스템의 구체적 사용 사례도 몇 가지 살펴보면 고려하지 못한 에지 케이스를 발견하는 데도 도움이 될 것이다.&lt;/p>
&lt;p>&lt;strong>뉴스 피드 시스템 개략적 설계 예시&lt;/strong>&lt;/p>
&lt;p>개략적으로 보면 &lt;strong>피드 발행&lt;/strong>, &lt;strong>피드 생성&lt;/strong> 두 가지 처리 플로로 나눠 생각해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>피드 발행
&lt;ul>
&lt;li>사용자가 포스트를 올리면 관련된 데이터가 캐시/데이터베이스에 기록되고, 해당 사용자의 친구 뉴스 피드에 뜨게 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>피드 생성
&lt;ul>
&lt;li>사용자의 뉴스 피드는 해당 사용자 친구들의 포스트를 시간 역순으로 정렬하여 만든다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/3/img.png"
width="423"
height="690"
srcset="https://codemario318.github.io/post/system-design-interview/3/img_hu039827f8027f9a00b1371e9a94d12627_101123_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/3/img_hu039827f8027f9a00b1371e9a94d12627_101123_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="피드 발행"
class="gallery-image"
data-flex-grow="61"
data-flex-basis="147px"
>
&lt;img src="https://codemario318.github.io/post/system-design-interview/3/img_1.png"
width="370"
height="589"
srcset="https://codemario318.github.io/post/system-design-interview/3/img_1_hu4e33947bf61ce6fe45cda92442fd57d4_67943_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/3/img_1_hu4e33947bf61ce6fe45cda92442fd57d4_67943_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="피드 생성"
class="gallery-image"
data-flex-grow="62"
data-flex-basis="150px"
>&lt;/p>
&lt;h3 id="상세-설계">상세 설계&lt;/h3>
&lt;p>이 단계로 왔다면 아래 목표는 달성한 상태일 것이다.&lt;/p>
&lt;ul>
&lt;li>시스템에서 전반적으로 달성해야 할 목표와 가능 범위 확인&lt;/li>
&lt;li>전체 설계의 개략적 청사진 마련&lt;/li>
&lt;li>해당 청사진에 대한 면접관의 의견 청취&lt;/li>
&lt;li>상세 설계에서 집중해야 할 영역들 확인&lt;/li>
&lt;/ul>
&lt;p>이 단계에서는 면접관이 설계 대상 컴포넌트 사이의 우선순위를 정한다.&lt;/p>
&lt;p>대부분의 경우 면접관은 &lt;strong>특정 시스템 컴포넌트들의 세부사항을 깊이 있게 설명하는 것을 보길 원한다&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>단축 URL 생성기
&lt;ul>
&lt;li>해시 함수의 설계의 구체적인 내용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>채팅 시스템
&lt;ul>
&lt;li>어떻게하면 지연시간을 줄이고 사용자의 온/오프라인 상태를 표시할 것인지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위와 같은 경우 너무 과도하거나 불필요한 세부 사항을 설명하지 않는 것이 바람직하다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/3/img_2.png"
width="641"
height="725"
srcset="https://codemario318.github.io/post/system-design-interview/3/img_2_hu6034e7d7aae53ae4575eee71d3d0d535_164348_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/3/img_2_hu6034e7d7aae53ae4575eee71d3d0d535_164348_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="피드 발행 상세"
class="gallery-image"
data-flex-grow="88"
data-flex-basis="212px"
>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/3/img_3.png"
width="563"
height="566"
srcset="https://codemario318.github.io/post/system-design-interview/3/img_3_hu740b51119dfe66fb11a0bcd33bce86e0_132618_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/3/img_3_hu740b51119dfe66fb11a0bcd33bce86e0_132618_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="뉴스 피드 가져오기 상세"
class="gallery-image"
data-flex-grow="99"
data-flex-basis="238px"
>&lt;/p>
&lt;h3 id="마무리">마무리&lt;/h3>
&lt;p>마지막 단계에서 면접관은 설계 결과물에 관련된 몇 가지 후속 질문을 던질 수도 있고 스스로 추가 논의를 진행하도록 할 수도 있다.&lt;/p>
&lt;p>그럴때는 아래와 같은 내용들을 언급해보면 좋은 방향으로 마무리 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>면접관이 시스템 병목구간, 혹은 좀 더 개선 가능한 지점을 찾아내라 주문할 때
&lt;ul>
&lt;li>완벽하다거나 개선할 부분이 없다는 답은 X&lt;/li>
&lt;li>비판적 사고 능력을 보이고, 마지막으로 좋은 인상을 남길 기회이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>만든 설계를 한번 다시 요약해준다.
&lt;ul>
&lt;li>여러 해결책을 제시한 경우에는 특히 중요하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오류가 발생하면 무슨 일이 생기는지 따져본다.&lt;/li>
&lt;li>운영 이슈도 논의할 가치가 충분하다.
&lt;ul>
&lt;li>메트릭 수집, 모니터링, 로그, 배포 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>미래에 닥칠 규모 확장 요구에 어떻게 대처할 것인가?&lt;/li>
&lt;li>필요하지만 다루지 못했던 세부적 개선사항들을 제안할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>해야할 것&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>질문을 통해 확인하라. 스스로 내린 가정이 옳다 믿고 진행하지 말라.&lt;/li>
&lt;li>문제의 요구사항을 이해하라.&lt;/li>
&lt;li>정답이나 최선의 답안 같은 것은 없다는 점을 명심하라.&lt;/li>
&lt;li>면접관이 사고 흐름을 이해할 수 있도록 하라. 면접관과 소통하라.&lt;/li>
&lt;li>가능하다면 여러 해법을 함께 제시하라.&lt;/li>
&lt;li>개략적 설계에 면접관이 동의하면, 가장 중요한 컴포넌트부터 컴포넌트의 세부사항을 설명하기 시작하라.&lt;/li>
&lt;li>면접관의 아이디어를 이끌어내라. 좋은 면접관은 같은 팀원처럼 협력한다.&lt;/li>
&lt;li>포기하지 말라.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>하지 말아야 할 것&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>전형적인 면접 문제들에도 대비하지 않은 상태에서 면접장에 가지 말라.&lt;/li>
&lt;li>요구사항이나 가정들을 분명히 하지 않은 상태에서 설계를 제시하지 말라.&lt;/li>
&lt;li>처음부터 특정 컴포넌트의 세부사항을 너무 깊이 설명하지 말라. 개략적 설계를 마친 뒤 서부사항으로 나아가라.&lt;/li>
&lt;li>힌트를 청하기를 주저하지 말라.&lt;/li>
&lt;li>소통을 주저하지 말라. 침묵 속에 설계를 진행하지 말라.&lt;/li>
&lt;li>설계안을 내놓는 순간 면접이 끝난다고 생각하지 말라.&lt;/li>
&lt;li>의견을 일찍, 그리고 자주 구하라.&lt;/li>
&lt;/ul>
&lt;h2 id="시간-배분">시간 배분&lt;/h2>
&lt;p>시스템 설계 면접은 보통 매우 광범위한 영역을 다루기 때문에 시간이 충분하지 않을 수 있어 시관 관리를 잘 하는 것이 중요하다.&lt;/p>
&lt;p>대략적인 시간 분배는 아래와 같으며, 문제의 범위나 면접관의 요구사항에 따라 달라질 수 있다.&lt;/p>
&lt;ul>
&lt;li>문제 이해 및 설계 범위 확정: 3 ~ 10분&lt;/li>
&lt;li>개략적 설계안 제시 및 동의 구하기: 10 ~ 15분&lt;/li>
&lt;li>상세 설계: 10 ~ 25분&lt;/li>
&lt;li>마무리: 3 ~ 5분&lt;/li>
&lt;/ul></description></item><item><title>2. 개략적인 규모 추정</title><link>https://codemario318.github.io/post/system-design-interview/2/</link><pubDate>Tue, 30 Apr 2024 22:03:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/2/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/2/cover.png" alt="Featured image of post 2. 개략적인 규모 추정" />&lt;p>개략적인 규모 추정(back-of-the-envelope estimation)은 보편적으로 통용되는 성능 수치상에서 사고 실험(thought experiments)을 행하여 추정치를 계산하는 행위로서, 어떤 설계가 요구사항에 부합할 것인지 보기 위한 것이다.&lt;/p>
&lt;h2 id="2의-제곱수">2의 제곱수&lt;/h2>
&lt;p>분산 시스템에서 다루는 데이터 양은 매우 커질 수 있으나 계산법은 기본을 크게 벗어나지 않는다.&lt;/p>
&lt;p>제데로 된 계산 결과를 얻으려면 데이터 볼륨의 단위를 2의 제곱수로 표현하면 어떻게 되는지를 알아야한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>2의 x 제곱&lt;/th>
&lt;th>근사치&lt;/th>
&lt;th>이름&lt;/th>
&lt;th>축약형&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>10&lt;/td>
&lt;td>1천&lt;/td>
&lt;td>1킬로바이트&lt;/td>
&lt;td>1KB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>20&lt;/td>
&lt;td>1백만&lt;/td>
&lt;td>1메가바이트&lt;/td>
&lt;td>1MB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>30&lt;/td>
&lt;td>10억&lt;/td>
&lt;td>1기가바이트&lt;/td>
&lt;td>1GB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>40&lt;/td>
&lt;td>1조&lt;/td>
&lt;td>1테라바이트&lt;/td>
&lt;td>1TB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>50&lt;/td>
&lt;td>1000조&lt;/td>
&lt;td>1페타바이트&lt;/td>
&lt;td>1PB&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="모든-프로그래머가-알아야-하는-응답지연-값">모든 프로그래머가 알아야 하는 응답지연 값&lt;/h2>
&lt;p>구글의 제프 딘은 2010년에 &lt;strong>통상적인 컴퓨터에서 구현된 연산들의 응답지연 값&lt;/strong>을 공개한 바 있다.&lt;/p>
&lt;p>컴퓨터의 성능이 더 좋아지며 유효하진 않지만, 연산의 처리 속도가 어느정도인지 가늠해볼 수는 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>연산명&lt;/th>
&lt;th>시간&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>L1 캐시 참조&lt;/td>
&lt;td>0.5ns&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>분기 예측 오류(branch mispredict)&lt;/td>
&lt;td>5ns&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>L2 캐시 참조&lt;/td>
&lt;td>7ns&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>뮤텍스 락/언락&lt;/td>
&lt;td>100ns&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주 메모리 참조&lt;/td>
&lt;td>100ns&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Zippy로 1 KB 압축&lt;/td>
&lt;td>10,000ns = 10µs&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1 Gbps 네트워크로 2 KB 전송&lt;/td>
&lt;td>20,000ns = 20µs&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>메모리에서 1 MB 순차적으로 read&lt;/td>
&lt;td>250,000ns = 250µs&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>같은 데이터 센터 내에서의 메시지 왕복 지연 시간&lt;/td>
&lt;td>500,000ns = 500µs&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>디스크 탐색(seek)&lt;/td>
&lt;td>10,000,000ns = 10ms&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>네트워크에서 1 MB 순차적으로 read&lt;/td>
&lt;td>10,000,000ns = 10ms&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>디스크에서 1 MB 순차적으로 read&lt;/td>
&lt;td>30,000,000ns = 30ms&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>한 패킷의 캘리포니아로부터 네덜란드까지의 왕복 지연 시간&lt;/td>
&lt;td>150,000,000ns = 150ms&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>한 구글 엔지니어가 딘 박사가 나열한 수들을 시각화하였고, 최근 기술 동향(2020)이 반영되어있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/2/img.png"
width="606"
height="594"
srcset="https://codemario318.github.io/post/system-design-interview/2/img_hu0f7c2f161aa870801df5883ac4825f9d_187921_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/2/img_hu0f7c2f161aa870801df5883ac4825f9d_187921_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="102"
data-flex-basis="244px"
>&lt;/p>
&lt;p>이 수치들을 분석하면 다음과 같은 결론이 나온다.&lt;/p>
&lt;ul>
&lt;li>메모리는 빠르지만 디스크는 아직도 느리다.&lt;/li>
&lt;li>디스크 탐색(seek)는 가능한 한 피하라.&lt;/li>
&lt;li>단순한 압축 알고리즘은 빠르다.&lt;/li>
&lt;li>데이터를 인터넷으로 전송하기 전에 가능하면 압축하라.&lt;/li>
&lt;li>데이터 센터는 보통 여러 지역에 분산되어 있고, 센터들 간에 데이터를 주고받는 데는 시간이 걸린다.&lt;/li>
&lt;/ul>
&lt;h2 id="가용성에-관계된-수치들">가용성에 관계된 수치들&lt;/h2>
&lt;p>고가용성(high availability)은 시스템이 오랜 시간 동안 지속적으로 중단 없이 운영될 수 있는 능력을 지칭하는 용어다.&lt;/p>
&lt;p>고가용성을 표현하는 값은 퍼센트로 표현하는데, 100%는 시스템이 단 한 번도 중단된 적이 없었음을 의미하며, 대부분의 서비스는 99%에서 100% 사이의 값을 갖는다.&lt;/p>
&lt;p>SLA(Service Level Agreement)는 서비스 사업자(service provider)가 보편적으로 사용하는 용어로, &lt;strong>서비스 사업자와 고객 사이에 맺어진 합의&lt;/strong>를 의미한다.&lt;/p>
&lt;p>이 합의에는 서비스 사업자가 제공하는 서비스의 가용시간(uptime)이 공식적으로 기술되어 있다.&lt;/p>
&lt;p>가용시간은 관습적으로 숫자 9를 사용해 표시하며, 9가 많을수록 좋다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>가용률&lt;/th>
&lt;th>하루당 장애시간&lt;/th>
&lt;th>주당 장애시간&lt;/th>
&lt;th>개월당 장애시간&lt;/th>
&lt;th>연간 장애시간&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>99%&lt;/td>
&lt;td>14.40분&lt;/td>
&lt;td>1.68시간&lt;/td>
&lt;td>7.31시간&lt;/td>
&lt;td>3.65일&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>99.9%&lt;/td>
&lt;td>1.44분&lt;/td>
&lt;td>10.08분&lt;/td>
&lt;td>43.83분&lt;/td>
&lt;td>8,77시간&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>99.99%&lt;/td>
&lt;td>8.64초&lt;/td>
&lt;td>1.01분&lt;/td>
&lt;td>4.38분&lt;/td>
&lt;td>52.60분&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>99.999%&lt;/td>
&lt;td>864.00밀리초&lt;/td>
&lt;td>6.05초&lt;/td>
&lt;td>26.30&lt;/td>
&lt;td>5.26분&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>99.9999&lt;/td>
&lt;td>86.40밀리초&lt;/td>
&lt;td>604.80밀리초&lt;/td>
&lt;td>2.63초&lt;/td>
&lt;td>31.56초&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="예제-트위터-qps와-저장소-요구량-추정">예제: 트위터 QPS와 저장소 요구량 추정&lt;/h2>
&lt;p>&lt;strong>가정&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>월간 능동 사용자(monthly active user)는 3억(300million) 명이다.&lt;/li>
&lt;li>50%의 사용자가 트위터를 매일 사용한다.&lt;/li>
&lt;li>평균적으로 각 사용자는 매일 2건의 트윗을 올린다.&lt;/li>
&lt;li>미디어를 포함하는 트윗은 10% 정도다.&lt;/li>
&lt;li>데이터는 5년간 보관된다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>추정&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>QPS(Query Per Second) 추정치
&lt;ul>
&lt;li>일간 능동 사용자(Daily Active User, DAU) = 3억 * 0.5 = 1.5억&lt;/li>
&lt;li>QPS = 1.5억 * 2트윗 / 24시간 / 3600초 = 약 3500&lt;/li>
&lt;li>최대 QPS(Peek QPS) = 2 * QPS = 약 7000&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>미디어 저장을 위한 저장소 요구량
&lt;ul>
&lt;li>평균 트윗 크기
&lt;ul>
&lt;li>tweet_id에 64바이트&lt;/li>
&lt;li>텍스트에 140바이트&lt;/li>
&lt;li>미디어에 1MB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>미디어 저정소 요구량 = 1.5억 * 2 * 0.1 * 1MB = 30TB/일&lt;/li>
&lt;li>5년간 미디어를 보관하기 위한 저장소 요구량: 30TB * 365 * 5 = 약 55PB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="팁">팁&lt;/h2>
&lt;p>개략적인 규모 추정과 관계된 면접에서 가장 중요한 것은 &lt;strong>문제를 풀어 나가는 절차&lt;/strong>다.&lt;/p>
&lt;p>&lt;strong>올바른 절차를 밟느냐가 결과를 내는 것보다 중요&lt;/strong>하다.&lt;/p>
&lt;ul>
&lt;li>근사치를 활용한 계산(rounding and approximation):
&lt;ul>
&lt;li>적절한 근사치를 활용하여 시간을 절약하자.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가정(assumption)들은 적어 둔다.&lt;/li>
&lt;li>단위(unit)을 붙여라.
&lt;ul>
&lt;li>헷갈리게 되므로, 단위를 붙이는 습고나을 들여 모호함을 방지할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>QPS, 최대 QPS, 저장소 요구량, 캐시 요구량, 서버 수 등을 추정하는 것이 자주 출제된다.&lt;/li>
&lt;/ul></description></item><item><title>1. 사용자 수에 따른 규모 확장성</title><link>https://codemario318.github.io/post/system-design-interview/1/</link><pubDate>Mon, 22 Apr 2024 14:53:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/1/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/cover.png" alt="Featured image of post 1. 사용자 수에 따른 규모 확장성" />&lt;p>수백만 사용자를 지원하는 시스템을 설계하는 것은 도전적인 과제이며, 지속적인 계량과 끝없는 개선이 요구되는 여정이다.&lt;/p>
&lt;p>이번 장은 한 명의 사용자를 지원하는 시스템에서 시작하여, 최종적으로 몇백만 사용자를 지원하는 시스템을 설계해본다.&lt;/p>
&lt;h2 id="단일-서버">단일 서버&lt;/h2>
&lt;p>모든 컴포넌트가 단 한대의 서버에서 실행되는 간단한 시스템부터 설계해보자.&lt;/p>
&lt;p>웹 앱, 데이터베이스, 캐시 등이 전부 서버 한 대에서 실행된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img.png"
width="615"
height="390"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_hu499b8fa6fe43f3f924784d377eb4708e_41034_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_hu499b8fa6fe43f3f924784d377eb4708e_41034_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="157"
data-flex-basis="378px"
>&lt;/p>
&lt;p>&lt;strong>사용자 요청 처리 흐름&lt;/strong>&lt;br>
&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_1.png"
width="608"
height="382"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_1_hua0cbd5db31f0ad82b45addc6a6db9692_42287_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_1_hua0cbd5db31f0ad82b45addc6a6db9692_42287_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="159"
data-flex-basis="381px"
>&lt;/p>
&lt;ol>
&lt;li>사용자는 도메인 이름(api.mysite.com)을 이용하여 웹사이트에 접속한다. 이 접속을 위해 DNS에 질의하여 IP 주소로 변환하는 과정을 치게 된다.
&lt;ul>
&lt;li>DNS는 보통 서드 파티가 제공하는 유료 서비스를 이용하므로 시스템의 일부는 아니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DNS 조회 결과로 IP 주소가 반환된다.&lt;/li>
&lt;li>해당 IP 주소로 HTTP 요청이 전달된다.&lt;/li>
&lt;li>요청을 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환한다.&lt;/li>
&lt;/ol>
&lt;p>실제 요청은 웹 앱과 모바일 앱 두가지 종류에 단말로 부터 온다.&lt;/p>
&lt;ul>
&lt;li>웹 애플리케이션
&lt;ul>
&lt;li>비즈니스 로직, 데이터 저장 등을 처리하기 위해서 서버 구현용 언어(자바, 파이썬 등)를 사용한다.&lt;/li>
&lt;li>프레젠테이션 용으로는 클라이언트 구현용 언어(HTML, 자바스크립트 등)를 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모바일 앱
&lt;ul>
&lt;li>모바일 앱과 웹 서버 간 통신을 위해서는 HTTP 프로토콜을 이용한다.&lt;/li>
&lt;li>반환될 응답 데이터의 포맷으로는 보통 JSON이 널리 쓰인다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="데이터베이스">데이터베이스&lt;/h2>
&lt;p>사용자가 늘면 서버 하나로는 충분하지 않아서 여러 서버를 두어야 한다.&lt;/p>
&lt;ul>
&lt;li>웹/모바일 트래픽 처리&lt;/li>
&lt;li>데이터베이스&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_2.png"
width="612"
height="377"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_2_hub3bdf37c2a22d7f06e833db20a5f8b0a_53786_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_2_hub3bdf37c2a22d7f06e833db20a5f8b0a_53786_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="162"
data-flex-basis="389px"
>&lt;/p>
&lt;p>웹/모바일 트래픽 처리 서버(웹 계층)와 데이터베이스 서버(데이터 계층)를 분리하면 그 각각을 독립적으로 확장해 나갈 수 있게 된다.&lt;/p>
&lt;h3 id="어떤-데이터베이스를-사용할-것인가">어떤 데이터베이스를 사용할 것인가?&lt;/h3>
&lt;p>전통적인 관계형 데이터베이스와 비-관계형 데이터베이스 사이에서 고를 수 있다.&lt;/p>
&lt;ul>
&lt;li>관계형 데이터베이스
&lt;ul>
&lt;li>관계형 데이터베이스 관리 시스템(RDBMS)이라고도 부르며, 자료를 테이블과 열, 컬럼으로 표현한다.&lt;/li>
&lt;li>SQL을 사용하면 여러 테이블에 있는 데이터를 그 관계에 따라 조인(join)하여 합칠 수 있다.&lt;/li>
&lt;li>ex) MySQL, Oracle, PostgreSQL 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비-관계형 데이터 베이스
&lt;ul>
&lt;li>NoSQL이라고도 부른다.&lt;/li>
&lt;li>키-값 저장소(key-value store), 그래프 저장소(graph store), 컬럼 저장소(column store), 문서 저장소(document store) 네 부류로 나뉜다.&lt;/li>
&lt;li>비-관계형 데이터베이스는 일반적으로 조인 연산은 지원하지 않는다.&lt;/li>
&lt;li>ex) CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>대부분의 개발자에게는 40년 이상 시장에서 살아남아 잘 사용되어온 관계형 데이터베이스가 최선이다.&lt;/p>
&lt;p>하지만 구축하려는 시스템에 적합하지 않은 경우에는 관계형 데이터베이스 이외의 저장소도 살펴보아야한다.&lt;/p>
&lt;ul>
&lt;li>아주 낮은 응답 지연시간(latency)이 요구됨&lt;/li>
&lt;li>다루는 데이터가 비정형(unstructured)이라 관계형 데이터가 아님&lt;/li>
&lt;li>데이터(JSON, YAML, XML 등)를 직렬화하거나(serialize) 역직렬화(deserialize) 할 수 있기만 하면 됨&lt;/li>
&lt;li>아주 많은 양의 데이터를 저장할 필요가 있음&lt;/li>
&lt;/ul>
&lt;h2 id="수직적-규모-확장-vs-수평적-규모-확장">수직적 규모 확장 VS 수평적 규모 확장&lt;/h2>
&lt;h3 id="수직적-규모-확장vertical-scaling">수직적 규모 확장(vertical scaling)&lt;/h3>
&lt;p>&lt;strong>스케일 업(scale up)&lt;/strong> 이라고도 불리는 수직적 규모 확장 프로세스는 서버에 고사양 자원을 추가하는 행위를 말한다.&lt;/p>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>서버로 유입되는 트래픽의 양이 적을 때는 수직적 확장이 좋은 선택이다.&lt;/li>
&lt;li>단순하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법이 없어 한계가 있다.&lt;/li>
&lt;li>장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안을 제시하지 않는다.
&lt;ul>
&lt;li>서버에 장애가 발생하면 완전히 중단된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="수평적-규모-확장horizontal-scaling">수평적 규모 확장(horizontal scaling)&lt;/h3>
&lt;p>&lt;strong>스케일 아웃(scale out)&lt;/strong> 이라고도 불리는 수평적 규모 확장 프로세스는 더 많은 서버를 추가하여 성능을 개선하는 행위를 말한다.&lt;/p>
&lt;p>수직적 규모 확장에서 언급된 단점으로 인해 대규모 애플리케이션을 지원하는 데는 수평적 규모 확장법이 보다 적절하다.&lt;/p>
&lt;hr>
&lt;p>수평적 규모 확장을 위해 추가적인 장치가 필요하다.&lt;/p>
&lt;p>앞서 본 설계에서 사용자가 웹 서버로 바로 연결되는데,&lt;/p>
&lt;ul>
&lt;li>웹 서버가 다운되면 사용자는 웹 사이트에 접속할 수 없다.&lt;/li>
&lt;li>너무 많은 사용자가 접속하여 웹 서버가 한계에 도달하면 응답 속도가 느려지거나 서버 접속이 불가능해질 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이런 문제를 해결하는 데는 부하 분산기 또는 로드밸런서를 도입하는 것이 최선이다.&lt;/p>
&lt;h3 id="로드밸런서load-balancer">로드밸런서(Load balancer)&lt;/h3>
&lt;p>로드밸런서는 부하 분산 집합(load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_3.png"
width="608"
height="540"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_3_huf74bbc3ffd6647fb098a2fc03966306f_85207_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_3_huf74bbc3ffd6647fb098a2fc03966306f_85207_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="270px"
>&lt;/p>
&lt;ul>
&lt;li>사용자는 로드밸런서의 공개 IP 주소로 접속하므로, 웹 서버는 클라이언트의 접속을 직접 처리하지 않는다.&lt;/li>
&lt;li>보안을 위해 서버 간 통신에는 사설 IP 주소가 이용된다.
&lt;ul>
&lt;li>같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 IP 주소로, 인터넷을 통해서 접속할 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>부하 분산 집합에 또 하나의 웹 서버를 추가하고 나면, 장애를 자동복구하지 못하는 문제(no failover)는 해소되며, 웹 계층의 가용성(availability)은 향상된다.&lt;/p>
&lt;ul>
&lt;li>서버 1이 다운되면 모든 트래픽은 서버 2로 전송된다.
&lt;ul>
&lt;li>웹 사이트 전체가 다운되는 일이 방지된다.&lt;/li>
&lt;li>부하를 나누기 위해 새로운 서버를 추가할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹사이트로 유입되는 트래픽이 가파르게 증가할 경우 웹 서버 계층에 더 많은 서버를 추가하면 로드밸런스가 자동적으로 트래픽을 분산한다.&lt;/li>
&lt;/ul>
&lt;h3 id="데이터베이스-다중화">데이터베이스 다중화&lt;/h3>
&lt;p>많은 데이터베이스들이 주(master)-부(slave) 관계를 설정하여 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식으로 다중화를 지원한다.&lt;/p>
&lt;p>쓰기 연산은 마스터에만 지원하며, 부 데이터베이스는 주 데이터베이스로부터 그 사본을 전달받아 읽기 연산만을 지원한다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스를 변경하는 명령어(&lt;code>INSERT&lt;/code>, &lt;code>DELETE&lt;/code>, &lt;code>UPDATE&lt;/code> 등)는 주 데이터베이스로만 전달되어야 한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_4.png"
width="612"
height="546"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_4_hu75d2f6312382855c75a554918b468d43_102326_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_4_hu75d2f6312382855c75a554918b468d43_102326_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="269px"
>&lt;/p>
&lt;p>데이터베이스르 다중화하면 다음과 같은 이득이 있다.&lt;/p>
&lt;ul>
&lt;li>더 나은 성능
&lt;ul>
&lt;li>모든 데이터 변경 연산은 주 데이터베이스 서버로만 전달되는 반면 읽기 연산은 부 데이터베이스 서버들로 분산되어 병렬로 처리될 수 있는 질의(query)가 늘어나므로, 성능이 좋아진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>안정성
&lt;ul>
&lt;li>자연 재해 등의 이유로 데이터베이스 서버 가운데 일부가 파괴되어도 데이터는 보존된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성
&lt;ul>
&lt;li>데이터를 여러 지역에 복제해 둠으로써, 하나의 데이터베이스 서버에 장애가 발생하더라도 다른 서버에 있는 데이터로 계속 서비스할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위와 같은 데이터계층을 구성하면 데이터베이스 서버 가운데 하나가 다운되더라도 아래와 같은 상황을 감당할 수 있다.&lt;/p>
&lt;ul>
&lt;li>부 서버 한대뿐인데 다운된 경우
&lt;ul>
&lt;li>읽기 연산이 한시적으로 주 데이터베이스로 전달된다.&lt;/li>
&lt;li>즉시 새로운 부 데이터베이스 서버가 장애 서버를 대처한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>부 서버 중 한대가 다운된 경우
&lt;ul>
&lt;li>일기 연산이 나머지 부 데이터베이스 서버로 분산된다.&lt;/li>
&lt;li>새로운 부 데이터베이스 서버가 장애 서버를 대체한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>주 데이터베이스 서버가 다운된 경우
&lt;ul>
&lt;li>부 데이터베이스 서버 중 하나가 새로운 주 서버가 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="다중화를-고려한-설계">다중화를 고려한 설계&lt;/h3>
&lt;p>아래는 로드밸런서와 데이터베이스 다중화를 고려한 설계안이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_5.png"
width="615"
height="680"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_5_hu0d3cc45b151b2f2d78ede4b0a35c84d1_160088_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_5_hu0d3cc45b151b2f2d78ede4b0a35c84d1_160088_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="90"
data-flex-basis="217px"
>&lt;/p>
&lt;ol>
&lt;li>사용자는 DNS로부터 로드밸런서의 공개 IP 주소를 받는다.&lt;/li>
&lt;li>사용자는 해당 IP 주소를 사용해 로드밸런서에 접속한다.&lt;/li>
&lt;li>HTTP 요청은 서버 1이나 서버 2로 전달된다.&lt;/li>
&lt;li>웹 서버는 사용자의 데이터를 부 데이터베이스 서버에서 읽는다.&lt;/li>
&lt;li>웹 서버는 데이터 변경 연산은 주 데이터베이스로 전달한다.&lt;/li>
&lt;/ol>
&lt;h2 id="캐시-cache">캐시 Cache&lt;/h2>
&lt;p>캐시를 붙여 응답 시간(latency)를 개선해볼 수 있다.&lt;/p>
&lt;p>캐시는 &lt;strong>값비싼 연산 결과&lt;/strong> 또는 &lt;strong>자주 참조되는 데이터&lt;/strong>를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소이다.&lt;/p>
&lt;p>애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 크게 좌우되는데, 캐시는 그런 문제를 완화할 수 있다.&lt;/p>
&lt;h3 id="캐시-계층">캐시 계층&lt;/h3>
&lt;p>캐시 계층(cache tier)은 데이터가 잠시 보관되는 곳으로 데이터베이스보다 훨씬 빠르다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스보다 훨씬 빠르므로 성능이 개선된다.&lt;/li>
&lt;li>요청 분산으로 데이터베이스의 부하를 줄일 수 있다.&lt;/li>
&lt;li>캐시 계층의 규모를 독립적으로 확장시키는 것도 가능해진다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_6.png"
width="613"
height="116"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_6_huc62d7a17723bf3e18e1d3339b357022d_33317_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_6_huc62d7a17723bf3e18e1d3339b357022d_33317_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="528"
data-flex-basis="1268px"
>&lt;/p>
&lt;p>요청받은 웹 서버는 캐시에 응답이 저장되어 있는지를 확인 후 저장되어 있다면 해당 데이터 반환하고 없을 경우 데이터베이스 조회하여 결과를 반환하는데, 이러한 캐시 전략을 &lt;strong>읽기 주도형 캐시 전략(read-through caching strategy)&lt;/strong> 이라고 부른다.&lt;/p>
&lt;p>이외에도 다양한 캐시 전략이 있으며, 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 선택하면 된다.&lt;/p>
&lt;ul>
&lt;li>쓰기 주도형 캐시 전략 (Write-Through Cache)
&lt;ul>
&lt;li>데이터를 업데이트할 때 캐시와 백엔드 데이터 소스 모두에 동시에 업데이트&lt;/li>
&lt;li>데이터 일관성을 유지하면서 쓰기 작업을 처리&lt;/li>
&lt;li>쓰기 작업의 경우 백엔드 저장소로의 추가적인 I/O 작업이 필요하므로 성능 저하의 가능성이 있지만, 데이터 일관성을 보장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>쓰기 지연형 캐시 전략 (Write-Behind Cache)
&lt;ul>
&lt;li>데이터 업데이트를 먼저 캐시에만 적용하고, 나중에 백엔드 데이터 소스에 업데이트를 적용&lt;/li>
&lt;li>이는 쓰기 작업의 지연을 최소화하여 응답 시간을 줄이는 데 도움&lt;/li>
&lt;li>쓰기 지연형 캐시는 데이터 일관성을 유지하기 위해 추가적인 메커니즘을 필요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>자세한 내용의 캐시 전략 (Write-Through and Read-Through Cache):
&lt;ul>
&lt;li>읽기와 쓰기 모두에 대해 캐시를 사용하는 전략&lt;/li>
&lt;li>데이터가 요청될 때마다 읽기 주도형 캐시와 유사하게 작동하며, 데이터가 업데이트될 때마다 쓰기 주도형 캐시와 유사한 방식으로 작동&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>캐시 앞 단의 캐시 전략 (Cache-Aside Cache):
&lt;ul>
&lt;li>클라이언트가 데이터를 직접 캐시에 저장하고 검색하는 방식&lt;/li>
&lt;li>캐시에 데이터가 없는 경우 클라이언트는 백엔드 데이터 소스에서 직접 데이터를 가져와서 캐시에 저장하고 응답&lt;/li>
&lt;li>이 방식은 간단하고 유연하며, 응용 프로그램 코드 내에 캐시 로직을 명시적으로 구현할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이중 캐시 전략 (Two-Level Cache):
&lt;ul>
&lt;li>두 개의 캐시 레이어를 사용하여 성능을 최적화&lt;/li>
&lt;li>보통 두 개의 캐시는 크기와 접근 속도 등에서 차이가 있음&lt;/li>
&lt;li>먼저 작은 고속 캐시가 데이터를 저장하고, 그 다음에 큰 용량의 캐시가 데이터를 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오프힙 로컬 캐시 전략 (Off-Heap Local Cache Strategy):
&lt;ul>
&lt;li>캐시를 메모리 외의 오프힙(Off-Heap) 영역에 저장하여 자바 가상 머신의 힙 메모리 한계를 초과하는 데이터 양을 처리할 수 있게 함&lt;/li>
&lt;li>이는 대규모 캐시나 대용량 데이터를 다룰 때 유용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="캐시-사용-시-유의할-점">캐시 사용 시 유의할 점&lt;/h3>
&lt;ul>
&lt;li>데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어나는 경우 고려할 수 있다.&lt;/li>
&lt;li>캐시는 데이터를 휘발성 메모리에 두므로, 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다.&lt;/li>
&lt;li>데이터를 무기한 보존할 수 없으므로 만료에 대한 정책을 마련해야한다.
&lt;ul>
&lt;li>너무 짧으면 데이터베이스 읽기가 자주 발생한다.&lt;/li>
&lt;li>너무 길면 원본과 차이 날 가능성이 높아진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 일관성이 깨질 수 있다.&lt;/li>
&lt;li>캐시 서버를 한 대만 두는 경우 해당 서버가 단일 장애 지점(Single Point of Failure, SPOF)이 되어버릴 가능성이 있다.
&lt;ul>
&lt;li>여러 지역에 걸처 캐시 서버를 분산시켜야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>캐시 메모리가 너무 작으면 액세스 패턴에 따라 데이터가 자주 캐시에서 밀려나 성능이 떨어지게 된다.
&lt;ul>
&lt;li>캐시 메모리를 과할당하면 데이터가 갑자기 늘어났을 때 생길 문제를 방지할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>캐시가 가득 찼을 때 추가로 데이터를 넣기 위한 데이터 방출 정책을 적절히 지정해야한다.
&lt;ul>
&lt;li>가장 널리 쓰이는 것은 LRU(least Recently Used - 가장 오래 사용 안된 데이터)나 FIFO(가장 먼저 들어온) 등이 있으며 경우에 맞게 적용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="콘텐츠-전송-네트워크-cdn">콘텐츠 전송 네트워크 CDN&lt;/h2>
&lt;p>응답 시간을 개선할 방법으로 CDN(Content Delivery Network)를 적용해 볼 수 있다.&lt;/p>
&lt;p>CDN은 정적 콘텐츠를 전성하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크이다. (이미지, 비디오, CSS, JS 파일 등)&lt;/p>
&lt;ul>
&lt;li>요청 경로, 질의 문자열, 쿠키, 요청 헤더 등의 정보에 기반하여 HTML을 캐싱하는 &lt;strong>동적 콘텐츠 캐싱&lt;/strong>도 적용해 볼 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_7.png"
width="605"
height="231"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_7_hu799239a592ed42b7290231250760d8ad_30988_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_7_hu799239a592ed42b7290231250760d8ad_30988_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="261"
data-flex-basis="628px"
>&lt;/p>
&lt;p>어떤 사용자 웹 사이트를 방문하면, 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달하며, 사용자가 CDN 서버로부터 멀어질 수록 천천히 로드될 것이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_8.png"
width="612"
height="218"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_8_hu5d5fc61be434c460205659abbfd7acf0_63071_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_8_hu5d5fc61be434c460205659abbfd7acf0_63071_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="280"
data-flex-basis="673px"
>&lt;/p>
&lt;ol>
&lt;li>사용자 A가 이미지 URL을 이용해 &lt;code>image.png&lt;/code>에 접근한다.(URL의 도메인은 CDN 서비스 사업자가 제공한다.)&lt;/li>
&lt;li>CDN 서버의 캐시에 해당 이미지가 없는 경우 원본 서버에서 요청하여 파일을 가져온다.&lt;/li>
&lt;li>원본 서버가 파일을 CDN 서버에 반환한다.
&lt;ul>
&lt;li>응답 HTTP 헤더에 TTL(Time-To-Live) 값을 넣어 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CDN 서버는 파일을 캐시하고 사용자 A에게 반환한다.
&lt;ul>
&lt;li>이미지는 TTL에 명신된 시간이 끝날 때 까지만 캐시된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자 B가 같은 이미지를 CDN 서버에게 요청한다.&lt;/li>
&lt;li>만료되지 않은 이미지에 대한 요청은 캐시를 통해 처리된다.&lt;/li>
&lt;/ol>
&lt;h3 id="cdn-사용-시-고려해야-할-사항">CDN 사용 시 고려해야 할 사항&lt;/h3>
&lt;ul>
&lt;li>비용
&lt;ul>
&lt;li>CDN은 보통 서드파티에 의해 운영되며, CDN으로 들어가고 나가는 데이터 전송 양에 따라 요금을 낸다.&lt;/li>
&lt;li>자주 사용되지 않는 콘텐츠를 캐싱하는 것은 이득이 적으므로, CDN에서 빼는 것을 고려할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>적절한 만료 시한 설정
&lt;ul>
&lt;li>시의성이 중요한(time-sensitive) 콘텐츠는 만료 시점을 잘 정해야한다.&lt;/li>
&lt;li>너무 길면 콘텐츠의 신선도가 떨어진다.&lt;/li>
&lt;li>너무 짧으면 원본 서버에 빈번히 접속되어 좋지 않다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CDN 장애 대처 방안
&lt;ul>
&lt;li>CDN 자체가 죽었을 경우 애플리케이션이 어떻게 동작해야 하는지 고려해야 한다.&lt;/li>
&lt;li>응답을 감지하여 원본 서버에서 가져오는 등의 방식으로 처리한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>콘텐츠 무효화 방법
&lt;ul>
&lt;li>만료되지 않은 콘텐츠라도 CDN에서 제거할 수 있다.&lt;/li>
&lt;li>CDN 서비스 사업자가 제공하는 API 활용&lt;/li>
&lt;li>콘텐츠의 다른 버전을 서비스 하도록 오브젝트 버저닝 이용.
&lt;ul>
&lt;li>&lt;code>image.png?v=2&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="cdn과-캐시가-추가된-설계">CDN과 캐시가 추가된 설계&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_9.png"
width="625"
height="670"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_9_hu460b71978870d67db3c5f1597124e471_170383_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_9_hu460b71978870d67db3c5f1597124e471_170383_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="93"
data-flex-basis="223px"
>&lt;/p>
&lt;ol>
&lt;li>정적 콘텐츠를 CDN을 통해 제공하여 더 나은 성능을 보장한다.&lt;/li>
&lt;li>캐시가 데이터베이스 부하를 줄여준다.&lt;/li>
&lt;/ol>
&lt;h2 id="무상태stateless-웹-계층">무상태(Stateless) 웹 계층&lt;/h2>
&lt;p>웹 계층을 수평적으로 확장하는 방법을 고민해 볼 수 있다.&lt;/p>
&lt;p>이를 위해 상태 정보(사용자 세션 등)를 웹 계층에서 제거해야한다.&lt;/p>
&lt;p>바람직한 전략은 상태 정보를 관계형 데이터베이스나 NoSQL 같은 지속성 저장소에 보관하고, 필요할 때 가져오도록 하는 것이다.&lt;/p>
&lt;p>이렇게 구성된 웹 계층을 &lt;strong>무상태 웹 계층&lt;/strong>이라 부른다.&lt;/p>
&lt;h3 id="상태-정보-의존적인-아키텍처">상태 정보 의존적인 아키텍처&lt;/h3>
&lt;p>상태 정보를 보고나하는 서버는 클라이언트 정보, 즉 상태를 유지하여 요청들 사이에 공유되도록 하지만, 무상태 서버에는 이러한 장치가 없다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_10.png"
width="624"
height="387"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_10_hu5fb9397f4d4b70e8494c0677a4642dc6_65604_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_10_hu5fb9397f4d4b70e8494c0677a4642dc6_65604_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="161"
data-flex-basis="386px"
>&lt;/p>
&lt;p>위와 같은 경우 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야 한다.&lt;/p>
&lt;p>로드밸런서가 이를 지원하기 위해 고정 세션이라는 기능을 제공하지만, 이는 로드밸런서에 부담을 줄 수 있다.&lt;/p>
&lt;p>또한 로드 밸런서 뒷단에 서버를 추가하거나 제거하기도 까다로워지며, 이들 서버의 장애를 처리하기도 복잡해진다.&lt;/p>
&lt;h3 id="무상태-아키텍처">무상태 아키텍처&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_11.png"
width="601"
height="582"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_11_hu39f308bbb91eb0dc2a5c19d7114ea62c_76175_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_11_hu39f308bbb91eb0dc2a5c19d7114ea62c_76175_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="103"
data-flex-basis="247px"
>&lt;/p>
&lt;p>무상태 아키텍처는 사용자로부터의 HTTP 요청은 어떤 웹 서버로도 전달될 수 있다.&lt;/p>
&lt;p>웹 서버는 상태 정보가 필요할 경우 물리적으로 분리된 공유 저장소로부터 데이터를 가져온다.&lt;/p>
&lt;h3 id="무상태-웹-계층을-갖는-설계">무상태 웹 계층을 갖는 설계&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_12.png"
width="592"
height="593"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_12_hu8a96a4f1289cdc64fec7a7b4b0f65b88_150815_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_12_hu8a96a4f1289cdc64fec7a7b4b0f65b88_150815_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="99"
data-flex-basis="239px"
>&lt;/p>
&lt;ul>
&lt;li>세션 데이터를 웹 계층에서 분리하고 지속성 데이터 보관소에 저장하도록 만들었다.
&lt;ul>
&lt;li>공유 저장소는 관계형 데이터베이스일 수도 있고, 캐시일 수도 있으며, NoSQL일 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>상태 정보가 웹 서버들로부터 제거되었으므로 자동으로 규모를 확장할 수 있다.&lt;/li>
&lt;/ul>
&lt;h2 id="데이터-센터">데이터 센터&lt;/h2>
&lt;p>애플리케이션의 사용자가 매우 많다면 가용성을 높이고 쾌적하게 사용할 수 있도록 하기 위해 여러 데이터 센터를 지원하는 것이 필수적이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_13.png"
width="605"
height="612"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_13_huacec91b27a2e95c1fae44550dc9946c4_231088_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_13_huacec91b27a2e95c1fae44550dc9946c4_231088_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="98"
data-flex-basis="237px"
>&lt;/p>
&lt;p>&lt;strong>지리적 라우팅&lt;/strong>&lt;/p>
&lt;p>장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내되는데 이 절차를 지리적 라우팅(geoDNS-routing 또는 geo-routing)이라고 부른다.&lt;/p>
&lt;p>geoDNS는 사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변활할지 결정할 수 있도록 해주는 DNS 서비스다.&lt;/p>
&lt;p>&lt;strong>데이터 센터 장애&lt;/strong>&lt;/p>
&lt;p>데이터 센터 중 하나에 심각한 장애가 발생하면 모든 트래픽은 장애가 없는 데이터 센터로 전송된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_14.png"
width="598"
height="619"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_14_huae6b76823045f17d81dcfd1753a37701_207085_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_14_huae6b76823045f17d81dcfd1753a37701_207085_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="96"
data-flex-basis="231px"
>&lt;/p>
&lt;p>이에 따라 다중 데이터센터 아키텍처를 만들려면 몇 가지 기술적 난제를 해결해야 한다.&lt;/p>
&lt;ul>
&lt;li>트래픽 우회
&lt;ul>
&lt;li>올바른 데이터센터로 트래픽을 보내는 효과적인 방법을 찾아야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 동기화(Synchronization)
&lt;ul>
&lt;li>데이터를 여러 데이터센터에 걸쳐 다중화 하여, 장애 복구 시에도 데이터를 동기화 할 수 있도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>테스트와 배포
&lt;ul>
&lt;li>여러 데이터 센터를 사용하도록 시스템이 구성된 상황이라면 웹 사이트 또는 애플리케이션을 여러 위치에서 테스트 해보는 것이 중요하다.&lt;/li>
&lt;li>자동화된 배포 도구는 모든 데이터 센터에 동일한 서비스가 설치되도록 하는 데 중요한 일을 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="메시지-큐message-queue">메시지 큐(Message Queue)&lt;/h2>
&lt;p>시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하여, 각기 독립적으로 확장될 수 있어야 한다.&lt;/p>
&lt;p>메시지 큐는 분산 시스템이 이 문제를 풀기 위해 채용하고 있는 핵심 전략 가운데 하나다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_15.png"
width="606"
height="141"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_15_huc34a000f73eb7366f54fab25c10cd600_37954_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_15_huc34a000f73eb7366f54fab25c10cd600_37954_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="429"
data-flex-basis="1031px"
>&lt;/p>
&lt;p>메시지 큐는 메시지의 무손실을 보장하는 비동기 통신을 지원하는 컴포넌트로 메시지의 버퍼 역할을 하며, 비동기적으로 전송한다.&lt;/p>
&lt;ol>
&lt;li>생산자 또는 발행자라고 불리는 입력 서비스가 메시지를 만들어 메시지 큐에 발행한다.&lt;/li>
&lt;li>소비자 혹은 구독자라 불리는 서비스 혹은 서버가 메시지를 받아 그에 맞는 동작을 수행한다.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>메시지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해져서, 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.&lt;/p>
&lt;ul>
&lt;li>생산자는 소비자 프로세스가 다운되어 있어도 메시지를 발행할 수 있다.&lt;/li>
&lt;li>소비자는 생산자 서비스가 가용한 상태가 아니더라도 메시지를 수신할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>큐가 커지면 더 많은 작업 프로세스를 추가해야 처리 시간을 줄일 수 있으며, 큐가 거의 항상 비어있는 상태라면, 작업 프로세스의 수를 줄일 수 있다.&lt;/p>
&lt;h2 id="로그-메트릭-그리고-자동화">로그, 메트릭 그리고 자동화&lt;/h2>
&lt;p>웹 사이트와 함께 사업 규모가 커지고 나면, 로그나 메트릭, 자동화 같은 도구에 필수적으로 투자해야한다.&lt;/p>
&lt;ul>
&lt;li>로그
&lt;ul>
&lt;li>시스템의 오류와 문제들을 쉽게 찾아낼 수 있게 돕는다.&lt;/li>
&lt;li>로그를 단일 서비스로 모아주는 도구를 활용하면 더 편리하게 검색하고 조회할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메트릭
&lt;ul>
&lt;li>사업 현황에 관한 유용한 정보를 얻을 수도 있고, 시스템의 현재 상태를 쉽게 파악할 수 있다.&lt;/li>
&lt;li>호스트 단위 메트릭: CPU, 메모리, 디스크 I/O,에 관한 메트릭&lt;/li>
&lt;li>종합 메트릭: 데이터베이스 계층의 성능, 캐시 계층의 성능 등&lt;/li>
&lt;li>핵심 비즈니스 메트릭: 일별 능동 사용자, 수익, 재방문 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>자동화
&lt;ul>
&lt;li>시스템이 크고 복잡해지면 생산성을 높이기 위해 자동화 도구를 활용해야한다.&lt;/li>
&lt;li>지속적 통합을 활용한 검증 절차 수행 및 빌드, 테스트, 배포 절차 자동화 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="수정한-설계안">수정한 설계안&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_16.png"
width="595"
height="741"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_16_hu91dcf9847683962bf50eb168546423cd_177817_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_16_hu91dcf9847683962bf50eb168546423cd_177817_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="80"
data-flex-basis="192px"
>&lt;/p>
&lt;ul>
&lt;li>메시지 큐는 각 컴포넌트가 보다 느슨히 결합될 수 있도록 하고, 결함에 대한 내성을 높인다.&lt;/li>
&lt;li>로그, 모니터링, 메트릭, 자동화 등을 지원하기 위한 장치를 추가한다.&lt;/li>
&lt;/ul>
&lt;h2 id="데이터베이스-규모-확장">데이터베이스 규모 확장&lt;/h2>
&lt;p>저장할 데이터가 많아지면 데이터베이스에 대한 부하도 증가한다.&lt;/p>
&lt;p>데이터베이스의 규모를 확장하는데는 앞서 언급했던 수직적 규모 확장과 수평적 규모 확장을 고려할 수 있다.&lt;/p>
&lt;p>&lt;strong>수평적 확장&lt;/strong>&lt;/p>
&lt;p>기존 서버에 더 많은, 고성능의 자원을 증설하는 방법이다.&lt;/p>
&lt;p>스택오버플로는 천만 명의 사용자 전부를 단 한 대의 마스터 데이터베이스로 처리했다.&lt;/p>
&lt;p>하지만 언급했던대로 몇가지 심각한 약점이 있다.&lt;/p>
&lt;ul>
&lt;li>무한 증설할 수는 없다.&lt;/li>
&lt;li>SPOF로 인한 위험성이 크다.&lt;/li>
&lt;li>비용이 많이 든다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>수평적 확장&lt;/strong>&lt;/p>
&lt;p>데이터베이스의 수평적 확장은 샤딩(sharding)이라고도 부르는데, 더 많은 서버를 추가함으로써 성능을 향상시킬 수 있도록 한다.&lt;/p>
&lt;h3 id="샤딩">샤딩&lt;/h3>
&lt;ul>
&lt;li>대규모 데이터베이스를 샤드(shard)라고 부르는 작은 단위로 분할하는 기술을 일컫는다.&lt;/li>
&lt;li>모든 샤드는 같은 스키마를 쓰지만 보관되는 데이터 사이에는 중복이 없다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_17.png"
width="369"
height="266"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_17_huc997d539c0fa3f28c4bae7dad9a2068b_33539_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_17_huc997d539c0fa3f28c4bae7dad9a2068b_33539_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="138"
data-flex-basis="332px"
>&lt;/p>
&lt;p>위의 예시에서 &lt;code>user_id % 4&lt;/code>를 해시 함수로 사용하여 데이터가 보관되는 샤드를 정한다.&lt;/p>
&lt;p>이처럼 샤딩 전략을 구현할 때 고려해야 할 가장 중요한 것은 &lt;strong>샤딩 키&lt;/strong>를 어떻게 정하냐 하는 것이다.&lt;/p>
&lt;ul>
&lt;li>샤딩 키(파티션 키)는 데이터가 어떻게 분살될지 정하는 하나 이상의 컬럼으로 구성된다.&lt;/li>
&lt;li>샤딩 키를 통해 올바른 데이터베이스에 질의를 보내어 데이터 조회나 변경을 처리하므로 효율을 높일 수 있다.&lt;/li>
&lt;/ul>
&lt;p>샤딩 키를 정할 때는 데이터를 고르게 분할 할 수 있도록 하는 게 가장 중요하다.&lt;/p>
&lt;p>&lt;strong>주의사항&lt;/strong>&lt;/p>
&lt;p>샤딩은 데이터베이스 규모 확장을 실현하는 휼륭한 기술이지만 완벽하지 않으며, 도입하면 시스템이 복잡해지고 풀어야 할 새로운 문제도 생긴다.&lt;/p>
&lt;ul>
&lt;li>데이터의 재 샤딩
&lt;ul>
&lt;li>데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어려울 때&lt;/li>
&lt;li>샤드 소진: 샤드 간 데이터 분포가 균등하지 못하여 어떤 샤드에 할당된 공간 소모가 다른 사드에 비해 빨리 진행될 때&lt;/li>
&lt;li>이러한 형상이 발생하면 샤드 키를 계산하는 함수를 변경하고 데이터를 재배치 하여야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유명인사 문제(핫스팟 키 문제)
&lt;ul>
&lt;li>특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제다.&lt;/li>
&lt;li>특정 샤드의 원인에 대해 샤드를 하나씩 할당해야 할 수도 있고, 더 잘개 쪼개야 할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>조인과 비정규화
&lt;ul>
&lt;li>데이터베이스를 여러 샤드 서버로 쪼개고 나면, 여러 샤드에 걸친 데이터를 조인하기가 힘들어진다.&lt;/li>
&lt;li>데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="샤드를-적용한-아키텍처">샤드를 적용한 아키텍처&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_18.png"
width="643"
height="800"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_18_hu3cfaabe2145c01222e45ae94975b52ee_217530_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_18_hu3cfaabe2145c01222e45ae94975b52ee_217530_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="80"
data-flex-basis="192px"
>&lt;/p>
&lt;ul>
&lt;li>데이터베이스에 대한 부하를 줄이기 위해 굳이 관계형 데이터베이스가 요구되지 않는 기능들은 NoSQL로 이전할 수 있다.&lt;/li>
&lt;/ul>
&lt;h2 id="백만-사용자-그리고-그-이상">백만 사용자, 그리고 그 이상&lt;/h2>
&lt;p>시스템의 규모를 확장하는 것은 지속적이고 반복적인 과정이며, 이번 장에서 다룬 내용을 반복하다 보면 원하는 규모의 시스템을 달성할 수 있게 된다.&lt;/p>
&lt;p>그러나 수백만 사용자 이상을 지원하려면 새로운 전략을 도입해야 하고 지속적으로 시스템을 가다듬어야 할 것이다.&lt;/p>
&lt;ul>
&lt;li>시스템 최적화 및 마이크로서비스 등&lt;/li>
&lt;/ul>
&lt;h2 id="정리">정리&lt;/h2>
&lt;ul>
&lt;li>웹 계층은 무상태 계층으로&lt;/li>
&lt;li>모든 계층에 다중화 도입&lt;/li>
&lt;li>가능한 한 많은 데이터를 캐시할 것&lt;/li>
&lt;li>여러 데이터 센터를 지원할 것&lt;/li>
&lt;li>정적 콘텐츠는 CDN을 통해 서비스할 것&lt;/li>
&lt;li>데이터 계층은 샤딩을 통해 그 규모를 확장할 것&lt;/li>
&lt;li>각 계층은 독립적 서비스로 분할할 것&lt;/li>
&lt;li>시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것&lt;/li>
&lt;/ul></description></item><item><title>34. 빠져있는 장: By Simon Brown</title><link>https://codemario318.github.io/post/clean-architecture/34/</link><pubDate>Fri, 19 Apr 2024 15:59:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/34/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/cover.png" alt="Featured image of post 34. 빠져있는 장: By Simon Brown" />&lt;p>지금까지 읽은 모든 조언을 통해 올바르게 정의된 경계, 명확한 책임, 통제된 의존성을 가진 클래스와 컴포넌트로 구성된 좋은 소프트웨어를 설계할 수 있다.&lt;/p>
&lt;p>하지만 실제 적용에서는 &lt;strong>디테일&lt;/strong>(구현 세부사항)을 심사숙고하지 않는다면 마지막 고비에 걸려 넘어지기 십상이다.&lt;/p>
&lt;h2 id="계층-기반-패키지">계층 기반 패키지&lt;/h2>
&lt;p>가장 단순한 설계 방식으로 &lt;strong>전통적인 수평 계층형 아키텍처&lt;/strong>가 있다.&lt;/p>
&lt;p>&lt;strong>계층 기반 패키지&lt;/strong>라고도 불리는 이 방법은 기술적인 관점에서 해당 코드가 하는 일에 기반해 그 코드를 분할한다.&lt;/p>
&lt;p>이러한 전형적인 계층형 아키텍처에는 웹, 업무 규칙, 영속성 코드를 위해 계층이 각각 하나씩 존재한다.&lt;/p>
&lt;p>코드는 계층이라는 얇은 수평 조각으로 나뉘며, 각 계층은 유사한 종류의 것들을 묶는 도구로 사용된다.&lt;/p>
&lt;ul>
&lt;li>엄격한 계층형 아키텍처의 경우 계층은 반드시 바로 아래 계층에만 의존해야한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img.png"
width="635"
height="674"
srcset="https://codemario318.github.io/post/clean-architecture/34/img_hu09d1a64cd1e72f2d69d142c6a608bf93_75674_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img_hu09d1a64cd1e72f2d69d142c6a608bf93_75674_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="94"
data-flex-basis="226px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;code>OrdersController&lt;/code>
&lt;ul>
&lt;li>웹 컨트롤러이며, 웹 기반 요청을 처리한다.&lt;/li>
&lt;li>ex) Spring MVC 컨트롤러 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>OrdersService&lt;/code>
&lt;ul>
&lt;li>주문 관련 업무 규칙을 정의하는 인터페이스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>OrdersServiceImpl&lt;/code>
&lt;ul>
&lt;li>&lt;code>OrdersService&lt;/code>의 구현체&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>OrdersRepository&lt;/code>
&lt;ul>
&lt;li>영구 저장된 주문 정보에 접근하는 방법을 정의하는 인터페이스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>JdbcOrdersRepository&lt;/code>
&lt;ul>
&lt;li>&lt;code>OrdersRespository&lt;/code>의 구현체&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>마틴 파울러는 &lt;strong>프레젠테이션 도메인 데이터&lt;/strong> 계층화에서 처음 시작하기에는 계층형 아키텍처가 적합하다고 언급한다.&lt;/p>
&lt;ul>
&lt;li>엄청난 복잡함을 겪지 않고도 무언가를 작동시켜 주는 아주 빠른 방법이다.&lt;/li>
&lt;li>소프트웨어가 커지고 복잡해지기 시작하면 세 개의 계층으로만은 부족하다 느끼고 더 잘게 모듈화 해야할 필요성을 느낄 수 있다.&lt;/li>
&lt;li>업무 도메인에 대해 아무것도 말해주지 않는다.&lt;/li>
&lt;/ul>
&lt;h2 id="기능-기반-패키지">기능 기반 패키지&lt;/h2>
&lt;p>&lt;strong>기능 기반 패키지&lt;/strong> 구조는 서로 연관된 기능, 도메인 개념, (도메인 주도 설계 용어를 자주 사용한다면) Aggregate Root에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img2.png"
width="627"
height="670"
srcset="https://codemario318.github.io/post/clean-architecture/34/img2_hub33c374a47ec3a9ae590abdd19e1dc17_60523_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img2_hub33c374a47ec3a9ae590abdd19e1dc17_60523_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="93"
data-flex-basis="224px"
>&lt;/p>
&lt;p>인터페이스와 클래스는 이전과 같지만, 모두가 단 하나의 패키지에 속하게 된다.&lt;/p>
&lt;ul>
&lt;li>이는 &lt;strong>계층 기반 패키지&lt;/strong>를 아주 간단히 리팩터링한 형태지만 코드의 상위 수준 구조가 업무 도메인에 대해 무언가를 알려주게된다.&lt;/li>
&lt;li>유스케이스가 변경될 경우 변경해야 할 코드를 모두 찾는 작업이 더 쉬워질 수 있다.&lt;/li>
&lt;/ul>
&lt;p>소프트웨어 개발팀이 수평적 계층화의 문제를 깨닫고, 수직적 계층화로 전환하는 경우가 많지만, 두 접근법 모두 차선책이다.&lt;/p>
&lt;h2 id="포트와-어댑터">포트와 어댑터&lt;/h2>
&lt;p>포트와 어댑터(Ports and Adapters) 혹은 육각형 아키텍처(Hexagonal Architecture), 경계, 컨트롤러, 엔티티(BCE) 등의 방식으로 접근하는 이유는 업무/도메인에 초점을 둔 코드가 프레임워크나 데이터베이스 같은 기술적인 세부 구현과 독립적이며 분리된 아키텍처를 만들기 위해서다.&lt;/p>
&lt;p>그런 코드 베이스는 **내부(도메인)**와 **외부(인프라)**로 구성됨을 흔히 볼 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img3.png"
width="633"
height="485"
srcset="https://codemario318.github.io/post/clean-architecture/34/img3_hub97e2c2908d969078290a6c0afd4246d_67211_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img3_hub97e2c2908d969078290a6c0afd4246d_67211_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="130"
data-flex-basis="313px"
>&lt;/p>
&lt;ul>
&lt;li>내부 영역
&lt;ul>
&lt;li>도메인 개념을 모두 포함한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>외부 영역
&lt;ul>
&lt;li>외부 세계(UI, DB, 서드파티 통합)와의 상호작용을 포함한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>외부가 내부에 의존하며, 절대 그 반대로는 안된다.&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img4.png"
width="632"
height="669"
srcset="https://codemario318.github.io/post/clean-architecture/34/img4_hu067ed2819602a97a65ad3f6557f29a26_73442_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img4_hu067ed2819602a97a65ad3f6557f29a26_73442_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="94"
data-flex-basis="226px"
>&lt;/p>
&lt;p>위 구조에서 &lt;code>com.mycompany.myapp.domain&lt;/code> 패키지가 내부이며, 나머지 패키지는 모두 외부이다.&lt;/p>
&lt;p>&lt;code>OrdersRepository&lt;/code>가 &lt;code>Orders&lt;/code>라는 간단한 이름으로 바뀌었는데, 이는 도메인 주도 설계라는 세계관에서 비롯된 명명법으로, &lt;strong>내부&lt;/strong>에 존재하는 모든 것의 이름은 반드시 &lt;strong>유비쿼터스 도메인 언어&lt;/strong>관점에서 기술하라고 조언한다.&lt;/p>
&lt;ul>
&lt;li>도메인에 대하 논의할 때 &lt;strong>주문&lt;/strong>에 대해 말하는 것이지 &lt;strong>주문 리포지토리&lt;/strong>에 대해 말하는 것이 아니기 때문&lt;/li>
&lt;/ul>
&lt;h2 id="컴포넌트-기반-패키지">컴포넌트 기반 패키지&lt;/h2>
&lt;p>SOLID, REP, CCP, CRP 같은 이 책에 대다수의 조언은 당연히 중요하지만, 코드를 조직화하는 방법에 대해서는 &lt;strong>컴포넌트 기반 패키지&lt;/strong>같은 접근 방법을 적용해 볼 수 있다.&lt;/p>
&lt;p>&lt;strong>계층형 아키텍처의 단점&lt;/strong>&lt;/p>
&lt;p>계층형 아키텍처의 목적은 기능이 같은 코드끼리 서로 분리하는 것이다.&lt;/p>
&lt;p>구현 관점에서 보면 각 계층은 일반적으로 자바 패키지에 해당하며 서로 다른 패키지에 속한다. 따라서 코드의 접근성 관점에서 살펴보면 아래와 같은 문제가 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>OrdersController&lt;/code>가 &lt;code>OrdersService&lt;/code> 인터페이스에 의존하려면 &lt;code>OrdersService&lt;/code> 인터페이스는 반드시 &lt;code>public&lt;/code>으로 선언되어야 한다.&lt;/li>
&lt;li>&lt;code>OrdersRepository&lt;/code> 인터페이스도 &lt;code>public&lt;/code>이어야만 &lt;code>repository&lt;/code> 패키지 외부에 있는 &lt;code>OrdersServiceImpl&lt;/code> 클래스에 접근할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>엄격한 계층형 아키텍처에서 의존성 화살표는 항상 아래를 향해야 하므로, 깔끔한 비순환 의존성 그래프를 만들 수 있을 것이라 생각할 수 있지만, 실제로는 코드 베이스의 요소들이 서로를 의존할 때는 몇 가지 규칙을 반드시 지켜야한다.&lt;/p>
&lt;p>여기서 큰 문제는, 속임수를 써서 의존성을 의도치 않은 방식으로 추가하더라도 보기에는 여전히 좋은 비순환 의존성 그래프가 생성된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img_1.png"
width="629"
height="671"
srcset="https://codemario318.github.io/post/clean-architecture/34/img_1_hue2c4f507d4fc8ef9fe870f9d5a52a08a_68784_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img_1_hue2c4f507d4fc8ef9fe870f9d5a52a08a_68784_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="93"
data-flex-basis="224px"
>&lt;/p>
&lt;p>위 상황처럼 &lt;code>OrdersController&lt;/code>가 &lt;code>OrdersService&lt;/code>를 우회하여 직접 &lt;code>OrdersRepository&lt;/code>에 의존성을 가지게 하더라도 비순환 의존성 그래프가 만들어진다.&lt;/p>
&lt;p>이러한 조직화는 인접한 계층들을 건너 뛰는 일이 허용되기 때문에 &lt;strong>완화된 계층형 아키텍처&lt;/strong>라고 부르며, 이러한 방식은 CQRS(Command Query Responsibility Segregation) 패턴 같은 경우를 제외한다면 바람직하지 못하다.&lt;/p>
&lt;p>따라서 계층형 아키텍처는 이러한 우회를 강제할 수 있는 방법이 없기 때문에 아키텍처가 지켜지기 힘들어진다.&lt;/p>
&lt;p>&lt;strong>컴포넌트 기반 패키지&lt;/strong>&lt;/p>
&lt;p>반면 컴포넌트 기반 패키지는 컴파일러를 사용해서 아키텍처를 강제할 수 있다.&lt;/p>
&lt;p>컴포넌트 기반 패키지는 큰 단위(coarse-grained)의 단일 컴포넌트와 관련된 모든 책임을 하나의 자바 패키지로 묶는데 주안점을 둔다.&lt;/p>
&lt;p>이 접근법은 마이크로서비스 아키텍처가 가진 시각과 동일하게 서비스 중심적인 시각으로 소프트웨어 시스템을 바라볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>포트와 어댑터에서 웹을 그저 또 다른 전달 메커니즘으로 취급하는 것과 마찬가지로, 사용자 인터페이스를 큰 단위의 컴포넌트로부터 분리해서 유지한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img_2.png"
width="628"
height="668"
srcset="https://codemario318.github.io/post/clean-architecture/34/img_2_huade6c3c558bab5a248a2fc0978ef31a2_60168_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img_2_huade6c3c558bab5a248a2fc0978ef31a2_60168_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="94"
data-flex-basis="225px"
>&lt;/p>
&lt;p>컴포넌트 기반 패키지는 본질적으로 업무 로직과 영속성 관련 코드를 하나로 묶는데 이러한 단위를 컴포넌트라 부른다.&lt;/p>
&lt;blockquote>
&lt;p>지금까지 언급되었던 배포할 수 있는 가장 작은 단위라는 의미가 아닌 &lt;strong>깔끔한 인터페이스로 감싸진 연관된 기능들의 묶음&lt;/strong>을 의미한다.&lt;br>
스프트웨어 시스템의 전적 구조를 컨테이너, 컴포넌트, 클래스(코드) 측면에서 계층적으로 생각하는 방법(C4 소프트웨어 아키텍처 모델)&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>관련된 무언가를 코딩해야 할 때 &lt;code>**Component&lt;/code>만 둘러보면 된다.&lt;/li>
&lt;li>컴포넌트 내부에서 관심사 분리는 여전히 유효하다.&lt;/li>
&lt;li>따라서 업무 로직은 데이터 영속성과 분리된다.
&lt;ul>
&lt;li>컴포넌트 구현과 관련된 세부사항으로, 사용자는 알 필요가 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>모노리틱 애플리케이션에서 컴포넌트를 잘 정의하면 마이크로서비스 아키텍처로 가기 위한 발판으로 삼을 수 있다.&lt;/p>
&lt;h2 id="구현-세부사항엔-항상-문제가-있다">구현 세부사항엔 항상 문제가 있다.&lt;/h2>
&lt;p>언급한 네 가지 접근법이 코드를 조직하하는 것으로 보이지만 세부사항을 잘못 구현하면 이러한 견해도 아주 빠르게 흐트러지기 시작한다.&lt;/p>
&lt;ul>
&lt;li>모든 타입에서 &lt;strong>public&lt;/strong> 지시자를 사용한다는 것 제공하는 캡슐화 이점을 활용하지 않겠다는 뜻이며, 이로인해 지향아는 아키텍처 스타일을 위반하게 될 것이다.&lt;/li>
&lt;/ul>
&lt;h3 id="조직화-vs-캡슐화">조직화 VS 캡슐화&lt;/h3>
&lt;p>자바 애플리케이션에서 모든 타입을 &lt;code>public&lt;/code>으로 지정한다면 패키지는 단순히 조직화를 위한 매커니즘(폴더와 같은 역할만)으로 전락하여 캠슐화를 위한 메커니즘이 될 수 없다.&lt;/p>
&lt;ul>
&lt;li>코드 베이스를 어디서도 사용할 수 있다면 패키지를 사용하는 데 따른 이점이 거의 없다.&lt;/li>
&lt;li>패키지를 무시해 버리면 캡슐화나 은닉에 아무런 도움이 없으므로 최종적으로 어떤 아키텍처 스타일로 만들려고 하는지는 아무런 의미가 없어진다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img_3.png"
width="630"
height="446"
srcset="https://codemario318.github.io/post/clean-architecture/34/img_3_hubd3840a39404a726edb0ac1a8a8a458d_77645_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img_3_hubd3840a39404a726edb0ac1a8a8a458d_77645_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="339px"
>&lt;/p>
&lt;p>모든 타입을 &lt;code>public&lt;/code>으로 선언한다면 실제로 갖게 되는 것은 수평적 계층형 아키텍처를 표현하는 방법에 불과해진다.&lt;/p>
&lt;hr>
&lt;p>접근 지시자를 적절하게 사용하면, 타입을 패키지로 배치하는 방식에 다라서 각 타입에 접근할 수 있는 정도가 실제로 크게 달라질 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img_4.png"
width="631"
height="487"
srcset="https://codemario318.github.io/post/clean-architecture/34/img_4_hub59749830694f830b27427b6082c0095_105897_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img_4_hub59749830694f830b27427b6082c0095_105897_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="129"
data-flex-basis="310px"
>&lt;/p>
&lt;ol>
&lt;li>계층 기반 패키지 접근법
&lt;ul>
&lt;li>&lt;code>OrdersService&lt;/code>, &lt;code>OrdersRepository&lt;/code> 인터페이스는 외부 패키지의 클래스로부터 자신이 속한 패키지 내부로 들어오는 의존성으로 &lt;code>public&lt;/code> 으로 선언되어야하지만, 구체 클래스는 누구도 알 필요가 없는 구현 세부사항이므로 &lt;code>protected&lt;/code>로 선언할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>기능 기반 패키지 접근법
&lt;ul>
&lt;li>&lt;code>OrdersController&lt;/code>가 패키지로 들어올 수 있는 유일한 통로를 제공하므로 나머지 패키지는 &lt;code>protected&lt;/code>로 지정할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>포트와 어댑터 접근법
&lt;ul>
&lt;li>&lt;code>OrdersService&lt;/code>와 &lt;code>Orders&lt;/code> 인터페이스는 외부로부터 들어오는 의존성을 가지므로 &lt;code>public&lt;/code>으로 지정해야한다.&lt;/li>
&lt;li>구현 클래스 패키지는 &lt;code>protected&lt;/code>로 지정하며, 런타임에 의존성을 주입할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>컴포넌트 기반 패키지
&lt;ul>
&lt;li>컨트롤러에서 &lt;code>OrdersComponent&lt;/code> 인터페이스로 향하는 의존성을 가지며, 그 외의 모든 것은 패키지 &lt;code>protected&lt;/code>로 지정할 수 있다.&lt;/li>
&lt;li>패키지 외부의 코드에서는 &lt;code>OrdersRepository&lt;/code> 인터페이스나 구현체를 직접 사용할 수 있는 방법이 전혀 없으므로 컴파일러를 통해 아키텍처를 강제할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>아키텍처 원칙을 강제할 때 컴파일러의 도움을 받아 그렇게 할 수 밖에 없도록 만들어야 한다.&lt;/p>
&lt;p>모든 코드가 하나의 소스 코드 트리로 존재하는 모노리틱 애플리케이션이라면 큰 도움이 될 것이다.&lt;/p>
&lt;h2 id="다른-결합-분리-모드">다른 결합 분리 모드&lt;/h2>
&lt;p>프로그래밍 언어가 제공하는 방법 외에도 소스 코드 의존성을 분리하는 방법은 존재할 수 있다.&lt;/p>
&lt;ul>
&lt;li>모듈 시스템(ex. 자바 OSGI)&lt;/li>
&lt;li>소스코드 수준에서 의존성을 분리하는 방법
&lt;ul>
&lt;li>&lt;strong>서로 다른 소스 코드 트리로 분리하는 방법&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="결론-빠져있는-조언">결론: 빠져있는 조언&lt;/h2>
&lt;p>최적의 설계를 꾀했더라도, 구현 전략에 얽힌 복잡함을 고려하지 않으면 설계가 순식간에 망가질 수도 있다.&lt;/p>
&lt;ul>
&lt;li>설계를 어떻게 해야만 원하는 코드 구조로 매핑할 수 있을지&lt;/li>
&lt;li>코드를 어떻게 조직화 할지&lt;/li>
&lt;li>런타임과 컴파일타입에 어떤 결합 분리 모드를 적용할지&lt;/li>
&lt;/ul>
&lt;p>위와 같은 내용을 고민해야하며, 선택사항을 열어두되 실용주의적으로 행해야한다.&lt;/p>
&lt;ul>
&lt;li>팀의 규모, 기술 수준, 해결책의 복잡성을 일정과 예산이라는 제약과 동시에 고려해야한다.&lt;/li>
&lt;li>선택된 아키텍처 스타일을 강제하는 데 컴파일러의 도움을 받을 수 있을지 고민해야한다.&lt;/li>
&lt;li>데이터 모델과 같은 다른 영역에 결합되지 않도록 주의해야한다.&lt;/li>
&lt;/ul>
&lt;p>구현 세부사항에는 항상 문제가 있는 법이다.&lt;/p></description></item><item><title>33. 사례연구: 비디오 판매</title><link>https://codemario318.github.io/post/clean-architecture/33/</link><pubDate>Fri, 19 Apr 2024 15:27:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/33/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/33/cover.png" alt="Featured image of post 33. 사례연구: 비디오 판매" />&lt;p>짧고 단순한 사례를 통해 뛰어난 아키텍트가 일을 처리하는 과정과 결정을 내리는 모습을 살펴보자.&lt;/p>
&lt;h2 id="제품-비디오-판매-웹-서비스">제품: 비디오 판매 웹 서비스&lt;/h2>
&lt;ul>
&lt;li>판매하길 원하는 비디오들이 있고, 개인과 기업에게 웹을 통해 판매한다.&lt;/li>
&lt;li>개인은 단품 가격을 지불해 스트리밍으로 본다.&lt;/li>
&lt;li>개인은 더 높은 가격을 지불하여 비디오를 다운로드해서 영구 소장할 수 있다.&lt;/li>
&lt;li>기업용 라이선스는 스트리밍 전용이다.&lt;/li>
&lt;li>기업용 라이선스로 대량 구매시 할인을 받을 수 있다.&lt;/li>
&lt;li>개인은 시청자인 동시에 구매자&lt;/li>
&lt;li>기업은 다른 사람들이 시청할 비디오를 구매하는 사람이 따로 있다.&lt;/li>
&lt;li>비디오 제작자는 비디오 파일과 설명서, 부속 파일(시험, 문제, 해법, 소스 코드 등)을 제공한다.&lt;/li>
&lt;li>관리자는 신규 비디오 시리즈물을 추가한다.&lt;/li>
&lt;li>관리자는 기존 시리즈물에 비디오를 추가 도는 삭제한다.&lt;/li>
&lt;li>관리자는 다양한 라이선스에 맞춰 가격을 책정한다.&lt;/li>
&lt;/ul>
&lt;h2 id="유스케이스-분석">유스케이스 분석&lt;/h2>
&lt;p>주요 액터는 구매자, 시청자, 제작자, 관리자 네 가지이다.&lt;/p>
&lt;p>단일 책임 원칙에 따라 네 액터가 시스템이 변경되어야 할 네 가지 주요 근원이 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/33/img.png"
width="709"
height="700"
srcset="https://codemario318.github.io/post/clean-architecture/33/img_huc3fc667673246b20a35a0a0b5773b4d6_306180_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/33/img_huc3fc667673246b20a35a0a0b5773b4d6_306180_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="101"
data-flex-basis="243px"
>&lt;/p>
&lt;p>신규 기능 추가나, 기존 기능 변경의 이유는 액터 중 하나에게 해당 기능을 제공하기 위함이므로, 시스템을 분할하여 특정 액터를 위한 변경이 나머지 액터에게는 전혀 영향을 미치지 않게 만들어야한다.&lt;/p>
&lt;p>중앙 점선으로 된 유스케이스는 추상 유스케이스이다.&lt;/p>
&lt;p>추상 유스케이스는 범용적인 정책을 담고 있으며, 다른 유스케이스에서 이를 더 구체화한다.&lt;/p>
&lt;p>시청자 입장에서 카탈로그 조회하기와 구매자 입장에서 카탈로그 조회하기 유스케이스는 모두 카탈로그 조회하기라는 추상 유스케이스를 상속받는다.&lt;/p>
&lt;ul>
&lt;li>이 추상 유스케이스를 다이어그램에서 없애더라도 전체 제품의 기능을 조금도 손상시키지 않지만, 이들 두 유스케이스는 너무 비슷하기 때문에, 유사성을 식별하여 분석 초기에 통합하는 방법을 찾는 방법이 더 현명하다고 판단하였다.&lt;/li>
&lt;/ul>
&lt;h2 id="컴포넌트-아키텍처">컴포넌트 아키텍처&lt;/h2>
&lt;p>액터와 유스케이스를 식별했으므로, 예비 단계의 컴포넌트 아키텍처를 만들어 볼 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/33/img_1.png"
width="642"
height="478"
srcset="https://codemario318.github.io/post/clean-architecture/33/img_1_hue0ddbb544a7f722e559ab09d7f8f1c4f_121162_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/33/img_1_hue0ddbb544a7f722e559ab09d7f8f1c4f_121162_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="134"
data-flex-basis="322px"
>&lt;/p>
&lt;p>이중으로 된 선은 아키텍처 경계를 나타낸다.&lt;/p>
&lt;ul>
&lt;li>뷰 프레젠터, 인터랙터, 컨트롤러로 분리된 전형적이 분할 방법을 활용했다.&lt;/li>
&lt;li>대응하는 액터에 다라 카테고리를 분리했다.&lt;/li>
&lt;/ul>
&lt;p>특수한 컴포넌트인 &lt;code>Catalog View&lt;/code>와 &lt;code>Catalog Presenter&lt;/code>는 &lt;strong>카탈로그 조회하기&lt;/strong>라는 추상 유스케이스를 처리하는 방식으로 뷰와 프레젠터는 해당 컴포넌트 내부에 추상 클래스로 코드화될 것이며, 상속받는 컴포넌트에서는 이를 추상클래스로부터 상속받은 뷰와 프레젠터 클래스들을 포함한다.&lt;/p>
&lt;p>시스템을 이러한 컴포넌트들로 모두 분할한다면, 모든 컴포넌트를 분할해서 여러개의 &lt;code>.jar&lt;/code> 등 파일로 전달할 수도 있고 모두 한 파일로도 합칠 수 있다.&lt;/p>
&lt;p>이는 선택지를 열어두는 것이며, 선택지를 열어두면, 시스템이 변경되는 양상에 맞춰 시스템 배포 방식을 조정할 수 있다.&lt;/p>
&lt;h2 id="의존성-관리">의존성 관리&lt;/h2>
&lt;p>위 그림에서 제어흐름은 오른족에서 왼쪽으로 이동한다.&lt;/p>
&lt;ol>
&lt;li>입력이 컨트롤러에서 발생&lt;/li>
&lt;li>인터렉터에 의해 처리되어 결과가 만들어짐&lt;/li>
&lt;li>프레젠터가 결과의 포멧을 변경&lt;/li>
&lt;li>뷰가 화면에 표시&lt;/li>
&lt;/ol>
&lt;p>대부분의 화살표가 왼쪽에서 오른쪽으로 향하는데, 이는 아키텍처가 의존성 규칙을 준수하기 때문이다.&lt;/p>
&lt;p>모든 의존성은 경계선을 한 방향으로만 즉, 항상 더 높은 수준의 정책을 포함하는 컴포넌트로 향해야한다.&lt;/p>
&lt;p>사용 관계(열린 화살표)는 제어흐름과 같은 방향을 가리키며, 상속 관계(닫힌 화살표)는 제어흐름과는 반대 방향을 가르키는데, 이는 개방 폐쇄 원칙을 적용했음을 보여준다.&lt;/p>
&lt;p>이를 통해 의존성이 올바른 방향으로 흐르며, 저수준의 세부사항에서 발생한 변경이 상위로 파급되어 상위 수준의 정책에 영향을 미치지는 않음을 보장할 수 있다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>그림으로 확인할 수 있는 단일 책임 원칙에 기반한 액터의 분리와 의존성 규칙 모두 서로 다른 이유로, 서로 다른 속도로 변경되는 컴포넌트를 분리하는 데 그 목적이 있다.&lt;/p>
&lt;ul>
&lt;li>서로 다른 이유라는 것은 액터와 관련이 있다.&lt;/li>
&lt;li>서로 다른 속도라는 것은 정책 수준과 관련이 있다.&lt;/li>
&lt;/ul>
&lt;p>이러한 방식으로 코드를 한번 구조화하고 나면 시스템을 실제로 배포하는 방식은 다양하게 선택할 수 있게된다.&lt;/p></description></item><item><title>32. 프레임워크는 세부사항이다</title><link>https://codemario318.github.io/post/clean-architecture/32/</link><pubDate>Thu, 18 Apr 2024 19:42:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/32/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/32/cover.png" alt="Featured image of post 32. 프레임워크는 세부사항이다" />&lt;p>아무리 해도 프레임워크는 아키텍처가 될 수 없다.&lt;/p>
&lt;h2 id="프레임워크-제작자">프레임워크 제작자&lt;/h2>
&lt;p>프레임워크 제작자는 자신이 해결해야 할 고유한 문제를 위해 프레임워크를 제작한 것 이므로, 내가 풀려는 문제와 완벽하게 일치할수는 없다.&lt;/p>
&lt;h2 id="혼인-관계의-비대칭성">혼인 관계의 비대칭성&lt;/h2>
&lt;p>프레임워크 제작자와 사용자의 관계는 놀라울 정도로 비대칭 적이며 프레임워크 제작자는 당신에게 프레임워크와 혼인하기를 요구하는 것 처럼 보인다.&lt;/p>
&lt;p>프레임워크 제작자는 당신의 애플리케이션이 가능하면 프레임워크에 공고하게 결합될 것을 강하게 역설한다.&lt;/p>
&lt;p>이러한 결합은 제작자에게는 위험 요소가 되지 않으며, 프레임워크에대해 절대적인 제어권을 쥐고 있는 입장에서 오히려 프레임워크와 결합되기를 바란다.&lt;/p>
&lt;p>한술 더 떠 제작자는 사용자도 프레임워크에 결합되어 관계를 깨지 못하는 것을 기대하고 있다.&lt;/p>
&lt;p>제작자는 프레임워크에대해 장시간에 걸친 헌신을 요청하지만, 그에 상응하는 헌신을 받을수 는 없을 것이다.&lt;/p>
&lt;p>모든 위험과 부담은 당신이 감수할 뿐, 제작자가 감수하는 건 아무것도 없다.&lt;/p>
&lt;h2 id="위험요인">위험요인&lt;/h2>
&lt;p>&lt;strong>프레임워크의 아키텍처는 깔끔하지 않은 경우가 많다.&lt;/strong> &lt;br>
프레임워크는 의존성 규칙을 위반하는 경향이 있다.&lt;/p>
&lt;ul>
&lt;li>업무 객체를 만들 때 프레임워크 코드를 상속할 것을 요구한다.&lt;/li>
&lt;li>고유한 엔티티에 코드가 상속되면 애플리케이션의 가장 안쪽 원과 프레임워크의 결합이 발생한다.&lt;/li>
&lt;/ul>
&lt;p>프레임워크가 한번 원 안으로 들어가버리면 다시는 원 밖으로 나오지 않을 것이다.&lt;/p>
&lt;p>&lt;strong>결국 싸우게된다.&lt;/strong>&lt;/p>
&lt;p>프레임워크가 애플리케이션의 초기 기능을 만드는데 도움이 될 것이지만, 제품이 성숙해지면서 프레임워크가 제공하는 기능과 틀을 벗어나게 될 것이다.&lt;/p>
&lt;p>&lt;strong>앞으로의 변화&lt;/strong>&lt;/p>
&lt;p>프레임워크는 애플리케이션에게 도움되지 않는 방향으로 진화할 수도 있다.&lt;/p>
&lt;p>&lt;strong>더 나은 프레임워크&lt;/strong>&lt;/p>
&lt;p>새롭고 더 나은 프레임워크가 등장해서 갈아타고 싶을 수도 있다.&lt;/p>
&lt;h2 id="해결책">해결책&lt;/h2>
&lt;blockquote>
&lt;p>프레임워크와 결혼하지 말라!&lt;/p>
&lt;/blockquote>
&lt;p>프레임워크를 사용할 수는 있지만 결합해서는 안된다.&lt;/p>
&lt;p>프레임워크는 아키텍처의 바깥쪽 원에 속하는 세부사항으로 취급해야한다.&lt;/p>
&lt;p>업무 객체를 만들 때 프레임워크가 자신의 기반 클래스로부터 파생하기를 요구한다면, 프락시를 만들고, 업무 규칙에 플러그인할 수 있는 컴포넌트에 이 프락시를 위치시켜 프레임워크가 핵심 코드 안으로 들어오지 못하게 해야한다.&lt;/p>
&lt;p>대신 핵심 코드에 플러그인할 수 있는 컴포넌트에 프레임워크를 통합하고, 의존성 규칙을 준수한다.&lt;/p>
&lt;h2 id="이제-선언합니다">이제 선언합니다.&lt;/h2>
&lt;p>애플리케이션이 프레임워크와 결혼하고자 한다면 애플리케이션의 남은 생애 동안 그 프레임워크와 항상 함께 해야 한다는 사실을 반드시 명심해야한다.&lt;/p>
&lt;p>결코 가볍게 시작할 수 있는 관계가 아니다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>프레임워크와의 첫 만남부터 바로 결혼하려 들지 말라.&lt;/p>
&lt;p>가급적이면 프레임워크를 가능한 한 오랫동안 아키텍처 경계 너머에 두자.&lt;/p></description></item><item><title>31. 웹은 세부사항이다</title><link>https://codemario318.github.io/post/clean-architecture/31/</link><pubDate>Thu, 18 Apr 2024 19:07:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/31/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/31/cover.png" alt="Featured image of post 31. 웹은 세부사항이다" />&lt;h2 id="끝없이-반복하는-추">끝없이 반복하는 추&lt;/h2>
&lt;p>1960년대 이래로 모든 연산 능력을 중앙 서버에 두는 방식과 모든 연산 능력을 단말에 두는 방식 사이의 일련의 반복되는 진동을 겪어왔으며 웹은 진동 끝 한 점에 있을 뿐이다.&lt;/p>
&lt;p>IT 역사 전체로 시야를 넓히면 웹은 아무것도 바꾸지 않았으며, 이러한 진동은 앞으로도 지속될것이다.&lt;/p>
&lt;p>따라서 아키텍트로서 이 진동은 핵심 업무 규칙의 중심에서 밀어내야하는 단기적인 문제일 뿐이다.&lt;/p>
&lt;p>이러한 진동은 GUI의 변경을 동반하며, 이러한 변경으로부터 애플리케이션을 보호하기 위해 GUI로부터 업무 규칙을 분리해야한다.&lt;/p>
&lt;h2 id="요약">요약&lt;/h2>
&lt;p>GUI는 세부사항이다. 웹은 입 출력 장치의 다른 모습이므로 GUI이며, 이러한 이유로 웹은 세부사항이다.&lt;/p>
&lt;p>따라서 아키텍트는 웹을 핵심 업무 로직에서 분리된 경계 바깥에 두어야한다.&lt;/p>
&lt;p>애플리케이션과 GUI의 상호작용은 빈번하고 방식도 사용중인 GUI 종류에 따라 차이가 크기 때문에 추상화하려는 시도는 성공할 가능성이 낮아 보인다.&lt;/p>
&lt;p>하지만 UI와 애플리케이션 사이에는 추상화가 가능한 또 다른 경계가 존재한다.&lt;/p>
&lt;ul>
&lt;li>업무 로직은 다수의 유스케이스로 구성되며, 각 유스케이스는 사용자를 대신해서 일부 함수를 수행하는 것을 볼 수 있다.&lt;/li>
&lt;li>각 유스케이스는 입력 데이터 수행할 처리 과정, 출력 데이터를 기반으로 기술할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>완전한 입력 데이터&lt;/strong>와 그에 따른 &lt;strong>출력 데이터&lt;/strong>는 데이터 구조로 만들어서 유스케이스를 실행하는 처리 과정의 입력 값과 출력 값으로 사용할 수 있기 때문에, &lt;strong>각 유스케이스가 장치 독립적인 방식으로 UI라는 입출력 장치를 동작시킨다&lt;/strong>고 간주할 수 있다.&lt;/p>
&lt;p>이러한 입력 데이터와 그에 따른 출력 데이터로 만들어지는 데이터 구조는 UI와 애플리케이션 사이의 경계를 넘나드는 수단이므로 추상화가 가능한 경계이다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>이러한 종류의 추상화는 만들기 쉽지 않고, 제대로 만들려면 수차례의 반복 과정을 거쳐야 할 것이다.&lt;/p>
&lt;p>하지만 이러한 추상화는 가능하며, 변경이 될 요소는 매우 많기 때문에 추상화는 꼭 필요하다.&lt;/p></description></item><item><title>30. 데이터베이스는 세부사항이다</title><link>https://codemario318.github.io/post/clean-architecture/30/</link><pubDate>Thu, 18 Apr 2024 16:19:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/30/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/30/cover.png" alt="Featured image of post 30. 데이터베이스는 세부사항이다" />&lt;p>아키텍처 관점에서 볼 때 데이터베이스는 엔티티가 아니다.&lt;/p>
&lt;p>데이터 모델과는 달리 아키텍처 관점에서는 데이터베이스는 세부사항이라서 아키텍처의 구성요소 수준으로 끌어올릴 수 없다.&lt;/p>
&lt;p>데이터베이스는 소프트웨어일 뿐이며, 데이터에 접근할 방법을 제공하는 유틸리티이다.&lt;/p>
&lt;p>유틸리티는 저수준 세부사항(메커니즘)일 뿐 아키텍처와는 관계 없으므로, 데이터베이스를 이용한다는 사실이 아키텍처에 영향을 주지 않아야한다.&lt;/p>
&lt;h2 id="관계형-데이터베이스">관계형 데이터베이스&lt;/h2>
&lt;p>관계형 테이블은 특정한 형식의 데이터에 접근하는 경우에 편리함을 제공하지만, 데이터를 테이블에 행 단위로 배치한다는 자체는 아키텍처적으로 볼 때 전혀 중요하지 않다.&lt;/p>
&lt;p>따라서 (관계형 데이터베이스에 저장된)데이터가 테이블 구조를 가진다는 사실은 오직 아키텍처의 외부 원에 위치한 최하위 수준의 유틸리티 함수만 알아야한다.&lt;/p>
&lt;p>소프트웨어에서 테이블과 행을 허용한다면, 유스케이스, 업무 규칙, UI조차도 관계형 데이터 구조에 결합되어버린다.&lt;/p>
&lt;h2 id="데이터베이스-시스템은-왜-이렇게-널리-사용되는가">데이터베이스 시스템은 왜 이렇게 널리 사용되는가?&lt;/h2>
&lt;p>데이터 저장 공간의 한계로 디스크를 사용할 수 밖에 없었기 때문이다.&lt;/p>
&lt;p>디스크의 단점은 느리다는 점 인데, 이로인해 발생하는 성능 저하 완화를 위한 색인, 캐시, 쿼리 계획 최적화가 필요해졌다.&lt;/p>
&lt;p>색인, 캐시, 쿼리 계획을 위해 작업중인 대상이 어떤 데이터인지 알 수 있어야 했으므로 데이터를 표현하는 일종의 표준적인 방식도 필요했고, 시간이 흘러 파일 시스템과 관계형 데이터베이스 관리 시스템(RDBMS) 2가지 유형으로 분리되었다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>파일 시스템&lt;/strong>&lt;/p>
&lt;p>문서(document) 기반 시스템으로, 문서 전체를 자연스럽고 편리하게 저장하는 방법을 제공한다.&lt;/p>
&lt;p>문서를 이름을 기준으로 저장하거나 조회할 때는 잘 동작하지만, 내용을 기준으로 검색할 때는 크게 도움되지 않는다.&lt;/p>
&lt;p>&lt;strong>데이터베이스 시스템&lt;/strong>&lt;/p>
&lt;p>내용 기반 시스템으로 내용을 기반으로 레코드를 자연스럽고 편리하게 찾는 방법을 제공한다.&lt;/p>
&lt;p>레코드가 서로 공유하는 일부 내용에 기반해서 다수의 레코드를 연관 짓는 데 매우 탁월하지만, 정형화되지 않은 문서를 저장하고 검색하는 데는 대체로 부적합하다.&lt;/p>
&lt;hr>
&lt;p>각 시스템은 데이터를 디스크에 체계화하고 특화된 방식으로 데이터를 저장하고 검색할 수 있도록 하며, 성능을 높히기 위해 데이터를 색인하고 RAM에 배치하는 고유한 전략을 활용한다.&lt;/p>
&lt;h2 id="디스크가-없다면-어떻게-될까">디스크가 없다면 어떻게 될까?&lt;/h2>
&lt;p>디스크는 RAM으로 대체되고있다.&lt;/p>
&lt;p>모든 데이터가 RAM에 저장된다면 데이터들을 연결 리스트, 트리, 해시 테이블, 스택, 큐 와 같은 데이터 구조로 체계화 될 것이며, 데이터에 접근할 때는 포인터나 참조를 활용할 것이다.&lt;/p>
&lt;p>데이터가 데이터베이스나 파일 시스템에 있더라도, RAM으로 읽은 후에는 다루기 편리한 형태로 그 구조로 변경하는데, 이는 프로그래머가 하는 일로 그대로 하면 된다.&lt;/p>
&lt;h2 id="세부사항">세부사항&lt;/h2>
&lt;p>데이터가 파일 시스템이나 데이터베이스 시스템을 통해 저장된다고 하더라도 결과적으로 실제 데이터를 처리할 때는 사용하기 편한 방식(자료구조)으로 처리하여 RAM에 올려 사용하게 된다.&lt;/p>
&lt;p>이처럼 데이터베이스는 디스크와 RAM 사이에서 데이터를 옮길 때 사용할 뿐인 메커니즘이고, 데이터를 장기적으로 저장하는 공간일 뿐이다.&lt;/p>
&lt;p>따라서 아케텍처 관점에서 본다면 데이터베이스는 세부사항이므로, 데이터가 어떤 형태로 어디에 저장되어있는지 인식해서는 안된다.&lt;/p>
&lt;h2 id="하지만-성능은">하지만 성능은?&lt;/h2>
&lt;p>데이터 저장소 측면에서 성능은 완전히 캡슐화하여 업무 규칙과는 분리할 수 있는 관심사이다.&lt;/p>
&lt;p>데이터 저장소에서 데이터를 빠르게 넣고 뺄 수 있어야 하는 것은 맞지만, 이는 저수준 관심사로 저수준의 데이터 매커니즘 단에서 다뤄야한다.&lt;/p>
&lt;ul>
&lt;li>인덱스 등&lt;/li>
&lt;/ul>
&lt;p>따라서 데이터 저장소의 성능은 시스템의 전반적인 아케텍처와는 관계가 없다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>체계화된 데이터 구조와 데이터 모델은 아키텍처적으로 중요한 반면, 데이터를 디스크에서 이리 저리 옮길 뿐인 기술과 시스템은 아키텍처적으로 중요하지 않다.&lt;/p>
&lt;p>데이터를 테이블 구조로 만들고 SQL로만 접근하도록 하는 관계형 데이터베이스 시스템은 후자와 관련이 깊으므로 아키텍처적으로 종요하지 않다.&lt;/p>
&lt;p>데이터는 중요하나, 데이터베이스는 세부사항이다.&lt;/p></description></item><item><title>28. 테스트 경계</title><link>https://codemario318.github.io/post/clean-architecture/28/</link><pubDate>Mon, 15 Apr 2024 18:17:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/28/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/28/cover.png" alt="Featured image of post 28. 테스트 경계" />&lt;p>테스트는 시스템의 일부이며, 아키텍처에도 관여한다.&lt;/p>
&lt;h2 id="시스템-컴포넌트인-테스트">시스템 컴포넌트인 테스트&lt;/h2>
&lt;p>아키텍처 관점에서는 어떠한 종류에 테스트이든 동일하다.&lt;/p>
&lt;p>테스트는 태생적으로 의존성 규칙을 따른다.&lt;/p>
&lt;ul>
&lt;li>테스트는 세부적이며 구체적이다.&lt;/li>
&lt;li>따라서 의존성은 항상 테스트 대상이 되는 코드를 향한다.(아키텍처의 가장 바깥쪽 원으로 볼 수 있다.)&lt;/li>
&lt;li>시스템 내부의 어떤 것도 테스트에는 의존하지 않는다.&lt;/li>
&lt;li>독립적으로 배포 가능하다.&lt;/li>
&lt;li>시스템 컴포넌트 중에서 가장 고립되어 있다.&lt;/li>
&lt;li>시스템 운영에 꼭 필요치는 않다.&lt;/li>
&lt;li>테스트의 역할은 운영이 아니라 개발을 지원하는 것이므로, 어떤 사용자도 테스트에 의존하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>그렇다고 하더라도 테스트가 시스템 컴포넌트가 아니라는 뜻은 아니며, 다른 모든 시스템 컴포넌트가 반드시 지켜야하는 모델을 표현해준다.&lt;/p>
&lt;h2 id="테스트를-고려한-설계">테스트를 고려한 설계&lt;/h2>
&lt;p>테스트의 극단적인 고립성이 대체로 배포하지 않는다는 사실과 어우러져, 테스트가 시스템의 설계 범위 밖에 있다고 착각한다.&lt;/p>
&lt;p>테스트가 시스템 설계와 잘 통합되지 않으면, 테스트는 깨지기 쉬워지고, 시스템은 뻣뻣해져서 변경하기가 어려워진다.&lt;/p>
&lt;p>&lt;strong>깨지기 쉬운 테스트 문제(Fragile Tests Problem)&lt;/strong>&lt;/p>
&lt;p>시스템에 강하게 결합된 테스트라면 시스템이 변경될 때 함께 변경되어야하므로, 시스템 컴포넌트에 생긴 아주 사소한 변경도, 이와 결합된 수많은 테스트를 망가뜨릴 수 있다.&lt;/p>
&lt;p>시스템의 공통 컴포넌트가 변경되면 수백, 심지어 수천 개의 테스트가 망가진다.&lt;/p>
&lt;hr>
&lt;p>깨지기 쉬운 테스트는 시스템을 뻣뻣하게 만든다는 부작용을 낳을 때가 많다.&lt;/p>
&lt;ul>
&lt;li>시스템에 가한 간단한 변경이 대량의 테스트 실패로 이어진다는 사실을 알게되면, 개발자는 변경을 하지 않으려고 할 것이다.&lt;/li>
&lt;/ul>
&lt;p>따라서 이러한 문제를 해결하기 위해 테스트를 고려한 설계가 필요하다.&lt;/p>
&lt;p>핵심은 &lt;strong>변동성이 있는 것에 의존하지 않는 것&lt;/strong>이다.&lt;/p>
&lt;p>변동성이 큰 GUI같은 것으로 시스템을 조작하는 테스트 스위트는 깨지기 쉽기 때문에 시스템과 테스트를 설계할 때 GUI를 사용하지 않고 업무 규칙을 테스트 할 수 있게 해야한다.&lt;/p>
&lt;h2 id="테스트-api">테스트 API&lt;/h2>
&lt;p>변동성이 적은 방식으로 업무 규칙을 테스트하기 위해 모든 업무 규칙을 검증하는 데 사용할 수 있도록 특화된 API를 만든다.&lt;/p>
&lt;ul>
&lt;li>보안 제약 사항을 무시할 수 있어야 한다.&lt;/li>
&lt;li>데이터베이스와 같은 값비싼 자원은 건너뛰고, 시스템을 테스트 가능한 특정 상태로 강제하는 강력한 힘을 지녀야한다.&lt;/li>
&lt;li>사용자 인터페이스가 사용하는 &lt;strong>인터렉터&lt;/strong>와 &lt;strong>인터페이스 어댑터&lt;/strong>들의 상위 집합이 될 것이다.&lt;/li>
&lt;/ul>
&lt;p>테스트 API는 테스트를 애플리케이션으로부터 분리할 목적으로 사용한다.&lt;/p>
&lt;h3 id="구조적-결합">구조적 결합&lt;/h3>
&lt;p>구조적 결합은 테스트 결합 중에서 가장 강하며, 가장 은밀하게 퍼져나가는 유형이다.&lt;/p>
&lt;p>모든 상용 클래스에 테스트 클래스가 각각 존재하고, 모든 상용 메서드에 테스트 메서드 집합이 각각 존재하는 테스트 스위트가 있다고 가정할 때 이러한 테스트 스위트는 애플리케이션 구조에 강하게 결합되어있다.&lt;/p>
&lt;ul>
&lt;li>상용 클래스나 메서드 중 하나라도 변경되면 딸려있는 다수의 테스트가 변경되어야한다.&lt;/li>
&lt;li>테스트는 깨지기 위워지고, 이로 인해 상용 코드를 뻣뻣하게 만든다.&lt;/li>
&lt;/ul>
&lt;p>테스트 API의 역할은 애플리케이션의 구조를 테스트로부터 숨기는 데 있다.&lt;/p>
&lt;ul>
&lt;li>상용 코드를 리펙터링하거나 진화시키더라도 테스트에는 전혀 영향을 주지 않는다.&lt;/li>
&lt;li>테스트를 리펙터링 하거나 진화시킬 때도 사용 코드에는 영향을 주지 않는다.&lt;/li>
&lt;/ul>
&lt;p>시간이 지날수록 테스트는 계속해서 더 구체적이고 특화된 형태로 변하고, 상용 코드는 더 추상적이고 범용적인 형태로 변하기 때문에 따로따로 진화할 수 있다는 점은 필수적이다.&lt;/p>
&lt;p>하지만 구조적 결합이 강하면 위와 같은 진화 과정을 방해한다.&lt;/p>
&lt;h3 id="보안">보안&lt;/h3>
&lt;p>테스트 API를 운영 시스템에 배포하면 위험에 처할 수 있다.&lt;/p>
&lt;p>테스트 API 자체와 테스트 API 중 위험한 부분의 구현부를 독립적으로 배포할 수 있는 컴포넌트로 분리해야한다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>테스트는 시스템의 일부이다.&lt;/p>
&lt;p>따라서 테스트에서 기대하는 안정성과 회귀의 이점을 얻을 수 있으려면 테스트는 잘 설계 돼야만한다.&lt;/p>
&lt;p>테스트를 시스템의 일부로 설계하지 않으면 테스트는 깨지기 쉽고 유지보수하기 어려워지는 경향이 있으며, 이러한 테스트는 유지보수하기 힘들기 때문에 버려지는 최후를 맡는다.&lt;/p></description></item><item><title>27. 크고 작은 모든 서비스들</title><link>https://codemario318.github.io/post/clean-architecture/27/</link><pubDate>Mon, 15 Apr 2024 17:13:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/27/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/27/cover.png" alt="Featured image of post 27. 크고 작은 모든 서비스들" />&lt;p>서비스 지향 아키텍처와 마이크로서비스 아키텍처는 최근에 큰 인기를 끌고 있는데 이유는 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>서비스를 사용하면 상호 결합이 철저하게 분리되는 것처럼 보인다.&lt;/li>
&lt;li>서비스를 사용하면 개발과 배포 독립성을 지원하는 것처럼 보인다.&lt;/li>
&lt;/ul>
&lt;h2 id="서비스-아키텍처">서비스 아키텍처?&lt;/h2>
&lt;p>서비스를 사용한다는 것이 본질적으로 아키텍처에 해당하는지에 대해 생각해보면 명백히 사실이 아니다.&lt;/p>
&lt;p>시스템의 아키텍처는 의존선 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의된다.&lt;/p>
&lt;p>이러한 관점에서 애플리케이션의 행위를 분리할 뿐인 서비스라면 값비싼 함수 호출에 불과하며, 아키텍처 관점에서 꼭 중요하다고 볼 수는 없다.&lt;/p>
&lt;p>기능을 프로세스나 플랫폼에 독립적이 되게끔 서비스들을 생성하면 의존성 규칙 준수 여부와 상관 없이 큰 도움이 될 때가 많으나, 서비스 그 자체로는 아키텍처를 정의하지 않는다.&lt;/p>
&lt;p>위에 언급한대로 시스템에서 아키텍처를 정의하는 요소는 의존성 규칙을 따르며 아키텍처 경계를 넘나드는 행위 자체이며, 결국 서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않는다고 볼 수 있다.&lt;/p>
&lt;h2 id="서비스의-이점">서비스의 이점?&lt;/h2>
&lt;p>많은 사람들이 생각하는 서비스의 이점에 대해 아키텍처 관점의 근본적인 문제를 살펴보면 이러한 부분들이 완벽한 해결책은 아님을 알 수 있다.&lt;/p>
&lt;h3 id="결합-분리의-오류">결합 분리의 오류&lt;/h3>
&lt;p>시스템을 서비스들로 분리함으로써 얻게 되리라 예상되는 큰 이점중 하나는 &lt;strong>서비스 사이의 결합이 확실히 분리된다는 점&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>각 서비스는 서로 다른 프로세스에서 실행되므로 서비스는 다른 서비스의 변수에 직접 접근이 불가능하다.&lt;/li>
&lt;li>모든 서비스의 인터페이스는 반드시 잘 정의되어 있어야 한다.&lt;/li>
&lt;/ul>
&lt;p>서비스들이 변수를 통해 직접 접근할 수는 없지만 프로세서 내의 또는 네트워크 상의 공유 자원과 이로 인한 공유하는 데이터에 의해 서비스들이 강력하게 결합된다.&lt;/p>
&lt;ul>
&lt;li>서비스 사이를 오가는 데이터 레코드에 새로운 필드를 추가하면, 이 필드를 사용하는 모든 서비스는 반드시 변경되어야한다.&lt;/li>
&lt;li>필드에 담긴 데이터를 해석하는 방식을 사전에 완벽하게 조율해야 한다.&lt;/li>
&lt;/ul>
&lt;p>이로 인해 서비스들은 레코드에 강하게 결합되고, 서비스들 사이는 서로 간접적으로 결합되어버린다.&lt;/p>
&lt;h3 id="개발-및-배포-독립성의-오류">개발 및 배포 독립성의 오류&lt;/h3>
&lt;p>전담팀이 서비스를 소유하고 운영하게 되므로 각자 개발 및 배포할 수 있게되어 &lt;strong>확장 가능한&lt;/strong>, 확장이 용이한 구조라고 생각하지만, 서비스는 확장 가능한 시스템을 구축하는 유일한 선택지가 아니다.&lt;/p>
&lt;ul>
&lt;li>모노리틱 시스템이나 컴포넌트 기반 시스템으로도 확장 가능한 시스템을 구축할 수 있다는 사실이 역사적으로 증명되어왔다.&lt;/li>
&lt;/ul>
&lt;p>결합 분리 오류에서 언급한 내용을 토대로 살펴보면 서비스라고 해서 항상 독립적으로 개발, 배포, 운영할 수 있는 것은 아니며, 결합된 정도에 맞게 조정해야한다.&lt;/p>
&lt;h2 id="야옹이-문제">야옹이 문제&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/27/img.png"
width="1393"
height="574"
srcset="https://codemario318.github.io/post/clean-architecture/27/img_huc93515613977e36e214e87cb871aaccb_354737_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/27/img_huc93515613977e36e214e87cb871aaccb_354737_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="242"
data-flex-basis="582px"
>&lt;/p>
&lt;p>이전에 예시로 들었던 택시 통합 시스템을 수많은 작은 마이크로 서비스를 기반으로 구축했다.&lt;/p>
&lt;p>이러한 아키텍처에서 야옹이 배달 서비스를 런칭하겠다고 가정한다.&lt;/p>
&lt;p>&lt;strong>요구사항&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>사용자는 집이나 사무실로 야옹이를 배달해달라고 주문할 수 있다.
&lt;ul>
&lt;li>야옹이를 태울 다수의 승차 지점을 설정해야한다.&lt;/li>
&lt;li>승차 지점 중 한 곳에서 야옹이를 태운 후, 올바른 주로소 야옹이를 배달해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>제약사항&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>운전자가 고양이 알러지가 있는 경우 해당 운전자는 이 서비스에서 제외되어야한다.&lt;/li>
&lt;li>일반 택시 승객이 알러지가 있을 수 있으므로, 배차를 신청한 고객이 알러지가 있다면, 야옹이를 배달했던 차량은 배차에서 제외한다.&lt;/li>
&lt;/ul>
&lt;p>서비스 다이어그램을 살펴봤을 때 마이크로서비스들은 모두 결합되어 있어 독립적으로 개발하고 배포하거나 유지할 수 없다.&lt;/p>
&lt;p>따라서 야옹이 배달 기능을 추가하려면 구성된 모든 마이크로서비스를 변경해야 한다.&lt;/p>
&lt;p>이는 횡단 관심사(Cross-Cutting Concern)가 지닌 문제로 기능적 분해는 새로운 기능이 기능적 행위를 횡단하는 상황에서 매우 취약하다.&lt;/p>
&lt;h2 id="객체가-구출하다">객체가 구출하다&lt;/h2>
&lt;p>SOLID 설계원칙에서, 다향적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 한다.&lt;/p>
&lt;p>이를 통해 컴포넌트 아키텍처에서는 아래와 같은 전략을 활용할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/27/img_1.png"
width="1418"
height="1356"
srcset="https://codemario318.github.io/post/clean-architecture/27/img_1_hu5da0ee89e3d37864338935723ad5c1a6_654243_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/27/img_1_hu5da0ee89e3d37864338935723ad5c1a6_654243_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="104"
data-flex-basis="250px"
>&lt;/p>
&lt;p>원래 서비스 로직 중 대다수가 이 객체 모델의 기반 클래스들 내부로 녹아들었다.&lt;/p>
&lt;ul>
&lt;li>배차에 특화된 로직 부분은 &lt;code>Rides&lt;/code> 컴포넌트로 추출되었다.&lt;/li>
&lt;li>야옹이에 대한 신규 기능은 &lt;code>Kittens&lt;/code> 컴포넌트에 들어있다.&lt;/li>
&lt;li>이 두 컴포넌트는 기존 컴포넌트들에 있는 추상 기반 클래스를 템플릿 메서드나 전략 패턴 등을 이용해서 오버라이드한다.&lt;/li>
&lt;li>신규 컴포넌트 &lt;code>Rides&lt;/code>, &lt;code>Kittens&lt;/code>가 의존성 규칙을 준수한다.&lt;/li>
&lt;li>이 기능을 구현하는 클래스들은 UI의 제어 하에 팩토리가 생성한다.&lt;/li>
&lt;/ul>
&lt;p>이 전략을 따르더라도 야옹이 기능을 구현하려면 &lt;code>TaxiUI&lt;/code>는 변경해야 하지만, 그 외의 것들은 변경할 필요가 없다.&lt;/p>
&lt;p>따라서 야옹이 기능은 결합이 분리되며, 독립적으로 개발하여 배포할 수 있다.&lt;/p>
&lt;h2 id="컴포넌트-기반-서비스">컴포넌트 기반 서비스&lt;/h2>
&lt;p>서비스가 반드시 소규모 단일체(monolith)일 이유는 없다.&lt;/p>
&lt;p>서비스는 SOLID 원칙대로 설계할 수 있으며 컴포넌트 구조를 갖출 수도 있다.&lt;/p>
&lt;p>java의 경우 서비스를 하나 이상의 &lt;code>jar&lt;/code> 파일에 포함되는 &lt;strong>추상 클래스들의 집합&lt;/strong>이라고 생각할 수 있다.&lt;/p>
&lt;p>새로운 기능 추가 혹은 기능 확장은 기존 &lt;code>jar&lt;/code> 파일에 정의돈 추상 클래스들을 확장하여 새로운 &lt;code>jar&lt;/code> 파일로 만든다면, 새로운 기능 배포는 서비스를 재배포하는 문제가 아니라, 서비스를 로드하는 경로에 단순히 새로운 &lt;code>jar&lt;/code> 파일을 추가하는 문제가 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/27/img_2.png"
width="1404"
height="1024"
srcset="https://codemario318.github.io/post/clean-architecture/27/img_2_huc3c601dcdc257ffe66a5f4dc26dbb7e2_569311_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/27/img_2_huc3c601dcdc257ffe66a5f4dc26dbb7e2_569311_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="329px"
>&lt;/p>
&lt;p>각 서비스의 내부는 자신만의 컴포넌트 설계로 되어 있어서 파생 클래스를 만드는 방식으로 신규 기능을 추가할 수 있다.&lt;/p>
&lt;h2 id="횡단-관심사">횡단 관심사&lt;/h2>
&lt;p>아키텍처 경계는 서비스 사이에 있지 않고 오히려 서비스를 관통하며, 서비스를 컴포넌트 단위로 분할한다.&lt;/p>
&lt;p>모든 주요 시스템이 직면하는 횡단 관심사를 처리하려면, 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/27/img_3.png"
width="1426"
height="639"
srcset="https://codemario318.github.io/post/clean-architecture/27/img_3_hu56c1406b520655ab8ea4c66d27f42c03_210561_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/27/img_3_hu56c1406b520655ab8ea4c66d27f42c03_210561_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="223"
data-flex-basis="535px"
>&lt;/p>
&lt;p>서비스들은 시스템의 아키텍처 경계를 정의하지 않으며, 아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트이다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>서비스는 시스템의 확정성과 개발 가능성 측면에서 유용하지만, 그 자체로는 아키텍처적으로 그리 중요한 요소는 아니다.&lt;/p>
&lt;p>시스템의 아키텍처는 구성 요소가 통신하고 실행되는 물리적인 매커니즘에 의해 아키텍처가 정의되는 것이 아닌, 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의된다.&lt;/p>
&lt;ul>
&lt;li>서비스는 단 하나의 아케텍처 경계로 둘러싸인 단일 컴포넌트로 만들 수 있다.&lt;/li>
&lt;li>여러 아키텍처 경계로 분리된 다수의 컴포넌트로 구성할 수도 있다.&lt;/li>
&lt;li>클라이언트와 서비스가 강하게 결합되어 아키텍처적으로 아무런 의미가 없을 때도 있다.&lt;/li>
&lt;/ul></description></item><item><title>26. 메인 컴포넌트</title><link>https://codemario318.github.io/post/clean-architecture/26/</link><pubDate>Mon, 15 Apr 2024 16:48:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/26/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/26/cover.png" alt="Featured image of post 26. 메인 컴포넌트" />&lt;p>모든 시스템에는 최소한 하나의 컴포넌트가 존재하여 나머지 컴포넌트를 생성, 조정, 관리하는데 이러한 컴포넌트를 메인 컴포넌트라 한다.&lt;/p>
&lt;h2 id="궁극적인-세부사항">궁극적인 세부사항&lt;/h2>
&lt;p>메인 컴포넌트는 &lt;strong>궁극적인 세부사항&lt;/strong>으로, 가장 낮은 수준의 정책이다.&lt;/p>
&lt;ul>
&lt;li>시스템의 초기 진입점이다.&lt;/li>
&lt;li>운영체제를 제외하면 어떤 것도 메인에 의존하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>메인은 모든 팩토리(Factory)와 전략(Strategy), 시스템 전반을 담당하는 나머지 기발 설비를 생성한 후, 시스템에서 더 높은 수준을 담당하는 부분으로 제어권을 넘긴다.&lt;/p>
&lt;hr>
&lt;p>의존성 주입 프레임워크를 이용해 의존성을 주입하는 일은 메인 컴포넌트에서 이뤄져야 한다.&lt;/p>
&lt;p>메인에 의존성이 주입되고 나면, 의존성 주입 프레임워크를 사용하지 않고도 일반적인 방식으로 의존성을 분배할 수 있어야한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">IOException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">game&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">HtwFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeGame&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;htw.game.HuntTheWumpusFacade&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Main&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">createMap&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">BufferdReader&lt;/span> &lt;span class="n">br&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">BufferedReader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">InputStreamReader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">in&lt;/span>&lt;span class="o">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeRestCommand&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">excute&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getPlayerCavern&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Health: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">hitPoints&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; arrows: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getQuiver&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">HuntTheWumpus&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">Command&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeRestCommand&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;&amp;gt;&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">String&lt;/span> &lt;span class="n">command&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">br&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">readLine&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;e&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">EAST&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;w&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">WEST&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;n&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">NORTH&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;s&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">SOUTH&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;r&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;sw&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">WEST&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;se&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">EAST&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;sn&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">EAST&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;ss&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">SOUTH&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;q&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">excute&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>HtwFactory&lt;/code>를 사용하여 게임을 생성할 때, &lt;code>htw.game.HuntTheWumpusFacade&lt;/code>라는 클래스 이름을 문자열로 전달하는데, 이는 이 클래스가 변경이 매우 많은 지저분한 클래스이므로, 문자열을 통해 참조하도록 하여 직접 참조하지 않게 하여 변경이 생겨도 메인을 재컴파일/재배포하지 않게 만들기 위함이다.&lt;/p>
&lt;p>입력 스티름 생성 부분, 게임의 메인 루프 처리, 간단한 입력 명령어 해석 등은 모두 &lt;code>main()&lt;/code>에서 처리하지만, 명령어를 실제로 처리하는 일은 다른 고수준 컴포넌트로 위임한다.&lt;/p>
&lt;hr>
&lt;p>메인은 클린 아키텍처에서 가장 바깥 원에 위치하는, 지저분한 저수준 모듈이다.&lt;/p>
&lt;p>메인은 고수준의 시스템을 위한 모든 것을 로드한 후, 제어권을 고수준의 시스템에게 넘긴다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>메인을 초기 조건과 성정을 구성하고, 외부 자원을 모두 수집한 후 제어권을 애플리케이션의 고수준 정책으로 넘기는 플러그인이다.&lt;/p>
&lt;p>메인은 플러그인이므로 메인 컴포넌트를 애플리케이션의 설정별로 하나씩 두로록 하여 둘 이상의 메인 컴포넌트를 만들 수도 있다.&lt;/p>
&lt;ul>
&lt;li>개발용 메인 플러그인&lt;/li>
&lt;li>테스트용 메인 플러그인&lt;/li>
&lt;li>국가별 플러그인&lt;/li>
&lt;li>관할 영역 별 플러그인&lt;/li>
&lt;li>고객별 플러그인 등&lt;/li>
&lt;/ul>
&lt;p>메인을 플러그인 컴포넌트로 여기고 아키텍처 경계 바깥에 위치한다고 보면 설정 관련 문제를 훨씬 쉽게 해결할 수 있다.&lt;/p></description></item><item><title>25. 계층과 경계</title><link>https://codemario318.github.io/post/clean-architecture/25/</link><pubDate>Thu, 04 Apr 2024 09:16:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/25/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/25/cover.png" alt="Featured image of post 25. 계층과 경계" />&lt;p>단순한 시스템에서는 UI, 업무 규칙, 데이터베이스 컴포넌트만으로도 충분하지만, 대다수의 시스템에서 컴포넌트의 개수는 이보다 훨씬 많다.&lt;/p>
&lt;p>이에 따라 컴포넌트간 경계도 훨씬 많이질 수 밖에 없다.&lt;/p>
&lt;p>아키텍처 경계는 어디에나 존재하며, 아키텍트는 아키텍처 경계가 언제 필요한지를 신중하게 파악해내야한다.&lt;/p>
&lt;p>이러한 경계를 제대로 구현하는 비용은 크며, 경계가 무시되었다면 나중에 다시 추가하는 비용도 매우 크다.&lt;/p>
&lt;p>오버 엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많으므로 XP의 원칙인 &lt;strong>YAGNI&lt;/strong>가 말하는 것 처럼 추상화가 필요하리라고 미리 예측해서는 안 된다.&lt;/p>
&lt;p>하지만, 경계가 존재하지 않는 상황에서 경계가 필요하다는 것을 깨닳고 추가하려면 비용이 매우 많이 들고 큰 위험을 감수해야한다.&lt;/p>
&lt;hr>
&lt;p>이처럼 소프트웨어 아키텍트는 여러 상황들을 적절히 고려하여 소프트웨어가 어떻게 발전할지 예측해야한다.&lt;/p>
&lt;p>이를 통해 완벽하게 구현할 경계와 부분적으로 구현할 경계, 무시할 경계가 무엇인지 결정해야만 한다.&lt;/p>
&lt;p>그렇지만 프로젝트 초반에는 경계를 쉽게 결정할 수 없기 때문에 한번에 정해지는 것은 아니므로, 시스템이 발전함에 따라 주의를 기울여야한다.&lt;/p>
&lt;ul>
&lt;li>경계가 필요할 수 있는 부분에 주목한다.&lt;/li>
&lt;li>경계가 존재하지 않아 생기는 마찰의 첫 조짐을 신중하게 관찰한다.
&lt;ul>
&lt;li>경계를 구현하는 비용가 무시할 때 감수할 비용을 가늠해본다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>결정된 사항을 자주 검토한다.&lt;/li>
&lt;/ul>
&lt;p>경계의 구현 비용이 그것을 무시하여 생기는 비용보다 적어지는 시점에 경계를 구현해야하며, 적절한 시점에 경계를 구현하기 위해 빈틈없이 지켜봐야한다.&lt;/p></description></item><item><title>24. 부분적 경계</title><link>https://codemario318.github.io/post/clean-architecture/24/</link><pubDate>Thu, 04 Apr 2024 08:49:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/24/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/24/cover.png" alt="Featured image of post 24. 부분적 경계" />&lt;p>아키텍처 경계를 완벽하게 만드는 데는 엄청난 노력을 기율여야 하고, 유지하는 데도 엄청난 노력이 든다.&lt;/p>
&lt;ul>
&lt;li>쌍방향의 다형적 &lt;code>Boundary&lt;/code> 인터페이스&lt;/li>
&lt;li>&lt;code>Input&lt;/code>, &lt;code>Output&lt;/code>을 위한 데이터 구조&lt;/li>
&lt;li>두 영역을 독립적으로 컴파일하고 배포할 수 있는 컴포넌트로 격리하는 데 필요한 모든 의존성 관리&lt;/li>
&lt;/ul>
&lt;p>많은 경우에 이러한 경계를 만드는 비용이 크다고 판단하면서도, 필요한 작업만 해야한다는 XP 원칙인 &lt;strong>YAGNI&lt;/strong>(You Aren&amp;rsquo;t going to Need It)을 위배하며 나중에 필요할 것이라 예상대는 것들에 대한 대비하길 원한다.&lt;/p>
&lt;p>이렇게 필요할 것으로 예상되는 것을 꼭 대비해야 한다면 완벽한 경계가 아닌 &lt;strong>부분적 경계&lt;/strong>(Patial boundary)를 활용해 볼 수 있다.&lt;/p>
&lt;h2 id="마지막-단계를-건너-뛰기">마지막 단계를 건너 뛰기&lt;/h2>
&lt;p>독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 방법이다.&lt;/p>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>다수의 컴포넌트를 관리하는 작업을 하지 않아도 된다.&lt;/li>
&lt;li>추적을 위한 버전 번호도 필요없다.&lt;/li>
&lt;li>배포 관리 부담이 없다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>부분적 경계를 만들기 위해 완벽한 경계를 만들 때 만큼의 코드량과 사전 설계가 필요하다.&lt;/li>
&lt;li>시간이 흐르며 별도로 분리한 컴포넌트가 재사용될 가능성이 전혀 없을 것임이 명백해지는 경우가 있다.&lt;/li>
&lt;li>시간이 흐르며 컴포넌트 사이의 구분이 점점 약화된다.&lt;/li>
&lt;/ul>
&lt;h2 id="일차원-경계">일차원 경계&lt;/h2>
&lt;p>완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 &lt;code>Boundary&lt;/code> 인터페이스를 사용하는데, 이러한 형태는 초기 설정할 때나 지속적으로 유지할 때도 비용이 많이 든다.&lt;/p>
&lt;p>이러한 경우 추후 완벽한 형태의 경계로 확장할 수 있는 공간을 확보하고자 할 때, 전통적인 전략 패턴을 사용하여 간단한 구조를 활용해 볼 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/24/img.png"
width="720"
height="292"
srcset="https://codemario318.github.io/post/clean-architecture/24/img_huf66003e0682ccdb8f85feab7e684d52d_81657_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/24/img_huf66003e0682ccdb8f85feab7e684d52d_81657_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="246"
data-flex-basis="591px"
>&lt;/p>
&lt;p>&lt;code>Client&lt;/code>를 &lt;code>ServiceImpl&lt;/code>로 부터 격리시키는 데 필요한 의존성 역전이 적용되었기 때문에 미래에 필요한 아키텍처 경계를 대비할 수 있다.&lt;/p>
&lt;p>하지만 이러한 형태의 분리는 쌍방향 인터페이스가 없고 개발자와 아키텍트의 능력에 따라, 점선과 같은 비밀 통로가 생기는 일을 막을 방법이 없다.&lt;/p>
&lt;h2 id="퍼사드">퍼사드&lt;/h2>
&lt;p>더 단순한 경계는 퍼사드 패턴으로, 이 경우에는 의존성 역전까지 희생한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/24/img_1.png"
width="720"
height="299"
srcset="https://codemario318.github.io/post/clean-architecture/24/img_1_huda7c855c7c3463c0aff875896060fffa_46486_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/24/img_1_huda7c855c7c3463c0aff875896060fffa_46486_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="240"
data-flex-basis="577px"
>&lt;/p>
&lt;p>경계는 &lt;code>Facade&lt;/code> 클래스로만 간단히 전의되며, 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 서비스 클래스로 호출을 전달한다.&lt;/p>
&lt;p>클라이언트는 서비스 클래스에 직접 접근할 수 없지만, &lt;code>Client&lt;/code>가 이 모든 서비스 클래스에 대해 추이 종속성을 가지게 된다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>추이 종속성&lt;/strong>&lt;br>
A 모듈이 B 모듈에 의존하고, B 모듈이 C 모듈에 의존한다고 가정할 때, A 모듈은 직접적으로는 C 모듈에 의존하지 않지만, B 모듈을 통해 C 모듈에 간접적으로 의존하는 형태&lt;/p>
&lt;/blockquote>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>아키텍처 경계를 부분적으로 구현하는 방법은 많다.&lt;/p>
&lt;p>이러한 접근법은 각각 나름의 비용과 장점을 지니며, 완벽한 형태의 경계를 담기 위한 공간으로써 적절하게 사용할 수 있는 상황이 서로 다르다.&lt;/p>
&lt;p>부분적인 경계는 추후에 완벽한 형태의 경계가 실제로 구체화되지 않으면 가치가 떨어질 수 있다.&lt;/p></description></item><item><title>23. 프레젠터와 험블 객체</title><link>https://codemario318.github.io/post/clean-architecture/23/</link><pubDate>Wed, 03 Apr 2024 22:31:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/23/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/23/cover.png" alt="Featured image of post 23. 프레젠터와 험블 객체" />&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/23/img.png"
width="772"
height="567"
srcset="https://codemario318.github.io/post/clean-architecture/23/img_hudd764f775c86d6d6fb1802d465c14dac_405598_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/23/img_hudd764f775c86d6d6fb1802d465c14dac_405598_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="326px"
>&lt;/p>
&lt;p>프레젠터는 험블 객체(Humble Object) 패턴을 따른 형태로, 아키텍처 경계를 식별하고 보호하는 데 도움이 된다.&lt;/p>
&lt;h2 id="험블-객체-패턴">험블 객체 패턴&lt;/h2>
&lt;p>험블 객체 패턴은 디자인 패턴으로, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.&lt;/p>
&lt;ul>
&lt;li>행위들을 두 개의 모듈 또는 클래스로 나눈다.&lt;/li>
&lt;li>가장 기본적인 본질은 남기고, 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다.&lt;/li>
&lt;li>나머지 모듈에는 험블 객체에 속하지 않은, 테스트하기 쉬운 행위를 모두 옮긴다.&lt;/li>
&lt;/ul>
&lt;h2 id="프레젠터와-뷰">프레젠터와 뷰&lt;/h2>
&lt;p>GUI는 화면에서 각 요소가 필요한 위치에 적절히 표시되었는지 테스트 해야하므로 작성하기 어려운 반면, GUI에서 수행하는 행위의 대다수는 쉽게 테스트할 수 있다.&lt;/p>
&lt;p>험블 객체 패턴을 사용하면 두 부류의 행위를 분리하여 프레젠터와 뷰라는 서로 다른 클래스로 만들 수 있다.&lt;/p>
&lt;p>&lt;strong>뷰&lt;/strong>&lt;br>
뷰는 데이터를 GUI로 이동시키지만, 데이터를 직접 처리하지는 않는다.&lt;/p>
&lt;ul>
&lt;li>험블 객체이고 테스트하기 어렵다.&lt;/li>
&lt;li>포함된 코드를 가능한 간단하게 유지한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>프레젠터&lt;/strong>&lt;br>
애플리케이션으로 부터 데이터를 받아 화면에 표현할 수 있는 포멧으로 만든다.&lt;/p>
&lt;ul>
&lt;li>뷰가 데이터를 받아 화면에 전달하는 간단한 일만 처리하도록 만들어준다.&lt;/li>
&lt;li>테스트하기 쉬워진다.&lt;/li>
&lt;/ul>
&lt;p>뷰는 뷰 모델의 데이터를 화면으로 로드할 뿐이며, 이 외에 뷰가 맡은 역할은 전혀 없기 때문에 뷰는 보잘것없다(Humble)&lt;/p>
&lt;h2 id="테스트와-아키텍처">테스트와 아키텍처&lt;/h2>
&lt;p>테스트 용이성은 좋은 아키텍처가 지녀야 할 속성으로 오랫동안 알려저 왔다.&lt;/p>
&lt;p>험블 객체 패턴은 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하여 아키텍처 경계를 정의하므로 테스트가 용이하다.&lt;/p>
&lt;p>즉, 아키텍처에 험블 객체 패턴을 적절히 활용하면 프레젠터와 뷰와 같이 테스트가 용이한 구조를 만들 수 있다.&lt;/p>
&lt;h2 id="데이터베이스-게이트웨이">데이터베이스 게이트웨이&lt;/h2>
&lt;p>유스케이스 인터랙터와 데이터베이스 사이에는 데이터베이스 게이트웨이(데이터베이스의 쿼리를 처리하는 모든 메서드가 포함)가 위치한다.&lt;/p>
&lt;p>유스케이스 레이어는 SQL을 허용하지 않아야 하므로 필요한 메서드를 제공하는 게이트웨이 인터페이스를 호출하게 되는데, 이 때 데이터베이스 레이어에 존재하는 &lt;strong>인터페이스의 구현체&lt;/strong>가 험블 객체이다.&lt;/p>
&lt;p>이와 달리 인터랙터는 애플리케이션에 특화된 업무 규칙을 캡슐화화기 때문에 험블 객체가 아니기 때문에 게이트웨이는 가짜 데이터(Mock, stub, test-double, fake)를 통해서도 테스트를 할 수 있으므로 테스트하기 쉬워진다.&lt;/p>
&lt;h2 id="데이터-매퍼">데이터 매퍼&lt;/h2>
&lt;p>하이버네이트와 같은 ORM은 어느 계층에 속하는가?&lt;/p>
&lt;p>ORM 시스템은 데이터베이스 레이어에 위치하며 게이트웨이 인터페이스와 데이터베이스 사이의 일종에 또 다른 험블 객체 경계를 형성한다.&lt;/p>
&lt;ul>
&lt;li>사용자 관점에서 객체는 공개된 메서드만 볼 수 있으므로, 단순히 오퍼레이션의 집합이다.&lt;/li>
&lt;li>&lt;strong>데이터 구조&lt;/strong>는 함축된 행위를 가지지 않는 공개된 변수의 집합이다.&lt;/li>
&lt;/ul>
&lt;p>객체는 데이터 구조가 아니기 때문에, 사실 객체 관계 매퍼(Object Relational Mapper, ORM)는 관계형 데이터베이스 테이블로부터 가져온 데이터를 데이터 구조에 맞게 담아주는 역할을 수행하므로 사실 데이터 매퍼라고 볼 수 있다.&lt;/p>
&lt;h2 id="서비스-리스너">서비스 리스너&lt;/h2>
&lt;p>서비스에서도 험블 객체 패턴을 발견할 수 있다.&lt;/p>
&lt;p>애플리케이션은 데이터를 간단한 데이터 구조 형태로 로드한 후, 이 데이터 구조를 경계를 거슬러 특정 모듈로 전달하고, 데이터 구조를 전달받은 모듈이 적절한 포맷으로 만들어 외부 서비스로 전송하게 된다.&lt;/p>
&lt;p>외부로부터 데이터를 수신하는 서비스는 서비스 리스너가 서비스 인터페이스로부터 데이터를 수신하고, 데이터를 애플리케이션에서 사용할 수 있게 간단한 데이터 구조로 포맷을 변경하여 서비스 경계를 가로질러 내부로 전달된다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>아키텍처 경계마다 험블 객체 패턴을 발견할 수 있다.&lt;/p>
&lt;p>경계를 넘나드는 통신은 거의 모두 간단한 데이터 구조를 수반할 때가 많고, 대개 그 경계는 테스트하기 어려운 무언가와 테스트하기 쉬운 무언가로 분리된다.&lt;/p>
&lt;p>이러한 아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다.&lt;/p></description></item><item><title>22. 클린 아키텍처</title><link>https://codemario318.github.io/post/clean-architecture/22/</link><pubDate>Wed, 03 Apr 2024 16:22:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/22/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/22/cover.png" alt="Featured image of post 22. 클린 아키텍처" />&lt;ul>
&lt;li>육각형 아키텍처(Hexagonal Architecture)&lt;/li>
&lt;li>DCI(Data, Context and Interaction)&lt;/li>
&lt;li>BCE(Boundary-Control-Entity)&lt;/li>
&lt;/ul>
&lt;p>위와 같은 아키텍처들의 목적은 &lt;strong>관심사의 분리&lt;/strong>(Separation of concerns)이다.&lt;/p>
&lt;p>소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성할 수 있었다.&lt;/p>
&lt;p>각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함하며, 시스템이 다음과 같은 특징을 가지도록 만든다.&lt;/p>
&lt;ul>
&lt;li>프레임워크 독립성&lt;/li>
&lt;li>테스트 용이성&lt;/li>
&lt;li>UI 독립성&lt;/li>
&lt;li>데이터베이스 독립성&lt;/li>
&lt;li>모든 외부 에이전시에 대한 독립성&lt;/li>
&lt;/ul>
&lt;h2 id="의존성-규칙">의존성 규칙&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/22/img.png"
width="772"
height="567"
srcset="https://codemario318.github.io/post/clean-architecture/22/img_hudd764f775c86d6d6fb1802d465c14dac_405598_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/22/img_hudd764f775c86d6d6fb1802d465c14dac_405598_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="326px"
>&lt;/p>
&lt;p>그림의 각 동원은 소프트웨어의 서로 다른 영역을 표현하는데, 안으로 들어갈수록 고수준의 소프트웨어가 된다.(바깥쪽은 메커니즘, 안쪽은 정책)&lt;/p>
&lt;p>이러한 아키텍처가 동작하도록 하는 가장 중요한 규칙은 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다는 &lt;strong>의존성 규칙&lt;/strong>(Dependency Rule)이다.&lt;/p>
&lt;ul>
&lt;li>내부의 원에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못한다.
&lt;ul>
&lt;li>함수, 클래스, 변수, 엔티티 등&lt;/li>
&lt;li>외부의 원에 선언된 데이터 형식도 내부의 원에서 절대 사용해서는 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>외부 원에 위치한 어떤 것도 내부 원에 영향을 주지 않아야한다.&lt;/p>
&lt;h3 id="엔티티">엔티티&lt;/h3>
&lt;p>엔티티는 전사적인 핵심 업무 규칙을 캡슐화한 것이다.(단순한 단일 애플리케이션이라면 애플리케이션의 업무 객체)&lt;/p>
&lt;ul>
&lt;li>메서드를 가지는 객체&lt;/li>
&lt;li>일련의 데이터 구조와 함수의 집합&lt;/li>
&lt;/ul>
&lt;p>기업의 다양한 애플리케이션에서 엔티티를 재사용할 수만 있다면, 그 형태는 그다지 중요하지 않다.&lt;/p>
&lt;p>운영 관점에서 특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안 된다.&lt;/p>
&lt;h3 id="유스케이스">유스케이스&lt;/h3>
&lt;p>유스케이스 계층의 소프트웨어는 애플리케이션에 특화된 업무 규칙을 포함하며, 시스템의 모든 유스케이스를 캡슐화하고 구현한다.&lt;/p>
&lt;ul>
&lt;li>엔티티로 들어오고 나가는 데이터 흐름을 조정한다.&lt;/li>
&lt;li>엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다.&lt;/li>
&lt;/ul>
&lt;p>유스케이스 레이어를 잘 격리하여 발생한 변경이 엔티티에 영향을 줘서는 안될 뿐만 아니라, 외부 요소에서 발생한 변경이 이 계층에 영향을 줘서도 안된다.&lt;/p>
&lt;p>유스케이스 레이어는 아래와 같은 상황에서만 영향을 받아야한다.&lt;/p>
&lt;ul>
&lt;li>운영 관점에서 애플리케이션이 변경되어 유스케이스 자체가 영향을 받은 경우&lt;/li>
&lt;li>유스케이스의 세부 사항이 변경된 경우&lt;/li>
&lt;/ul>
&lt;h3 id="인터페이스-어댑터">인터페이스 어댑터&lt;/h3>
&lt;p>인터페이스 어댑터 레이어는 일련의 어댑터들(Controllers, Gateways, Presenters)로 구성된다.&lt;/p>
&lt;p>어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환한다.&lt;/p>
&lt;ul>
&lt;li>ex) GUI의 MVC 아키텍처&lt;/li>
&lt;/ul>
&lt;p>모델은 데이터 구조 정도에 지나지 않으며, 컨트롤러에서 유스케이스로 전달되고, 다시 유스케이스에서 프레젠터와 뷰로 되돌아간다.&lt;/p>
&lt;p>인터페이스 어댑터 레이어는 데이터를 엔티티와 유스케이스에게 가장 편리한 형식에서 영속성용으로 사용 중인 임의의 프레임워크(ex. DB)가 이용하기에 가장 편리한 형식으로 변환한다.&lt;/p>
&lt;p>또한 데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또 다른 어댑터가 필요하다.&lt;/p>
&lt;h3 id="프레임워크와-드라이버">프레임워크와 드라이버&lt;/h3>
&lt;p>가장 바깥 레이어인 프레임워크와 드라이버 레이어는 모든 세부사항이 위치하는 곳으로, 일반적으로 데이터베이스나 웹 프레임워크 같은 프레임워크나 도구들로 구성된다.&lt;/p>
&lt;p>이 계층에서는 안쪽 원과 통신하기 위한 접합 코드 외에는 특별히 더 작성해야 할 코드가 그다지 많지 않다.&lt;/p>
&lt;p>웹, 데이터베이스와 같은 세부사항을 모두 외부에 위치시켜서 피해를 최소화한다.&lt;/p>
&lt;h3 id="원은-네-개여야만-하는가">원은 네 개여야만 하는가?&lt;/h3>
&lt;p>그림의 원들은 하나의 예시일 뿐이며 더 많은 원이 필요할 수 있다.&lt;/p>
&lt;p>하지만 어떤 경우에도 &lt;strong>의존성 규칙&lt;/strong>은 적용된다.&lt;/p>
&lt;ul>
&lt;li>소스코드 의존성은 항상 안족을 향한다.&lt;/li>
&lt;li>안쪽으로 이동할수록 추상화와 정책의 수준은 높아진다.&lt;/li>
&lt;li>가장 바깥쪽 원은 저수준의 구체적인 세부사항으로 구성된다.&lt;/li>
&lt;li>안쪽으로 이동할수록 소프트웨어는 점점 추상화되고 더 높은 수준의 정책들을 캡슐화한다.&lt;/li>
&lt;/ul>
&lt;h3 id="경계-횡단하기">경계 횡단하기&lt;/h3>
&lt;p>위 예시에서 컨트롤러와 프레젠터가 다음 계층에 속한 유스케이스와 통신하는 모습을 확인할 수 있다.&lt;/p>
&lt;ol>
&lt;li>컨트롤에서 시작&lt;/li>
&lt;li>유스케이스를 지남&lt;/li>
&lt;li>프레젠터에서 실행&lt;/li>
&lt;/ol>
&lt;p>유스케이스가 내부 원의 인터페이스를 호출하도록 하고, 외부 원의 프레젠터가 그 인터페이스를 구현하도록 만들어 의존성 흐름을 역전시켰다.&lt;/p>
&lt;p>이처럼 제어흐름과 의존성의 방향이 명백히 반대여야 하는 경우, 의존성 역전 원칙을 사용하여 해결한다.&lt;/p>
&lt;ul>
&lt;li>인터페이스와 상속 관계 등&lt;/li>
&lt;/ul>
&lt;p>아키텍처 경계를 횡단할 때 언제라도 동일한 기법을 사용할 수 있다.&lt;/p>
&lt;h3 id="경계를-횡단하는-데이터는-어떤-모습인가">경계를 횡단하는 데이터는 어떤 모습인가?&lt;/h3>
&lt;p>경계를 가로지르는 데이터는 흔히 간단한 데이터 구조로 이루어져 있다.&lt;/p>
&lt;ul>
&lt;li>기본적인 구조체, 간단한 데이터 전송 객체(DTO) 등&lt;/li>
&lt;li>함수 호출 시 간단한 인자&lt;/li>
&lt;li>해시맵, 객체&lt;/li>
&lt;/ul>
&lt;p>중요한 점은 엔티티 객체나 데이터베이스의 행을 전달하는 것이 아닌 격리되어 있는 간단한 데이터 구조가 경계를 가로질러 전달되어야 한다.&lt;/p>
&lt;p>위와 같은 경우 결과적으로 어떠한 형태로든 전달되는 데이터 구조를 통해 내부의 원에서 외부 원의 무언가를 알게 되므로 의존성 규칙을 위배하게된다.&lt;/p>
&lt;p>따라서 경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야한다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>위와같은 간단한 규칙들을 준수하는 것은 어렵지 않으며, 향후에 겪을 수많은 고통거리를 덜어준다.&lt;/p>
&lt;p>소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며, 그에 다른 이점을 누릴 수 있다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스나 프레임워크와 같은 시스템의 외부 요소를 교체하더라도 훨씬 수월해진다.&lt;/li>
&lt;/ul></description></item><item><title>21. 소리치는 아키텍처</title><link>https://codemario318.github.io/post/clean-architecture/21/</link><pubDate>Tue, 02 Apr 2024 16:19:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/21/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/21/cover.png" alt="Featured image of post 21. 소리치는 아키텍처" />&lt;p>건물의 청사진을 살펴본다고 가정했을 때, 커다란 정문, 체크인과 체크아웃을 담당할 사서를 위한 공간, 독서 공간, 작은 회의실, 책장을 배치한 진열실이 나타난다면, 이 아키텍처는 &amp;ldquo;도서관&amp;quot;을 위한 아키텍처임을 예상해볼 수 있다.&lt;/p>
&lt;p>이처럼 잘 만들어진 소프트웨어 아키텍처라면 상위 수준의 디렉터리 구조, 최상위 패키지에 담긴 소스 파일등을 살펴보면 어떠한 역할을 수행하는 소프트웨어인지 한눈에 파악할 수 있다.&lt;/p>
&lt;h2 id="아키텍처의-테마">아키텍처의 테마&lt;/h2>
&lt;blockquote>
&lt;p>소프트웨어 아키텍처는 시스템의 유스케이스를 지원하는 구조이다.&lt;br>
- 이바 야콥슨 Ivar Jacobson,&lt;br>
Object-Oriented Software Engineering: Use Case Driven Approach&lt;/p>
&lt;/blockquote>
&lt;p>소프트웨어 애플리케이션의 아키텍처도 애플리케이션의 유스케이스에 대해 소리처야한다.&lt;/p>
&lt;ul>
&lt;li>아키텍처는 프레임워크에 대한 것이 아니며 절대로 그래서도 안된다.&lt;/li>
&lt;li>아키텍처를 프레임워크로부터 제공받아서는 절대 안된다.&lt;/li>
&lt;/ul>
&lt;p>프레임워크는 사용하는 도구일 뿐, 아키텍처가 준수해야 할 대상이 아니다.&lt;/p>
&lt;p>아키텍처를 프레임워크 중심으로 만들어버리면 유스케이스가 중심이 되는 아키텍처는 절대 나올 수 없다.&lt;/p>
&lt;h2 id="아키텍처의-목적">아키텍처의 목적&lt;/h2>
&lt;p>좋은 아키텍처는 유스케이스를 그 중심에 두기 때문에, 프레임워크나 도구, 환경에 전혀 구애받지 않고 유스케이스를 지원하는 구조를 아무런 문제 없이 기술할 수 있다.&lt;/p>
&lt;ul>
&lt;li>건물의 청사진의 관심사는 목적에 맞는 공간임을 확실히 하는 것이지, 어떤 기법, 재질로 지어지는지 확인하는 것이 아니다.&lt;/li>
&lt;/ul>
&lt;p>좋은 소프트웨어 아키텍처는 유스케이스에 중점을 두며, 지엽적인 관심사에 대한 결합을 분리시켜 개발 환경 문제나 도구에 대해서는 결정을 미루고, 쉽게 번복할 수 있도록 한다.&lt;/p>
&lt;h2 id="하지만-웹은">하지만 웹은?&lt;/h2>
&lt;p>웹은 전달 메커니즘(입출력 장치)이며, 애플리케이션 아키텍처에서도 그와 같이 취급해야한다.&lt;/p>
&lt;ul>
&lt;li>웹을 통해 전달된다는 사실 자체가 세부 사항이므로, 시스템 구조를 지배해서는 안된다.&lt;/li>
&lt;/ul>
&lt;p>시스템 아키텍처는 과도한 문제를 일으키거나 근본적인 아키텍처를 뜯어고치지 않더라도 시스템을 콘솔 앱, 웹 앱, 리치 클라이언트, 웹서비스 앱등 다양한 방식으로 전달할 수 있어야 한다.&lt;/p>
&lt;h2 id="프레임워크는-도구일-뿐-삶의-방식은-아니다">프레임워크는 도구일 뿐, 삶의 방식은 아니다&lt;/h2>
&lt;p>프레임워크는 매우 강력하고 상당히 유용할 수 있지만, 프레임워크가 아키텍처의 기준이 되서는 안된다.&lt;/p>
&lt;p>좋은 아키텍트라면 아키텍처를 유스케이스에 중점을 둔 채 그대로 보존할 수 있을지를 생각해야 하며, 프레임워크가 아키텍처의 중심을 차지하는 일을 막을 수 있는 전략을 개발해야한다.&lt;/p>
&lt;h2 id="테스트하기-쉬운-아키텍처">테스트하기 쉬운 아키텍처&lt;/h2>
&lt;p>아키텍처가 유스케이스를 최우선으로 하고, 이로인해 프레임워크와는 적당한 거리를 둔다면, 프레임워크를 전혀 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다.&lt;/p>
&lt;ul>
&lt;li>테스트를 돌리는 데 웹 서버가 반드시 필요한 상황이 되어서는 안된다.&lt;/li>
&lt;li>데이터베이스가 반드시 연결되어 있어야만 테스트를 돌릴 수 있어서도 안된다.&lt;/li>
&lt;/ul>
&lt;p>엔티티 객체는 반드시 오래된 방식의 간단한 객체(Plain Old Object)여야 하며, 여타 복잡한 것들에 의존해서는 안된다.&lt;/p>
&lt;p>유스케이스 객체가 엔티티 객체를 조작하도록 해야하며, 최종적으로 프레임워크로 인한 어려움을 겪지 않고도 이 모두를 있는 그래도 테스트할 수 있어야 한다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>아키텍처는 유스케이스를 통해 시스템을 이야기해야 하며, 시스템에 적용한 프레임워크에 대해 이야기해서는 안된다.&lt;/p>
&lt;p>시스템이 어떻게 전달될지 알지 못한 상태에서도 시스템의 모든 유스케이스를 이해할 수 있어야한다.&lt;/p></description></item><item><title>20. 업무 규칙</title><link>https://codemario318.github.io/post/clean-architecture/20/</link><pubDate>Fri, 22 Mar 2024 00:23:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/20/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/20/cover.png" alt="Featured image of post 20. 업무 규칙" />&lt;p>애플리케이션을 업무 규칙과 플러그인으로 구분하려면 업무 규칙이 실제로 무엇인지를 잘 이해해야만 한다.&lt;/p>
&lt;p>&lt;strong>핵심 업무 규칙&lt;/strong>(Critical Business Rule)&lt;/p>
&lt;ul>
&lt;li>업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차이다.&lt;/li>
&lt;li>컴퓨터상으로 구현했는지와 상관없이, 사업적으로 수익을 얻거나 비용을 줄일 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;p>핵심 업무 규칙은 사업 자체에 핵심적이며, 규칙을 자동화하는 시스템이 없더라도 업무 규칙은 그대로 존재한다.&lt;/p>
&lt;p>&lt;strong>핵심 업무 데이터&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>핵심 업무 규칙이 요구하는 데이터&lt;/li>
&lt;li>시스템으로 자동화되지 않은 경우에도 존재하는 데이터이다.&lt;/li>
&lt;/ul>
&lt;p>핵심 규칙과 핵심 데이터는 본질적으로 결함되어 있기 때문에 객체로 만들 좋은 후보가 되며 이러한 유형의 객체를 &lt;strong>엔티티&lt;/strong>(Entity)라고 부른다.&lt;/p>
&lt;h2 id="엔티티">엔티티&lt;/h2>
&lt;p>엔티티는 컴퓨터 시스템 내부의 객체로서, 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화한다.&lt;/p>
&lt;ul>
&lt;li>핵심 업무 데이터를 직접 포함할 수 있다.&lt;/li>
&lt;li>핵심 업무 데이터에 매우 쉽게 접근할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>엔티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/20/img.png"
width="600"
height="279"
srcset="https://codemario318.github.io/post/clean-architecture/20/img_hubc44a445cee9fc3574f155c156bd7117_18299_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/20/img_hubc44a445cee9fc3574f155c156bd7117_18299_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="215"
data-flex-basis="516px"
>&lt;/p>
&lt;p>엔티티를 생성할 때는&lt;/p>
&lt;ul>
&lt;li>업무에서 핵심적인 개념을 구현하는 소프트웨어를 한데 모은다.&lt;/li>
&lt;li>구축 중인 자동화 시스템의 나머지 모든 고려사항과 분리시킨다.&lt;/li>
&lt;/ul>
&lt;p>이 클래스는 업무의 대표자로서 독립적으로 존재한다.&lt;/p>
&lt;p>엔티티는 순전히 업무만을 위한 것이므로 데이터베이스, 사용자 인터페이스, 서드파티 프레임워크에 대한 고려사항들로 인해 오염되어서는 절대 안된다.&lt;/p>
&lt;ul>
&lt;li>어떤 시스템에서도 업무를 수행할 수 있어야 한다.&lt;/li>
&lt;li>시스템의 표현 형식이나 데이터 저장 방식, 시스템에서 컴퓨터가 배치되는 방식과도 무관하다.&lt;/li>
&lt;/ul>
&lt;p>엔티티의 유일한 요구 조건은 &lt;strong>핵심 업무 데이터와 핵심 업무 규칙을 하나로 묶어 별도의 소프트웨어 모듈로 만들어야 한다는 것이다.&lt;/strong>&lt;/p>
&lt;h2 id="유스케이스">유스케이스&lt;/h2>
&lt;p>유스케이스는 &lt;strong>자동화된 시스템이 동작하는 방법을 정의하고 제약함으로써 수익을 얻거나 비용을 줄이는 업무 규칙&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>자동화된 시스템이 사용되는 방법을 설명한다.&lt;/li>
&lt;li>사용자가 제공해야 하는 입력을 기술한다.&lt;/li>
&lt;li>사용자에게 제공해야하는 출력을 기술한다.&lt;/li>
&lt;li>해당 출력을 생성하기 위한 처리 단계를 기술한다.&lt;/li>
&lt;/ul>
&lt;p>엔티티 내의 핵심 업무 규칙과는 반대로, &lt;strong>애플리케이션에 특화된 업무 규칙&lt;/strong>을 설명한다.&lt;/p>
&lt;p>인터페이스로 들어오는 데이터와 인터페이스에서 도될려주는 데이터를 형식 없이 명시한다는 점만 빼면, 유스케이스는 사용자 인터페이스를 기술하지 않는다.&lt;/p>
&lt;p>유스케이스는 시스템이 사용자에게 어떻게 보이는지를 설명하지 않는다.&lt;/p>
&lt;p>애플리케이션에 특화된 규칙을 설명하며, 이를 통해 &lt;strong>사용자와 엔티티 사이의 상호작용을 규정&lt;/strong>한다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션에 특화된 업무 규칙을 구현하는 하나 이상의 함수를 제공한다.&lt;/li>
&lt;li>입력 데이터를 포함한다.&lt;/li>
&lt;li>출력 데이터를 포함한다.&lt;/li>
&lt;li>유스케이스가 상호작용하는 엔티티에 대한 참조 데이터를 포함한다.&lt;/li>
&lt;/ul>
&lt;p>유스케이스는 단일 애플리케이션에 특화되어 있으며, 따라서 해당 시스템의 입력과 출력에 보다 가깝게 위치하므로, 엔티티와 같은 고수준 개념은 유스케이스와 같은 저수준 개념에 대해 아무것도 알지 못한다.&lt;/p>
&lt;p>즉, 유스케이스는 엔티티에 의존하며, 엔티티는 유스케이스에 의존하지 않는다.&lt;/p>
&lt;h2 id="요청-및-응답-모델">요청 및 응답 모델&lt;/h2>
&lt;p>유스케이스는 입력 데이터를 받아서 출력 데이터를 생성한다.&lt;/p>
&lt;p>하지만 제대로 구성된 유스 케이스 객체라면 데이터를 사용자나 또 다른 컴포넌트와 주고 받는 방식에 대해서는 전혀 눈치챌 수 없어야 한다.&lt;/p>
&lt;p>유스케이스는 단순한 요청 데이터 구조를 입력으로 받아들이고 단순한 응답 데이터 구조를 출력으로 반환하는 역할만 수행하며, 이러한 데이터 구조는 어떤것에도 의존하지 않아야 한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>HttpRequest&lt;/code>, &lt;code>HttpResponse&lt;/code> 등&lt;/li>
&lt;/ul>
&lt;p>요청 및 응답 모델이 독립적이지 않다면 그 모델에 의존하는 유스케이스도 결국 해당 모델이 수반하는 의존성에 간접적으로 결합이 되므로 의존성을 제거해야 한다.&lt;/p>
&lt;hr>
&lt;p>엔티티와 요청/응답 모델은 많은 데이터를 공유하므로 엔티티의 참조를 요청/응답 데이터 구조에 포함하려는 유혹을 받을 수 있다.&lt;/p>
&lt;p>하지만 두 객체의 목적은 완전히 다르므로, 시간이 지남에 따라 다른 이유로 변경될 것이다.&lt;/p>
&lt;p>따라서 어떤 식으로든 함께 묶는 행위는 공통 폐쇄 원칙과 단일 책임 원칙을 위배하게 되며, 결국 코드에는 수많은 떠돌이 데이터가 만들어지고, 이로인해 수많은 조건문이 추가되어 버린다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>업무 규칙은 소프트웨어 시스템이 존재하는 이유, 핵심적인 기능이다.&lt;/p>
&lt;p>업무 규칙은 수익을 내고 비용을 줄이는 코드를 수반하는 매우 중요한 요소이다.&lt;/p>
&lt;p>따라서 사용자 인터페이스나 데이터베이스와 같은 저수준의 관심사로 인해 오염되어서는 안 되며, 원래 그대로의 모습으로 남아 있어야 한다.&lt;/p>
&lt;p>이상적으로는 업무 규칙을 표현하는 코드는 반드시 시스템의 심장부에 위치해야 하며, 덜 중요한 코드는 이 심장부에 플러그인되어야 한다.&lt;/p>
&lt;p>&lt;strong>업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드여야 한다.&lt;/strong>&lt;/p></description></item><item><title>19. 정책과 수준</title><link>https://codemario318.github.io/post/clean-architecture/19/</link><pubDate>Thu, 21 Mar 2024 23:41:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/19/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/19/cover.png" alt="Featured image of post 19. 정책과 수준" />&lt;p>소프트웨어 시스템이란 정책을 기술한 것이다.&lt;/p>
&lt;p>컴퓨터 프로그램은 각 입력을 출력으로 변환하는 정책을 상세하게 기술한 설명서이다.&lt;/p>
&lt;p>대다수의 주요 시스템에서 하나의 정책은 이 정책을 서술하는 여러 개의 조그만 정책들로 쪼갤 수 있다.&lt;/p>
&lt;p>소프트웨어 아키텍처를 개발하는 기술에는 정책을 신중하게 분리하고, 정책이 변경되는 양상에 따라 정책을 재편성하는 일도 포함된다.&lt;/p>
&lt;ul>
&lt;li>동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며, 동일한 컴포넌트에 속해야 한다.&lt;/li>
&lt;li>서로 다른 이유, 다른 시점에 변경되는 정책은 다른 수준에 위치하며, 반드시 컴포넌트로 분리해야 한다.&lt;/li>
&lt;/ul>
&lt;p>아키텍처 개발은 재편성된 컴포넌트들을 비순환 방향 그래프(directed acyclic graph)로 구성하는 기술을 포함한다.&lt;/p>
&lt;ul>
&lt;li>정점(node): 동일한 수준의 정책을 포함하는 컴포넌트&lt;/li>
&lt;li>간선(edge): 컴포넌트 사이의 의존성&lt;/li>
&lt;/ul>
&lt;p>좋은 아키텍처라면 각 컴포넌트를 연결할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계해야 한다.&lt;/p>
&lt;h2 id="수준">수준&lt;/h2>
&lt;p>수준(level)은 &lt;strong>입력과 출력까지의 거리&lt;/strong>로 정의할 수 있다.&lt;/p>
&lt;p>시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아지며, 입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치한다.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/19/img.png"
width="1400"
height="738"
srcset="https://codemario318.github.io/post/clean-architecture/19/img_hu0cccb83cda5e1cfc944d8b5720341535_354495_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/19/img_hu0cccb83cda5e1cfc944d8b5720341535_354495_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="189"
data-flex-basis="455px"
>&lt;/p>
&lt;p>간단한 암호화 프로그램의 설계 예시 처럼 프로그램을 제대로 설계했다면 소스 코드 의존성은 곧은 점선처럼 표시되어야 한다.&lt;/p>
&lt;p>&lt;code>Translate&lt;/code> 컴포넌트는 입력과 출력에서 가장 멀리 떨어져 있으므로 최고 수준의 컴포넌트이다.&lt;/p>
&lt;p>굽은 실선은 데이터의 흐름을 나타내는데, 보는 것과 같이 데이터 흐름과 소스 코드 의존성이 항상 같은 방향을 가리키지는 않는다.&lt;/p>
&lt;ul>
&lt;li>소스 코드 의존성은 그 수준에 따라 결합되어야 하며, 데이터 흐름을 기준으로 결합되어서는 안된다는 것이다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">function encrypt() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while(true)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> writeChar(translate(readChar()));
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위와 같은 예시는 고수준인 &lt;code>encrypt&lt;/code> 함수가 저수준인 &lt;code>readChar&lt;/code>, &lt;code>writeChar&lt;/code> 함수에 의존하기 때문에 잘못된 아키텍처이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/19/img_1.png"
width="672"
height="560"
srcset="https://codemario318.github.io/post/clean-architecture/19/img_1_hu3792ba83091153c640e2b5a2eab1f46a_335401_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/19/img_1_hu3792ba83091153c640e2b5a2eab1f46a_335401_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="288px"
>&lt;/p>
&lt;p>&lt;code>Encrypt&lt;/code> 클래스, &lt;code>CharWriter&lt;/code>와 &lt;code>CharReader&lt;/code> 인터페이스를 둘러싸고 있는 점선으로 된 경계로 묶인 영역이 이 시스템에서 최고 수준의 구성요소이며, 횡단하는 의존성은 모두 경계 안쪽으로 향한다.&lt;/p>
&lt;p>입력과 출력에 변화가 생기더라도 암호화 정책은 거의 영향을 받지 않기 때문에, 고수준의 암호화 정책을 저수준의 입력/출력 정책으로 부터 분리시켜 암호화 정책을 더 넓은 맥락에서 사용할 수 있다.&lt;/p>
&lt;hr>
&lt;p>정책을 컴포넌트로 묶는 기준은 정책이 변경되는 방식에 달려있다.&lt;/p>
&lt;p>단일 책임 원칙(SRP)과 공통 폐쇄 원칙(CCP)에 따르면 동일한 이유로 동일한 시점에 변경되는 정책은 함께 묶인다.&lt;/p>
&lt;ul>
&lt;li>고수준 정책: 입력/출력에서부터 멀리 떨어진 정책
&lt;ul>
&lt;li>저수준 정책에 비해 덜 빈번하게 변경된다.&lt;/li>
&lt;li>보다 중요한 이유로 변경된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>저수준 정책: 입력과 출력에 가까운 정책
&lt;ul>
&lt;li>더 빈빈하게 변경된다.&lt;/li>
&lt;li>긴급성을 요하며, 덜 중요한 이유로 변경된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이처럼 소스 코드 의존성 방향이 고수준 정책을 향할 수 있도록 정책을 분리했다면 변경의 영향도를 줄일 수 있다.&lt;/p>
&lt;ul>
&lt;li>시스템의 최저 수준에서 중요하지 않지만 긴급한 변경이 발생하더라도, 중요한 수준에 미치는 영향이 거의 없게 된다.&lt;/li>
&lt;/ul>
&lt;p>이는 저수준 컴포넌트가 고수준 컴포넌트에 플러그인되어야 한다는 관점으로도 바라볼 수 있다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>정책을 분리하는 것은 단일 책임 원칙, 개방 폐쇄 원칙, 공통 폐쇄 원칙, 의존성 역전 원칙, 안정된 의존성 원칙, 안정된 추상화 원칙을 모두 포함한다.&lt;/p></description></item><item><title>18. 경계 해부학</title><link>https://codemario318.github.io/post/clean-architecture/18/</link><pubDate>Thu, 21 Mar 2024 15:36:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/18/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/18/cover.png" alt="Featured image of post 18. 경계 해부학" />&lt;p>시스템 아키텍처는 일련의 소프트웨어 퀌포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의된다.&lt;/p>
&lt;p>이러한 경계는 다양한 형태로 나타난다.&lt;/p>
&lt;h2 id="경계-횡단하기">경계 횡단하기&lt;/h2>
&lt;p>&amp;lsquo;런타임에 경계를 횡단한다&amp;rsquo;는 의미는 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일에 불과하다.&lt;/p>
&lt;p>적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다.&lt;/p>
&lt;ul>
&lt;li>소스 코드 모듈 하나의 변경으로 읜존하는 다른 소스 코드 모듈을 변경하거나, 다시 컴파일해서 새로 배포해야 할 지도 모르기 때문&lt;/li>
&lt;/ul>
&lt;p>경계는 소스 코드 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단으로써 존재한다.&lt;/p>
&lt;h2 id="두려운-단일체">두려운 단일체&lt;/h2>
&lt;p>아키텍처 경계 중 가장 단순하며 흔한 형태는 물리적으로 엄격하게 구분되지 않는 형태다.&lt;/p>
&lt;p>이는 앞서 언급했던 소스 수준 분리 모드로, 함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며 나름의 규칙에 따라 분리되어있는 상태이다.&lt;/p>
&lt;p>배포 관점에서 이는 단일체(monolith)라고 불리는 단일 실행 파일이므로, 외부에서 볼 때(물리적으로) 경계가 밖으로 드러나지는 않는다.&lt;/p>
&lt;p>가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/18/img.png"
width="878"
height="328"
srcset="https://codemario318.github.io/post/clean-architecture/18/img_hu33eeba12431c5bf1806d35e4e7b8ce12_88436_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/18/img_hu33eeba12431c5bf1806d35e4e7b8ce12_88436_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="267"
data-flex-basis="642px"
>&lt;/p>
&lt;p>이 경우 런타임 의존성과 컴파일타임 의존성은 모두 저수준 컴포넌트에서 고수준 컴포넌트로 향한다.&lt;/p>
&lt;hr>
&lt;p>고수준 클라이언트가 저수준 서비스를 호출해야 한다면 동적 다형성을 사용하여 제어흐름과는 반대 방향으로 의존성을 역전시킬 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/18/img_1.png"
width="886"
height="326"
srcset="https://codemario318.github.io/post/clean-architecture/18/img_1_hu4203ca497a373869a2b5425ba45e2e20_90287_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/18/img_1_hu4203ca497a373869a2b5425ba45e2e20_90287_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="271"
data-flex-basis="652px"
>&lt;/p>
&lt;p>경계를 횡단할 때 의존성은 모두 고수준 컴포넌트를 향하고 있으며, 데이터 구조의 정의가 호출하는 쪽에 위치한다.&lt;/p>
&lt;hr>
&lt;p>정적 링크된 모노리틱 구조의 실행 파일이라도 규칙적인 방식으로 구조를 분리하면 프로젝트를 개발, 테스트, 배포하는 작업에 큰 도움이 된다.&lt;/p>
&lt;p>단일체에서 컴포넌트간 통신은 전형적인 함수 호출에 지나지 않으므로 매우 빠르고 값싸며, 이러한 이유로 소스 수준에서 결합이 분리되면 경계를 가로지르는 통신은 상당히 빈번할 수 있다.&lt;/p>
&lt;h2 id="배포형-컴포넌트">배포형 컴포넌트&lt;/h2>
&lt;p>아키텍처의 경계가 물리적으로 드러날 수도 있는데 그중 가장 단순한 형태는 동적 링크 라이브러리다.&lt;/p>
&lt;p>이는 배포 수준 결합 분리 모드에 해당하며 컴포넌트를 동적 링크 라이브러리 형태로 배포하면 따로 컴파일하지 않고 곧바로 사용할 수 있는 대신 바이너리와 같이 배포 가능한 형태로 전달된다.&lt;/p>
&lt;p>배포 관점에서 이러한 형태는 단순히 배포 가능한 단위를 좀 더 편리한 형태로 묶으므로, 단일체와 동일하다.&lt;/p>
&lt;ul>
&lt;li>모든 함수가 동일한 프로세서와 주소 공간에 위치하며, 컴포넌트 간 의존성을 관리하는 전략도 동일하다.&lt;/li>
&lt;/ul>
&lt;p>단일체와 마찬가지로 경계를 가로지르는 통신은 함수 호출에 지나지 않으므로 값싸기 때문에, 경계를 가로지르는 통신은 대체로 매우 빈번하다.&lt;/p>
&lt;h2 id="스레드">스레드&lt;/h2>
&lt;p>스레드는 아키텍처 경계도 아니며 배포 단위도 아니다.&lt;/p>
&lt;p>단일체와 배포형 컴포넌트 모두 스레드를 활용할 수 있다.&lt;/p>
&lt;p>스레드는 실행 계획과 순서를 체계화 하는 방법에 가까우며, 모든 스레드가 단 하나의 컴포넌트에 포함될 수도 있고, 분산될 수도 있다.&lt;/p>
&lt;h2 id="로컬-프로세스">로컬 프로세스&lt;/h2>
&lt;p>로컬 프로세스는 이전 언급한 경계보다 훨씬 강한 물리적 형태를 띈다.&lt;/p>
&lt;p>주로 명령행이나 그와 유사한 시스템 호출을 통해 생성되고, 동일한 프로세서 또는 하나의 멀티코어 시스템에 속한 여러 프로세서들에서 실행되지만, 독립된 주소 공간에서 실행된다.&lt;/p>
&lt;p>종종 공유 메모리 파티션을 사용하기도 하지만, 일반적으로는 메모리 보호를 통해 프로세스들이 메모리를 공유하지 못하게 한다.&lt;/p>
&lt;p>대개의 경우 소켓, 메일박스, 메시지 큐와 같이 운영체제에서 제공하는 통신 기능을 이용하여 서로 통신한다.&lt;/p>
&lt;hr>
&lt;p>각 로컬 프로세스는 정적으로 링크된 단일체 이거나 동적으로 링크된 여러개의 컴포넌트로 구성될 수 있다.&lt;/p>
&lt;ul>
&lt;li>정적으로 링크된 단일체
&lt;ul>
&lt;li>여러 모노리틱 프로세스가 같은 컴포넌트들을 가지고 있을 수 있다.&lt;/li>
&lt;li>컴파일하고 정적 링크하는 과정에서 각 컴포넌트의 바이너리가 단일체에 물리적으로 복사되기때문&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>동적으로 링크된 배포형 컴포넌트
&lt;ul>
&lt;li>동적으로 링크된 배포형 컴포넌트들을 서로 공유할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>로컬 프로세스는 컴포넌트 간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트로 구성되므로 일종의 최상위 컴포넌트로 볼 수 있다.&lt;/p>
&lt;p>로컬 프로세스 간 분리 전략은 단일체나 바이너리 컴포넌트의 경우와 동일하다.&lt;/p>
&lt;p>소스 코드 의존성은 고수준 컴포넌트를 향해야하므로 로컬 프로세스에서는 고수준 프로세스의 소스 코드가 저수준 프로세스의 이름, 물리 주소, 레지스트리 조회 키를 절대로 포함해서는 안된다.&lt;/p>
&lt;p>로컬 프로세스 경계를 지나는 통신에는 운영체제 호출, 데이터 마샬링, 언마샬링, 프로세스 간 문맥 교환 등이 있으며, 이들은 제법 비싼 작업이므로 통신이 너무 빈번하게 이뤄지지 않도록 신중하게 제한해야한다.&lt;/p>
&lt;h2 id="서비스">서비스&lt;/h2>
&lt;p>물리적인 형태를 띠는 가장 강력한 경계는 서비스다.&lt;/p>
&lt;p>서비스는 프로세스로, 일반적으로 명령행 또는 그와 동등한 시스템 호출을 통해 구동된다.&lt;/p>
&lt;p>서비스들은 모든 통신이 네트워크를 통해 이뤄진다고 가정하므로 자신의 물리적 위치에 구애받지 않는다.&lt;/p>
&lt;p>서비스 경계를 지나는 통신은 함수 호출에 매우 느리므로 가능하다면 빈번하게 통신하는 일을 피해야 하며, 지연(latency)에 따른 문제를 고수준에서 처리할 수 있어야 한다.&lt;/p>
&lt;p>이를 제외하고는 로컬 프로세스에 적용한 규칙이 서비스에 적용된다.&lt;/p>
&lt;p>저수준 서비스는 반드시 고수준 서비스에 &lt;strong>플러그인&lt;/strong>되어야하며, 고수준 서비스의 소스 코드에는 저수준 서비스를 특정 짓는 어떤 물리적인 정보(URI 등)도 절대로 포함해서는 안된다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.&lt;/p>
&lt;p>실제로 서비스는 상호작용하는 일련의 로컬 프로세스 퍼사드에 불과할 때가 많다.&lt;/p>
&lt;p>또한 개별 서비스 또는 로컬 프로세스는 거의 언제나 소스 코드 컴포넌트로 구성된 단일체이거나, 동적으로 링크된 배포형 컴포넌트의 집합이다.&lt;/p>
&lt;p>즉, 한 시스템 안에서도 통신이 빈번한 로컬 경계와 지연을 중요하게 고려해야 하는 경계가 혼합되어 있음을 의미한다.&lt;/p></description></item><item><title>17. 경계: 선 긋기</title><link>https://codemario318.github.io/post/clean-architecture/17/</link><pubDate>Wed, 20 Mar 2024 21:36:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/17/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/17/cover.png" alt="Featured image of post 17. 경계: 선 긋기" />&lt;p>소프트웨어 아키텍처는 선을 긋는 기술이며, 이러한 선을 &lt;strong>경계&lt;/strong>(Boundary)라고 부른다.&lt;/p>
&lt;p>경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 소소가 반대편에 있는 요소를 알지 못하도록 막는다.&lt;/p>
&lt;p>이 중 초기에 그려지는 선은 &lt;strong>가능한 한 오랫동안 결정을 연기&lt;/strong>시키기고, 결정이 핵심적인 업무 로직을 &lt;strong>오염시키지 못하게 만들려는 목적&lt;/strong>으로 쓰인다.&lt;/p>
&lt;p>아키텍트의 목표는 시스템을 만들고 유지하는 데 드는 자원을 최소화 하는 것인데, 효율을 떨어뜨리는 요인은 &lt;strong>결합&lt;/strong>(Coupling)이며, &lt;strong>너무 일찍 내려진 결정에 따른 결합은 더 큰 영향&lt;/strong>을 미친다.&lt;/p>
&lt;p>너무 일찍 내려진 결정은 시스템의 업무 요구사항, 즉 유스케이스와 아무런 관련이 없는 결정을 의미한다.&lt;/p>
&lt;ul>
&lt;li>프레임워크&lt;/li>
&lt;li>데이터베이스&lt;/li>
&lt;li>웹 서버&lt;/li>
&lt;li>유틸리티 라이브러리&lt;/li>
&lt;li>의존성 주입에 대한 결정 등&lt;/li>
&lt;/ul>
&lt;p>좋은 시스템 아키텍처란 유스케이스와 아무런 관련이 없는 결정에 의존하지 않아 이러한 결정이 부수적이며, 연기할 수 있는 아키텍처다.&lt;/p>
&lt;p>경계선을 긋는 행위는 결정을 늦추고 연기하는 데 도움이되며, 궁극적으로는 시간을 엄청나게 절약해주었으며, 골치를 썩지 않게 해준다.&lt;/p>
&lt;h2 id="어떻게-선을-그을까-언제-그을까">어떻게 선을 그을까? 언제 그을까?&lt;/h2>
&lt;p>관련이 있는 것과 없는 것 사이에 선을 긋는다.&lt;/p>
&lt;ul>
&lt;li>GUI는 업뮤 규칙과는 관련 없기 때문에, 둘 사이에는 반드시 선이 있어야한다.&lt;/li>
&lt;li>데이터베이스는 GUI와는 고나련이 없으므로, 둘 사이에는 반드시 선이 있어야한다.&lt;/li>
&lt;li>데이터베이스는 업무 규칙과 관련이 없으므로, 둘 사이에도 선이 있어야한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>데이터베이스는 업무 규칙과 서로 떼어놓을 수 없는 관계라고 배운 사람이 많으며, 심지어 업무 규칙이 구체화된 것이 데이터베이스라고 확신하는 사람도 더러 있지만 이는 잘못된 생각이다.&lt;/p>
&lt;p>업무 규칙은 데이터를 가져오고 저장할 때 사용할 수 있는 함수 집합이 있다는 사실이 전부여야한다.&lt;/p>
&lt;p>이러한 함수 집합을 통해 데이터베이스를 인터페이스 뒤로 숨길 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/17/img.png"
width="407"
height="281"
srcset="https://codemario318.github.io/post/clean-architecture/17/img_hu673cbb09eeb85c8e13222d62fdbc3a4e_65890_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/17/img_hu673cbb09eeb85c8e13222d62fdbc3a4e_65890_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클래스 경계선"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;p>&lt;code>DatabaseAccess&lt;/code>에서 출발하는 화살표는 클래스로부터 바깥쪽으로 향하는데 이는 &lt;code>DatabaseAccess&lt;/code>가 존재하는 클래스는 없다는 의미이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/17/img_1.png"
width="401"
height="283"
srcset="https://codemario318.github.io/post/clean-architecture/17/img_1_hub12dd706ba5018e7ec9bc226af343837_66166_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/17/img_1_hub12dd706ba5018e7ec9bc226af343837_66166_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="컴포넌트 경계선"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="340px"
>&lt;/p>
&lt;p>&lt;code>DatabaseInterface&lt;/code> 클래스는 &lt;code>BusinessRules&lt;/code> 컴포넌트에 속하며, &lt;code>DatabaseAccess&lt;/code> 클래스는 &lt;code>Database&lt;/code> 컴포넌트에 속하므로, &lt;code>Database&lt;/code>는 &lt;code>BusinessRules&lt;/code>에 대해 알고있지만, &lt;code>BusinessRules&lt;/code>은 &lt;code>Database&lt;/code>에 관해 알지 못한다.&lt;/p>
&lt;p>따라서 &lt;code>BusinessRules&lt;/code>에게 있어 &lt;code>Database&lt;/code>는 문제가 되지 않지만, &lt;code>Database&lt;/code>는 &lt;code>BusinessRules&lt;/code> 없이는 존재할 수 없다.&lt;/p>
&lt;hr>
&lt;p>&lt;code>Database&lt;/code> 컴포넌트는 &lt;code>BusinessRules&lt;/code>가 만들어 낸 호출을 데이터베이스의 쿼리 언어로 변환하는 코드를 담고 있으며, 이 변환 코드가 &lt;code>BusinessRules&lt;/code>를 알고 있는 것이다.&lt;/p>
&lt;p>두 컴포넌트 사이에 경계선, 화살표의 방향이 &lt;code>BusinessRules&lt;/code>를 향하도록 만들었기 때문에 어떤 종류의 데이터베이스도 사용할 수 있게된다.&lt;/p>
&lt;p>따라서 데이터베이스에 대한 결정을 연기할 수 있으며, 데이터베이스를 결정하기에 앞서 업무 규칙을 먼저 작성하고 테스트하는 데 집중할 수 있다.&lt;/p>
&lt;h2 id="입력과-출력은">입력과 출력은?&lt;/h2>
&lt;p>입력과 출력은 중요하지않다.&lt;/p>
&lt;p>시스템의 행위를 입출력이 지닌 행위적 측면에서 생각하는 경향이 있는데, 이러한 입출력 뒤에는 모델(데이터 구조와 함수로 구성된 정교한 집합)이 존재한다는 사실을 잊는다.&lt;/p>
&lt;p>이러한 모델은 GUI가 없이도 동작할 수 있으므로 중요하지 않고, 실제로 중요한 것은 &lt;strong>업무 규칙&lt;/strong>이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/17/img_2.png"
width="401"
height="275"
srcset="https://codemario318.github.io/post/clean-architecture/17/img_2_huca1b9f1dde324acc9010f81287c21632_63448_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/17/img_2_huca1b9f1dde324acc9010f81287c21632_63448_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="349px"
>&lt;/p>
&lt;p>&lt;code>GUI&lt;/code> 컴포넌트는 &lt;code>BusinessRules&lt;/code> 컴포넌트에게 의존하기 때문에 경계선으로 분할할 수 있다.&lt;/p>
&lt;p>따라서 &lt;code>GUI&lt;/code>는 다른 종류의 인터페이스로 얼마든지 교체할 수 있으며 &lt;code>BusinessRules&lt;/code>에 끼치는 영향은 없다.&lt;/p>
&lt;h2 id="플러그인-아키텍처">플러그인 아키텍처&lt;/h2>
&lt;p>데이터베이스와 GUI에 대해 내린 두 가지 결정을 하나로 합쳐서 보면 컴포넌트 추가와 관련한 일정의 패턴이 만들어진다.&lt;/p>
&lt;p>소프트웨어 개발 기술의 역사는 프러그인을 손쉽게 생성하여, 확장 가능하며 유지보수가 쉬운 시스템 아키텍처를 확립할 수 있게 만드는 방법에 대한 이야기이다.&lt;/p>
&lt;ul>
&lt;li>선택적이거나 또는 수많은 다양한 형태로 구현될 수 있는 나머지 컴포넌트로부터 핵심적인 업무 규칙은 분리되어 있고, 또한 독립적이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/17/img_3.png"
width="411"
height="276"
srcset="https://codemario318.github.io/post/clean-architecture/17/img_3_hu6d5ed14c5677eea0e6c3298e2ee307eb_74568_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/17/img_3_hu6d5ed14c5677eea0e6c3298e2ee307eb_74568_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="148"
data-flex-basis="357px"
>&lt;/p>
&lt;p>위와 같은 설계에서 사용자 인터페이스는 플러그인 형태로 고려되었기에, 수많은 종류의 사용자 인터페이스를 플러그인 형태로 연결할 수 있게 된다.&lt;/p>
&lt;p>데이터베이스도 동일하게 적용할 수 있다.&lt;/p>
&lt;p>GUI, 데이터베이스 등의 교체 작업이 쉬운 작업은 아니고, 업무 규칙 활용을 위해 추가적인 작업도 필요할 수 있지만, 플러그인 구조를 가정한 채 시작함으로써, 이러한 변경 작업을 현실성 있도록 만든다.&lt;/p>
&lt;h2 id="플러그인에-대한-논의">플러그인에 대한 논의&lt;/h2>
&lt;p>시스템을 플러그인 아키텍처로 배치함으로써 변경이 전파될 수 없는 방화벽을 생성할 수 있다.&lt;/p>
&lt;p>경계는 &lt;strong>변경의 축&lt;/strong>(Axis of change)이 있는 지점에 그어진다. 그리고 경계의 한쪽에 위치한 컴포넌트는 경계 반대편의 컴포넌트와는 다른 속도로, 다른 이유로 변경된다.&lt;/p>
&lt;p>따라서 다른 시점에 다른 속도로 변경되는 둘 사이에는 반드시 경계가 필요하다.&lt;/p>
&lt;p>이 역시도 단일 책임 원칙에 해당하며, 단일 책임 원칙은 어디에 경계를 그어야 할지 알려준다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>소프트웨어 아키텍처에서 경계선을 그리려면&lt;/p>
&lt;ol>
&lt;li>
&lt;p>먼저 시스템을 컴포넌트 단위로 분할해야한다.&lt;/p>
&lt;ul>
&lt;li>일부 컴포넌트는 핵심 업무 규칙에 해당한다.&lt;/li>
&lt;li>나머지 컴포넌트는 플러그인으로 핵심 업무와는 직접적인 관련이 없지만 필수 기능을 포함한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>컴포넌트 사이의 화살표가 핵심 업무를 향하도록 컴포넌트의 소스를 배치한다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>이는 의존성 역전 원칙과 안정된 추상화 원칙을 응용한 것이며, 의존성의 화살표는 저수준 세부사항에서 고수준의 추상화를 향하도록 배치된다.&lt;/p></description></item><item><title>16. 독립성</title><link>https://codemario318.github.io/post/clean-architecture/16/</link><pubDate>Wed, 13 Mar 2024 14:51:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/16/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/16/cover.png" alt="Featured image of post 16. 독립성" />&lt;p>좋은 아키텍처는 다음을 지원해야한다.&lt;/p>
&lt;ul>
&lt;li>시스템의 유스케이스&lt;/li>
&lt;li>시스템의 운영&lt;/li>
&lt;li>시스템의 개발&lt;/li>
&lt;li>시스템의 배포&lt;/li>
&lt;/ul>
&lt;h2 id="유스케이스">유스케이스&lt;/h2>
&lt;p>시스템의 아키텍처는 시스템의 의도를 지원해야 한다는 뜻이다.&lt;/p>
&lt;p>실제로 아키텍트의 최우선 관심사는 유스케이스이며, 아키텍처에서도 유스케이스가 최우선이다. 따라서 아키텍처는 반드시 유스케이스를 지원해야한다.&lt;/p>
&lt;p>아키텍처는 시스템의 행위 차제에는 큰 영향을 주지 않으며, 행위와 관련하여 아키텍처가 열어둘 수 있는 선택사항의 거의 없다.&lt;/p>
&lt;p>하지만, 아키텍처의 시스템의 행위에 대한 직접적인 영향력과 별개로 좋은 아키텍처는 시스템의 행위를 지원할 수 있다.&lt;/p>
&lt;ul>
&lt;li>행위를 명확히 하고 외부로 드러낸다.&lt;/li>
&lt;li>이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만든다.&lt;/li>
&lt;/ul>
&lt;p>좋은 아키텍처를 가진다면 시스템의 유스케이스는 시스템 구조 자체에서 한눈에 드러난다.&lt;/p>
&lt;ul>
&lt;li>이러한 시스템의 &lt;strong>행위&lt;/strong>는 &lt;strong>일급 요소 first-class element&lt;/strong>이며 시스템의 최상위 수준에서 알아볼 수 있으므로, 개발자가 일일이 찾아 헤매이지 않아도 된다.&lt;/li>
&lt;li>이들 요소는 클래스이거나 함수 또는 모듈러서 아키텍처 내에서 핵심적인 자리를 차지할 뿐만 아니라, 자신의 기능을 분명하게 설명하는 이름을 가져야한다.&lt;/li>
&lt;/ul>
&lt;h2 id="운영">운영&lt;/h2>
&lt;p>시스템의 운영 지원 관점에서 볼 때 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡는다.&lt;/p>
&lt;p>&lt;strong>예시&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>시스템이 초당 100,000명의 고객을 처리해야 한다면, 아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞은 처리량과 응답시간을 보장해야 한다.&lt;/li>
&lt;li>시스템에서 수 밀리초 안에 3차원의 빅데이터 테이블에 질의해야 한다면, 반드시 이러한 운영 작업을 허용할 수 있는 형태로 아키텍처를 구조화해야한다.&lt;/li>
&lt;/ul>
&lt;p>예시와 같이 &lt;strong>형태를 지원&lt;/strong>한다는 말은 다양한 의미를 지닌다.&lt;/p>
&lt;ul>
&lt;li>시스템의 처리 요소를 일련의 작은 서비스들로 배열하여, 서로 다른 많은 서버에서 병렬로 실행할 수 있는 시스템&lt;/li>
&lt;li>경량의 수많은 스레드가 단일 프로세서에서 같은 주소 공간을 공유하는 시스템&lt;/li>
&lt;li>독립된 주소 공간에서 실행되는 소수의 프로세스만으로도 충분한 시스템&lt;/li>
&lt;li>단일 프로세스에서 실행되는 단순한 모노리틱 프로그램&lt;/li>
&lt;/ul>
&lt;p>위와 같은 운영 관점의 아키텍처 결정은 뛰어난 이키텍트라면 열어두어야 하는 선택 사항 중의 하나다.&lt;/p>
&lt;p>아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.&lt;/p>
&lt;h2 id="개발">개발&lt;/h2>
&lt;p>아키텍처는 개발환경을 지원하는데 있어 핵심적인 역할을 수행한다.&lt;/p>
&lt;blockquote>
&lt;p>시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.&lt;br>
- 콘웨이 법칙 -&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>많은 팀으로 구성되며 관심사가 다양한 조직에서 어떤 시스템을 개발해야 한다면, 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 팀들이 서로 방해하지 않도록 해야 한다.&lt;/li>
&lt;li>잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할 할 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="배포">배포&lt;/h2>
&lt;p>아키텍처는 배포 용이성(&lt;strong>즉각적인 배포 immediate deployment&lt;/strong>)을 결정하는 데 중요한 역할을 한다.&lt;/p>
&lt;p>좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.&lt;/p>
&lt;ul>
&lt;li>수십 개의 작은 설정 스크립트나 속성 파일을 약간씩 수정하는 방식을 사용하지 않는다.&lt;/li>
&lt;li>꼭 필요한 디렉터리나 파일을 수작업으로 생성하게 내버려 두지 않는다.&lt;/li>
&lt;/ul>
&lt;p>이러한 아케텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다.&lt;/p>
&lt;p>마스터 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야 한다.&lt;/p>
&lt;h2 id="선택사항-열어놓기">선택사항 열어놓기&lt;/h2>
&lt;p>좋은 아키텍처는 컴포넌트 구조와 관련된 이 관심사들 사이에서 균형을 맞추고, 각 관심사 모두를 만족시켜야 하지만, 현실에서는 이러한 균형을 잡기가 매우 어렵다.&lt;/p>
&lt;ul>
&lt;li>모든 유스케이스를 알 수는 없다.&lt;/li>
&lt;li>운영하는 데 따르는 제약사항, 팀 구조, 배포 요구사항을 알지 못한다.&lt;/li>
&lt;li>이러한 사항들을 알고 있더라도, 시스템이 생명주기의 단계를 하나씩 거쳐감에 따라 이 사항들도 반드시 변한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>도달하려는 목표는 뚜렷하지 않을 뿐만 아니라 시시각각 변한다.&lt;/strong>&lt;/p>
&lt;p>이러한 변화속에서도 몇몇 아키텍처 원칙을 구현하는 비용이 비교적 비싸지 않으며, 이를 통해 관심사들 사이에서 균형을 잡는데 도움이 된다는 사실은 변하지 않는다.&lt;/p>
&lt;ul>
&lt;li>균형을 맞추려는 목표점을 명확히 그릴 수 없는 경우에도 관심사들 사이에서 균형을 잡는 데 도움이 된다.&lt;/li>
&lt;li>시스템을 제대로 격리된 컴포넌트 단위로 분할할 때 도움이 된다.&lt;/li>
&lt;li>이를 통해 선택사항을 가능 한 많이, 가능한 오랫동안 열어 둘 수 있게 해준다.&lt;/li>
&lt;/ul>
&lt;p>좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.&lt;/p>
&lt;h2 id="계층-결합-분리">계층 결합 분리&lt;/h2>
&lt;p>UI, 애플리케이션 자체와 밀접한 업무 규칙과, 도메인에 밀접한 업무 규칙, 기술적인 세부사항 등은 각자 다른 속도로, 다른 이유로 변경되므로 서로 분리하고, 독립적으로 변경할 수 있도록 만들어야만 한다.&lt;/p>
&lt;p>업무 규칙은 그 자체가 애플리케이션과 밀접한 관련이 있거나, 혹은 더 범용적일 수 있는데, 아키텍트는 이들을 시스템의 나머지 부분으로부터 분리하여 독립적으로 변경할 수 있도록 해야한다.&lt;/p>
&lt;ul>
&lt;li>입력 필드 유효성 검사는 애플리케이션 자체와 밀접하게 관련된 업무 규칙이다.&lt;/li>
&lt;li>계좌의 이자 계산이나 재고품 비교는 업무 도메인에 더 밀접하게 연관된 업무 규칙이다.&lt;/li>
&lt;/ul>
&lt;p>이러한 계층의 예로는 UI, 애플리케이션에 특화된 업무 규칙, 애플리케이션과는 독립접인 업무 규칙, 데이터베이스와 같은 기술적인 세부사항등이 있다.&lt;/p>
&lt;h2 id="유스케이스-결합-분리">유스케이스 결합 분리&lt;/h2>
&lt;p>유스케이스 자체도 서로 다른 이유로 변경될 수 있다.&lt;/p>
&lt;ul>
&lt;li>예) 주문 입력 시스템의 주문 추가 유스케이스와 주문 삭제 유스케이스&lt;/li>
&lt;/ul>
&lt;p>유스케이스는 시스템의 수평적인 계층을 가르지르도록 자른 수직으로 좁다란 조각이기도 하다.&lt;/p>
&lt;ul>
&lt;li>각 유스케이스는 UI의 일부, 애플리케이션 특화 업무 규칙의 일부, 애플리케이션 독립적 업무 규칙의 일부 데이터베이스 기능의 일부 를 사용한다.&lt;/li>
&lt;/ul>
&lt;p>따라서 시스템을 수평적 계층으로 분할하면서 동시에 해당 계층을 가로지르는 얇은 수직적인 유스케이스로 시스템을 분할할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/16/img.png"
width="725"
height="247"
srcset="https://codemario318.github.io/post/clean-architecture/16/img_hu9d481b337dae54d8696707eddc9309ec_159985_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/16/img_hu9d481b337dae54d8696707eddc9309ec_159985_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="293"
data-flex-basis="704px"
>&lt;/p>
&lt;p>이와 같이 수직, 수평 결합을 동시에 분리하여 시스템의 맨 아래 계층까지 수직으로 내려가며 유스케이스들이 각 계층에서 서로 겹치지 않게 한다.&lt;/p>
&lt;p>서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있다.&lt;/p>
&lt;p>또한 유스케이스를 뒷받침하는 서로 다른 관점(aspect)을 사용하게 되면, 새로운 유스케이스를 추가하더라도 기존 유스케이스에 영향을 주는 일은 거의 없을 것이다.&lt;/p>
&lt;h2 id="개발-독립성">개발 독립성&lt;/h2>
&lt;p>컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다.&lt;/p>
&lt;p>기능 팀, 컴포넌트 팀, 계층 팀, 혹은 다른 형태의 팀이라도, 계층과 유스케이스의 결합이 분리되는 한 시스템의 아키텍처는 그 팀 구조를 뒷받침해 줄 것이다.&lt;/p>
&lt;h2 id="배포-톡립성">배포 톡립성&lt;/h2>
&lt;p>유스케이스와 계층의 결합이 분리되면 배포 측면에서도 고도의 유연성이 생긴다.&lt;/p>
&lt;p>결합을 제대로 분리했다면 운영 중인 시스템에서도 계층과 유스케이스를 교체할 수 있다.&lt;/p>
&lt;h2 id="가짜-중복">가짜 중복&lt;/h2>
&lt;p>아키텍트는 중복에 대한 공포로부터 발생하는 함정에 빠지곤 한다.&lt;/p>
&lt;p>소프트웨어에서 중복은 일반적으로 나쁜 것이나, 중복에도 여러 종류가 있다.&lt;/p>
&lt;ul>
&lt;li>진짜 중복
&lt;ul>
&lt;li>인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가짜 중복: 거짓된 또는 우발적인 중복
&lt;ul>
&lt;li>중복으로 보이는 두 코드 영역이 각자의 경로로 발전한다면(서로 다른 속도와 다른 이유로 변경된다면) 이 코드는 중복이 아니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>의도적으로 만든 중복(비슷하지만 다른 방향으로 발전할 것이 예상되는)우발적 중복을 통합한다면 나중에 코드를 다시 분리하느라 큰 수고를 감수해야 한다.&lt;/p>
&lt;p>유스케이스를 수직으로 분리할 때 이러한 문제와 마주치는 경우가 많으므로, 중복이 진짜 중복인지 확인하고 통합해야한다.&lt;/p>
&lt;p>계층을 수평으로 분리하는 경우, 특정 데이터베이스 레코드의 데이터 구조가 특정 화면의 데이터 구조와 상당히 비슷한 경우를 자주 볼 수 있는데, 이때 데이터베이스 레코드와 동일한 형태의 뷰 모델을 만들어서 각 항목을 복사하는 방식을 선택해야한다.&lt;/p>
&lt;h2 id="결합-분리-모드">결합 분리 모드&lt;/h2>
&lt;p>위와 같이 결합을 분리하면 운영 관점에서 여러가지 장점을 살펴볼 수 있다.&lt;/p>
&lt;p>유스케이스에서 서로 다른 관점이 분리되었다면,&lt;/p>
&lt;ul>
&lt;li>높은 처리량을 보장해야 하는 유스케이스와 낮은 처리량으로도 충분한 유스케이스는 이미 분리되어 있을 가능성이 높다.&lt;/li>
&lt;li>UI와 데이터베이스가 업무 규칙과 분리되어 있다면, UI와 데이터베이스는 업무 규칙과는 다른 서버에서 실행될 수 있다.&lt;/li>
&lt;li>높은 대역폭을 요구하는 유스케이스는 여러 서버로 복제하여 실행할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>유스케이스를 위해 수행하는 그 작업들(분리된 것들)은 운영에도 도움이 될 수 있다.&lt;/p>
&lt;p>운영 측면에서 이점을 살리기 이해선 결합을 분리할 때 적절한 모드를 선택해야 한다.&lt;/p>
&lt;ul>
&lt;li>분리된 컴포넌트를 서로 다른 서버에서 실행해야 하는 상황: MSA 등&lt;/li>
&lt;/ul>
&lt;p>때때로는 컴포넌트를 서비스 수준까지도 분리해야 한다.&lt;/p>
&lt;p>좋은 아키텍처는 선택권을 열어둔다는 말에서 결합 분리 모드는 이러한 선택지 중 하나다.&lt;/p>
&lt;p>계층과 유스케이스의 결합을 분리하는 방법은 다양하다.&lt;/p>
&lt;ul>
&lt;li>소스 수준 분리 모드
&lt;ul>
&lt;li>소스 코드 모듈 사이의 의존성을 제어할 수 있다.&lt;/li>
&lt;li>하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만들 수 있다.&lt;/li>
&lt;li>모노리틱 구조&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>배포 수준 분리 모드
&lt;ul>
&lt;li>&lt;code>.jar&lt;/code>, &lt;code>DLL&lt;/code>, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있다.&lt;/li>
&lt;li>소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있다.&lt;/li>
&lt;li>많은 컴포넌트가 같은 주소 공간에 상주하며, 단순한 함수 호출을 통해 통신할 수 있다.&lt;/li>
&lt;li>어떤 컴포넌트는 동일한 프로세스의 다른 프로세스에 상주하고, 프로세스 간 통신, 소켓, 공유 메모리를 통해 통신할 수 있다.&lt;/li>
&lt;li>결합이 분리된 컴포넌트가 독립적으로 배포할 수 있는 단위로 분할되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서비스 수준 분리 모드
&lt;ul>
&lt;li>의존하는 수준을 데이터 구조 단위까지 낮추고, 네트워크 패킷을 통해서만 통신하도록 만들 수 있다.&lt;/li>
&lt;li>모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적이게 된다.&lt;/li>
&lt;li>마이크로서비스, 서비스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>프로젝트 초기 단계는 어떤 모드가 최선인지 알기 어려우며, 프로젝트가 성숙해갈수록 최적인 모드가 달라질 수 있다.&lt;/p>
&lt;p>좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도,이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장하고, 또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 한다.(반대도 마찬가지)&lt;/p>
&lt;p>좋은 아키텍처는 결합 분리 모드를 선택사항으로 남겨두어서 배포 규모에 다라 가장 적합한 모드를 선택해 사용할 수 있게 만들어 준다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영할 수 있도록 만들어야한다.&lt;/p></description></item><item><title>15. 아키텍처란?</title><link>https://codemario318.github.io/post/clean-architecture/15/</link><pubDate>Tue, 12 Mar 2024 15:37:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/15/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/15/cover.png" alt="Featured image of post 15. 아키텍처란?" />&lt;p>&lt;strong>소프트웨어 아키텍트란?&lt;/strong>&lt;br>
소프트웨어 아키텍트는 프로그래머이며, 앞으로도 계속 프로그래머로 남아야하므로, 고수준 문제에만 집중하여 코드와 동떨어져서는 안 된다.&lt;/p>
&lt;p>소프트웨어 아키텍트는 개발에 참여하며 나머지 팀원들이 생산성을 극대화할 수 있는 설계를 하도록 방향을 이끌어준다.&lt;/p>
&lt;p>따라서 프로그래밍을 작업에 계속 참여하며 문제를 직접 경험하고 이를 통해 다른 프로그래머를 지원하는 작업을 수행해야한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>소프트웨어 시스템의 아키텍처란?&lt;/strong>&lt;/p>
&lt;p>시스템을 구축했던 사람들이 만들어낸 시스템의 형태로 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라 정해진다.&lt;/p>
&lt;p>이러한 시스템 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다.&lt;/p>
&lt;blockquote>
&lt;p>개발, 배포, 운영, 유지보수를 용이하게 만들기 위해서는 가능한 한 많은 선택지를, 가능한 한 오래 남겨두는 전략을 따라야한다.&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>시스템 아키텍처는 시스템의 동작 여부와는 거의 관련이 없다.&lt;/p>
&lt;ul>
&lt;li>형편없는 아키텍처를 갖춤 시스템도 수없이 많지만, 그런데로 잘 동작한다.&lt;/li>
&lt;li>이러한 경우 대체로 운영에서는 문제가 없지만 배포, 유지보수, 계속되는 개발 과정에서 어려움을 겪는다.&lt;/li>
&lt;/ul>
&lt;p>시스템 아키텍처가 시스템이 제대로 동작하는 것과는 직접적으로 관련이 없지만, 시스템이 제대로 동작하도록 &lt;strong>지원&lt;/strong>한다(간접적).&lt;/p>
&lt;ul>
&lt;li>시스템을 쉽게 이해할 수 있게 한다.&lt;/li>
&lt;li>쉽게 개발할 수 있게 한다.&lt;/li>
&lt;li>쉽게 유지보수할 수 있게 한다.&lt;/li>
&lt;li>쉽게 배포하게 해준다.&lt;/li>
&lt;/ul>
&lt;p>아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다. 궁극적으로 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.&lt;/p>
&lt;h2 id="개발">개발&lt;/h2>
&lt;p>시스템 아키텍처는 개발팀(들)이 시스템을 쉽게 개발할 수 있도록 뒷받침해야만 한다.&lt;/p>
&lt;p>&lt;strong>팀 구조&lt;/strong>&lt;/p>
&lt;p>팀 구조가 다르다면 아키텍처 관련 결정에서도 차이가 난다.&lt;/p>
&lt;ul>
&lt;li>작은 규모
&lt;ul>
&lt;li>팀 규모가 작아 상위 구조로 인한 장애물이 없기를 바라기 때문에 아키텍처 없이 시작하는 경우가 많다.&lt;/li>
&lt;li>잘 정의된 컴포넌트나 인터페이스가 없더라도 서로 효율적으로 협력하여 모노리틱 시스템을 개발할 수 있다.&lt;/li>
&lt;li>개발 초기에는 아키텍처 관련 제약들이 오히려 방해가 된다고 여길 가능성이 높다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>큰 규모
&lt;ul>
&lt;li>다른 요소를 고려하지 않는다면 아키텍처는 팀별 단일 컴포넌트(큰 관심사 별 컴포넌트)로 각각 발전될 가능성이 높다.&lt;/li>
&lt;li>팀별 단일 컴포넌트 아키텍처는 시스템을 배포, 운영, 유지보수하는 데 최적은 아닐 확률이 높다.&lt;/li>
&lt;li>시스템을 신뢰할 수 있고 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리하지 않으면 개발이 진척되지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="배포">배포&lt;/h2>
&lt;p>배포 비용이 높을수록 시스템의 유용성은 떨어진다.&lt;/p>
&lt;p>따라서 소프트웨어 아키텍처는 시스템을 단 한번에 쉽게 배포할 수 있도록 만드는 데 그 목표를 두어야 한다.&lt;/p>
&lt;ul>
&lt;li>초기 개발 단계에서는 배포 전략을 거의 고려하지 않기 때문에 개발하기는 쉬워도 배포하기는 어려운 아키텍처가 만들어진다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>마이크로서비스 아키텍처 micro-service architecture&lt;/strong>&lt;/p>
&lt;p>컴포넌트 경계가 매우 뚜렷해지고, 인터페이스가 대체로 안정화되므로 시스템을 매우 쉽게 개발할 수 있다.&lt;/p>
&lt;p>하지만 늘어난 수많은 마이크로서비스로인해 서로 연결하기 위해 설정하고 작동 순서를 결정하는 과정에서 오작동이 발생할 원천이 스며들어 배포하기 어려워진다.&lt;/p>
&lt;hr>
&lt;p>아키텍트가 배포 문제를 초기에 고려했다면, 더 적은 서비스를 사용하고, 서비스 컴포넌트와 프로세스 수준의 컴포넌트를 하이브리드 형태로 융합하며, 좀 더 통합된 도구를 사용해 상호 연결을 관리했을 것이다.&lt;/p>
&lt;h2 id="운영">운영&lt;/h2>
&lt;p>아키텍처가 시스템 운영에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향보다는 &lt;strong>덜 극적&lt;/strong>이다.&lt;/p>
&lt;p>운영에서 겪는 대다수의 어려움은 단순히 하드웨어를 더 투입해서 해결할 수 있다.&lt;/p>
&lt;ul>
&lt;li>소프트웨어 아키텍처가 비효율적이라면 스토리자와 서버를 추가하는 것만으로 제대로 동작하도록 만들 수 있을 때가 많다.&lt;/li>
&lt;li>하드웨어는 값싸고 인력은 비싸다.&lt;/li>
&lt;/ul>
&lt;p>운영 관점에서 소프트웨어 아키텍처는 비용 공식 관점에서 보다는 개발, 배포 유지보수 쪽으로 더 기운다는 의미를 가진다.&lt;/p>
&lt;p>&lt;strong>운영 방식&lt;/strong>&lt;/p>
&lt;p>시스템 아키텍처가 개발자에게 시스템의 운영 방식을 잘 드러내 준다.&lt;/p>
&lt;p>좋은 소프트웨어 아키텍처는 시스템을 운영하는 데 필요한 요구도 알려준다.&lt;/p>
&lt;ul>
&lt;li>유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시킨다.&lt;/li>
&lt;li>위 요소가 개발자에게 주요 목표로 인식되도록 해야한다.&lt;/li>
&lt;/ul>
&lt;p>이를 통해 시스템을 이해하기 쉬워지며, 따라서 개발과 유지보수에 큰 도움이 된다.&lt;/p>
&lt;h2 id="유지보수">유지보수&lt;/h2>
&lt;p>유지보수는 모든 측면에서 소프트웨어 시스템에서 가장 많은 비용이 발생한다.&lt;/p>
&lt;p>유지보수의 가장 큰 비용은 &lt;strong>탐사 spelunking&lt;/strong>와 &lt;strong>이로 인한 위험부담&lt;/strong>에 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>탐사란?&lt;/strong>&lt;/p>
&lt;p>기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 소프트웨어를 파헤쳐서 어디를 고치는 게 최선인지, 어떤 전략을 쓰는 게 최적일지를 결정할 때 드는 비용&lt;/p>
&lt;/blockquote>
&lt;p>변경사항을 반영할 때 의도치 않은 결함이 발생할 가능성은 항상 존재하며, 이로인한 위험부담 비용이 추가된다.&lt;/p>
&lt;p>주의를 기울여 신중하게 아키텍처를 만들면 이 비용을 크게 줄일 수 있다.&lt;/p>
&lt;ul>
&lt;li>시스템을 컴포넌트로 분리&lt;/li>
&lt;li>안정된 인터페이스를 두어 서로 격리&lt;/li>
&lt;/ul>
&lt;p>이를 통해 미래에 추가될 기능에 대한 길을 밝혀 둘 수 있을 뿐만 아니라 의도치 않은 장재가 발생할 위험을 크게 줄일 수 있다.&lt;/p>
&lt;h2 id="선택사항-열어두기">선택사항 열어두기&lt;/h2>
&lt;p>책 초반에 언급했듯, 소프트웨어는 행위적 가치와 구조적 가치를 지니며, 아키텍처 관점에서 구조적 가치를 추구해야한다.&lt;/p>
&lt;p>소프트웨어를 만든 이유는 기계의 행위를 빠르고 쉽게 변경하는 방법이 필요했기 때문인데, 이러한 유연성은 &lt;strong>시스템의 형태&lt;/strong>, &lt;strong>컴포넌트의 배치 방식&lt;/strong>, &lt;strong>컴포넌트가 상호 연결되는 방식&lt;/strong>에 상당히 크게 의존한다.&lt;/p>
&lt;p>소프트웨어의 유연성을 유지하는 방법은 선택사항(세부사항)을 &lt;strong>가능한 한 많이&lt;/strong>, &lt;strong>가능한 한 오랫동안&lt;/strong> 열어두는 것이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>정책과 세부사항&lt;/strong>&lt;/p>
&lt;p>모든 소프트웨어 시스템은 정책과 세부사항으로 분해할 수 있다.&lt;/p>
&lt;ul>
&lt;li>정책
&lt;ul>
&lt;li>모든 업무 규칙과 업무 절차를 구체화한다.&lt;/li>
&lt;li>시스템의 진정한 가치가 살아있는 곳&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>세부사항
&lt;ul>
&lt;li>사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소&lt;/li>
&lt;li>정책이 가진 행위에는 조금도 영향을 미치지 않는다.&lt;/li>
&lt;li>입출력 장치, DB, 웹 시스템, 서버, 프레임워크, 프로토콜 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 데 있다.&lt;/p>
&lt;p>이를 통해 세부사항을 결정하는 일은 미루거나 연기할 수 있게 된다.&lt;/p>
&lt;p>&lt;strong>예시&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>개발 초기에는 데이터베이스 시스템을 선택할 필요가 없다.
&lt;ul>
&lt;li>고수준의 정책을 데이터베이스가 관계형인지, 분산형인지, 계층형인지 등에 관계 없도록 만들어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개발 초기에는 웹 서버를 선택할 필요가 없다.
&lt;ul>
&lt;li>고수준의 정책은 자신이 웹을 통해 전달된다는 사실을 알아서는 안 된다.&lt;/li>
&lt;li>웹 개발 기술들에 대해 고수준의 정책이 전혀 알지 못하게 만들면, 프로젝트 후반까지는 어떤 종류의 웹 시스템을 사용할지를 결정하지 않아도 된다.&lt;/li>
&lt;li>시스템을 웹을 통해 전송할 것인지조차도 결정할 필요가 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개발 초기에는 REST를 적용할 필요가 없다.
&lt;ul>
&lt;li>고수준의 정책은 외부 세계로의 인터페이스에 대해 독립적이어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>의존성 주입 프레임워크를 적용할 필요가 없다.
&lt;ul>
&lt;li>고수준의 정책은 의존성을 해석하는 방식에 대해 신경써서는 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>세부사항에 몰두하지 않은 채 고수준의 정책을 만들 수 있다면, 이러한 세부사항에 대한 결정을 오랫동안 미루거나 연기할 수 있다.&lt;/p>
&lt;ul>
&lt;li>이러한 결정을 더 오래 참을 수 있다면, 더 많은 정보를 얻을 수 있고, 이를 기초로 제대로 된 결정을 내릴 수 있다.&lt;/li>
&lt;li>선택사항을 더 오랫동안 열어 둘 수 있다면 더 많은 실험을 해볼 수 있고 더 많은 것을 시도할 수 있다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>좋은 아케텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다.&lt;/p>
&lt;p>이를 통해 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다.&lt;/p>
&lt;p>좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.&lt;/p></description></item><item><title>14. 컴포넌트 결합</title><link>https://codemario318.github.io/post/clean-architecture/14/</link><pubDate>Thu, 07 Mar 2024 15:31:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/14/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/cover.png" alt="Featured image of post 14. 컴포넌트 결합" />&lt;p>지금부터 다룰 세 가지 원칙은 &lt;strong>컴포넌트 사이의 관계&lt;/strong>를 설명한다.&lt;/p>
&lt;p>컴포넌트 사이의 관계는 응집도와 마찬가지로 개발 가능성과 논리적 설계 사이의 균형을 다룬다.&lt;/p>
&lt;p>컴포넌트 구조와 관련된 아키텍처를 침범하는 힘은 기술적이며, 정치적이고, 가변적이다.&lt;/p>
&lt;h2 id="adp-의존성-비순환-원칙">ADP: 의존성 비순환 원칙&lt;/h2>
&lt;blockquote>
&lt;p>컴포넌트 의존성 그래프에 순환(Cycle)이 있어서는 안된다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>숙취 증후군 The morning after syndrome&lt;/strong>&lt;br>
무언가를 작동하게 만들놓았는데, 무언가를 의존하고 있던 무언가를 다른 사람이 수정하여 동작하지 않는 현상을 저자는 숙취 증후군이라 부른다.&lt;/p>
&lt;hr>
&lt;p>숙취 증후군은 많은 개발자가 동일한 소스 파일을 수정하는 환경에서 발생한다.&lt;/p>
&lt;p>소수의 개발자로 구성된 작은 프로젝트에서는 큰 문제가 되지 않지만, 프로젝트와 개발팀 규모가 커지면 큰 문제로 다가온다.&lt;/p>
&lt;p>지난 수십 년 동안 이 문제의 해결책으로 두 가지 방법이 발전되어 왔다.&lt;/p>
&lt;ul>
&lt;li>주 단위 빌드(Weekly build)&lt;/li>
&lt;li>의존성 비순환 원칙(Acyclic Dependencies Principle)&lt;/li>
&lt;/ul>
&lt;h3 id="주-단위-빌드">주 단위 빌드&lt;/h3>
&lt;p>중간 규모의 프로젝트에서는 흔하게 사용되는 방법으로 일주일의 첫 4일 동안은 각자 작업한 후 금요일이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다.&lt;/p>
&lt;p>이 접근법은 5일 중 4일 동안 개발자가 걱정없이 개발할 수 있다는 장점이 있지만, 금요일에 통합과 관련된 막대한 업보를 치러야한다는 단점을 가진다.&lt;/p>
&lt;ol>
&lt;li>프로젝트가 커질수록 통합은 하루만에 끝마치는게 불가능해진다.
&lt;ul>
&lt;li>통합 일정이 길어진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개발보다 통합에 드는 시간이 늘어나면서 팀의 효율성도 서서히 나빠진다.
&lt;ul>
&lt;li>빌드 주기가 길어진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>이러한 과정이 반복되며 효율성을 유지하기 위해 빌드 일정을 계속 늘려야 하고, 빌드 주기가 늦어질수록 프로젝트가 감수할 위험은 더 커지게된다.&lt;/p>
&lt;ul>
&lt;li>통합과 테스트를 수행하기가 점점 어려워진다.&lt;/li>
&lt;li>빠른 피드백이 주는 장점을 잃는다.&lt;/li>
&lt;/ul>
&lt;h3 id="순환-의존성-제거하기">순환 의존성 제거하기&lt;/h3>
&lt;p>이 문제의 해결책은 &lt;strong>개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것&lt;/strong>이다.&lt;/p>
&lt;p>이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.&lt;/p>
&lt;ol>
&lt;li>개발자가 해당 컴호넌트가 동작하도록 만든 후, 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할 수 있도록 만든다.&lt;/li>
&lt;li>컴포넌트에 릴리스 번호를 부여하고, 다른팀에서 사용할 수 있는 디렉터리로 이동시킨다.&lt;/li>
&lt;li>개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정한다.&lt;/li>
&lt;li>나머지 개발자는 릴리스된 버전을 사용한다.&lt;/li>
&lt;li>컴포넌트가 새로 릴리스되어 사용할 수 있게 되면, 다른팀에서는 새 릴리스를 적용할 지 결정한다.&lt;/li>
&lt;/ol>
&lt;p>특정 컴포넌트가 변경 되더라도 다른 팀에 영향을 즉각 영향을 주지는 않으므로 어떤 팀도 다른 팀에 의해 좌우되지 않는다.&lt;/p>
&lt;ul>
&lt;li>각 팀은 특정 컴포넌트가 새로 릴리스되면 자신의 컴포넌트를 해당 컴포넌트에 맞게 수정할 시기를 스스로 결정할 수 있다.&lt;/li>
&lt;li>통합은 작고 점진적으로 이뤄진다.&lt;/li>
&lt;/ul>
&lt;p>이 같은 작업 절차는 단순하며 합리적이여서 널리 사용되는 방식이나, 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img.png"
width="1410"
height="706"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_hu25b06e863fc54028a17a8c977c361598_212469_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_hu25b06e863fc54028a17a8c977c361598_212469_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="199"
data-flex-basis="479px"
>&lt;/p>
&lt;p>컴포넌트 다이어그램에서는 컴포넌트를 조립하여 애플리케이션을 만드는 다소 전형적인 구조로, 중요한 점은 컴포넌트 간의 의존성 구조이다.&lt;/p>
&lt;ul>
&lt;li>의존성 관계는 일방향이다.&lt;/li>
&lt;li>어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없다.&lt;/li>
&lt;li>어떠한 컴포넌트의 새로운 릴리스를 만들게 되면 영향을 받는 컴포넌트는 의존성 화살표를 거꾸로 따라가면 알 수 있다.
&lt;ul>
&lt;li>&lt;code>Presenters&lt;/code> &amp;gt; &lt;code>View&lt;/code>, &lt;code>Main&lt;/code>&lt;/li>
&lt;li>&lt;code>Main&lt;/code>은 새로 릴리스되더라도 영향을 받는 컴포넌트가 전혀 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;code>Presenters&lt;/code> 컴포넌트를 만드는 개발자가 이 컴포넌트를 테스트하려고 한다면, 현재 사용중인 버전의 &lt;code>Interactors&lt;/code>와 &lt;code>Entities&lt;/code>를 이용해서 &lt;code>Presenters&lt;/code> 자체 버전을 빌드하면 그만이다.&lt;/p>
&lt;ul>
&lt;li>테스트를 구성할 때 대체로 적은 노력이 든다.&lt;/li>
&lt;li>고려해야 할 변수도 상대적으로 적다.&lt;/li>
&lt;/ul>
&lt;p>시스템 전체를 릴리스해야 할 때가 오면 릴리스 절차는 상향식으로 진행된다.&lt;/p>
&lt;ol>
&lt;li>&lt;code>Entities&lt;/code> 컴포넌트를 컴파일하고, 테스트하고, 릴리스한다.&lt;/li>
&lt;li>&lt;code>Database&lt;/code>와 &lt;code>Interactors&lt;/code>에서도 동일한 과정을 거친다.&lt;/li>
&lt;li>&lt;code>Presenters&lt;/code>, &lt;code>Views&lt;/code>, &lt;code>Controllers&lt;/code>, &lt;code>Authorizer&lt;/code> 순으로 진행한다.&lt;/li>
&lt;li>마지막으로 &lt;code>Main&lt;/code>을 처리한다.&lt;/li>
&lt;/ol>
&lt;p>구성요소 간 의존성을 파악하고 있으면 시스템을 빌드하는 방법을 알 수 있다.&lt;/p>
&lt;h3 id="순환이-컴포넌트-의존성-그래프에-미치는-영향">순환이 컴포넌트 의존성 그래프에 미치는 영향&lt;/h3>
&lt;p>요구사항 발생으로 &lt;code>Entities&lt;/code>의 &lt;code>User&lt;/code> 클래스가 &lt;code>Authorizer&lt;/code>의 &lt;code>Permissions&lt;/code> 클래스를 사용한다고 가정하면, 아래와 같이 순환 의존성이 발생한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_2.png"
width="600"
height="293"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_2_hu1d9357bad079e1bd21e0590f44df1af1_28113_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_2_hu1d9357bad079e1bd21e0590f44df1af1_28113_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="204"
data-flex-basis="491px"
>&lt;/p>
&lt;p>&lt;code>Database&lt;/code> 컴포넌트를 릴리스하려면 &lt;code>Entities&lt;/code>와의 호환되어야 하므로 &lt;code>Authorizer&lt;/code>과 확인도 필요하며, &lt;code>Authorizer&lt;/code>는 &lt;code>Interactors&lt;/code>와도 의존하므로 세 개의 컴포넌트가 사실상 하나의 거대한 컴포넌트가되어 릴리스 하기 어려워진다.&lt;/p>
&lt;p>해당 컴포넌트의 개발자들은 항상 정확하게 동일한 릴리스를 사용해야하므로 모두 서로에게 얽매이게 된다.&lt;/p>
&lt;p>&lt;code>Entites&lt;/code> 컴포넌트를 테스트할 때도 &lt;code>Authorizer&lt;/code>와 &lt;code>Interactors&lt;/code> 까지도 반드시 빌드하고 통합해야한다.&lt;/p>
&lt;p>이처럼 순환이 생기면 컴포넌트를 분리하기가 상당히 어려워진다.&lt;/p>
&lt;ul>
&lt;li>단위테스트를 하고 릴리스를 하는 일도 굉장히 어려워진다. 에러가 쉽게 발생한다.&lt;/li>
&lt;li>모듈의 개수가 많아짐에 따라 빌드 관련 이슈는 기하급수적으로 증가한다.&lt;/li>
&lt;li>컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어진다.
&lt;ul>
&lt;li>순환이 생기면 올바른 순서라는 것 자체가 없을 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="순환-끊기">순환 끊기&lt;/h3>
&lt;p>컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG로 원상복구하는 일은 언제라도 가능하다.&lt;/p>
&lt;p>&lt;strong>의존성 역전 원칙 적용&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_4.png"
width="600"
height="297"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_4_hu2d0ddebed758504a656ef831a9615a2e_23447_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_4_hu2d0ddebed758504a656ef831a9615a2e_23447_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="202"
data-flex-basis="484px"
>&lt;/p>
&lt;ol>
&lt;li>&lt;code>User&lt;/code>가 필요로하는 메서드를 제공하는 인터페이스를 생성한다.&lt;/li>
&lt;li>이 인터페이스를 &lt;code>Entities&lt;/code>에 위치시키고, &lt;code>Authorizer&lt;/code>에서 이 인터페이스를 상속받는다.&lt;/li>
&lt;/ol>
&lt;p>이를 통해 &lt;code>Entities&lt;/code>와 &lt;code>Authorizer&lt;/code> 사이의 의존성을 역전시킬 수 있고, 이를 통해 순환을 끊을 수 있다.&lt;/p>
&lt;p>&lt;strong>새로운 컴포넌트&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_1.png"
width="1024"
height="496"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_1_hud3e3acb0c4f3794f6f3cfe621553502d_150119_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_1_hud3e3acb0c4f3794f6f3cfe621553502d_150119_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="495px"
>&lt;/p>
&lt;ol>
&lt;li>&lt;code>Entities&lt;/code>와 &lt;code>Authorizer&lt;/code>가 모두 의존하는 새로운 컴포넌트를 만든다.&lt;/li>
&lt;li>두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.&lt;/li>
&lt;/ol>
&lt;h3 id="흐트러짐jitters">흐트러짐(Jitters)&lt;/h3>
&lt;p>새로운 컴포넌트를 생성하는 두 번째 해결책에서 시사하는 바는 &lt;strong>요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다&lt;/strong>는 사실이다.&lt;/p>
&lt;p>애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장하므로, 의존성 구조에 순환이 발생하는지를 항상 관찰하여 순환이 발생하면 어떤 식으로든 끊어야 한다.&lt;/p>
&lt;p>이로인해 새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질수도 있다.&lt;/p>
&lt;h2 id="하향식top-down-설계">하향식(Top-down) 설계&lt;/h2>
&lt;p>지금까지 논의로 &lt;strong>컴포넌트 구조는 하향식으로 설계될 수 없다&lt;/strong>는 결론에 다다른다.&lt;/p>
&lt;p>컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.&lt;/p>
&lt;hr>
&lt;p>컴포넌트와 같이 큰 단위로 분해된 구조는 고수준의 기능적인 구조로 다시 분해할 수 있다고 기대하기 때문에 동의하지 않을 수 있지만, 컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없다.&lt;/p>
&lt;p>컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도이므로 빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도 도한 필요 없기 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.&lt;/p>
&lt;p>하지만 프로젝트가 진행되고 발전함에 따라 의존성관리, 영향범위 최소화, 안정적인 컴포넌트, 재사용성 등의 대한 요구로 점점 아키텍처를 새로 만들고 가다듬게 되어 컴포넌트 의존성 그래프는 조금씩 흐트러지고 성장한다.&lt;/p>
&lt;hr>
&lt;p>이처럼 아직 아무런 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하려고 시도한다면 큰 실패를 맛볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>공통 폐쇄에 대해 파악할 수 없다.&lt;/li>
&lt;li>재사용 가능한 요소도 알 수 없다.&lt;/li>
&lt;li>컴포넌트 생성 시 대부분 순환 의존성이 발생하게된다.&lt;/li>
&lt;/ul>
&lt;p>따라서 컴포넌트 의존성 구조는 시스템의 논리적인 설계에 발맞춰 성장하며 또 진화해야한다.&lt;/p>
&lt;h2 id="sdp-안정된-의존성-원칙">SDP: 안정된 의존성 원칙&lt;/h2>
&lt;blockquote>
&lt;p>안정성의 방향으로(더 안정된 쪽에) 의존하라.&lt;/p>
&lt;/blockquote>
&lt;p>설계를 유지하다 보면 변경은 불가피하므로 결코 정적일 수 없다.&lt;/p>
&lt;p>공통 폐쇄 원칙을 준수함으로써 컴포넌트가 다른 유형의 변경에는 영향받지 않으면서도 &lt;strong>특정 유형의 변경&lt;/strong>에만 민감하게 만들 수 있으며, 이에 맞추어 특정 컴포넌트는 변동성을 지니도록 설계한다.&lt;/p>
&lt;p>변동성이 높은(변동이 예상되는) 컴포넌트에 한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워지므로 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대 안된다.&lt;/p>
&lt;ul>
&lt;li>모듈을 만들 때는 변경하기 쉽도록 설계했지만, 그 모듈에 의존성을 매달아 버리면 해당 모듈도 변경하기 어려워진다.&lt;/li>
&lt;li>만든 모듈에서는 한 줄의 코드도 변경되지 않았더라도 변경하는 일이 상당히 도전적인 일이 되어버린다.&lt;/li>
&lt;/ul>
&lt;p>안정된 의존성 원칙을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.&lt;/p>
&lt;h3 id="안정성">안정성&lt;/h3>
&lt;p>동전을 세로로 세우면 안정성이 떨어지지만 건드리지 않으면 넘어지지 않는 것 처럼, 안정성은 변화가 발생하는 빈도와는 직접적인 관련이 없다.&lt;/p>
&lt;p>웹스터 사전에서는 안정성을 &amp;lsquo;쉽게 움직이지 않는&amp;rsquo;이라고 정의하는데 이는 변경을 만들기 위해 필요한 작업량과 관련된다.&lt;/p>
&lt;ul>
&lt;li>변경을 위해 필요한 작업량이 많으면 안정적이다.&lt;/li>
&lt;/ul>
&lt;p>소프트웨어 컴포넌트를 변경하기 어렵게 만드는 데는 크기, 복잡도, 간결함 등 많은 요인이 있지만, 변경하기 어렵게 만드는 확실한 방법 중 하나는 &lt;strong>수 많은 컴포넌트가 해당 컴포넌트에 의존&lt;/strong>하게 만드는 것이다.&lt;/p>
&lt;ul>
&lt;li>컴포넌트 안쪽으로 들어오는 의존성이 많아지면, 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하기 위해 많은 노력이 들기 때문에 상당히 안정적이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>안정된 컴포넌트&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_5.png"
width="600"
height="236"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_5_huda8f1298a64169a65f641afa6cef89c1_12377_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_5_huda8f1298a64169a65f641afa6cef89c1_12377_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="254"
data-flex-basis="610px"
>&lt;/p>
&lt;ul>
&lt;li>X는 세 컴포넌트를 &lt;strong>책임 responsible&lt;/strong>진다
&lt;ul>
&lt;li>X에 3개 컴포넌트가 의존하기 때문에 X를 변경하지 말아야할 이유는 3가지이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>X는 &lt;strong>독립적&lt;/strong>이다.
&lt;ul>
&lt;li>어디에도 의존하지 않으므로 변경되도록 만들 수 있는 외적인 영향이 전혀 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>불안정한 컴포넌트&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_6.png"
width="600"
height="240"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_6_hu7f1ed0727c7caffa02617c63a39a84b1_16824_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_6_hu7f1ed0727c7caffa02617c63a39a84b1_16824_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="250"
data-flex-basis="600px"
>&lt;/p>
&lt;ul>
&lt;li>책임성이 없다.
&lt;ul>
&lt;li>어떤 컴포넌트도 Y에 의존하지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>의존적이다.
&lt;ul>
&lt;li>3개 컴포넌트에 의존하므로 변경이 발생할 수 있는 외부 요인이 3가지이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="안정성-지표">안정성 지표&lt;/h3>
&lt;p>컴포넌트로 들어오고 나가는 의존성의 개수를 세어 컴포넌트가 위치상(Positional) 어느 정도의 안정성을 가지는지 계산할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Fan-in&lt;/strong>: 안으로 들어오는 의존성
&lt;ul>
&lt;li>컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래수 개수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Fan-out&lt;/strong>: 바깥으로 나가는 의존성
&lt;ul>
&lt;li>컴포넌트 외부의 크래스에 의존하는 컴포넌트 내부의 클래수 개수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>I(불안정성)&lt;/strong>: &lt;code>I = Fan-out / (Fan-in + Fan-out)&lt;/code>
&lt;ul>
&lt;li>0 ~ 1&lt;/li>
&lt;li>0이면 최고로 안정된 컴포넌트&lt;/li>
&lt;li>1이면 최고로 불안정한 컴포넌트&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Fan-in&lt;/code>과 &lt;code>Fan-out&lt;/code> 지표는 특정 컴포넌트 내부의 클래스에 의존하는, 컴포넌트 외부에 위치한 클래스의 개수를 세어서 계산할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_7.png"
width="600"
height="270"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_7_hub157614c3a6b055305efa756855a49e0_18409_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_7_hub157614c3a6b055305efa756855a49e0_18409_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="222"
data-flex-basis="533px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;code>I&lt;/code> 값이 1이면 어떤 컴포넌트도 해당 컴포넌트에 의존하지 않지만, 해당 컴포넌트는 다른 컴포넌트에 의존한다는 뜻이다.
&lt;ul>
&lt;li>최고로 불안정한 상태, 책임이 없으며 의존적이다.&lt;/li>
&lt;li>자신에게 의존하는 컴포넌트가 없으므로 변경하지 말아야 할 이유가 없다.&lt;/li>
&lt;li>다른 컴포넌트에 의존하기 때문에 언젠가는 해당 컴포넌트를 변경해야 할 이유가 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>I&lt;/code> 값이 0이면 해당 컴포넌트에 의존하는 다른 컴포넌트가 있지만, 해당 컴포넌트 자체는 다른 컴포넌트에 의존하지 않는다는 뜻이다.
&lt;ul>
&lt;li>최고로 안정된 상태, 다른 컴포넌트를 책임지면서 독립적이다.&lt;/li>
&lt;li>자신에게 의존하는 컴포넌트가 있으므로 변경하기가 어렵다.&lt;/li>
&lt;li>해당 컴포넌트를 변경하도록 강제하는 의존성은 같지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>SDP에서 컴포넌트 &lt;code>I&lt;/code> 지표는 그 컴포넌느가 의존하는 다른 컴포넌트들의 &lt;code>I&lt;/code>보다 커야한다고 말한다.&lt;/p>
&lt;p>즉, 의존성 방향으로 갈수록 &lt;code>I&lt;/code> 지표 값이 감소해야한다.&lt;/p>
&lt;h3 id="모든-컴포넌트가-안정적이어야-하는-것은-아니다">모든 컴포넌트가 안정적이어야 하는 것은 아니다.&lt;/h3>
&lt;p>모든 컴포넌트가 최고로 안정적인 시스템이라면 &lt;strong>변경이 불가능&lt;/strong>하다.&lt;/p>
&lt;p>이는 바람직한 상황은 아니며, 컴포넌트 구조를 설계할 때 기대하는 것은 &lt;strong>불안정한 컴포넌트와 안정된 컴포넌트가 공존하는 상태&lt;/strong>다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_8.png"
width="600"
height="279"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_8_hudc89e9bfdfd398c241eb318aebd58dcb_13750_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_8_hudc89e9bfdfd398c241eb318aebd58dcb_13750_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="215"
data-flex-basis="516px"
>&lt;/p>
&lt;p>위 다이어그램은 세 컴포넌트로 구성된 이상적인 구조이다.&lt;/p>
&lt;p>&lt;strong>추상 컴포넌트&lt;/strong>&lt;/p>
&lt;p>인터페이스만을 포함하는 추상 컴포넌트는 상당히 안정적이므로, 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_9.png"
width="1234"
height="265"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_9_hu6570728dfc635355d54dc2e2f70ef94b_129829_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_9_hu6570728dfc635355d54dc2e2f70ef94b_129829_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="465"
data-flex-basis="1117px"
>&lt;/p>
&lt;p>안정적인 &lt;code>Stable&lt;/code>의 내부 클래스 &lt;code>U&lt;/code>가 불안정한 &lt;code>Flexible&lt;/code>의 내부 클래스 &lt;code>C&lt;/code>를 사용해야한다면, DIP를 도입해 문제를 해결할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_10.png"
width="1232"
height="493"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_10_hu9ebc981cdc230977d03f9eebf0861deb_153552_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_10_hu9ebc981cdc230977d03f9eebf0861deb_153552_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="249"
data-flex-basis="599px"
>&lt;/p>
&lt;p>&lt;code>US&lt;/code>라는 인터페이스를 생성한 수 &lt;code>UServer&lt;/code> 컴포넌트에 넣고, 해당 인터페이스를 구현하도록 하면 &lt;code>Stable&lt;/code>의 &lt;code>Flexible&lt;/code>에 대한 의존성을 끊을 수 있고, &lt;code>UServer&lt;/code> 자체는 어디에도 의존하지 않으므로 안정된 상태이므로, 모든 의존성이 감소하는 방향으로 개선할 수 있다.&lt;/p>
&lt;h2 id="sap-안정된-추상화-원칙">SAP: 안정된 추상화 원칙&lt;/h2>
&lt;blockquote>
&lt;p>컴포넌트는 안정된 정도만큼만 추상화되어야 한다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="고수준-정책을-어디에-위치시켜야-하는가">고수준 정책을 어디에 위치시켜야 하는가?&lt;/h3>
&lt;p>고수준 아키텍처가 정책 결정과 관련된 소프트웨어는 자주 변경되서는 절대로 안되는 소프트웨어이다.&lt;/p>
&lt;p>따라서 시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트(&lt;code>I = 0&lt;/code>)에 위치해야 한다.&lt;/p>
&lt;p>불안정한 컴포넌트(&lt;code>I = 1&lt;/code>)는 반드시 변동성이 큰 소프트웨어, 즉 쉽고 바르게 변경할 수 있는 소프트웨어만을 포함해야 한다.&lt;/p>
&lt;p>하지만 고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스코드는 수정하기 어려워져 시스템 전체 아키텍쳐가 유연성을 잃게 된다.&lt;/p>
&lt;p>개방 폐쇄 원칙의 추상화를 통해 컴포넌트가 최고로 안정된 상태이면서도 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있다.&lt;/p>
&lt;h3 id="안정된-추상화-원칙">안정된 추상화 원칙&lt;/h3>
&lt;p>안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의한다.&lt;/p>
&lt;ul>
&lt;li>안정된 컴포넌트는 추상 컴포넌트여야한다.&lt;/li>
&lt;li>이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다.&lt;/li>
&lt;li>불안정한 컴포넌트는 반드시 구체 컴포넌트여야한다.
&lt;ul>
&lt;li>컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하므로&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>따라서 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다.&lt;/p>
&lt;p>안정된 컴포넌트가 확장 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 된다.&lt;/p>
&lt;p>SDP에서는 의존성이 반드시 안정성의 방향으로 향해야 한다고 말하며, SAP에서는 안정성이 결국 추상화를 의미한다고 말하기 때문에 SAP와 SDP를 결합하면 &lt;strong>컴포넌트에 대한 DIP&lt;/strong>와 같다.&lt;/p>
&lt;ul>
&lt;li>따라서 의존성은 추상화의 방향으로 향하게 된다.&lt;/li>
&lt;/ul>
&lt;h3 id="추상화-정도-측정하기">추상화 정도 측정하기&lt;/h3>
&lt;p>SDP + SPA 조합이 컴포넌트에 대한 DIP라고 언급했었지만, DIP는 클래스에 대한 원칙이므로 추상적이거나 그렇지 않거나 둘중 하나이다.&lt;/p>
&lt;p>하지만 SDP + SAP 조합은 컴포넌트에 대한 원칙이므로 컴포넌트의 어떤 부분은 추상적이면서 다른 부분은 안정적일 수 있다.&lt;/p>
&lt;p>&lt;code>A&lt;/code> 지표는 컴포넌트의 클래스 총 수 대비 인터페이스와 추상 클래스의 개수를 단순히 계산하여 컴포넌트의 추상화 정도를 측정한 값이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>Nc&lt;/code>: 컴포넌트의 클래스 개수&lt;/li>
&lt;li>&lt;code>Na&lt;/code>: 컴포넌트의 추상 클래스와 인터페이스 개수&lt;/li>
&lt;li>&lt;code>A&lt;/code>: 추상화 정도
&lt;ul>
&lt;li>&lt;code>A = Na / Nc&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>A&lt;/code>지표는 0과 1 사이의 값을 가지며, 0이면 추상 클래스가 하나도 없다는 뜻, 1이면 추상클래스만 포함한다는 뜻이다.&lt;/p>
&lt;h3 id="주계열-main-sequence">주계열: Main Sequence&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_11.png"
width="600"
height="297"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_11_hua926ad8375330f6f0926e565cc510cc5_5673_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_11_hua926ad8375330f6f0926e565cc510cc5_5673_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="202"
data-flex-basis="484px"
>&lt;/p>
&lt;ul>
&lt;li>최고로 안정적이며 추상화된 컴포넌트는 (0, 1)&lt;/li>
&lt;li>최고로 불안정하며 구체화된 컴포넌트는 (1, 0)&lt;/li>
&lt;/ul>
&lt;p>컴포넌트는 추상화와 안정화 정도가 다양하므로 두 지점에만 분포할 수는 없다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_12.png"
width="579"
height="297"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_12_huf3699ca9d7d2715e368d8f9e5572debf_24335_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_12_huf3699ca9d7d2715e368d8f9e5572debf_24335_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="194"
data-flex-basis="467px"
>&lt;/p>
&lt;p>따라서 A/I 그래프 상에서 컴포넌트가 위치할 수 있는 합리적인 지점을 정의하는 궤적이 있을 것이라 가정해 볼 수 있으며, 이 궤적은 컴포넌트가 절대로 위치해서는 안 되는 영역(배제할 구역)을 찾는 방식으로 추론할 수 있다.&lt;/p>
&lt;h3 id="고통의-구역-zone-of-pain">고통의 구역: Zone of Pain&lt;/h3>
&lt;p>(0, 0) 주변 구역에 위치한 컴포넌트는 매우 안정적이며 구체적이므로 굉장히 뻣뻣한 상태로 바람직한 상태는 아니다.&lt;/p>
&lt;ul>
&lt;li>추상적이지 않으므로 확장할 수 없다.&lt;/li>
&lt;li>안정적이므로 변경하기 어렵다.&lt;/li>
&lt;/ul>
&lt;p>제대로 설계된 컴포넌트라면 (0, 0) 근처에는 위치하지 않을 것이라 보는게 일반적이다.&lt;/p>
&lt;p>일부 소프트웨어 엔티티는 고통의 구역에 위치한다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스 스키마
&lt;ul>
&lt;li>변동성이 매우 높다.&lt;/li>
&lt;li>극단적으로 구체적이다.&lt;/li>
&lt;li>많은 컴포넌트가 의존한다.&lt;/li>
&lt;li>OO 애플리케이션과 데이터베이스 사이에 위치한 인터페이스는 관리하기 굉장히 어렵다.&lt;/li>
&lt;li>스키마가 변경되면 대체로 고통을 수반한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유틸리티 라이브러리(&lt;code>String&lt;/code> 컴포넌트)
&lt;ul>
&lt;li>I가 1일지라도, 실제로는 변동성이 거의 없다.&lt;/li>
&lt;li>속한 클래스가 모두 구체 클래스이다.&lt;/li>
&lt;li>광범위하게 사용되어 수정하면 혼란을 초래할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>변동될 가능성이 거의 없는 컴포넌트는 (0, 0)에 위치했더라도 해롭지 않다.&lt;/p>
&lt;p>고통의 구역에서 문제가 되는 경우는 변동성이 있는 소프트웨어 컴포넌트이다.&lt;/p>
&lt;h3 id="쓸모없는-구역-zone-of-uselessness">쓸모없는 구역: Zone of Uselessness&lt;/h3>
&lt;p>(1, 1)에 위치한 컴포넌트는 최고로 추상적이지만 누구도 그 컴포넌트에 의존하지 않기 때문에 쓸모없는 컴포넌트이며 이로인해 쓸모없는 구역이라 부른다.&lt;/p>
&lt;p>이 영역에 존재하는 소프트웨어 엔티티는 폐기물과도 같다.&lt;/p>
&lt;ul>
&lt;li>대부분 누구도 구현하지 않은 채 남겨진 추상 클래스&lt;/li>
&lt;/ul>
&lt;p>쓸모없는 구역 내부 깊숙이 자리잡은 컴포넌트는 이러한 엔티티의 상당 부분을 포함할 가능성이 높다.&lt;/p>
&lt;h3 id="배제-구역-벗어나기">배제 구역 벗어나기&lt;/h3>
&lt;p>변동성이 큰 컴포넌트 대부분은 두 배제 구역으로부터 가능한 멀리 떨어뜨려야 한다.&lt;/p>
&lt;p>주계열에 위치한 컴포넌트는 자신의 안정성에 비해 너무 추상적이지도 않고, 추상화 정도에 비해 너무 불안정하지도 않다.&lt;/p>
&lt;ul>
&lt;li>쓸모없지 않으면서 고통을 안겨 주지도 않는다.&lt;/li>
&lt;li>추상화된 수준에 어울릴 정도로만 다른 컴포넌트가 의존한다.&lt;/li>
&lt;li>구체화된 수준에 어울릴 정로로만 다른 컴포넌트에 의존한다.&lt;/li>
&lt;/ul>
&lt;p>컴포넌트가 위치할 수 있는 가장 바람직한 지점은 &lt;strong>주계열의 두 종점&lt;/strong>이다.&lt;/p>
&lt;p>하지만 대규모 시스템에서 일부 컴포넌트는 완벽히 추상적이거나 완전하게 안정적일 수 없으므로, 이러한 컴포넌트는 주 계열 바로 위에 또는 가깝게 위치하게 설계하는 것이 이상적이다.&lt;/p>
&lt;h3 id="주계열과의-거리">주계열과의 거리&lt;/h3>
&lt;p>추상화 정도를 측정하는 A/I 그래프에서 (1, 0), (0, 1)를 연결하는 직선인 주계열을 기준으로 해당 컴포넌트가 얼마나 떨어져있는지 거리를 측정하여 지표으로 사용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>D: 거리, D = |A + I - 1|
&lt;ul>
&lt;li>유효범위: [0, 1]&lt;/li>
&lt;li>0이면 주계열 바로 위에 위치, 1이면 주계열로부터 가정 멀리 위치&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 지표를 통해 컴포넌트가 주계열에 대체로 일치하도록 설계되었는지(추상화, 구체화 수준에 어울리는 의존성을 갖는지) 분석하고, 거리가 먼 컴포넌트들을 개선할 수 있다.&lt;/p>
&lt;p>&lt;strong>통계적 활용&lt;/strong>&lt;/p>
&lt;p>값으로 계산할 수 있으므로 통계적으로 분석 가능해진다.&lt;/p>
&lt;p>설계에 포함된 컴포넌트들의 D를 계산하고 이들의 평균과 분산을 측정하였을때, 주계열에 일치하도록 설계되었다면 평균과 분산은 0에 가까워진다.&lt;/p>
&lt;ul>
&lt;li>분산을 통해 다른 컴포넌트에 비해 극히 예외적인 컴포넌트르 식별할 수 있으므로 관리 한계를 결정하는데 유용할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>시간에 따른 변화 확인&lt;/strong>&lt;/p>
&lt;p>각 컴포넌트의 D 값을 시간의 흐름에 따라 확인해보면, 해당 컴포넌트가 시간이 지남에 따라 의존성이 어떻게 변화하는지 확인할 수 있다.&lt;/p>
&lt;p>이를 통해 주계열에서 멀리 벗어난 컴포넌트들을 분석하여 인사이트를 얻는 것도 가능하다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>의존성 관리 지표는 설계의 의존성과 추상화 정도가 휼륭한 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다.&lt;/p>
&lt;p>하지만 지표는 임의로 결정된 표준을 기초로 한 측정값이므로 진리가 아니며, 의존성의 좋고 나쁨을 지표로만 판단해서는 안된다.&lt;/p>
&lt;p>그러나 이러한 지표를 통해 이상을 확인할 여지가 충분하고, 이를 상세하게 분석하여 아키텍처 개선에 유용하게 사용될 수 있다.&lt;/p></description></item><item><title>13. 컴포넌트 응집도</title><link>https://codemario318.github.io/post/clean-architecture/13/</link><pubDate>Thu, 07 Mar 2024 15:09:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/13/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/13/cover.png" alt="Featured image of post 13. 컴포넌트 응집도" />&lt;p>이 장에서는 컴포넌트 응집도와 관련된 세 가지 원칙을 논의한다.&lt;/p>
&lt;h2 id="rep-재사용릴리스-등가-원칙">REP: 재사용/릴리스 등가 원칙&lt;/h2>
&lt;blockquote>
&lt;p>재사용 단위는 릴리스 단위와 같다.&lt;/p>
&lt;/blockquote>
&lt;p>재사용 가능한 컴포넌트나 컴포넌트 라이브러리가 매우 많이 만들어짐에 따라 모듈 관리 도구가 점점 중요해졌다.&lt;/p>
&lt;p>소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나, 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수도 없고, 하지도 않을 것이다.&lt;/p>
&lt;ul>
&lt;li>릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없다.&lt;/li>
&lt;li>릴리스 번호를 통해 새로운 버전이 언제 출시되고 무엇이 변했는지를 소프트웨어 개발자들이 알아야 한다.
&lt;ul>
&lt;li>따라서 릴리스 절차에는 적절한 공지와 함께 릴리스 문서 작성도 포함되어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 &lt;strong>단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함&lt;/strong>을 뜻한다.&lt;/p>
&lt;p>다른 시각으로 바라보면 &lt;strong>하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 한다.&lt;/li>
&lt;li>동일한 릴리스로 추적 관리되어야 한다.&lt;/li>
&lt;li>동일한 릴리스 문서에 포함되어야 한다.&lt;/li>
&lt;/ul>
&lt;p>REP의 이러한 내용은 개발자들 간의 관습이라는 점이 약점이다. 하지만 그렇기 때문에 컴포넌트가 REP를 위배하면 컴포넌트 사용자가 알게 되고, 아키텍트로서 능력을 높게 평가하지 않을 것이다.&lt;/p>
&lt;p>이 원칙의 약점은 다른 두 원칙이 지닌 강점을 통해 충분히 보완할 수 있다.&lt;/p>
&lt;h2 id="ccp-공통-폐쇄-원칙">CCP: 공통 폐쇄 원칙&lt;/h2>
&lt;blockquote>
&lt;p>동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라.&lt;br>
서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.&lt;/p>
&lt;/blockquote>
&lt;h3 id="srp와-유사성">SRP와 유사성&lt;/h3>
&lt;p>이 원칙은 단일 책임 원칙(SRP)을 컴포넌트 관점에서 다시 쓴 원칙이다.&lt;/p>
&lt;blockquote>
&lt;p>동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.&lt;/p>
&lt;/blockquote>
&lt;p>SRP에서 클래스의 변경 이유는 하나여야 한다고 말하듯이, 공통 폐쇄 원칙에서도 마찬가지로 &lt;strong>단일 컴포넌트는 변경의 이유가 여러개여서는 안된다&lt;/strong>고 말한다.&lt;/p>
&lt;p>대다수의 애플리케이션에서 유지보수성(Maintainability)은 재사용성보다 훨씬 중요하다.&lt;/p>
&lt;p>애플리케이션의 코드가 반드시 변경되어야 한다면, 여러 컴포넌트 도처에서 분산되어 발생하기 보다는, 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.&lt;/p>
&lt;p>변경을 단일 컴포넌트로 제한할 수 있다면, 해당 컴포넌트만 재배포하면 되므로 의존하지 않는 다른 컴포넌트는 다시 검증하거나 배포할 필요가 없어진다.&lt;/p>
&lt;p>CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권한다.&lt;/p>
&lt;ul>
&lt;li>물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 한다.&lt;/li>
&lt;/ul>
&lt;p>이를 통해 소프트웨어를 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화 할 수 있다.&lt;/p>
&lt;h3 id="ocp와의-유사성">OCP와의 유사성&lt;/h3>
&lt;p>이 원칙은 개방 폐쇄 원칙과도 밀접하게 관련되어 있다.&lt;/p>
&lt;p>OCP에서는 클래스가 변경에는 닫혀있고 확장에는 열려있어야 한다고 말하는데, 100% 완전한 폐쇄란 불가능하므로 전략적으로 폐쇄해야 하며, 이에 따라 발생할 가능성이 있거나 과거에 발생했던 대다수의 공통적인 변경에 대해서 클래스가 닫혀 있도록 설계한다.&lt;/p>
&lt;p>CCP에서는 동일한 유형의 변경에 대해 닫혀있는 클래스들을 하나의 컴포넌트로 묶음으로써 OCP에서 얻은 교훈을 확대 적용한다.&lt;/p>
&lt;p>따라서 변경이 필요한 요구사항이 발생했을 때, 그 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아진다.&lt;/p>
&lt;h2 id="crp-공통-재사용-원칙">CRP: 공통 재사용 원칙&lt;/h2>
&lt;blockquote>
&lt;p>컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.&lt;/p>
&lt;/blockquote>
&lt;p>공통 재사용 원칙도 클래스와 모듈을 어느 컴포넌트에 위치시킬 지 결정할 때 도움되는 원칙이다.&lt;/p>
&lt;p>CRP에서는 &lt;strong>같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말한다.&lt;/strong>&lt;/p>
&lt;p>재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용하는 경우가 많은데, CRP에서는 이런 클래스들이 동일한 컴포넌트에 포함되어야 한다고 말한다.&lt;/p>
&lt;ul>
&lt;li>예를 들어 컨테이너 클래스와 해당 클래스의 이터레이터 클래스는 서로 강하게 결합되어 있기 때문에 함께 재사용되므로 이들 클래스는 반드시 동일한 컴포넌트에 위치해야 한다.&lt;/li>
&lt;/ul>
&lt;p>이처럼 CRP는 각 컴포넌트에 어떤 클래스들을 포함시켜야 하는지를 설명해준다.&lt;/p>
&lt;h3 id="isp와의-관계">ISP와의 관계&lt;/h3>
&lt;p>CRP는 인터페이스 분리 원칙의 포괄적인 버전이다.&lt;/p>
&lt;blockquote>
&lt;p>필요하지 않은 것에 의존하지 말라.&lt;/p>
&lt;/blockquote>
&lt;p>ISP는 사용하지 않은 메서드가 있는 클래스에 의존하지 말라고 조언하고, CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다.&lt;/p>
&lt;p>이를 통해 CRP는 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다.&lt;/p>
&lt;p>&lt;strong>어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에는 의존성이 생겨난다.&lt;/strong>&lt;/p>
&lt;p>사용하는 컴포넌트가 사용되는 컴포넌트의 극히 일부만을 사용한다고 하더라도 의존성은 조금도 약해지지 않는다.&lt;/p>
&lt;ul>
&lt;li>사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트도 변경해야 할 가능성이 높다.&lt;/li>
&lt;li>사용하는 컴포넌트를 변경하지 않더라도, 재컴파일, 재검증, 재배포를 해야 하는 가능성은 여전히 남아있다.&lt;/li>
&lt;/ul>
&lt;p>따라서 &lt;strong>의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야한다.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없다.&lt;/li>
&lt;li>그 중 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확실히 인지해야한다.&lt;/li>
&lt;/ul>
&lt;p>CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안 되는지에 대해 훨씬 더 많은 것을 이야기한다.&lt;/p>
&lt;ul>
&lt;li>강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안된다고 말한다.&lt;/li>
&lt;/ul>
&lt;h2 id="컴포넌트-응집도에-대한-균형-다이어그램">컴포넌트 응집도에 대한 균형 다이어그램&lt;/h2>
&lt;p>응집도 관점으로 세 원칙이 상충된다.&lt;/p>
&lt;ul>
&lt;li>포함 원칙: &lt;strong>REP&lt;/strong>, &lt;strong>CCP&lt;/strong>
&lt;ul>
&lt;li>컴포넌트의 크기를 더욱 크게 만든다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>배제 원칙: &lt;strong>CRP&lt;/strong>
&lt;ul>
&lt;li>컴포넌트를 더욱 작게 만든다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>뛰어난 아키텍트라면 이 원칙들이 균형을 이루는 방법을 찾아야한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/13/img.png"
width="821"
height="556"
srcset="https://codemario318.github.io/post/clean-architecture/13/img_hue86487ac117dcaed641584f80e0bb2e1_143879_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/13/img_hue86487ac117dcaed641584f80e0bb2e1_143879_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="147"
data-flex-basis="354px"
>&lt;/p>
&lt;ul>
&lt;li>REP와 CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미친다.&lt;/li>
&lt;li>CCP와 REP에만 과도하게 집중하면 불필요한 릴리스가 너무 빈번해진다.&lt;/li>
&lt;/ul>
&lt;p>이 균형 삼각형에서 개발팀이 현재 관심을 기울이는 부분을 충족시키는 위치를 찾아야 하며, 시간이 흐르면서 개발팀이 주의를 기울이는 부분 역시 변한다는 사실도 이해하고 있어야 한다.&lt;/p>
&lt;ul>
&lt;li>ex) 프로젝트 초기에는 개발 가능성이 더욱 중요하므로 CCP가 REP보다 훨씬 더 중요하다.&lt;/li>
&lt;/ul>
&lt;p>일반적으로 프로젝트는 삼각형의 오른쪽에서 시작하여 재사용성을 희생한다.&lt;/p>
&lt;p>프로젝트가 성숙하고, 파생된 또 다른 프로젝트가 시작되면, 점차 왼쪽으로 이동해간다.&lt;/p>
&lt;p>즉, 프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변하며, 프로젝트가 실제로 수행하는 일 자체보다는 프로젝트가 발전되고 사용되는 방법과 더 관련이 깊다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>과거에는 응집도를 &amp;lsquo;모듈은 단 하나의 기능만 수행해야한다.&amp;lsquo;는 속성 정도로 훌씬 단순했다.&lt;/p>
&lt;p>하지만 컴포넌트 응집도에 관한 세 가지 원칙은 응집도가 가질 수 있는 훨씬 복잡한 다양성을 설명해 준다.&lt;/p>
&lt;p>어느 클래스들을 묶어서 컴포넌트로 만들지 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 고려하여 애플리케이션의 요구에 맞게 균형을 잡는 일은 중요하다.&lt;/p>
&lt;p>이 균형점은 거의 항상 유동적이므로 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화해야한다.&lt;/p></description></item><item><title>12. 컴포넌트</title><link>https://codemario318.github.io/post/clean-architecture/12/</link><pubDate>Thu, 07 Mar 2024 14:21:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/12/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/12/cover.png" alt="Featured image of post 12. 컴포넌트" />&lt;blockquote>
&lt;p>SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명한다.&lt;/p>
&lt;p>큰 빌딩과 마찬가지로 대규모 소프트웨어 시스템은 작은 컴포넌트들로 만들어지므로, 컴포넌트가 무엇인지, 구성하는 요소는 무엇인지 알아보고, 컴포넌트를 결합하여 시스탬을 구성하는 방법에 대해 논의한다.&lt;/p>
&lt;/blockquote>
&lt;p>컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.&lt;/p>
&lt;ul>
&lt;li>java: .jar, ruby: gem, .net: DLL&lt;/li>
&lt;li>컴파일 언어에서는 바이너리 파일의 결합체&lt;/li>
&lt;li>인터프리터 언어의 경우 소스 파일의 결합체&lt;/li>
&lt;/ul>
&lt;p>여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있다.&lt;/p>
&lt;ul>
&lt;li>단일 아카이브: &lt;code>.war&lt;/code>&lt;/li>
&lt;li>플러그인: &lt;code>.jar&lt;/code>, &lt;code>dll&lt;/code>&lt;/li>
&lt;li>실행 파일: &lt;code>.exe&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>컴포넌트가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야한다.&lt;/p>
&lt;h2 id="컴포넌트의-간략한-역사">컴포넌트의 간략한 역사&lt;/h2>
&lt;p>소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어하여, 프로그램 위치가 결정되면, 재배치가 불가능했다.&lt;/p>
&lt;ul>
&lt;li>라이브러리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일했다.&lt;/li>
&lt;li>라이브러리는 바이너리가 아니라 소스 코드 형태로 유지되었다.&lt;/li>
&lt;li>자원이 한정적이었기 때문에 소스코드 전체를 여러번에 걸쳐서 읽어야하지만, 코드 전체를 메모리에 상주시킬 수가 없어 여러차례 읽어야했다.&lt;/li>
&lt;li>컴파일 시간을 단축시키기위해 함수 라이브러리의 소스코드를 애플리케이션 코드로부터 분리했다.
&lt;ul>
&lt;li>개별적으로 컴파일하고, 컴파일된 바이너리를 메모리의 특정 위치에 로드했다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>하지만 애플리케이션은 점점 커졌고, 할당된 공간을 넘어서게 되어 두 개의 주소 세그먼트로 분리하고 함수 라이브라리 공간을 사이에 두고 오가며 동작하게 배치해야했다.&lt;/li>
&lt;li>사용하는 메모리가 늘어날스록 이러한 단편화는 계속될 수밖에 없었기 때문에 지속가능하지 않았다.&lt;/li>
&lt;/ul>
&lt;h3 id="재배치성">재배치성&lt;/h3>
&lt;p>이러한 문제의 해결책은 재배치가 가능한 바이너리(Relocatable binary)였다.&lt;/p>
&lt;ul>
&lt;li>지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정&lt;/li>
&lt;/ul>
&lt;p>함수 라이브러리를 로드할 위치와 애필리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었다.&lt;/p>
&lt;p>이를 통해 오직 필요한 함수만을 로드할 수 있게 되었다.&lt;/p>
&lt;p>컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정되었다.&lt;/p>
&lt;ul>
&lt;li>프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 외부 참조(External reference)&lt;/li>
&lt;li>라이브러리 함수를 정의하는 프로그램이라면 외부 정의(External definition)&lt;/li>
&lt;/ul>
&lt;p>이렇게 함으로써 외부 정의를 로드할 위치가 정해지만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 되었고, 이렇게 링킹 로더(Linking Loader)가 탄생했다.&lt;/p>
&lt;h3 id="링커">링커&lt;/h3>
&lt;p>링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다.&lt;/p>
&lt;p>하지만 프로그램도 훨씬 커지게 되며 링킹 로더의 성능으로 감당할 수 없는 수준이 되었다.&lt;/p>
&lt;p>이에 따라 로드와 링크가 두 단계로 분리되었다.&lt;/p>
&lt;ul>
&lt;li>링커라는 별도의 애플리케이션으로 링크가 완료된 재배치 코드를 만들어주어 로딩 과정이 아주 빨라졌다.&lt;/li>
&lt;li>한번 만들어둔 실행 파일은 언제라도 빠르게 로드할 수 있게 되었다.&lt;/li>
&lt;/ul>
&lt;p>이후 C와 같은 고수준 언어를 사용하기 시작하며 소스 모듈은 &lt;code>.c&lt;/code>파일에서 &lt;code>.o&lt;/code> 파일로 컴파일된 후, 링커로 전달되어 바르게 로드될 수 있는 형태의 실행 파일로 만들어졌다.&lt;/p>
&lt;p>하지만 프로그램의 규모가 커지며 전체 모듈을 컴파일 하는데 꽤 시간이 걸렸고, 이후에 링크에서는 더 많은 시간이 소요되었다.&lt;/p>
&lt;blockquote>
&lt;p>로드 시간은 여전히 빨랐지만, &lt;strong>컴파일-링크 시간&lt;/strong>이 병목 구간이었다.&lt;/p>
&lt;/blockquote>
&lt;p>하지만 자원의 성능이 비약적으로 향상되며 프로그램을 성장시키는 속도보다 링크 시간이 줄어드는 속고가 더 빨라지기 시작했고, 소규모 작업이라면 링킹 로더마저도 다시금 사용할 만하게 되었다.&lt;/p>
&lt;p>이렇게 액티브 X와 공유 라이브러리 시대가 열렸고 &lt;code>.jar&lt;/code> 파일도 등장하기 시작했다.&lt;/p>
&lt;p>다수의 &lt;code>.jar&lt;/code> 파일 또는 다수의 공유 라이브러리를 순식간에 서로 링크한 후, 링크가 끝난 프로그램을 실행할 수 있게 되었고, 이렇게 **컴포넌트 플러그인 아키텍쳐(Component Plugin Architecture)**가 탄생했다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다.&lt;/p>
&lt;p>과거에는 초인적인 노력을 들여아만 컴포넌트 플러그인 아키텍처를 적용할 수 있었지만, 이제는 기본으로 쉽게 사용할 수 있는 지점까지 다다랐다.&lt;/p></description></item><item><title>11. DIP: 의존성 역전 원칙</title><link>https://codemario318.github.io/post/clean-architecture/11/</link><pubDate>Sun, 03 Mar 2024 10:17:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/11/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/11/cover.png" alt="Featured image of post 11. DIP: 의존성 역전 원칙" />&lt;p>의존성 역전 원칙에서 말하는 &amp;lsquo;유연성이 극대화된 시스템&amp;rsquo;이란 &lt;strong>소스 코드 의존성이 추상(Abstraction)에 의존하며 구체(Concretion)에는 의존하지 않는 시스템&lt;/strong>이다.&lt;/p>
&lt;p>자바와 같은 정적 타입 언어에서 이 말은 &lt;code>use&lt;/code>, &lt;code>import&lt;/code>, &lt;code>include&lt;/code> 구분은 오직 &lt;strong>인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다&lt;/strong>는 뜻이다.&lt;/p>
&lt;p>마찬가지로 동적 타입 언어에서도 소스 코드 의존 관계에서 구체 모듈은 참조해서는 안된다.&lt;/p>
&lt;p>하지만 구체 모듈이 무엇인지 정의하기 다소 어렵고, 호출할 함수가 구현된 모듈이라면 참조하지 않기가 특히 어렵다.&lt;/p>
&lt;p>소프트웨어 시스템이라면 구체적인 많은 장치에 반드시 의존하기 때문에 규칙으로 보기에 비현실적이다.&lt;/p>
&lt;ul>
&lt;li>ex) 자바 &lt;code>String&lt;/code>은 구체 클래스
&lt;ul>
&lt;li>애써 추상 클래스로 만들려는 시도는 현실성이 없다.&lt;/li>
&lt;li>&lt;code>java.lang.String&lt;/code> 구체 클래스에 대한 소스 코드 의존성은 벗어날 수 없고, 벗어나서도 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>String&lt;/code> 클래스는 변경되는 일이 거의 없고, 있더라도 엄격하게 통제되므로 매우 안정적이다.&lt;/p>
&lt;ul>
&lt;li>개발자와 아키텍트는 &lt;code>String&lt;/code> 클래스에서 변경이 자주 발생할 것이라고 염려할 필요가 없다.&lt;/li>
&lt;/ul>
&lt;p>이러한 이유로 DIP를 논할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다.&lt;/p>
&lt;ul>
&lt;li>환경에 대한 의존성을 용납하는 이유는 변경되지 않기 때문이다.&lt;/li>
&lt;/ul>
&lt;p>즉, &lt;strong>변동성이 큰(Volatile) 구체적인 요소&lt;/strong>가 의존하지 않도록 만들어야 하는 목표이며, 구체적인 요소는 지속적인 개발을 통해 계속 변경될 수 밖에 없는 모듈들이다.&lt;/p>
&lt;h2 id="안정된-추상화">안정된 추상화&lt;/h2>
&lt;p>안정된 소프트웨어 아키텍처란 변동성이 큰 구현제에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처이다.&lt;/p>
&lt;p>인터페이스는 구현체보다 변동성이 낮다.&lt;/p>
&lt;p>따라서 인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 통해 인터페이스의 변동성을 낮춰야한다.&lt;/p>
&lt;ul>
&lt;li>변동성이 큰 구체 클래스를 참조하지 말라.
&lt;ul>
&lt;li>추상 인터페이스를 참조하라&lt;/li>
&lt;li>객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리(Abstract Factory)를 사용하도록 강제한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>변동성이 큰 구체 클래스로부터 파생하지 말라.
&lt;ul>
&lt;li>상속은 소스 코드에 존재하는 모든 관계 중에서 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다.&lt;/li>
&lt;li>상속을 아주 신중하게 사용해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>구체 함수를 오버라이드 하지 말라.
&lt;ul>
&lt;li>구체 함수는 대체로 소스 코드 의존성을 필요로한다.&lt;/li>
&lt;li>구체 함수를 오버라이드 하면 이러한 의존성을 제거할 수 없게되며, 그 의존성을 상속하게 된다.&lt;/li>
&lt;li>추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.&lt;/li>
&lt;/ul>
&lt;h2 id="팩토리">팩토리&lt;/h2>
&lt;p>사실상 모든 언어에서 객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생하므로, &lt;strong>변동성이 큰 구체적인 객체는 특별히 주의해서 생성&lt;/strong>해야한다.&lt;/p>
&lt;p>대다수의 객체 지향 언어에서 바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/11/img.png"
width="1410"
height="712"
srcset="https://codemario318.github.io/post/clean-architecture/11/img_hufd5bb71d9d4dcad5d050da13121b4711_297143_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/11/img_hufd5bb71d9d4dcad5d050da13121b4711_297143_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="475px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>소스 코드 의존성&lt;/strong>
&lt;ul>
&lt;li>곡선은 구체적인 것들로부터 추상적인 것들은 분리하고 있다.&lt;/li>
&lt;li>소스 코드 의존성은 해당 곡선과 교차할 때 모두 추상적인 쪽으로 향한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>컴포넌트&lt;/strong>
&lt;ul>
&lt;li>시스템이 곡선을 기준으로 추상 컴포넌트와 구체 컴포넌트로 분리된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>제어흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지르고 있는데, 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다.&lt;/p>
&lt;p>이러한 이유로 이 원칙을 의존성 역전이라고 부른다.&lt;/p>
&lt;h2 id="구체-컴포넌트">구체 컴포넌트&lt;/h2>
&lt;p>위 예제의 경우 &lt;code>ServiceFactoryImpl&lt;/code> 구체 클래스가 &lt;code>ConcreteImpl&lt;/code> 구체 클래스에 의존하고 있으므로 DIP를 위배한다고 볼 수 있다.&lt;/p>
&lt;p>DIP 위배를 모두 없앨수는 없지만, DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과는 분리할 수 있다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>DIP는 고수준의 아키텍처 원칙에서 지속적으로 언급되는 규칙이다.&lt;/p>
&lt;p>DIP는 아키텍처 다이어그램에서 가장 눈에 드라나는 원칙이 될 것이다.&lt;/p>
&lt;p>곡선은 아키텍처의 경계가 되고, 의존성은 곡선을 경계로 더 추상적인 엔티티가 있는 쪽으로만 향한다.&lt;/p></description></item><item><title>10. ISP: 인터페이스 분리 원칙</title><link>https://codemario318.github.io/post/clean-architecture/10/</link><pubDate>Sun, 03 Mar 2024 09:49:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/10/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/10/cover.png" alt="Featured image of post 10. ISP: 인터페이스 분리 원칙" />&lt;pre class="mermaid" style="text-align: center;">classDiagram
direction BT
class User1 {
}
class User2 {
}
class User3 {
}
class OPS {
op1()
op2()
op3()
}
OPS &lt;-- User1
OPS &lt;-- User2
OPS &lt;-- User3
&lt;/pre>
&lt;ul>
&lt;li>다수의 사용자가 &lt;code>OPS&lt;/code> 클래스의 오퍼레이션을 사용함
&lt;ul>
&lt;li>&lt;code>UserN&lt;/code>은 &lt;code>opN&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>OPS&lt;/code>는 정적 타입 언어로 작성된 클래스&lt;/li>
&lt;/ul>
&lt;p>위와 같은 경우 &lt;code>User1&lt;/code>이 &lt;code>op2&lt;/code>, &lt;code>op3&lt;/code>를 전혀 사용하지 않음에도 이 두 메서드에 의존하게되고, 사용하지 않는 소스 코드가 변경되면 다시 컴파일한 후 새로 배포해야한다.&lt;/p>
&lt;p>인터페이스 분리 원칙은 &lt;strong>오퍼레이션을 인터페이스 단위로 분리하여 이러한 의존성을 제거&lt;/strong>한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">classDiagram
class User1 {
}
class User2 {
}
class User3 {
}
class U1Ops {
&lt;&lt; interface >>
op1()
}
class U2Ops {
&lt;&lt; interface >>
op2()
}
class U3Ops {
&lt;&lt; interface >>
op3()
}
class OPS {
op1()
op2()
op3()
}
OPS --|> U1Ops
OPS --|> U2Ops
OPS --|> U3Ops
U1Ops &lt;-- User1
U2Ops &lt;-- User2
U3Ops &lt;-- User3
&lt;/pre>
&lt;p>&lt;code>User1&lt;/code>의 소스 코드는 &lt;code>U1Ops&lt;/code>와 &lt;code>op1&lt;/code>에는 의존하지만 &lt;code>OPS&lt;/code>에는 의존하지 않게 되어 &lt;code>OPS&lt;/code> 에서 발생한 변경이 &lt;code>User1&lt;/code>과 전혀 관계없는 변경이라면, &lt;code>User1&lt;/code>을 다시 컴파일하고 새로 배포하는 상황은 초래되지 않는다.&lt;/p>
&lt;h2 id="isp와-언어">ISP와 언어&lt;/h2>
&lt;p>정적 타입 언어는 사용자가 &lt;code>import&lt;/code>, &lt;code>use&lt;/code>, &lt;code>include&lt;/code>와 같은 타입 선언문을 사용하도록 강제한다.&lt;/p>
&lt;p>이러한 &lt;strong>&amp;lsquo;포함된(included)&amp;rsquo;&lt;/strong> 선언문으로 인해 소스 코드 의존성이 발생하고, 이로 인해 재컴파일 도는 재배포가 강제되는 상황이 무조건 초래된다.&lt;/p>
&lt;ul>
&lt;li>동적 타입 언어네서는 소스 코드에 이러한 선언문이 존재하지 않고 런타임에 추론이 발생한다.
&lt;ul>
&lt;li>소스 코드 의존성이 아예 없으며, 재컴파일과 재배포가 필요없다.&lt;/li>
&lt;li>이러한 이유로 동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때보다 유연하며 결합도가 낮은 시스템을 만들 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>ISP를 아키텍처가 아니라, 언어와 관련된 문제라고 결론내릴 여지가 있다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="isp와-아키텍처">ISP와 아키텍처&lt;/h2>
&lt;p>ISP를 사용하는 근본적인 동기를 살펴보면, 잠재되어 있는 더 깊은 우려사항을 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>일반적으로 필요 이상으로 많을 걸 포함하는 모듈에 의존하는 것은 해로운 일이다.
&lt;ul>
&lt;li>소스 코드 의존성의 경우 &lt;strong>불필요한 재컴파일과 재배포를 강제&lt;/strong>하기 때문이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위와 같은 문제는 물론 아키텍처 수준에서도 마찬가지의 상황이 발생한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
a[System S]
b[Framework F]
c[Database D]
a --> b --> c
&lt;/pre>
&lt;ul>
&lt;li>&lt;code>S&lt;/code> 시스템을 구축하며 &lt;code>F&lt;/code>라는 프레임워크를 도입하려고한다.&lt;/li>
&lt;li>&lt;code>F&lt;/code> 프레임워크는 &lt;code>D&lt;/code>라는 특정 데이터베이스를 반드시 사용하도록 만들었다.&lt;/li>
&lt;li>&lt;code>S&lt;/code>는 &lt;code>F&lt;/code>에 의존하고, &lt;code>F&lt;/code>는 &lt;code>D&lt;/code>에 의존하게 된다.&lt;/li>
&lt;/ul>
&lt;p>위와 같은 상황에서 &lt;code>F&lt;/code>에서는 불필요한 기능, 즉 &lt;code>S&lt;/code>와는 전혀 관계없는 기능이 &lt;code>D&lt;/code>에 포함되어있다고 가정하면,&lt;/p>
&lt;ul>
&lt;li>불필요한 기능으로 인해 &lt;code>D&lt;/code> 내부가 변경되면, &lt;code>F&lt;/code>를 재배포 해야할 수도 있다.&lt;/li>
&lt;li>&lt;code>D&lt;/code> 내부의 기능 중 &lt;code>F&lt;/code>와 &lt;code>S&lt;/code>에서 불필요한 기능에 문제가 발생해도 &lt;code>F&lt;/code>와 &lt;code>S&lt;/code>에 영향을 준다.&lt;/li>
&lt;/ul>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다.&lt;/p></description></item><item><title>9. LSP: 리스코프 치환 원칙</title><link>https://codemario318.github.io/post/clean-architecture/9/</link><pubDate>Sat, 02 Mar 2024 16:20:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/9/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/9/cover.png" alt="Featured image of post 9. LSP: 리스코프 치환 원칙" />&lt;blockquote>
&lt;p>&lt;strong>하위 타입(Subtype)&lt;/strong>&lt;br>
&lt;code>S&lt;/code>타입의 객체 &lt;code>o1&lt;/code> 각각에 대응하는 &lt;code>T&lt;/code>타입 객체 &lt;code>o2&lt;/code>가 있고, &lt;code>T&lt;/code>타입을 이용해서 정의한 모든 프로그램 &lt;code>P&lt;/code>에서 &lt;code>o2&lt;/code>의 자리에 &lt;code>o1&lt;/code>을 치환하더라도 &lt;code>P&lt;/code>의 행위가 변하지 않는다면, &lt;code>S&lt;/code>는 &lt;code>T&lt;/code>의 하위 타입이다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="상속을-사용하도록-가이드하기">상속을 사용하도록 가이드하기&lt;/h2>
&lt;pre class="mermaid" style="text-align: center;">classDiagram
class Billing {
}
class License {
&lt;&lt; interface >>
calcFee()
}
class PersonalLicense {
}
class BusinessLicense {
users
}
Billing --> License
License &lt;|-- PersonalLicense
License &lt;|-- BusinessLicense
&lt;/pre>
&lt;p>&lt;code>Billing&lt;/code> 애플리케이션의 행위가 &lt;code>License&lt;/code>타입 중 무엇을 사용하는지에 전혀 의존하지 않이 때문에, 이들 하위 타입은 모두 &lt;code>License&lt;/code> 타입을 치환할 수 있으므로 위 설계는 리스코프 치환 원칙을 준수한다.&lt;/p>
&lt;h2 id="정사각형직사각형-문제">정사각형/직사각형 문제&lt;/h2>
&lt;p>리스코프 치환 원칙을 위반하는 전형적인 문제로 유명한 정사각형/직사각형 문제가 있다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">classDiagram
direction LR
class User {
}
class Rectangle {
H, W
setH()
setW()
}
class Square {
setSide()
}
User --> Rectangle
Rectangle &lt;|-- Square
&lt;/pre>
&lt;p>위 예제에서 &lt;code>Rectangle&lt;/code>의 높이와 너비는 서로 독립적으로 변경될 수 있는 반면, &lt;code>Square&lt;/code>의 높이와 너비는 반드시 함께 변경되므로 &lt;code>Square&lt;/code>는 &lt;code>Rectangle&lt;/code>의 하위 타입으로는 부적합하다.&lt;/p>
&lt;p>이러한 경우 &lt;code>User&lt;/code>는 대화하고 있는 상대가 &lt;code>Rectangle&lt;/code> 이라고 생각하므로 혼동이 생길 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Rectangle&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">setW&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">setH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">area&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위와 같은 경우 &lt;code>...&lt;/code>에 &lt;code>Square&lt;/code>를 생성한다면(치환한다면), &lt;code>assert&lt;/code>문은 실패하게된다.&lt;/p>
&lt;hr>
&lt;p>이러한 형태의 리스코프 치환 원칙 위반을 막기 위한 유일한 방법은 검사하는 메커니즘을 &lt;code>User&lt;/code>에 추가하는 것 인데, &lt;code>User&lt;/code>의 행위가 사용하는 타입에 의존하게 되므로, 결국 타입을 서로 치환할 수 없게 된다.&lt;/p>
&lt;h2 id="lsp와-아키텍처">LSP와 아키텍처&lt;/h2>
&lt;p>LSP는 상속을 사용하도록 가이드하는 방법 정도로 간주 되었으나, 시간이 지나면서 LSP는 &lt;strong>인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모해왔다.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>인터페이스&lt;/strong>&lt;/p>
&lt;p>위에서 말하는 인터페이스는 여러 의미로 해석 가능하다.&lt;/p>
&lt;ul>
&lt;li>인터페이스 하나와 이를 구현하는 여러 개의 클래스&lt;/li>
&lt;li>동일한 메서드 시그니처를 공유하는 여러 개의 클래스&lt;/li>
&lt;li>동일한 REST 인터페이스에 응답하는 서비스 집단&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>잘 정의된 인터페이스와 그 인터페이스의 구현체끼리의 상호 치환 가능성에 기대는 사용자들이 존재하기 때문에 대부분의 상황에서 LSP를 적용할 수 있다.&lt;/p>
&lt;h2 id="lsp-위배-사례-택시-파견-서비스">LSP 위배 사례: 택시 파견 서비스&lt;/h2>
&lt;p>&lt;strong>요구사항&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>고객이 어느 택시업체인지는 신경쓰지 않고 자신의 상황에 가장 적합한 택시를 찾는다.&lt;/li>
&lt;li>택시를 결정하면, 시스템은 REST 서비스를 통해 선택된 택시를 고객 위치로 파견한다.
&lt;ul>
&lt;li>URI가 운전기사 데이터베이스에 저장되어 있다.&lt;/li>
&lt;li>URI 정보를 이용하여 해당 기사를 고객 위치로 파견한다.&lt;/li>
&lt;li>ex) Bob의 URI: &lt;code>purplecab.com/driver/Bob&lt;/code>&lt;/li>
&lt;li>요청 예시&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">purplecab.com/driver/Bob
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> /picupAddress/24 Maple St.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> /pickupTime/153
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> /destination/ORD
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 서비스를 만들 때 다양한 택시업체에서 동일한 REST 인터페이스를 반드시 준수하도록 만들어야한다.&lt;/p>
&lt;p>만약 택시업체 ACME에서 &lt;code>destination&lt;/code> 필드를 &lt;code>dest&lt;/code>로 축약해서 사용했다고 가정하면, 해당 예외 사항을 처리하는 로직을 추가해야만 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">driver&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getDispatchUri&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">startWith&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;acme.com&amp;#34;&lt;/span>&lt;span class="p">))...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&amp;ldquo;acme&amp;quot;라는 단어를 코드 자체에 추가하면, 끔찍할 뿐만 아니라 이해할 수도 없는 온갖 종류의 에러가 발생할 여지를 만들게 된다.&lt;/li>
&lt;li>새로운 택시업체 추가시 또 다른 if문이 필요할 수 있다.&lt;/li>
&lt;li>위와 같은 버그를 방지하기 위해 &lt;strong>설정용 데이터베이스&lt;/strong>를 이용하는 파견 명령 생성 모듈을 만들어야 할 수도 있다.
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>URI&lt;/th>
&lt;th>Dispatch Format&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Acme.com&lt;/td>
&lt;td>/pickupAddress/%s/pickupTime/%s/dest/%s&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>*.*&lt;/td>
&lt;td>/pickupAddress/%s/pickupTime/%s/destination/%s&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>REST 서비스들의 인터페이스가 서로 치환 가능하지 않다는 사실을 처리하는 중요하고 복잡한 매커니즘을 추가해야 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다.&lt;/p>
&lt;p>치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.&lt;/p></description></item><item><title>8. 개방 폐쇄 원칙</title><link>https://codemario318.github.io/post/clean-architecture/8/</link><pubDate>Fri, 01 Mar 2024 09:06:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/8/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/8/cover.png" alt="Featured image of post 8. 개방 폐쇄 원칙" />&lt;blockquote>
&lt;p>소프트웨어 개체(Artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.&lt;/p>
&lt;/blockquote>
&lt;p>개방 폐쇄 원칙은 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안된다는 원칙이다.&lt;/p>
&lt;p>요구사항을 살짝 확장하는 데 소프트웨어를 많이 수정해야 한다면, 그 소프트웨어 시스템을 설계한 아키텍트는 엄청난 실패에 맞닥뜨린 것이다.&lt;/p>
&lt;p>OCP는 클래스와 모듈을 설계할 때 도움이 되는 원칙으로 알려져 있지만, &lt;strong>아키텍처 컴포넌트 수준에서 고려할 때 훨씬 중요한 의미를 가진다.&lt;/strong>&lt;/p>
&lt;h2 id="사고-실험-재무제표-시스템">사고 실험: 재무제표 시스템&lt;/h2>
&lt;p>&lt;strong>요구사항&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>웹 페이지에 표시되는 데이터는 스크롤할 수 있음&lt;/li>
&lt;li>음수는 빨간색으로 출력&lt;/li>
&lt;li>추가 요구 사항: 동일한 정보를 보고서 형태로 변환해서 흑백 프린터로 출력 가능
&lt;ul>
&lt;li>페이지 번호가 제대로 메겨져 있어야 함&lt;/li>
&lt;li>페이지마다 적절한 머리글과 바닥글 있어야 함&lt;/li>
&lt;li>표의 각 열에는 레이블이 있어야 함&lt;/li>
&lt;li>음수는 괄호로 감싸야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>소프트웨어 아키텍처가 훌륭하다면 추가 요구사항에 따라 변경되는 코드의 양이 가능한 최소화 될 것이다.(이상적인 변경량은 0)&lt;/p>
&lt;p>이러한 경우 &lt;strong>서로 다른 목적으로 변경되는 요소를 적절하게 분리&lt;/strong>하고(단일 책임 원칙), 이들 &lt;strong>요소 사이의 의존성을 체계화&lt;/strong>함으로(의존성 역전 원칙) 변경량을 최소화 할 수 있다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
a[재무 데이터]
b((재무 분석기))
c[보고서용 재무 데이터]
d((보고서를 웹에 표시))
e((보고서를 프린터로 출력))
a --> b
b --> c
c --> d
c --> e
&lt;/pre>
&lt;ul>
&lt;li>보고서 생성이 두 개의 책임으로 분리 &amp;gt; 웹, 프린터
&lt;ul>
&lt;li>책임을 분리했다면, 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 의존성도 확실히 조직화 해야한다.&lt;/li>
&lt;li>행위가 확장될 때 변경이 발생하지 않음을 보장해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 목적을 달성하려면 &lt;strong>처리과정을 클래스 단위로 분할&lt;/strong>, &lt;strong>컴포넌트 단위로 구분&lt;/strong>해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/8/img_1.png"
width="1596"
height="1320"
srcset="https://codemario318.github.io/post/clean-architecture/8/img_1_hu67afed36bbb285aef637bc2b5de4e81c_785295_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/8/img_1_hu67afed36bbb285aef637bc2b5de4e81c_785295_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="290px"
>&lt;/p>
&lt;ul>
&lt;li>모든 의존성이 소스 코드 의존성을 나타낸다.
&lt;ul>
&lt;li>&lt;code>FinancialDataMapper&lt;/code>는 구현 관계를 통해 &lt;code>FinancialDataGateway&lt;/code>를 알고 있지만, &lt;code>FinancialDataGateway&lt;/code>는 &lt;code>FinancialDataMapper&lt;/code>에 대해 알지 못한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이중선은 화살표와 오직 한 방향으로만 교차한다.
&lt;ul>
&lt;li>모든 컴포넌트 관계는 단 방향으로 이루어진다.&lt;/li>
&lt;li>화살표는 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/8/img.png"
width="1734"
height="918"
srcset="https://codemario318.github.io/post/clean-architecture/8/img_hua4d495848552290f72309b8d34290664_326621_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/8/img_hua4d495848552290f72309b8d34290664_326621_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;blockquote>
&lt;p>A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야한다.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;code>Presenter&lt;/code>에서 발생한 변경으로부터 &lt;code>Controller&lt;/code>를 보호&lt;/li>
&lt;li>&lt;code>View&lt;/code>에서 발생한 변경으로부터 &lt;code>Presenter&lt;/code>를 보호&lt;/li>
&lt;li>&lt;code>Interactor&lt;/code>는 다른 모든 것에서 발생한 변경으로부터 보호&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Interactor&lt;/code>는 변경 폐쇄 원칙을 가장 잘 준수하는 곳에 위치하고 있는데, 이는 &lt;code>Interactor&lt;/code>가 애플리케이션에서 가장 높은 수준의 정책, 가장 중요한 문제를 담당하고 있기 때문이다.&lt;/p>
&lt;p>보호의 계층구조는 &lt;strong>수준 level&lt;/strong>이라는 개념을 바탕으로 구성되어야하며, 높은 수준일수록(세부 구현과 멀 수록) 변경에 대해 강력한 보호가 필요하다.&lt;/p>
&lt;p>아키텍처 수준에서 개방 폐쇄 원칙은 아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다.&lt;/p>
&lt;p>컴포넌트 계층구조를 이와 같이 조족화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.&lt;/p>
&lt;h2 id="방향성-제어">방향성 제어&lt;/h2>
&lt;p>&lt;code>FinancialDataGateway&lt;/code> 인터페이스는 &lt;code>Interactor&lt;/code> 컴포넌트에서 &lt;code>Database&lt;/code> 컴포넌트의 의존성을 역전시키기 위해 &lt;code>FinancialReportGenerator&lt;/code>와 &lt;code>FinancialDataMapper&lt;/code> 사이에 위치한다.&lt;/p>
&lt;p>&lt;code>FinancialDataGateway&lt;/code> 인터페이스가 없었다면 의존성이 &lt;code>Interactor&lt;/code> 컴포넌트에서 &lt;code>Database&lt;/code> 컴포넌트로 바로 향하게된다.&lt;/p>
&lt;h2 id="정보-은닉">정보 은닉&lt;/h2>
&lt;p>&lt;code>FinancialReportRequester&lt;/code> 인터페이스는 &lt;code>FinancialReportController&lt;/code>가 &lt;code>Interactor&lt;/code> 내부에 대해 너무 많이 알지 못하도록 막기 위해서 존재한다.&lt;/p>
&lt;ul>
&lt;li>인터페이스가 없었다면 &lt;code>Controller&lt;/code>는 &lt;code>FinancialEntities&lt;/code>에 대해 추이 종속성(Transitive dependency)을 가지게 된다.&lt;/li>
&lt;li>추이 종속성을 가지게 되면, 소프트웨어 엔티티는 **&amp;lsquo;자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다.&amp;rsquo;**는 소프트웨어 원칙을 위반하게 된다.&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Controller&lt;/code>에서 발생한 변경으로부터 &lt;code>Interactor&lt;/code>를 보호하는 일의 우선순위가 가장 높지만, 반대로 &lt;code>Interactor&lt;/code>에서 발생한 변경으로 부터 &lt;code>Controller&lt;/code>도 보호되길 바라기 때문에 &lt;code>Interactor&lt;/code> 내부를 은닉한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>추이 종속성(Transitive dependency)&lt;/strong>&lt;/p>
&lt;p>클래스 A가 클래스 B에 의존하고, 클래스 B가 클래스 C에 의존한다면, 클래스 A는 클래스 C에 의존하게 된다.&lt;/p>
&lt;ul>
&lt;li>클래스 이외의 소프트웨어의 모든 엔티티에도 동일하게 적용된다.&lt;/li>
&lt;li>클래스 의존성이 순환적이라면, 모든 클래스가 서로 의존하게 되는 문제가 있다.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>개방 폐쇄 원칙은 아키텍처를 떠받치는 원동력 중 하나다. OCP의 목표는 &lt;strong>시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있다.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>시스템을 컴포넌트 단위로 분리한다.&lt;/li>
&lt;li>저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 한다.&lt;/li>
&lt;/ul></description></item><item><title>7. 단일 책임 원칙</title><link>https://codemario318.github.io/post/clean-architecture/7/</link><pubDate>Thu, 29 Feb 2024 16:27:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/7/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/7/cover.png" alt="Featured image of post 7. 단일 책임 원칙" />&lt;h2 id="solid">SOLID&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>SOLID 원칙&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>함수와 데이터 구조를 클래스로 배치하는 방법&lt;/li>
&lt;li>클래스를 서로 결합하는 방법&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>좋은 소프트웨어 시스템은 깔끔한 코드(Clean Code)를 전제한다.&lt;/p>
&lt;p>하지만 깔끔한 코드를 사용한다고 하더라도 아키텍처가 좋지 못하다면 좋은 소프트웨어 시스템을 만들 수 없기 때문에 깔끔한 코드로 좋은 아키텍처를 정의하는 원칙이 필요하다.&lt;/p>
&lt;p>SOLID 원칙의 목적은 &lt;strong>중간 수준의 소프트웨어 구조&lt;/strong>가 아래와 같도록 만드는 것이다.&lt;/p>
&lt;ul>
&lt;li>변경에 유연&lt;/li>
&lt;li>이해하기 쉬움&lt;/li>
&lt;li>많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>중간 수준&lt;/strong>의미는?&lt;br>
프로그래머가 이들 원칙을 &lt;strong>모듈 수준&lt;/strong>에서 작업할 때 적용할 수 있다.&lt;br>
코드 수준보다는 조금 더 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는 데 도움을 준다.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>SRP: Single Responsibility Principle, 단일 책임 원칙&lt;/strong>
&lt;ul>
&lt;li>콘웨이(Conway) 법칙
&lt;ul>
&lt;li>조직이 설계한 시스템은 해당 조직의 커뮤니케이션 구조를 반영한다.&lt;/li>
&lt;li>조직의 내부 구조와 상호 작용 방식은 그 조직이 개발하는 소프트웨어의 구조와 유사해진다.&lt;/li>
&lt;li>조직 내에 분산된 팀이 서로 간의 교류가 원할하지 않을 경우 개발하는 소프트웨어도 모듈화 인터페이스 설계에 문제가 발생한다.&lt;/li>
&lt;li>따름 정리:
&lt;ul>
&lt;li>특정한 제한을 둔 조직 구조가 특정한 형태의 소프트웨어 아키텍처를 유도한다.&lt;/li>
&lt;li>특정한 형테의 조직 구조가 특정한 형태의 소프트웨어 아키텍처를 촉진하거나 제한할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>따라서 각 소프트웨어의 모듈은 변경의 이유가 하나여야만 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>OCP: Open-Closed Principle, 개방 폐쇠 원칙&lt;/strong>
&lt;ul>
&lt;li>기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 시스템을 쉽게 변경할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>LSP: Liskov Substitution Principle, 리스코프 치환 원칙&lt;/strong>
&lt;ul>
&lt;li>상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 구성요소는 반드시 서로 치환 가능해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>ISP: Interface Segregation Principle, 인터페이스 분리 원칙&lt;/strong>
&lt;ul>
&lt;li>사용하지 않은 것에 의존하지 않아야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>DIP: Dependency Inversion Principle, 의존성 역전 원칙&lt;/strong>
&lt;ul>
&lt;li>고수준 정책을 구현하는 코드는 저수준 세보사항을 구현하는 코드에 절대로 의존해서는 안된다.&lt;/li>
&lt;li>세부사항이 정책에 의존해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="srp-단일-책임-원칙">SRP: 단일 책임 원칙&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경된다.&lt;/p>
&lt;p>따라서 SRP가 말하는 변경의 이유는 **사용자와 이해관계자 집단(액터, Actor)**을 의미하며, 이러한 관점에서 단일 책임 원칙은 다음과 같이 말할 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>하나의 모듈은 한의 액터에 대해서만 책임져야 한다&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>모듈이란?&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>소스 파일&lt;/li>
&lt;li>단순히 함수와 데이터 구조로 음집된 집합&lt;/li>
&lt;/ul>
&lt;p>단일 액터를 책임지는 코드르 함께 묶어주는 힘이 바로 &lt;strong>응집성 Cohesion&lt;/strong>이다.&lt;/p>
&lt;h3 id="징후-1-우발적-중복">징후 1: 우발적 중복&lt;/h3>
&lt;pre class="mermaid" style="text-align: center;">classDiagram
class Employee {
calculatePay()
reportHours()
save()
}
&lt;/pre>
&lt;ul>
&lt;li>&lt;code>calculatePay()&lt;/code>
&lt;ul>
&lt;li>회계팀에서 기능을 정의&lt;/li>
&lt;li>CFO 보고를 위해 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>reportHours()&lt;/code>
&lt;ul>
&lt;li>인사팀에서 기능을 정의하고 사용&lt;/li>
&lt;li>COO 보고를 위해 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>save()&lt;/code>
&lt;ul>
&lt;li>DBA가 기능을 정의&lt;/li>
&lt;li>CTO 보고를 위해 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Employee&lt;/code> 클래스는 서로 매우 다른 액터를 책임지기 때문에 SRP를 위반하게 된다.&lt;/p>
&lt;p>&lt;code>Employee&lt;/code>는 단일 클래스 내의 각각 다른 액터를 책임지는 메서드들로 인해 액터간의 결합이 발생하였고, 이러한 결합으로 인해 의존하는 무언가에 영향을 줄 수 있다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart TD
a[calculatePay]
b[reportHours]
c[regularHours]
a --> c
b --> c
&lt;/pre>
&lt;p>위 처럼 &lt;code>calculatePay&lt;/code>와 &lt;code>reportHours&lt;/code> 메소드의 시간 계산 코드 중복을 피하기 위해 &lt;code>regularHours&lt;/code> 메소드를 추가했다고 가정하고, &lt;code>calculatePay&lt;/code>의 정책 변경으로 인해 &lt;code>reqularHours&lt;/code> 메소드를 일부 변경했다.&lt;/p>
&lt;p>이러한 경우 해당 메소드와 연관된 액터가 CFO, COO 둘이지만, CFO의 요구사항으로 변경되었기 때문에 변경을 원하지 않는 COO의 기능에도 영향을 미치게 되는데, 관심사가 달라 의존 관계를 확인하기 어려워 확인이 누락이 될 수 있다.&lt;/p>
&lt;p>(이로인해 &lt;code>reportHours&lt;/code> 메소드에서는 이러한 변경으로 인해 잘못된 결과를 얻을 수 있다.)&lt;/p>
&lt;p>결과적으로 이러한 문제는 &lt;strong>서로 다른 액터가 의존하는 코드를 너무 가까이 배치&lt;/strong>했기 때문에 발생한 문제이며, SRP는 이러한 문제를 &lt;strong>서로 다른 액터가 의존하는 코드를 서로 분리&lt;/strong>하여 예방하라고 말하고 있다.&lt;/p>
&lt;h3 id="징후-2-병합">징후 2: 병합&lt;/h3>
&lt;p>메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성이 확실히 더 높아진다.&lt;/p>
&lt;p>많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우에 발생한다.&lt;/p>
&lt;ul>
&lt;li>다른 목적으로 인해 같은 코드를 변경할 가능성이 높아지고 이로인해 변경사항이 충돌할 여지가 많다.&lt;/li>
&lt;/ul>
&lt;p>이러한 문제는 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것으로 이러한 문제를 벗어날 수 있다.&lt;/p>
&lt;h3 id="해결책">해결책&lt;/h3>
&lt;p>이 문제의 해결책은 다양하지만, 모두 메서드를 각기 다른 클래스로 이동시키는 것은 공통적으로 포함한다.&lt;/p>
&lt;p>가장 확실한 해결책은 데이터와 메서드를 분리하는 방식으로, 아무런 메서드가 없는 데이터 구조인 &lt;code>EmployeeData&lt;/code> 클래스를 만들어 세 개의 클래스가 공유하도록 만든다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">classDiagram
direction LR
class EmployeeData {
datas...
}
class PayCalculator {
calculatePay()
}
class HourReporter {
reportHours()
}
class EmployeeSaver {
saveEmployee()
}
PayCalculator --> EmployeeData
HourReporter --> EmployeeData
EmployeeSaver --> EmployeeData
&lt;/pre>
&lt;p>세 클래스는 서로의 존재를 모르기 때문에 &lt;strong>우연한 중복&lt;/strong>을 피할 수 있다.&lt;/p>
&lt;p>위 방식은 개발자가 세 가지 클래스를 인스턴스화하고 추적해야 한다는 단점이 있는데, 퍼사드 패턴을 활용하여 개선이 가능하다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">classDiagram
direction LR
class EmployeeFacade {
calculatePay()
reportHours()
save()
}
class EmployeeData {
datas...
}
class PayCalculator {
calculatePay()
}
class HourReporter {
reportHours()
}
class EmployeeSaver {
saveEmployee()
}
EmployeeFacade --> PayCalculator
EmployeeFacade --> HourReporter
EmployeeFacade --> EmployeeSaver
PayCalculator --> EmployeeData
HourReporter --> EmployeeData
EmployeeSaver --> EmployeeData
&lt;/pre>
&lt;p>중요한 업무 규칙을 데이터와 가깝게 배치하는 방식을 원한다면 아래와 같이 구성할 수도 있다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">classDiagram
direction LR
class Employee {
employeeData
calculatePay()
reportHours()
save()
}
class HourReporter {
reportHours()
}
class EmployeeSaver {
saveEmployee()
}
Employee --> HourReporter
Employee --> EmployeeSaver
&lt;/pre>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>단일 책임 원칙은 &lt;strong>메서드와 클래스 수준의 원칙&lt;/strong>이다.&lt;/p>
&lt;p>하지만 이보다 상위 두 수준에서도 다른 형태로 다시 등장한다.&lt;/p>
&lt;ul>
&lt;li>컴포넌트 수준: 공통 폐쇄 원칙(Common Closure Principle)&lt;/li>
&lt;li>아키텍처 수준: 아키텍쳐 경계(Architectural Boundaray)의 생성을 책임지는 변경의 축(Axis of Change)&lt;/li>
&lt;/ul></description></item><item><title>6. 함수형 프로그래밍</title><link>https://codemario318.github.io/post/clean-architecture/6/</link><pubDate>Sun, 25 Feb 2024 20:36:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/6/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/6/cover.png" alt="Featured image of post 6. 함수형 프로그래밍" />&lt;p>함수형 프로그래밍이라는 개념은 프로그래밍 그 자체보다 앞서 등장했다.&lt;/p>
&lt;p>이 패러다임에서 핵심이 되는 기반은 람다(Lambda) 계산법으로 안론조 처치가 1930년대에 발명했다.&lt;/p>
&lt;h2 id="불변성과-아키텍처">불변성과 아키텍처&lt;/h2>
&lt;p>일반적인 언어들과 달리 함수형 언어에서는 변수가 한번 초기화되면 절대로 변경되지 않는다.&lt;/p>
&lt;p>가변 변수로 인해 경합 조건, 교착상태 조건, 동시 업데이트 문제가 발생하는데, 만약 어떠한 변수도 갱신되지 않는다면 경합 조건이나 동시 업데이트 문제가 발생하지 않는다.&lt;/p>
&lt;p>락(lock)이 가변적이지 않다면 교착상태도 일어나지 않는다.&lt;/p>
&lt;p>동시성 애플리케이션에서 마주치는 모든 문제, 즉 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.&lt;/p>
&lt;p>불변성은 저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다면 보장 가능하지만 그럴 수 없으므로 어느정도 타협이 필요하다.&lt;/p>
&lt;h2 id="가변셩의-분리">가변셩의 분리&lt;/h2>
&lt;p>불변성과 관련하여 가장 주요한 타협 중 하나는 애플리케이션 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.&lt;/p>
&lt;p>불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.&lt;/p>
&lt;p>불변 컴포넌트는 변수의 상태를 변경할 수 있는, 죽 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/6/img.png"
width="574"
height="396"
srcset="https://codemario318.github.io/post/clean-architecture/6/img_hu99e785152b719343990f143a06772634_81872_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/6/img_hu99e785152b719343990f143a06772634_81872_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="상태 변경과 트랜잭션 메모리"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;p>상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 트랜잭션 메모리와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호한다.&lt;/p>
&lt;p>트랜잭션 메모리는 트랜잭션을 사용하거나 도는 재시도 기법을 통해 변수를 보호한다.&lt;/p>
&lt;p>애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야한다.&lt;/p>
&lt;p>그리고 이렇게 분리하려면 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침해야한다.&lt;/p>
&lt;p>현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.&lt;/p>
&lt;h2 id="이벤트-소싱">이벤트 소싱&lt;/h2>
&lt;p>이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다.&lt;/p>
&lt;p>상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.&lt;/p>
&lt;p>이 전략은 많은 저장 공간을 필요로 하지만 현재는 저장 공간을 충분히 확보할 수 있다.&lt;/p>
&lt;ul>
&lt;li>데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없으므로, 결과적으로 애플리케이션은 CRUD가 아닌 그저 CR만 수행한다.&lt;/li>
&lt;li>데이터 저장소에서 변경과 삭제가 전혀 발생하지 않으므로 동시 없데이트 문제 또한 일어나지 않는다.&lt;/li>
&lt;/ul>
&lt;p>저장 공간과 처리 능력이 충분하면 완전한 불변성을 갖도록 만들 수 있고, 따라서 완전한 함수형으로 만들 수 있다.&lt;/p>
&lt;ul>
&lt;li>버전 관리 시스템이 정확히 이방식으로 동작한다.&lt;/li>
&lt;/ul>
&lt;h2 id="결론">결론&lt;/h2>
&lt;ul>
&lt;li>구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.&lt;/li>
&lt;li>객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.&lt;/li>
&lt;li>함수형 프로그래밍은 변수 할당에 부과되는 규율이다.&lt;/li>
&lt;/ul>
&lt;p>세 패러다임 모두 무언가를 하지 못하게 제한하고 있으며, 코드를 작성하는 방식의 형태를 한정시킨다.&lt;/p>
&lt;p>지난 반세기 동안 우리가 배운 것은 &lt;strong>해서는 안되는 것&lt;/strong>에 대해서이다.&lt;/p>
&lt;p>도구는 달라졌고 소프트웨어도 변했지만, 소프트웨어는 순차, 분기, 반복 참조로 구성된다는 것은 변하지 않았다.&lt;/p></description></item><item><title>5. 객체 지향 프로그래밍</title><link>https://codemario318.github.io/post/clean-architecture/5/</link><pubDate>Sun, 25 Feb 2024 17:46:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/5/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/5/cover.png" alt="Featured image of post 5. 객체 지향 프로그래밍" />&lt;p>좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는 데서 출발한다.&lt;/p>
&lt;h2 id="object-oriented란-무엇인가">Object Oriented란 무엇인가?&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>데이터와 함수의 조합&lt;/strong>
&lt;ul>
&lt;li>대체로 이런 방식으로 많이 설명되지만 만족스러운 대답은 아니다.&lt;/li>
&lt;li>&lt;code>o.f()&lt;/code>가 &lt;code>f(o)&lt;/code>와 다르다는 의미를 내포한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>실제 세계를 모델링하는 새로운 방법&lt;/strong>
&lt;ul>
&lt;li>얼버무리는 수준에 지나지 않는다. 의도가 불분명하며, 정의가 너무 모호하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>캡슐화, 상속, 다형성
&lt;ul>
&lt;li>세가지 개념을 적절하게 조합한 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="캡슐화encapsulation">캡슐화(Encapsulation)?&lt;/h2>
&lt;p>OO를 정의하는 요소 중 하나로 캡슐화를 언급하는 이유는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 OO 언어가 제공하기 때문이다.&lt;/p>
&lt;p>이를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>private&lt;/code>, &lt;code>public&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>하지만 이러한 개념은 OO에만 국한된 것은 아니다.&lt;/p>
&lt;p>&lt;strong>point.h&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">makePoint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">double&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">double&lt;/span> &lt;span class="nf">distance&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>point.c&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;point.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;math.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">makepoint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">double&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">double&lt;/span> &lt;span class="nf">distance&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">dx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p1&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">p2&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">dy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p1&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">p2&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nf">sqrt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dx&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">dx&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">dy&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">dy&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위 예시에서 &lt;code>point.h&lt;/code>를 사용하는 측에서 &lt;code>struct Point&lt;/code>의 멤버에 접근할 방법이 전혀 없다.&lt;/p>
&lt;ul>
&lt;li>사용자는 &lt;code>makePoint()&lt;/code> 함수와 &lt;code>distance()&lt;/code> 함수를 호출할 수는 있지만, &lt;code>Point&lt;/code> 구조체의 데이터 구조와 함수가 어떻게 구현되었는지에 대해서는 조금도 알지 못한다.&lt;/li>
&lt;/ul>
&lt;p>이것이 완벽한 캡슐화이며, OO가 아닌 언어에서도 충분히 가능하다.&lt;/p>
&lt;p>오히려 OO를 지원하는 언어들이 캡슐화를 훼손하고 있는 경우가 많아 언어에 &lt;code>public&lt;/code>, &lt;code>private&lt;/code>, &lt;code>protected&lt;/code> 키워드를 도입하여 불완전한 캡슐화를 보완한다.&lt;/p>
&lt;ul>
&lt;li>C++는 컴파일러가 클래스의 인스턴스 크기를 알아야하는 기술적인 이유로 클래스의 멤버변수를 해당 클래스의 헤더파일에 선언해야하고, 이로인해 사용측에서 멤버변수의 존재를 알게된다.&lt;/li>
&lt;li>자바, C#은 헤더와 구현체를 분리하는 방식을 버렸다. 이로인해 클래스 선언과 정의를 구분하는게 불가능하다.&lt;/li>
&lt;/ul>
&lt;p>이 때문에 OO가 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들며, 대부분의 OO를 제공하는 언어들이 실제로는 C언어에서 누렸던 완벽한 캡슐화를 약화시켰다.&lt;/p>
&lt;ul>
&lt;li>많은 언어가 캡슐화를 거의 강제하지 않는다.&lt;/li>
&lt;li>OO 프로그래밍은 프로그래머가 캡슐화를 우회하지 않을 것 이라는 믿음을 기반으로 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="상속">상속?&lt;/h2>
&lt;p>OO 언어가 더 나은 캡슐화를 제공하지는 못했지만, 상속만큼은 확실히 제공했다.&lt;/p>
&lt;p>하지만 상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어 재정의하는 일에 불과하다.&lt;/p>
&lt;p>&lt;strong>namedPoint.h&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">makeNamedPoint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">double&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">setName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">getName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>namedPoint.c&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;NamedPoint.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">makeNmaedPoint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">double&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">setName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">np&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">getName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">NmaedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>main.c&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;point.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;namedPoint.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">ac&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">**&lt;/span> &lt;span class="n">av&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">origin&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">makeNamedPoint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">0.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;origin&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">upperRight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">makeNamedPoint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">1.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">1.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;upperRight&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;distance=%f&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">distance&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">origin&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// namedPoint를 point로 쓰고있음
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">upperRight&lt;/span> &lt;span class="c1">// namedPoint를 point로 쓰고있음
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>main&lt;/code> 프로그램을 살펴보면 &lt;code>NamedPoint&lt;/code> 데이터 구조가 &lt;code>Point&lt;/code> 데이터 구조로부터 파생된 구조인 것 처럼 동작한다는 사실을 볼 수 있다.&lt;/p>
&lt;p>이처럼 눈속임처럼 보이는 방식은 OO가 출현하기 이전부터 프로그래머가 흔히 사용했던 기법이다. 실제로 C++은 이 방법을 이용해 단일 상속을 구현하였다.&lt;/p>
&lt;p>OO 언어가 고안되기 훨씬 이전에도 상속과 비슷한 기법이 사용되었지만, 상속만큼 편리한 방식은 절대 아니다.&lt;/p>
&lt;p>따라서 OO 언어가 완전히 새로운 개념을 만들지는 못했지만, 상당히 편리한 방식으로 제공했다고 볼 수 있다.&lt;/p>
&lt;h2 id="다형성">다형성?&lt;/h2>
&lt;p>OO 언어가 있기 이전에도 다형성을 표현할 수 있었다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">copy&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">getchar&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">EOF&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">putchar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>getchar()&lt;/code>는 &lt;code>STDIN&lt;/code>에서 문자를 읽고, &lt;code>putchar()&lt;/code>는 &lt;code>STDOUT&lt;/code>으로 문자를 쓴다.&lt;/p>
&lt;p>&lt;code>STDIN&lt;/code>과 &lt;code>STDOUT&lt;/code>은 다양한 장치가 될 수 있기 때문에 이러한 함수는 다형적(Polymorphic)이다.&lt;/p>
&lt;p>유닉스 운영체제의 경우 모든 입출력 장치 드라이버가 다섯 가지 표준 함수를 제공할 것을 요구한다&lt;/p>
&lt;ul>
&lt;li>&lt;code>open&lt;/code>, &lt;code>close&lt;/code>, &lt;code>read&lt;/code>, &lt;code>write&lt;/code>, &lt;code>seek&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>FILE&lt;/code> 데이터 구조는 이들 다섯 함수를 가리키는 포인터들을 포함한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">FILE&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">open&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">close&lt;/span>&lt;span class="p">)();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="p">)();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">write&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">seek&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>입출력 드라이버에서는 이들 함수를 아래와 같이 전의하며, &lt;code>FILE&lt;/code> 데이터 구조를 함수에 대한 주소와 함께 로드한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;file.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="cm">/* ... */&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">close&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="cm">/* ... */&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">read&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* ... */&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="cm">/* ... */&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">seek&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="cm">/* ... */&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">FILE&lt;/span> &lt;span class="n">console&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">open&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">close&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">write&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">seek&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>STDIN&lt;/code>을 &lt;code>FILE*&lt;/code>로 선언하면 콘솔 데이터 구조를 가리키므로, &lt;code>getchar()&lt;/code>는 아래와 같은 방식으로 구현할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">extern&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">FILE&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">STDIN&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">getchar&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">STDIN&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="nf">read&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>다시말해 &lt;code>getchar()&lt;/code>는 &lt;code>STDIN&lt;/code>으로 참초되는 &lt;code>FILE&lt;/code> 데이터 구조의 &lt;code>read&lt;/code> 포인터가 가르키는 함수를 단순히 호출할 뿐이다.&lt;/p>
&lt;p>이처럼 단순한 기법이 모든 OO가 지는 다형성이 근간이 되며, 즉 함수를 가리키는 포인터를 응용한 것이 다형성이고 OO가 새롭게 만든 개념이 아니다.&lt;/p>
&lt;p>하지만, OO 언어는 좀 더 안전하고 편리하게 사용할 수 있게 해준다.&lt;/p>
&lt;ul>
&lt;li>함수 포인터를 사용하기 위한 관례들을 없애 실수할 위험이 없다.&lt;/li>
&lt;/ul>
&lt;p>OO는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론 지을 수 있다. (??)&lt;/p>
&lt;h3 id="다형성이-가진-힘">다형성이 가진 힘&lt;/h3>
&lt;p>복사 프로그램 예제에서 새로운 입출력 장치가 생겨도 프로그램의 아무런 변경이 필요하지 않다.&lt;/p>
&lt;ul>
&lt;li>복사 프로그램의 소스 코드는 입출력 드라이버의 소스 코드에 의존하지 않기 때문이다.&lt;/li>
&lt;li>입출력 드라이버가 &lt;code>FILE&lt;/code>에 정의된 다섯가지 표준 함수를 구현한다면, 복사 프로그램에서는 어떠한 입출력 드라이버도 사용할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>플러그인 아키텍처(Plugin architecture)&lt;/strong>&lt;/p>
&lt;p>플러그인 아키텍처는 이처럼 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다.&lt;/p>
&lt;p>그런데도 대다수의 프로그래머는 함수 포인터의 위험함 때문에 이러한 개념을 확장하여 적용하지 않았는데, OO의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.&lt;/p>
&lt;h3 id="의존성-역전">의존성 역전&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/5/img_1.png"
width="437"
height="218"
srcset="https://codemario318.github.io/post/clean-architecture/5/img_1_hu9d7ba88c223125c910483171079777bc_7404_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/5/img_1_hu9d7ba88c223125c910483171079777bc_7404_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="소스 코드 의존성 vs. 제어흐름"
class="gallery-image"
data-flex-grow="200"
data-flex-basis="481px"
>&lt;/p>
&lt;p>다형성을 안전하고 편리하게 적용할 수 있기 전에는 &lt;code>main&lt;/code> 함수가 고수준 함수를 호출하고, 고수준 함수는 다시 중간 수준 함수를, 중간 수준 함수는 저수준 함수를 호출한다.&lt;/p>
&lt;p>이로인해 소스 코드 의존성의 방향은 반드시 제어흐름을 따르게 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/5/img.png"
width="694"
height="280"
srcset="https://codemario318.github.io/post/clean-architecture/5/img_hu57338117272e8a2dea8d6af8f8d33249_6758_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/5/img_hu57338117272e8a2dea8d6af8f8d33249_6758_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="의존성 역전"
class="gallery-image"
data-flex-grow="247"
data-flex-basis="594px"
>&lt;/p>
&lt;p>하지만 다형성을 활용하면 의존성의 방향이 바뀐다.&lt;/p>
&lt;p>&lt;code>HL1&lt;/code> 모듈은 &lt;code>ML1&lt;/code> 모듈의 &lt;code>F()&lt;/code> 함수를 호출한다. 하지만 &lt;code>ML1&lt;/code>과 &lt;code>I&lt;/code> 인터페이스 사이의 소스 코드 의존성(상속 관계)이 제어흐름과는 반대이다.&lt;/p>
&lt;p>이는 의존성 역전(Dependency inversion)이라고 부르며, 소프트웨어 아키텍처 관점에서 이러한 현상은 &lt;strong>소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻&lt;/strong>이기도 하다.&lt;/p>
&lt;p>이러한 접근법을 사용한다면, OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대한 방향을 결정할 수 있는 절대적인 권한을 가지게 된다.&lt;/p>
&lt;ul>
&lt;li>소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다.&lt;/li>
&lt;li>호출하는 모듈이든 호출 받는 모듈이든 관계없이 소스 코드 의존성을 원하는 방향으로 설정할 수 있다.&lt;/li>
&lt;/ul>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
a[UI]
b[Business Rules]
c[Database]
a-->b
b-.->a
c-->b
b-.->c
&lt;/pre>
&lt;p>위 와 같은 경우 업무 규칙이 데이터베이스와 UI에 의존하는 대신에, 시스템의 소스코드 의존성을 반대로 배치하여 데이터베이스와 UI가 업무 규칙에 의존하게 만들 수 있다.&lt;/p>
&lt;ul>
&lt;li>UI와 데이터베이스가 업무 규칙의 플러그인이 된다는 뜻이다.&lt;/li>
&lt;li>업무 규칙의 소스 코드에서는 UI나 데이터베이스를 호출하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>결과적으로 업무 규칙, UI, 데이터베이스는 세 가지로 분리된 컴포넌트 또는 배포 가능한 단위로 컴파일할 수 있고, 의존하지 않기 때문에 각 컴포넌트들을 독립적으로 배포할 수 있다.&lt;/p>
&lt;ul>
&lt;li>특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포한다.&lt;/li>
&lt;li>이를 배포 독립성(Independent deployability)이라고 한다.&lt;/li>
&lt;li>시스템의 모듈을 독립적으로 배포할 수 있게 되면, 다른 팀에서 각 모듈을 독립적으로 개발할 수 있고, 이것을 개발 독립성 이라 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>소프트웨어 아키텍트 관점에서 OO란 다형성을 이용하여 전체 시스템의 모든 소스코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.&lt;/p>
&lt;p>OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 전책을 포함하는 모듈은 저수순의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.&lt;/p>
&lt;p>저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.&lt;/p></description></item><item><title>4. 구조적 프로그래밍</title><link>https://codemario318.github.io/post/clean-architecture/4/</link><pubDate>Tue, 20 Feb 2024 20:33:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/4/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/4/cover.png" alt="Featured image of post 4. 구조적 프로그래밍" />&lt;p>구조적 프로그래밍(Structured Programming)은 프로그래밍의 한 접근 방법으로, 프로그램을 작성할 때 제어 흐름을 구조화하여 코드를 보다 이해하기 쉽고 유지 보수하기 쉽게 만들려는 것을 중점으로한다.&lt;/p>
&lt;p>구조적 프로그래밍은 프로그래밍 분야에서 중요한 발전 중 하나로, 초기 프로그래밍 방법론이 가진 한계(복잡성, 프로그래밍 실수, 소프트웨어 신뢰성 등)를 극복하고자 탄생하였다.&lt;/p>
&lt;h2 id="goto문의-해로움">&lt;code>goto&lt;/code>문의 해로움&lt;/h2>
&lt;p>구조적 프로그래밍을 발견한 데이크스트라는 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘하지 못한다고 생각하였는제 아래와 같은 이유가 원인이라고 생각했다.&lt;/p>
&lt;ul>
&lt;li>모든 프로그램은 단순할지라도 너무 많은 세부사항을 담고 있었다.&lt;/li>
&lt;li>아주 작은 세부사항이라도 간과하면 예상 외의 방식으로 실패하곤 했다.&lt;/li>
&lt;/ul>
&lt;p>데이크스트라는 &lt;strong>증명&lt;/strong>이라는 수학적인 원리를 적용하여 이러한 문제를 해결하려고자 했고, 수학자가 유클리드 계층구조를 사용하여 증명하는 방식을 프로그래머도 사용할 수 있다고 믿었다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>유클리드 계층구조&lt;/strong>&lt;br>
공리(axiom)는 증명 없이 참으로 받아들이는 명제를 뜻한다.&lt;/p>
&lt;p>정리(theorem)는 증명이라는 과정을 통해 참이라는 것이 밝혀진 명제다.&lt;/p>
&lt;p>이러한 정리를 증명하는 데 필요한 정리를 보조정리(lemma)로 부르며, 정리를 통해 자연스럽게 도출되는 정리를 따름정리(corollary)라고 부른다.&lt;/p>
&lt;/blockquote>
&lt;p>이를 위한 연구를 진행하면서 합리적인 증명을 위한 분할 정복 접근법을 적용하려 했는데 &lt;code>goto&lt;/code> 문장을 이용한 제어 흐름 전환이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 된다는 것을 발견하였다.&lt;/p>
&lt;p>반면 &lt;code>goto&lt;/code> 문장을 사용하더라도 모듈을 분해할 때 문제가 되지 않는 경우는 &lt;code>if/then/else&lt;/code>와 &lt;code>do/while&lt;/code> 같은 분기와 반복이라는 단순한 제어 구조에 해당한다는 사실을 발견했다.&lt;/p>
&lt;p>다익스트라는 제어 구조가 순차 실행(Sequential execution)과 결합해야 한다고 깨닳았다.&lt;/p>
&lt;h2 id="structured-program-theoremhttpsenwikipediaorgwikistructured_program_theorem">&lt;a class="link" href="https://en.wikipedia.org/wiki/Structured_program_theorem" target="_blank" rel="noopener"
>Structured program theorem&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/4/img.png"
width="700"
height="117"
srcset="https://codemario318.github.io/post/clean-architecture/4/img_hu2203a586a82df95cc8044769f2a6a61e_7549_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/4/img_hu2203a586a82df95cc8044769f2a6a61e_7549_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="598"
data-flex-basis="1435px"
>&lt;/p>
&lt;p>&lt;strong>Böhm–Jacopini 정리&lt;/strong>라고도 불리는 구조적 프로그래밍 정리는 프로그램을 작성하는 데 사용되는 모든 제어 구조를 표한할 수 있는 최소한의 구조가 있음을 보여준다.&lt;/p>
&lt;ul>
&lt;li>순차(Sequence)
&lt;ul>
&lt;li>프로그램의 각 문장들은 순차적으로 실행&lt;/li>
&lt;li>어떤 작업을 차례대로 수행하는 것을 의미함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>분기(Selection)
&lt;ul>
&lt;li>조건문을 사용하여 프로그램의 흐름을 분기&lt;/li>
&lt;li>조건에 따라 다른 명령문 또는 블록을 실행&lt;/li>
&lt;li>일반적으로 &lt;code>if-else&lt;/code>문이나 &lt;code>switch-case&lt;/code>문을 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>반복(Iteration)
&lt;ul>
&lt;li>루프를 사용하여 특정 조건이 충족될 때까지 특정한 명령문 또는 블록을 반복하여 실행&lt;/li>
&lt;li>대표적으로는 &lt;code>for&lt;/code>루프나 &lt;code>while&lt;/code>루프&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 제어 구조들이 모든 프로그램을 작성하는 데 필요한 최소한의 구조라는 것을 보여주며, 즉 어떤 프로그램이라도 세 가지 구조로 구현할 수 있다는 것을 의미한다.&lt;/p>
&lt;h2 id="기능적-분해">기능적 분해&lt;/h2>
&lt;p>구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 분해할 수 있게 되었다.&lt;/p>
&lt;ul>
&lt;li>이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻하며, 거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있다.&lt;/li>
&lt;li>분해한 기능들은 구조적 프로그래밍의 &lt;strong>제한된 제어구조&lt;/strong>를 이용하여 표현할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이를 토대로 구조적 분석이나 구조적 설계와 같은 기법이 인기를 끌었으며, 개선되어 널리 알려졌다.&lt;/p>
&lt;ul>
&lt;li>대규모 시스템을 모듈과 컴포넌트로 나눌 수 있다.&lt;/li>
&lt;li>모듈과 컴포넌트는 입증할 수 있는 작은 기능들로 세분화할 수 있다.&lt;/li>
&lt;/ul>
&lt;h2 id="과학적-방법scientific-method">과학적 방법(Scientific Method)&lt;/h2>
&lt;blockquote>
&lt;p>테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄수는 없다.&lt;/p>
&lt;/blockquote>
&lt;p>소프트웨어 개발이 수학적인 구조를 다루는 듯 보이더라도, 소프트웨어 개발은 수학적인 시도가 아니다.&lt;/p>
&lt;p>오히려 올바르지 않음을 증명하는 데 실패함으로 올바름을 보여주는 과학과 같다.&lt;/p>
&lt;p>이러한 부정확함에 대한 증명은 입증 가능한 프로그램에만 적용할 수 있으며, 구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다.&lt;/p>
&lt;p>그러고 나서 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도하며, 거짓임을 증명하는 테스트가 실패한다면, 충분히 참이라고 여기게 된다.&lt;/p>
&lt;h2 id="현대적-가치">현대적 가치&lt;/h2>
&lt;p>구조적 프로그래밍에 대한 논의는 많은 새로운 언어를 낳았으며, 기존의 언어에 구조적인 면이 추가되는 등 언어의 발전에 도움이 되었다. 그리고 이후에 나온 프로그래밍 패러다임들에도 영향을 끼쳤다.&lt;/p>
&lt;p>구조적 프로그래밍은 프로그래머의 습관을 바꾸었다.&lt;/p>
&lt;p>프로그램의 정확성을 증명하는 문제를 떠나서 데이크스트라가 그의 논문에서 말한 대로 시간에 따라 변하는 동적인 과정을 시각화하는 것은 인간에게 매우 어려운 일이다.&lt;/p>
&lt;p>꼭 &lt;code>GOTO&lt;/code>문만의 문제가 아니라 구조화된 흐름 제어문을 사용한다고 할지라도 너무 복잡하게 중첩되어 있거나 스코프의 길이가 너무 긴 코드를 작성한다거나 너무 긴 길이의 하위프로그램을 작성하는 일을 가급적 피하게 경향이 생겼다.&lt;/p>
&lt;p>그리고 이런 습관은 다른 사람이 작성한 프로그래밍 코드를 쉽게 이해하는 데 도움을 준다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;ul>
&lt;li>구조적 프로그래밍이 가치있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력 때문이다.&lt;/li>
&lt;li>가작 작은 기능에서 부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 반증 가능성에 의해 주도된다.&lt;/li>
&lt;li>스프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기위해 노력해야 한다.&lt;/li>
&lt;li>구조적 프로그래밍과 유사한 제한적인 규칙들을 통해 쉽게 반증 가능한 구조를 만들 수 있다.&lt;/li>
&lt;/ul></description></item><item><title>3. 패러다임 개요</title><link>https://codemario318.github.io/post/clean-architecture/3/</link><pubDate>Sun, 18 Feb 2024 19:54:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/3/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/3/cover.png" alt="Featured image of post 3. 패러다임 개요" />&lt;h2 id="구조적-프로그래밍">구조적 프로그래밍&lt;/h2>
&lt;blockquote>
&lt;p>구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.&lt;/p>
&lt;/blockquote>
&lt;p>최초로 적용된 패러다임(최초로 만들어진 패러다임은 아님)으로 1968년 에츠허르 비버 데이크스트라가 발견했다.&lt;/p>
&lt;ul>
&lt;li>무분별한 점프(&lt;code>goto&lt;/code> 문장)는 프로그램 구조에 해롭다는 사실을 제시함&lt;/li>
&lt;li>이러한 점프들을 &lt;code>if/then/else&lt;/code>, &lt;code>do/while/until&lt;/code>과 같이 더 익숙한 구조로 대체함&lt;/li>
&lt;/ul>
&lt;h2 id="객체-지향-프로그래밍">객체 지향 프로그래밍&lt;/h2>
&lt;blockquote>
&lt;p>객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.&lt;/p>
&lt;/blockquote>
&lt;p>두 번째로 도입된 패러다음으로 구조적 프로그래밍보다 2년 앞선 1966년 올레 요한 달과 크리스텐 니가드에 의해 등장했다.&lt;/p>
&lt;p>알골(ALGOL) 언어의 함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지될 수 있음을 발견했다.&lt;/p>
&lt;ul>
&lt;li>이러한 함수가 클래스의 생성자가 되었고, 지역 변수는 인스턴스 변수, 중첩 함수는 메서드가 되었다.&lt;/li>
&lt;li>함수 포인터를 특정 규칙에 따라 사용하는 과정을 통해 필연적으로 다형성이 등장하게 되었다.&lt;/li>
&lt;/ul>
&lt;h2 id="함수형-프로그래밍">함수형 프로그래밍&lt;/h2>
&lt;blockquote>
&lt;p>함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.&lt;/p>
&lt;/blockquote>
&lt;p>최근에 들어서야 겨우 도입되기 시작했지만 가장 먼저 만들어졌다.&lt;/p>
&lt;p>알론조 처치는 앨런 튜링도 똑같이 흥미를 느꼈던 수학적 문제를 해결하는 과정에서 람다(Lambda) 계산법을 발명했는데, 함수형 프로그래밍은 이러한 연구 결과에 직접적인 영향을 받아 만들어졌다.&lt;/p>
&lt;p>1958년에 존 매카시가 만든 LISP 언어에 근간이 되는 개념이 바로 이 람다 계산법이다.&lt;/p>
&lt;ul>
&lt;li>람다 계산법의 기초가 되는 개념은 불변성으로, 심볼의 값이 변경되지 않는다는 개념이다.&lt;/li>
&lt;li>이는 함수형 언어에는 할당문이 전혀 없다는 뜻이기도 하다.&lt;/li>
&lt;li>대다수의 함수형 언어가 변수값을 변경할 수 있는 방법을 제공하기는 하지만, 굉장히 까다로운 조건 아래서만 가능하다.&lt;/li>
&lt;/ul>
&lt;h2 id="생각할-거리">생각할 거리&lt;/h2>
&lt;p>각 패러다임은 프로그래머에게서 권한을 박탈한다. 어느 패러다임도 새로운 권한을 부여하지 않는다.&lt;/p>
&lt;ul>
&lt;li>각 패러다임은 추가적인 규칙을 통해 특정 행동들을 하지 못하게 제약한다.&lt;/li>
&lt;li>패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안되는지를 말해준다.&lt;/li>
&lt;/ul>
&lt;p>각 패러다임이 우리에게서 무언가를 빼앗는다는 사실을 인지하는 것이다.&lt;/p>
&lt;ul>
&lt;li>구조적 프로그래밍: &lt;code>goto&lt;/code>문&lt;/li>
&lt;li>객체 지향 프로그래밍: 함수 포인터&lt;/li>
&lt;li>함수형 프로그래밍: 할당문&lt;/li>
&lt;/ul>
&lt;p>이 외에 개발자에게 가져갈 수 있는 것이 남아있지 않으므로, 프로그래밍 패러다임은 앞으로도 세 가지 밖에 없을 것이다.&lt;/p>
&lt;ul>
&lt;li>패러다임이 10년 동안 모두 만들어진 이후 수십 년이 지났지만 새롭게 등장한 패러다임은 전혀 없다.&lt;/li>
&lt;/ul>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>패러다임의 역사로부터 얻을 수 있는 이러한 교훈은 아키텍처와 큰 관계가 있다.&lt;/p>
&lt;ul>
&lt;li>아키텍처 경계를 넘나들기 위한 메커니즘으로 다형성을 이용한다.&lt;/li>
&lt;li>함수형 프로그래밍을 이용하여 데이터의 위치와 접근 방법에 대해 규칙을 부과한다.&lt;/li>
&lt;li>모듈 기반 알고리즘으로 구조적 프로그래밍을 사용한다.&lt;/li>
&lt;/ul>
&lt;p>세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목하자.&lt;/p></description></item><item><title>2. 두 가지 가치에 대한 이야기</title><link>https://codemario318.github.io/post/clean-architecture/2/</link><pubDate>Sun, 18 Feb 2024 19:03:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/2/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/2/cover.png" alt="Featured image of post 2. 두 가지 가치에 대한 이야기" />&lt;p>모든 소프트웨어 시스템은 이해관계자에게 행위(Behavior)와 구조(Structure)라는 두가지 가치를 제공한다.&lt;/p>
&lt;p>따라서 소프트웨어 개발자는 두 가치를 모두 반드시 높게 유지해야 하는 책임을 진다.&lt;/p>
&lt;p>하지만 한 가지 가치에만 집중하고 나머지 가치는 배제하곤 하며, 대체로 덜 중요한 가치에 집중하여 결국에는 소프트웨어 시스템이 쓸모 없게 만들어버린다.&lt;/p>
&lt;h2 id="행위기능">행위(기능)&lt;/h2>
&lt;p>프로그래머를 고용하는 이유는 이해관계자를 위해 기계가 수익을 창출하거나 비용을 절약하도록 만들기 위해서이다.&lt;/p>
&lt;ul>
&lt;li>이해관계자가 기능 명세서나 요구사항 문서를 구체화할 수 있도록 돕는다.&lt;/li>
&lt;li>이해관계자의 기계가 이러한 요구사항을 만족하도록 코드를 작성한다.
&lt;ul>
&lt;li>요구사항을 위반하면 문제를 고친다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>행위는 개발자가 구현해야하는 기능을 의미하며, 기능을 구현하고 만들어진 기능을 운영하는 것만을 개발자의 역할이라고 생각한다.&lt;/p>
&lt;h2 id="아키텍처">아키텍처&lt;/h2>
&lt;p>소프트웨어라는 단어는 부드러운(soft)과 제품(ware)의 합성어이다.&lt;/p>
&lt;p>소프트웨어는 부드러움을 지니도록 만들어졌으며, 소프트웨어를 만든 이유는 기계의 행위를 쉽게 변경할 수 있도록 하기 위해서이다.&lt;/p>
&lt;p>따라서 소프트웨어가 가진 본연의 목적을 추구하려면 소프트웨어는 반드시 부드러움, 즉 변경이 쉬워야하며 이해관계자가 기능에 대한 생각을 바꾸면 이러한 변경사항을 간단하고 쉽게 적용할 수 있어야 한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>변경사항을 적용하는 데 드는 어려움은 변경되는 범위에 비례해야하며, 변경사항의 형태와는 관련이 없어야 한다.&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>소프트웨어 개발 비용의 증가를 결정짓는 주된 요인은 바로 변경사항의 범위와 형태의 차이에 있다.&lt;/p>
&lt;p>이해관계자는 범위가 비슷한 일련의 변경사항을 제시할 뿐이지만, 개발자 입장에서는 복잡도가 지속적으로 증가하는 퍼즐 판 위에서 이해관계자가 계속해서 퍼즐 조각을 맞추라는 지시를 하는 것처럼 느낀다.&lt;/p>
&lt;p>이는 시스템의 형태와 요구사항의 형태가 서로 맞지 않기 때문인데, 원인은 소프트웨어 아키텍처다.&lt;/p>
&lt;p>아키텍처가 특정 형태를 다른 형태보다 선호하면 할수록, 새로운 기능을 이 구조에 맞추는 게 더 힘들어진다.&lt;/p>
&lt;p>&lt;strong>따라서 아키텍처는 항상 형태에 독립적이어야하고, 그럴수록 더 실용적이다.&lt;/strong>&lt;/p>
&lt;h2 id="더-높은-가치">더 높은 가치&lt;/h2>
&lt;p>기능과 아키텍처 둘 중 어느 것의 가치가 더 높은지 업무 관리자에게 묻는다면, 대다수가 소프트웨어 시스템이 동작하는 것이 더 중요하다고 대답하지만, 개발자는 아키텍처에 더 가치를 둬야한다.&lt;/p>
&lt;p>&lt;strong>양 극단 사례 검토&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>완벽하게 동작하지만 수정이 불가능한 프로그램은 요구사항이 변경될 때 동작하지 않게 되어 쓸모가 없다.&lt;/li>
&lt;li>동작은 하지 않니만 변경이 쉬운 프로그램은 개발자가 돌아가도록 만들 수 있고, 변경사항이 발생하더라도 여전히 동작하여 유용한채로 남는다.&lt;/li>
&lt;/ul>
&lt;p>변경에 드는 비용이 변경으로 창출되는 수익을 초과하는 경우 수정이 현실적으로 불가능하며, 이로 인해 기능 또는 설정 측면에서 만은 시스템이 현실적으로 수정할 수 없는 상황에 빠진다.&lt;/p>
&lt;p>현재의 기능 동작을 위해 미래의 유연성을 희생한다면, 변경에 드는 비용이 높아지게되어 현실적으로 수정할 수 없는 상황에 빠지게되고, 결과적으로 책임은 개발자에게 돌아간다.&lt;/p>
&lt;h2 id="아이젠하워-매트릭스">아이젠하워 매트릭스&lt;/h2>
&lt;p>긴급한 문제가 아주 중요한 문제일 경우는 드물고, 중요한 문제가 몹시 긴급한 경우는 거의 없다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/2/img.png"
width="1440"
height="1476"
srcset="https://codemario318.github.io/post/clean-architecture/2/img_hub52f30903063439618abfbc9fbd0cd5f_559836_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/2/img_hub52f30903063439618abfbc9fbd0cd5f_559836_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="아이젠하워 매트릭스"
class="gallery-image"
data-flex-grow="97"
data-flex-basis="234px"
>&lt;/p>
&lt;ol>
&lt;li>긴급 O, 중요 O&lt;/li>
&lt;li>긴급 X, 중요 O&lt;/li>
&lt;li>긴급 O, 중요 X&lt;/li>
&lt;li>긴급 X, 중요 X&lt;/li>
&lt;/ol>
&lt;p>아이젠하워 매트릭스에서는 위와 같은 우선순위로 문제를 해결할 것을 제안하고 있다.&lt;/p>
&lt;hr>
&lt;p>첫 번째 가치인 행위는 대부분 긴급하지만 매번 높은 중요도를 가지는 것은 아니며, 두 번째 가치인 아키텍처는 중요하지만 즉각적인 긴급성을 필요로 하는 경우는 절대 없다.&lt;/p>
&lt;p>아키텍처는 1, 2를 차지하는 반변, 행위는 1, 3에 위치한다.&lt;/p>
&lt;p>많은 업무 관리자와 개발자가 3번에 위치한 항목을 1번으로 격상시키는 실수를 많이 한다.&lt;/p>
&lt;ul>
&lt;li>긴급하지만 중요하지 않은 기능과 진짜로 긴급하면서 주용한 기능을 구분하지 못한다.&lt;/li>
&lt;/ul>
&lt;p>이러한 실패로 중요도가 높은 아키텍처를 무시한 채 중요도가 떨어지는 기능을 선택하게 된다.&lt;/p>
&lt;h2 id="아키텍처를-위해-투쟁하라">아키텍처를 위해 투쟁하라&lt;/h2>
&lt;p>더 중요한 가치인 아키텍처가 더 낮은 우선순위를 가지게 되는 이유는 대부분의 업무 관리자가 아키텍처의 중요성을 평가하지 못하기 때문이다.&lt;/p>
&lt;p>따라서 개발자, 개발팀은 다른 이해관계자들을 설득해야 할 의무가 있다.&lt;/p>
&lt;ul>
&lt;li>기능의 긴급성이 아닌 아키텍처의 중요성을 설득하는 일은 소프트웨어 개발팀이 책임을 져야한다.&lt;/li>
&lt;li>소프트웨어 개발자도 이해관계자이며, 소프트웨어를 안전하게 보호해야 할 책임이 있다.&lt;/li>
&lt;/ul>
&lt;p>소프트웨어 아키텍트는 시스템이 제공하는 특성이나 기능보다는 시스템의 구조에 더 중점을 둔다. 아키텍트는 이러한 특성과 기능을 개발하기 쉽고, 간편하게 수정할 수 있으며, 확장하기 쉬운 아키텍처를 만들어야 한다.&lt;/p>
&lt;p>개발자가 아키텍처에 더 높은 우선순위를 둘 수 있도록 이해관계자들과 투쟁하는 것은 장기적인 관점에서 더 나은 소프트웨어를 만들 수 있는 가능성을 높힌다.&lt;/p>
&lt;hr>
&lt;p>아키텍처가 후순위가 되면 시스템을 개발하는 비용이 점점 더 많이 들게되고, 결국 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 힘들어진다.&lt;/p>
&lt;p>이러한 상황이 발생하도록 용납했다면, 이는 결국 소프트웨어 개발팀이 스스로 옳다고 믿는 가치를 위해 충분히 투쟁하지 않았다는 뜻이다.&lt;/p></description></item><item><title>1. 설계와 아키텍처란?</title><link>https://codemario318.github.io/post/clean-architecture/1/</link><pubDate>Sun, 18 Feb 2024 18:09:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/1/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/1/cover.png" alt="Featured image of post 1. 설계와 아키텍처란?" />&lt;h2 id="설계와-아키텍처의-차이">설계와 아키텍처의 차이&lt;/h2>
&lt;p>설계(Design)와 아키텍처(Architecture)의 정의가 모호하여 오랫동안 많은 혼란이 있었지만 실제로는 둘의 차이는 없다.&lt;/p>
&lt;ul>
&lt;li>아키텍처는 저수준 세부사항과는 분리된 고수준의 무언가를 가릴킬 때 흔히 사용된다.&lt;/li>
&lt;li>설계는 저수준의 구조 또는 결정사항 등을 의미할 때가 많다.&lt;/li>
&lt;/ul>
&lt;p>하지만 아키텍트가 실제로 하는 일을 살펴보면 이러한 구분은 무의미하다.&lt;/p>
&lt;h3 id="새로운-집">새로운 집&lt;/h3>
&lt;p>새로운 집을 설계하는 아키텍트가 있다면 이 집의 아키텍처는 형태, 외관, 입면도, 공간이나 방의 배치등이 포함된다.&lt;/p>
&lt;p>하지만 아키텍트가 만든 도면을 살펴보면 콘센트, 전등 스위치, 전등이 모두 어디에 위치하는 지 등 세부사항도 모두 확인할 수 있으며, 벽, 지붕 기초 공사등이 어떻게 진행될지도 상세히 확인할 수 있다.&lt;/p>
&lt;p>이처럼 모든 고수준의 결정사항을 지탱하는 &lt;strong>모든 세부사항&lt;/strong>과 &lt;strong>고수준의 결정사항&lt;/strong>은 집의 전체 설계의 구성요소가 된다.&lt;/p>
&lt;p>소프트웨어 설계도 마찬가지로, 저수준의 세부사항과 고수준의 구조는 모두 소프트웨어 전체 설계의 구성요소다.&lt;/p>
&lt;p>저수준 세부사항과 고수준 세부사항은 &lt;strong>단절 없이 이어진 직물&lt;/strong>과 같으며, 이를 통해 대상 시스템의 구조를 정의한다.&lt;/p>
&lt;blockquote>
&lt;p>이 둘은 개별로 존재할 수 없으며, 경계 또한 뚜렸하지 않고 &lt;strong>고수준에서 저수준으로 향하는 의사결정의 연속성만이 있을 뿐이다.&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;h2 id="목표는">목표는?&lt;/h2>
&lt;p>이러한 의사결정, 좋은 소프트웨어 설계 즉 소프트웨어 아키텍처의 목표는 &lt;strong>필요한 시스템을 만드록 유지보수하는데 투입되는 인력을 최소화하는 데 있다.&lt;/strong>&lt;/p>
&lt;p>설계 품질의 척도는 고객의 &lt;strong>요구를 만족시키는 데 드는 비용&lt;/strong> 척도와 다름 없다.&lt;/p>
&lt;ul>
&lt;li>비용이 낮을 뿐만 아니라 시스템의 수명이 다할 때까지 &lt;strong>낮게 유지할 수 있다면 좋은 설계&lt;/strong>라고 말할 수 있다.&lt;/li>
&lt;li>새로운 기능을 출시할 때 마다 &lt;strong>비용이 증가&lt;/strong>한다면 나쁜 설계다.&lt;/li>
&lt;/ul>
&lt;h2 id="좋은-설계가-필요한-이유">좋은 설계가 필요한 이유&lt;/h2>
&lt;p>소프트웨어 아키텍처가 나쁘다면 소프트웨어가 진화함에 따라 점점 비용이 증가한다. (생산성이 떨어진다.)&lt;/p>
&lt;ul>
&lt;li>이러한 비용의 상승은 사업 모델의 수익을 고갈시킨다.&lt;/li>
&lt;li>회사의 성장을 멈추게 하거나 심지어는 완전히 망하게 만든다.&lt;/li>
&lt;/ul>
&lt;p>시스템을 급하게 만들거나, 결과물의 총량을 순전히 프로그래머 수만으로 결정하거나, 코드와 설계와 구조를 깔끔하게 만들려는 생각을 전혀 하지 않는다면, 시간이 지남에 따라 비용이 급격히 상승하게되고, 이를 통해 생산성이 바닥을 치게 된다.&lt;/p>
&lt;p>이러한 현상이 발생하게 되면 개발자가 기능 개발보다는 엉망이 된 상황에 대처하는 데 소모되기 시작하며, 개발자들이 쏟은 노력의 가치를 보잘것없게 만든다.&lt;/p>
&lt;h3 id="무엇이-잘못-되었나">무엇이 잘못 되었나?&lt;/h3>
&lt;p>&lt;strong>생산성을 유지할 수 있다는 착각&lt;/strong>&lt;/p>
&lt;p>일부 개발자들은 생산성을 유지할 수 있다고 자신의 능력을 과신한다.(언제든지 돌아가 생산성을 회복시킬 수 있다고 생각한다.)&lt;/p>
&lt;p>현대의 개발자들은 빠른 시장 출시가 경쟁자보다 앞서 가는 것이라 생각하며 &amp;ldquo;코드는 나중에 정리하면 돼. 당장은 시장에 출시하는 게 먼저야!&amp;ldquo;라고 스스로를 속인다.&lt;/p>
&lt;p>하지만 시장의 압박은 절대 수그러들지 않기 때문에 태세를 전환하지 않고 정리하는 일은 매우 드물게 되며, 이로 인해 휼륭하고 깔끔하게 잘 설계된 코드와 점점 더 거리가 멀어지게 된다.&lt;/p>
&lt;p>이러한 상황에서 계속해서 새로운 기능들이 추가가 되어 결국 엉망진창이 되고, 생산성이 0으로 수렴하기 시작한다.&lt;/p>
&lt;p>&lt;strong>지저분한 코드를 작성하면 단기간에 빠르게 갈 수 있다는 착각&lt;/strong>&lt;/p>
&lt;p>지저분한 코드를 작성하면 단 기간에는 빠르게 갈 수 있고, &lt;strong>장기적으로 볼 때만 생산성이 낮아진다는 견해&lt;/strong>는 엉망으로 코드를 짜기위한 자기합리화이며, 진실은 &lt;strong>엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리다.&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/1/img.png"
width="491"
height="355"
srcset="https://codemario318.github.io/post/clean-architecture/1/img_hu97e80447e00e45f30d31a1b6d7350367_79701_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/1/img_hu97e80447e00e45f30d31a1b6d7350367_79701_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이터레이션별 걸린 시간과 TDD 적용 여부"
class="gallery-image"
data-flex-grow="138"
data-flex-basis="331px"
>&lt;/p>
&lt;p>제이슨 고먼은 코드를 깔끔하게 유지하는 잘 알려진 방법 중 하나인 TDD를 사용 여부로 생산성을 측정했다.&lt;/p>
&lt;p>TDD를 적용했을때가 훨씬 더 빨랐으며, 심지어 TDD를 적용한 가장 느렸던 날이 적용하지 않은 가장 빨리 작업한 날보다 더 빨랐다.&lt;/p>
&lt;blockquote>
&lt;p>빨리 가는 유일한 방법은 제대로 가는 것이다.&lt;/p>
&lt;/blockquote>
&lt;p>생산성이 감소되고 비용이 증가하는 현상을 되돌릴 수 있는 유일한 방법은 없다.&lt;/p>
&lt;p>이러한 문제를 해결하기 위해 처음부터 다시 시작하더라도 한번 문제를 발생시킨 개발자(팀)는 똑같은 문제를 반복하는 경우가 많으며, 이 때문에 항상 코드와 설계를 깔끔하게 만들려는 노력을 지속해야한다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>어떤 경우라도 개발 조직이 할 수 있는 최고의 선택지는 조직에 스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처의 품질을 심각하게 고민하기 시작하는 것이다.&lt;/p>
&lt;p>소프트웨어 아키텍처를 심각하게 고려할 수 있으려면 좋은 소프트웨어 아키텍처가 무엇인지 이해해야 한다.&lt;/p>
&lt;ul>
&lt;li>비용은 최소화하고 생산성은 최대화 할 수 있는 설계와 아키텍처를 가진 시스템을 만드려면, 시스템 아키텍처가 지닌 속성을 알고 있어야 한다.&lt;/li>
&lt;/ul>
&lt;p>이 책은 훌륭하고 깔끔한 아키텍처와 설계가 무엇인지 설명하고, 이를 통해 소프트웨어 개발자가 장시간에 걸쳐 수익을 창출하는 시스템을 만들 수 있게 하고자 한다.&lt;/p></description></item><item><title>Python - Generator</title><link>https://codemario318.github.io/post/python_cover/</link><pubDate>Tue, 18 Apr 2023 14:31:00 +0900</pubDate><guid>https://codemario318.github.io/post/python_cover/</guid><description>&lt;img src="https://codemario318.github.io/post/python_cover/python_cover.png" alt="Featured image of post Python - Generator" />&lt;p>제너레이터는 제너레이터 함수가 호출될 때 반환되는 이터러블 객체이다. 제네레이터 함수는 일반적인 함수와 비슷하게 생겼지만 &lt;code>yield&lt;/code> 구문을 사용해 데이터를 원하는 시점에 반환하고 처리를 다시 시작할 수 있다. 일반적인 함수는 진입점이 하나라면 제네레이터는 진입점이 여러개라고 생각할 수 있다. 이러한 특성때문에 제네레이터를 사용하면 원하는 시점에 원하는 데이터를 받을 수 있게된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">generator&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">yield&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">yield&lt;/span> &lt;span class="s1">&amp;#39;string&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">yield&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">gen&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">generator&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gen&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># &amp;lt;generator object generator at 0x10a47c678&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">next&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gen&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">#1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">next&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gen&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># &amp;#39;string&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">next&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gen&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">next&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gen&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">Traceback (most recent call last):
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">StopIteration
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="동작">동작&lt;/h2>
&lt;ol>
&lt;li>&lt;code>yield&lt;/code> 문이 포함된 함수를 실행하면 제너레이터 객체가 반환되는데 이 때는 함수의 내용이 실행되지 않는다.&lt;/li>
&lt;li>&lt;code>next()&lt;/code> 라는 빌트인 메서드를 통해 제네레이터를 실행시킬 수 있으며 next() 메서드 내부적으로 iterator 를 인자로 받아 이터레이터의 &lt;code>__next__()&lt;/code> 메서드를 실행시킨다.&lt;/li>
&lt;li>처음 &lt;code>__next__()&lt;/code> 를 호출하면 함수의 내용을 실행하다 &lt;code>yield&lt;/code> 문을 만났을 때 처리를 중단한다.&lt;/li>
&lt;li>이 때 모든 local state는 유지되는데 변수의 상태, 명령어 포인터, 내부 스택, 예외 처리 상태를 포함한다.&lt;/li>
&lt;li>그 후 제어권을 상위 컨텍스트로 양보(yield)하고 또 &lt;code>__next__()&lt;/code> 가 호출되면 제네레이터는 중단된 시점부터 다시 시작한다.&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;code>yield&lt;/code> 문의 값은 어떤 메서드를 통해 제네레이터가 다시 동작했는지에 따라 다른데, &lt;code>__next__()&lt;/code> 를 사용하면 None이고 &lt;code>send()&lt;/code> 를 사용하면 메서드로 전달 된 값을 갖게되어 외부에서 데이터를 입력받을 수 있게 된다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="장점">장점&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/python_cover/python_generator_1.png"
width="1272"
height="574"
srcset="https://codemario318.github.io/post/python_cover/python_generator_1_huffa17e204d26514765855512ef8025cc_55547_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/python_cover/python_generator_1_huffa17e204d26514765855512ef8025cc_55547_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Genrator, Iterator, Iterable 간 관계"
class="gallery-image"
data-flex-grow="221"
data-flex-basis="531px"
>&lt;/p>
&lt;p>&lt;code>List&lt;/code>, &lt;code>Set&lt;/code>, &lt;code>Dict&lt;/code> 표현식은 iterable 하기에 &lt;code>for&lt;/code> 표현식 등에서 유용하게 쓰일 수 있다. 하지만 해당 객체들은 &lt;code>Collection&lt;/code> 특성상 가진 데이터를 메모리에 담고 있어야 하기 때문에 큰 값을 다룰 때는 성능상 불리하다. 제너레이터는 &lt;code>yield&lt;/code> 를 통해 필요한 값만 받아 쓰기 때문에 모든 값을 메모리에 들고 있을 필요가 없게 된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">sys&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100000&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">sys&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getsizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">#824464&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100000&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">sys&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getsizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">#88&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>리스트가 여러번 사용될 수 있는 반면 &lt;code>b&lt;/code> 제네레이터는 한번 사용된 후 소진된다. 이는 모든 이터레이터가 마찬가지인데 &lt;code>List&lt;/code>, &lt;code>Set&lt;/code> 등은 이터러블하지만 이터레이터는 아니기에 소진되지 않는다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1"># 100000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1"># 0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>while True&lt;/code> 구분으로 제공받을 데이터가 무한하거나, 모든 값을 한번에 계산하기엔 시간이 많이 소요되어 그때 그때 필요한 만큼만 받아 계산하고 싶을 때 제네레이터를 활용할 수 있다.&lt;/p></description></item><item><title>검색 엔진</title><link>https://codemario318.github.io/post/search_engine/</link><pubDate>Tue, 18 Apr 2023 14:04:15 +0900</pubDate><guid>https://codemario318.github.io/post/search_engine/</guid><description>&lt;img src="https://codemario318.github.io/post/search_engine/search_engine_cover.jpeg" alt="Featured image of post 검색 엔진" />&lt;p>&lt;img src="https://codemario318.github.io/post/search_engine/search_1.png"
width="1920"
height="1624"
srcset="https://codemario318.github.io/post/search_engine/search_1_hu403bad1118769606b062ea29b7dc1dc8_181102_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/search_engine/search_1_hu403bad1118769606b062ea29b7dc1dc8_181102_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="118"
data-flex-basis="283px"
>
검색 엔진은 컴퓨터 시스템에 저장된 정보를 찾아주는 것을 도와주도록 설계된 정보 검색 시스템이다. 검색 엔진을 사용하여정보를 찾는데 필요한 시간을 최소화할 수 있다.&lt;/p>
&lt;h2 id="웹-검색-엔진">웹 검색 엔진&lt;/h2>
&lt;p>웹 사이트를 검색하기 위한 프로그램이다.&lt;/p>
&lt;p>FTP 서버나 웹 사이트의 파일 검색 결과를 포함하며, 이미지나 토렌트 파일 또는 특정 부류의 웹 사이트에 특화된 웹 검색 엔진도 있다.&lt;/p>
&lt;p>서버에서는 &amp;lsquo;로봇&amp;rsquo;이라 불리는 특별한 프로그램을 이용하 웹 사이트들을 돌아다니며 웹 사이트들에 대한 정보를 미리 자동적으로 수집한다. 이휴 검색 엔진 사이트에서 특정 검색어를 입력하면 검색 엔진이 수집한 정보 중 그에 맞는 결과를 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>로봇이 참조와 어휘를 분헉하는 방식에 따라 검색 품질이 결정됨&lt;/li>
&lt;/ul>
&lt;h3 id="원리">원리&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/search_engine/search_2.png"
width="910"
height="212"
srcset="https://codemario318.github.io/post/search_engine/search_2_hubf6b83db01328e832aa8960bbb3db72a_146347_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/search_engine/search_2_hubf6b83db01328e832aa8960bbb3db72a_146347_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="429"
data-flex-basis="1030px"
>&lt;/p>
&lt;p>검색 엔진은 사용자가 검색 엔진을 사용하기 전에 미리 웹 상에서 정보를 수집하여 색인을 만들어 놓는다. 그리고 나서 사용자가 찾고자 하는 정보의 키워드를 입력하면, 미리 만들어 놓은 색인 중에서 입력된 키워드에 해당하는 정보들을 찾아서 보여준다.&lt;/p>
&lt;h3 id="문서-수집">문서 수집&lt;/h3>
&lt;p>현재 대부분의 검색 엔진에서는 엡상의 방대한 정보들을 검색하고 색인화 하는 과정을 크롤러라고 부르는 정보 수집 프로그램을 사용하여 수행하고 있다.&lt;/p>
&lt;p>크롤러가 주기적으로 웹에 접속된 사이트들을 방문하여 해당 웹 사이트가 가지고 있는 정보에 대해 색인을 작성한 후 그것을 데이터베이스에 저장하여 검색시 활용하게된다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>크롤러&lt;/strong>&lt;br>
웹상의 문서나 이미지, 영상 등을 주기적으로 검색하고 취합하여, 자동으로 데이터베이스화 시키는 프로그램으로 봇(Bot)이라고도 부른다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="검색-엔진의-종류">검색 엔진의 종류&lt;/h2>
&lt;p>수집한 정보를 색인하는 방법에 따라 구분된다.&lt;/p>
&lt;h3 id="로봇-검색-엔진">로봇 검색 엔진&lt;/h3>
&lt;p>크롤라라고 불리는 로봇을 이용하여 웹상의 데이터를 효율적으로 수집하고, 이렇게 수집한 데이터 키워드 색인을 통해 사용자에게 제공하는 검색 엔진&lt;/p>
&lt;ul>
&lt;li>Google, Naver등 현재 사용되는 대부분의 검색 엔진이 이 방식을 채택하고 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="디렉토리-검색-엔진">디렉토리 검색 엔진&lt;/h3>
&lt;p>주제 분류에 의한 검색을 제공하는 검색 엔진이며, 데이터의 분류를 사람이 직접 슈행해야 한다.&lt;/p>
&lt;ul>
&lt;li>현재 주류인 방식은 아니며, 1990년대 Yahoo등에서 사용되었음&lt;/li>
&lt;/ul>
&lt;h3 id="메타-검색-엔진">메타 검색 엔진&lt;/h3>
&lt;p>자체적으로 정보를 보유하고 있지 않으면서 사용자가 입력한 키워드를 복수의 다른 검색 엔진으로 전송하여 결과를 얻고, 그 결과들을 종합하여 표시만 해주는 검색 엔진&lt;/p>
&lt;p>여러 검색 엔진의 결과를 동시에 보여주기 때문에 결과를 한눈에 살펴보기에는 편하지만, 메타 검색이라는 과정을 한 번 더 거쳐야 하므로 속도가 느를 수 있다.&lt;/p>
&lt;h2 id="검색-엔진-최적화search-engine-optimization-seo">검색 엔진 최적화(Search Engine Optimization, SEO)&lt;/h2>
&lt;p>검색 결과의 상위에 자신의 웹 페이지가 노출되기 위해 검색 엔진이 자료를 수집하고 결과를 산출하는 방식에 맞춰 웹 페이지의 구성을 조정하는 것을 의미한다.&lt;/p>
&lt;p>각각의 검색 엔진에 맞처 웹 페이지 내의 키워드나 링크 등을 최적화 하는 작업을 SEO라고 한다.&lt;/p></description></item><item><title>Nginx VS Apache</title><link>https://codemario318.github.io/post/nginx_vs_apache/</link><pubDate>Mon, 17 Apr 2023 19:10:21 +0900</pubDate><guid>https://codemario318.github.io/post/nginx_vs_apache/</guid><description>&lt;img src="https://codemario318.github.io/post/nginx_vs_apache/web_cover.jpeg" alt="Featured image of post Nginx VS Apache" />&lt;h2 id="apache">Apache&lt;/h2>
&lt;p>아파치는 클라이언트 요청을 받으면 MPM(Multi Processing Module : 다중처리모듈) 방식으로 처리한다.&lt;/p>
&lt;h3 id="스레드프로세스-기반-구조-동작">스레드/프로세스 기반 구조 동작&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/nginx_vs_apache/apache_1.png"
width="650"
height="228"
srcset="https://codemario318.github.io/post/nginx_vs_apache/apache_1_hud788ba3048e19a1ebe7d38112e42e6a1_35541_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/nginx_vs_apache/apache_1_hud788ba3048e19a1ebe7d38112e42e6a1_35541_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="285"
data-flex-basis="684px"
>&lt;/p>
&lt;ol>
&lt;li>ServerSocket으로 request A가 들어오면 Thread를 할당해준다.&lt;/li>
&lt;li>Thread는 해당 socket을 가지고 read, write작업 등을 수행한다.&lt;/li>
&lt;li>수행 도중 ServerSocket으로 request B가 들어오면, context switching이 일어난다.&lt;/li>
&lt;li>새로 들어온 요청에 쓰레드를 배분하고, 또 해당 소켓을 가지고 작업을 수행한다.&lt;/li>
&lt;li>아직 마무리되지 않은 A를 처리하기 위해 일정 기간마다 지속적으로 context switching을 반복하고 모든 작업을 마무리 한다.&lt;/li>
&lt;/ol>
&lt;h3 id="prefork-mpm">Prefork MPM&lt;/h3>
&lt;blockquote>
&lt;p>실행중인 프로세스를 복제하여 처리하는 방식&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://codemario318.github.io/post/nginx_vs_apache/apache_2.png"
width="540"
height="228"
srcset="https://codemario318.github.io/post/nginx_vs_apache/apache_2_hu4aea97f916963e39605fd52709e9d50f_18335_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/nginx_vs_apache/apache_2_hu4aea97f916963e39605fd52709e9d50f_18335_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="236"
data-flex-basis="568px"
>&lt;/p>
&lt;p>각 프로세스는 한번에 한 연결만 처리하고, 요청량이 많아질수록 프로세스를 복제하여 동작한다.&lt;/p>
&lt;p>프로세스를 복제하는 방식이기 떄문에 메모리가 많이 소비된다&lt;/p>
&lt;blockquote>
&lt;p>연결 수 = 프로세스 수&lt;/p>
&lt;/blockquote>
&lt;h3 id="worker-mpm">Worker MPM&lt;/h3>
&lt;p>&lt;code>Prefork&lt;/code> 방식은 한개의 프로세스가 한개의 스레드로 처리되지만, &lt;code>Worker&lt;/code> 방식은 한개의 프로세스가 여러 쓰레드를 사용하여 처리한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/nginx_vs_apache/apache_3.png"
width="567"
height="306"
srcset="https://codemario318.github.io/post/nginx_vs_apache/apache_3_hue17f6f82a5b8ce67bf262ebdfc3b1f83_23290_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/nginx_vs_apache/apache_3_hue17f6f82a5b8ce67bf262ebdfc3b1f83_23290_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="185"
data-flex-basis="444px"
>&lt;/p>
&lt;p>쓰레드를 사용하기 떄문에 &lt;code>Prefork&lt;/code> 방식보다 메모리 소모가 적고, 통신량이 많을 때 유리하다.&lt;/p>
&lt;h3 id="문제점">문제점&lt;/h3>
&lt;p>아파치는 접속마다 프로세스 또는 쓰레드를 생성하는 구조이다.&lt;/p>
&lt;p>동시 접속 요청이 많을수록 그만큰 생성 비용이 들고 대용양 요청을 처리할 수 있는 웹 서버로서 한계가 나타난다.&lt;/p>
&lt;h2 id="nginx">Nginx&lt;/h2>
&lt;p>한개 또는 고정된 프로세스만 생성하고, 프로세스 내부에서 비동기 방식으로 작업을 처리한다. 따라서 동시 접속 요청이 많아도 프로세스 또는 쓰레드 생성 비용이 존재하지 않는다.&lt;/p>
&lt;h3 id="event-driven-방식">Event-Driven 방식&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/nginx_vs_apache/nginx_1.png"
width="650"
height="228"
srcset="https://codemario318.github.io/post/nginx_vs_apache/nginx_1_hub9b084e6dd23334ae771f5e5c2e9549d_33410_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/nginx_vs_apache/nginx_1_hub9b084e6dd23334ae771f5e5c2e9549d_33410_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="285"
data-flex-basis="684px"
>&lt;/p>
&lt;blockquote>
&lt;p>Event-Driven 방식은 Reactor pattern을 사용한다.&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>&lt;code>Reactor&lt;/code>는 이벤트가 들어오면 알맞는 &lt;code>handler&lt;/code>로 &lt;code>dispatch&lt;/code> 해준다.&lt;/li>
&lt;li>&lt;code>Handler&lt;/code>는 &lt;code>dispatch&lt;/code>된 이벤트를 받아서 처리하는 역할을 수행&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;strong>Reactor pattern&lt;/strong>&lt;br>
이벤트 처리(event handling)디자인 패턴으로 하나의 &lt;code>Reactor&lt;/code>가 계속 이벤트를 찾고 이벤트가 발생(trigger)하면 해당 이벤트 처리기(event handler)에게 알린다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="nginx와-apache의-차이점">Nginx와 Apache의 차이점&lt;/h2>
&lt;h3 id="컨텐츠의처리-방식">컨텐츠의처리 방식&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>정적 컨텐츠 처리&lt;/p>
&lt;ul>
&lt;li>Apache: 전통적인 파일기반 방식의 정적 컨텐츠&lt;/li>
&lt;li>Nginx: 이벤트 처리/비동기식/논블로킹 방식 처리로 인해 정적 컨텐츠 제공시 고속 처리 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>동적 컨텐츠 처리&lt;/p>
&lt;ul>
&lt;li>Apache: 서버 내에서 처리
&lt;ul>
&lt;li>기본적으로 유연성과 범용성을 갖추는 방식으로 서버 자체에서 동적 컨텐츠 처리가 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Nginx: 동적 컨텐츠를 처리하지 않음
&lt;ul>
&lt;li>동적 웹 페이지 컨텐츠를 가진 모든 요청을 위해 외부 자원과 연계한다. 따라서 최종적으로 동적 컨텐츠가 다시 돌아올 때까지 기다렸다가 클라이언트에게 전달하는 방식을 가지고 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="os-지원에-대한-범용성">OS 지원에 대한 범용성&lt;/h3>
&lt;ul>
&lt;li>Apache: 리눅스, BSD, UNIX, WINDOW
&lt;ul>
&lt;li>역사가 있는 만큼 지원 범위가 다양하기 때문에 일관성 있는 웹 서비스 아키텍쳐를 구현할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Nginx: LINUX, BSD, UNIX, WIN(부분 지원)
&lt;ul>
&lt;li>다양한 운영체제를 지원하지만 아파치 만큼 완벽히 지원하지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="분산중앙집중식-구성-방식">분산/중앙집중식 구성 방식&lt;/h3>
&lt;ul>
&lt;li>Apache: 분산/중앙집중식 구성 채택
&lt;ul>
&lt;li>.htaccess를 통해 디렉토리별로 추가 구성을 할 수 있다. 단일 기반 뿐만 아니라 분산형 구칙이 가능하므로 대용량 서버 아키텍쳐에서 자원만 충분하다면 여러 웹 서비스를 구현 할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Nginx: 중앙집중식 구성 채택
&lt;ul>
&lt;li>아파치처럼 .htaccess를 지원하지 않는다. 따라서 추가 구성을 할 수 없는 단점이 있다. 하지만 이러한 방식은 가상화, 클라우드, MSA와 같은 아키텍쳐에서는 오히려 경량화와 성능 보장이라는 측면에서 단점이 되지 않을 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="모듈-및-확장성보안">모듈 및 확장성/보안&lt;/h3>
&lt;ul>
&lt;li>Apache
&lt;ul>
&lt;li>60개 이상의 다양한 기능과 모듈을 지원하며, 필요에 따라 활성화 또는 비활성 시킬 수 있다. 동적 모듈을 통해 웹 서버의 사용자 지정도 가능하게 할 수 있는 등 다양한 디자인과 확장이 가능하다.&lt;/li>
&lt;li>보안을 위해 다양한 Web기반 DDoS 방어 기술을 제공한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Nginx
&lt;ul>
&lt;li>다른 코어 모듈을 동적으로 로딩할 수 없도록 되어있다. 옵션을 최소화 해서 태생 부터 성능에 포커싱 했다.&lt;/li>
&lt;li>보안에 대한 다양한 기술 문서를 제공하며, 코드 자체가 가볍고 경량화 되어 있어서 보안에 유리한 측면도 있다.&lt;a class="link" href="https://youngmind.tistory.com/entry/Apache-vs-Nginx" target="_blank" rel="noopener"
>https://youngmind.tistory.com/entry/Apache-vs-Nginx&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Web</title><link>https://codemario318.github.io/post/web/</link><pubDate>Mon, 17 Apr 2023 18:28:10 +0900</pubDate><guid>https://codemario318.github.io/post/web/</guid><description>&lt;img src="https://codemario318.github.io/post/web/web_cover.jpeg" alt="Featured image of post Web" />&lt;h2 id="웹-동작-방식">웹 동작 방식&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/web/web_1.png"
width="1480"
height="730"
srcset="https://codemario318.github.io/post/web/web_1_hu7f6c89e951b5c7c2fdb2549d3b17bd79_46991_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/web/web_1_hu7f6c89e951b5c7c2fdb2549d3b17bd79_46991_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="웹 동작 방식"
class="gallery-image"
data-flex-grow="202"
data-flex-basis="486px"
>&lt;/p>
&lt;p>클라이언트(브라우저)가 HTTP(URL)을 통해 요청을 보내면 HTML, CSS, 이미지와 같은 정적 콘텐츠를 응답으로 보내게 되고 그것을 받은 클라이언트가 해석하여 페이지로 보여준다.&lt;/p>
&lt;h2 id="static-pages와-dynamic-pages">Static pages와 Dynamic Pages&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/web/web_2.png"
width="3233"
height="1262"
srcset="https://codemario318.github.io/post/web/web_2_hu118d3ab45ddaa4b1e54aef5407b22c06_339090_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/web/web_2_hu118d3ab45ddaa4b1e54aef5407b22c06_339090_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Static and Dynamic"
class="gallery-image"
data-flex-grow="256"
data-flex-basis="614px"
>&lt;/p>
&lt;h3 id="static-pages">Static Pages&lt;/h3>
&lt;ul>
&lt;li>Web Server는 파일 경로의 이름을 받아 경로와 일치하는 file contents를 반환&lt;/li>
&lt;li>항상 동일한 페이지를 반환&lt;/li>
&lt;li>Ex) image, html, css, javascript 파일과 같이 컴퓨터에 저장되어 있는 파일들&lt;/li>
&lt;/ul>
&lt;h3 id="dynamic-pages">Dynamic Pages&lt;/h3>
&lt;ul>
&lt;li>인자의 내용에 맞게 동적인 Contents를 반환&lt;/li>
&lt;li>웹 서버에 의해서 실행되는 프로그램을 통해서 만들어진 결과물(WAS)위에서 돌아가는 프로그램&lt;/li>
&lt;/ul>
&lt;h2 id="web-server와-was의-차이">Web Server와 WAS의 차이&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/web/web_3.png"
width="1917"
height="607"
srcset="https://codemario318.github.io/post/web/web_3_hub574429a97bf680de242b6364e3018eb_132576_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/web/web_3_hub574429a97bf680de242b6364e3018eb_132576_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Web Server와 WAS"
class="gallery-image"
data-flex-grow="315"
data-flex-basis="757px"
>&lt;/p>
&lt;h3 id="web-server">Web Server&lt;/h3>
&lt;p>소프트웨어와 하드웨어로 구분된다.&lt;/p>
&lt;ul>
&lt;li>하드웨어
&lt;ul>
&lt;li>Web 서버가 설치되어 있는 컴퓨터&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>소프트웨어
&lt;ul>
&lt;li>웹 브라우저 클라이언트로 부터 HTTP 요청을 받아 &lt;strong>정적인 컨텐츠&lt;/strong>(.html, .jpeg, .css 등)을 제공하는 컴퓨터 프로그램&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="web-server의-역할">Web Server의 역할&lt;/h4>
&lt;blockquote>
&lt;p>HTTP 프로토콜을 기반으로 하여 클라이언트의 요청을 서비스 하는 기능 담당&lt;/p>
&lt;/blockquote>
&lt;p>요청에 따라 두 가지 기능 중 적절하게 선택하여 수행&lt;/p>
&lt;ol>
&lt;li>정적인 컨텐츠 제공
&lt;ul>
&lt;li>WAS를 거치지 않고 바로 자원을 제공한다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>동적인 컨텐츠 제공을 위한 요청 전달
&lt;ul>
&lt;li>클라이언트의 요청을 WAS에 보내고, WAS가 처리한 결과를 클라이언트에게 전달한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="web-server의-예">Web Server의 예&lt;/h4>
&lt;ul>
&lt;li>Apache Server&lt;/li>
&lt;li>Nginx&lt;/li>
&lt;li>IIS 등&lt;/li>
&lt;/ul>
&lt;h3 id="wasweb-application-server">WAS(Web Application Server)&lt;/h3>
&lt;blockquote>
&lt;p>DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기위해 만들어진 Application Server&lt;/p>
&lt;/blockquote>
&lt;p>HTTP를 통해 컴퓨터나 장치에 어플리케이션을 수행해주는 미들웨어이다.&lt;/p>
&lt;blockquote>
&lt;p>웹 컨테이너(Web Container), 서블릿 컨테이너(Servlet Container)라고도 불림&lt;/p>
&lt;/blockquote>
&lt;h4 id="was의-역할">WAS의 역할&lt;/h4>
&lt;blockquote>
&lt;p>WAS = Web Server + Web Container&lt;/p>
&lt;/blockquote>
&lt;p>웹서버 기능들을 구조적으로 분리하여 처리하고자하는 목적으로 제시됨&lt;/p>
&lt;ul>
&lt;li>분산 트랜잭션&lt;/li>
&lt;li>보안&lt;/li>
&lt;li>메시징&lt;/li>
&lt;li>쓰레드 처리 등&lt;/li>
&lt;/ul>
&lt;p>DB와 서버와 같이 수행됨&lt;/p>
&lt;h4 id="was의-주요-기능">WAS의 주요 기능&lt;/h4>
&lt;ul>
&lt;li>프로그램 실행 환경과 DB 접속 기능 제공&lt;/li>
&lt;li>여러 개의 트랜잭션 관리 기능&lt;/li>
&lt;li>업무를 처리하는 비지니스 로직 수행&lt;/li>
&lt;/ul>
&lt;h4 id="was가-필요한-이유">WAS가 필요한 이유&lt;/h4>
&lt;p>웹 페이지는 정적 컨텐츠와 동적 컨텐츠가 모두 존재한다.&lt;/p>
&lt;ul>
&lt;li>사용자의 요청에 맞게 적절한 동적 컨텐츠를 만들어서 제공해야 한다.&lt;/li>
&lt;li>웹 서버만을 이용하게 되면 그에 맞는 결과가 정적 파일로 존재해야 한다.&lt;/li>
&lt;/ul>
&lt;p>따라서 WAS를 통해 요청에 맞는 데이터를 DB에서 가져와 비즈니스 로직에 맞게 결과를 만들어 제공함으로 자원을 효율적으로 사용할 수 있다.&lt;/p>
&lt;h2 id="was와-web-server를-분리하는-이유">WAS와 Web Server를 분리하는 이유&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>기능 분리를 통한 서버 부하 방지&lt;/strong>&lt;br>
WAS만으로도 웹서비스를 제공 가능하지만 WAS는 DB조회 등 동적인 웹 페이지를 위한 다양한 동작을 하기 때문에 바쁘다. 따라서 웹 서버를 통해 정적인 컨텐츠를 제공하여 부하를 방지한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>물리적으로 분리하여 보안 강화&lt;/strong>&lt;br>
SSL에 대한 암복호화 처리에 웹서버를 사용한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>여러대의 WAS를 연결 가능&lt;/strong>&lt;br>
Load Balancing을 위해 Web Server를 사용 가능하다&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>fail over(장애 극복), fail back 처리에 유리&lt;/li>
&lt;li>여러대의 서버를 사용하는 대용량 웹 어플리케이션의 경우 웹 서버와 WAS를 분리하여 무중단 운영을 위한 장애 극복에 쉽게 대응할 수 있다.&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>&lt;strong>여러 웹 어플리케이션 서비스 가능&lt;/strong>&lt;br>
하나의 웹 서버로 다양한 WAS를 이용하게 만들 수 있다.&lt;/li>
&lt;/ol></description></item></channel></rss>