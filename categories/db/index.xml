<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DB on Mario Blog</title><link>https://codemario318.github.io/categories/db/</link><description>Recent content in DB on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Thu, 13 Apr 2023 12:39:01 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/categories/db/index.xml" rel="self" type="application/rss+xml"/><item><title>4.2 InnoDB 스토리지 엔진 아키텍처(3)</title><link>https://codemario318.github.io/post/real_mysql_4_2_3/</link><pubDate>Thu, 13 Apr 2023 12:39:01 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_4_2_3/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_3/real_mysql.jpeg" alt="Featured image of post 4.2 InnoDB 스토리지 엔진 아키텍처(3)" />&lt;h2 id="double-write-buffer">Double Write Buffer&lt;/h2>
&lt;p>InnoDB 스토리지 엔진의 리두 로그는 공간 낭비를 막기 위해 페이지의 변경된 내용만 기록한다. 이로인해 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생하면 그 페이지의 내용은 복구할 수 없을 가능성이 있다.&lt;/p>
&lt;p>이런 현상을 파셜 페이지 또는 톤 페이지라고 하는데, 하드웨어의 오작동이나 시스템의 비정상 종료 등으로 발생할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>파셜 페이지(Partial-Page)&lt;/strong>&lt;br>
데이터 베이스 페이지 중에서 데이터가 일부만 채워진 페이지. 레코드가 페이지의 크기보다 작을 때 발생하며, 레코드가 페이지를 벗어나지 않은 상태에서 페이지의 일부만 사용하게 된다.&lt;/li>
&lt;li>&lt;strong>톤 페이지(Tone-Page)&lt;/strong>&lt;br>
디스크에 기록 중인 페이지의 기록 작업이 중간에 중단되어 발생하는 문제. 페이지 일부가 디스크에 기록되지 않아 데이터 무결성이 손상되는 문제를 일으킬 수 있다.&lt;/li>
&lt;/ul>
&lt;p>InnoDB 스토리지 엔진은 이러한 문제를 막기 위해 Double-Write 기법을 활용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_3/mysql_4_15.png"
width="577"
height="469"
srcset="https://codemario318.github.io/post/real_mysql_4_2_3/mysql_4_15_hud9759c13d9680ee964cf64ca3b80fcce_99858_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_3/mysql_4_15_hud9759c13d9680ee964cf64ca3b80fcce_99858_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Double Write 작동 방식"
class="gallery-image"
data-flex-grow="123"
data-flex-basis="295px"
>&lt;/p>
&lt;p>InnoDB 스토리지 엔진은 실제 데이터 파일에 변경 내용을 기록하기 전에 기록될 더티 페이지들을 묶어 시스템 테이블 스페이스의 DoubleWrite 버퍼에 기록한다.&lt;/p>
&lt;p>더티 페이지 플러싱 중 오류등으로 서버가 종료되었다면 InnoDB 스토리지 엔진은 재시작 될 때 항상 Double Write 버퍼의 내용을 데이터 파일의 페이지로 복사하게 된다.&lt;/p>
&lt;p>DoubleWrite 기능을 사용할지 여부는 &lt;code>Innodb_doublewrite&lt;/code> 시스템 변수로 제어할 수 있다.&lt;/p>
&lt;p>이처럼 DoubleWrite 버퍼는 데이터의 안정성을 위해 사용되는데, HDD처럼 자기 원판이 회전하는 저장 시스템에서는 한 번의 순차 디스크 쓰기를 하는 것으로 부담스럽지 않지만 SSD처럼 랜덤 IO와 순차 IO의 비용이 비슷한 저장 시스템에서는 부담스럽다.&lt;/p>
&lt;blockquote>
&lt;p>SSD는 HDD와 다르게 내부적으로 물리적인 섹터 단위로 데이터를 읽고 쓰지 않는다. 따라서 메모리에 복사된 내용이 SSD의 섹터 크기보다 작은 경우에도(순차 디스크 쓰기) 여러번 기록되어야 한다.&lt;/p>
&lt;/blockquote>
&lt;p>하지만 데이터의 무결성이 매우 중요한 서비스에서는 DoubleWrite의 활성화를 고려하는 것도 좋다. 만약 데이터베이스 서버의 성능을 위해 InnoDB 리두 로그 동기화 설정(&lt;code>innodb_flush_log_at_trx_commit&lt;/code> 시스템 변수)을 1이 아닌 값으로 설정했다면, DoubleWrite도 비활성화 하는 것이 좋다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>&lt;code>innodb_flush_log_at_trx_commit&lt;/code>&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>0: 커밋 후 로그 버퍼를 디스크에 즉시 플러시 하지 않고, 로그 버퍼가 일정 수준 채워지거나 데이터베이스 서버가 종료될 때 플러시한다. 데이터 일관성이 보장되지 않을 수 있다.&lt;/li>
&lt;li>1(default): 컷밋 후 로그 버퍼를 디스크에 즉시 플러시한다. 데이터 일관성은 보장하지만 디스크 IO가 부하를 발생시킬 수 있다.&lt;/li>
&lt;li>2: 커밋 후 로그 버퍼를 디스크에 즉시 플러시 하지 않고, 로그를 별도 파일에 쓴 후 파일을 주기적으로 플러시 한다. 0과 1의 중간 정도로 데이터 일관성과 디스크 IO 부하 감소를 균형있게 유지할 수 있다.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="언두-로그">언두 로그&lt;/h2>
&lt;p>InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업한다. 이렇게 백업된 데이터를 언두 로그(Undo Log)라고 한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>트랜잭션 보장&lt;/strong>&lt;br>
트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구한다.&lt;/li>
&lt;li>&lt;strong>격리 수준 보장&lt;/strong>&lt;br>
특정 커넥션에서 데이터를 변경하는 도중 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 한다.&lt;/li>
&lt;/ul>
&lt;h3 id="언두-로그-모니터링">언두 로그 모니터링&lt;/h3>
&lt;p>언두 로그로 인해 여러가지 성능 이슈가 발생할 수 있어 모니터링이 필요하다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>대용량 처리 트랜잭션&lt;/strong>&lt;br>
1억 건의 레코드가 저장된 100GB 크기의 테이블을 &lt;code>DELETE&lt;/code>로 삭제한다고 가정했을때, 언두 로그에 삭제전 값을 저장해야 하므로 언두 로그 공간은 100GB가 된다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>장시간 활성화된 트랜잭션&lt;/strong>&lt;br>
트랜잭션이 완료됐다고 해서 해당 트랜잭션이 생성한 언두 로그를 즉시 삭제할수 없을 수 있다. 먼저 시작된 트랜잭션보다 이후 발생한 트랜잭션이 완료된 경우, 먼저 시작된 완료된 트랜적션이 완료되기 전 까지 언두 로그는 삭제되지 않는다. 이러한 경우 언두 로그의 이력을 필요한 만큼 스캔해야만 필요한 레코드를 찾을 수 있기 때문에 쿼리의 성능이 전반적으로 떨어질 수 있다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* MySQL 모든 버전 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGING&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">INNODB&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="k">G&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/* MySQL 8.0 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">count&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">information_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">innodb_metrics&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SUBSYSTEM&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;transaction&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">NAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;trx_rseg_history_len&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>MySQL 서버에서 실행되는 &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 문장이 얼마나 많은 데이터를 변경하느냐에 따라 평상시 언두 로그 건수는 상이할 수 있어, 안정적인 시점의 언두 로그 건수를 확인하고 이를 기중으로 언두 로그의 급증 여부를 모니터링하는 것이 좋다.&lt;/p>
&lt;blockquote>
&lt;p>MySQL 서버에서 &lt;code>INSERT&lt;/code> 문장으로 인한 언두 로그와 &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 문장으로 인한 언두 로그는 별도로 관리된다. &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 문장으로 인한 언두 로그는 MVCC와 데이터 복구(롤백 등)에 모두 사용되지만, &lt;code>INSERT&lt;/code> 문장으로 인한 언두 로그는 롤백, 데이터 복구만을 위해 사용된다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="언두-테이블스페이스-관리">언두 테이블스페이스 관리&lt;/h3>
&lt;p>언두 로그가 저장되는 공간을 언두 테이블스페이스(Undo Tablespace)라고 한다.&lt;/p>
&lt;p>MySQL 5.6 이전 버전에서는 언두 로그가 모두 시스템 테이블스페이스(&lt;code>ibdata.idb&lt;/code>)에 저장되었었지만, 시스템 테이블스페이스의 언두 로그는 MySQL서버가 초기화될 때 생성되기 때문에 확장의 한계가 있었다.
이에 따라 5.6 버전에서는 &lt;code>innodb_undo_tablespaces&lt;/code> 시스템 변수가 도입되어 별도 로그 파일을 사용할 수 있게 되었고, 8.0으로 업그레이드되면서 언두 로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에만 기록되도록 개선되었다.&lt;/p>
&lt;p>하나의 언두 테이블스페이스는 1~128개의 롤백 세그먼트를 가지며, 롤백 세크먼트는 1개 이상의 언두 슬롯(Undo Slot)을 가진다.&lt;/p>
&lt;p>최대 동시 처리 가능한 트랜잭션의 개수는 다음 수식으로 예측할 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>(InnDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블 스페이스 수)&lt;/p>
&lt;/blockquote>
&lt;p>InnoDB 기본 설정(innodb_undo_tablespace=2, innodb_rollback_segments=128)을 사용한다면 131,072개 정도의 트랜잭션이 동시에 처리 가능해진다. 일반적인 서비스에서 이 정도까지 동시 트랜잭션이 필요하진 않겠지만 기본값으로 해서 크게 문제될 건 없다.&lt;/p>
&lt;p>언두 로그 슬롯이 부족한 경우에는 트래잭션을 시작할 수 없는 심각한 문제가 발생하기 때문에 적절히 정해야 한다.&lt;/p>
&lt;p>MySQL 8.0 부터 &lt;code>CREATE UNDO TABLESPACE&lt;/code>나 &lt;code>DROP TABLESPACE&lt;/code>같은 명령으로 새로운 언두 테이블 스페이스를 동적으로 추가하고 삭제할 수 있게 개선되었다.&lt;/p>
&lt;p>언두 테이블스페이스 공간을 필요한 만큼만 남기고 불필요하거나 과도하게 할당된 공간을 운영체제로 반납하는 것을 &amp;lsquo;Undo tablespace truncate&amp;rsquo;라고 하며 자동, 수동 두가지 방법이 있다.&lt;/p>
&lt;h2 id="체인지-버퍼">체인지 버퍼&lt;/h2>
&lt;p>RDBMS에서 레코드가 추가, 변경될 때 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다. 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 상당히 많은 자원을 소모하게 된다. 따라서 InnoDB는 변경해야 할 인덱스 페이지가 버퍼풀에 있으면 바로 업데이트를 수행하지만, 그렇지 않고 디스크로부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 되는데, 이때 사용하는 임시 메모리 공간을 체인지 버퍼(Change Buffer)라고 한다.&lt;/p>
&lt;p>사용자에게 결과를 반환하기 전에 반드시 중복 여부를 체크해야 하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없다.&lt;/p>
&lt;p>체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데, 이 스레드를 체인지 버퍼 머지 스레드라고 한다.&lt;/p>
&lt;p>MySQL 5.5 이전 버전까지는 &lt;code>INSERT&lt;/code> 작업에 대해서만 이러한 버퍼링이 가능했는데, 이후 조금씩 개선되며 &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code>로 인해 키를 추가하거나 삭제하는 작업에 대해서도 버퍼링이 될 수 있게 개선되었다.&lt;/p>
&lt;p>또한 &lt;code>innodb_change_buffering&lt;/code>이라는 시스템 변수가 새로 도입되어 작업의 종류별로 체인지 버퍼를 활성화할 수 있으며, 체인지 버퍼가 비효일적일 때는 체인지 버퍼를 사용하지 않게 설정할 수 있게 개선되었다.&lt;/p>
&lt;ul>
&lt;li>all: 모든 인덱스 관련 작업을 버퍼링(inserts + deletes + purges)&lt;/li>
&lt;li>none: 버퍼링 안함&lt;/li>
&lt;li>inserts: 인덱스에 새로운 아이템을 추가하는 작업만 버퍼링&lt;/li>
&lt;li>deletes: 인덱스에서 기존 아이템을 삭제하는 작업(삭제됐다는 마킹 작업)만 버퍼링&lt;/li>
&lt;li>changes: 인덱스에 추가하고 삭제하는 작업만(inserts + deletes) 버퍼링&lt;/li>
&lt;li>purges: 인덱스 아이템을 영구적으로 삭제하는 작업만 버퍼링(백그라운드 작업)&lt;/li>
&lt;/ul>
&lt;p>체인지 버퍼는 기본적으로 InnoDB 버퍼풀로 설정된 메모리 공간의 25%까지 활용할 수 있게 설정돼있으며, 필요하다면 50%까지 설정할 수 있다. &lt;code>innodb_change_buffer_max_size&lt;/code> 시스템 변수에 비율을 조정하여 바꿀 수 있다.&lt;/p>
&lt;h2 id="리두-로그-및-로그-버퍼">리두 로그 및 로그 버퍼&lt;/h2>
&lt;p>리두 로그는 트랜잭션의 4가지 요소인 ACID 중에서 D(Durable)에 해당하는 영속성과 가장 밀점하게 연관돼 있다. 리두 로그는 &lt;strong>하드웨어나 소프트웨어 등 문제로 인해 MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치&lt;/strong>이다.&lt;/p>
&lt;p>대부분 데이터베이스 서버는 데이터 변경 내용을 로그로 먼저 기록한다. 대부분 DBMS에서 데이터 파일은 쓰기보다 읽기 성능을 고려한 자료 구조를 가지고 있기 때문에 데이터 파일 쓰기는 디스크의 랜덤 액세스가 필요하여 상대적으로 큰 비용이 필요하다.&lt;/p>
&lt;p>이로 인한 성능 저하를 막기 위해 쓰기 비용이 낮은 자료구조인 리두 로그를 가지고 있으며, 비정상 종료가 발생하면 리두 로그의 내용을 이용해 데이터 파일을 다시 서버가 종료되기 직전 상태로 복구한다.&lt;/p>
&lt;p>또한 성능을 위해 리두 로그를 버퍼링 할 수 있는 InnoDB 버퍼풀이나, 리두 로그를 버퍼링할 수 있는 로그 버퍼와 같은 자료 구조도 가지고 있다.&lt;/p>
&lt;p>MySQL 서버가 비정상으로 종료되는 경우 InnoDB 스토리지 엔진의 데이터 파일은 두 가지 일관되지 않은 데이터를 가질 수 있다.&lt;/p>
&lt;ul>
&lt;li>커밋됐지만 데이터 파일에 기록되지 않은 데이터&lt;/li>
&lt;li>롤백됐지만 데이터 파일에 이미 기록된 데이터&lt;/li>
&lt;/ul>
&lt;p>리두로그를 활용하여 변경이 커밋, 롤백, 트랜잭션의 실행 중간 상태였는지 확인하고, 적절히 처리한다.&lt;/p>
&lt;p>데이터베이스 서버에서 리두 로그는 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 시스템 변수를 설정하는 것을 권장한다. 그래야만 서버가 비정상적으로 종료되었을때 직전까지의 트랜잭션 커밋 내용이 리두 로그에 기록될 수 있고, 그 리두 로그를 이용해 장애 직전 시점까지 복구가 가능해진다.&lt;/p>
&lt;p>하지만 트랜잭션이 커밋될 때마다 리두 로그를 디스크에 기록하면 부하가 생길 수 있어, InnoDB 스토리지 엔진에서 리두 로그를 어느 주기로 디스크에 동기화할지를 결정하는 &lt;code>innodb_flush_log_trx_commit&lt;/code> 시스템 변수를 제공한다.&lt;/p>
&lt;ul>
&lt;li>0: 1초에 한 번씩 리두 로그를 디스크로 기록하고 동기화를 실행한다. 서버가 비정상 종료되면 최대 1초 동안의 트랜잭션은 커밋됐더라도 데이터는 사라질 수 있다.&lt;/li>
&lt;li>1: 매번 트랜잭션이 커밋될 때마다 디스크로 기록되고 동기화까지 수행한다.&lt;/li>
&lt;li>2: 트랜잭션이 커밋될 때마다 디스크로 기록은 되지만 실질적인 동기화는 1초에 한번씩 실행된다. 커밋이 되면 변경 내용이 운영체제의 메모리 버퍼로 기롤되는 것이 보장되기 때문에 MySQL 서버가 비정상 종료되더라도 트랜잭션 데이터는 사라지지 않는다.&lt;/li>
&lt;/ul>
&lt;p>리두 로그 파일들의 전체 크기는 버버풀의 효율성을 결정하기 때문에 신중히 결정해야한다. 리두 로그 파일의 크기는 innodb_log_file_size 시스템 변수로 결정하며, innodb_log_files_in_group 시스템 뼌수는 리두 로그 파일 개수를 결정한다.&lt;/p>
&lt;p>리두 로그 파일의 전체 크기를 버퍼풀의 크기에 맞게 설정해야 적절히 변경된 내용을 버퍼풀에 모아 한번에 디스크에 기록할 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>ACID는 데이터베이스에서 트랜잭션의 무결성을 보장하기 위해 꼭 필요한 4가지 요소(기능)을 의미한다.&lt;/p>
&lt;ul>
&lt;li>A(Atomic): 트랜잭션은 원자성 작업이어야 함.&lt;/li>
&lt;li>C(Consistent): 일관성&lt;/li>
&lt;li>I(Isolated): 격리성&lt;/li>
&lt;li>D(Durable): 영속성. 한 번 저장된 데이터는 지속적으로 유지되어야 함.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="리두-로그-아카이빙">리두 로그 아카이빙&lt;/h3>
&lt;p>MySQL 8.0부터 InnoDB 스토리지 엔진의 리두 로그를 아카이빙 할 수 있는 기능이 추가됐다.&lt;/p>
&lt;p>백업 툴이 리두 로그 아카이빙을 사용하려면 먼저 MySQL 서버에서 아카이빙된 리두 로그가 저장될 디렉터리를 innodb_redo_log_archive_dirs 시스템 변수에 설정해야 하며, 디렉터리는 운영체제의 MySQL 서버를 실행하는 유저만 접근이 가능해야 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">mkdir /var/log/mysql_redo_archive
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> /var/log/mysql_redo_archive
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mkdir &lt;span class="m">20230413&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">chmod &lt;span class="m">700&lt;/span> &lt;span class="m">20230413&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_redo_log_archive_dirs&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;backup:/var/log/mysql_redo_archive&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>디렉터리가 준비되면 리두 로그 아카이빙을 시작하도록 &lt;code>innodb_redo_log_archive_start&lt;/code> UDF(사용자 정의 함수)를 실행한다. 해당 UDF는 리두 로그를 아카이빙할 디렉터리에 대한 레이블과 선택적으로 서브 디렉터리 이름 총 두가지의 매개 변수를 받는다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">DO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_redo_log_archive_start&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;backup&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;20230413&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>리두 아카이빙을 종료할 때는 &lt;code>innodb_redo_log_archive_stop&lt;/code> UDF를 실행한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">DO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_redo_log_archive_stop&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>innodb_redo_log_archive_start&lt;/code> UDF를 실행한 세션의 연결이 끊어지면 InnoDB 스토리지 엔진은 리두 로그 아카이빙을 멈추고 아카이빙 파일도 자동으로 삭제하므로 커넥션을 유지해야 하고, &lt;code>innodb_redo_log_archive_stop&lt;/code> UDF를 호출하여 정상적으로 종료돼야 한다.&lt;/p>
&lt;h3 id="리두-로그-활성화-및-비활성화">리두 로그 활성화 및 비활성화&lt;/h3>
&lt;p>InnoDB 스토리지 엔진의 리두 로그는 MySQL 서버가 비정상 종료됐을때 데이터 파일에 기록되지 못한 트랜잭션을 복구하기 위해 항상 활성화되어있다. MySQL 서버에서 트랜잭션이 커밋돼도 데이터 파일은 즉시 디스크로 동기화되지 않는 반면, 리두 로그는 항상 디스크로 기록된다.&lt;/p>
&lt;p>MySQL 8.0 버전부터 수동으로 리두 로그를 비활성화 할 수 있어, 대용량 데이터를 한번에 적재하는 경우 사용하여 적재 시간을 단축할 수 있다.&lt;/p>
&lt;h3 id="어댑티브-해시-인덱스">어댑티브 해시 인덱스&lt;/h3>
&lt;p>어댑티브 해시 인덱스는 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스로, &lt;code>innodb_adaptive_hash_index&lt;/code> 시스템 변수를 이용하여 활성화, 비활성화 할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-btree-index.png"
width="854"
height="359"
srcset="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-btree-index_hu7ca498aefa34ff05f0faa56ead14966c_53504_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_3/mysql-btree-index_hu7ca498aefa34ff05f0faa56ead14966c_53504_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL B-Tree Index"
class="gallery-image"
data-flex-grow="237"
data-flex-basis="570px"
>&lt;/p>
&lt;p>InnoDB 스토리지 엔진의 대표적인 인덱스는 B-Tree로 데이터는 PK 순으로 정렬되어 관리되고, Secondary Key는 &lt;code>인덱스키 + PK&lt;/code> 조합으로 정렬되어 있다. 특정 데이터를 찾기 위해 Secondary Key에서 PK를 찾고, 찾은 PK를 통해 원하는 데이터를 찾는 형태로 처리된다.&lt;/p>
&lt;blockquote>
&lt;p>PK 사용시 데이터에 접근되는 비용은 &lt;code>O(logN)&lt;/code>이고, Secondary Key를 사용해 데이터에 접근은 PK에 대한 접근도 필요하므로 &lt;code>2 * O(logN)&lt;/code>이다.&lt;/p>
&lt;/blockquote>
&lt;p>따라서 B-Tree 자료구조 특성으로 데이터가 많아진다 하더라도 탐색 비용이 크게 증가하지 않지만, 동시에 많은 스레드에서 탐색 작업이 발생할 경우 Lock 등으로 인해 성능 저하가 발생할 수 있다.&lt;/p>
&lt;p>어댑티브 해시 인덱스는 B-Tree의 검색 시간을 줄여주기 위해 도입된 기능으로, 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고, 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있다.&lt;/p>
&lt;h4 id="구조">구조&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-adaptive-hash-index.png"
width="509"
height="345"
srcset="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-adaptive-hash-index_hu35636e5b1bec8218b375a53611c0cccc_35239_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_3/mysql-adaptive-hash-index_hu35636e5b1bec8218b375a53611c0cccc_35239_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL Adaptive Hash Index"
class="gallery-image"
data-flex-grow="147"
data-flex-basis="354px"
>&lt;/p>
&lt;p>해시 인덱스는 &lt;strong>인덱스 키 값&lt;/strong>과 해당 인덱스 키 값이 저장된 &lt;strong>데이터 페이지 주소&lt;/strong>의 쌍으로 관리된다.&lt;/p>
&lt;ul>
&lt;li>인덱스 키 값:&lt;br>
B-Tree 인덱스의 고유번호 + B-Tree 인덱스의 실제 키 값
&lt;ul>
&lt;li>인덱스의 고유번호가 포함되는 이유는 InnoDB 스토리지 엔진에서 어댑티브 해시 인덱스는 하나만 존재하기 때문이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 페이지 주소:&lt;br>
실제 키 값이 저장된 데이터 페이지의 메모리 주소, 버퍼풀에 로딩된 페이지의 주소를 의미&lt;/li>
&lt;/ul>
&lt;p>어댑티브 해시 인덱스는 버퍼풀에 올려진 데이터 페이지에 대해서만 괸리되고, 버퍼풀에서 해당 데이터 페이지가 없어지면 어댑티브 해시 인덱스에서도 해당 페이지의 정보는 사라진다.&lt;/p>
&lt;h4 id="성능">성능&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-adaptive-hash-search.png"
width="665"
height="226"
srcset="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-adaptive-hash-search_hu531e6a3f072257a601880d914189c4d5_19765_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_3/mysql-adaptive-hash-search_hu531e6a3f072257a601880d914189c4d5_19765_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="쿼리 처리 수 변화"
class="gallery-image"
data-flex-grow="294"
data-flex-basis="706px"
>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_3/mysql_adaptive_hash_index_cpu.png"
width="664"
height="226"
srcset="https://codemario318.github.io/post/real_mysql_4_2_3/mysql_adaptive_hash_index_cpu_hu1567471173400d56b803e008a98f0c2b_10894_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_3/mysql_adaptive_hash_index_cpu_hu1567471173400d56b803e008a98f0c2b_10894_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="CPU 사용률 변화"
class="gallery-image"
data-flex-grow="293"
data-flex-basis="705px"
>&lt;/p>
&lt;p>어댑티브 해시 인덱스를 활성화 후 처리량은 2배 가까이 늘었음에도 불구하고 CPU 사용량은 오히려 떨어진다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-semaphores.png"
width="763"
height="252"
srcset="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-semaphores_hu1335a30742e00261da10a60e6c5fce19_21643_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_3/mysql-semaphores_hu1335a30742e00261da10a60e6c5fce19_21643_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="세마포어 변화"
class="gallery-image"
data-flex-grow="302"
data-flex-basis="726px"
>&lt;/p>
&lt;p>InnoDB 내부잠금(세마포어)의 횟수도 획기적으로 줄어든다.&lt;/p>
&lt;p>추가로 MySQL 8.0 부터는 내부 잠금을 줄이기 위해 어댑티브 해시 인덱스의 파티션 기능을 제공하며 &lt;code>innodb_adaptive_hash_index_parts&lt;/code> 시스템 변수를 통해 파티션 개수를 변경할 수 있다(기본값 8개).&lt;/p>
&lt;p>어댑티브 해시 인덱스가 성능에 많은 도음이 된다면 파티션 개수를 더 많이 설정하는 것도 도움이 될 수 있다.&lt;/p>
&lt;h4 id="한계">한계&lt;/h4>
&lt;p>상황에 따라 어댑티브 해시 인덱스가 성능 향상에 크게 도움이 되지 않는 경우도 있다.&lt;/p>
&lt;ul>
&lt;li>성능 향상에 도움이 되는 경우
&lt;ul>
&lt;li>디스크의 데이터가 InnoDB 버퍼풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)&lt;/li>
&lt;li>동등 조건 검색(동등 비교 및 &lt;code>IN&lt;/code> 연산)이 많은 경우&lt;/li>
&lt;li>쿼리가 일부 데이터에만 집중 되는 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>성능 향상에 크게 도움이 되지 않는 경우
&lt;ul>
&lt;li>디스크 읽기가 많은 경우&lt;/li>
&lt;li>특정 패턴의 쿼리가 많은 경우(&lt;code>JOIN&lt;/code>, &lt;code>LIKE&lt;/code> 패턴 검색)&lt;/li>
&lt;li>매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>어댑티브 해시 인덱스는 데이터 페이지를 메모리(버퍼풀) 내에서 접근하는 것을 더 빠르게 만드는 기능으로 데이터 페이지를 디스크에서 읽어오는 경우가 많은 경우 데이터베이스 서버에서는 큰 도움이 되지 않는다.&lt;/p>
&lt;ul>
&lt;li>어댑티브 해시 인덱스 또한 메모리를 사용하며, 때로는 상당히 큰 메모리 공간을 사용할 수 있다.&lt;/li>
&lt;li>데이터 페이지의 인덱스 키가 해시 인덱스로 만들어져야 하기 때문에 불필요한 경우 제거되어야 한다.&lt;/li>
&lt;li>활성화되면 InnoDB 스토리지 엔진이 필수적으로 검색에 활용해야 하기 때문에 불필요한 접근이 발생할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="주의할-점">주의할 점&lt;/h4>
&lt;p>테이블 삭제(&lt;code>DROP&lt;/code>), 변경(&lt;code>ALTER&lt;/code>)시 해당 테이블이 가진 모든 데이터 페이지의 내용을 어댑티브 해시 인덱스에서 제거해야한다. 이로 인해 테이블이 삭제되거나 스키마가 변경되는 동안 상당히 많은 CPU 자원을 사용하게되어 데이터베이스 서버의 처리 성능이 떨어진다.&lt;/p>
&lt;h4 id="모니터링">모니터링&lt;/h4>
&lt;p>MySQL 서버의 상태 값들을 통해 어댑티브 해시 인덱스가 불필요한 오버헤드만 만들고 있는지 확인할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">INNODB&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="k">G&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">Hash table size 8747, node heap has 1 buffers(s)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">Hash table size 8747, node heap has 0 buffers(s)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">1.03 hash searches/s, 2.64 non-hash searches/s
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>&lt;code>searches&lt;/code>: 쿼리가 처리되기 위해 내부적으로 키 값의 검색이 몇 번 실행되었는지를 의미함&lt;/p>
&lt;/blockquote>
&lt;p>어댑티브 해시 인덱스의 효율은 검색 횟수가 아니라 &lt;strong>해시 인덱스 히트율&lt;/strong>과 &lt;strong>인덱스가 사용 중인 메모리 공간&lt;/strong>, &lt;strong>서버의 CPU 사용량&lt;/strong>을 종합해서 판단해야 한다.&lt;/p>
&lt;p>위 실행 쿼리 결과에서는 28% 정도가 어댑티브 해시 인덱스를 이용했다는 것을 알 수 있는데, 서버의 CPU 사용량이 100%에 근접한다면 효율적이라고 볼 수 있다. 하지만 CPU 사용량이 낮고 어댑티브 해시 인덱스의 메모리 사용량이 높다면 비활성화하여 버퍼풀이 더 많은 메모리를 사용할 수 있게 유도하는 것도 좋은 방법이다.&lt;/p>
&lt;p>어댑티브 해시 인덱스의 메모리 사용량은 performance_schema를 이용해서 확인 가능하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">EVENT_NAME&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">CURRENT_NUMBER_OF_BYTES_USED&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">memory_summary_global_by_event_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">EVENT_NAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;memory/innodb/adaptive hash index&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="myisam-memory-스토리지-엔진-비교">MyISAM, MEMORY 스토리지 엔진 비교&lt;/h2>
&lt;h3 id="myisam">MyISAM&lt;/h3>
&lt;p>MySQL 5.5부터는 InnoDB 스토리지 엔진이 기본 스토리지 엔진으로 채택 되었지만, 이전까지는 MyISAM이 기본 스토리지 엔진으로 사용되는 경우가 많았다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>MySQL 서버의 시스템 테이블의 기본 스토리지 엔진&lt;/strong>
MySQL 8.0 부터는 MyISAM이 기본 설정되었던 서버의 시스템 테이블(사용자 인증 관련 정보, 복제 관련 정보가 저장된 mysql DB의 테이블) 등 서버의 모든 기능을 InnoDB 스토리지 엔진으로 교체되었다.&lt;/li>
&lt;li>&lt;strong>전문 검색 및 공간 좌표 검색 기능 제공.&lt;/strong>
InnoDB 스토리지 엔진에서도 전문 검색과 공간 좌표 검색 기능을 모두 지원하도록 개선되었다.&lt;/li>
&lt;/ul>
&lt;p>이러한 이유로 MyISAM 스토리지 엔진은 InnoDB 스토리지 엔진으로 대체될 것으로 예상된다.&lt;/p>
&lt;h3 id="memory">MEMORY&lt;/h3>
&lt;p>MEMORY 스토리지 엔진이 메모리라는 이름 때문에 과대 평가를 받는 경우가 있다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>단일 스레드 처리 성능
단일 스레드 처리 성능은 MEMORY 스토리지 엔진이 빠를 수 있으나, MySQL 서버는 일반적으로 온라인 트랜잭션 처리를 위한 목적으로 사용되어 동시 처리 성능이 매우 중요하다. MEMORY 스토리지 엔진에서 동시에 많은 클라이언트 쿼리 요청이 실행되는 상황이라면 테이블 수준의 잠금으로 인해 InnoDB 스토리지 엔진을 따라갈 수 없다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>임시 테이블 용도로 활용
MySQL 5.7 버전까지 내부 임시 테이블 용도로 활용되었으나, 가변 길이 타입의 컬럼을 지원하지 않는다는 문제점으로 MySQL 8.0 부터는 TempTable 스토리지 엔진이 대체되어 사용된다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>이러한 이유로 MEMORY 스토리지 엔진을 선택해서 얻을 수 있는 장점이 없어져, 향후 버전에서는 제거될 것으로 예상된다.&lt;/p></description></item><item><title>4.2 InnoDB 스토리지 엔진 아키텍처(2) - InnoDB 버퍼풀</title><link>https://codemario318.github.io/post/real_mysql_4_2_2/</link><pubDate>Wed, 12 Apr 2023 14:27:41 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_4_2_2/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_2/real_mysql.jpeg" alt="Featured image of post 4.2 InnoDB 스토리지 엔진 아키텍처(2) - InnoDB 버퍼풀" />&lt;p>버퍼풀은 InnoDB 스토리지 엔진의 핵심으로 디스크에서 데이터를 읽어 메모리에 보관하고, 필요할 때 메모리에서 데이터를 읽어와 처리하는 역할을 수행한다. 또한디스크와 메모리 사이에서 데이터 읽기 및 쓰기를 관리하여 데이터 베이스의 성능을 향상시킨다.&lt;/p>
&lt;ul>
&lt;li>디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다.&lt;/li>
&lt;li>쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 수행한다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>일반적인 애플리케이션에서는 &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code>처럼 데이터를 변경하는 쿼리는 데이터 파일의 흩어져있는 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킨다. 변경을 모아 처리하여 랜덤 디스크 접근 작업 수를 줄일 수 있다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="버퍼풀의-크기-설정">버퍼풀의 크기 설정&lt;/h2>
&lt;p>운영체제와 각 클라이언트 스레드가 사용할 메모리도 충분히 고려하여 설정한다. MySQL 서버 내에서 메모리를 필요로 하는 부분은 크게 없지만 아주 독특한 경우 레코드 버퍼가 상당한 메모리를 사용하기도 한다.&lt;/p>
&lt;blockquote>
&lt;p>레코드버퍼&lt;br>
각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간으로 커넥션이 많고 사용하는 테이블도 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 많이 필요할 수 있다.&lt;/p>
&lt;/blockquote>
&lt;p>MySQL 서버가 사용하는 레코드 버퍼 공간은 별도로 설정할 수 없어, 전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 테이블의 개수에 따라 결정되고, 동적으로 해제되기도 하므로 정확히 필요한 메모리의 크기를 계산할 수 없다.&lt;/p>
&lt;h3 id="버퍼풀-동적-크기-조절">버퍼풀 동적 크기 조절&lt;/h3>
&lt;p>MySQL 5.7 버전부터 InnoDB 버퍼풀의 크기를 동적으로 조절할 수 있게 개선되어 가능하면 InnoDB 버퍼풀의 크기를 적절히 작은 값으로 설정하고 상황을 봐가며 증가시키는 방법이 최적이다.&lt;/p>
&lt;p>&lt;code>innodb_buffer_pool_size&lt;/code> 시스템 변수로 크기를 설정할 수 있으며, 동적으로 버퍼풀의 크기를 확장할 수 있다.&lt;/p>
&lt;ul>
&lt;li>크리티컬한 변경이므로 가능하며 MySQL 서버가 한가한 시점을 골라 실행한다.&lt;/li>
&lt;li>버퍼풀의 크기를 줄이는 작업은 서비스 영향도가 매우 크므로 주의해야한다.&lt;/li>
&lt;li>버퍼풀은 내부적으로 128MB 청크 단위로 쪼개어 관리되어 조절된다.&lt;/li>
&lt;/ul>
&lt;h3 id="버퍼풀-나누기">버퍼풀 나누기&lt;/h3>
&lt;p>InnoDB 버퍼풀은 정통적으로 버퍼풀 전체를 관리하는 잠금(세마포어)으로 인해 내부 잠금 경합을 많이 유발해왔는데, 이런 경함을 줄이기 위해 버퍼풀을 여러개로 쪼개어 관리할 수 있게 개선되었다.&lt;/p>
&lt;blockquote>
&lt;p>버퍼풀이 여러 개의 작은 버퍼풀로 쪼개지면서 개별 버퍼풀을 관리하는 잠금 자체도 경합이 분산되는 효과를 얻을 수 있게 된다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>innodb_buffer_pool_instances&lt;/code> 시스템 변수를 이용해 버퍼풀을 여러개로 분리하여 관리할 수 있다.&lt;/p>
&lt;h2 id="버퍼풀-구조">버퍼풀 구조&lt;/h2>
&lt;p>InnoDB 스토리지 엔진은 버퍼풀이라는 거대한 메모리 공간을 페이지 크기(&lt;code>innodb_page_size&lt;/code> 시스템 변수에 설정된)의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>페이지(Page)&lt;br>
데이터베이스에서 읽어온 데이터의 기본 단위. 일반적으로 16KB의 크기를 가지며, 디스크에서 데이터를 읽어와서 메모리에 로드됨&lt;/p>
&lt;/li>
&lt;li>
&lt;p>프레임(Frame)&lt;br>
버퍼풀에 로드된 페이지의 메모리 상의 표현. 페이지와 같은 크기(일반적으로 16KB)를 가지며, 페이지와 연관된 모든 정보를 포함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>풀(Pool)&lt;br>
프레임의 컬렉션. 버퍼풀에서 사용 가능한 모든 프레임을 포함한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>큐(Queue)&lt;br>
버퍼풀에서 사용하는 페이지 교체 알고리즘을 위해 사용. 프레임에 대한 포인터 리스트로 구성됨. 페이지 교체 알고리즘은 큐에서 프레임을 선택하여 페이지를 교체한다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>버퍼풀의 페이지 조각을 관리하기 위해 LRU(least Recently Used) 리스트와, 플러시(Flush) 리스트, 프리(Free) 리스트라는 3개의 자료 구조를 관리한다.&lt;/p>
&lt;ul>
&lt;li>LRU 리스트: 디스크로부터 읽어온 페이지 저장하는 자료구조. 읽어온 페이지를 최대한 오랫동안 버퍼풀의 메모리에 유지하여 디스크 읽기를 최소화 한다.&lt;/li>
&lt;li>플러시 리스트: 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리한다.&lt;/li>
&lt;li>프리리스트: 버퍼풀에서 실제 사용자 데이터로 채워지지 않은 비어있는 페이지들의 목록. 사용자의 쿼리가 새로벡 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.&lt;/li>
&lt;/ul>
&lt;h3 id="lru-리스트-구조">LRU 리스트 구조&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_2/mysql_4_13.png"
width="316"
height="292"
srcset="https://codemario318.github.io/post/real_mysql_4_2_2/mysql_4_13_hue0f5dcd0b58a4f8a7118d2c75e37f46e_29762_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_2/mysql_4_13_hue0f5dcd0b58a4f8a7118d2c75e37f46e_29762_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="LRU 리스트 구조"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="259px"
>&lt;/p>
&lt;p>LRU 리스트는, &lt;strong>Old 서브리스트 영역&lt;/strong>은 LRU, **New 서브리스트 영역은 MRU(Most Recently Used)**가 합쳐진 방식으로 동작한다.&lt;/p>
&lt;p>New 서브리스트의 Tail과 Old 서브리스트의 Head가 만나는 지점을 MidPoint라 하며 버퍼풀에 새로운 페이지가 들어올 경우 Old 서브리스트의 Head 부분에 저장한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>New 서브리스트와 Old 서브리스트로 나눈 이유는?&lt;/strong>&lt;br>
하나의 큐를 사용하여 페이지를 관리할 경우에 Head 또는 Tail에 페이지를 저장하는 방식을 생각해 볼 수 있다. Head에 저장될 경우 새로 관리되는 페이지가 사용되지 않더라도 오랜 시간동안 리스트에 남아 있게되고, Tail에 저장될경우 해당 페이지를 즉시 읽지 않는다면 리스트에 남아있지 않게 되어 의미가 없어질 수 있다.&lt;br>
이를 위해 두개의 서브리스트로 나누고, 경험적으로 얻은 5/8 지점을 활용한 중간점 삽입 전략을 사용하는 것 같다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="데이터를-찾는-과정">데이터를 찾는 과정&lt;/h3>
&lt;ol>
&lt;li>필요한 레코드가 저장된 데이터 페이지가 버퍼풀에 있는지 검사
&lt;ol>
&lt;li>InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색&lt;/li>
&lt;li>해당 테이블의 인덱스(B-Tree)를 이용해 버퍼풀에서 페이지를 검색&lt;/li>
&lt;li>버퍼풀에 이미 데이터 페이지가 있다면 해당 페이지의 포인터를 MRU 방향으로 승급&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>디스크에서 필요한 데이터 페이지를 버퍼풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가&lt;/li>
&lt;li>버퍼풀의 LRU 헤더에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동(Read Ahead와 같이 대량 읽기의 경우 디스크 페이지가 버퍼풀로 적재는 되지만 실제 쿼리에서 사용되지는 않을수도 있으며, 이련 경우는 MRU로 이동되지 않음)&lt;/li>
&lt;li>버퍼풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이가 부여되며, 버퍼풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 오래된 페이지는 버퍼풀에서 제거됨. 버퍼풀의 페이지가 쿼리에 의해 사용되면 나이가 초기회되고 MRU헤더 부분으로 옮겨진다.&lt;/li>
&lt;li>필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가&lt;/li>
&lt;/ol>
&lt;p>처음 한번 읽힌 데이터 페이지가 이후 자주 사용된다면 버퍼풀의 MRU 영역에서 살아남게 되고, 그렇지 않은 경우 새롭게 읽히는 데이터 페이지에 밀려 결과적으로 버퍼풀에서 제거된다.&lt;/p>
&lt;h2 id="버퍼풀과-리두-로그">버퍼풀과 리두 로그&lt;/h2>
&lt;p>버퍼풀은 데이터 베이스 서버의 성능 향상을 위해 &lt;strong>데이터 캐시&lt;/strong>와 &lt;strong>쓰기 버퍼링&lt;/strong>이라는 두가지 용도가 있다.
따라서 메모리가 허용하는 만큼 크게 설정하면 데이터 캐시 공간을 키워 쿼리의 성능 높힐 수 있지만, 쓰기 버퍼링 성능 향상을 위해서는 버퍼풀과 리두 로그의 관계에 대해 이해하는 것이 중요하다.&lt;/p>
&lt;h3 id="리두-로그redo-log란">리두 로그(Redo Log)란?&lt;/h3>
&lt;p>리두 로그는 데이터베이스에 대한 모든 변경 내용을 기록하는 파일셋이다. 시스템 장애나 충돌이 발생했을 때 데이터의 내구성과 일관성을 보장하기 위해 사용된다.&lt;/p>
&lt;p>데이터베이스에 변경 사항이 발생하면, 먼저 선로깅(write-ahead logging)프로세스로 리두 로그에 쓰여지고 변경 내용이 리두 로그에 기록되면 데이터베이스에 적용된다.&lt;/p>
&lt;p>리두 로그 파일은 일반적으로 디스크에 저장되며, MySQL은 변경 사항을 순차적으로 기록한다. 리두 로그 파일이 가득 차면 MySQL은 &amp;ldquo;체크포인트(checkpoint)&amp;ldquo;를 수행하여 데이터베이스의 모든 더티 페이지(버퍼풀에서 수정된 페이지)를 디스크에 기록한 후, 로그 파일을 잘라내어 공간을 확보하게 된다.&lt;/p>
&lt;p>MySQL에서 리두 로그는 원형 버퍼 형식으로 저장되며, 채워지면 다음 변경 사항은 순환 방식으로 다음 사용 가능한 리두 로그 파일에 기록된다. 이를 통해 리두 로그에 변경 사항이 지속적으로 기록되어 시스템 충돌이나 장애가 발생하더라도 변경 사항을 손실하지 않도록 보장한다.&lt;/p>
&lt;h3 id="버퍼풀과-리두-로그의-관계">버퍼풀과 리두 로그의 관계&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_2/mysql_4_14.png"
width="254"
height="212"
srcset="https://codemario318.github.io/post/real_mysql_4_2_2/mysql_4_14_hu12b3affca177d60e9363f94fd37fd0f1_14755_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_2/mysql_4_14_hu12b3affca177d60e9363f94fd37fd0f1_14755_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="버퍼풀과 리두 로그의 관계"
class="gallery-image"
data-flex-grow="119"
data-flex-basis="287px"
>&lt;/p>
&lt;p>버퍼풀은 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지(Clean Page)와 함께 &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code>를 통해 변경된 데이터를 가진 더티 페이지(Duty Page)를 가지고 있다.&lt;/p>
&lt;p>데이터 변경이 발생하면 먼저 리두 로그에 기록되고 리두 로그는 더티 페이지와 대응하게 된다.&lt;br>
데이터 변경이 반복되면 결국 리두 로그 파일을 기록할 수 없거나 버퍼풀 용량이 부족해지는데, 이를 대응하기 위해 체크포인트를 수행하여 모든 더티페이지를 디스크에 기록한 후, 리두 로그 파일을 잘라내어 공간을 확보한다.&lt;/p>
&lt;p>이러한 방식이 버퍼풀이 쓰기 버퍼의 역할을 수행하게 만들게 되는데, 이에 따라서 리두 로그 파일의 크기가 작을수록 버퍼풀의 크기가 크더라도 대응되는 더티 페이지가 적으므로 버퍼링으로 얻을 수 있는 효과가 적어지고, 리두 로그 파일이 클수록 체크포인트를 통해 디스크에 기록되는 데이터가 많아져 갑자기 많은 디스크 I/O를 발생 시킬 수 있다.&lt;/p>
&lt;p>따라서, 리두 로그 파일의 크기를 적절히 선택해야하며, 어렵다면 버퍼풀의 크기가 100GB 이하의 MySQL 서버에서는 리두 로그 파일의 전체 크기를 대략 5~10GB 수준으로 선택하고 필요할 때마다 조금씩 늘려가며 최적값을 찾는 것이 좋다.&lt;/p>
&lt;h2 id="버퍼풀-플러시buffer-pool-flush">버퍼풀 플러시(Buffer Pool Flush)&lt;/h2>
&lt;p>버퍼풀에서 수정된 데이터 페이지를 디스크로 쓰는 과정으로 MySQL 5.6 버전까지는 InnoDB 스토리지 더티 페이지 플러시 기능이 급작스럽게 디스크 기록이 폭증해서 MySQL 서버의 사용자 쿼리 처리 성능에 영향을 받는 등 그다지 부드럽게 처리되지 않았다.&lt;/p>
&lt;p>MySQL 5.7 버전을 거쳐 8.0 버전으로 업그레이드되면서 대부분의 서비스에서는 더티 페이지 프러시에서 예전과 같이 폭증 현상은 발생하지 않았다. 따라서 InnoDB 스토리지 엔진의 더티 페이지 플러시 성능 문제가 발생하지 않는다면 관련 시스템 변수는 조절하지 않아도 괜찮다.&lt;/p>
&lt;p>InnoDB 스토리지 엔진은 버퍼풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상 악영향 없이 디스크에 동기화하기 위해 다음과 같이 2개의 플러시 기능을 백그라운드로 실행한다.&lt;/p>
&lt;ul>
&lt;li>플러시 리스트(Flush_list) 플러시&lt;/li>
&lt;li>LRU 리스트(LRU_list) 플러시&lt;/li>
&lt;/ul>
&lt;h3 id="플러시-리스트-플러시">플러시 리스트 플러시&lt;/h3>
&lt;p>InnoDB 스토리지 엔진은 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비운다. 이때 오래된 리두 로그 공간이 지워지려면 반드시 InnoDB 버퍼풀의 더티 페이지가 먼저 디스크로 동기화 돼야 한다.&lt;/p>
&lt;p>이를 위해 InnoDB 스토리지 엔진은 주기적으로 플러시 리스트(Flush_list) 플러시 함수를 호출하여 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화 하는 작업을 수행한다.&lt;/p>
&lt;p>이때 언제부터 얼마나 많은 더티 페이지를 한번에 디스크로 기록하느냐에 따라 사용자의 쿼리 처리가 악영향을 받지 않으면서 부드럽게 처리된다. 리를 위해 InnoDB 스토리지 엔진은 여러 시스템 변수를 제공한다.&lt;/p>
&lt;h4 id="innodb_page_cleaners">&lt;code>innodb_page_cleaners&lt;/code>&lt;/h4>
&lt;p>InnoDB 스토리지 엔진에서 더티 페이지를 디스크로 동기화하는 스레드를 클리너 스레드(Cleaner Thread)라고 하고, 클리너 스레드의 개수를 조정할 수 있게 해준다.&lt;/p>
&lt;p>설정값이 버퍼풀 인스턴스 개수보다 많은 경우 &lt;code>innodb_buffer_pool_instances&lt;/code> 설정값으로 자동으로 변경하여, 하나의 클리너 스레드가 하나의 버퍼풀 인스턴스를 처리하도록 한다.&lt;/p>
&lt;p>시스템 변수의 설정값이 버퍼풀 인스턴스 개수보다 적은 경우 하나의 클리너 스레드가 여러 개의 버퍼풀 인스턴스를 처리하므로, &lt;code>innodb_page_cleaners&lt;/code> 설정값은 &lt;code>innodb_buffer_pool_instances&lt;/code> 설정 값과 동일하게 설정하는 것이 좋다.&lt;/p>
&lt;h4 id="innodb_max_dirty_pages_pct">&lt;code>innodb_max_dirty_pages_pct&lt;/code>&lt;/h4>
&lt;p>InnoDB 버퍼풀은 클린 페이지와 더티 페이지를 함께 가지고 있어 뭏란정 더티 페이지를 그대로 유지할 수 없다.
기본적으로 InnoDB 스토리지 엔진은 전체 버퍼풀이 가진 페이지의 90%까지 더티페이지를 가질 수 있는데, &lt;code>innodb_max_dirty_pct&lt;/code> 시스템 변수를 이용해 더티페이지의 비율을 조절할 수 있다.&lt;/p>
&lt;p>일반적으로 버퍼풀이 더티페이지를 많이 가지고 있을수록 디스크 쓰기 작업을 버퍼링함으로써 I/O 작업을 줄일 수 있으므로 기본값으로 유지하는 것이 좋다.&lt;/p>
&lt;h4 id="innodb_max_dirty_pages_pct_lwm">&lt;code>innodb_max_dirty_pages_pct_lwm&lt;/code>&lt;/h4>
&lt;p>InnoDB 스토리지 엔진은 &lt;code>innodb_io_capacity&lt;/code> 시스템 변수에 설정된 값을 기준으로 더티 페이지 쓰기를 실행하는데, 디스크로 기록되는 더티페이지 개수보다 더 많은 더티페이지가 발생하면 버퍼풀에 더티페이지가 계속 증가하게 되고, 지정한 비율이 넘어가면 더티페이지를 디스크로 기록하여 디스크 쓰기 폭발(Dist IO Bust) 현상이 발생할 가능성이 있다.&lt;/p>
&lt;p>이런 문제를 완화하기 위해 &lt;code>innodb_max_dirty_pages_pct_lwm&lt;/code> 시스템 설정 변수를 이용해 일정 수준 이상의 더티페이지가 발생하면 조금씩 더티 페이지를 디스크로 기록한다.&lt;/p>
&lt;p>기본값은 10% 정도로, 디스크 쓰기가 많이 발생하고 더티 페이지 비율이 낮은 상태를 유지한다면 높은 값으로 조정할 수 있다.&lt;/p>
&lt;h4 id="innodb_io_capacity-innodb_io_capacity_max">&lt;code>innodb_io_capacity&lt;/code>, &lt;code>innodb_io_capacity_max&lt;/code>&lt;/h4>
&lt;p>데이터베이스 서버에서 어느정도의 디스크 IO가 가능한지 설정하는 값이다.
&lt;code>innodb_io_capacity는&lt;/code> 일반적인 상황에서 디스크가 적절히 처리할 수 있는 수준의 값을 설정하며, &lt;code>innodb_io_capacity_max&lt;/code>는 디스크가 최대 성능을 발휘할 때 어느 정도 IO가 가능한지를 설정한다.&lt;/p>
&lt;p>여기서 언급되는 IO는 InnoDB 스토리지 엔진의 백그라운드 스레드가 수행하는 디스크 작업을 의미하며, 대부분 더티페이지 쓰기이다.&lt;/p>
&lt;p>스토리지 엔진은 사용자의 쿼리를 처리하기 위해 디스크를 읽기도 해야하므로 하드웨어 성능에 무조건 맞추는 것은 좋지 않다.&lt;/p>
&lt;h4 id="innodb_adaptive_flushing-innodb_adaptive_flushing_lwm">&lt;code>innodb_adaptive_flushing&lt;/code>, &lt;code>innodb_adaptive_flushing_lwm&lt;/code>&lt;/h4>
&lt;p>어댑티브 플러시를 활성화 하면 InnoDB 스토리지 엔진은 버퍼불의 더티 페이지 비율이나 &lt;code>innodb_io_capacity&lt;/code>, &lt;code>innodb_io_capacity_max&lt;/code> 설정 값에 의존하지 않고 알고리즘을 사용한다.&lt;/p>
&lt;p>더티 페이지는 리두 로그와 대응하므로, 리두 로그가 어느정도 증가하는지 분석하여 확인할 수 있다. 어댑티브 플러시 알고리즘은 리두 로그의 증가 속도를 분석하여 적절한 수준의 더티 페이지가 버퍼풀에 유지될 수 있도록 디스크 쓰기를 실행한다.&lt;/p>
&lt;p>&lt;code>innodb_adaptive_flushing&lt;/code>는 기본값이 활성이며, &lt;code>innodb_adaptive_flushing_lwm&lt;/code>는 어댑티브 플러시 알고리즘 활성을 위한 활성 리두 공간의 하한 비율을 의미한다.&lt;/p>
&lt;h4 id="innodb_flush_neighbors">&lt;code>innodb_flush_neighbors&lt;/code>&lt;/h4>
&lt;p>더티페이지를 디스크에 기록할 때 디스크에서 근접한 페이지 중 더티페이지가 있다면 InnoDB 스토리지 엔진이 함께 묶어 디스크로 기록하게 해주는 기능을 활성화 할지 결정한다.&lt;/p>
&lt;p>과거에는 HDD의 경우 IO 비용이 높아 최대한 줄이기 위해 만들어졌다.&lt;/p>
&lt;p>데이터 저장을 하드디스크로 하고있다면 1, 2 정도로 활성화 하고, SDD를 사용한다면 기본값인 비활성으로 유지하는 것이 좋다.&lt;/p>
&lt;h3 id="lru-리스트-플러시">LRU 리스트 플러시&lt;/h3>
&lt;p>InnoDB 스토리지 엔진은 LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거하여 새로운 페이지들을 읽어올 공간을 만들어야 하는데, 이를 위해 LRU 리스트 플러시 함수가 사용된다.&lt;/p>
&lt;p>리스트 끝부분 부터 시작하여 최대 &lt;code>innodb_lru_scan_depth&lt;/code> 시스템 변수에 설정된 수만큼의 페이지들을 스캔하는데, 이때 더티체이지는 디스크에 동기화하고, 클린 페이지는 즉시 프리 리스트로 페이지를 옮긴다.&lt;/p>
&lt;p>InnoDB 스토리지 엔진은 버퍼풀 인스턴스 별로 최대 &lt;code>innodb_lru_scan_depth&lt;/code> 개수만큼 스캔하기 때문에 실질적으로 LRU 리스트의 스캔은 (&lt;code>innodb_buffer_pool_instances&lt;/code> * &lt;code>innodb_lru_scan_depth&lt;/code>) 수만큼 수행하게 된다.&lt;/p>
&lt;h2 id="버퍼풀-상태-백업-및-복구">버퍼풀 상태 백업 및 복구&lt;/h2>
&lt;p>InnoDB 서버의 버퍼풀은 쿼리의 성능에 매우 밀접하게 연결돼 있다. 서버 재실행시 버퍼풀에 쿼리들이 사용할 데이터가 없어 성능이 매우 떨어지게 된다.&lt;/p>
&lt;p>디스크의 데이터가 버퍼풀에 적재돼 있는 상태를 위밍업(Warming Up)이라고 표현하는데, 워밍업 상태에 따라 몇십 배 쿼리 처리속도 차이가 발생하게 된다.&lt;/p>
&lt;p>MySQL 5.5 버전은 재실행시 강제 워밍업을 위해 주요 테이블과 인덱스에 대해 풀스캔을 실행하고 서비스를 오픈했었다. 하지만 5.6 버전부터는 버퍼풀 덤프 및 적재 기능이 도입되어 MySQL 서버 셧다운 전 &lt;code>innodb_buffer_pool_dump_now&lt;/code> 시스템 변수를 이용해 현재 InnoDB 버퍼풀 상태를 백업할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* 버퍼풀 상태 백업 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_buffer_pool_dump_now&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/* 백업된 버퍼풀 상태 복구 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_buffer_pool_load_now&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>버퍼풀 백업을 수행하면 데이터 디렉터리에 ib_buffer_pool이라는 파일로 생성되는데, InnoDB 스토리지 엔진이 버퍼풀의 LRU 리스트에서 적재된 데이터 페이지의 메타 정보만 가져와 저장하여, 버퍼풀이 크다고 하더라도 몇십 MB 이하로 작다.&lt;/p>
&lt;p>하지만 버퍼풀로 복구하는 과정에서 각 테이블의 데이터 페이지를 디스크에서 다시 읽어와야 하기 때문에 버퍼풀의 크기에 따라 매우 오래 걸릴 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Innodb_buffer_pool_dump_status&amp;#39;&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="k">G&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>InnoDB의 버퍼풀을 복구하는 작업은 상당히 많은 디스크 읽기를 필요로 하기 때문에, 복구중 서비스 재개하는 것은 좋지 않을 수 있다. 버퍼풀 적재 작업을 중지하려면 &lt;code>innodb_buffer_pool_load_abort&lt;/code> 시스템 변수를 통해 중지하여 재개하는 것을 권장한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_buffer_pool_load_abort&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="백업-및-복구-자동화">백업 및 복구 자동화&lt;/h3>
&lt;p>InnoDB 스토리지 엔진은 &lt;code>innodb_buffer_pool_dump_at_shutdown&lt;/code>, &lt;code>innodb_buffer_pool_load_at_shutdown&lt;/code> 설정을 MySQL 설정 파일에 넣으면 서버가 셧다운 되기 직전에 버퍼풀의 백업을 실행하고, MySQL 서버가 시작되면 자동으로 백업된 버퍼풀의 상태를 복구할 수 있는 기능을 제공한다.&lt;/p>
&lt;h2 id="버퍼풀의-적재-내용-확인">버퍼풀의 적재 내용 확인&lt;/h2>
&lt;p>MySQL 5.6 버전부터 MySQL 서버의 &lt;code>infomation_schema&lt;/code> 데이터베이스의 &lt;code>innodb_buffer_page&lt;/code> 테이블을 이용해 InnoDB 버퍼풀의 메모리에 어떤 테이블의 페이지들이 적재돼 있는지 확인할 수 있었다. 하지만 버퍼풀이 큰 경우에는 테이블 조회가 상당히 큰 부하를 일으키면서 서비스 쿼리가 많이 느려지는 문제가 있어, 실제 서비스용으로 사용되는 MySQL 서버에서는 버퍼풀의 상태를 확인하는 것이 거의 불가능했다.&lt;/p>
&lt;p>MySQL 8.0 버전에서는 &lt;code>information_schema&lt;/code> 데이터베이스에 &lt;code>innodb_cached_indexes&lt;/code> 테이블이 새로 추가되어, 테이블의 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼풀에 적재돼 있는지 확인할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ii&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">index_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ici&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">n_cached_pages&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n_cached_pages&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">information_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">innodb_tables&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">information_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">innodb_indexes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ii&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ii&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">table_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">table_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">information_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">innodb_cached_indexes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ici&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ici&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">index_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ii&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">index_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">CONCAT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;employees&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;/&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;employees&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>아직 MySQL 서버는 개별 인덱스별로 전체 페이지 개수가 몇 개인지는 사용자에게 알려주지 않기 때문에 information_schema의 테이블을 이용해도 테이블의 인덱스별로 페이지가 InnoDB 버퍼풀에 적재된 비율은 확인할 수가 없다.&lt;/p></description></item><item><title>4.2 InnoDB 스토리지 엔진 아키텍처(1)</title><link>https://codemario318.github.io/post/real_mysql_4_2_1/</link><pubDate>Tue, 11 Apr 2023 19:15:11 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_4_2_1/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_1/real_mysql.jpeg" alt="Featured image of post 4.2 InnoDB 스토리지 엔진 아키텍처(1)" />&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_1/mysql_4_9.png"
width="430"
height="388"
srcset="https://codemario318.github.io/post/real_mysql_4_2_1/mysql_4_9_hu105976b7b8154af6ae8266098f664ca6_57568_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_1/mysql_4_9_hu105976b7b8154af6ae8266098f664ca6_57568_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="InnoDB 구조"
class="gallery-image"
data-flex-grow="110"
data-flex-basis="265px"
>&lt;/p>
&lt;p>InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.&lt;/p>
&lt;h2 id="프라이머리-키에-의한-클러스터링">프라이머리 키에 의한 클러스터링&lt;/h2>
&lt;p>InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 자장된다.&lt;/p>
&lt;ul>
&lt;li>프라이머리 키 값의 순서대로 디스크에 저장되며, 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.&lt;/li>
&lt;li>프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.&lt;/li>
&lt;li>쿼리의 실행계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다.&lt;/li>
&lt;/ul>
&lt;h2 id="외래-키-지원">외래 키 지원&lt;/h2>
&lt;p>외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.&lt;/p>
&lt;p>외래 키는 데이터베이스 서버 운영의 불편함 때문에 서비스용 데이터베이스에서는 생성하지 않는 경우도 자주 있다. 그렇다 하더라도 개발 환경의 데이터베이스에서는 좋은 가이드 역할을 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요함&lt;/li>
&lt;li>변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로, 잠금이 여러 테이블로 전파됨&lt;/li>
&lt;li>그로인한 데드락이 발생할 때가 많으므로 개발할때도 외래 키의 존재에 주의하는 것이 좋음&lt;/li>
&lt;/ul>
&lt;p>수동으로 데이터를 적재하거나 스키마 변경 등의 관리 작업이 실패할 수 있다. 부모 테이블과 자식 테이블의 관계를 명확히 파악해서 순서대로 작업한다면 문제없이 실행될 수 있지만 외래키가 복잡하게 얽힌 경우에는 간단하지 않다.&lt;/p>
&lt;p>&lt;code>foreign_key_checks&lt;/code> 시스템 변수를 &lt;code>OFF&lt;/code>로 설정하면 외래키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다. 외래키 체크 작업을 일시적으로 멈추면 대략 레코드 적재나 삭제 등의 작업도 부가적인 체크가 필요 없기 때문에 훨씬 빠르게 처리할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">foreign_key_checks&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">OFF&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/* 작업 수행 ... */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">foreign_key_checks&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>외래키 체크를 일시적으로 중지한 상태에서 외래키 관계를 가진 부모 테이블의 레코드를 삭제했다면 반드시 자식 테이블의 레코드도 살제하여 일관성을 맞춰준 후 다시 외래키 체크 기능을 활성화 해야 한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>foreign_key_checks&lt;/code>가 비활성화되면 외래키 관계의 부모 테이블에 대한 작업도 무시한다.(&lt;code>ON DELETE CASCADE&lt;/code>, &lt;code>ON UPDATE CASCADE&lt;/code>)&lt;/p>
&lt;/blockquote>
&lt;h2 id="mvcc---multi-version-concurrency-control">MVCC - Multi Version Concurrency Control&lt;/h2>
&lt;p>일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 &lt;em>&lt;strong>잠금을 사용하지 않는 일관된 읽기&lt;/strong>&lt;/em>를 제공하는 데 있다.&lt;/p>
&lt;p>InnoDB는 언두 로그(Undo log)를 이용해 이 기능을 구현한다.&lt;/p>
&lt;ul>
&lt;li>멀티 버전: 하나의 레코드에 대해 여러 개의 버전이 동시에 관리&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">member&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">m_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">m_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">m_area&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m_id&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ix_area&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m_area&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">member&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">m_name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">m_area&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;홍길동&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;서울&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">COMMIT&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">UPDATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">member&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">m_area&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;경기&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">m_id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_1/mysql_4_11.png"
width="381"
height="336"
srcset="https://codemario318.github.io/post/real_mysql_4_2_1/mysql_4_11_hu900f8d0207e527c4c59056077a732b18_46489_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_1/mysql_4_11_hu900f8d0207e527c4c59056077a732b18_46489_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="113"
data-flex-basis="272px"
>&lt;/p>
&lt;p>UPDATE 문장이 실행되면 커밋 실행 여부와 관계 없이 InnoDB의 버퍼풀은 새로운 값인 ‘경기’로 업데이트 된다. 그리고 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 스레드에 의해 새로운 값으로 업데이트돼 있을 수도 있고 아닐 수도 있다.(InnoDB가 ACID를 보장하기 때문에 일반적으로는 InnoDB의 버퍼풀과 데이터 파일은 동일한 상태라고 가정해도 무방함)&lt;/p>
&lt;p>아직 COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 다음 같은 쿼리로 작업 중인 레코드를 조회한다면, MySQL 서버의 시스템 변수(&lt;code>transaction_isolation&lt;/code>)에 설정된 격리 수준(Isolation level)에 따라 다르다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>READ_UNCOMMITED&lt;/code>: InnoDB 버퍼풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환한다.&lt;/li>
&lt;li>&lt;code>READ_COMMITTED&lt;/code>, &lt;code>REPEATABLE_READ&lt;/code>, &lt;code>SERIALIZABLE&lt;/code>: 아직 커밋되지 않았기 때문에 InnoDB 버퍼풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환한다.&lt;/li>
&lt;/ul>
&lt;p>이러한 과정을 DBMS에서는 MVCC라고 표현한다. 즉 하나의 레코드(회원번호가 12인 레코드)에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 다르다.&lt;/p>
&lt;p>트랜잭션이 길어지면 언두에서 관리하는 예전 데이터가 삭제되지 못하고 오랫동안 관리되어야 하며, 자연히 언두 영역이 저장되는 시스템 테이블 스페이스의 공간이 많이 늘어나는 상황이 발생할 수 있다.&lt;/p>
&lt;p>&lt;code>UPDATE&lt;/code> 쿼리가 실행되면 InnoDB 버퍼 풀은 즉시 새로운 데이터로 변경되고 기존 데이터는 언두영역으로 복사된다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>COMMIT&lt;/code>: InnoDB는 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어 버린다.&lt;/li>
&lt;li>&lt;code>ROLLBACK&lt;/code>: 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제한다.&lt;/li>
&lt;/ul>
&lt;p>커밋이 된다고 언두 영역의 백업 데이터가 항상 바로 삭제되지는 않고, 언두 영역을 필요로 하는 트랜잭션이 없을때 삭제된다.&lt;/p>
&lt;h2 id="잠금-없는-일관된-읽기---non-locking-consistent-read">잠금 없는 일관된 읽기 - Non-Locking Consistent Read&lt;/h2>
&lt;p>InnoDB 스토리지 엔진은 MVCC 기술을 이용해 감금을 걸지 않고 읽기 작업을 수행한다. 잠금을 걸지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능하다.&lt;/p>
&lt;p>격리수준이 &lt;code>SERIALIZABLE&lt;/code>이 아닌 &lt;code>READ_UNCOMMITED&lt;/code>나 &lt;code>READ_COMMITED&lt;/code>, &lt;code>REPEATEABLE_READ&lt;/code> 수준인 경우 &lt;code>INSERT&lt;/code>와 연결되지 않은 순수한 읽기(&lt;code>SELECT&lt;/code>) 작업은 다른 트랜잭션의 변경 작업과 관계 없이 항상 잠금을 대기하지 않고 바로 실행된다.&lt;/p>
&lt;p>특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 변경 트랜잭션이 다른 사용자의 &lt;code>SELECT&lt;/code> 작업을 방해하지 않는다. 이를 ‘잠금 없는 일관된 읽기’ 라고 표현하며, InnoDB에서는 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다.&lt;/p>
&lt;p>오랜 시간 동안 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 문제가 발생할 때가 가끔 있는데, 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생하는 문제이다.&lt;/p>
&lt;p>따라서 트랜잭션이 시작됐다면 가능한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋다.&lt;/p>
&lt;h2 id="자동-데드락-감지">자동 데드락 감지&lt;/h2>
&lt;p>InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 &lt;strong>잠금 대기 목록&lt;/strong>(Wait-for List)을 그래프 형태로 관리한다. InnoDB 스토리지 엔진은 데드락 감지 스레드를 통해 주기적으로 잠금 대기를 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를 &lt;strong>강제 종료&lt;/strong>한다.&lt;/p>
&lt;blockquote>
&lt;p>트랜잭션의 언두 로그양이 적은 트랜잭션이 롤백 해도 처리한 내용이 적기 때문에 선택된다.&lt;/p>
&lt;/blockquote>
&lt;p>InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금(&lt;code>LOCK TABLES&lt;/code> 명령으로 잠긴 테이블)은 볼 수가 없어 데드락 감지가 불확실 할 수 있는데, &lt;code>innodb_table_locks&lt;/code> 시스템 변수를 활성화 하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 &lt;strong>테이블 레벨의 잠금&lt;/strong> 까지 감지할 수 있게 된다.&lt;/p>
&lt;p>일반적인 서비스에서는 데드락 감지 스레드가 데드락을 찾아내는 작업은 부담되지 않지만, 동시 처리 스레드가 매우 많아지거나 트랜잭션이 가진 잠금 개수가 많아지면 데드락 감지 스레드가 느려진다.&lt;/p>
&lt;p>데드락 감지 스레드는 잠금 목록을 검사해야 하기 때문에 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트(잠금 테이블)에 새로운 잠금을 걸고 데드락 스레드를 찾게 되는데, 데드락 감시 스레드가 느려지면 서비스 쿼리를 처리중인 스레드는 더는 작업을 진행하지 못하고 대기하며 서비스에 악영항을 미치게 된다. 이렇게 동시 처리 스레드가 매우 많은 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있다.&lt;/p>
&lt;p>&lt;code>innodb_deadlock_detect&lt;/code> 시스템 변수를 활용하여 데드락 감지 스레드를 비활성화 할 수 있다. 이럴 경우 데드락 상황 발생시 무한정 대기할 수도 있지만, &lt;code>innodb_lock_wait_timeout&lt;/code> 시스템 변수를 활성화하면 일정 시간이 지났을 경우 요청 실패하고 에러 메시지를 반환하게 만들 수 있다.&lt;/p>
&lt;p>데드락 감시 스레드가 부담되어 &lt;code>innodb_deadlock_detect&lt;/code>를 OFF로 설장해서 비활성화 하는 경우에는 &lt;code>innodb_lock_time_wait_timeout&lt;/code>을 기본값인 50초보다 훨씬 낮은 시간으로 변경하여 사용할 것을 권장한다.&lt;/p>
&lt;h2 id="자동화된-장애-복구">자동화된 장애 복구&lt;/h2>
&lt;p>InnoDB에는 손실이나 장애로 부터 데이터를 보호하기 위한 여러가지 메커니즘이 탑재돼있다. 그러한 메커니즘을 이용해 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된(Partial write)데이터 페이지 등에 대한 인련의 복구 작업이 자동으로 진행된다.&lt;/p>
&lt;p>InnoDB 스토리지 엔진은 매우 견고해서 데이터 파일이 손상되거나 MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않지만, 디스크나 하드웨어 이슈로 InnoDB 스토리지 엔진이 자동으로 복구를 못 하는 경우도 발생할 수 있는데, 한번 문제가 생기면 복구하기 쉽지 않다.&lt;/p>
&lt;p>InnoDB 데이터 파일은 기본적으로 서버가 시작될 때 자동 복구를 수행하며, 자동으로 복구될 수 없는 손상이 있다면 서버가 종료된다.&lt;/p>
&lt;h3 id="장애-복구-대응">장애 복구 대응&lt;/h3>
&lt;p>MySQL 서버의 설정 파일에 &lt;code>innodb_force_recovery&lt;/code> 시스템 변수를 설정하여 시작해야 한다.&lt;/p>
&lt;ul>
&lt;li>6: 로그 파일 손상&lt;/li>
&lt;li>1: 테이블의 데이터 파일이 손상&lt;/li>
&lt;li>어떤 부분이 문제인지 알 수 없다면 1~6까지 변경하며 재실행&lt;/li>
&lt;/ul>
&lt;p>이후 서버가 가동되고 InnoDB 테이블이 인식된다면 &lt;code>mysqldump&lt;/code>를 이용해 데이터를 가능한 만큼 백업하고 그 데이터로 MySQL 서버의 DB와 테이블을 다시 생성하는 것이 좋다.&lt;/p>
&lt;h3 id="innodb_force_recovery-옵션">&lt;code>InnoDB_force_recovery&lt;/code> 옵션&lt;/h3>
&lt;ul>
&lt;li>1(&lt;code>SRV_FORCE_IGNORE_CORRUPT&lt;/code>):&lt;br>
테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분이 발견되도 무시하고 서버를 시작한다.
&lt;ul>
&lt;li>&lt;strong>&amp;lsquo;Database page corruption on disk or a failed&amp;rsquo;&lt;/strong> 출력되는 경우가 많다.&lt;/li>
&lt;li>&lt;code>mysqldump&lt;/code>나 &lt;code>SELECT INTO OUTFILE ...&lt;/code>를 이용해 덤프하여 데이터베이스를 다시 구축하는 것이 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>2(&lt;code>SRV_FORCE_NO_BACKGROUND&lt;/code>):&lt;br>
백그라운드 스레드 가운데 메인 스레드를 시작하지 않고 MySQL 서버를 시작한다.
&lt;ul>
&lt;li>메인 스레드가 언두 데이터를 삭제하는 과정에서 장애가 발생했을때 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>3(&lt;code>SRV_FORCE_NO_TRX_UNDO&lt;/code>):&lt;br>
일반적으로 MySQL 서버는 재실행시 언두 영역의 데이터를 먼저 파일에 적용하고 리두 로그의 내용을 다시 덮어써서 장애 시점의 데이터 상태를 만들어 낸 후, 최종적으로 커밋되지 않은 트랜잭션의 작업을 롤백하지만 3으로 설정시 롤백하지 않고 그대로 나둔다.
&lt;ul>
&lt;li>커밋되지 않고 종료된 트랜잭션은 계속 그 상태로 남아있게 된다.&lt;/li>
&lt;li>백업 후 데이터베이스를 다시 구축하는 것이 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>4(&lt;code>SRV_FORCE_NO_IBUF_MERGE&lt;/code>):&lt;br>
InnoDB는 &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 등의 데이터 변경으로 인한 인덱스 변경 작업을 상황에 따라 즉시처리 혹은 버퍼에 두고 나중에 처리할 수 있다. 인서트 버퍼를 통해 처리가 될 경우, 비정상 종료시 병합 될지 알 수 없기 때문에, 인서트 버퍼의 손상을 감지하면 에러를 발생시켜 MySQL 서버의 실행을 막는다.
&lt;ul>
&lt;li>인서트 버퍼의 내용을 무시하고 강제로 MySQL을 실행시킨다.&lt;/li>
&lt;li>인서트 버퍼는 실제 데이터와 관련된 부분이 아니라, 인덱스에 관련된 부분이므로 테이블을 텀프한 후 다시 데이터베이스를 구축하면 데이터의 손실 없이 복구할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>5(&lt;code>SRV_FORCE_NO_UNDO_LOG_SCAN&lt;/code>):&lt;br>
MySQL 서버가 종료되는 시점에 처리중인 트랜잭션이 있을 경우 별도의 처리 없이 커넥션을 강제로 끊어버리고 종료된다. MySQL 서버가 재실행되면 InnoDB 엔진은 언두 레코드를 이용해 데이터 페이지를 복구하고 리두 로그를 적용해 종료 시점의 상태로 만들고, 커밋되지 않은 트랜잭션에서 변경한 작업은 모두 롤백 처리한다. 이때 InnoDB 스토리지 엔진이 언두 로그를 사용할 수 없다면 에러가 발생하여 MySQL 서버가 실행될 수 없다.
&lt;ul>
&lt;li>언두 로그를 모두 무시하고 실행한다.&lt;/li>
&lt;li>MySQL 서버가 종료되던 시점에 커밋되지 않았던 작업도 모두 커밋된 것처럼 처리되어 잘못된 데이터가 남을 수 있다.&lt;/li>
&lt;li>데이터를 백업하고, 데이터베이스를 새로 구축해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>6(&lt;code>SRV_FORCE_NO_LOG_REDO&lt;/code>):&lt;br>
InnoDB 스토리지 엔진의 리두 로그가 손상되면 MySQL 서버가 실행되지 못한다. 해당 복구 모드로 실행하면 리두 로그를 무시하고 서버가 실행된다.&lt;br>
트랜잭션이 커밋됐다 하더라도 리두 로그에만 기록되고 데이터 파일에 기록되지 않은 데이터는 모두 무시되므로 마지막 체크 포인트시점의 데이터만 남게 된다.
&lt;ul>
&lt;li>기존 InnoDB의 리두 로그는 모두 삭제 또는 백업하고 MySQL 서버를 시작하는 것이 좋다.&lt;/li>
&lt;li>데이터를 백업하고 MySQL 서버를 새로 구축하는 것이 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위 방법을 수행해도 MySQL서버가 시작되지 않으면 백업을 이용해 다시 구축하는 방법밖에 없다. 백업이 있다면 마지막 백업으로 데이터베이스를 다시 구축하고, 바이너리 로그를 사용해 최대한 장애 시점까지의 데이터를 복구할 수도 있다.&lt;/p>
&lt;blockquote>
&lt;p>마지막 풀 백업 시점부터 장애 시점까지의 바이너리 로그가 있다면 이용하는 것이 데이터 손실이 더 적을 수 있다.&lt;/p>
&lt;/blockquote>
&lt;p>백업은 있지만 복제의 바이너리 로그가 없거나 손실되었다면, 마지막 백업 시점가지만 복구할 수 있다.&lt;/p></description></item><item><title>4.1 MySQL 엔진 아키텍처</title><link>https://codemario318.github.io/post/real_mysql_4_1/</link><pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate><guid>https://codemario318.github.io/post/real_mysql_4_1/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_4_1/real_mysql.jpeg" alt="Featured image of post 4.1 MySQL 엔진 아키텍처" />&lt;h2 id="mysql의-전체-구조">MySQL의 전체 구조&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_1/mysql_4_1.png"
width="780"
height="802"
srcset="https://codemario318.github.io/post/real_mysql_4_1/mysql_4_1_hu83fe18d660041abfde171686de4da5cf_206729_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_1/mysql_4_1_hu83fe18d660041abfde171686de4da5cf_206729_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL 전체 구조"
class="gallery-image"
data-flex-grow="97"
data-flex-basis="233px"
>
MySQL 서버는 크게 &lt;strong>MySQL 엔진&lt;/strong>과 &lt;strong>스토리지 엔진&lt;/strong>으로 구분할 수 있다.&lt;br>
사람으로 비유하면 MySQL 엔진은 머리 역할을 담담하고, 스토리지 엔진은 손과 발의 역할을 담당한다.&lt;/p>
&lt;h2 id="mysql-엔진">MySQL 엔진&lt;/h2>
&lt;p>MySQL 엔진은 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행한다.&lt;/p>
&lt;ul>
&lt;li>커넥션 핸들러: 클라이언트 요청에 따라 새로운 연결을 생성하고 관리&lt;/li>
&lt;li>SQL 파서 및 전처리기: SQL 쿼리를 최적화 및 실행하기 전에 구문 분석 및 전처리를 담당&lt;/li>
&lt;li>옵티마이저: 쿼리의 최적화&lt;/li>
&lt;/ul>
&lt;p>MySQL은 표준 SQL(ANSI SQL) 문법을 지원하기 때문에 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환되어 실행될 수 있다.&lt;/p>
&lt;h2 id="스토리지-엔진">스토리지 엔진&lt;/h2>
&lt;p>스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 역할 수행한다.&lt;/p>
&lt;p>MySQL 서버에서 MySQL엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">test_table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fd2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">INNODB&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위처럼 테이블이 사용할 스토리지 엔진을 지정하면 해당 테이블의 모든 읽기 작업과 변경 작업은 정의된 스토리지 엔진이 처리한다.&lt;/p>
&lt;p>각 스토리지 엔진은 성능 향상을 위해 &lt;code>키 캐시&lt;/code>(MyISAM), &lt;code>버퍼풀&lt;/code>(InnoDB) 같은 기능을 내장하고 있다.&lt;/p>
&lt;h2 id="핸들러-api">핸들러 API&lt;/h2>
&lt;p>MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러 요청이라고 하며, 사용되는 API를 핸들러 API라고 한다.&lt;/p>
&lt;p>InnoDB 스토리지 엔진 또한 이 핸들러 API를 이용해 MySQL 엔진과 데이터를 주고 받는다.&lt;/p>
&lt;p>핸들러 API를 통해 발생한 작업은 아래 쿼리로 확인 가능하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Handler%&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="mysql-스레딩-구조">MySQL 스레딩 구조&lt;/h2>
&lt;p>MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 동작한다.&lt;/p>
&lt;p>MySQL 서버에서 실행 중인 스레드 목록은 &lt;code>performance_schema&lt;/code> 데이터베이스에 &lt;code>threads&lt;/code> 테이블을 통해 확인할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">thread_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">type&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">processlist_user&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">processlist_host&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">threads&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">type&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">thread_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>백그라운드 스레드의 개수는 MySQL 서버의 설정 내용에 따라 가변적일 수 있다. 동일한 스레드가 2개 이상씩 보이는 것은 MySQL 서버의 설정 내용에 의해 여러 스레드가 동일 작업을 병렬로 처리하는 경우이다.&lt;/p>
&lt;h3 id="포그라운드-스레드클라이언트-스레드">포그라운드 스레드(클라이언트 스레드)&lt;/h3>
&lt;p>포그라운드 스레드는 클라이언트 연결 요청을 처리하고 데이터베이스 작업을 수행한다. 이러한 스레드는 쿼리 실행 중에 CPU 및 I/O 리소스를 사용하므로, 성능에 중요한 역할을 한다.&lt;/p>
&lt;p>포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다.&lt;/p>
&lt;p>클라이언트 사용자가 작업을 마치고 커넥션을 종료하면, 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 돌아간다.&lt;/p>
&lt;p>이때 이미 스레드 캐시에 일정 개수 이상의 대기중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 한다.&lt;/p>
&lt;p>스레드 캐시에 유지할 수 있는 최대 스레드 개수는 &lt;code>thread_cache_size&lt;/code> 시스템 변수로 설정한다.&lt;/p>
&lt;p>포그라운드 스레드는 데이터를 MySQL 데이터 버퍼나 캐시로 부터 가져오며, 버퍼나 캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.&lt;/p>
&lt;ul>
&lt;li>MyISAM: 디스크 쓰기 작업까지 포그라운드 스레드가 처리&lt;/li>
&lt;li>InnoDB: 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리&lt;/li>
&lt;/ul>
&lt;h3 id="백그라운드-스레드">백그라운드 스레드&lt;/h3>
&lt;p>MyISAM의 경우 해당 사항이 별로 없지만, InnoDB는 다음과 같이 여러가지 작업이 백그라운드로 처리된다.&lt;/p>
&lt;ul>
&lt;li>인서트 버퍼(Insert Buffer)를 병합하는 스레드&lt;/li>
&lt;li>로그를 디스크로 기록하는 스레드&lt;/li>
&lt;li>InnoDB 버퍼풀의 데이터를 디스크에 기록하는 스레드&lt;/li>
&lt;li>데이터 버퍼로 읽어 오는 스레드&lt;/li>
&lt;li>잠금이나 데드락을 모니터링 하는 스레드&lt;/li>
&lt;/ul>
&lt;p>모두 중요한 역할을 수행하지만 로그 스레드와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리하는 쓰기 스레드(Write thread)가 특히 중요하다.&lt;/p>
&lt;p>MySQL 5.5 버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 2개 이상 지정할 수 있게 됐으며, &lt;code>innodb_write_io_thread&lt;/code>, &lt;code>innodb_read_io_threads&lt;/code> 시스템 변수로 스레드의 개수를 설정한다.&lt;/p>
&lt;blockquote>
&lt;p>InnoDB에서도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드는 많이 설정할 필요는 없지만, 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 일반적인 내장 디스크를 사용할때는 2~4 정도, DAS, SAN과 같은 스토리지를 사용할 때는 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다.&lt;/p>
&lt;/blockquote>
&lt;p>사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다. 일반적인 상용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 있다.&lt;/p>
&lt;ul>
&lt;li>InnoDB: &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다.&lt;/li>
&lt;li>MyISAM: 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계되어, 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.&lt;/li>
&lt;/ul>
&lt;h2 id="메모리-할당-및-사용-구조">메모리 할당 및 사용 구조&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_1/mysql_4_3.png"
width="640"
height="423"
srcset="https://codemario318.github.io/post/real_mysql_4_1/mysql_4_3_huc090c2efafb1abf5a9a425a77bd2dd06_96981_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_1/mysql_4_3_huc090c2efafb1abf5a9a425a77bd2dd06_96981_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL 메모리 할당 구조"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="363px"
>&lt;/p>
&lt;p>글로벌 메모리 영역과 로컬 메모리 영역으로 구분되며, 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분된다.&lt;/p>
&lt;h3 id="글로벌-메모리-영역">글로벌 메모리 영역&lt;/h3>
&lt;p>일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다. 필요에 따라 2개 이상의 메모리 공간을 할당받을 수도 있지만 클라이언트의 스레드 수와 무관하며, 생성된 글로벌 영역이 N개라 하더라도 모든 스레드에 의해 공유된다.&lt;/p>
&lt;ul>
&lt;li>테이블 캐시&lt;/li>
&lt;li>InnoDB 버퍼풀&lt;/li>
&lt;li>InnoDB 어댑티드 해시 인덱스&lt;/li>
&lt;li>InnoDB 리두 로그 버퍼&lt;/li>
&lt;/ul>
&lt;p>등이 대표적인 글로벌 메모리 영역이다.&lt;/p>
&lt;h3 id="로컬-메모리-영역">로컬 메모리 영역&lt;/h3>
&lt;p>세션 메모리 영역이라고도 표현하며, MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다.&lt;/p>
&lt;ul>
&lt;li>정렬 버퍼&lt;/li>
&lt;li>조인 버퍼&lt;/li>
&lt;li>바이너리 로그 캐시&lt;/li>
&lt;li>네트워크 버퍼&lt;/li>
&lt;/ul>
&lt;p>MySQL 서버에 클라이언트가 접속하면, 클라이언트 커넥션(세션)으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당하게 되는데, 클라이언트 스레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리 영역이라고도 한다.&lt;/p>
&lt;p>로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다.&lt;/p>
&lt;p>일반적으로 글로벌 메모리 영역의 크기는 주의해서 설정하지만 소트 버퍼와 같은 오컬 메모리 영역은 크게 신경 쓰지 않고 설정하는데, 최악의 경우 MySQL 서버가 메모리 부족으로 멈춰 버릴수도 있으므로 적절한 메모리 공간을 설정하는 것이 중요하다.&lt;/p>
&lt;ul>
&lt;li>커넥션이 열러있는 동안 계속 할당된 상태로 남아있는 경우: 커넥션 버퍼, 결과 버퍼&lt;/li>
&lt;li>쿼리를 실행하는 순간에만 할당: 소트 버퍼, 조인 버퍼&lt;/li>
&lt;/ul>
&lt;h2 id="플러그인-스토리지-엔진-모델">플러그인 스토리지 엔진 모델&lt;/h2>
&lt;p>MySQL의 독특한 구조 중 대표적인 중 하나가 플러그인 모델이다.&lt;/p>
&lt;ul>
&lt;li>스토리지 엔진&lt;/li>
&lt;li>검색 엔진을 위한 검색어 파서&lt;/li>
&lt;li>사용자의 인증을 위한 Native Authentication, Caching SHA-2 Authentication 등&lt;/li>
&lt;/ul>
&lt;p>MySQL은 이미 기본적으로 많은 스토리지 엔진을 가지고 있지만, 필요에 의해 직접 스토리지 엔진을 만드는 것도 가능하다.&lt;/p>
&lt;p>MySQL에서 쿼리가 실행되는 과정을 보면 대부분 작업이 MySQL엔진에서 처리되고, 마지막 &lt;strong>데이터 읽기, 쓰기&lt;/strong> 작업만 스토리지 엔진에 의해 처리한다.&lt;/p>
&lt;p>&lt;code>GROUP BY&lt;/code>, &lt;code>ORDER BY&lt;/code> 등 복잡한 처리는 스토리지 엔진 영역이 아니라 MySQL 엔진의 처리 영역인 &lt;strong>쿼리 실행기&lt;/strong>에서 처리된다.&lt;/p>
&lt;p>스토리지 엔진에 따라 데이터 읽기/쓰기 작업 처리 방식이 크게 달라질 수 있다.&lt;/p>
&lt;p>하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 MySQL 엔진 영역에서 처리되는지 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* 스토리지 엔진 조회 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINES&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>서버에 포함되지 않은 스토리지 엔진을 사용하려면 MySQL 서버를 다시 빌드해야 한다. 준비만 되어있다면 플러그인 형태로 빌드된 스토리지 엔진 라이브러리를 다운로드해서 끼워넣기만 하면 사용할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* 플러그인 조회 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PLUGINS&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="컴포넌트">컴포넌트&lt;/h2>
&lt;p>플러그인 아키텍처는 다음과 같은 단점이 있다.&lt;/p>
&lt;ul>
&lt;li>오직 MySQL 서버와 인테페이스할 수 있고, 플러그인끼리는 통신할 수 없음&lt;/li>
&lt;li>MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안됨)&lt;/li>
&lt;li>플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어려움&lt;/li>
&lt;/ul>
&lt;p>이러한 문제를 개선하기 위해 MySQL 8.0 부터는 기존의 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원된다.&lt;/p>
&lt;p>예를 들면, MySQL 5.7 버전까지는 비밀번호 검증 기능이 플러그인 형태로 제공됐지만 MySQL8.0의 비밀번호 검증 기능은 컴포넌트로 개선됐다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* validate_password 설치 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">INSTALL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">COMPONENT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;file://component_validate_password&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/* 설치된 컴포넌트 확인 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">component&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="쿼리-실행-구조">쿼리 실행 구조&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_1/mysql_4_6.png"
width="411"
height="302"
srcset="https://codemario318.github.io/post/real_mysql_4_1/mysql_4_6_hue3f22860c2cd0cfc88afa48f7566f2b3_32277_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_1/mysql_4_6_hue3f22860c2cd0cfc88afa48f7566f2b3_32277_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="쿼리 실행 구조"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="326px"
>&lt;/p>
&lt;h3 id="쿼리-파서">쿼리 파서&lt;/h3>
&lt;p>쿼리 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태의 구조로 만들어 내는 작업을 의미한다.&lt;/p>
&lt;ul>
&lt;li>쿼리 문장의 기본 문법 오류는 이 과정에서 발견되고 사용자에게 오류 메시지를 전달하게 된다.&lt;/li>
&lt;/ul>
&lt;h3 id="전처리기">전처리기&lt;/h3>
&lt;p>파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.&lt;/p>
&lt;p>각 토큰을 테이블 이름이나 컬럼 이름, 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인하는 과정을 수행한다.&lt;/p>
&lt;ul>
&lt;li>실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰(컬럼, 내장 함수)은 이 단계에서 걸러진다.&lt;/li>
&lt;/ul>
&lt;h3 id="옵티마이저">옵티마이저&lt;/h3>
&lt;p>사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할을 담당한다.&lt;/p>
&lt;p>DBMS의 두뇌에 비유되며, 옵티마이저가 더 나은 선택을 하도록 유도하는 것이 매우 중요하다.&lt;/p>
&lt;h3 id="실행-엔진">실행 엔진&lt;/h3>
&lt;p>옵티마이저가 두뇌라면 실행 엔진과 핸들러는 손과 발에 비유할 수 있다.&lt;/p>
&lt;p>옵티마이저가 &lt;code>GROUP BY&lt;/code>를 처리하기 위해 임시 테이블을 사용하기로 결정했다면 아래 과정을 거칠 수 있다.&lt;/p>
&lt;ol>
&lt;li>실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청&lt;/li>
&lt;li>실행 엔진은 &lt;code>WHERE&lt;/code> 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청&lt;/li>
&lt;li>읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 핸들러에게 요청&lt;/li>
&lt;li>데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 요청&lt;/li>
&lt;li>결과를 사용자나 다른 모듈로 넘김&lt;/li>
&lt;/ol>
&lt;p>즉, 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.&lt;/p>
&lt;h3 id="핸들러스토리지-엔진">핸들러(스토리지 엔진)&lt;/h3>
&lt;p>MySQL 서버의 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당한다.&lt;/p>
&lt;p>핸들러는 결국 스토리지 엔진을 의미하며, MyISAM 테이블을 조작하는 경우 핸들러가 MyISAM 스토리지 엔진이 되고, InnoDB 테이블을 조작하는 경우 InnoDB 스토리지 엔진이 된다.&lt;/p>
&lt;h2 id="복제">복제&lt;/h2>
&lt;p>MySQL 서버에서 복제(Replication)는 매우 중요한 역할을 담당하며, 지금까지 MySQL 서버에서 복제는 많은 발전을 거듭해왔다.(16장)&lt;/p>
&lt;h2 id="쿼리-캐시">쿼리 캐시&lt;/h2>
&lt;p>쿼리 캐시는 빠른 응답을 필요로 하는 웹 기반의 응용 프로그램에서 매우 중요한 역할을 담당했다. 쿼리 캐시는 SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환하기 때문에 매우 빠른 성능을 보였다.&lt;/p>
&lt;p>하지만 쿼리 캐시는 테이블의 데이터가 변경되면 캐시에 저장된 결과 중에서 변경된 테이블과 관련된 테이블과 관련된 것들은 모두 삭제(Invalidate)해야 하므로, 심각한 동시 처리 성능 저하를 유발한다. 또한 MySQL 서버가 발전하면서 성능이 개선되는 과정에서 쿼리 캐시는 계속된 동시 처리 성능 저하와 많은 버그의 원인이 되기도 했다.&lt;/p>
&lt;blockquote>
&lt;p>다수의 클라이언트가 동시에 같은 쿼리를 실행하는 경우 쿼리 캐시 락(query cache lock)이 발생 가능하다. 이는 쿼리 캐시에 새로운 결과를 저장하거나 기존 결과를 반환하기 위해 필요한 락(lock)으로, 동시 처리가 많은 시스템에서는 쿼리 캐시를 사용하지 않는 것이 더 나은 성능을 보일 수 있다.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>MySQL 5.6 이하 버전에서는 쿼리 캐시가 InnoDB 또는 NDB Cluster 스토리지 엔진을 사용하는 경우에만 동작하는데 MyISAM 스토리지 엔진을 사용하는 경우에도 쿼리 캐시를 켜면 쿼리 결과가 무한정 캐시될 수 있는 버그가 있었다. 이러한 버그는 시스템의 부하를 높일 뿐만 아니라, 캐시 메모리의 공간을 차지해 다른 쿼리의 실행에 영향을 미칠 수 있다.&lt;/p>
&lt;/blockquote>
&lt;p>이러한 이유로 MySQL 8.0으로 올라오면서 &lt;em>완전히 제거되고, 관련 시스템 변수도 모두 제거&lt;/em>되었다.&lt;/p>
&lt;h2 id="스레드-풀">스레드 풀&lt;/h2>
&lt;p>MySQL 서버 엔터프라이즈 에디션은 스레드풀 기능을 제공하지만 커뮤니티 에디션은 지원하지 않는다. 따라서 Percona Server 플러그인에서 제공하는 스레드풀 기능을 살펴본다.&lt;/p>
&lt;p>스레드풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다 하더라도 MySQL 서버의 CPU가 &lt;strong>제한된 개수의 스레드 처리에만 집중할 수 있게 하여 서버의 자원 소모를 줄이는것이 목적&lt;/strong>이다.&lt;/p>
&lt;p>하지만 스레드풀이 실제 서비스에서 눈에띄는 성능 향상을 보여준 경우는 드물다.&lt;/p>
&lt;p>실행 중인 스레드들을 CPU가 최대한 잘 처리해낼 수 있는 수준으로 줄여서 빨리 처리하게 하는 기능으므로 스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하는 경우 쿼리 처리가 더 느려지는 사례도 발생할 수 있다.&lt;/p>
&lt;p>제한된 수의 스레드만으로 CPU가 처리하도록 적절히 유도하면 CPU의 프로세서 친화도(Processor affinity)도 높히고 불필요한 컨텍스트 스위치를 줄여 오버헤드를 낮출 수 있다.&lt;/p>
&lt;h3 id="스레드-그룹-개수">스레드 그룹 개수&lt;/h3>
&lt;p>Percona Server의 스레드 풀은 기본적으로 CPU 코어의 개수만큼 스레드 그룹을 생성하며 일반적으로 CPU 코어의 개수와 맞추는것이 CPU 프로세서 친화도를 높이는 데 좋다.&lt;/p>
&lt;p>MySQL 서버가 처리해야할 요청이 생기면 스레드풀로 처리를 이관하는데, 이미 스레드풀이 처리중인 작업이 있는 경우 시스템 변수에 설정된 개수만큼 추가로 더 받아들여서 처리한다. 너무 많으면 스케줄링해야 할 수레드가 많아져 비효율적으로 작동할 수 있다.&lt;/p>
&lt;h3 id="타이머-스레드">타이머 스레드&lt;/h3>
&lt;p>스레드 그룹의 모든 스레드가 일을 처리하고 있다면 스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드를 추가할지, 기존 작업 스레드가 처리를 완료할 때가지 기다릴지 여부를 판단해야 한다.&lt;/p>
&lt;p>주기적으로 스레드 그룹의 상태를 체크해서 &lt;code>thread_pool_stall_limit&lt;/code> 시스템 변수에 정의된 시간에 작업을 끝내지 못했다면 새로운 스레드를 생성해 스레드 그룹에 추가한다.&lt;/p>
&lt;p>모든 스레드 그룹의 스레드가 작업을 수행중이라면 시스템 변수에 설정된 개수를 넘어설 수 없어 대기해야 한다.&lt;/p>
&lt;p>응답 시간이 아주 민감한 서비스라면 시스템 변수를 적절히 낮춰 설정해야하며, 0에 가까운 값으로 설정하는 것은 좋지 않고 이런 경우는 스레드풀을 사용하지 않는 것이 좋을 수 있다.&lt;/p>
&lt;h3 id="우선순위-큐">우선순위 큐&lt;/h3>
&lt;p>선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능도 제공한다. 먼저 시작된 트랜잭션 내에 속한 SQL을 빨리 처리해주면 해당 트랜잭션이 가지고 있던 잠금이 빨리 해제되고 잠금 경합을 낮춰 전체적인 처리 성능을 향상시킬 수 있다.&lt;/p>
&lt;h1 id="트랜잭션-지원-메타데이터">트랜잭션 지원 메타데이터&lt;/h1>
&lt;p>데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보를 데이터 딕셔너리 또는 메타데이터라고 하는데, MySQL 서버는 5.7 버전까지 테이블의 구조를 FRM 파일에 저장하고 일부 스토어드 프로그램 또한 파일 기반으로 관리 되었다.&lt;/p>
&lt;p>이러한 파일 기반의 메타데이터는 생성 및 변경 작업이 트랜잭션을 지원하지 않기 때문에 테이블의 생성 또는 변경 도중에 MySQL 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남게되는 문제가 있었다.&lt;/p>
&lt;p>이에따라 8버전 부터는 테이블의 구조 정보나 스토어드 프로그램의 코드 관련 정보를 모두 InnoDB의 테이블에 저장하도록 개선되었다.&lt;/p></description></item></channel></rss>