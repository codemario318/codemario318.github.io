<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Git on Mario Blog</title><link>https://codemario318.github.io/tags/git/</link><description>Recent content in Git on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Sat, 03 Aug 2024 11:22:49 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/git/index.xml" rel="self" type="application/rss+xml"/><item><title>챌린지 과정 3주차 회고</title><link>https://codemario318.github.io/post/boostcamp-9th/review/challenge/3/</link><pubDate>Sat, 03 Aug 2024 11:22:49 +0900</pubDate><guid>https://codemario318.github.io/post/boostcamp-9th/review/challenge/3/</guid><description>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/3/cover.png" alt="Featured image of post 챌린지 과정 3주차 회고" />&lt;p>챌린지 3주차가 마무리되었습니다🥳&lt;/p>
&lt;p>이번주 역시 저번주와 마찬가지로, 저번주보다 훨씬 더 빠르게 지나간 것 같네요.&lt;/p>
&lt;p>미션도 어려웠지만 이번주는 날씨가 역대급으로 더웠는데, 에어컨 고장 이슈가 발생하는 바람에 육체적, 정신적으로 정말 힘들었던 한 주 였습니다🥵&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/3/img.png"
width="772"
height="512"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/3/img_hu49700197eb00dd7c6958db7079e6d44f_504814_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/3/img_hu49700197eb00dd7c6958db7079e6d44f_504814_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="150"
data-flex-basis="361px"
>&lt;/p>
&lt;h2 id="짝-활동">짝 활동&lt;/h2>
&lt;p>이번주는 저번주에 예고되었던대로 &lt;strong>짝 활동&lt;/strong>으로 한 주가 진행되었습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/3/img_1.png"
width="506"
height="245"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/3/img_1_hue18cc63406e6b0e55de22018cf95147c_73580_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/3/img_1_hue18cc63406e6b0e55de22018cf95147c_73580_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="495px"
>&lt;/p>
&lt;p>각자 개발하고 짝과 함께 서로의 결과물을 개선해보는 &lt;strong>짝 개선&lt;/strong>이 11~12일 이틀에 걸쳐 진행되었고, 같이 개발하고 각자 개선해보는 &lt;strong>짝 개발&lt;/strong>이 13~14일 이틀에 걸쳐 진행되었습니다.&lt;/p>
&lt;p>미션을 함께하며 문제 해결을 위해 많은 소통을 하였습니다.&lt;/p>
&lt;p>의사 결정 과정에서 공통으로 중요하다고 생각하는 부분, 공통으로 중요하지 않다고 생각하는 부분 등을 토론하며 훨씬 더 빠르게 최선의 선택을 할 수 있었던 것 같아 좋았습니다.&lt;/p>
&lt;hr>
&lt;p>이번주도 저번주에 이어서 &lt;strong>애자일스러운 개발&lt;/strong>과 &lt;strong>TDD&lt;/strong>를 시도했습니다. 이번에는 짝과 함께 했다는 것이 조금 다를 것 같네요&lt;/p>
&lt;p>&lt;strong>애자일스러운 개발&lt;/strong>은 개인 미션일 때는 어느정도 달성할 수 있었으나, 짝 개발에서는 짝이 지금까지 해오던 스타일과 많이 달라 완전히 적용하지는 못했고,&lt;/p>
&lt;p>&lt;strong>TDD&lt;/strong>역시 미션의 접근 방법에 맞춘 테스트를 작성하는 것에 어려움을 느껴 일부만 적용하여 조금 아쉬웠습니다.&lt;/p>
&lt;h2 id="미션">미션&lt;/h2>
&lt;p>이번주 미션도 역시 어려운 주제들을 다뤘습니다.&lt;/p>
&lt;p>저번주는 패러다임 등과 같은 내용들로 생각의 전환이 필요하여 어려웠다면, 이번주는 저번주의 개념에 복잡한 요구사항이 추가된 모습이었습니다.&lt;/p>
&lt;p>아마도 2일씩 이루어질 짝 활동을 반영하여 더 어려운 문제로 선정했던것이 아닐까 예상해봅니다.&lt;/p>
&lt;h3 id="11일차-이벤트-주도-개발과-스레드-풀">11일차: 이벤트 주도 개발과 스레드 풀&lt;/h3>
&lt;p>11일차 미션은 짝 개선을 하기 위한 개인 결과를 만드는 과정이었습니다.&lt;/p>
&lt;p>미션의 요구사항을 나름대로 해석해보면, &lt;strong>이벤트 주도 설계&lt;/strong>를 통해 이벤트 발생시 작업을 &lt;strong>비동기&lt;/strong>로 실행하고, 해당 작업을 &lt;strong>스레드&lt;/strong>를 이용해 동시에 처리할 수 있도록 해야하는 문제였습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>이벤트 주도 설계&lt;/strong>&lt;/p>
&lt;p>저번주 미션을 통해 &lt;strong>이벤트 주도 설계&lt;/strong>에 어느정도 감을 잡았다고 생각했었는데, 요구사항이 훨씬 복잡해지니 정신을 못차리게 되더군요 &lt;del>안 좋은 컨디션 때문인지 더 그랬던 것 같아요&lt;/del> 🥲&lt;/p>
&lt;p>하지만 과제를 마무리할 때 쯤에는 이벤트와 더욱 친해졌다는 느낌을 받을 수 있었습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>테스트 코드&lt;/strong>&lt;/p>
&lt;p>제 설계는 작업들이 이벤트를 연쇄적으로 발생시켜 실행되는 구조였는데, 연쇄적으로 실행되는 동안 작업의 상태들을 추적하는 테스트를 적용해야한다고 판단하였습니다.&lt;/p>
&lt;p>하지만 연쇄적으로 처리되는 일부 작업이 &lt;code>Private&lt;/code> 메소드로 실행되는터라 모든 처리 흐름에서의 상태 변화 추적할 수 있는 테스트 코드를 작성할 방법이 떠오르지 않더군요&amp;hellip;&lt;/p>
&lt;p>이에 따라, 이벤트로 처리되는 흐름에서의 &lt;strong>모든 상태 변화&lt;/strong>를 검증하지는 못했습니다.&lt;/p>
&lt;p>(개선 방법은 아래에 나옵니다! 끝까지 봐주세요😁)&lt;/p>
&lt;hr>
&lt;p>&lt;strong>스레드&lt;/strong>&lt;/p>
&lt;p>이벤트 흐름으로 실행 될 마지막 작업을 JS의 &lt;strong>worker-thread&lt;/strong>(이하 WT)를 통해 처리할 수 있다고 판단되었지만, WT를 무한정 생성할수는 없다고 판단했기 때문에 &lt;strong>WT Pool&lt;/strong>을 구현할 필요성을 느꼈습니다.&lt;/p>
&lt;p>&lt;del>시간이 부족했던 이유도 있지만&lt;/del> 워커를 적절히 만들고 배분할 좋은 방법이 떠오르지 않아, 결과적으로 스레드를 이용한 처리는 &lt;strong>비동기 처리&lt;/strong>로 대체하여 구현했습니다.&lt;/p>
&lt;h3 id="12일차-짝-개선---같이-개선하기">12일차: 짝 개선 - 같이 개선하기&lt;/h3>
&lt;p>&lt;strong>짝 개선&lt;/strong>은 11일차에 만든 자신의 결과물 중 개선할 부분을 찾아 선정하고, 짝과 함께 선정한 부분을 개선하는 과정이었습니다.&lt;/p>
&lt;p>기존 결과에서 새로운 것을 추가하지 않고 개선하는 방향으로 진행하라는 지침이 있어, 저는 &lt;strong>테스트를 위한 코드 구조 일부 개선과 테스트 추가&lt;/strong>, 짝은 &lt;strong>관심사 분리를 위한 구조 개선&lt;/strong>을 개선 목표로 선정했습니다.&lt;/p>
&lt;p>저희 페어는 아래와 같은 방식으로 개선 과정을 진행하였습니다.&lt;/p>
&lt;ol>
&lt;li>짝에게 왜 이러한 부분을 개선하려고 하는 지 설명&lt;/li>
&lt;li>그 이유에 맞춰 각자의 관점에서 문제를 해석&lt;/li>
&lt;li>의견 교환을 통해 문제 재구조화&lt;/li>
&lt;li>세부 구현을 보며 의견 교환 및 수정&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>&lt;strong>나의 개선: 테스트를 위한 구조 개선&lt;/strong>&lt;/p>
&lt;p>11일차 미션에서 어려웠던 점으로 언급했던 부분인 &lt;strong>이벤트가 연쇄적으로 발생하는 구조로 인한 상태 변화 추적 테스트&lt;/strong>의 개선을 위해 호출 구조를 약간 변경하였습니다.&lt;/p>
&lt;p>그리고 &lt;code>Jest&lt;/code>의 &lt;code>SpyOn&lt;/code>을 활용하여 이벤트 발생시 특정 함수가 호출되는지 확인하고, 호출되는 함수가 상태를 적절히 변경하는지 테스트 하는 방향으로 개선되었습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>짝의 개선: 관심사 분리를 위한 구조 개선&lt;/strong>&lt;/p>
&lt;p>피어 세션에서 다른 분들에 작업 결과를 보며 특정 클래스가 &lt;strong>너무 많은 책임&lt;/strong>을 가지고있다고 판단하셨고, 이를 함께 개선하였습니다.&lt;/p>
&lt;p>클래스의 특정 관심사를 묶어 다른 클래스로 분리하고, 기존 클래스의 메서드를 호출해야하는 부분을 이벤트로 처리하게 변경하였습니다.&lt;/p>
&lt;p>이 과정에서 연쇄적으로 처리해야하는 부분이 이전 클래스와 &lt;strong>강한 결합&lt;/strong>이 남아있어 같이 고민하게 되었는데, 제가 &lt;strong>콜백 함수를 넘기는 메서드&lt;/strong>를 제안하였고 이를 반영하였습니다.&lt;/p>
&lt;p>저의 의견으로 고민되었던 부분을 개선할 수 있어 뿌듯했네요😁&lt;/p>
&lt;h3 id="13일차-짝-구현---페어-프로그래밍">13일차: 짝 구현 - 페어 프로그래밍&lt;/h3>
&lt;p>13일차에는 &lt;strong>분산 버전 관리 시스템&lt;/strong>인 &lt;strong>Git&lt;/strong>을 완벽하게 이해해야 해결할 수 있는 미션이 주어졌습니다.&lt;/p>
&lt;p>또한 &lt;strong>페어 프로그래밍&lt;/strong>을 통해 주어진 미션을 해결해야하는 조건이 있었습니다.&lt;/p>
&lt;p>새롭게 배정된 짝과 어떻게 미션을 수행할지 협의했고, 결과적으로 아래와 같은 흐름으로 미션을 수행했습니다.&lt;/p>
&lt;ol>
&lt;li>각자 미션 해결을 위해 필요한 내용들 학습&lt;/li>
&lt;li>함께 요구사항 분석&lt;/li>
&lt;li>함께 설계&lt;/li>
&lt;li>함께 구현&lt;/li>
&lt;/ol>
&lt;p>바로 만나서 학습부터 같이 수행하는 것이 아니라 각자 관련 내용에 대해 충분히 학습한 후 미션 수행을 시작하였습니다.&lt;/p>
&lt;hr>
&lt;p>지난주에 했던 방법과 유사하게 &lt;code>VSCode&lt;/code>의 &lt;code>Live share&lt;/code>를 통해 페어 프로그래밍을 진행하였고, 개발 전 충분한 분석과 설계를 위해 &lt;code>mermaid&lt;/code> 를 적극적으로 활용하였습니다.&lt;/p>
&lt;p>이전까지는 주로 &lt;strong>객체 지향 프로그래밍&lt;/strong>을 주로 활용했었는데, 짝이 선호하는 &lt;strong>함수형 프로그래밍&lt;/strong>을 시도한 것도 새로운 시도였네요😊&lt;/p>
&lt;p>이에 따라 요구하는 기능들을 모듈로 묶어 설계하고 구현하였습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>TDD와 애자일스러운 개발&lt;/strong>&lt;/p>
&lt;p>짝에게 &lt;strong>애자일스러운 개발&lt;/strong>과 &lt;strong>TDD&lt;/strong>를 제안하여 시도했습니다.&lt;/p>
&lt;p>아쉽게도 저도 이러한 방식에 완전히 적응된 상태는 아니었고, 짝도 불편함을 느끼고 있다는 것이 작업 효율이 떨어지는 것으로 느낄 수 있었습니다.&lt;/p>
&lt;p>이러한 이유로 짝이 편해하는 방식으로 자연스럽게 전환되었던 것 같습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>파일 시스템 테스트&lt;/strong>&lt;/p>
&lt;p>파일과 디렉터리를 처리해야하는 요구사항이 있었습니다.&lt;/p>
&lt;p>테스트 과정에서 실제 파일과 디렉터리를 생성하여 작업하는 것이 적절치 않다고 판단하여 이를 대체할 수 있는 방법을 찾게 되었고,&lt;code>mock-fs&lt;/code>를 찾아 적용하였습니다.&lt;/p>
&lt;p>하지만&amp;hellip; &lt;code>Node v20&lt;/code> 환경에서 &lt;code>fs&lt;/code>의 모든 &lt;strong>파일 쓰기&lt;/strong> 가 모킹한 가상 디렉터리에 생성되는 것이 아닌 실제 디렉터리에 생성하는 문제가 발생하였습니다.&lt;/p>
&lt;p>파일을 처리해야하는 부분이 미션에서 굉장히 중요한 부분이었기 때문에 어떻게든 해결해보려했지만 시간이 많지 않았기 때문에, 이때 부터 테스트 코드를 작성하지 않고 개발을 진행하게 되었네요🥲&lt;/p>
&lt;hr>
&lt;p>전주와 다르게 짝에게 테스트에 대한 긍정적인 인식을 심어주지 못한 것 같아 많이 아쉬웠지만 다음에 이러한 상황이 발생한다면 빠르게 결정을 내려 &lt;strong>TDD&lt;/strong>를 끝까지 이어나가야겠다고 다짐 하게되었습니다👊&lt;/p>
&lt;h3 id="14일차-각자-개선하기">14일차: 각자 개선하기&lt;/h3>
&lt;p>13일차에 짝과 만든 결과물을 각자의 방식으로 개선하는 과정이었습니다.&lt;/p>
&lt;p>이러한 단계를 만든 이유를 예상해보자면&amp;hellip; 같이 고민하여 만든 결과물이지만, 각자의 방법으로 개선된 결과를 보며 어떠한 생각의 차이를 가지고있는지 확인해볼라는 의도 같았습니다.&lt;/p>
&lt;p>12일차 &lt;strong>같이 개선하기&lt;/strong>와 마찬가지로 새로운 것을 추가하는 것 보다는 기존 구현에서 개선해보라는 지침이 있어 기존 결과에서 문제점이라고 생각했던 부분을 개선하였습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>나의 개선: 코드 구조 개선&lt;/strong>&lt;/p>
&lt;p>13일차의 미션을 수행할 때 요구하는 기능을 각각 나누어 개발하는 방식으로 진행되었습니다.&lt;/p>
&lt;p>구현 과정에서 &lt;strong>TDD&lt;/strong>로 시작했지만 결국 테스트 코드를 작성하지 않게 되었었는데, 이유 중 하나가 모든 기능에서 공통적으로 사용되었던 &lt;strong>파일 시스템과의 결합을 적절히 분리하지 못했기 때문&lt;/strong>이라는 생각을 하게되었습니다.&lt;/p>
&lt;p>&lt;strong>파일시스템&lt;/strong>을 통해 파일과 디렉터리를 다루는 부분을 완벽히 분리한다면, 다른 주요 로직들은 파일 시스템을 이용해야하는 데이터를 &lt;strong>엔티티&lt;/strong>로 취급하여 처리할 수 있게 됩니다.&lt;/p>
&lt;p>그렇다면 &lt;strong>파일시스템 관련 테스트만 배제&lt;/strong>할 수 있기 때문에 다른 처리에서는 &lt;strong>TDD&lt;/strong>를 지속할 수 있었지 않았을까? 하고 말이죠&lt;/p>
&lt;p>그래서 &lt;code>FileSystem&lt;/code>이라는 클래스를 별도로 구현하여 파일에 관한 모든 책임을 담당하게 하였습니다.&lt;/p>
&lt;p>또한 파일로 핸들링 해야하는 &lt;strong>데이터를 정의&lt;/strong>하여 엔티티처럼 활용할 수 있도록 하였습니다.&lt;/p>
&lt;p>추가적으로 주요 처리 흐름을 클래스로 분리해 &lt;code>FileSystem&lt;/code>을 주입하여 데이터의 처리 흐름에 집중할 수 있도록 구조를 변경하였습니다.&lt;/p>
&lt;p>이러한 변경을 통해 가독성을 높히는 것은 물론, 기존 기능을 구현한 코드의 크기를 획기적으로 줄일 수 있었습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>mock-fs&lt;/code>&lt;/strong>&lt;/p>
&lt;p>쓰기 작업에서의 이슈로 인해 제대로 활용하지 못했던 &lt;code>mock-fs&lt;/code>가 신경쓰여 잠이 안오더라구요😂&lt;/p>
&lt;p>이에 다양한 방법들을 시도했지만 결국 해결할 수 없었습니다.&lt;/p>
&lt;p>그래서 다른 언어에서도 파일 시스템을 활용한 기능들을 테스트 해야할텐데 어떤 방법들을 활용하고있을까 찾아보게 되었습니다.&lt;/p>
&lt;p>해결 방법은 단순했더라구요..🥲&lt;/p>
&lt;p>그냥 파일 처리를 테스트할 디렉터리를 따로 만들고, 그 디렉터리에서만 확인하는 것 이었습니다.&lt;/p>
&lt;p>테스트 디렉터리를 구성한 후 &lt;code>.gitignore&lt;/code>로 해당 디렉터리를 안 올라가게 만들면 되었던건데&amp;hellip; &lt;code>mock-fs&lt;/code>에 너무 집착한 탓에 충분히 생각해볼 수 있는 단순한 방법도 고려하지 못했던 것 같습니다.&lt;/p>
&lt;p>이 일을 계기로 조금 더 여유를 가지고 문제를 바라봐야겠다는 다짐을 해봅니다.🔥&lt;/p>
&lt;h2 id="마무리">마무리&lt;/h2>
&lt;p>이번주는 개인적으로 컨디션이 많이 안좋았어서 그만큼 결과물도 좋지 않았던 것 같습니다.&lt;/p>
&lt;p>첫주의 각오처럼 결과물을 통해서 인사이트를 드리고 싶었는데 조금 아쉬웠어요. &lt;del>그래도 다음주에는 에어컨이 수리됩니다.&lt;/del>&lt;/p>
&lt;p>하지만 그랬기 때문에 개선하기에 더욱 많은 변화를 보여드릴 수 있었을지도 모르겠습니다.&lt;/p>
&lt;p>한 주간 모두 고생 많으셨습니다. 부캠 챌린지도 1주밖에 남지 않았네요! 마지막까지 화이팅해봐요🔥🔥🔥&lt;/p></description></item><item><title>Git 객체로 살펴보는 add와 commit</title><link>https://codemario318.github.io/post/git/add-commit/</link><pubDate>Wed, 31 Jul 2024 13:17:42 +0900</pubDate><guid>https://codemario318.github.io/post/git/add-commit/</guid><description>&lt;img src="https://codemario318.github.io/post/git/add-commit/cover.png" alt="Featured image of post Git 객체로 살펴보는 add와 commit" />&lt;p>&lt;strong>Git&lt;/strong>은 분산형 버전 관리 시스템(Distributed Version Control System, DVCS)으로, 소스 코드와 파일의 변경 이력을 관리하는 도구입니다.&lt;/p>
&lt;p>&lt;strong>Git&lt;/strong>을 활용하려면 원하는 디렉토리 경로에 &lt;code>git init&lt;/code> 명령을 실행하게되는데, 이때 &lt;code>.git&lt;/code> 디렉토리가 만들어집니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/git/add-commit/img_1.png"
width="471"
height="311"
srcset="https://codemario318.github.io/post/git/add-commit/img_1_hu2a5eb33a792f1a5359f11c4937882c21_37732_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/git/add-commit/img_1_hu2a5eb33a792f1a5359f11c4937882c21_37732_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt=".git 내부 구조"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="363px"
>&lt;/p>
&lt;p>이 때 만들어지는 &lt;code>.git&lt;/code> 디렉토리는 저장소(repository)의 &lt;strong>메타데이터&lt;/strong>와 &lt;strong>Git 객체&lt;/strong>들을 저장하는 장소이며, 그 중 &lt;strong>Git 객체&lt;/strong>는 저장소의 데이터를 관리하고 추적하는데 핵심입니다.&lt;/p>
&lt;p>&lt;strong>Git&lt;/strong>은 &lt;strong>Git 객체&lt;/strong>와 워킹 디렉토리의 파일들을 기준으로 변경을 감지하고, &lt;code>Git 객체&lt;/code>의 정보를 통해 코드의 버전들을 관리하고 추적하게됩니다.&lt;/p>
&lt;p>이를 조금 더 자세히 살펴보겠습니다.&lt;/p>
&lt;h2 id="git-객체">Git 객체&lt;/h2>
&lt;p>&lt;code>.git&lt;/code> 디렉토리 아래에 있는 &lt;code>/objects&lt;/code> 디렉토리에 파일로 저장되는 &lt;strong>Git 객체&lt;/strong>는 Git의 핵심으로, 모든 데이터의 내용과 실제 저장 위치를 의미하게 됩니다.&lt;/p>
&lt;p>실제 &lt;code>/objects&lt;/code>의 경로를 확인하면 아래와 같은 구조를 확인할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">/objects
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── 0d
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── df0ae059b771e502af67931f9f8a4a17632661
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── 24
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── 643cc37449b4bde54411a80b8ed61258225e34
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── 35
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── eb1ddfbbc029bcab630581847471d7f238ec53
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── 6c
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── 435e543633035641c810e97681b078d627a946
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── a6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── d422786b4daf0d8cbd7466a02e4a4fa9fd8570
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── b1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── 7d46df496e1a6aef89fc6d67937a2ba47b5d33
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── info
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">└── pack
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── pack-15a971ce7fbb8c9997e7e167347a23bbfe438d71.idx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> └── pack-15a971ce7fbb8c9997e7e167347a23bbfe438d71.pack
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>파일의 경로가 &lt;strong>2글자로 시작하는 디렉토리&lt;/strong> 아래에 &lt;strong>불특정한 38자 이름&lt;/strong>을 가진 파일이 저장되어있는데, 이 저장된 파일이 &lt;strong>Git 객체&lt;/strong>입니다.&lt;/p>
&lt;h3 id="git-객체의-이름-상태가">Git 객체의 이름 상태가&amp;hellip;?&lt;/h3>
&lt;p>저장되는 파일 이름을 보시면 어느정도 눈치 채셨을 것 같은데요.&lt;/p>
&lt;p>&lt;code>Git&lt;/code> 객체가 위치와 이름은 총 40자, 16진수 문자열로 파일의 전체 내용을 &lt;code>SHA-1&lt;/code> 함수로 해싱한 결과입니다.&lt;/p>
&lt;p>이로인해 파일 내용의 무결성을 보장함은 물론 파일을 거의 유일하게 식별할 수 있습니다.&lt;/p>
&lt;p>해시값을 사용하는 이유는 파일의 내용이 변경되면 아예 다른 결과가 반환되는 해시 함수의 특징을 활용해 &lt;strong>파일의 변경&lt;/strong>을 간편하게 확인하기 위함입니다.&lt;/p>
&lt;p>파일 내용이 &lt;code>e69de29bb2d1d6434b8b29ae775ad8c2e48c5391&lt;/code> 해시 값을 가진다면, &lt;code>.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391&lt;/code>에 저장됩니다.&lt;/p>
&lt;p>앞에 2자를 분리해 굳이 디렉토리로 만든 이유는 2가지 정도로 확인됩니다.&lt;/p>
&lt;ul>
&lt;li>성능 최적화
&lt;ul>
&lt;li>한 디렉토리 내에 너무 많은 파일을 저장하면 성능이 저하됨&lt;/li>
&lt;li>수천 개 또는 수십만 개 파일을 하나의 디렉토리에 저장하면 검색, 파일 생성 및 접근 속도가 느려질 수 있음&lt;/li>
&lt;li>객체들을 고르게 분산하여 저장할 수 있어 성능 저하를 방지할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>관리 용이
&lt;ul>
&lt;li>디렉토리 구조로 나눔으로써 객체 파일을 관리하고 탐색하는 것이 더 쉬워짐(2자로 디렉터리를 바로 찾을 수 있음)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="내용물은">내용물은?&lt;/h3>
&lt;p>문서 혹은 파일의 내용으로 만들어지는 해시값을 경로로 저장되는 Git 객체 파일에는 해시값을 만드는데 사용하기도 했던 파일의 전체 내용을 압축하여 저장합니다.&lt;/p>
&lt;h3 id="git-객체의-종류">Git 객체의 종류&lt;/h3>
&lt;p>&lt;strong>Git 객체&lt;/strong>는 3가지 유형이 존재합니다.&lt;/p>
&lt;ul>
&lt;li>파일의 저장 경로와 파일의 내용은 모두 위와 동일하게 만들어집니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>블롭(&lt;code>Blob&lt;/code>)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>파일의 내용 자체를 저장&lt;/li>
&lt;li>파일의 이름이나 메타데이터는 저장하지 않고 파일의 원본 내용만 저장함&lt;/li>
&lt;/ul>
&lt;p>블롭 유형의 파일은 데이터 원본의 내용만을 압축하여 저장합니다.&lt;/p>
&lt;p>압축하여 저장된 원본 데이터는 복구 등의 처리에서 활용됩니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>트리(&lt;code>Tree&lt;/code>)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>디렉터리의 구조를 저장&lt;/li>
&lt;li>디렉터리의 파일 및 하위 디렉터리와 그에 대한 블롭 객체 객체의 참조를 포함(트리는 블롭과 또 다른 트리로 구성됨)&lt;/li>
&lt;/ul>
&lt;p>트리 객체를 통해 디렉토리 구조를 관리할 수 있게 됩니다.&lt;/p>
&lt;p>트리 객체가 의미하는 디렉토리의 존재하는 모든 &lt;strong>파일&lt;/strong>, &lt;strong>디렉토리&lt;/strong>들의 경로(파일 주소)를 Git 객체의 값으로 압축하여 저장하게 됩니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>커밋(&lt;code>Commit&lt;/code>)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>커밋 정보를 저장&lt;/li>
&lt;li>커밋 메시지, 작성자, 날짜 및 커밋 시점의 트리 객체를 포함&lt;/li>
&lt;/ul>
&lt;p>직전 루트 트리 객체의 주소(파일 경로), 현재 루트 트리 객체의 주소(파일 경로)와 커밋 메시지 등 메타데이터를이 압축되어 저장됩니다.&lt;/p>
&lt;h2 id="git-add">&lt;code>git add&lt;/code>&lt;/h2>
&lt;p>&lt;code>git add&lt;/code> 명령어는 작업 디렉토리에서 변경된 파일들을 스테이징 영역에 추가하여 다음 커밋에 포함될 파일들을 준비하게됩니다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>작업 디렉토리&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>사용자가 작업 중인 실제 파일들이 존재하는 디렉토리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>인덱스(스테이징 영역)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>커밋을 준비하기 위해 변경된 파일들이 추가되는 영역&lt;/li>
&lt;li>인덱스는 &lt;code>.git/index&lt;/code> 파일에 저장됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>먼저 변경된 파일들을 어떻게 관리하는지 확인해보겠습니다.&lt;/p>
&lt;h3 id="파일의-추적-상태">파일의 추적 상태&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/git/add-commit/img.png"
width="800"
height="330"
srcset="https://codemario318.github.io/post/git/add-commit/img_hu0d2cd540fc510e4ec1c1a61158d3600f_25950_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/git/add-commit/img_hu0d2cd540fc510e4ec1c1a61158d3600f_25950_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="파일 상태 변화"
class="gallery-image"
data-flex-grow="242"
data-flex-basis="581px"
>&lt;/p>
&lt;p>Git은 작업 디렉토리의 파일을 4가지 상태로 추적, 관리합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>UnTracked&lt;/code>: 추적되지 않는 파일
&lt;ul>
&lt;li>Git에 등록되지않아 추적되지 않는 상태&lt;/li>
&lt;li>Git이 버전 관리하고 있지 않은 파일&lt;/li>
&lt;li>새로 생성된 파일이거나, 추적되지 않도록 명시적으로 설정된 파일(.gitignore)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Unmodified&lt;/code>: 수정되지 않은 파일
&lt;ul>
&lt;li>Git이 추적하고 있는 파일이지만, 마지막 커밋 이후 변경되지 않은 상태&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Modified&lt;/code>: 수정된 파일
&lt;ul>
&lt;li>Git이 추적하고 있는 파일이지만, 마지막 커밋 이후로 파일의 내용이 변경된 상태&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Staged&lt;/code>: 스테이징된 파일
&lt;ul>
&lt;li>&lt;code>git add&lt;/code> 명령을 통해 스테이징 영역에 추가된 상태&lt;/li>
&lt;li>다음 커밋에 포함될 준비가 되었다는 의미&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>&lt;code>Untracked&lt;/code> -&amp;gt; &lt;code>Staged&lt;/code>&lt;/strong>&lt;/p>
&lt;p>Git으로 관리되고 있는 프로젝트에 처음 생성된 파일은 &lt;code>UnTracked&lt;/code> 상태입니다. 즉 Git이 추적하고 있지 않은 상태임을 의미합니다.&lt;/p>
&lt;p>&lt;code>git add&lt;/code> 명령을 수행하면 해당 파일이 스태이징 영역에 추가되며 &lt;code>Staged&lt;/code> 상태로 변경됩니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>Unmodified&lt;/code> -&amp;gt; &lt;code>Modified&lt;/code>&lt;/strong>&lt;/p>
&lt;p>Git을 통해 추적하고 있지만, 마지막 변경 이후 수정되지 않았다면 &lt;code>Unmodifed&lt;/code> 상태입니다.&lt;/p>
&lt;p>&lt;code>Unmodifed&lt;/code> 상태의 파일에 변경이 발생하면(이전과 다른 부분이 발생하면) &lt;code>Modifed&lt;/code> 상태가 됩니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>Modified&lt;/code> -&amp;gt; &lt;code>Staged&lt;/code>&lt;/strong>&lt;/p>
&lt;p>&lt;code>Unmodified&lt;/code> 상태인 파일에 변경이 발생하여 &lt;code>Modifed&lt;/code> 상태가 되었을 때 &lt;code>git add&lt;/code> 명령로 스테이징 영역에 추가할 수 있습니다.&lt;/p>
&lt;h3 id="git에서-일어나는-일">&lt;code>.git&lt;/code>에서 일어나는 일&lt;/h3>
&lt;p>이제는 &lt;code>.git&lt;/code> 내부에 어떤 일들이 발생하는지 살펴보겠습니다.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>변경된 파일의 해시 계산&lt;/strong>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;code>git add&lt;/code> 명령어가 실행되면, Git은 현재 인덱스 파일(&lt;code>.git/index&lt;/code>)의 기록된 정보를 활용하여 작업 디렉토리에서 변경된 파일의 내용을 찾아 읽습니다.
&lt;ul>
&lt;li>&lt;code>Untracked&lt;/code>, &lt;code>Modified&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>변경된 파일의 내용을 기반으로 SHA-1 해시를 계산하여 고유한 해시 값을 생성합니다.(Git 객체의 이름, 저장될 경로)&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>&lt;strong>객체 생성 및 저장&lt;/strong>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>생성된 해시값을 이용하여 파일의 내용을 Git 객체로 저장합니다.(Blob)
&lt;ul>
&lt;li>Blob 객체는 파일의 바이너리 데이터를 담고 있으며, &lt;code>.git/obects&lt;/code> 디렉토리에 저장&lt;/li>
&lt;li>저장 경로는 해시값의 처음 두자리를 디렉토리 이름으로 사용하고, 나머지 38자리를 파일 이름으로 사용하여 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>&lt;strong>인덱스 업데이트&lt;/strong>
&lt;ul>
&lt;li>Blob 객체가 생성되고 저장된 후, Git은 인덱스 파일(&lt;code>.git/index&lt;/code>)을 업데이트합니다.
&lt;ul>
&lt;li>파일의 모드, 해시 값, 파일 이름 등을 기록합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="index">&lt;strong>&lt;code>index&lt;/code>&lt;/strong>&lt;/h3>
&lt;p>&lt;code>index&lt;/code> 파일은 &lt;code>stage&lt;/code> 영역에 있는 파일들 즉 작업 디렉토리 내 추적중인 파일을 의미하며, 다음 &lt;code>commit&lt;/code>에 포함될 파일의 정보들을 의미하게됩니다.&lt;/p>
&lt;p>만약 &lt;code>git init&lt;/code> 명령을 수행하고 &lt;code>README.md&lt;/code>와 &lt;code>src/index.js&lt;/code>를 추가한 후 &lt;code>git add&lt;/code> 명령을 수행했다면 &lt;code>.git/index&lt;/code> 파일의 내용은 아래와 같이 수정됩니다.(해시 값은 임의로 설정하였습니다.)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0 README.md
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">100644 24643cc37449b4bde54411a80b8ed61258225e34 0 src/index.js
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>띄어쓰기로 구분되는 각 요소는 &lt;code>파일 모드&lt;/code>, &lt;code>해시값&lt;/code>, &lt;code>스테이지 번호&lt;/code>, &lt;code>파일 경로&lt;/code>를 의미합니다.&lt;/p>
&lt;p>여기서 주의해야할 점은 &lt;code>.git/index&lt;/code>에는 &lt;code>Blob&lt;/code> 객체만 저장된다는 점 입니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>파일 모드&lt;/strong>&lt;/p>
&lt;p>맨 앞의 &lt;code>100644&lt;/code>는 파일 식별자로 흔히 알려진 파일의 권한을 포함하게됩니다.&lt;/p>
&lt;p>그 역할은 아래와 같습니다.&lt;/p>
&lt;ul>
&lt;li>읽기, 쓰기 파일(블롭): &lt;code>100644&lt;/code> (&lt;code>chmod 644&lt;/code>)&lt;/li>
&lt;li>실행 파일(블롭): &lt;code>100755&lt;/code> (&lt;code>chmod 755&lt;/code>)&lt;/li>
&lt;li>디렉터리(트리): &lt;code>040000&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>.git/index&lt;/code>는 &lt;code>Blob&lt;/code> 객체 정보만 관리하므로 읽기 파일, 실행 파일만 저장됩니다.&lt;/p>
&lt;p>&lt;code>Tree&lt;/code> 객체를 를 의미하는 &lt;code>040000&lt;/code>는 이후 커밋에 활용됩니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>스테이지 번호&lt;/strong>&lt;/p>
&lt;p>스테이지 번호는 병합 충돌 시 사용되는 필드입니다. 파일이 정상적으로 추가되었을 때는 &lt;code>0&lt;/code> 입니다.&lt;/p>
&lt;ul>
&lt;li>0: 기본 스테이지. 충돌이 없는 파일이 여기에 위치합니다.&lt;/li>
&lt;li>1: 공통 조상 (ancestor) 버전.&lt;/li>
&lt;li>2: 현재 브랜치 (our) 버전.&lt;/li>
&lt;li>3: 병합하려는 브랜치 (their) 버전.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>&lt;code>.git/index&lt;/code>의 역할&lt;/strong>&lt;/p>
&lt;p>인덱스 파일의 역할을 정리해보면 아래와 같습니다.&lt;/p>
&lt;ul>
&lt;li>인덱스 파일은 다음 커밋에 포함될 파일들을 추적합니다.&lt;/li>
&lt;li>인덱스에 추가된 파일들은 다음 &lt;code>git commit&lt;/code> 명령어가 실행될 때 커밋 히스토리에 포함됩니다.&lt;/li>
&lt;/ul>
&lt;h2 id="git-commit">&lt;code>git commit&lt;/code>&lt;/h2>
&lt;p>&lt;code>git commit&lt;/code> 명령어가 실행되었을 때 어떤 흐름이 발생하는지 확인해보겠습니다.&lt;/p>
&lt;ol>
&lt;li>&lt;code>Tree&lt;/code> 객체 생성
&lt;ul>
&lt;li>인덱스 파일에 기록된 내용을 바탕으로 트리 객체가 생성됩니다.&lt;/li>
&lt;li>트리 객체는 디렉토리 구조와 파일 정보를 담고 있으며, 각 파일은 &lt;code>Blob&lt;/code> 객체와 &lt;code>Tree&lt;/code> 객체를 가리킵니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Commit&lt;/code> 객체 생성
&lt;ul>
&lt;li>트리 객체가 생성된 후, 커밋 객체가 생성됩니다.
&lt;ul>
&lt;li>트리 객체의 해시 값&lt;/li>
&lt;li>부모 커밋(이전 커밋)의 해시 값(최초 커밋인 경우 제외)&lt;/li>
&lt;li>커밋 메시지&lt;/li>
&lt;li>작성자와 커미터 정보(이름, 이메일, 타임스탬프 등)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객체 저장 및 참조 업데이트
&lt;ul>
&lt;li>객체 저장
&lt;ul>
&lt;li>생성된 커밋 객체와 트리 객체는 &lt;code>.git/objects&lt;/code> 디렉토리에 저장됩니다.&lt;/li>
&lt;li>&lt;code>Blob&lt;/code> 객체와 마찬가지로 각 객체는 해시값을 기반으로 저장됩니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>참조 업데이트
&lt;ul>
&lt;li>새로운 커밋 객체가 생성되면, 현재 브랜치의 참조가 새로운 커밋을 가리키도록 업데이트 합니다.
&lt;ul>
&lt;li>현재 브랜치의 참조는 &lt;code>.git/refs/heads/&amp;lt;브랜치 이름&amp;gt;&lt;/code> 파일에 저장&lt;/li>
&lt;li>&lt;code>main&lt;/code>인 경우 &lt;code>.git/refs/heads/main&lt;/code> 파일의 내용이 새로운 커밋의 해시값으로 업데이트&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>새 커밋이 생성되면서 Git은 버전 히스토리를 관리합니다.&lt;/p>
&lt;p>각 커밋 객체는 이전 커밋 객체(부모 객체)를 가르키며, 이를 통해 커밋 히스토리가 마치 &lt;strong>연결 리스트&lt;/strong> 형태로 구성됩니다.&lt;/p>
&lt;h3 id="tree-객체의-구성">&lt;code>Tree&lt;/code> 객체의 구성&lt;/h3>
&lt;p>처음 &lt;code>git commit&lt;/code> 명령이 수행되면 작업 디렉토리를 기반으로 트리 객체를 만들게됩니다.&lt;/p>
&lt;p>트리 객체는 특정 디렉터리 내부에 포함되는 모든 파일(&lt;code>Blob&lt;/code> 객체), 디렉토리(&lt;code>Tree&lt;/code> 객체)의 해시값을 내용으로 가지며, 작업 디렉토리가 아래와 같은 구조를 가진다고 가정하고 내부 구조를 확인해보겠습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">project/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── README.md
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">└── src/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> └── index.js
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>작업 디렉터리의 루트 &lt;code>Tree&lt;/code> 객체는 아래와 같은 내용을 가지게됩니다.(해시값은 임의로 작성하였습니다.)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 README.md
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea0ea1e1 src
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>src&lt;/code> 디렉토리를 의미하는 &lt;code>Tree&lt;/code> 객체는 아래와 같은 내용을 가집니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">100644 24643cc37449b4bde54411a80b8ed61258225e34 index.js
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>각 내용들이 디렉토리를 구성하는 &lt;code>Git&lt;/code> 객체의 주소값을 가르키게됩니다.&lt;/p>
&lt;h3 id="commit-객체의-구성">&lt;code>Commit&lt;/code> 객체의 구성&lt;/h3>
&lt;p>&lt;code>Tree&lt;/code> 객체가 만들어지면 작업 디렉토리의 &lt;code>Tree&lt;/code> 객체(루트 &lt;code>Tree&lt;/code> 객체)의 주소를 이용하여 &lt;code>Commit&lt;/code> 객체를 만들게됩니다.&lt;/p>
&lt;p>&lt;code>Commit&lt;/code> 객체의 내용에는 작업 디렉토리의 루트 &lt;code>Tree&lt;/code> 객체의 해시값, 부모 커밋의 해시값, 커밋 메시지, 작성자와 커밋터의 정보가 담깁니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">tree &amp;lt;작업 디렉토리의 Tree 객체의 해시 값&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">parent &amp;lt;이전 커밋의 해시 값(첫 커밋이라면 생략)&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">author John Doe &amp;lt;john.doe@example.com&amp;gt; 1609459200 +0000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">committer John Doe &amp;lt;john.doe@example.com&amp;gt; 1609459200 +0000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;lt;커밋 메시지&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="요약">요약&lt;/h3>
&lt;ul>
&lt;li>&lt;code>git commit&lt;/code> 명령어는 스테이징 영역의 파일들을 기반으로 트리 객체를 생성하고, 이를 참조하는 커밋 객체를 생성합니다.&lt;/li>
&lt;li>생성된 커밋 객체는 &lt;code>.git/objects&lt;/code> 디렉토리에 저장되며, 현재 브랜치의 참조가 새로운 커밋 객체를 가리키도록 업데이트됩니다.&lt;/li>
&lt;li>이 과정은 Git의 분산 버전 관리 시스템이 효율적으로 파일의 변경 이력을 관리하고 추적할 수 있게 합니다.&lt;/li>
&lt;/ul>
&lt;h2 id="마무리">마무리&lt;/h2>
&lt;p>이전부터 &lt;code>.git&lt;/code>의 존재는 알았지만, 왜 존재하는지, 어떻게 구성되어있는지, 역할이 뭔지 등에 대해서는 큰 관심이 없었습니다.&lt;/p>
&lt;p>이번 기회를 통해 &lt;code>.git&lt;/code>의 내부 파일들(&lt;code>Git&lt;/code> 객체)의 상태 변화를 확인하면서 &lt;code>add&lt;/code>와 &lt;code>commit&lt;/code> 명령이 어떻게 수행되는지 더 깊이 이해할 수 있어 좋은 경험이었네요 😁&lt;/p>
&lt;p>읽어보시고 잘못된 정보나, 이해가 어려운 부분이 있다면 댓글 남겨주세요!&lt;/p>
&lt;p>틀린 내용이 있다면 빠르게 반영하고, 이해가 어려운 부분은 같이 다시 고민해볼 기회가 될 수 있을것 같습니다🔥&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다.😊&lt;/p></description></item><item><title>2. 깃 브랜치 전략과 CI/CD</title><link>https://codemario318.github.io/post/infra/container-env/2/</link><pubDate>Thu, 31 Aug 2023 23:21:25 +0900</pubDate><guid>https://codemario318.github.io/post/infra/container-env/2/</guid><description>&lt;img src="https://codemario318.github.io/post/infra/container-env/2/cover.png" alt="Featured image of post 2. 깃 브랜치 전략과 CI/CD" />&lt;h2 id="개요">개요&lt;/h2>
&lt;p>이번에는 깃 브랜치 전략을 바탕으로 깃 브랜치를 구성해보고, 이에 맞는 CI/CD를 구성해보겠습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/infra/container-env/2/img_6.png"
width="611"
height="815"
srcset="https://codemario318.github.io/post/infra/container-env/2/img_6_hua2ce8da1c7fb282b5321cfbd81b98186_159615_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/infra/container-env/2/img_6_hua2ce8da1c7fb282b5321cfbd81b98186_159615_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Git flow 브랜치 전략"
class="gallery-image"
data-flex-grow="74"
data-flex-basis="179px"
>&lt;/p>
&lt;p>이전 직장에서는 Git flow 브랜치 전략과 Gitlab flow 브랜치 전략과 유사한 방식으로 브랜치를 운용했습니다.&lt;/p>
&lt;p>관련 문서에는 Git flow 브랜치 전략으로 구성했다고 되어있었는데, 지속적으로 사용하면서 개발자들이 편하게 느끼는 방식으로 자연스럽게 바뀐 듯 했습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/infra/container-env/2/img_2.png"
width="340"
height="380"
srcset="https://codemario318.github.io/post/infra/container-env/2/img_2_hu37b9174b2a235d71e5adb3c528d76bd2_8951_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/infra/container-env/2/img_2_hu37b9174b2a235d71e5adb3c528d76bd2_8951_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Gitlab CI/CD"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="214px"
>&lt;/p>
&lt;p>그리고 Gitlab CI/CD를 통해 CI/CD가 구성되어 있었는데, 서버 로직에 jQuery 뿐만 아니라 Vue 등이 한 프로젝트에 존재하는 조금 복잡한 모놀리식 구조에서 Vue를 직접 빌드해서 푸시하는 것이 너무 불편해서 관련 작업을 했었습니다.&lt;/p>
&lt;p>CI/CD가 온프레미스 환경에서 이미 구축되어있던 운영, 테스트, 개발 환경을 유지하기 위해 깃 전환 전(3~4년 전?) SVN에서 사용하던 스크립트를 동작시키는 형태로 사용되고 있었는데 스크립트가 SPA 활용을 고려하지 않았고, 많이 복잡해서 고생했었던 기억이 나네요.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/infra/container-env/2/img_3.png"
width="676"
height="411"
srcset="https://codemario318.github.io/post/infra/container-env/2/img_3_hu5831d2581bfa751d7cc7e64e04ff784d_81701_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/infra/container-env/2/img_3_hu5831d2581bfa751d7cc7e64e04ff784d_81701_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Jenkins"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>8년 동안 제대로 진행하지 못한 회사의 계획인 언어 전환을 위해 MSA로 구조를 변경해야한다는 의견을 피력했었습니다.&lt;/p>
&lt;p>이를 위해 MSA 구조 변경을 위한 컨테이너 인프라에서 개발, 테스트, 운영 환경을 어떻게 배포해야 할까, CI/CD는 어떻게 구성하면 좋을까 고민했었는데 퇴사 기념으로 한번 정리해보고 직접 구성해보려고 합니다.&lt;/p>
&lt;p>Gitlab CI/CD 작업할 때 자료가 많이 없어 고생했던 기억도 있고, 새로운 내용을 찍먹하기 위해 이번에는 Jenkins으로 해보겠습니다.&lt;/p>
&lt;h2 id="개발-프로세스">개발 프로세스&lt;/h2>
&lt;p>다시 이전 직장 이야기를 해보면 개발 프로세스는 다음과 같았습니다.(git-flow 기준으로 설명하겠습니다.)&lt;/p>
&lt;ol>
&lt;li>release 브랜치에서 feature 브랜치를 생성한다.
&lt;ul>
&lt;li>CI/CD로 온프레미스 테스트용 서버들로 feature 브랜치를 복제하고 nginx 설정 추가를 통해 개발 서버를 배포&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>feature 브랜치에서 작업한다.
&lt;ul>
&lt;li>개발자가 여러 명 투입되면 한 브랜치를 같이 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>feature 브랜치로 release 브랜치에 대해 MR을 만들고 개발 테스트와 선택적으로 코드 리뷰를 진행한다.&lt;/li>
&lt;li>feature 브랜치를 통해 배포된 devlopment, staging, production 환경에서 QA를 진행한다.&lt;/li>
&lt;li>feature 브랜치를 release 브랜치에 머지하고 release 브랜치를 이용해 devlopment, staging, production 환경에서 QA를 진행한다.
&lt;ul>
&lt;li>production 테스트 진행시 사용자에게 영향을 줄 수 있는 테스트는 금지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>매주 화, 목 release 브랜치를 master 브랜치와 머지한다.
&lt;ul>
&lt;li>CI/CD를 통해 배포&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="문제">문제&lt;/h2>
&lt;p>위와 같은 개발 프로세스를 거치면서 아래와 같은 불편함을 느꼈습니다.&lt;/p>
&lt;ul>
&lt;li>작업 영역이 비슷한 경우, release 브랜치에서 발생한 이슈가 내가 작업한 부분 때문에 발생한 이슈인지, 다른 feature에서 발생한 이슈인지 확인하기 까다롭다.
&lt;ul>
&lt;li>작업을 최대한 겹치지 않게 배정해주시긴 했습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>release 브랜치에 새로운 feature가 머지되면 새로운 이슈가 발생하여 다른 feature에도 영향을 줄 수 있다.
&lt;ul>
&lt;li>충돌 처리 실수, 사이드 이펙트 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>release 브랜치에서의 QA 시나리오가 클 경우 정기 배포로 인해 충분히 검증할 시간이 부족할 수 있다.&lt;/li>
&lt;li>feature 브랜치들이 온프레미스 환경에 배포되어 진행중인 업무가 많다면 서버의 리소스가 부족해진다.&lt;/li>
&lt;/ul>
&lt;p>저는 이러한 문제의 원인이 feature가 통합되는 release 브랜치라고 생각했습니다.&lt;/p>
&lt;hr>
&lt;p>많은 회사에서 Git flow를 채택하여 버전 별 release 환경을 구성하는 방식을 채택하고 있으며, 특히 feature 브랜치를 많이 구성해야하는 경우 이러한 선택을 통해 리스크를 줄이고 있는 것으로 보입니다.&lt;/p>
&lt;p>개인적으로 Git flow 브랜치 전략에서 release 브랜치를 구성하는 이유는 production 버저닝이 가장 크다고 생각합니다.&lt;/p>
&lt;p>많은 소프트웨어 제품, 라이브러리처럼 버전마다 많은 변경을 한번에 적용하고 이전 버전을 계속 사용해야 하는 경우 release를 통해 여러 장점을 취할 수 있지만 웹 서비스처럼 작은 변경 사항들을 지속적으로 빠르게 반영해야고, 이전 버전이 큰 의미가 없는 경우 이러한 버저닝이 주는 장점은 크지 않으며 오히려 부작용이 더 크다고 생각되었습니다.&lt;/p>
&lt;p>그럼에도 불구하고 이전 직장에서 이러한 방식으로 브랜치를 구성한 이유도 납득은 됩니다.&lt;/p>
&lt;ul>
&lt;li>큰 모놀리식 레거시로 인해 발생하는 이슈를 release를 통해 확인할 수 있어 안심할 수 있음&lt;/li>
&lt;li>비교적 최근까지 활용했던 SVN 개발 프로세스를 그대로 활용하기 위해&lt;/li>
&lt;li>온프레미스 환경에 맞추어 작성된 복잡한 배포 스크립트 수정 부담&lt;/li>
&lt;li>기존 개발자들의 학습 부담 등&lt;/li>
&lt;/ul>
&lt;h2 id="github-flow">Github flow&lt;/h2>
&lt;p>Git flow와 같은 복잡한 브랜치 전략을 단순화 하기 위해 GitHub flow와 이를 기본으로 한 여러 브랜치 전략이 제안되었습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/infra/container-env/2/img_5.png"
width="899"
height="310"
srcset="https://codemario318.github.io/post/infra/container-env/2/img_5_hu32b531840387ea0c7d99f8c87fd2f043_42672_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/infra/container-env/2/img_5_hu32b531840387ea0c7d99f8c87fd2f043_42672_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Github flow 브랜치 전략"
class="gallery-image"
data-flex-grow="290"
data-flex-basis="696px"
>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/infra/container-env/2/img.png"
width="680"
height="215"
srcset="https://codemario318.github.io/post/infra/container-env/2/img_hub4e24b09e961750363b132c6ffc9a180_42277_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/infra/container-env/2/img_hub4e24b09e961750363b132c6ffc9a180_42277_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Trunk-Based Development"
class="gallery-image"
data-flex-grow="316"
data-flex-basis="759px"
>&lt;/p>
&lt;p>Github flow는 Github에서 제안된 배포 전략으로 크게 아래와 같은 프로세스를 가집니다.&lt;/p>
&lt;ol>
&lt;li>main 브랜치를 기준으로 새로운 기능 또는 버그 수정을 개발하기 위한 브랜치 생성.&lt;/li>
&lt;li>변경 사항을 커밋하고, 이를 Pull Request (PR)로 병합 요청.&lt;/li>
&lt;li>PR에서 코드 검토와 논의 진행.&lt;/li>
&lt;li>PR 승인 시 main 브랜치로 병합하고 자동 배포.&lt;/li>
&lt;/ol>
&lt;p>Github Flow는 단순한 구조로 버전 관리가 필요 없으면서 빠른 배포가 필요한 작은 규모의 프로젝트에서 유용하게 활용될 수 있으나 너무 단순한 구조로 인해 비교적 규모가 있는 프로젝트에서는 적합하지 않을 수 있습니다.&lt;/p>
&lt;ul>
&lt;li>복잡한 워크플로우 지원 부족&lt;/li>
&lt;li>긴 작업 처리의 어려움&lt;/li>
&lt;li>명시적인 staging 환경 부재 등&lt;/li>
&lt;/ul>
&lt;p>이러한 단점으로 아래와 같은 경우 적용이 어려울 수 있습니다.&lt;/p>
&lt;ul>
&lt;li>다수의 인원이 협업을 하는 경우&lt;/li>
&lt;li>작업 수가 많은 경우 등&lt;/li>
&lt;li>모놀리식 구조&lt;/li>
&lt;li>Mono-repo&lt;/li>
&lt;/ul>
&lt;h2 id="gitlab-flow">Gitlab flow&lt;/h2>
&lt;p>release 브랜치를 통해 feature 브랜치를 통합하는 과정이 없이 리뷰 완료 후 배로 배포되는 Github flow에서는 기존 Git 복잡함을 해소하였지만 단순한 구조로 아쉬운 부분들이 있는데, 이러한 부분들을 해소할 수 있는 브랜치 전략으로 Gitlab flow가 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/infra/container-env/2/img_1.png"
width="560"
height="618"
srcset="https://codemario318.github.io/post/infra/container-env/2/img_1_hu11c3f8bf1da0319955b150f4042e7b59_25349_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/infra/container-env/2/img_1_hu11c3f8bf1da0319955b150f4042e7b59_25349_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Gitlab flow 브랜치 전략"
class="gallery-image"
data-flex-grow="90"
data-flex-basis="217px"
>&lt;/p>
&lt;p>Git flow는 develop 브랜치를 기준으로 새로운 기능들이 추가되고 이러한 변경 내용들을 release 브랜치를 통해 통합되지만, Gitlab flow는 master 브랜치를 기준으로 feature 브랜치를 만들고 feature 브랜치를 통해 만들어지는 기능을 직접 반영하는 방식입니다.&lt;/p>
&lt;p>이러한 기능 중심의 개발을 통해 릴리스 머지에서 발생하는 오버헤드를 예방할 수 있습니다.&lt;/p>
&lt;p>feature 브랜치를 통해 개발 환경 테스트를 진행하고, master 브랜치를 통해 staging 환경에 대한 배포와 테스트를 진행하며, pre-production 브랜치를 통해 운영 환경에서의 테스트를 완료하고 실제 운영 환경으로 배포되는 흐름을 가지고 있습니다.&lt;/p>
&lt;p>그래서 저는 Gitlab flow 브랜치 전략을 활용해서 프로세스를 구성하고, CI/CD로 테스트 환경까지 만들어보는 작업을 해보려고 합니다. 대략적인 프로세스는 다음과 같습니다.&lt;/p>
&lt;ol>
&lt;li>master 브랜치에서 feature 브랜치를 생성한다.
&lt;ul>
&lt;li>feature 브랜치를 기준으로 CI/CD를 활용하여 dev 환경을 배포한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>feature 브랜치에서 작업을 완료 후 master 브랜치에 MR를 만들고 리뷰를 진행하고 리뷰가 완료되면 master 브랜치에 머지한다.
&lt;ul>
&lt;li>master 기준으로 stg 환경을 배포한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>stg QA가 완료되면 master 브랜치를 pre-production 브랜치로 머지한다.
&lt;ul>
&lt;li>pre-production 기준으로 운영 환경을 배포한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>pre-production QA가 완료되면 실제로 배포한다.&lt;/li>
&lt;/ol>
&lt;h3 id="best-practices">Best practices&lt;/h3>
&lt;p>Gitlab flow 브랜치 전략을 사용할 때 아래와 같은 그라운드 룰을 설정하고 지킬것을 권하고 있습니다.&lt;/p>
&lt;ol>
&lt;li>master 브랜치에 대해 직접 커밋하지 않고 꼭 feature 브랜치들을 사용하여 반영
&lt;ul>
&lt;li>머지 전 코드 리뷰를 쉽게 할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모든 커밋에 대해 모든 테스트를 수행
&lt;ul>
&lt;li>master 브랜치에 존재하는 모든 기능들이 기본적으로 동작한다고 확신할 수 있어야 한다.&lt;/li>
&lt;li>feature 브랜치에 새롭게 커밋할 때&lt;/li>
&lt;li>master에 병합할 때&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>master 브랜치에 feature 브랜치를 머지하기 전 코드리뷰 수행&lt;/li>
&lt;li>배포는 branch 또는 tag 기준으로 자동을 수행&lt;/li>
&lt;li>master에 이미 반영된 커밋에 대해 rebase를 수행 X
&lt;ul>
&lt;li>기존 테스트와 수정 내용을 확인하기 힘들어 질 수 있다.&lt;/li>
&lt;li>cherry pick이 힘들어질 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모든 feature 브랜치의 시작과 병합 대상은 master 브랜치
&lt;ul>
&lt;li>길어지는 브랜치 분기를 막을 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>커밋 메시지는 무슨 역할을 했는지 표현해야함.&lt;/li>
&lt;li>핫픽스는 master 먼저 반영할 것&lt;/li>
&lt;/ol></description></item></channel></rss>