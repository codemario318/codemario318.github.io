<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Consistency on Mario Blog</title><link>https://codemario318.github.io/tags/consistency/</link><description>Recent content in Consistency on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Wed, 21 May 2025 16:10:00 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/consistency/index.xml" rel="self" type="application/rss+xml"/><item><title>논문으로 다시 이해한 CAP 정리</title><link>https://codemario318.github.io/post/common/cap/</link><pubDate>Wed, 21 May 2025 16:10:00 +0900</pubDate><guid>https://codemario318.github.io/post/common/cap/</guid><description>&lt;img src="https://codemario318.github.io/post/common/cap/cover.png" alt="Featured image of post 논문으로 다시 이해한 CAP 정리" />&lt;h2 id="들어가며">들어가며&lt;/h2>
&lt;p>분산 시스템 설계에 대해 학습하다보면, CAP 정리가 항상 언급되는 것 같습니다.&lt;/p>
&lt;p>CAP 정리는 일관성(Consistency), 가용성(Availability), 분할 내성(Partition Tolerance) 세 가지를 동시에 만족할 수 없다는 원칙으로 요약되는데요&lt;/p>
&lt;p>이 정리는 2000년 Eric Brewer가 학회 발표에서 처음 제안한 이후, 분산 시스템 설계의 기본 전제로 널리 인용되어 왔습니다.&lt;/p>
&lt;p>처음 봤을 땐 그렇구나 하고 넘어갔는데, 계속 등장하니 조금 더 깊은 내용이 궁금해졌습니다.&lt;/p>
&lt;p>그래서 이 글에서는 해당 추측을 이론적으로 증명한 논문, &lt;a class="link" href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;amp;type=pdf&amp;amp;doi=24cece61e2128780072bc58f90b8ba47f624bc27" target="_blank" rel="noopener"
>&lt;em>Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services&lt;/em>&lt;/a>를 바탕으로 CAP가 어떤 의미인지 정확히 파악해보려고 합니다.&lt;/p>
&lt;p>논문의 내용을 단락 단위로 해석하고, 그 의미를 함께 짚어보는 방식으로 살펴보겠습니다.&lt;/p>
&lt;h2 id="도입부">도입부&lt;/h2>
&lt;h3 id="brewer의-추측">Brewer의 추측&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>At PODC 2000, Brewer, in an invited talk, made the following conjecture: it is impossible for a web service to provide the following three guarantees: consistency, availability, and partition-tolerance.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>2000년 PODC 학회에서 Eric Brewer는 웹 서비스가 다음의 세 가지 특성을 동시에 만족시킬 수 없다는 추측을 언급했습니다.&lt;/p>
&lt;ul>
&lt;li>일관성 (Consistency)&lt;/li>
&lt;li>가용성 (Availability)&lt;/li>
&lt;li>분할 내성 (Partition tolerance)&lt;/li>
&lt;/ul>
&lt;p>이 세 가지는 각각의 의미도 중요하지만, 무엇보다 &amp;ldquo;동시에 만족시킬 수 없다&amp;quot;는 점이 핵심입니다. 처음엔 추측으로 제안된 이 주장은, 지금은 CAP 정리라는 이름으로 잘 알려져 있죠.&lt;/p>
&lt;p>그러한 이유로 CAP 정리를 브루어의 정리라고도 부르기도 합니다. 논문은 이 세 가지가 왜 동시에 만족될 수 없는지를 구체적인 모델 위에서 이론적으로 증명합니다.&lt;/p>
&lt;h3 id="일관성에-대한-기대">일관성에 대한 기대&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>Most web services today attempt to provide strongly consistent data. &amp;hellip; (중략) &amp;hellip; once a transaction is committed it is permanent (durable).&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>현실의 웹 서비스는 ACID 트랜잭션을 전제로 강한 일관성을 기본 기대값으로 두고 있다&lt;/strong>고 볼 수 있습니다.&lt;/p>
&lt;p>사용자는 데이터가 중간에 잘렸거나, 쓰기 도중 일부만 반영된 상태를 보는 것을 원하지 않습니다. 쓰기가 완료되었다면 어떤 노드에서 읽더라도 동일한 값을 받을 수 있어야 한다는 기대가 전제되어 있습니다.&lt;/p>
&lt;p>이런 이유로 대부분의 시스템은 트랜잭션을 기반으로 한 일관성 보장 메커니즘을 필수 요소로 고려하게 됩니다.&lt;/p>
&lt;h3 id="가용성에-대한-기대">가용성에 대한 기대&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>Web services are similarly expected to be highly available. &amp;hellip; (중략) &amp;hellip; The goal of most web services today is to be as available as the network on which they run: if any service on the network is available, then the web service should be accessible.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>웹 서비스는 언제든지 요청에 응답할 수 있어야 한다는 기대를 받는다&lt;/strong>고 정리할 수 있습니다.&lt;/p>
&lt;p>서비스 중단은 단순한 불편을 넘어서 실제 피해로 이어질 수 있습니다. 논문에서는 증권 거래 사이트(E-Trade)의 사례를 들어, 서비스가 중요한 시점에 응답하지 못할 경우 법적 문제까지 발생할 수 있다고 설명합니다.&lt;/p>
&lt;p>그만큼 가용성은 기술적 요구를 넘어 &lt;strong>서비스의 신뢰성과 직접 연결되는 특성&lt;/strong>입니다.&lt;/p>
&lt;p>이 때문에 대부분의 시스템은 네트워크 어딘가에 살아 있는 노드가 있다면, 전체 시스템 역시 반드시 응답할 수 있어야 한다는 전제를 갖고 설계됩니다.&lt;/p>
&lt;h3 id="분할-내성에-대한-필요">분할 내성에 대한 필요&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>Finally, on a highly distributed network, it is desirable to provide some amount of fault-tolerance. &amp;hellip; (중략) &amp;hellip; In this note we will not consider stopping failures, though in some cases a stopping failure can be modeled as a node existing in its own unique component of a partition.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>분산 시스템에서는 네트워크 분할 상황에서도 동작을 계속할 수 있는 능력, 즉 분할 내성이 요구된다&lt;/strong>고 볼 수 있습니다.&lt;/p>
&lt;p>노드나 통신 경로에 장애가 발생하는 상황은 실제 시스템에서 흔히 일어납니다. 이때 전체 시스템이 멈추지 않고 가능한 범위 내에서 계속 동작해야 한다는 요구가 생깁니다.&lt;/p>
&lt;p>논문에서는 일부 노드나 메시지가 단절된 상황을 &amp;ldquo;분할(partition)&amp;ldquo;로 간주하고, 이러한 환경에서도 서비스가 가능한 상태를 유지할 수 있어야 한다는 점을 분할 내성의 핵심으로 설명합니다.&lt;/p>
&lt;h2 id="논문에서-정의하는-세-가지-특성">논문에서 정의하는 세 가지 특성&lt;/h2>
&lt;p>앞에서 소개한 세 가지 특성은 모두 중요하지만, 그 의미가 모호하거나 해석에 따라 다르게 받아들여질 수 있습니다.&lt;/p>
&lt;p>따라서 논문에서는 본격적인 증명에 앞서, 이 세 가지 특성을 정확히 어떤 의미로 사용할지를 형식적으로 정의하고 있습니다.&lt;/p>
&lt;p>각 정의는 논문 전체에서 사용하는 모델의 핵심 가정이기도 하며, 이후 증명의 기반이 되는 전제 조건으로 작용합니다.&lt;/p>
&lt;h3 id="atomic-data-object">Atomic Data Object&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>The most natural way of formalizing the idea of a consistent service is as an atomic data object. &amp;hellip; (중략) &amp;hellip; See [6] for a more complete definition of atomic consistency.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>Atomic Data Object는 분산된 환경에서도 순차적으로 동작하는 것처럼 보이는 일관성을 모델링한 개념이다&lt;/strong>라고 이해할 수 있습니다.&lt;/p>
&lt;p>논문에서는 일관성을 형식적으로 정의하기 위해 &lt;strong>Atomic Data Object&lt;/strong>를 사용합니다.&lt;/p>
&lt;p>이 객체는 **atomic consistency (또는 linearizability)**를 만족해야 하며, 이는 모든 연산이 일관된 전역 순서를 따르는 것처럼 동작함을 의미합니다.&lt;/p>
&lt;p>예를 들어, 어떤 쓰기 연산이 완료된 이후 시작된 읽기 연산은 반드시 그 값 또는 그 이후의 값을 반환해야 합니다.&lt;/p>
&lt;p>이런 모델은 사용자 입장에서 시스템이 &lt;strong>단일 노드처럼 예측 가능하게&lt;/strong> 동작한다고 느낄 수 있게 해줍니다.&lt;/p>
&lt;h3 id="availability">Availability&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>For a distributed system to be continuously available, every request received by a non-failing node in the system must result in a response. &amp;hellip; (중략) &amp;hellip; even when severe network failures occur, every request must terminate.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>고장나지 않은 노드로 들어온 요청은 반드시 응답을 받아야 한다&lt;/strong>라고 이해할 수 있습니다.&lt;/p>
&lt;p>논문에서는 가용성을 &amp;ldquo;모든 요청이 언젠가는 응답을 받아야 한다&amp;quot;는 조건으로 정의합니다. 특히 이 정의는 &lt;strong>메시지가 유실될 수 있는 환경에서도 요청을 포기하지 않고 처리해야 함&lt;/strong>을 전제로 하고 있습니다.&lt;/p>
&lt;p>이는 단순한 성능 문제가 아니라 &lt;strong>시스템이 지속적으로 응답 가능하다는 보장&lt;/strong>, 즉 실시간으로 동작하는 서비스가 가져야 할 기본 조건으로 제시됩니다.&lt;/p>
&lt;p>또한 부분 실패 상황, 예를 들어 다른 모든 노드가 실패하더라도 하나의 노드만 살아 있다면 그 노드는 여전히 &lt;strong>요청에 응답할 수 있어야 한다&lt;/strong>는 점을 강조합니다.&lt;/p>
&lt;h3 id="partition-tolerance">Partition Tolerance&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>In order to model partition tolerance, the network will be allowed to lose arbitrarily many messages sent from one node to another. &amp;hellip; (중략) &amp;hellip; a valid (atomic) response must be generated.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>분할 내성은 네트워크 일부가 단절되어도 시스템이 동작을 멈추지 않아야 한다는 특성을 의미한다&lt;/strong>고 볼 수 있습니다.&lt;/p>
&lt;p>논문에서는 네트워크 분할을 모델링하기 위해, &lt;strong>일부 노드 간의 메시지가 영구적으로 손실되는 상황&lt;/strong>을 허용합니다. 이 경우 시스템은 전체가 멈추는 것이 아니라, &lt;strong>분리된 각 노드가 독립적으로 응답을 계속할 수 있어야 한다&lt;/strong>는 요구를 받습니다.&lt;/p>
&lt;p>분할 내성을 만족하는 시스템은 하나의 노드만 살아 있고 나머지 노드들과 통신할 수 없는 상황에서도, 해당 노드는 &lt;strong>자체적으로 요청을 처리하고 응답할 수 있어야 합니다.&lt;/strong>&lt;/p>
&lt;p>이 정의는 논문 전반에서 &lt;strong>Partition Tolerance를 &amp;lsquo;메시지 유실이 있는 환경에서의 정상 동작 보장&amp;rsquo;으로 해석한다&lt;/strong>는 점에서 중요합니다.&lt;/p>
&lt;h2 id="비동기-네트워크에서의-불가능성">비동기 네트워크에서의 불가능성&lt;/h2>
&lt;p>논문에서는 본격적인 증명에 앞서 정의한 세 가지 특성이 어떤 조건 하에서 동시에 만족될 수 없는지를 순차적으로 보여줍니다.&lt;/p>
&lt;p>이 섹션에서는 먼저 &lt;strong>비동기 네트워크 모델&lt;/strong>에서의 불가능성을 다루고 있으며, 이를 통해 CAP 정리가 단순한 직관이 아니라 &lt;strong>논리적으로 증명 가능한 제약&lt;/strong>임을 밝히고 있습니다.&lt;/p>
&lt;h3 id="정리-1-비동기-모델에서-cap-불가능성-증명">정리 1: 비동기 모델에서 CAP 불가능성 증명&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>In the asynchronous model, there is no clock, and nodes must make decisions based only on the messages received and local computation. &amp;hellip; (중략) &amp;hellip; Theorem 1: It is impossible in the asynchronous network model to implement a read/write data object that guarantees the following properties: Availability, Atomic consistency, in all fair executions (including those in which messages are lost).&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>비동기 네트워크 모델에서는 가용성과 원자적 일관성을 동시에 만족하는 읽기/쓰기 객체를 구현할 수 없다&lt;/strong>는 것이 이 정리의 핵심입니다.&lt;/p>
&lt;p>논문에서 사용하는 비동기 네트워크 모델은 다음과 같은 특징을 가집니다.&lt;/p>
&lt;ul>
&lt;li>시스템에는 전역 시계가 없음&lt;/li>
&lt;li>노드는 수신한 메시지와 로컬 상태만으로 동작을 결정&lt;/li>
&lt;li>메시지는 유실될 수 있고, 언제 도착할지 보장되지 않음&lt;/li>
&lt;/ul>
&lt;p>이러한 조건 아래에서, 논문은 &lt;strong>쓰기 연산이 완료된 후에도 일부 노드가 이전 값을 반환하는 상황이 발생&lt;/strong>할 수 있음을 보여줍니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">sequenceDiagram
participant Client
participant G1 as 노드 G1
participant G2 as 노드 G2
Note over G1, G2: 초기 상태: v₀ (G1 = v₀, G2 = v₀)
Client->>G1: 쓰기 요청 (v₁)
G1->>G1: v₁ 저장
G1-->>Client: 쓰기 완료 응답
G1-xG2: 메시지 유실 (v₁ 전달 실패)
Client->>G2: 읽기 요청
G2-->>Client: v₀ 반환
&lt;/pre>
&lt;ol>
&lt;li>노드 G1에서 쓰기 연산이 완료&lt;/li>
&lt;li>G1과 G2 사이의 네트워크가 분할되어, G2는 그 값을 전달받지 못함&lt;/li>
&lt;li>이후 클라이언트가 G2에 읽기 요청을 보냄&lt;/li>
&lt;li>G2는 여전히 초기 값을 반환&lt;/li>
&lt;/ol>
&lt;p>이 상황에서 시스템은 가용성을 만족하기 위해 G2의 요청에 응답하지만, 그 결과 일관성이 깨지는 응답을 줄 수밖에 없다는 모순이 발생합니다.&lt;/p>
&lt;p>이를 통해 CAP 정리에서 말하는 세 가지 특성이 &lt;strong>왜 동시에 만족될 수 없는지를, 수학적 모델을 통해 명확히 보여주는 출발점&lt;/strong>이 됩니다.&lt;/p>
&lt;h3 id="따름정리-11-메시지-유실-여부를-판단할-수-없는-상황">따름정리 1.1: 메시지 유실 여부를 판단할 수 없는 상황&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>Corollary 1.1: It is impossible in the asynchronous network model to implement a read/write data object that guarantees the following properties: Availability, in all fair executions, and Atomic consistency, in fair executions in which no messages are lost.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>메시지가 유실되지 않는 경우에도 가용성과 원자적 일관성을 동시에 만족하는 시스템은 구현할 수 없다&lt;/strong>는 것이 이 따름정리의 핵심입니다.&lt;/p>
&lt;p>정리 1에서는 메시지 유실이 가능한 상황을 통해 모순을 구성했지만, Corollary 1.1에서는 &lt;strong>메시지가 유실되지 않는 경우만 고려하더라도 동일한 모순이 발생&lt;/strong>함을 강조합니다.&lt;/p>
&lt;p>그 이유는 &lt;strong>비동기 모델에서는 메시지가 단순히 지연된 것인지, 실제로 유실된 것인지 시스템이 구분할 수 없기 때문&lt;/strong>입니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">sequenceDiagram
participant Client
participant G1 as 노드 G1
participant G2 as 노드 G2
Note over G1, G2: 초기 상태: v₀ (G1 = v₀, G2 = v₀)
Client->>G1: 쓰기 요청 (v₁)
G1->>G1: v₁ 저장
G1-->>Client: 쓰기 완료 응답
Client->>G2: 읽기 요청
G2-->>Client: v₀ 반환
G1->>G2: 메시지 수신
G2->>G2: v₁ 저장
&lt;/pre>
&lt;p>위 상황은 G1의 메시지가 클라이언트가 G2에게 보내는 요청 보다 빨리 도달했을 때를 가정해봤습니다.&lt;/p>
&lt;p>이처럼 메시지가 유실되지 않았더라도, 노드는 언제까지 기다려야 할지 알 수 없고, 결국 같은 방식의 일관성 위반이 발생하게 됩니다.&lt;/p>
&lt;p>이 따름정리는 비동기 모델에서의 &lt;strong>정보 부족의 한계&lt;/strong>를 명확히 드러냅니다. 즉, 유실 여부를 알 수 없다는 사실 하나만으로도, 어떤 실행에서는 일관성을 만족시키는 것이 불가능해질 수 있습니다.&lt;/p>
&lt;p>논문에서는 완전한 비동기 환경이라면 노드가 메시지가 지연되는지, 유실되었는지 판단할 수 없기 때문에 메시지가 유실되지 않는 경우 가용성과 원자적 일관성을 동시에 만족한다는 의미는 결과적으로 &lt;strong>모든 상황(유실, 지연)에 가용성과 원자적 일관성을 동시에 만족&lt;/strong>하는 상황이라고 강조합니다.&lt;/p>
&lt;h2 id="비동기-모델에서의-현실적인-조합">비동기 모델에서의 현실적인 조합&lt;/h2>
&lt;p>앞서 정리 1과 따름정리 1.1을 통해,&lt;br>
비동기 네트워크에서는 &lt;strong>Atomic consistency, Availability, Partition tolerance&lt;/strong>를 동시에 만족하는 것이 불가능하다는 점이 증명되었습니다.&lt;/p>
&lt;p>하지만 세 가지를 모두 만족할 수 없다면, 그중 두 가지 조합은 실현 가능할 수 있음을 언급하며, 이를 다음과 같이 세 가지 조합으로 구분하고, 각각 어떤 상황에서 가능한지를 간단한 모델을 통해 설명합니다.&lt;/p>
&lt;blockquote>
&lt;p>이때 사용되는 &amp;ldquo;Atomic&amp;quot;은 앞서 정의한 atomic consistency, 즉 선형화 가능한 일관성을 의미합니다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="atomic--available">Atomic + Available&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>If partition-tolerance is not required, then atomicity and availability are easy to guarantee. &amp;hellip; (중략) &amp;hellip; This technique only works if the centralized node is always accessible.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>Partition tolerance를 포기하면 atomic consistency와 availability는 함께 보장할 수 있습니다.&lt;/strong>&lt;/p>
&lt;p>이 조합은 Partition tolerance를 전제하지 않는 경우에 가능합니다.&lt;/p>
&lt;p>즉, 네트워크가 항상 안정적이며, 노드 간 통신이 절대 실패하지 않는 환경이라면 atomic consistency와 availability를 동시에 만족하는 시스템을 구현할 수 있습니다.&lt;/p>
&lt;p>논문에서는 이러한 조건 아래에서 중앙 집중형 알고리즘을 통해 모든 요청을 직렬화하고, 실패가 없는 한 모든 요청에 응답할 수 있는 구조를 예시로 제시합니다.&lt;/p>
&lt;p>다만 Partition tolerance가 없는 분산 시스템은 현실적으로 성립하기 어렵기 때문에, 이 조합은 제한된 환경(예: 단일 데이터센터, LAN 등)에서만 현실적으로 가능하다는 점도 강조하고 있습니다.&lt;/p>
&lt;h3 id="available--partition-tolerant">Available + Partition Tolerant&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>It is possible to provide high availability and partition tolerance, if atomic consistency is not required. &amp;hellip; (중략) &amp;hellip; Web caches are one example of a weakly consistent network.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>atomic consistency를 포기하면 availability와 partition tolerance는 동시에 만족할 수 있습니다.&lt;/strong>&lt;/p>
&lt;p>이 조합은 시스템이 항상 응답 가능해야 하면서도, 네트워크 분할 상황에서도 멈추지 않고 동작해야 할 때 선택할 수 있습니다. 대신 모든 노드가 동일한 시점의 값을 보장하는 일관성은 포기해야 합니다.&lt;/p>
&lt;p>논문에서는 이 조합을 만족시키는 극단적인 예로, 모든 읽기 요청에 초기값 &lt;code>v₀&lt;/code>만을 반환하는 시스템을 제시합니다.&lt;/p>
&lt;p>이 경우 일관성은 없지만, 어떤 상황에서도 요청은 처리됩니다.&lt;/p>
&lt;p>실제로는 이보다는 **약한 일관성(weak consistency)**을 부분적으로 유지하면서, 가능한 한 최신 데이터를 반환하려는 구조들이 현실적인 선택지로 사용됩니다.&lt;/p>
&lt;ul>
&lt;li>이러한 접근은 이후 논문에서 다루는 약한 일관성과 지연된 일관성 개념으로 이어집니다.&lt;/li>
&lt;/ul>
&lt;h3 id="atomic--partition-tolerant">Atomic + Partition Tolerant&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>If availability is not required, then it is easy to achieve atomic data and partition tolerance. &amp;hellip; (중략) &amp;hellip; If there are no failures, then liveness is guaranteed.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>가용성을 포기하면 atomic consistency와 partition tolerance는 동시에 만족시킬 수 있습니다.&lt;/strong>&lt;/p>
&lt;p>이 조합은 Availability를 포기한 경우에 가능합니다. 시스템이 일관성과 분할 내성을 만족해야 한다면, 일부 요청에 대해서는 응답하지 않아도 되는 상황을 허용해야 합니다.&lt;/p>
&lt;p>논문에서는 중앙 집중형 알고리즘을 예로 들며 이 조합이 어떻게 성립하는지를 설명합니다.&lt;/p>
&lt;p>요청을 받은 노드는 중앙 노드에 메시지를 전송하고, 중앙 노드로부터 응답을 받은 뒤에야 클라이언트에 응답합니다. 하지만 네트워크 분할로 인해 중앙 노드와 통신이 불가능한 경우, 클라이언트 요청에 대한 응답은 무한히 지연되거나 아예 실패할 수 있습니다.&lt;/p>
&lt;p>이 방식은 모든 메시지가 정상적으로 전달된다면 시스템은 응답 가능하지만, 분할이 발생하는 실행에서는 일관성을 보존하기 위해 가용성을 희생하게 됩니다.&lt;/p>
&lt;h2 id="부분-동기-모델에서의-논의">부분 동기 모델에서의 논의&lt;/h2>
&lt;p>비동기 네트워크에서는 CAP 세 가지를 동시에 만족할 수 없다는 점이 증명되었지만, 현실의 시스템은 대부분 &lt;strong>완전히 비동기적이지는 않습니다&lt;/strong>.&lt;/p>
&lt;p>일정 시간 안에 메시지가 도달하거나, 노드가 타임아웃을 기준으로 동작을 조정하는 식의 &lt;strong>부분적인 동기성&lt;/strong>이 존재합니다.&lt;/p>
&lt;p>논문에서는 이러한 현실적인 조건을 반영한 **부분 동기 네트워크 모델(partially synchronous model)**을 도입하여, 이 환경에서도 여전히 불가능한 것이 무엇인지 분석합니다.&lt;/p>
&lt;h3 id="정리-2-시계가-있어도-해결되지-않는-모순">정리 2: 시계가 있어도 해결되지 않는 모순&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>Theorem 2: It is impossible in the partially synchronous network model to implement a read/write data object that guarantees the following properties: Availability and Atomic consistency.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>부분 동기 모델에서도 Availability와 Atomic consistency는 동시에 만족시킬 수 없습니다.&lt;/strong>&lt;/p>
&lt;p>이 정리는 분산 시스템의 각 노드가 시계를 가지고 있고, 메시지가 일정 시간 내에 도착하거나 유실된다는 조건이 주어진 상황에서도 앞서와 같은 모순이 여전히 발생함을 보여줍니다.&lt;/p>
&lt;p>논문에서는 G1에서 쓰기 연산이 완료된 뒤 충분한 시간이 흐른 후, G2에서 읽기 연산이 수행되는 시나리오를 구성합니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">sequenceDiagram
participant Client
participant G1 as 노드 G1
participant G2 as 노드 G2
Note over G1, G2: 초기 상태: G1 = v₀, G2 = v₀
rect rgba(0, 200, 0, 0.05)
Note over G1: 쓰기 연산 α₁
Client->>G1: 쓰기 요청 (v₁)
G1->>G1: v₁ 저장
G1-->>Client: 쓰기 완료
end
G1-xG2: 메시지 손실 (v₁ 미전달)
rect rgba(255, 255, 0, 0.1)
Note over G1, G2: α₁ 이후 충분한 시간 간격 (α′₂)
end
rect rgba(0, 200, 0, 0.05)
Note over G2: 읽기 연산 α₂
Client->>G2: 읽기 요청
G2-->>Client: v₀ 반환 (최신 값 아님)
end
&lt;/pre>
&lt;ol>
&lt;li>G1에서 쓰기 연산 α₁이 발생하여 v₁을 저장&lt;/li>
&lt;li>G1과 G2 사이의 메시지는 손실됨&lt;/li>
&lt;li>α₁ 이후 충분한 시간 간격(α′₂)이 존재함&lt;/li>
&lt;li>G2에서 읽기 연산 α₂가 발생하지만, 여전히 v₀을 반환 (최신 값을 알 수 없음)&lt;/li>
&lt;li>G2는 가용성을 만족하기 위해 응답하지만, 일관성을 위반&lt;/li>
&lt;/ol>
&lt;p>이때 메시지가 손실된 경우, 읽기는 여전히 이전 값을 반환할 수밖에 없고, 이는 &lt;strong>일관성 위반&lt;/strong>이 됩니다.&lt;/p>
&lt;p>즉, 타임아웃을 통해 메시지 유실 여부를 추론할 수 있다 하더라도 CAP 세 가지를 동시에 만족시키는 것은 여전히 불가능하다는 점을 이 정리를 통해 강조합니다.&lt;/p>
&lt;h3 id="네트워크-안정-시-가능해지는-조건적-보장">네트워크 안정 시 가능해지는 조건적 보장&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>While it is not possible to implement an atomic read/write register in the partially synchronous model, if availability is required, it is still possible to implement such an object if atomicity is required only in executions in which all messages are delivered.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>부분 동기 모델에서도 모든 메시지가 전달되는 실행에 대해서는 atomic consistency를 만족할 수 있습니다.&lt;/strong>&lt;/p>
&lt;p>정리 2에서는 가용성과 일관성을 동시에 보장하는 것이 불가능하다고 했지만, &lt;strong>그 불가능은 모든 실행에 대해 동시에 만족시킬 수 없다는 의미&lt;/strong>입니다.&lt;/p>
&lt;p>만약 시스템이 &lt;strong>일관성을 제공해야 하는 상황을 &amp;ldquo;모든 메시지가 eventually 전달되는 실행&amp;quot;으로 한정&lt;/strong>한다면,그 범위 안에서는 atomicity를 구현하는 것이 가능합니다.&lt;/p>
&lt;p>논문에서는 중앙 집중형 알고리즘을 예로 들어 이 가능성을 설명합니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart TD
Client[클라이언트] --> A[로컬 노드 A]
A --> C[중앙 노드 C]
C --> A
A --> Client
C --> N1[다른 노드 1]
C --> N2[다른 노드 2]
C --> N3[다른 노드 3]
style C fill:#fdf6b2,stroke:#e0c000,stroke-width:2px
style A fill:#e0f7fa,stroke:#00acc1,stroke-width:1px
style Client fill:#eeeeee,stroke:#aaaaaa
&lt;/pre>
&lt;p>요청은 중앙 노드로 전달되고, 중앙 노드가 이를 직렬화하여 처리하는 구조로, 네트워크가 안정적이라면 모든 요청은 eventually 수락되고, 그 결과는 atomic하게 보장될 수 있습니다.&lt;/p>
&lt;p>이 조건부 보장은 완전한 불가능을 대체하지는 않지만, &lt;strong>현실적인 시스템 설계에서 atomicity를 제한적으로라도 달성할 수 있는 여지를 제공&lt;/strong>한다는 점에서 의미가 있습니다.&lt;/p>
&lt;h2 id="약한-일관성-조건">약한 일관성 조건&lt;/h2>
&lt;p>앞서 살펴본 바와 같이, 네트워크가 비동기적이거나 분할 상황이 존재한다면 원자적 일관성과 가용성, 분할 내성을 동시에 만족하는 것은 불가능합니다.&lt;/p>
&lt;p>이러한 제약을 인정하면서도 시스템이 제공하는 응답의 품질을 통제하기 위해, 논문은 이 섹션에서 &lt;strong>일관성을 약화시키되, 그 조건을 형식적으로 정의하는 모델&lt;/strong>을 제안합니다.&lt;/p>
&lt;p>이 모델은 Delayed-t Consistency라고 불리며, 약한 일관성 조건을 시간 기반으로 규정합니다.&lt;/p>
&lt;h3 id="완전한-일관성을-항상-보장할-수-없는-상황">완전한 일관성을 항상 보장할 수 없는 상황&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>While it is useful to guarantee that atomic data will be returned in executions in which all messages are delivered (within some time bound), it is equally important to specify what happens in executions in which some of the messages are lost.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>모든 메시지가 도달하는 경우만 고려해서는 충분하지 않으며, 메시지가 유실되는 실행에서는 어떤 값이 반환될 수 있는지도 명시해야 합니다.&lt;/strong>&lt;/p>
&lt;p>앞서 정리 1과 정리 2에서는, 비동기 및 부분 동기 네트워크 모델에서 atomic consistency와 availability를 동시에 만족할 수 없음을 보였습니다.&lt;/p>
&lt;p>그렇다고 해서 메시지가 유실되거나 지연되는 상황에서 시스템이 무조건 응답을 중단하거나, 무의미한 값을 반환하도록 내버려 둘 수는 없습니다.&lt;/p>
&lt;p>논문은 이 지점에서 **&amp;ldquo;약한 일관성 조건(weaker consistency conditions)&amp;rdquo;**이라는 방향을 제시합니다. 즉, 메시지 유실이 존재하는 환경에서도 &lt;strong>응답 값이 지켜야 할 최소한의 일관성 조건을 형식적으로 정의하는 방법&lt;/strong>을 제안하는 것입니다.&lt;/p>
&lt;h3 id="delayed-t-consistency란">Delayed-t Consistency란?&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>This consistency model ensures that if messages are delivered, then eventually some notion of atomicity is restored.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>일정 시간 동안 메시지가 안정적으로 전달된다면, 그 이후에는 atomic consistency가 다시 보장되어야 한다&lt;/strong>는 모델입니다.&lt;/p>
&lt;p>이 일관성 모델은 다음과 같은 전제를 가집니다.&lt;/p>
&lt;ul>
&lt;li>네트워크가 일시적으로 분할되거나 메시지가 손실될 수는 있지만,&lt;/li>
&lt;li>&lt;strong>일정 시간 t 이상 메시지 손실이 발생하지 않는 구간이 존재한다면&lt;/strong>,&lt;/li>
&lt;li>그 구간 이후부터는 시스템이 &lt;strong>다시 원자적(atomic)인 응답을 보장&lt;/strong>해야함&lt;/li>
&lt;/ul>
&lt;p>논문에서는 이를 &lt;strong>Delayed-t Consistency&lt;/strong>라고 정의하고, 그 조건을 만족하는 실행에 대해 어떤 순서 보장과 응답 품질이 필요한지를 형식적으로 정의합니다.&lt;/p>
&lt;p>이 모델은 완전한 atomic consistency를 제공하지는 않지만, &lt;strong>네트워크가 회복된 뒤 일정 시간이 지나면 다시 강한 일관성이 회복됨을 보장&lt;/strong>합니다.&lt;/p>
&lt;p>이는 eventually consistent 시스템보다 더 구체적이며, “언젠가 일관성이 회복된다”가 아니라 &amp;ldquo;&lt;strong>정해진 시간 이후에는 반드시 회복된다&lt;/strong>&amp;ldquo;는 점에서 의미 있는 차이가 있습니다.&lt;/p>
&lt;h3 id="definition-3-delayed-t-consistency의-형식적-정의">Definition 3: Delayed-t Consistency의 형식적 정의&lt;/h3>
&lt;blockquote>
&lt;p>*Definition 3: A timed execution, α, of a read-write object is Delayed-t Consistent if:&lt;/p>
&lt;ol>
&lt;li>P is a partial order that orders all write operations, and orders all read operations with respect to the write operations.&lt;/li>
&lt;li>The value returned by every read operation is exactly the one written by the previous write operation in P (or the initial value, if there is no such previous write in P).&lt;/li>
&lt;li>The order in P is consistent with the order of read and write requests submitted at each node.&lt;/li>
&lt;li>(Atomicity) If all messages in the execution are delivered, and an operation θ completes before an operation φ begins, then φ does not precede θ in the partial order P.&lt;/li>
&lt;li>(Weakly Consistent) Assume there exists an interval of time longer than t in which no messages are lost. Further, assume an operation, θ, completes before the interval begins, and another operation, φ, begins after the interval ends. Then φ does not precede θ in the partial order P.*&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>Delayed-t Consistency는 메시지 유실이 없는 일정 시간(t) 이후부터는 연산 순서가 atomic consistency에 부합하도록 제한되는 일관성 모델&lt;/strong>입니다.&lt;/p>
&lt;p>각 조건의 의미는 다음과 같습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>1. P는 모든 쓰기 연산을 순서화하고, 읽기 연산은 그에 대해 순서화되어야 한다.&lt;/strong>&lt;br>
→ 전체 실행을 정렬하는 하나의 순서가 있으며, 읽기/쓰기 간 순서 관계를 명확히 정의합니다.&lt;/p>
&lt;p>&lt;strong>2. 모든 읽기는 순서상 가장 가까운 직전 쓰기 값(또는 초기값)을 반환해야 한다.&lt;/strong>&lt;br>
→ 읽기가 이전 쓰기를 반드시 반영해야 함을 요구합니다.&lt;/p>
&lt;p>&lt;strong>3. 각 노드 내의 연산 순서는 부분 순서 P와 일치해야 한다.&lt;/strong>&lt;br>
→ 단일 노드 기준으로 볼 때, 로컬에서 일어난 순서는 전역 순서와 모순되지 않아야 합니다.&lt;/p>
&lt;p>&lt;strong>4. (Atomicity 조건)&lt;/strong>&lt;br>
→ 메시지가 유실되지 않은 실행에서, 어떤 연산 θ가 φ보다 먼저 끝났다면 φ는 절대 θ보다 앞선 순서에 위치할 수 없습니다. (순서가 뒤집히지 않아야 함)&lt;/p>
&lt;p>&lt;strong>5. (약한 일관성 조건)&lt;/strong>&lt;br>
→ 메시지 유실이 없는 구간이 t 이상 존재하고, 그 구간 이전에 끝난 연산 θ와 구간 이후 시작된 연산 φ가 있다면 φ는 θ보다 먼저 일어난 것처럼 간주되어서는 안 됩니다. 즉, &lt;strong>네트워크가 안정된 이후에는 순서를 지키라는 조건&lt;/strong>입니다.&lt;/p>
&lt;p>이 정의는 단순히 “eventually consistency”처럼 막연하게 일관성이 회복된다고 말하는 것이 아니라, &lt;strong>일관성 회복의 조건(시간, 순서, 메시지 전파 범위)을 명시적으로 제한&lt;/strong>하는 점에서 현실적인 구현 기준이 됩니다.&lt;/p>
&lt;h3 id="설계-가능성-중앙-집중형-알고리즘-설명">설계 가능성: 중앙 집중형 알고리즘 설명&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>A variant of the centralized algorithm described in Section 4.3 is Delayed-t consistent. Assume node C is the centralized node. The algorithm behaves as follows: &amp;hellip;&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>논문은 Definition 3을 만족하는 구조로 중앙 집중형 알고리즘의 변형을 제시합니다.&lt;/strong>&lt;/p>
&lt;p>이 알고리즘은 기존의 중앙 집중형 모델을 기반으로 하되, &lt;strong>시간 기반 메시지 처리&lt;/strong>와 &lt;strong>타임아웃에 따른 보조 흐름&lt;/strong>을 추가한 구조입니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">sequenceDiagram
participant Client
participant A as 로컬 노드 A
participant C as 중앙 노드 C
participant N1 as 다른 노드
%% 쓰기 요청 처리 흐름
Client->>A: 쓰기 요청 (v₁)
A->>C: 중앙 노드에 전달
C->>C: v₁ 저장, 시퀀스 번호 증가
C->>A: 응답
A->>Client: 쓰기 응답
C->>N1: v₁ 전파
%% 메시지 유실 시 타임아웃 처리
Note over C,N1: 메시지 손실 시 C는 일정 시간 내 재전송 시도
&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>쓰기 요청 처리&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>노드 A가 중앙 노드 C에 새로운 값을 보냄&lt;/li>
&lt;li>C는 시퀀스 번호를 증가시키고 값을 저장&lt;/li>
&lt;li>C는 모든 노드에 값을 전파&lt;/li>
&lt;li>메시지 유실이 의심되면 C는 t−2×timeout 시간 안에 재전송을 수행&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>읽기 요청 처리&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>노드 A는 C에 현재 값을 요청&lt;/li>
&lt;li>응답이 정상적으로 오면 그 값을 클라이언트에 전달&lt;/li>
&lt;li>응답이 없으면, 로컬에 저장된 가장 최신 값(또는 초기값)을 반환&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>이 구조는 메시지가 도달하지 않더라도 &lt;strong>가용성(응답)을 보장하면서&lt;/strong>, 네트워크가 안정된 이후에는 &lt;strong>atomic consistency로 회복되는&lt;/strong> 설계입니다.&lt;/p>
&lt;h3 id="theorem-4-이-알고리즘은-정의를-만족함">Theorem 4: 이 알고리즘은 정의를 만족함&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>Theorem 4: The modified centralized algorithm is Delayed-t consistent.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>앞서 설명한 중앙 집중형 알고리즘은 Delayed-t Consistency의 다섯 가지 조건을 모두 만족한다.&lt;/strong> 입니다.&lt;/p>
&lt;p>논문은 Definition 3에서 제시한 일관성 조건들을 하나씩 검토하며, 해당 알고리즘이 그것들을 모두 충족함을 논리적으로 설명합니다.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>부분 순서(P) 정의&lt;/strong>
&lt;ul>
&lt;li>중앙 노드 C가 모든 쓰기 요청에 시퀀스 번호를 부여하므로, 연산 간 전역 순서가 정해짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>읽기 연산은 이전 쓰기 값을 반환&lt;/strong>
&lt;ul>
&lt;li>각 읽기는 로컬 또는 중앙 노드로부터 가장 최근의 쓰기 값을 참조&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>로컬 순서와 부분 순서의 일치&lt;/strong>
&lt;ul>
&lt;li>각 노드는 자신의 연산 순서를 전역 순서와 동일하게 유지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>모든 메시지가 전달되는 실행에서 atomic consistency 보장&lt;/strong>
&lt;ul>
&lt;li>C가 직렬화하고 모든 노드에 전파하므로, 메시지 손실이 없는 경우에는 원자성을 만족&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>메시지 유실 없는 시간 구간 이후 순서 보장&lt;/strong>
&lt;ul>
&lt;li>일정 시간(t) 동안 모든 메시지가 전달되면, 그 이후 연산은 앞선 연산을 순서상 앞서지 않도록 설계&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>이로써 Delayed-t Consistency는 단순한 이론적 모델이 아니라, &lt;strong>구체적인 알고리즘을 통해 구현 가능하고 증명 가능한 약한 일관성 조건&lt;/strong>이라는 점이 논리적으로 뒷받침됩니다.&lt;/p>
&lt;h2 id="마무리">마무리&lt;/h2>
&lt;p>CAP 정리는 세 가지 특성을 모두 만족할 수 없다는 이야기로 자주 소개되지만, 이 논문을 통해 그 제약이 단순한 경험법칙이 아니라 모델과 조건이 주어졌을 때 논리적으로 증명 가능한 것임을 알 수 있었습니다. &lt;del>논문에서 논리로만 설명할 줄은 몰랐네요😂&lt;/del>&lt;/p>
&lt;p>정리에 따르면 비동기나 부분 동기 네트워크에서는 일관성과 가용성을 동시에 만족시키는 것이 원칙적으로 불가능하고, 이런 한계를 어떻게 받아들이고 설계할 것인지는 시스템마다 다를 수밖에 없다는 것을 강조하고 있습니다.&lt;/p>
&lt;p>논문에서 제시한 Delayed-t Consistency는 일관성을 완전히 포기하는 대신, 메시지 손실이 없는 구간 이후에는 다시 원자성을 회복할 수 있도록 제한하는 방식이 인상적이었습니다.&lt;/p>
&lt;p>정리하면서 CAP에 대해 그동안 놓치고 있었던 부분을 정리할 수 있어 좋았네요, 비슷한 고민을 하신 분께도 조금은 도움이 되었으면 합니다.&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다.😊&lt;/p></description></item><item><title>7. 호텔 예약 시스템</title><link>https://codemario318.github.io/post/system-design-interview-2/7/</link><pubDate>Sat, 12 Oct 2024 14:59:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/7/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/cover.png" alt="Featured image of post 7. 호텔 예약 시스템" />&lt;p>이번 장에서는 호텔 체인의 예약 시스템을 설계한다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>호텔 예약 시스템은 복잡하고 그 컴포넌트는 시스템을 사업에 어떻게 이용할지에 따라 달라지므로 범위를 명확히 해야한다.&lt;/p>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>높은 수준의 동시성 지원
&lt;ul>
&lt;li>성수기, 대규모 이벤트 기간에는 일부 인기 호텔의 특정 객실을 예약하려는 고객이 많이 몰릴 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>적절한 지연 시간
&lt;ul>
&lt;li>사용자가 예약을 할 때는 응답 시간이 빠르면 이상적이겠으나 &lt;strong>예약 요청 처리&lt;/strong>에 &lt;strong>몇 초 정도&lt;/strong> 걸리는 것은 괜찮다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;ul>
&lt;li>총 5,000개 호텔, 100만 개의 객실이 있다고 가정&lt;/li>
&lt;li>평균 &lt;strong>객실의 70%가 사용 중&lt;/strong>, 평균 &lt;strong>투숙 기간은 3일&lt;/strong>이라고 가정&lt;/li>
&lt;li>&lt;code>일일 예상 예약 건수 = (1백만 * 0.7) / 3 ~= 240,000&lt;/code>&lt;/li>
&lt;li>&lt;code>초당 예약 건수 = 240,000 / 하루에 10^5초 ~= 3&lt;/code>
&lt;ul>
&lt;li>초당 예약 트랜잭션 수(TPS)는 높지 않다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>시스템 내 모든 페이지의 QPS를 계산해본다.&lt;/p>
&lt;p>호텔 예약 시스템은 일반적으로 고객이 아래와 같은 흐름을 거친다.&lt;/p>
&lt;ol>
&lt;li>호텔/객실 상세 페이지
&lt;ul>
&lt;li>사용자가 호텔/객실 정보를 확인한다.(조회)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예약 상세 정보 페이지
&lt;ul>
&lt;li>날짜, 투숙 인원, 결제 방법 등의 상세 정보를 예약 전에 확인한다.(조회)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객실 예약 페이지
&lt;ul>
&lt;li>사용자가 &amp;lsquo;예약&amp;rsquo; 버튼을 눌러 객실을 예약한다.(트랜잭션 발생)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img.png"
width="1290"
height="630"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_hudca757551e48c8d1d2e333630b9f6cbe_51951_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_hudca757551e48c8d1d2e333630b9f6cbe_51951_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="QPS 분포"
class="gallery-image"
data-flex-grow="204"
data-flex-basis="491px"
>&lt;/p>
&lt;p>대략 10%의 사용자가 간 단계에서 다음 단계를 진행한다고 가정하면 최종 예약 TPS는 3이므로, 예약 페이지의 QPS는 30, 객실 정보 확인 페이지의 QPS는 300이다.&lt;/p>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="api-설계">API 설계&lt;/h3>
&lt;p>호텔 예약 시스템의 가장 중요한 API만 RESTful 관례에 따라 표현하면 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>검색 기능 등의 직관적인 기능도 필요하나, 기술적으로 도전적이지는 않다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>호텔 관련 API&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/hotels/id&lt;/td>
&lt;td>호텔의 상세 정보 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST /v1/hotels&lt;/td>
&lt;td>신규 호텔 추가(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PUT /v1/hotels/id&lt;/td>
&lt;td>호텔 정보 갱신(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE /v1/hotels/id&lt;/td>
&lt;td>호텔 정보 삭제(관리자)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>객실 관련 API&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/hotels/:id/rooms/id&lt;/td>
&lt;td>객실 상세 정보 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST /v1/hotels/:id/rooms&lt;/td>
&lt;td>신규 객실 추가(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PUT /v1/hotels/:id/rooms/id&lt;/td>
&lt;td>객실 정보 갱신(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE /v1/hotels/:id/rooms/id&lt;/td>
&lt;td>객실 정보 삭제(관리자)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>예약 관련 API&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/reservations&lt;/td>
&lt;td>로그인 사용자의 예약 이력 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GET /v1/reservations/id&lt;/td>
&lt;td>특정 예약의 상세 정보 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST /v1/reservations&lt;/td>
&lt;td>신규 예약&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE /v1/reservations/id&lt;/td>
&lt;td>예약 취소&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>신규 예약 접수는 아주 중요한 기능으로, 새 예약을 만들 때 전달하는 인자의 형태는 아래와 같은데&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;startDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-28&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;endDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-30&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;hotelID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;245&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;roomID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;U12354673389&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;reservationID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;13422445&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>researvationID&lt;/code>는 &lt;strong>이중 예약을 방지하고 동일한 예약은 단 한 번만 이루어지도록 보증하는 멱등 키(idempotent key)다.&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>멱등성?&lt;/strong>
연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질&lt;/p>
&lt;/blockquote>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>어떤 데이터베이스를 사용할지 결정하기위해 데이터 접근 패턴을 확인해야한다.&lt;/p>
&lt;ol>
&lt;li>호텔 상세 정보 확인&lt;/li>
&lt;li>지정된 날짜 범위에 사용 가능한 객실 유형 확인&lt;/li>
&lt;li>예약 정보 기록&lt;/li>
&lt;li>예약 내역 또는 과거 예약 이력 정보 조회&lt;/li>
&lt;/ol>
&lt;p>시스템 규모가 크지 않지만 대규모 이벤트 등으로 인해 트래픽이 급증할 수도 있으니 대비가 필요하다.&lt;/p>
&lt;p>이런 요구사항을 종합적으로 고려하였을 때 &lt;strong>관계형 데이터베이스&lt;/strong>가 적절해보인다.&lt;/p>
&lt;ul>
&lt;li>읽기 빈도가 쓰기 연산에 비해 높은 작업 흐름을 잘 지원한다.
&lt;ul>
&lt;li>읽기 반도가 압도적인 작업 흐름은 충분히 잘 지원한다.&lt;/li>
&lt;li>NoSQL 데이터베이스는 대체로 쓰기 연산에 최적화되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ACID 속성(원자성, 일관성, 격리성, 영속성)을 보장한다.
&lt;ul>
&lt;li>예약이라는 도메인 특성으로 인해 ACID 속성은 매우 중요하다.&lt;/li>
&lt;li>ACID를 보장하지 않으면 잔액 마이너스 문제, 이중 청구 문제, 이중 예약 문제 등을 방지하기 어렵다.&lt;/li>
&lt;li>ACID 속성이 충족되는 데이터베이스를 사용하면 코드는 단순해지고 이해하기 쉬워진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터를 쉽게 모델링 할 수 있다.
&lt;ul>
&lt;li>비즈니스 데이터의 구조를 명확하게 표현할 수 있을 뿐 아니라 엔티티 간의 간계를 안정적으로 지원할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_1.png"
width="1622"
height="1138"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_1_hude4e50a98d4fd9adb0d8d3f89cda06c5_259967_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_1_hude4e50a98d4fd9adb0d8d3f89cda06c5_259967_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터베이스 스키마"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="342px"
>&lt;/p>
&lt;p>&lt;code>reservation&lt;/code> 테이블의 &lt;code>status&lt;/code> 필드는 &lt;code>Pending&lt;/code>, &lt;code>Paid&lt;/code>, &lt;code>Refunded&lt;/code>, &lt;code>Canceled&lt;/code>, &lt;code>Rejected&lt;/code> 다섯 상태 가운데 하나를 값으로 가질 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_2.png"
width="1320"
height="630"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_2_hu654fdd7d1e7937dbeca03f4655f81aa1_21966_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_2_hu654fdd7d1e7937dbeca03f4655f81aa1_21966_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="예약 상태"
class="gallery-image"
data-flex-grow="209"
data-flex-basis="502px"
>&lt;/p>
&lt;p>이 스키마에서 &lt;code>room_id&lt;/code>는 에어비엔비 같은 회사에는 적합하나, 특정 호텔의 특정 객실 유형을 예약하는 호텔에는 적절하지 않을 수 있다.&lt;/p>
&lt;ul>
&lt;li>객실 번호는 예약할 때가 아닌, 투숙객이 체크인 하는 시점에 부여된다.&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>이번 호텔 예약 시스템에는 마이크로서비스 아키텍처를 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_3.png"
width="1946"
height="1100"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_3_hu282c3b24ada39ab6809ed01eac989c4e_87808_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_3_hu282c3b24ada39ab6809ed01eac989c4e_87808_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="176"
data-flex-basis="424px"
>&lt;/p>
&lt;p>마이크로 서비스 간 상호작용을 나타내는 화살표 상당수를 생략하였다.&lt;/p>
&lt;p>실제 상업적으로 이용되는 시스템의 서비스 간 통신에는 gRPC와 같은 고성능 원격 프로세서 호출 프레임워크를 사용하곤 한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>gRPC?&lt;/strong>&lt;br>
gRPC는 Google에서 개발한 고성능, 오픈 소스 원격 프로시저 호출(Remote Procedure Call, RPC) 프레임워크이다.
클라이언트와 서버 간에 원격 프로시저를 호출할 수 있게 해 주며, 마치 로컬에서 함수를 호출하는 것처럼 네트워크를 통해 다른 시스템의 메서드를 실행할 수 있다.
주로 프로토콜 버퍼(Protocol Buffers, protobuf)라는 직렬화 방식을 사용해 데이터를 효율적으로 전송하며, HTTP/2를 기반으로 동작해 성능과 확장성을 높인다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="개선된-데이터-모델">개선된 데이터 모델&lt;/h3>
&lt;p>호텔 객실을 예약할 때는 특정 객실이 아니라 특정한 객실 유형을 예약하게 된다.&lt;/p>
&lt;p>이러한 특성을 반영하기 위해 예약 API의 경우 호출 인자 가운데 &lt;code>roomID&lt;/code>는 &lt;code>roomTypeID&lt;/code>로 변경한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;startDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-28&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;endDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-30&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;hotelID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;245&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;roomTypeID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;U12354673389&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;reservationID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;13422445&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>스키마는 아래와 같이 변경된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_4.png"
width="1366"
height="1028"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_4_hu481f8e14d20d4e775dd6afb82166b25a_281965_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_4_hu481f8e14d20d4e775dd6afb82166b25a_281965_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="갱신된 스키마"
class="gallery-image"
data-flex-grow="132"
data-flex-basis="318px"
>&lt;/p>
&lt;p>주요 변경 사항은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>room&lt;/code>: 객실에 관계된 정보&lt;/li>
&lt;li>&lt;code>room_type_rate&lt;/code>: 특정 객실 유형의 특정 일자 요금 정보&lt;/li>
&lt;li>&lt;code>reservation&lt;/code>: 투숙객 예약 정보&lt;/li>
&lt;li>&lt;code>room_type_inventory&lt;/code>: 호텔의 모든 객실 유형
&lt;ul>
&lt;li>&lt;code>hotel_id&lt;/code>: 호텔 식별자&lt;/li>
&lt;li>&lt;code>room_type_id&lt;/code>: 객실 유형 식별자&lt;/li>
&lt;li>&lt;code>date&lt;/code>: 일자&lt;/li>
&lt;li>&lt;code>total_inventory&lt;/code>: 총 객실 수에서 일시적으로 제외한 객실 수를 뺀 값
&lt;ul>
&lt;li>유지 보수를 위해 예약 가능 목록에서 제외할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>total_reserved&lt;/code>: 저정된 hotel_id, room_type_id, date에 예약된 모든 객실의 수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>날짜당 하나의 레코드를 사용하면 날짜 범위 내에서 예약을 쉽게 관리하고 질의할 수 있다.&lt;/p>
&lt;p>이 테이블의 기본키는 &lt;code>(hotel_id, room_type_id, date)&lt;/code>의 복합키로, 2년 이내 모든 미래 날짜에 대한 가용 객실 데이터 질의 결과를 토대로 미리 채워 놓고, 시간이 흐름에 따라 새로 추가해야 하는 객실 정보는 매일 한 번씩 일괄 작업을 돌려 반영한다.&lt;/p>
&lt;hr>
&lt;p>5,000개의 호텔이 있고 각 호텔에는 20개의 객실 유형이 있으므로 테이블에 저장해야 하는 레코드의 수는 &lt;code>5,000 * 20 * 2년 * 365일 = 7,300만 개&lt;/code> 정도이다.&lt;/p>
&lt;p>많은 데이터가 아니므로 데이터베이스 하나면 저장하기 충분하지만, 하나만 둔다면 SPOF 문제를 피할 수 없게된다.&lt;/p>
&lt;p>고가용성을 달성하려면 여러 지역, 또는 가용성 구역에 데이터베이스를 복제해 두어야 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;code>room_type_inventory&lt;/code> 테이블은 고객이 특정 유형의 객실을 예약할 수 있는지 여부를 확인할 때 사용한다.&lt;/p>
&lt;ul>
&lt;li>입력
&lt;ul>
&lt;li>&lt;code>startDate&lt;/code>&lt;/li>
&lt;li>&lt;code>endDate&lt;/code>&lt;/li>
&lt;li>&lt;code>roomTypeId&lt;/code>&lt;/li>
&lt;li>&lt;code>hotelId&lt;/code>&lt;/li>
&lt;li>&lt;code>numberOfRoomsToReserve&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>출력
&lt;ul>
&lt;li>해당 유형의 객실에 여유가 있고 예약 가능한 상태라면 &lt;code>True&lt;/code>, 아니면 &lt;code>False&lt;/code>를 반환한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>SQL 관점에서 두 절차를 거친다.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>주어진 기간에 해당하는 레코드를 구한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">date&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_inventory&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_reserved&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">room_type_inventory&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">room_type_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">roomTypeId&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">hotel_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">hotelId&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BETWEEN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">startDate&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">endDate&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>반환한 각 레코드마다 다음 조건을 확인한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">if ((total_reserved + ${numberOfRoomsToReserve}) &amp;lt;= total_inventory)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>레코드의 모든 행을 검사한 결과 &lt;code>True&lt;/code>가 반환되면 주어진 기간 내 모든 날짜에 충분한 객실이 있다는 뜻 이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>예약 데이터가 단을 데이터베이스에 담기에 너무 크다면 다음과 같은 방안을 생각해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>현재 및 향후 예약 데이터만 저장한다.
&lt;ul>
&lt;li>예약 이력은 자주 접근하지 않으므로 아카이빙 하거나 냉동 저장소로 옮길 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터베이스를 샤딩한다.
&lt;ul>
&lt;li>자주 사용되는 질의는 &lt;strong>예약&lt;/strong> 및 &lt;strong>예약 확인&lt;/strong>이므로, 두 질의에서 모두 먼저 알아야하는 &lt;code>hotel_id&lt;/code>를 샤딩키로 사용한다.&lt;/li>
&lt;li>데이터는 &lt;code>hash(hotel_id) % number_of_service&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="동시성-문제">동시성 문제&lt;/h3>
&lt;p>또 하나의 중요한 문제는 &lt;strong>이중 예약 방지&lt;/strong>이며, 이를 위해 두가지 문제를 해결해야한다.&lt;/p>
&lt;ul>
&lt;li>같은 사용자가 예약 요청을 여러번 시도할 수 있다.&lt;/li>
&lt;li>여러 사용자가 같은 객실을 동시에 예약하려 할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="같은-사용자가-같은-예약-요청을-시도하는-경우">&lt;strong>같은 사용자가 같은 예약 요청을 시도하는 경우&lt;/strong>&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_5.png"
width="1508"
height="986"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_5_hueb9926d5bdf21d1ae178c13f6ba855ec_83059_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_5_hueb9926d5bdf21d1ae178c13f6ba855ec_83059_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="같은 고객의 이중 예약"
class="gallery-image"
data-flex-grow="152"
data-flex-basis="367px"
>&lt;/p>
&lt;p>이 문제를 푸는 일반적인 접근법으로는 다음 두가지가 있다.&lt;/p>
&lt;ul>
&lt;li>클라이언트 측 구현
&lt;ul>
&lt;li>요청 전송 후 예약 버튼을 비활성화 한다.
&lt;ul>
&lt;li>클라이언트에서 우회 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>멱등 API
&lt;ul>
&lt;li>예약 API 요청에 멱등 키를 추가하는 방안&lt;/li>
&lt;li>&lt;code>reservation_id&lt;/code>를 멱등 키로 사용하여 이중 예약 문제를 해결하는 방안이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_6.png"
width="1130"
height="1066"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_6_hu48c6b4b2100602be71a6178ae06987e2_69862_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_6_hu48c6b4b2100602be71a6178ae06987e2_69862_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="유일성 조건"
class="gallery-image"
data-flex-grow="106"
data-flex-basis="254px"
>&lt;/p>
&lt;ol>
&lt;li>예약 주문서를 만든다.&lt;/li>
&lt;li>고객이 검토할 수 있도록 예약 주문서를 반환한다.&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>반환 결과에 &lt;code>reservation_id&lt;/code>를 넣는다.(전역적 유일성을 보증하는 ID, 예제에서는의 예약 테이블의 기본키)&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>검토가 끝난 예약을 전송한다.
&lt;ul>
&lt;li>요청에 &lt;code>reservation_id&lt;/code>를 포함한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예약 완료 버튼을 한 번 더 눌러 보내도 &lt;code>reservation_id&lt;/code>가 예약 테이블의 기본 키 이므로 유일성 조건에 위반되어 처리되지 않는다.&lt;/li>
&lt;/ol>
&lt;h4 id="여러-사용자가-하나뿐인-객실을-동시에-예약하는-경우">&lt;strong>여러 사용자가 하나뿐인 객실을 동시에 예약하는 경우&lt;/strong>&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_7.png"
width="1438"
height="1262"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_7_hu8a18da16175039b3cfa48b49d042fdf5_80735_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_7_hu8a18da16175039b3cfa48b49d042fdf5_80735_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="경쟁 조건"
class="gallery-image"
data-flex-grow="113"
data-flex-basis="273px"
>&lt;/p>
&lt;p>이 문제를 해결하려면 어떤 형태로든 락을 활용해야 한다.&lt;/p>
&lt;p>&lt;strong>비관적 락&lt;/strong>&lt;/p>
&lt;p>비관적 락은 비관적 동시성 제어 방안이라고도 불리며, 사용자가 &lt;strong>레코드를 갱신하려고 하는 순간 즉시 락을 걸어 동시 업데이트를 방지하는 기술&lt;/strong>이다.&lt;/p>
&lt;p>따라서 해당 레코드를 갱신하려는 다른 사용자는 락 해제를 기다려야 한다.&lt;/p>
&lt;ul>
&lt;li>MySQL 같은 경우는 &lt;code>SELECT ... FOR UPDATE&lt;/code> 문을 실행하면 &lt;code>SELECT&lt;/code>가 반환한 레코드에 락이 걸린다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_8.png"
width="1994"
height="1320"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_8_hu40fa4d62dd848fb68c0b889e46e94f87_126013_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_8_hu40fa4d62dd848fb68c0b889e46e94f87_126013_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비관적 락"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="362px"
>&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>변경 중이거나 변경이 끝난 데이터를 갱신하는 일을 막을 수 있다.&lt;/li>
&lt;li>구현이 쉽고 모든 갱신 연산을 직렬화하여 충돌을 막는다.&lt;/li>
&lt;li>데이터에 대한 경합이 심할 때 유용하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>여러 레코드에 락을 걸면 교착 상태가 발생할 수 있다.
&lt;ul>
&lt;li>교착 상태가 발생하지 않는 코드 작성은 어렵다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장성이 낮다.&lt;/li>
&lt;li>트랜잭션이 너무 오랫동안 락을 해제하지 않고 있으면 다른 트랜잭션은 락이 걸린 자원에 접근할 수 없어 트랜잭션 수명이 길거나 많은 엔티티에 관련된 경우 성능에 심각한 영향을 끼친다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 이유로 비관적 락 메커니즘은 군장하지 않는다.&lt;/p>
&lt;p>&lt;strong>낙관적 락&lt;/strong>&lt;/p>
&lt;p>낙관적 락은 &lt;strong>낙관적 동시성 제어&lt;/strong>라고도 불리는 방안으로 &lt;strong>여러 사용자가 동시에 같은 자원을 갱신하려 시도하는 것을 허용&lt;/strong>한다.&lt;/p>
&lt;p>일반적으로 버전 번호(version_number)와 타임스탬프(timestamp) 두 가지 방법으로 구현한다.&lt;/p>
&lt;ul>
&lt;li>서버 시계는 시간이 지남에 따라 부정확해질 수 있으므로 일반적으로는 버전 번호를 더 나은 선택지로 본다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_9.png"
width="1938"
height="1142"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_9_hu9411dd474af31fd86c2a43d5119b3270_97882_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_9_hu9411dd474af31fd86c2a43d5119b3270_97882_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="낙관적 락"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="407px"
>&lt;/p>
&lt;p>낙관적 락은 데이터베이스에 직접 락을 걸지 않으므로 일반적으로 비관적 락 보다 빠르지만 동시성 수준이 아주 높으면 성능이 급격히 나빠진다.&lt;/p>
&lt;p>예를 들어 설명하면 잔여 객실 수를 읽을 수 있는 클라이언트 수에는 제한이 없으므로, 모든 클라이언트는 같은 잔여 객실 수와 같은 버전 정보를 취득하게 될 수 있기 때문에 모든 클라이언트는 같은 잔여 객실 수와 같은 버전 번호 정보를 취득한다.&lt;/p>
&lt;p>하지만 실제로 버전 번호 갱신에 성공하는 클라이언트는 하나이므로, 다른 모든 클라이언트는 버전 번호 검사에 실패하게된다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>애플리케이션이 유효하지 않은 데이터를 편집하는 일을 막는다.&lt;/li>
&lt;li>데이터베이스 자원에 락을 걸 필요가 없다.(데이터베이스 관점에서 락은 없다.) 책임은 애플리케이션에 있다.&lt;/li>
&lt;li>데이터에 대한 경쟁이 치열하지 않은 상황에 적합하다.
&lt;ul>
&lt;li>락을 관리하는 비용 없이 트랜잭션을 실행할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>데이터에 대한 경쟁이 치열한 상황에서는 성능이 좋지 못하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>낙관적 락은 예약 QPS가 일반적으로 높지 않은 호텔 예약 시스템에서는 적합한 선택지이다.&lt;/p>
&lt;p>&lt;strong>데이터베이스 제약 조건&lt;/strong>&lt;/p>
&lt;p>낙관적 락과 아주 유사하게 동작한다.&lt;/p>
&lt;p>&lt;code>room_type_inventory&lt;/code> 테이블에 다음 제약 조건을 추가한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CONSTRAINT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">check_room_count&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">CHECK&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">total_inventory&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_reserved&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_10.png"
width="1478"
height="1368"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_10_hu8a54ba9888669d6b439cae205e8f7b91_81051_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_10_hu8a54ba9888669d6b439cae205e8f7b91_81051_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 베이스 제약 조건"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="259px"
>&lt;/p>
&lt;p>사용자가 객실을 예약하려면 &lt;code>total_reserved&lt;/code>의 값이 101으로 제약 조건을 위반하게되어 롤백된다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>구현이 쉽다.&lt;/li>
&lt;li>데이터에 대한 경쟁이 심하지 않을 때 잘 동작한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>데이터에 대한 경쟁이 심하면 실패하는 연산 수가 매우 늘어날 수 있다.&lt;/li>
&lt;li>데이터베이스 제약 조건은 애플리케이션 코드와 달라서 버전을 통제하기 어렵다.&lt;/li>
&lt;li>제약 조건을 허용하지 않는 데이터베이스도 있으므로 마이그레이션 등에 문제가 될 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="시스템-규모-확장">시스템 규모 확장&lt;/h3>
&lt;p>일반적으로 호텔 예약 시스템에 대한 부하는 높지 않지만, 유명한 여행 예약 웹 사이트와 연동이 되어야한다면 QPS는 매우 늘어날 수 있다.&lt;/p>
&lt;p>시스템 부하가 높을 때는 무엇이 병목이 될 수 있는지 이해해야한다.&lt;/p>
&lt;ul>
&lt;li>해당 시스템의 모든 서비스는 무상태 서비스이므로 서버를 추가하는 것으로 성능 문제는 해결할 수 있다.&lt;/li>
&lt;li>데이터베이스는 단순히 데이터베이스 서버를 늘리는 것만으로는 성능 문제를 해결할 수 없다.&lt;/li>
&lt;/ul>
&lt;h4 id="데이터베이스-샤딩">데이터베이스 샤딩&lt;/h4>
&lt;p>데이터베이스를 여러 대 두고, 각각에 데이터의 일부만 보관하도록 하는 방식이다.&lt;/p>
&lt;p>데이터베이스를 샤딩할 때는 데이터를 어떻게 분배할 지 먼저 정한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>hotel_id&lt;/code>를 필터링 조건으로 사용하므로 샤딩 조건으로 쓰면 좋다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_11.png"
width="1964"
height="1122"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_11_hu98af43fce089f7bbf6f6bf1fb85b60d6_147947_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_11_hu98af43fce089f7bbf6f6bf1fb85b60d6_147947_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터베이스 샤딩"
class="gallery-image"
data-flex-grow="175"
data-flex-basis="420px"
>&lt;/p>
&lt;p>위는 16개 샤드로 분산하는 사례로, QPS가 30,000이라면 샤딩 후에는 1875QPS 정도로 한 대의 MySQL 서버로도 감당할 수 있는 부하가 된다.&lt;/p>
&lt;h4 id="캐시">캐시&lt;/h4>
&lt;p>호텔 잔여 객실 데이터는 현재와 미래의 데이터만 중요하다는 특성이 있다.&lt;/p>
&lt;p>따라서 데이터를 보관할 때 낡은 데이터는 자동적으로 소멸되도록 TTL을 설정할 수 있다면 바람직하다.&lt;/p>
&lt;ul>
&lt;li>이력 데이터는 다른 데이터베이스를 통해 질의하도록 하면 된다.&lt;/li>
&lt;/ul>
&lt;p>이런 상황에 레디스는 매우 적합하다.&lt;/p>
&lt;hr>
&lt;p>데이터 로딩 속도와 데이터베이스 확장성이 문제가 되기 시작하면 데이터베이스 앞에 캐시 계층을 두고 잔여 객실 확인 및 객실 예약 로직이 해당 계층에서 실행되도록 할 수 있다.&lt;/p>
&lt;p>요청의 일부만 잔여 객실 데이터베이스가 처리하고 나머지는 캐시가 담당하도록 한다.&lt;/p>
&lt;ul>
&lt;li>레디스 캐시 데이터에는 잔여 객실이 충분해 보여도 실제 데이터베이스를 다시 한번 확인해야한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_12.png"
width="1094"
height="682"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_12_hu5d3b54b38dcf02612143f1622e8a715a_133204_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_12_hu5d3b54b38dcf02612143f1622e8a715a_133204_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="캐시"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="384px"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>예약 서비스&lt;/strong>: 다음과 같은 잔여 객실 관리 API를 제공한다.&lt;/p>
&lt;ul>
&lt;li>지정된 호텔과 객실 유형, 주어진 날짜 범위에 이용 가능한 객실의 수를 질의&lt;/li>
&lt;li>객실을 예약하고 &lt;code>total_reserved&lt;/code>의 값을 1 증가&lt;/li>
&lt;li>고객이 예약을 취소하면 잔여 객실 수를 갱신&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>잔여 객실 캐시&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>모든 잔여 객실 관리에 필요한 질의는 레디스로 구현되는 잔여 객실 캐시로 옮긴다.&lt;/li>
&lt;li>따라서 사전에 잔여 객실 정보를 캐시에 미리 저장해두어야 한다.&lt;/li>
&lt;li>캐시에 저장되는 데이터 형식
&lt;ul>
&lt;li>키: &lt;code>hotelID_roomTypeId_{날짜}&lt;/code>&lt;/li>
&lt;li>값
&lt;ul>
&lt;li>주어진 호텔 ID&lt;/li>
&lt;li>객실 유형 ID&lt;/li>
&lt;li>날짜에 맞는 잔여 객실 수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>호텔 예약 시스템은 잔여 객실 확인 작업 때문에 읽기 연산 빈도가 쓰기 연산보다 훨씬 많으므로 대부분의 읽기 연산을 캐시로 처리하면 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>잔여 객실 데이터베이스&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>잔여 객실 수에 대한 가장 믿을 만한 정보가 보관되는 장소&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>캐시가 주는 새로운 과제&lt;/strong>&lt;/p>
&lt;p>캐시 계층을 추가하면 시스템의 확장성과 처리량은 대폭 증가하지만 데이터베이스와 캐시 사이의 데이터 일관성 유지에 관한 새로운 문제가 생긴다.&lt;/p>
&lt;p>사용자가 객실을 예약할 때 아무 문제가 없는 경우에는 다음 두 가지 작업이 이루어진다.&lt;/p>
&lt;ol>
&lt;li>잔여 객실 수를 질의하여 충분한지 확인(캐시)&lt;/li>
&lt;li>잔여 객실 데이터를 갱신
&lt;ul>
&lt;li>데이터베이스 갱신 이후 캐시 갱신&lt;/li>
&lt;li>비동기적으로 실행&lt;/li>
&lt;li>변경 데이터 감지(CDC) 매커니즘을 활용할 수 있다.
&lt;ul>
&lt;li>데이터베이스에서 발생한 변화를 감지하여 해당 변경 내역을 다른 시스템에 적용할 수 있도록 하는 매커니즘&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>잔여 객실 데이터에 대한 변화를 데이터베이스에 먼저 반영하므로 캐시에는 최신 데이터가 없을 가능성이 있다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>이러한 불일치 문제는 데이터베이스가 최종적으로 잔여 객실 확인을 하도록 한다면 문제가 되지는 않는다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>장점&lt;/p>
&lt;ul>
&lt;li>읽기 질의를 캐시가 처리하므로 데이터베이스의 부하가 크게 줄어든다.&lt;/li>
&lt;li>읽기 질의를 메모리에서 실행하므로 높은 성능을 보장할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>단점&lt;/p>
&lt;ul>
&lt;li>데이터베이스와 캐시 사이의 데이터 일관성을 유지하는 것은 어렵다.
&lt;ul>
&lt;li>데이터 불일치가 사용자 경험에 끼치는 영향을 신중하게 살펴야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="서비스-간-데이터-일관성">서비스 간 데이터 일관성&lt;/h3>
&lt;p>모노리스 아키텍처의 경우 데이터의 일광성을 보장하기 위해 관계형 데이터베이스를 공유하는 것이 보통이지만, 해당 시스템은 예약 테이블과 잔여 객실 테이블만 동일한 관계형 데이터베이스에 저장하는 MSA 하이브리드 접근법을 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_13.png"
width="1920"
height="514"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_13_huc5f5e8f7744db63fc867cea3c0d26387_55893_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_13_huc5f5e8f7744db63fc867cea3c0d26387_55893_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="모노리스 vs 마이크로서비스"
class="gallery-image"
data-flex-grow="373"
data-flex-basis="896px"
>&lt;/p>
&lt;p>이를 통해 관계형 데이터베이스의 ACID 속성을 활용하여 동시성 문제를 효과적으로 대응할 수 있지만, MSA 순수 주의자라면 마이크로 서비스가 독자적인 데이터베이스를 갖추고 있어야 한다고 주장할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_15.png"
width="1362"
height="1150"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_15_hu1651b063c3947755463e1494fe52dabe_39875_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_15_hu1651b063c3947755463e1494fe52dabe_39875_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="모노리스 아키텍처"
class="gallery-image"
data-flex-grow="118"
data-flex-basis="284px"
>&lt;/p>
&lt;p>모노리스 아키텍처는 하나의 데이터베이스만 사용하므로 여러 연산을 하나의 트랜잭션으로 묶어 ACID 속성이 만족되도록 보장할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_14.png"
width="1748"
height="1062"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_14_hu657f4a94828478d72376098f027fabfa_59765_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_14_hu657f4a94828478d72376098f027fabfa_59765_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="마이크로서비스 아키텍처"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="395px"
>&lt;/p>
&lt;p>하지만 서비스가 독자적인 데이터베이스를 갖도록 하면, 논리적으로는 하나의 원자적 연산이 여러 데이터베이스에 걸쳐 실행되는 일을 피할 수 없다.&lt;/p>
&lt;ul>
&lt;li>하나의 트랜잭션으로 데이터 일관성을 보증하는 기법을 사용할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>이러한 데이터 일관성 문제를 해결하기 위해 널리 사용되는 방법은 2가지 정도가 있다.&lt;/p>
&lt;ul>
&lt;li>2단계 커밋(2-phase commit, 2PC)
&lt;ul>
&lt;li>여러 노드에 걸친 원자적 트랜잭션 실행을 보증하는 데이터베이스 프로토콜&lt;/li>
&lt;li>모든 노드가 성공하든 아니면 실패하든 둘 중 하나로 트랜잭션이 마무리되도록 보증&lt;/li>
&lt;li>비중단 실행이 가능한 프로토콜이 아니므로 어느 한 노드에 장애가 발생하면 해당 장애가 복구될 때까지 진행이 중단된다.(성능이 뛰어난 프로토콜은 아니다.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사가(Saga)
&lt;ul>
&lt;li>각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮는다.&lt;/li>
&lt;li>각각의 트랜잭션은 완료되면 다음 트랜잭션을 시작하는 트리거로 쓰일 메시지를 만드러 보낸다.&lt;/li>
&lt;li>한 트랜잭션이라도 실패하면 그 이전 트랜잭션의 결과를 전부 되될리는 트랜잭션들을 순차적으로 실행한다.&lt;/li>
&lt;li>2pc는 여러 노드에 걸친 하나의 트랜잭션을 통해 ACID 속성을 만족시키는 개념이지만 사가는 각 단계가 하나의 트랜잭션이라서 결과적 일관성에 의존하는 것으로 본다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>마이크로서비스 간의 데이터 불일치를 해결하기 위해 사용되는 복잡한 매커니즘은 시스템 전체 설계의 복잡성을 크게 증가시킨다.&lt;br>
증가한 복잡성이 그만한 가치가 있는 지 결정하는 것은 설계자의 몫이다.&lt;/p>
&lt;ul>
&lt;li>이번 설계안은 그만한 가치는 없다고 판단하여 예약 및 잔여 객실 정보를 동일한 관계형 데이터베이스에 저장하는 좀 더 실용적인 접근 방법을 선택했다.&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;ul>
&lt;li>경쟁 조건이 발생할 수 있는 시나리오
&lt;ul>
&lt;li>비관적 락&lt;/li>
&lt;li>낙관적 락&lt;/li>
&lt;li>데이터베이스 제약 조건&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규모 확장
&lt;ul>
&lt;li>데이터베이스 샤딩&lt;/li>
&lt;li>레디스 캐시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>마이크로아키텍처의 데이터 일관성 문제&lt;/li>
&lt;/ul></description></item></channel></rss>