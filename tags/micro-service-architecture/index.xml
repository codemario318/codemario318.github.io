<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Micro Service Architecture on Mario Blog</title><link>https://codemario318.github.io/tags/micro-service-architecture/</link><description>Recent content in Micro Service Architecture on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Wed, 23 Oct 2024 13:53:50 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/micro-service-architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>8. 분산 메일 서비스</title><link>https://codemario318.github.io/post/system-design-interview-2/8/</link><pubDate>Wed, 23 Oct 2024 13:53:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/8/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/cover.png" alt="Featured image of post 8. 분산 메일 서비스" />&lt;p>이번 장에서는 지메일, 아웃룩 같은 대규모 이메일 서비스를 설계해본다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>현대적 이메일 서비스는 다양한 기능을 갖춘 복잡한 시스템으로 발전했다. 따라서 짧은시간에 설계는 불가능하므로 질문을 통해 설계 범위를 좁혀야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;del>인증&lt;/del>&lt;/li>
&lt;li>이메일 발송/수신&lt;/li>
&lt;li>모든 이메일 가져오기&lt;/li>
&lt;li>읽음 여부에 따른 이메일 필터링&lt;/li>
&lt;li>제목, 발신인, 메일 내용에 따른 검색 기능&lt;/li>
&lt;li>스팸 및 바이러스 방지 기능&lt;/li>
&lt;li>프로토콜
&lt;ul>
&lt;li>SMTP, POP, IMAP 등과 같은 서비스 제공자 전용 프로토콜이 있으나 HTTP 사용한다고 가정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부파일 지원&lt;/li>
&lt;/ul>
&lt;h3 id="비기능적-요구사항">비기능적 요구사항&lt;/h3>
&lt;ul>
&lt;li>안정성
&lt;ul>
&lt;li>이메일 데이터는 소실되어선 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성
&lt;ul>
&lt;li>이메일과 사용자 데이터를 여러 노드에 자동으로 복제하여 가용성을 보장해야한다.&lt;/li>
&lt;li>부분적으로 장애가 발생해도 시스템은 계속 동작해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확정성
&lt;ul>
&lt;li>사용자 수가 늘어나더라도 감당할 수 있어야 한다.&lt;/li>
&lt;li>사용자나 이메일이 많아져도 시스템 성능은 저하되지 않아야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유연성과 확장성
&lt;ul>
&lt;li>새 컴포넌트를 더하여 쉽게 기능을 추가하고 성능을 개선할 수 있는 유연하고 확장성 높은 시스템이어야 한다.&lt;/li>
&lt;li>POP나 IMAP 같은 기존 이메일 프로토콜은 기능이 매우 제한적이므로, 요구사항을 만족하기 위해 맞춤형 프로토콜이 필요할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적인-규모-추정">개략적인 규모 추정&lt;/h3>
&lt;ul>
&lt;li>10억 사용자&lt;/li>
&lt;li>한 사람이 하루에 보내는 평균 이메일 수는 10건 가정
&lt;ul>
&lt;li>&lt;code>QPS = 10^9 * 10 / 10^5 = 100,000&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>한 사람이 하루에 수신하는 이메일 수는 평균 40건 가정&lt;/li>
&lt;li>메일 하나의 메타데이터는 평균 50KB로 가정(첨부파일 X)&lt;/li>
&lt;li>메타데이터는 데이터베이스에 저장한다고 가정
&lt;ul>
&lt;li>1년간 메타데이터를 유지하기 위한 스토리지 요구사항은 &lt;code>10억 사용자 * 하루 40건 * 365일 * 50KB = 730PB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부 파일을 포함하는 이메일의 비율은 20%, 평균 크기는 50KB 가정
&lt;ul>
&lt;li>1년간 첨부 파일을 보관하는 데 필요한 저장 용량은 &lt;code>10억 사용자 * 하루 40건 * 365 * 20% * 500KB = 1,460PB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>많은 데이터를 처리해야하므로 분산 데이터베이스 솔루션이 필요하다.&lt;/p>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>이메일 서버에 대해 알아야 할 기본적인 사항과 더불어 서버가 시간이 흐름에 따라 어떻게 진화하는지 논의한다.&lt;/p>
&lt;p>그 후 분산 이메일 서버의 개략적인 설계안을 살펴본다.&lt;/p>
&lt;h3 id="이메일-101">이메일 101&lt;/h3>
&lt;p>이메일을 주고받는 프로토콜에는 대부분 POP, IMAP, SMTP 같은 프로토콜을 사용해왔다.&lt;/p>
&lt;h4 id="이메일-프로토콜">이메일 프로토콜&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>SMTP&lt;/strong>(Simple Mail Transfer Protocol)
&lt;ul>
&lt;li>이메일을 한 서버에서 다른 서버로 보내는 표준 프로토콜&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>POP&lt;/strong>(Post Office Protocol)
&lt;ul>
&lt;li>이메일을 가져오는 목적으로 널리 사용&lt;/li>
&lt;li>이메일 클라이언트가 원격 메일 서버에서 이메일을 수신하고 다운로드하기 위해 사용하는 표준 프로토콜&lt;/li>
&lt;li>단말로 다운로드된 이메일은 서버에서 삭제
&lt;ul>
&lt;li>결과적으로 한 대 단말에서만 이메일을 읽을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일을 확인하기 위해 전부 내려받아야 함
&lt;ul>
&lt;li>용량이 큰 첨부 파일이 붙은 이메일은 읽으려면 시간이 오래걸림&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>IMAP&lt;/strong>(Internet Mail Access Protocol)
&lt;ul>
&lt;li>이메일을 가져오는 목적으로 널리 사용&lt;/li>
&lt;li>POP과 달리 클리하지 않으면 메시지는 다운로드 되지 않으며, 메일 서버에서 지워지지도 않음
&lt;ul>
&lt;li>여러 단말에서 이메일을 읽을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개인 이메일 계정에서 가장 널리 사용되는 프로토콜&lt;/li>
&lt;li>이메일을 실제로 열기 전에는 헤더만 다운로드
&lt;ul>
&lt;li>인터넷 속도가 느려도 잘 동작함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>HTTPS&lt;/strong>
&lt;ul>
&lt;li>메일 전송 프로토콜은 아니지만 웹 기반 이메일 시스템의 메일함 접속에 이용될 수 있음&lt;/li>
&lt;li>ex) 아웃룩의 액티브 싱크&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="dns---도메인-이름-서비스">DNS - 도메인 이름 서비스&lt;/h4>
&lt;p>수신자 도메인의 메일 교환기 레코드(Mail Exchange, MX) 검색에 이용된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img.png"
width="1494"
height="546"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_hub7f0eb4bd2d0a33dfc88796a278dea75_678809_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_hub7f0eb4bd2d0a33dfc88796a278dea75_678809_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MX 레코드"
class="gallery-image"
data-flex-grow="273"
data-flex-basis="656px"
>&lt;/p>
&lt;ul>
&lt;li>숫자는 우선순위 값으로 선호도를 나타내어 값이 낮으면 높은 우선순위로 처리됨&lt;/li>
&lt;/ul>
&lt;h4 id="첨부-파일">첨부 파일&lt;/h4>
&lt;p>첨부 파일은 이메일 메시지와 함께 전송되며 일반적으로 Base64 인코딩을 활용한다.&lt;/p>
&lt;p>일반적으로 첨부 파일에는 크기 제한이 있고, 설정 가능한 수치로, 개인 계정이냐 기업 계정이냐에 따라 다르게 설정된다.(필요한 만큼 알아서 설정한다)&lt;/p>
&lt;ul>
&lt;li>아웃룩 20MB, 지메일 25MB&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>MIME&lt;/strong>( Multi-purpose Internet Mail Extension)&lt;br>
인터넷을 통해 첨부 파일을 전송할 수 있도록 하는 표준 규격&lt;/p>
&lt;/blockquote>
&lt;h4 id="전통적-메일-서버">전통적 메일 서버&lt;/h4>
&lt;p>분산 메일 서버에 알아보기 전 기존 메일 서버의 역사와 동작 방식에 대해 살펴본다.&lt;/p>
&lt;p>전통적인 메일 서버는 보통 &lt;strong>서버 한 대로 운용되는, 사용자가 많지 않을 때 잘 동작하는 시스템&lt;/strong>이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>전통적 메일 서버 아키텍처&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_1.png"
width="1166"
height="928"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_1_hu802478e41453ab6fdfaa430529afc2d8_190128_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_1_hu802478e41453ab6fdfaa430529afc2d8_190128_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="전통적 메일 서버"
class="gallery-image"
data-flex-grow="125"
data-flex-basis="301px"
>&lt;/p>
&lt;ol>
&lt;li>보내기 버튼을 누르면 메일 서버로 전송된다.(SMTP)&lt;/li>
&lt;li>메일 서버는 DNS 질의를 통해 수신 SMTP 서버를 찾고 해당 서버로 이메일을 보낸다(SMTP)&lt;/li>
&lt;li>메일을 수신한 서버는 이메일을 저장하고 수신자가 읽어갈 수 있도록 한다.&lt;/li>
&lt;li>수신자가 로그인하면 IMAP/POP 서버를 통해 새 이메일을 가져온다.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>&lt;strong>저장소&lt;/strong>&lt;/p>
&lt;p>전통적 메일 서버는 &lt;strong>이메일을 파일 시스템의 디렉터리에 저장&lt;/strong>한다.&lt;/p>
&lt;p>각각의 이메일은 고유한 이름을 가진 별도 파일로 보관도며, 각 사용자의 설정 데이터와 메일함은 사용자 디렉터리에 보관한다.&lt;/p>
&lt;ul>
&lt;li>이러한 디렉터리 구조를 &lt;strong>Maildir&lt;/strong> 이라고 함&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_2.png"
width="920"
height="1166"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_2_hu2474c31464cc06986e6e832f2b67e40e_32499_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_2_hu2474c31464cc06986e6e832f2b67e40e_32499_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Maildir"
class="gallery-image"
data-flex-grow="78"
data-flex-basis="189px"
>&lt;/p>
&lt;p>파일과 디렉터리를 활용하는 방안은 사용자가 많지 않을 때는 잘 동작하나 디스크 I/O로 인한 병목으로 인해 수십억 개의 이메일을 검색하고 백업하는 목적으로 활용하기에는 곤란했다.&lt;/p>
&lt;p>그리고 &lt;strong>이메일을 서버의 파일 시스템에 보관&lt;/strong>하였기 때문에 &lt;strong>가용성과 안정성&lt;/strong> 요구사항도 만족할 수 없었기 때문에 더 안정적인 분산 데이터 저장소 계층이 필요했다.&lt;/p>
&lt;ul>
&lt;li>디스크 손상, 서버 장애 등&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이메일 기능은 1960년대에 발명된 이래로 텍스트 중심에서 멀티미디어, 메일 스레드, 검색, 레이블 등 다양한 기능을 지원하도록 발전해 왔지만, POP, IMAP, SMTP 같은 이메일 프로토콜은 이러한 기능을 지원하도록 설계되지 않았기 때문에 확장할 수 없었다.&lt;/p>
&lt;h3 id="분산-메일-서버">분산 메일 서버&lt;/h3>
&lt;p>분산 메일 서버는 현대적 사용 패턴을 지원하고 확장성과 안정성 문제를 해결한다.&lt;/p>
&lt;h4 id="이메일-api">이메일 API&lt;/h4>
&lt;p>이메일 API의 의미는 메일 클라이언트, 이메일 생명주기 단계마다 달라질 수 있다.&lt;/p>
&lt;ul>
&lt;li>모바일 단말 클라이언트를 위한 SMTP/POP/IMAP API&lt;/li>
&lt;li>송신 측 메일 서버와 수신 측 메일 서버 간의 SMTP 통신&lt;/li>
&lt;li>대화형 웹 기반 이메일 애플리케이션을 위한 HTTP 기반 RESTful API&lt;/li>
&lt;/ul>
&lt;p>이 책에서는 가장 중요한 API만 다루며, 웹메일 통신에는 일반적으로 HTTP 프로토콜이 쓰인다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>POST /v1/messages&lt;/code>&lt;/strong>&lt;/p>
&lt;p>To, Tc, Bcc 헤더에 명시된 수신자에게 메시지를 전송한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/folders&lt;/code>&lt;/strong>&lt;/p>
&lt;p>주어진 이메일 계정에 존재하는 모든 폴더를 반환한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">[{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;id&amp;#34;: string,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;name&amp;#34;: string,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;user_id&amp;#34;: string
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/folders/{:folder_id}/messages&lt;/code>&lt;/strong>&lt;/p>
&lt;p>주어진 폴더 아래의 모든 메시지를 반환한다.&lt;/p>
&lt;ul>
&lt;li>단순화한 명세로 페이지네이션을 지원해야 하는 등 훨씬 복잡할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/messages/{:message_id}&lt;/code>&lt;/strong>&lt;/p>
&lt;p>주어진 특정 메시지에 대한 모든 정보를 반환한다.&lt;/p>
&lt;p>메시지는 이메일 애플리케이션의 핵심 구성 요소이다.&lt;/p>
&lt;ul>
&lt;li>발신자, 수신자, 메시지 제목, 본문, 첨부 파일 등의 정보로 구성&lt;/li>
&lt;/ul>
&lt;h4 id="분산-메일-서버-아키텍처">분산 메일 서버 아키텍처&lt;/h4>
&lt;p>전통적인 이메일 서버가 단일 장비 위에서만 동작하도록 설계되었기 때문에 한 대 이상의 서버로 규모를 늘리는 것은 까다롭다.&lt;/p>
&lt;ul>
&lt;li>여러 서버 사이에 데이터를 동기화하는 것은 어려운 작업이다.&lt;/li>
&lt;li>수신자 메일 서버에서 이메일이 스팸으로 잘못 분류되지 않도록 하려면 까다로운 문제들을 풀어야한다.&lt;/li>
&lt;/ul>
&lt;p>이번 절에서는 클라우드 기술을 활용하여 이러한 문제를 쉽게 푸는 방법을 알아본다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_3.png"
width="1328"
height="1040"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_3_hu97293f0920808d780af3a4f7f2404b28_190471_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_3_hu97293f0920808d780af3a4f7f2404b28_190471_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="127"
data-flex-basis="306px"
>&lt;/p>
&lt;ul>
&lt;li>웹메일
&lt;ul>
&lt;li>사용자는 웹브라우저를 사용해 메일을 받고 보냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹서버
&lt;ul>
&lt;li>사용자가 이용하는 요청/응답 서비스로, 로그인, 가입, 사용자 프로파일 등에 대한 관리 기능을 담당&lt;/li>
&lt;li>본 설계안에서는 이메일 발송, 폴더 목록 확인, 폴더 내 모든 메시지 확인 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>실시간 서버
&lt;ul>
&lt;li>새로운 이메일 내역을 클라이언트에 실시간으로 전달한다.&lt;/li>
&lt;li>지속성 연결을 맺고 유지해야하므로 상태 유지 서버다.
&lt;ul>
&lt;li>롱폴링, 웹소켓 등&lt;/li>
&lt;li>웹소켓이 좀 더 우아하지만 브라우저 호환성 문제가 있을 수 있다.&lt;/li>
&lt;li>기본적으로는 웹 소켓을 쓰되 여의치 않으면 롱 폴링을 백업으로 이용할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 데이터베이스
&lt;ul>
&lt;li>이메일 제목, 본문, 발신인, 수신인 목록 등 메타 데이터를 저장하는 데이터베이스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부 파일 저장소
&lt;ul>
&lt;li>아마존 S3(Simple Storage Service) 같은 객체 저장소를 사용할 것이다.
&lt;ul>
&lt;li>이미지나 동영상 등의 대용량 파일을 저장하는 데 적합하고 확장이 용이한 인프라이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부파일 크기는 25MB로 제한한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>분산 캐시
&lt;ul>
&lt;li>최근에 수신된 이메일은 자주 읽을 가능성이 높으므로 클라이언트로 하여금 메모리에 캐시해 두도록 하면 메일을 표시하는 시간을 많이 줄일 수 있다.&lt;/li>
&lt;li>레디스
&lt;ul>
&lt;li>리스트와 같은 다양한 기능을 제공하고, 규모 확장이 용이하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>검색 저장소
&lt;ul>
&lt;li>검색 저장소는 분산 문서 저장소이다.&lt;/li>
&lt;li>고속 텍스트 검색을 지원하는 &lt;strong>역 인덱스&lt;/strong>를 자료 구조로 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>카산드라가 첨부 파일 저장소로 적합하지 않은 이유&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>카산드라가 BLOB 자료형을 지원하고 해당 자료형이 지원하는 데이터의 최대 크기가 2GB이긴 하지만 실질적으로는 1MB 이상의 파일은 지원하지 못한다.&lt;/li>
&lt;li>카산드라에 첨부 파일을 저장하면 첨부 파일이 너무 많은 메모리를 사용하게되어 레코드 캐시를 사용하기 어렵다.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="이메일-전송-절차">이메일 전송 절차&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_4.png"
width="1698"
height="1126"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_4_hu6c1accd62c346f29cf05623f72575dc4_306833_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_4_hu6c1accd62c346f29cf05623f72575dc4_306833_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이메일 전송 절차"
class="gallery-image"
data-flex-grow="150"
data-flex-basis="361px"
>&lt;/p>
&lt;ol>
&lt;li>사용자가 웹에서 메일을 정송하면 요청은 로드밸런서로 전송된다.&lt;/li>
&lt;li>로드벨런서가 처리율 제한 한도를 넘지 않는 선에서 요청을 웹 서버로 전달한다.&lt;/li>
&lt;li>웹 서버는 다음 역할을 담당한다.
&lt;ul>
&lt;li>기본적인 이메일 검증
&lt;ul>
&lt;li>이메일 크기 한도 같은 사전 미리 정의된 규칙을 사용하여 수신된 이메일을 검사한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>수신자 이메일 주소 도메인이 송신자 이메일 주소 도메인과 같은지 검사
&lt;ul>
&lt;li>이메일 내용의 스팸 여부와 바이러스 감염 여부를 검사&lt;/li>
&lt;li>검사를 통과한 이메일은 송신인의 보낸 편지함과 수신인의 받은 편지함에 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>수신인 측 클라이언트는 RESTful API를 사용하여 이메일을 바로 가져올 수 있어 4단계 이후는 수행할 필요가 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 큐
&lt;ol>
&lt;li>기본적인 검증을 통과한 이메일은 외부 전송 큐로 전달된다.
&lt;ul>
&lt;li>&lt;strong>첨부 파일의 크기가 너무 큰 이메일&lt;/strong>의 경우 &lt;strong>첨부 파일을 객체 저장소에 따로 저장&lt;/strong>하고 해당 &lt;strong>저장 위치에 대한 참조 정보만 저장&lt;/strong>한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>기본적인 검증에 실패한 이메일은 에러 큐에 보관한다.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>외부 전송 담당 SMTP 작엄 프로세스는 외부 전송 큐에서 메시지를 꺼내어 이메일의 스팸 및 바이러스 감염 여부를 확인한다.&lt;/li>
&lt;li>검증 절차를 통과한 이메일은 저장소 계층 내의 보낸 편지함에 저장된다.&lt;/li>
&lt;li>외부 전송 담당 SMTP 작업 프로세스가 수신자의 메일 서버로 메일을 전송한다.&lt;/li>
&lt;/ol>
&lt;p>외부 전송 큐에 보관되는 모든 메시지에는 &lt;strong>이메일을 생성하는 데 필요한 모든 메타데이터가 포함&lt;/strong>되어 있다.&lt;/p>
&lt;p>&lt;strong>분산 메시지 큐&lt;/strong>는 비동기적 메일 처리를 가능케 하는 핵심적 컴포넌트이다.&lt;/p>
&lt;ul>
&lt;li>웹 서버에서 외부 전송 담당 SMTP 프로세스를 분리함으로 전송용 SMTP 프로세스의 규모를 독립적으로 조정할 수 있게 된다.&lt;/li>
&lt;/ul>
&lt;p>외부 전송 큐의 크기를 모니터링 할 때 메일이 처리되지 않고 큐에 오랫동안 남아 있으면 그 이유를 분석해야한다.&lt;/p>
&lt;ul>
&lt;li>수신자 측 메일 서버에 장애 발생
&lt;ul>
&lt;li>나중에 메일을 다시 전송해야 한다.&lt;/li>
&lt;li>ex) 지수적 백오프(Exponential Backoff)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일을 보낼 큐의 소비자 수가 불충분
&lt;ul>
&lt;li>더 많은 소비자를 추가하여 처리 시간을 단축하는 방법을 생각해 볼 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="이메일-수신-절차">이메일 수신 절차&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_5.png"
width="1824"
height="946"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_5_hufa935ff62aaff4ec9a22919e7479ce7e_259381_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_5_hufa935ff62aaff4ec9a22919e7479ce7e_259381_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이메일 수신 절차"
class="gallery-image"
data-flex-grow="192"
data-flex-basis="462px"
>&lt;/p>
&lt;ol>
&lt;li>이메일이 SMTP 로드밸런서에 도착&lt;/li>
&lt;li>트래픽을 여러 SMTP 서버로 분산
&lt;ul>
&lt;li>SMTP 연결에는 이메일 수락 정책을 구성하여 적용 가능&lt;/li>
&lt;li>유효하지 않은 이메일은 방송하도록 하여 불필요한 이메일 처리를 피할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일의 첨부 파일이 큐에 들어가기 너무 큰 경우 첨부 파일 저장소(S3)에 보관&lt;/li>
&lt;li>이메일을 수신 이메일 큐에 넣는다
&lt;ul>
&lt;li>메일 처리 작업 프로세스와 SMTP 간 결합도를 낮추어 각자 독립적으로 규모 확장이 가능하도록 함&lt;/li>
&lt;li>수신 이메일이 폭증하는 경우 버퍼 역할도 하게됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메일 처리 작업 프로세스(worker)는 스팸 메일을 걸러내고 바이러스를 차단하는 등의 다양한 역할 담당
&lt;ul>
&lt;li>이후 처리는 검증 작업이 끝난 이메일을 대상으로 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일을 메일 저장소, 캐시, 객체 저장소 등에 보관&lt;/li>
&lt;li>수신자가 온라인 상태일 경우 실시간 서버로 전달&lt;/li>
&lt;li>실시간 서버는 수신자 클라이언트가 새 이메일을 실시간으로 받을 수 있도록 하는 웹소켓 서버&lt;/li>
&lt;li>오프라인 상태 사용자의 이메일은 저장소 계층에 보관
&lt;ul>
&lt;li>온라인 상태가 되면 클라이언트가 웹 서버에 RESTful API를 통해 열결됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>새로운 이메일을 저장소 계층에서 가져와 클라이언트에 반환&lt;/li>
&lt;/ol>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>몇 가지 핵심 요소에 대해 더 자세히 알아보고 규모 확장 방안을 점검한다.&lt;/p>
&lt;h3 id="메타데이터-데이터베이스">메타데이터 데이터베이스&lt;/h3>
&lt;p>이메일 메타데이터의 특성을 알아보고 올바른 데이터베이스와 데이터 모델을 고르는 문제, 이메일 스레드 지원 방안에 대해 알아본다.&lt;/p>
&lt;h4 id="이메일-메타데이터의-특성">이메일 메타데이터의 특성&lt;/h4>
&lt;ul>
&lt;li>이메일의 헤더는 일반적으로 작고, 빈번하게 이용&lt;/li>
&lt;li>이메일 본문의 크기는 다양하지만 사용 빈도는 낮음
&lt;ul>
&lt;li>일반적으로 한 번만 읽음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일 가져오기, 읽은 메일로 표시, 검색 등의 이메일 관련 작업은 사용자 별로 격리 수행되어야함
&lt;ul>
&lt;li>어떤 사용자의 이메일은 해당 사용자만 읽을 수 있어야함&lt;/li>
&lt;li>이메일에 대한 작업도 그 사용자만이 수행할 수 있어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 신선도는 데이터 사용 패턴에 영향을 미침
&lt;ul>
&lt;li>사용자는 보통 최근 메일만 읽음&lt;/li>
&lt;li>만들어진 지 16일 이하에 발생하는 읽기 질의 비율은 전체 질의의 82%에 달함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터의 높은 안정성이 보장되어야 함
&lt;ul>
&lt;li>&lt;strong>데이터 손실은 용납되지 않음&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="올바른-데이터베이스의-선정">올바른 데이터베이스의 선정&lt;/h4>
&lt;p>지메일이나 아웃룩 정도의 규모가 되면 시스템의 부하로 인해, 초당 입/출력 연산 빈도(Input/Output Operations Per Second, IOPS)를 낮추기 위한 맞춤 제장 데이터베이스를 사용한다.&lt;/p>
&lt;p>올바른 데이터베이스 선택은 쉽지 않은데, 가능한 모든 선택지를 미리 살펴보면 도움이 된다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>관계형 데이터베이스&lt;/strong>&lt;/p>
&lt;p>관계형 데이터베이스를 고르는 주된 동기는 이메일을 효율적으로 검색할 수 있다는 장점 때문이다.&lt;/p>
&lt;ul>
&lt;li>이메일 헤더와 본문에 대한 인덱스를 만들면 효율적으로 검색할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>하지만 관계형 데이터베이스는 데이터 크기가 작을 때 적합하다.&lt;/p>
&lt;ul>
&lt;li>이메일은 수 KB보다 크고 HTML이 포함되면 쉽게 100KB를 넘어간다.&lt;/li>
&lt;li>BLOB 자료형을 쓰면 큰 이메일도 처리할 수 있으나, 비정형 BLOB에 대한 검색 질의 성능은 좋지 않다.
&lt;ul>
&lt;li>BLOB이 고정된 크기 페이지를 연결하여 큰 데이터를 저장하도록 하고 있어 해당 컬럼의 데이터를 접근할 때마다 많은 디스크 I/O가 발생한다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>따라서 관계형 데이터베이스는 바람직하지 않다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>분산 객체 저장소&lt;/strong>&lt;/p>
&lt;p>이메일의 원시 데이터를 그대로 아마존 S3 같은 객체 저장소에 보관하는 방법도 고려할 수 있다.&lt;/p>
&lt;p>하지만 객체 저장소는 백업 데이터를 보관하기에는 좋지만 이메일의 읽음 표시, 키워드 검색, 이메일 스레드 드의 기능을 구현하기에 그다지 좋지 않다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>NoSQL 데이터베이스&lt;/strong>&lt;/p>
&lt;p>지메일은 구글 빅테이블을 저장소로 사용하는데 충분히 실현 가능한 방안이다.&lt;/p>
&lt;p>하지만 빅테이블은 오픈소스로 공개되어 있지 않고 이메일 검색을 빅테이블 위에서 어떻게 구현했는지는 공개되어있지않다.&lt;/p>
&lt;p>카산드라가 좋은 대안이 될 수도 있지만 대형 이메일 서비스 제공 업체 가운데 카산드라를 사용하는 곳은 아직 확인된 바가 없다.&lt;/p>
&lt;hr>
&lt;p>위 후보들을 봤을 때 본 설계안이 필요로 하는 기능을 완벽히 지원하는 데이터베이스는 없다고 봐도 좋을 것 같다.&lt;/p>
&lt;p>이러한 이유로 대형 이메일 서버스 업체는 대체로 독자적인 데이터베이스 시스템을 만들어 사용한다.&lt;/p>
&lt;p>이러한 데이터베이스를 설계하기엔 시간이 부족하므로, 해당 데이터베이스가 아래와 같은 조건을 충족해야 한다는 점을 설명할 수 있어야한다.&lt;/p>
&lt;ul>
&lt;li>어떤 단일 컬럼의 크기는 한 자리수의 MB 정도일 수 있다.&lt;/li>
&lt;li>강력한 데이터 일관성이 보장되어야 한다.&lt;/li>
&lt;li>디스크 I/O가 최소화되도록 설계되어야 한다.&lt;/li>
&lt;li>가용성이 아주 높아야 하고 일부 장애를 감내할 수 있어야 한다.&lt;/li>
&lt;li>증분 백업(incremental backup)이 쉬워야 한다.&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-모델">데이터 모델&lt;/h4>
&lt;p>데이터를 저장하는 한 가지 방법은 &lt;code>user_id&lt;/code>를 파티션 키로 사용하여 특정한 사용자의 데이터는 항상 같은 샤드에 보관하는 것이다.&lt;/p>
&lt;ul>
&lt;li>메시지를 여러 사용자와 공유할 수 없지만 요구사항과는 관계 없다.&lt;/li>
&lt;/ul>
&lt;p>기본 키는 파티션 키(partition key)와 클러스터 키(clustering key)의 두 가지 부분으로 구성된다.&lt;/p>
&lt;ul>
&lt;li>파티션 키
&lt;ul>
&lt;li>데이터를 여러 노드에 분산하는 기준&lt;/li>
&lt;li>데이터가 모든 노드에 균등하게 분산되도록 하는 파티션 키를 골라야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클러스터 키
&lt;ul>
&lt;li>파티션에 속한 데이터를 정렬하는 기준&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>개략적으로 이메일 서비스의 데이터 계층은 다음과 같은 질의를 지원해야 한다.&lt;/p>
&lt;ul>
&lt;li>주어진 사용자의 모든 폴더를 구한다.&lt;/li>
&lt;li>특정 폴더 내의 모든 이메일을 표시한다.&lt;/li>
&lt;li>메일을 생성, 삭제, 조회한다.&lt;/li>
&lt;li>읽은 메일 전부, 또는 읽지 않은 메일 전부를 가져온다.&lt;/li>
&lt;li>이메일 스레드를 전부 가져온다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_6.png"
width="856"
height="518"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_6_hu00ad76f03bcbd533c2a84dbc6e348eb4_89085_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_6_hu00ad76f03bcbd533c2a84dbc6e348eb4_89085_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="키 구성"
class="gallery-image"
data-flex-grow="165"
data-flex-basis="396px"
>&lt;/p>
&lt;p>&lt;strong>질의 1: 특정 사용자의 모든 폴더 질의&lt;/strong>&lt;/p>
&lt;p>파티션 키는 &lt;code>user_id&lt;/code>다. 따라서 어떤 사용자의 모든 폴더는 같은 파티션 안에 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_7.png"
width="872"
height="544"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_7_hu156bc7a2fc679faefe0f0978519d3cb5_79626_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_7_hu156bc7a2fc679faefe0f0978519d3cb5_79626_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="사용자 별 폴더 목록"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="384px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>질의 2: 특정 폴더에 속한 모든 이메일 표시&lt;/strong>&lt;/p>
&lt;p>사용자가 자기 메일 폴더를 열면 이메일은 가장 최근 이메일부터 오래된 것 순으로 정렬되어 표시된다.&lt;/p>
&lt;p>같은 폴더에 속한 모든 이메일이 같은 파티션에 속하도록 하려면 &lt;code>&amp;lt;user_id, foler_id&amp;gt;&lt;/code> 형태의 복합 파티션 키를 사용해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_9.png"
width="876"
height="982"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_9_hu41305bc042d3fec07ebe69ff8294aa6a_136085_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_9_hu41305bc042d3fec07ebe69ff8294aa6a_136085_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="폴더별 이메일"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="214px"
>&lt;/p>
&lt;p>&lt;code>email_id&lt;/code>의 자료형은 &lt;code>TIMEUUID&lt;/code>로 이메일을 시간순으로 정렬하는 데 사용되는 클러스터 키다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>질의 3: 이메일 생성/삭제/수신&lt;/strong>&lt;/p>
&lt;p>이메일 상세 정로를 가져오는 방법을 살펴본다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">emails_by_user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">email_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">123&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이 질의를 지원하기 위해 두 테이블이 필요하다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_10.png"
width="1328"
height="642"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_10_hucad2710252b37d32d309b4b9de9854c5_132150_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_10_hucad2710252b37d32d309b4b9de9854c5_132150_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="사용자별 이메일"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="496px"
>&lt;/p>
&lt;p>한 이메일에는 여러 첨부 파일이 있을 수 있으므로, &lt;code>email_id&lt;/code>, &lt;code>filename&lt;/code> 필드를 같이 사용하면 모든 첨부 파일을 질의할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>질의 4: 읽은, 또는 읽지 않은 모든 메일&lt;/strong>&lt;/p>
&lt;p>관계형 데이터베이스로 도메인 모델을 구현하는 경우, 읽은 메일 전부는 다음과 같이 질의할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">emails_by_folder&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">is_read&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">email_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>본 설계안의 데이터모델은 NoSQL로 보통 파티션 키와 클러스터 키에 대한 질의만 허용하므로 &lt;code>emails_by_folder&lt;/code> 테이블의 &lt;code>is_read&lt;/code> 필드는 이에 해당하지 않기 때문에 대부분의 NoSQL 데이터베이스에서는 위 쿼리를 실행할 수 없다.&lt;/p>
&lt;p>이 문제를 해결하기 위한 방법으로 &lt;strong>주어진 폴더에 속한 모든 메시지를 가져온 다음 애플리케이션 단에서 필터링&lt;/strong> 해줄 수 있다.&lt;/p>
&lt;ul>
&lt;li>대규모 서비스에는 적합하지 않다.&lt;/li>
&lt;/ul>
&lt;p>따라서 이런 문데는 NoSQL 데이터베이스 테이블을 비정규화(denormalization)하여 해결하는 것이 보통이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>emails_by_folder&lt;/code> 테이블을 두 테이블로 분할한다.&lt;/li>
&lt;li>&lt;code>read_emails&lt;/code>: 읽은 상태의 모든 이메일을 보관&lt;/li>
&lt;li>&lt;code>unread_eamils&lt;/code>: 읽지 않은 모든 이메일을 보관&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_11.png"
width="1288"
height="568"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_11_hueb1288bc525b10d750ab98ffc79e7b70_139881_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_11_hueb1288bc525b10d750ab98ffc79e7b70_139881_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비정규화"
class="gallery-image"
data-flex-grow="226"
data-flex-basis="544px"
>&lt;/p>
&lt;p>특정 폴더 안의 읽지 않은 모든 메일을 가져오는 질의는 다음과 같이 표현될 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">unread_mails&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">email_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이러한 비정규화는 흔한 관행으로, 애플리케이션 코드가 좀 더 복잡해지고 관리하기 까다로워지지만, 질의 성능은 대규모 서비스에 어울리는 수준으로 개선한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>보너스: 이메일 스레드 가져오기&lt;/strong>&lt;/p>
&lt;p>이메일 스레드는 많은 이메일 클라이언트가 지원하는 기능으로 모든 답장을 최초 메시지에 스레드로 엮어 보여주는 기능이다.&lt;/p>
&lt;p>사용자가 특정한 대화에 관련된 모든 메일을 한 번에 확인할 수 있게된다.&lt;/p>
&lt;ul>
&lt;li>전통적으로 &lt;strong>JWZ&lt;/strong> 같은 알고리즘을 통해 구현한다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;headers&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;Message-Id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;7BA04B2A-430C-4D12-8B57-862103C34501@gmail.com&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;In-Reply-To&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;CAEWTXuPfN=LzECjDJtgY9Vu03kgFvJnJUSHTt6TW@gmail.com&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;References&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;lt;7BA04B2A-430C-4D12-8B57-862103C34501@gmail.com&amp;gt;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>Message-Id&lt;/strong>
&lt;ul>
&lt;li>메시지 식별자&lt;/li>
&lt;li>메시지를 보내는 클라이언트가 생성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>In-Reply-To&lt;/strong>
&lt;ul>
&lt;li>어떤 메시지가 어떤 메시지에 대한 답신인지 나타내는 식별자&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>References&lt;/strong>
&lt;ul>
&lt;li>스레드에 관계된 메시지 식별자 목록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 필드들로 이메일 클라이언트는 타래 내의 모든 메시지가 사전에 메모리에 로드되어 있는 경우 전체 대화 스레드를 재구성해 낼 수 있게된다.&lt;/p>
&lt;h4 id="일관성-문제">일관성 문제&lt;/h4>
&lt;p>높은 가용성을 달성하기 위해 다중화에 의존하는 분산 데이터베이스는 데이터 일관성과 가용성 사이에서 타협적인 결정을 내릴 수 밖에 없다.&lt;/p>
&lt;p>이메일 시스템의 경우 &lt;strong>데이터의 정확성이 아주 중요&lt;/strong>하므로, 모든 메일함은 반드시 하나의ㅏ 주 사본을 통해 서비스된다고 가정해야한다.&lt;/p>
&lt;p>따라서 장애가 발생하면 클라이언트는 다른 사본을 통해 주 사본이 복원될 때까지 동기화/갱신 작업을 완료할 수 없다.&lt;/p>
&lt;ul>
&lt;li>일관성을 위해 가용성을 희생한다.&lt;/li>
&lt;/ul>
&lt;h3 id="이메일-전송-가능성">이메일 전송 가능성&lt;/h3>
&lt;p>메일 서버를 구성하고 이메일을 보내는 것은 쉽지만 특정 사용자의 메일함에 실제로 메일이 전달되도록 하는 것은 어려운 문제이다.&lt;/p>
&lt;p>이메일이 &lt;strong>스팸 폴더&lt;/strong>에 들어가 버리면 수신자가 메일을 읽을 가능성은 아주 낮아진다.&lt;/p>
&lt;ul>
&lt;li>연구에 따르면 메일 가운데 50%가 그팸으로 분류된다.&lt;/li>
&lt;/ul>
&lt;p>새로 구성한 메일 서버는 인터넷에서 좋은 평판을 쌓을 기회가 전혀 없었기 때문에 보내는 메일이 대부분 스팸 폴더로 떨어진다.&lt;/p>
&lt;p>따라서 이메일의 전송 가능성을 높이기 이ㅜ해서 다음과 같은 요소들을 고려한다.&lt;/p>
&lt;ul>
&lt;li>전용 IP
&lt;ul>
&lt;li>전용 IP 주소를 사용하라&lt;/li>
&lt;li>대부분의 이메일 서비스 사업자는 아무 이력이 없는 IP 새로운 IP 주소에서 온 메일을 무시한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>범주화
&lt;ul>
&lt;li>범주가 다른 이메일은 다른 IP 주소를 통해 보내라&lt;/li>
&lt;li>마케팅 목적의 메일을 중요한 이메일과 같은 서버에서 발송하면 ISP가 모든 이메일을 판촉 메일로 분류할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>발신인 평판
&lt;ul>
&lt;li>새로운 이메일 서버의 IP 주소는 사용 빈도를 서서히 올리는 것이 좋다.&lt;/li>
&lt;li>그래야 좋은 평판이 쌓여 해당 IP 주소에서 발송되는 메일을 스팸으로 분류할 가능성이 낮아진다.&lt;/li>
&lt;li>아마존 SES에 따르면 새로운 IP 주소를 메일 발송해 아무 문제 없이 쓸 수 있게 되는 데는 대략 2 ~ 6주가 소요된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>스팸 발송자의 신속한 차단
&lt;ul>
&lt;li>스팸을 뿌리는 사용자는 서버 평판을 심각하게 훼손하기 전에 시스템에서 신속히 차단한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>피드백 처리
&lt;ul>
&lt;li>불만 신고가 접수되는 비율을 낮추고 스팸 계정을 신속히 차단하기위해서는 ISP 측에서의 피드백을 쉽게 받아 처리할 수 있는 경로를 만드는 것이 중요하다.&lt;/li>
&lt;li>이메일이 전달되지 못하거나 사용자로부터 불만 신고가 접수된 경우 다음과 같은 일들이 벌어질 수 있다.
&lt;ul>
&lt;li>경성 반송(hard bounce)
&lt;ul>
&lt;li>수신인의 이메일 주소가 올바르지 않아 ISP가 전달을 거부한 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>연성 반송(soft bounce)
&lt;ul>
&lt;li>ISP 측의 이메일 처리 자원 부족 등의 이유로 일시적으로 이메일을 전달할 수 없었던 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>불만 신고(complaint)
&lt;ul>
&lt;li>수신인이 스팸으로 신고 버튼을 누르는 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일 인증
&lt;ul>
&lt;li>2018년도 데이터 유출 조사 보고서에 따르면 ㅍ피싱이나 프리텍스팅이 전체 유철 사고에서 차지하는 비중은 93%에 달한다.&lt;/li>
&lt;li>보편적으로 SPF(Sender Policy Framework), DKIM(DomainKeys Identified Mail), DMARC(Domain-based Message Authentication, Reporting and Conformance) 등으로 피싱에 대응한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>명심해야할 점은 이메일이 목적지에 성공적으로 도착하도록 하기 어렵다는 사실이다. 도메인 지식은 물론 ISP와 좋은 관계를 유지할 필요도 있다.&lt;/p>
&lt;h3 id="검색">검색&lt;/h3>
&lt;p>기본적인 이메일 검색은 보통 이메일 제목이나 본문에 특정 키워드가 포함되었는지 찾는 것을 뜻하며, 고급 기능에는 발신인, 제목, 읽지 않음 같이 메일 속성에 따른 필터링 기능이 포함된다.&lt;/p>
&lt;p>검색 기능을 제공하려면 이메일이 전송, 수신, 삭제 될 때마다 색인(indexing) 작업을 수행해야 한다.&lt;/p>
&lt;p>그에 반해 검색은 사용자가 검색 버튼을 누를 때만 실행되므로, 이메일 시스템의 검색 기능에서는 쓰기 연산이 읽기 연산보다 훨씬 많이 발생한다.&lt;/p>
&lt;p>검색 기능을 지원하기 위해 일래스틱서치(ElasticSearch)를 이용하는 방안과 데이터 저장소에 내장된 기본 검색 기능을 활용하는 방안의 두 가지 선택지를 비교해본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>방안 1: 일래스틱서치&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_12.png"
width="1210"
height="1224"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_12_hu3000d4f01569124c541bea50802fb702_56268_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_12_hu3000d4f01569124c541bea50802fb702_56268_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="일래스틱 서치"
class="gallery-image"
data-flex-grow="98"
data-flex-basis="237px"
>&lt;/p>
&lt;p>질의가 대부분 사용자의 이메일 서버에서 실행되므로 &lt;code>user_id&lt;/code>를 파티션 키로 사용하여 같은 사용자의 이메일은 같은 노드에 묶어 놓는다.&lt;/p>
&lt;ul>
&lt;li>사용자가 검색 버튼을 누른 다음 결과가 수신될 때 까지 기다리므로, 검색 요청은 동기 방식으로 처리되어야 한다.&lt;/li>
&lt;li>이메일 전송, 이메일 수신, 이메일 삭제 같은 이벤트는 처리 결과를 클라이언트로 전달할 필요는 없으며, 추가로 색인 작업이 필요하다.&lt;/li>
&lt;/ul>
&lt;p>본 설계안은 카프카를 활용하여 색인 작업을 시작하는 서비스와 실제로 색인을 수행할 서비스 사이의 결합도를 낮추는 방안을 채택한다.&lt;/p>
&lt;ul>
&lt;li>일래스틱서치는 2021년 6월 기준으로 가장 널리 사용되고 있는 검색 엔진 데이터베이스이며 이메일 검색에 필요한 텍스트 기반 검색을 잘 지원한다.&lt;/li>
&lt;/ul>
&lt;p>일래스틱서치를 사용할 경우 주 이메일 저장소와 동기화를 맞추는 부분이 까다롭다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>방안 2: 맞춤형 검색 솔루션&lt;/strong>&lt;/p>
&lt;p>대규모 이메일 서비스 사업자는 보통 자기 제품에 고유한 요구사항을 만족시키기 위해 검색 엔진을 자체적으로 개발해 사용한다.&lt;/p>
&lt;p>매우 어렵고 범위를 넘어서기 때문에 자체적으로 검색 솔루션을 구현하는 경우 마주하게 될 주요 과제인 디스크 I/O 병목 문제를 살펴본다.&lt;/p>
&lt;p>개략적 규모 추정 결과 메타 데이터와 첨부 파일은 매일 페타바이트 수준으로 저장소에 추가되며, 하나의 이메일 계정에 몇십 만개 넘는 이메일이 저장되는 것도 흔하다.&lt;/p>
&lt;ul>
&lt;li>따라서 메일 색인 서버의 주된 병복은 보통 디스크 I/O다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_13.png"
width="1926"
height="1002"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_13_hu495b352c0880296eb3398fcf25077ab9_380701_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_13_hu495b352c0880296eb3398fcf25077ab9_380701_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="LSM 트리"
class="gallery-image"
data-flex-grow="192"
data-flex-basis="461px"
>&lt;/p>
&lt;p>색인을 구축하는 프로세스는 다량의 쓰기 연산을 발생시킬 수 밖에 없으므로 LSM(Log-Structured Merge)트리를 사용하여 &lt;strong>디스크에 저장되는 색인을 구조화하는 것이 바람직한 전략&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>쓰기 경로는 순차적 쓰기 연산(sequential write)만 수행하도록 최적화 되어있다.&lt;/li>
&lt;li>빅테이블이나 카산드라, RocksDB 같은 데이터베이스의 핵심 자료 구조다.&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>새로운 이메일이 도착하면 우선 메모리 캐시로 구현되는 0번 계층에 저장된다.&lt;/li>
&lt;li>메모리에 보관된 데이터의 양이 사전에 정의된 임계치를 넘으면 데이터는 다음 계층에 병합된다.&lt;/li>
&lt;/ol>
&lt;p>자주 바뀌는 데이터를 그렇지 않은 데이터와 분리하는 효과도 얻을 수 있다.&lt;/p>
&lt;ul>
&lt;li>이메일 데이터는 보통 바뀌지 않지만 메일 폴더의 정보는 상이한 필터링 규칙들 때문에 자주 바뀌는 경향이 있다.&lt;/li>
&lt;li>데이터를 두 개 파트로 나누거 어떤 요청이 폴더 변경에 관한 것 이면 폴더 정보만 바꾸고 이메일 데이터는 내벼려둔다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>소규모의 이메일 시스템을 구축하는 경우 통합하기 쉽고 엔지니어링에 많은 노력이 필요하지 않은 일래스틱서치가 좋은 선택지이다.&lt;/p>
&lt;p>대규모 시스템을 구축하는 경에도 일래스틱서치를 사용할 수 있겠지만 이메일 검색 인프라를 개발하고 관리하는 전담 팀이 필요할 수 있다.&lt;/p>
&lt;p>지메일이나 아웃룩 규모의 이메일 시스템을 지원하려면 독립적인 검색 전용 시스템을 두기보다는 데이터베이스에 내장된 전용 검색 솔루션을 사용하는 것이 바람직할 수도 있다.&lt;/p>
&lt;h3 id="규모-확장성-및-가용성">규모 확장성 및 가용성&lt;/h3>
&lt;p>각 사용자의 데이터 접근 패턴은 다른 사용자와 무고나하므로, 시스템의 대부분 컴포넌트는 수평적으로 규모 확장이 가능할 것으로 기대할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_14.png"
width="1362"
height="1260"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_14_hu7aa95457bd45ad9d0fc44f5368731ee7_86292_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_14_hu7aa95457bd45ad9d0fc44f5368731ee7_86292_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="시스템 다중화"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="259px"
>&lt;/p>
&lt;p>가용성을 향상시키기 위해서는 데이터를 여러 데이터센터에 다중화하는 것이 필요하다.&lt;/p>
&lt;ul>
&lt;li>자신과 물리적으로 가까운 메일 서버와 통신한다.&lt;/li>
&lt;li>네트워크 파티션 발생시 다른 데이터센터에 보관된 메시지를 이용한다.&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>면접장에서 시간이 남는다면 추가로 논의해 볼 만한 주제로는 다음과 같은 것들이 있다.&lt;/p>
&lt;ul>
&lt;li>결함 내성
&lt;ul>
&lt;li>노드 장애, 네트워크 문제, 이벤트 전달 지연 등의 문제에 어떻게 대처할지 살펴보면 좋을 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규정 준수
&lt;ul>
&lt;li>전 세계 다양한 시스템과 연동해야 하고 각 나라에는 준수해야할 법규가 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>보안
&lt;ul>
&lt;li>민감한 정보가 포함되므로 보안이 매우 중요하다.&lt;/li>
&lt;li>피싱 방지, 안전 브라우징, 첨부 파일 사전 경고, 계정 안전, 기밀 모드, 이메일 암호화 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>최적화
&lt;ul>
&lt;li>같은 이메일이 여러 수신자에 전송되는 경우 동일한 첨부 파일이 있는지 확인하는 방식으로 최적화를 진행할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>7. 호텔 예약 시스템</title><link>https://codemario318.github.io/post/system-design-interview-2/7/</link><pubDate>Sat, 12 Oct 2024 14:59:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/7/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/cover.png" alt="Featured image of post 7. 호텔 예약 시스템" />&lt;p>이번 장에서는 호텔 체인의 예약 시스템을 설계한다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>호텔 예약 시스템은 복잡하고 그 컴포넌트는 시스템을 사업에 어떻게 이용할지에 따라 달라지므로 범위를 명확히 해야한다.&lt;/p>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>높은 수준의 동시성 지원
&lt;ul>
&lt;li>성수기, 대규모 이벤트 기간에는 일부 인기 호텔의 특정 객실을 예약하려는 고객이 많이 몰릴 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>적절한 지연 시간
&lt;ul>
&lt;li>사용자가 예약을 할 때는 응답 시간이 빠르면 이상적이겠으나 &lt;strong>예약 요청 처리&lt;/strong>에 &lt;strong>몇 초 정도&lt;/strong> 걸리는 것은 괜찮다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;ul>
&lt;li>총 5,000개 호텔, 100만 개의 객실이 있다고 가정&lt;/li>
&lt;li>평균 &lt;strong>객실의 70%가 사용 중&lt;/strong>, 평균 &lt;strong>투숙 기간은 3일&lt;/strong>이라고 가정&lt;/li>
&lt;li>&lt;code>일일 예상 예약 건수 = (1백만 * 0.7) / 3 ~= 240,000&lt;/code>&lt;/li>
&lt;li>&lt;code>초당 예약 건수 = 240,000 / 하루에 10^5초 ~= 3&lt;/code>
&lt;ul>
&lt;li>초당 예약 트랜잭션 수(TPS)는 높지 않다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>시스템 내 모든 페이지의 QPS를 계산해본다.&lt;/p>
&lt;p>호텔 예약 시스템은 일반적으로 고객이 아래와 같은 흐름을 거친다.&lt;/p>
&lt;ol>
&lt;li>호텔/객실 상세 페이지
&lt;ul>
&lt;li>사용자가 호텔/객실 정보를 확인한다.(조회)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예약 상세 정보 페이지
&lt;ul>
&lt;li>날짜, 투숙 인원, 결제 방법 등의 상세 정보를 예약 전에 확인한다.(조회)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객실 예약 페이지
&lt;ul>
&lt;li>사용자가 &amp;lsquo;예약&amp;rsquo; 버튼을 눌러 객실을 예약한다.(트랜잭션 발생)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img.png"
width="1290"
height="630"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_hudca757551e48c8d1d2e333630b9f6cbe_51951_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_hudca757551e48c8d1d2e333630b9f6cbe_51951_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="QPS 분포"
class="gallery-image"
data-flex-grow="204"
data-flex-basis="491px"
>&lt;/p>
&lt;p>대략 10%의 사용자가 간 단계에서 다음 단계를 진행한다고 가정하면 최종 예약 TPS는 3이므로, 예약 페이지의 QPS는 30, 객실 정보 확인 페이지의 QPS는 300이다.&lt;/p>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="api-설계">API 설계&lt;/h3>
&lt;p>호텔 예약 시스템의 가장 중요한 API만 RESTful 관례에 따라 표현하면 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>검색 기능 등의 직관적인 기능도 필요하나, 기술적으로 도전적이지는 않다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>호텔 관련 API&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/hotels/id&lt;/td>
&lt;td>호텔의 상세 정보 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST /v1/hotels&lt;/td>
&lt;td>신규 호텔 추가(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PUT /v1/hotels/id&lt;/td>
&lt;td>호텔 정보 갱신(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE /v1/hotels/id&lt;/td>
&lt;td>호텔 정보 삭제(관리자)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>객실 관련 API&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/hotels/:id/rooms/id&lt;/td>
&lt;td>객실 상세 정보 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST /v1/hotels/:id/rooms&lt;/td>
&lt;td>신규 객실 추가(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PUT /v1/hotels/:id/rooms/id&lt;/td>
&lt;td>객실 정보 갱신(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE /v1/hotels/:id/rooms/id&lt;/td>
&lt;td>객실 정보 삭제(관리자)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>예약 관련 API&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/reservations&lt;/td>
&lt;td>로그인 사용자의 예약 이력 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GET /v1/reservations/id&lt;/td>
&lt;td>특정 예약의 상세 정보 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST /v1/reservations&lt;/td>
&lt;td>신규 예약&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE /v1/reservations/id&lt;/td>
&lt;td>예약 취소&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>신규 예약 접수는 아주 중요한 기능으로, 새 예약을 만들 때 전달하는 인자의 형태는 아래와 같은데&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;startDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-28&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;endDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-30&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;hotelID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;245&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;roomID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;U12354673389&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;reservationID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;13422445&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>researvationID&lt;/code>는 &lt;strong>이중 예약을 방지하고 동일한 예약은 단 한 번만 이루어지도록 보증하는 멱등 키(idempotent key)다.&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>멱등성?&lt;/strong>
연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질&lt;/p>
&lt;/blockquote>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>어떤 데이터베이스를 사용할지 결정하기위해 데이터 접근 패턴을 확인해야한다.&lt;/p>
&lt;ol>
&lt;li>호텔 상세 정보 확인&lt;/li>
&lt;li>지정된 날짜 범위에 사용 가능한 객실 유형 확인&lt;/li>
&lt;li>예약 정보 기록&lt;/li>
&lt;li>예약 내역 또는 과거 예약 이력 정보 조회&lt;/li>
&lt;/ol>
&lt;p>시스템 규모가 크지 않지만 대규모 이벤트 등으로 인해 트래픽이 급증할 수도 있으니 대비가 필요하다.&lt;/p>
&lt;p>이런 요구사항을 종합적으로 고려하였을 때 &lt;strong>관계형 데이터베이스&lt;/strong>가 적절해보인다.&lt;/p>
&lt;ul>
&lt;li>읽기 빈도가 쓰기 연산에 비해 높은 작업 흐름을 잘 지원한다.
&lt;ul>
&lt;li>읽기 반도가 압도적인 작업 흐름은 충분히 잘 지원한다.&lt;/li>
&lt;li>NoSQL 데이터베이스는 대체로 쓰기 연산에 최적화되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ACID 속성(원자성, 일관성, 격리성, 영속성)을 보장한다.
&lt;ul>
&lt;li>예약이라는 도메인 특성으로 인해 ACID 속성은 매우 중요하다.&lt;/li>
&lt;li>ACID를 보장하지 않으면 잔액 마이너스 문제, 이중 청구 문제, 이중 예약 문제 등을 방지하기 어렵다.&lt;/li>
&lt;li>ACID 속성이 충족되는 데이터베이스를 사용하면 코드는 단순해지고 이해하기 쉬워진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터를 쉽게 모델링 할 수 있다.
&lt;ul>
&lt;li>비즈니스 데이터의 구조를 명확하게 표현할 수 있을 뿐 아니라 엔티티 간의 간계를 안정적으로 지원할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_1.png"
width="1622"
height="1138"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_1_hude4e50a98d4fd9adb0d8d3f89cda06c5_259967_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_1_hude4e50a98d4fd9adb0d8d3f89cda06c5_259967_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터베이스 스키마"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="342px"
>&lt;/p>
&lt;p>&lt;code>reservation&lt;/code> 테이블의 &lt;code>status&lt;/code> 필드는 &lt;code>Pending&lt;/code>, &lt;code>Paid&lt;/code>, &lt;code>Refunded&lt;/code>, &lt;code>Canceled&lt;/code>, &lt;code>Rejected&lt;/code> 다섯 상태 가운데 하나를 값으로 가질 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_2.png"
width="1320"
height="630"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_2_hu654fdd7d1e7937dbeca03f4655f81aa1_21966_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_2_hu654fdd7d1e7937dbeca03f4655f81aa1_21966_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="예약 상태"
class="gallery-image"
data-flex-grow="209"
data-flex-basis="502px"
>&lt;/p>
&lt;p>이 스키마에서 &lt;code>room_id&lt;/code>는 에어비엔비 같은 회사에는 적합하나, 특정 호텔의 특정 객실 유형을 예약하는 호텔에는 적절하지 않을 수 있다.&lt;/p>
&lt;ul>
&lt;li>객실 번호는 예약할 때가 아닌, 투숙객이 체크인 하는 시점에 부여된다.&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>이번 호텔 예약 시스템에는 마이크로서비스 아키텍처를 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_3.png"
width="1946"
height="1100"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_3_hu282c3b24ada39ab6809ed01eac989c4e_87808_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_3_hu282c3b24ada39ab6809ed01eac989c4e_87808_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="176"
data-flex-basis="424px"
>&lt;/p>
&lt;p>마이크로 서비스 간 상호작용을 나타내는 화살표 상당수를 생략하였다.&lt;/p>
&lt;p>실제 상업적으로 이용되는 시스템의 서비스 간 통신에는 gRPC와 같은 고성능 원격 프로세서 호출 프레임워크를 사용하곤 한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>gRPC?&lt;/strong>&lt;br>
gRPC는 Google에서 개발한 고성능, 오픈 소스 원격 프로시저 호출(Remote Procedure Call, RPC) 프레임워크이다.
클라이언트와 서버 간에 원격 프로시저를 호출할 수 있게 해 주며, 마치 로컬에서 함수를 호출하는 것처럼 네트워크를 통해 다른 시스템의 메서드를 실행할 수 있다.
주로 프로토콜 버퍼(Protocol Buffers, protobuf)라는 직렬화 방식을 사용해 데이터를 효율적으로 전송하며, HTTP/2를 기반으로 동작해 성능과 확장성을 높인다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="개선된-데이터-모델">개선된 데이터 모델&lt;/h3>
&lt;p>호텔 객실을 예약할 때는 특정 객실이 아니라 특정한 객실 유형을 예약하게 된다.&lt;/p>
&lt;p>이러한 특성을 반영하기 위해 예약 API의 경우 호출 인자 가운데 &lt;code>roomID&lt;/code>는 &lt;code>roomTypeID&lt;/code>로 변경한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;startDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-28&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;endDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-30&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;hotelID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;245&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;roomTypeID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;U12354673389&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;reservationID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;13422445&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>스키마는 아래와 같이 변경된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_4.png"
width="1366"
height="1028"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_4_hu481f8e14d20d4e775dd6afb82166b25a_281965_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_4_hu481f8e14d20d4e775dd6afb82166b25a_281965_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="갱신된 스키마"
class="gallery-image"
data-flex-grow="132"
data-flex-basis="318px"
>&lt;/p>
&lt;p>주요 변경 사항은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>room&lt;/code>: 객실에 관계된 정보&lt;/li>
&lt;li>&lt;code>room_type_rate&lt;/code>: 특정 객실 유형의 특정 일자 요금 정보&lt;/li>
&lt;li>&lt;code>reservation&lt;/code>: 투숙객 예약 정보&lt;/li>
&lt;li>&lt;code>room_type_inventory&lt;/code>: 호텔의 모든 객실 유형
&lt;ul>
&lt;li>&lt;code>hotel_id&lt;/code>: 호텔 식별자&lt;/li>
&lt;li>&lt;code>room_type_id&lt;/code>: 객실 유형 식별자&lt;/li>
&lt;li>&lt;code>date&lt;/code>: 일자&lt;/li>
&lt;li>&lt;code>total_inventory&lt;/code>: 총 객실 수에서 일시적으로 제외한 객실 수를 뺀 값
&lt;ul>
&lt;li>유지 보수를 위해 예약 가능 목록에서 제외할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>total_reserved&lt;/code>: 저정된 hotel_id, room_type_id, date에 예약된 모든 객실의 수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>날짜당 하나의 레코드를 사용하면 날짜 범위 내에서 예약을 쉽게 관리하고 질의할 수 있다.&lt;/p>
&lt;p>이 테이블의 기본키는 &lt;code>(hotel_id, room_type_id, date)&lt;/code>의 복합키로, 2년 이내 모든 미래 날짜에 대한 가용 객실 데이터 질의 결과를 토대로 미리 채워 놓고, 시간이 흐름에 따라 새로 추가해야 하는 객실 정보는 매일 한 번씩 일괄 작업을 돌려 반영한다.&lt;/p>
&lt;hr>
&lt;p>5,000개의 호텔이 있고 각 호텔에는 20개의 객실 유형이 있으므로 테이블에 저장해야 하는 레코드의 수는 &lt;code>5,000 * 20 * 2년 * 365일 = 7,300만 개&lt;/code> 정도이다.&lt;/p>
&lt;p>많은 데이터가 아니므로 데이터베이스 하나면 저장하기 충분하지만, 하나만 둔다면 SPOF 문제를 피할 수 없게된다.&lt;/p>
&lt;p>고가용성을 달성하려면 여러 지역, 또는 가용성 구역에 데이터베이스를 복제해 두어야 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;code>room_type_inventory&lt;/code> 테이블은 고객이 특정 유형의 객실을 예약할 수 있는지 여부를 확인할 때 사용한다.&lt;/p>
&lt;ul>
&lt;li>입력
&lt;ul>
&lt;li>&lt;code>startDate&lt;/code>&lt;/li>
&lt;li>&lt;code>endDate&lt;/code>&lt;/li>
&lt;li>&lt;code>roomTypeId&lt;/code>&lt;/li>
&lt;li>&lt;code>hotelId&lt;/code>&lt;/li>
&lt;li>&lt;code>numberOfRoomsToReserve&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>출력
&lt;ul>
&lt;li>해당 유형의 객실에 여유가 있고 예약 가능한 상태라면 &lt;code>True&lt;/code>, 아니면 &lt;code>False&lt;/code>를 반환한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>SQL 관점에서 두 절차를 거친다.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>주어진 기간에 해당하는 레코드를 구한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">date&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_inventory&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_reserved&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">room_type_inventory&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">room_type_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">roomTypeId&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">hotel_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">hotelId&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BETWEEN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">startDate&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">endDate&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>반환한 각 레코드마다 다음 조건을 확인한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">if ((total_reserved + ${numberOfRoomsToReserve}) &amp;lt;= total_inventory)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>레코드의 모든 행을 검사한 결과 &lt;code>True&lt;/code>가 반환되면 주어진 기간 내 모든 날짜에 충분한 객실이 있다는 뜻 이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>예약 데이터가 단을 데이터베이스에 담기에 너무 크다면 다음과 같은 방안을 생각해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>현재 및 향후 예약 데이터만 저장한다.
&lt;ul>
&lt;li>예약 이력은 자주 접근하지 않으므로 아카이빙 하거나 냉동 저장소로 옮길 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터베이스를 샤딩한다.
&lt;ul>
&lt;li>자주 사용되는 질의는 &lt;strong>예약&lt;/strong> 및 &lt;strong>예약 확인&lt;/strong>이므로, 두 질의에서 모두 먼저 알아야하는 &lt;code>hotel_id&lt;/code>를 샤딩키로 사용한다.&lt;/li>
&lt;li>데이터는 &lt;code>hash(hotel_id) % number_of_service&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="동시성-문제">동시성 문제&lt;/h3>
&lt;p>또 하나의 중요한 문제는 &lt;strong>이중 예약 방지&lt;/strong>이며, 이를 위해 두가지 문제를 해결해야한다.&lt;/p>
&lt;ul>
&lt;li>같은 사용자가 예약 요청을 여러번 시도할 수 있다.&lt;/li>
&lt;li>여러 사용자가 같은 객실을 동시에 예약하려 할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="같은-사용자가-같은-예약-요청을-시도하는-경우">&lt;strong>같은 사용자가 같은 예약 요청을 시도하는 경우&lt;/strong>&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_5.png"
width="1508"
height="986"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_5_hueb9926d5bdf21d1ae178c13f6ba855ec_83059_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_5_hueb9926d5bdf21d1ae178c13f6ba855ec_83059_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="같은 고객의 이중 예약"
class="gallery-image"
data-flex-grow="152"
data-flex-basis="367px"
>&lt;/p>
&lt;p>이 문제를 푸는 일반적인 접근법으로는 다음 두가지가 있다.&lt;/p>
&lt;ul>
&lt;li>클라이언트 측 구현
&lt;ul>
&lt;li>요청 전송 후 예약 버튼을 비활성화 한다.
&lt;ul>
&lt;li>클라이언트에서 우회 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>멱등 API
&lt;ul>
&lt;li>예약 API 요청에 멱등 키를 추가하는 방안&lt;/li>
&lt;li>&lt;code>reservation_id&lt;/code>를 멱등 키로 사용하여 이중 예약 문제를 해결하는 방안이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_6.png"
width="1130"
height="1066"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_6_hu48c6b4b2100602be71a6178ae06987e2_69862_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_6_hu48c6b4b2100602be71a6178ae06987e2_69862_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="유일성 조건"
class="gallery-image"
data-flex-grow="106"
data-flex-basis="254px"
>&lt;/p>
&lt;ol>
&lt;li>예약 주문서를 만든다.&lt;/li>
&lt;li>고객이 검토할 수 있도록 예약 주문서를 반환한다.&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>반환 결과에 &lt;code>reservation_id&lt;/code>를 넣는다.(전역적 유일성을 보증하는 ID, 예제에서는의 예약 테이블의 기본키)&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>검토가 끝난 예약을 전송한다.
&lt;ul>
&lt;li>요청에 &lt;code>reservation_id&lt;/code>를 포함한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예약 완료 버튼을 한 번 더 눌러 보내도 &lt;code>reservation_id&lt;/code>가 예약 테이블의 기본 키 이므로 유일성 조건에 위반되어 처리되지 않는다.&lt;/li>
&lt;/ol>
&lt;h4 id="여러-사용자가-하나뿐인-객실을-동시에-예약하는-경우">&lt;strong>여러 사용자가 하나뿐인 객실을 동시에 예약하는 경우&lt;/strong>&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_7.png"
width="1438"
height="1262"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_7_hu8a18da16175039b3cfa48b49d042fdf5_80735_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_7_hu8a18da16175039b3cfa48b49d042fdf5_80735_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="경쟁 조건"
class="gallery-image"
data-flex-grow="113"
data-flex-basis="273px"
>&lt;/p>
&lt;p>이 문제를 해결하려면 어떤 형태로든 락을 활용해야 한다.&lt;/p>
&lt;p>&lt;strong>비관적 락&lt;/strong>&lt;/p>
&lt;p>비관적 락은 비관적 동시성 제어 방안이라고도 불리며, 사용자가 &lt;strong>레코드를 갱신하려고 하는 순간 즉시 락을 걸어 동시 업데이트를 방지하는 기술&lt;/strong>이다.&lt;/p>
&lt;p>따라서 해당 레코드를 갱신하려는 다른 사용자는 락 해제를 기다려야 한다.&lt;/p>
&lt;ul>
&lt;li>MySQL 같은 경우는 &lt;code>SELECT ... FOR UPDATE&lt;/code> 문을 실행하면 &lt;code>SELECT&lt;/code>가 반환한 레코드에 락이 걸린다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_8.png"
width="1994"
height="1320"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_8_hu40fa4d62dd848fb68c0b889e46e94f87_126013_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_8_hu40fa4d62dd848fb68c0b889e46e94f87_126013_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비관적 락"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="362px"
>&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>변경 중이거나 변경이 끝난 데이터를 갱신하는 일을 막을 수 있다.&lt;/li>
&lt;li>구현이 쉽고 모든 갱신 연산을 직렬화하여 충돌을 막는다.&lt;/li>
&lt;li>데이터에 대한 경합이 심할 때 유용하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>여러 레코드에 락을 걸면 교착 상태가 발생할 수 있다.
&lt;ul>
&lt;li>교착 상태가 발생하지 않는 코드 작성은 어렵다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장성이 낮다.&lt;/li>
&lt;li>트랜잭션이 너무 오랫동안 락을 해제하지 않고 있으면 다른 트랜잭션은 락이 걸린 자원에 접근할 수 없어 트랜잭션 수명이 길거나 많은 엔티티에 관련된 경우 성능에 심각한 영향을 끼친다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 이유로 비관적 락 메커니즘은 군장하지 않는다.&lt;/p>
&lt;p>&lt;strong>낙관적 락&lt;/strong>&lt;/p>
&lt;p>낙관적 락은 &lt;strong>낙관적 동시성 제어&lt;/strong>라고도 불리는 방안으로 &lt;strong>여러 사용자가 동시에 같은 자원을 갱신하려 시도하는 것을 허용&lt;/strong>한다.&lt;/p>
&lt;p>일반적으로 버전 번호(version_number)와 타임스탬프(timestamp) 두 가지 방법으로 구현한다.&lt;/p>
&lt;ul>
&lt;li>서버 시계는 시간이 지남에 따라 부정확해질 수 있으므로 일반적으로는 버전 번호를 더 나은 선택지로 본다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_9.png"
width="1938"
height="1142"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_9_hu9411dd474af31fd86c2a43d5119b3270_97882_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_9_hu9411dd474af31fd86c2a43d5119b3270_97882_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="낙관적 락"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="407px"
>&lt;/p>
&lt;p>낙관적 락은 데이터베이스에 직접 락을 걸지 않으므로 일반적으로 비관적 락 보다 빠르지만 동시성 수준이 아주 높으면 성능이 급격히 나빠진다.&lt;/p>
&lt;p>예를 들어 설명하면 잔여 객실 수를 읽을 수 있는 클라이언트 수에는 제한이 없으므로, 모든 클라이언트는 같은 잔여 객실 수와 같은 버전 정보를 취득하게 될 수 있기 때문에 모든 클라이언트는 같은 잔여 객실 수와 같은 버전 번호 정보를 취득한다.&lt;/p>
&lt;p>하지만 실제로 버전 번호 갱신에 성공하는 클라이언트는 하나이므로, 다른 모든 클라이언트는 버전 번호 검사에 실패하게된다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>애플리케이션이 유효하지 않은 데이터를 편집하는 일을 막는다.&lt;/li>
&lt;li>데이터베이스 자원에 락을 걸 필요가 없다.(데이터베이스 관점에서 락은 없다.) 책임은 애플리케이션에 있다.&lt;/li>
&lt;li>데이터에 대한 경쟁이 치열하지 않은 상황에 적합하다.
&lt;ul>
&lt;li>락을 관리하는 비용 없이 트랜잭션을 실행할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>데이터에 대한 경쟁이 치열한 상황에서는 성능이 좋지 못하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>낙관적 락은 예약 QPS가 일반적으로 높지 않은 호텔 예약 시스템에서는 적합한 선택지이다.&lt;/p>
&lt;p>&lt;strong>데이터베이스 제약 조건&lt;/strong>&lt;/p>
&lt;p>낙관적 락과 아주 유사하게 동작한다.&lt;/p>
&lt;p>&lt;code>room_type_inventory&lt;/code> 테이블에 다음 제약 조건을 추가한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CONSTRAINT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">check_room_count&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">CHECK&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">total_inventory&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_reserved&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_10.png"
width="1478"
height="1368"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_10_hu8a54ba9888669d6b439cae205e8f7b91_81051_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_10_hu8a54ba9888669d6b439cae205e8f7b91_81051_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 베이스 제약 조건"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="259px"
>&lt;/p>
&lt;p>사용자가 객실을 예약하려면 &lt;code>total_reserved&lt;/code>의 값이 101으로 제약 조건을 위반하게되어 롤백된다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>구현이 쉽다.&lt;/li>
&lt;li>데이터에 대한 경쟁이 심하지 않을 때 잘 동작한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>데이터에 대한 경쟁이 심하면 실패하는 연산 수가 매우 늘어날 수 있다.&lt;/li>
&lt;li>데이터베이스 제약 조건은 애플리케이션 코드와 달라서 버전을 통제하기 어렵다.&lt;/li>
&lt;li>제약 조건을 허용하지 않는 데이터베이스도 있으므로 마이그레이션 등에 문제가 될 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="시스템-규모-확장">시스템 규모 확장&lt;/h3>
&lt;p>일반적으로 호텔 예약 시스템에 대한 부하는 높지 않지만, 유명한 여행 예약 웹 사이트와 연동이 되어야한다면 QPS는 매우 늘어날 수 있다.&lt;/p>
&lt;p>시스템 부하가 높을 때는 무엇이 병목이 될 수 있는지 이해해야한다.&lt;/p>
&lt;ul>
&lt;li>해당 시스템의 모든 서비스는 무상태 서비스이므로 서버를 추가하는 것으로 성능 문제는 해결할 수 있다.&lt;/li>
&lt;li>데이터베이스는 단순히 데이터베이스 서버를 늘리는 것만으로는 성능 문제를 해결할 수 없다.&lt;/li>
&lt;/ul>
&lt;h4 id="데이터베이스-샤딩">데이터베이스 샤딩&lt;/h4>
&lt;p>데이터베이스를 여러 대 두고, 각각에 데이터의 일부만 보관하도록 하는 방식이다.&lt;/p>
&lt;p>데이터베이스를 샤딩할 때는 데이터를 어떻게 분배할 지 먼저 정한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>hotel_id&lt;/code>를 필터링 조건으로 사용하므로 샤딩 조건으로 쓰면 좋다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_11.png"
width="1964"
height="1122"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_11_hu98af43fce089f7bbf6f6bf1fb85b60d6_147947_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_11_hu98af43fce089f7bbf6f6bf1fb85b60d6_147947_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터베이스 샤딩"
class="gallery-image"
data-flex-grow="175"
data-flex-basis="420px"
>&lt;/p>
&lt;p>위는 16개 샤드로 분산하는 사례로, QPS가 30,000이라면 샤딩 후에는 1875QPS 정도로 한 대의 MySQL 서버로도 감당할 수 있는 부하가 된다.&lt;/p>
&lt;h4 id="캐시">캐시&lt;/h4>
&lt;p>호텔 잔여 객실 데이터는 현재와 미래의 데이터만 중요하다는 특성이 있다.&lt;/p>
&lt;p>따라서 데이터를 보관할 때 낡은 데이터는 자동적으로 소멸되도록 TTL을 설정할 수 있다면 바람직하다.&lt;/p>
&lt;ul>
&lt;li>이력 데이터는 다른 데이터베이스를 통해 질의하도록 하면 된다.&lt;/li>
&lt;/ul>
&lt;p>이런 상황에 레디스는 매우 적합하다.&lt;/p>
&lt;hr>
&lt;p>데이터 로딩 속도와 데이터베이스 확장성이 문제가 되기 시작하면 데이터베이스 앞에 캐시 계층을 두고 잔여 객실 확인 및 객실 예약 로직이 해당 계층에서 실행되도록 할 수 있다.&lt;/p>
&lt;p>요청의 일부만 잔여 객실 데이터베이스가 처리하고 나머지는 캐시가 담당하도록 한다.&lt;/p>
&lt;ul>
&lt;li>레디스 캐시 데이터에는 잔여 객실이 충분해 보여도 실제 데이터베이스를 다시 한번 확인해야한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_12.png"
width="1094"
height="682"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_12_hu5d3b54b38dcf02612143f1622e8a715a_133204_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_12_hu5d3b54b38dcf02612143f1622e8a715a_133204_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="캐시"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="384px"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>예약 서비스&lt;/strong>: 다음과 같은 잔여 객실 관리 API를 제공한다.&lt;/p>
&lt;ul>
&lt;li>지정된 호텔과 객실 유형, 주어진 날짜 범위에 이용 가능한 객실의 수를 질의&lt;/li>
&lt;li>객실을 예약하고 &lt;code>total_reserved&lt;/code>의 값을 1 증가&lt;/li>
&lt;li>고객이 예약을 취소하면 잔여 객실 수를 갱신&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>잔여 객실 캐시&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>모든 잔여 객실 관리에 필요한 질의는 레디스로 구현되는 잔여 객실 캐시로 옮긴다.&lt;/li>
&lt;li>따라서 사전에 잔여 객실 정보를 캐시에 미리 저장해두어야 한다.&lt;/li>
&lt;li>캐시에 저장되는 데이터 형식
&lt;ul>
&lt;li>키: &lt;code>hotelID_roomTypeId_{날짜}&lt;/code>&lt;/li>
&lt;li>값
&lt;ul>
&lt;li>주어진 호텔 ID&lt;/li>
&lt;li>객실 유형 ID&lt;/li>
&lt;li>날짜에 맞는 잔여 객실 수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>호텔 예약 시스템은 잔여 객실 확인 작업 때문에 읽기 연산 빈도가 쓰기 연산보다 훨씬 많으므로 대부분의 읽기 연산을 캐시로 처리하면 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>잔여 객실 데이터베이스&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>잔여 객실 수에 대한 가장 믿을 만한 정보가 보관되는 장소&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>캐시가 주는 새로운 과제&lt;/strong>&lt;/p>
&lt;p>캐시 계층을 추가하면 시스템의 확장성과 처리량은 대폭 증가하지만 데이터베이스와 캐시 사이의 데이터 일관성 유지에 관한 새로운 문제가 생긴다.&lt;/p>
&lt;p>사용자가 객실을 예약할 때 아무 문제가 없는 경우에는 다음 두 가지 작업이 이루어진다.&lt;/p>
&lt;ol>
&lt;li>잔여 객실 수를 질의하여 충분한지 확인(캐시)&lt;/li>
&lt;li>잔여 객실 데이터를 갱신
&lt;ul>
&lt;li>데이터베이스 갱신 이후 캐시 갱신&lt;/li>
&lt;li>비동기적으로 실행&lt;/li>
&lt;li>변경 데이터 감지(CDC) 매커니즘을 활용할 수 있다.
&lt;ul>
&lt;li>데이터베이스에서 발생한 변화를 감지하여 해당 변경 내역을 다른 시스템에 적용할 수 있도록 하는 매커니즘&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>잔여 객실 데이터에 대한 변화를 데이터베이스에 먼저 반영하므로 캐시에는 최신 데이터가 없을 가능성이 있다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>이러한 불일치 문제는 데이터베이스가 최종적으로 잔여 객실 확인을 하도록 한다면 문제가 되지는 않는다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>장점&lt;/p>
&lt;ul>
&lt;li>읽기 질의를 캐시가 처리하므로 데이터베이스의 부하가 크게 줄어든다.&lt;/li>
&lt;li>읽기 질의를 메모리에서 실행하므로 높은 성능을 보장할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>단점&lt;/p>
&lt;ul>
&lt;li>데이터베이스와 캐시 사이의 데이터 일관성을 유지하는 것은 어렵다.
&lt;ul>
&lt;li>데이터 불일치가 사용자 경험에 끼치는 영향을 신중하게 살펴야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="서비스-간-데이터-일관성">서비스 간 데이터 일관성&lt;/h3>
&lt;p>모노리스 아키텍처의 경우 데이터의 일광성을 보장하기 위해 관계형 데이터베이스를 공유하는 것이 보통이지만, 해당 시스템은 예약 테이블과 잔여 객실 테이블만 동일한 관계형 데이터베이스에 저장하는 MSA 하이브리드 접근법을 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_13.png"
width="1920"
height="514"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_13_huc5f5e8f7744db63fc867cea3c0d26387_55893_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_13_huc5f5e8f7744db63fc867cea3c0d26387_55893_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="모노리스 vs 마이크로서비스"
class="gallery-image"
data-flex-grow="373"
data-flex-basis="896px"
>&lt;/p>
&lt;p>이를 통해 관계형 데이터베이스의 ACID 속성을 활용하여 동시성 문제를 효과적으로 대응할 수 있지만, MSA 순수 주의자라면 마이크로 서비스가 독자적인 데이터베이스를 갖추고 있어야 한다고 주장할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_15.png"
width="1362"
height="1150"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_15_hu1651b063c3947755463e1494fe52dabe_39875_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_15_hu1651b063c3947755463e1494fe52dabe_39875_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="모노리스 아키텍처"
class="gallery-image"
data-flex-grow="118"
data-flex-basis="284px"
>&lt;/p>
&lt;p>모노리스 아키텍처는 하나의 데이터베이스만 사용하므로 여러 연산을 하나의 트랜잭션으로 묶어 ACID 속성이 만족되도록 보장할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_14.png"
width="1748"
height="1062"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_14_hu657f4a94828478d72376098f027fabfa_59765_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_14_hu657f4a94828478d72376098f027fabfa_59765_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="마이크로서비스 아키텍처"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="395px"
>&lt;/p>
&lt;p>하지만 서비스가 독자적인 데이터베이스를 갖도록 하면, 논리적으로는 하나의 원자적 연산이 여러 데이터베이스에 걸쳐 실행되는 일을 피할 수 없다.&lt;/p>
&lt;ul>
&lt;li>하나의 트랜잭션으로 데이터 일관성을 보증하는 기법을 사용할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>이러한 데이터 일관성 문제를 해결하기 위해 널리 사용되는 방법은 2가지 정도가 있다.&lt;/p>
&lt;ul>
&lt;li>2단계 커밋(2-phase commit, 2PC)
&lt;ul>
&lt;li>여러 노드에 걸친 원자적 트랜잭션 실행을 보증하는 데이터베이스 프로토콜&lt;/li>
&lt;li>모든 노드가 성공하든 아니면 실패하든 둘 중 하나로 트랜잭션이 마무리되도록 보증&lt;/li>
&lt;li>비중단 실행이 가능한 프로토콜이 아니므로 어느 한 노드에 장애가 발생하면 해당 장애가 복구될 때까지 진행이 중단된다.(성능이 뛰어난 프로토콜은 아니다.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사가(Saga)
&lt;ul>
&lt;li>각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮는다.&lt;/li>
&lt;li>각각의 트랜잭션은 완료되면 다음 트랜잭션을 시작하는 트리거로 쓰일 메시지를 만드러 보낸다.&lt;/li>
&lt;li>한 트랜잭션이라도 실패하면 그 이전 트랜잭션의 결과를 전부 되될리는 트랜잭션들을 순차적으로 실행한다.&lt;/li>
&lt;li>2pc는 여러 노드에 걸친 하나의 트랜잭션을 통해 ACID 속성을 만족시키는 개념이지만 사가는 각 단계가 하나의 트랜잭션이라서 결과적 일관성에 의존하는 것으로 본다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>마이크로서비스 간의 데이터 불일치를 해결하기 위해 사용되는 복잡한 매커니즘은 시스템 전체 설계의 복잡성을 크게 증가시킨다.&lt;br>
증가한 복잡성이 그만한 가치가 있는 지 결정하는 것은 설계자의 몫이다.&lt;/p>
&lt;ul>
&lt;li>이번 설계안은 그만한 가치는 없다고 판단하여 예약 및 잔여 객실 정보를 동일한 관계형 데이터베이스에 저장하는 좀 더 실용적인 접근 방법을 선택했다.&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;ul>
&lt;li>경쟁 조건이 발생할 수 있는 시나리오
&lt;ul>
&lt;li>비관적 락&lt;/li>
&lt;li>낙관적 락&lt;/li>
&lt;li>데이터베이스 제약 조건&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규모 확장
&lt;ul>
&lt;li>데이터베이스 샤딩&lt;/li>
&lt;li>레디스 캐시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>마이크로아키텍처의 데이터 일관성 문제&lt;/li>
&lt;/ul></description></item><item><title>15. 아키텍처란?</title><link>https://codemario318.github.io/post/clean-architecture/15/</link><pubDate>Tue, 12 Mar 2024 15:37:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/15/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/15/cover.png" alt="Featured image of post 15. 아키텍처란?" />&lt;p>&lt;strong>소프트웨어 아키텍트란?&lt;/strong>&lt;br>
소프트웨어 아키텍트는 프로그래머이며, 앞으로도 계속 프로그래머로 남아야하므로, 고수준 문제에만 집중하여 코드와 동떨어져서는 안 된다.&lt;/p>
&lt;p>소프트웨어 아키텍트는 개발에 참여하며 나머지 팀원들이 생산성을 극대화할 수 있는 설계를 하도록 방향을 이끌어준다.&lt;/p>
&lt;p>따라서 프로그래밍을 작업에 계속 참여하며 문제를 직접 경험하고 이를 통해 다른 프로그래머를 지원하는 작업을 수행해야한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>소프트웨어 시스템의 아키텍처란?&lt;/strong>&lt;/p>
&lt;p>시스템을 구축했던 사람들이 만들어낸 시스템의 형태로 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라 정해진다.&lt;/p>
&lt;p>이러한 시스템 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다.&lt;/p>
&lt;blockquote>
&lt;p>개발, 배포, 운영, 유지보수를 용이하게 만들기 위해서는 가능한 한 많은 선택지를, 가능한 한 오래 남겨두는 전략을 따라야한다.&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>시스템 아키텍처는 시스템의 동작 여부와는 거의 관련이 없다.&lt;/p>
&lt;ul>
&lt;li>형편없는 아키텍처를 갖춤 시스템도 수없이 많지만, 그런데로 잘 동작한다.&lt;/li>
&lt;li>이러한 경우 대체로 운영에서는 문제가 없지만 배포, 유지보수, 계속되는 개발 과정에서 어려움을 겪는다.&lt;/li>
&lt;/ul>
&lt;p>시스템 아키텍처가 시스템이 제대로 동작하는 것과는 직접적으로 관련이 없지만, 시스템이 제대로 동작하도록 &lt;strong>지원&lt;/strong>한다(간접적).&lt;/p>
&lt;ul>
&lt;li>시스템을 쉽게 이해할 수 있게 한다.&lt;/li>
&lt;li>쉽게 개발할 수 있게 한다.&lt;/li>
&lt;li>쉽게 유지보수할 수 있게 한다.&lt;/li>
&lt;li>쉽게 배포하게 해준다.&lt;/li>
&lt;/ul>
&lt;p>아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다. 궁극적으로 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.&lt;/p>
&lt;h2 id="개발">개발&lt;/h2>
&lt;p>시스템 아키텍처는 개발팀(들)이 시스템을 쉽게 개발할 수 있도록 뒷받침해야만 한다.&lt;/p>
&lt;p>&lt;strong>팀 구조&lt;/strong>&lt;/p>
&lt;p>팀 구조가 다르다면 아키텍처 관련 결정에서도 차이가 난다.&lt;/p>
&lt;ul>
&lt;li>작은 규모
&lt;ul>
&lt;li>팀 규모가 작아 상위 구조로 인한 장애물이 없기를 바라기 때문에 아키텍처 없이 시작하는 경우가 많다.&lt;/li>
&lt;li>잘 정의된 컴포넌트나 인터페이스가 없더라도 서로 효율적으로 협력하여 모노리틱 시스템을 개발할 수 있다.&lt;/li>
&lt;li>개발 초기에는 아키텍처 관련 제약들이 오히려 방해가 된다고 여길 가능성이 높다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>큰 규모
&lt;ul>
&lt;li>다른 요소를 고려하지 않는다면 아키텍처는 팀별 단일 컴포넌트(큰 관심사 별 컴포넌트)로 각각 발전될 가능성이 높다.&lt;/li>
&lt;li>팀별 단일 컴포넌트 아키텍처는 시스템을 배포, 운영, 유지보수하는 데 최적은 아닐 확률이 높다.&lt;/li>
&lt;li>시스템을 신뢰할 수 있고 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리하지 않으면 개발이 진척되지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="배포">배포&lt;/h2>
&lt;p>배포 비용이 높을수록 시스템의 유용성은 떨어진다.&lt;/p>
&lt;p>따라서 소프트웨어 아키텍처는 시스템을 단 한번에 쉽게 배포할 수 있도록 만드는 데 그 목표를 두어야 한다.&lt;/p>
&lt;ul>
&lt;li>초기 개발 단계에서는 배포 전략을 거의 고려하지 않기 때문에 개발하기는 쉬워도 배포하기는 어려운 아키텍처가 만들어진다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>마이크로서비스 아키텍처 micro-service architecture&lt;/strong>&lt;/p>
&lt;p>컴포넌트 경계가 매우 뚜렷해지고, 인터페이스가 대체로 안정화되므로 시스템을 매우 쉽게 개발할 수 있다.&lt;/p>
&lt;p>하지만 늘어난 수많은 마이크로서비스로인해 서로 연결하기 위해 설정하고 작동 순서를 결정하는 과정에서 오작동이 발생할 원천이 스며들어 배포하기 어려워진다.&lt;/p>
&lt;hr>
&lt;p>아키텍트가 배포 문제를 초기에 고려했다면, 더 적은 서비스를 사용하고, 서비스 컴포넌트와 프로세스 수준의 컴포넌트를 하이브리드 형태로 융합하며, 좀 더 통합된 도구를 사용해 상호 연결을 관리했을 것이다.&lt;/p>
&lt;h2 id="운영">운영&lt;/h2>
&lt;p>아키텍처가 시스템 운영에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향보다는 &lt;strong>덜 극적&lt;/strong>이다.&lt;/p>
&lt;p>운영에서 겪는 대다수의 어려움은 단순히 하드웨어를 더 투입해서 해결할 수 있다.&lt;/p>
&lt;ul>
&lt;li>소프트웨어 아키텍처가 비효율적이라면 스토리자와 서버를 추가하는 것만으로 제대로 동작하도록 만들 수 있을 때가 많다.&lt;/li>
&lt;li>하드웨어는 값싸고 인력은 비싸다.&lt;/li>
&lt;/ul>
&lt;p>운영 관점에서 소프트웨어 아키텍처는 비용 공식 관점에서 보다는 개발, 배포 유지보수 쪽으로 더 기운다는 의미를 가진다.&lt;/p>
&lt;p>&lt;strong>운영 방식&lt;/strong>&lt;/p>
&lt;p>시스템 아키텍처가 개발자에게 시스템의 운영 방식을 잘 드러내 준다.&lt;/p>
&lt;p>좋은 소프트웨어 아키텍처는 시스템을 운영하는 데 필요한 요구도 알려준다.&lt;/p>
&lt;ul>
&lt;li>유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시킨다.&lt;/li>
&lt;li>위 요소가 개발자에게 주요 목표로 인식되도록 해야한다.&lt;/li>
&lt;/ul>
&lt;p>이를 통해 시스템을 이해하기 쉬워지며, 따라서 개발과 유지보수에 큰 도움이 된다.&lt;/p>
&lt;h2 id="유지보수">유지보수&lt;/h2>
&lt;p>유지보수는 모든 측면에서 소프트웨어 시스템에서 가장 많은 비용이 발생한다.&lt;/p>
&lt;p>유지보수의 가장 큰 비용은 &lt;strong>탐사 spelunking&lt;/strong>와 &lt;strong>이로 인한 위험부담&lt;/strong>에 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>탐사란?&lt;/strong>&lt;/p>
&lt;p>기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 소프트웨어를 파헤쳐서 어디를 고치는 게 최선인지, 어떤 전략을 쓰는 게 최적일지를 결정할 때 드는 비용&lt;/p>
&lt;/blockquote>
&lt;p>변경사항을 반영할 때 의도치 않은 결함이 발생할 가능성은 항상 존재하며, 이로인한 위험부담 비용이 추가된다.&lt;/p>
&lt;p>주의를 기울여 신중하게 아키텍처를 만들면 이 비용을 크게 줄일 수 있다.&lt;/p>
&lt;ul>
&lt;li>시스템을 컴포넌트로 분리&lt;/li>
&lt;li>안정된 인터페이스를 두어 서로 격리&lt;/li>
&lt;/ul>
&lt;p>이를 통해 미래에 추가될 기능에 대한 길을 밝혀 둘 수 있을 뿐만 아니라 의도치 않은 장재가 발생할 위험을 크게 줄일 수 있다.&lt;/p>
&lt;h2 id="선택사항-열어두기">선택사항 열어두기&lt;/h2>
&lt;p>책 초반에 언급했듯, 소프트웨어는 행위적 가치와 구조적 가치를 지니며, 아키텍처 관점에서 구조적 가치를 추구해야한다.&lt;/p>
&lt;p>소프트웨어를 만든 이유는 기계의 행위를 빠르고 쉽게 변경하는 방법이 필요했기 때문인데, 이러한 유연성은 &lt;strong>시스템의 형태&lt;/strong>, &lt;strong>컴포넌트의 배치 방식&lt;/strong>, &lt;strong>컴포넌트가 상호 연결되는 방식&lt;/strong>에 상당히 크게 의존한다.&lt;/p>
&lt;p>소프트웨어의 유연성을 유지하는 방법은 선택사항(세부사항)을 &lt;strong>가능한 한 많이&lt;/strong>, &lt;strong>가능한 한 오랫동안&lt;/strong> 열어두는 것이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>정책과 세부사항&lt;/strong>&lt;/p>
&lt;p>모든 소프트웨어 시스템은 정책과 세부사항으로 분해할 수 있다.&lt;/p>
&lt;ul>
&lt;li>정책
&lt;ul>
&lt;li>모든 업무 규칙과 업무 절차를 구체화한다.&lt;/li>
&lt;li>시스템의 진정한 가치가 살아있는 곳&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>세부사항
&lt;ul>
&lt;li>사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소&lt;/li>
&lt;li>정책이 가진 행위에는 조금도 영향을 미치지 않는다.&lt;/li>
&lt;li>입출력 장치, DB, 웹 시스템, 서버, 프레임워크, 프로토콜 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 데 있다.&lt;/p>
&lt;p>이를 통해 세부사항을 결정하는 일은 미루거나 연기할 수 있게 된다.&lt;/p>
&lt;p>&lt;strong>예시&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>개발 초기에는 데이터베이스 시스템을 선택할 필요가 없다.
&lt;ul>
&lt;li>고수준의 정책을 데이터베이스가 관계형인지, 분산형인지, 계층형인지 등에 관계 없도록 만들어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개발 초기에는 웹 서버를 선택할 필요가 없다.
&lt;ul>
&lt;li>고수준의 정책은 자신이 웹을 통해 전달된다는 사실을 알아서는 안 된다.&lt;/li>
&lt;li>웹 개발 기술들에 대해 고수준의 정책이 전혀 알지 못하게 만들면, 프로젝트 후반까지는 어떤 종류의 웹 시스템을 사용할지를 결정하지 않아도 된다.&lt;/li>
&lt;li>시스템을 웹을 통해 전송할 것인지조차도 결정할 필요가 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개발 초기에는 REST를 적용할 필요가 없다.
&lt;ul>
&lt;li>고수준의 정책은 외부 세계로의 인터페이스에 대해 독립적이어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>의존성 주입 프레임워크를 적용할 필요가 없다.
&lt;ul>
&lt;li>고수준의 정책은 의존성을 해석하는 방식에 대해 신경써서는 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>세부사항에 몰두하지 않은 채 고수준의 정책을 만들 수 있다면, 이러한 세부사항에 대한 결정을 오랫동안 미루거나 연기할 수 있다.&lt;/p>
&lt;ul>
&lt;li>이러한 결정을 더 오래 참을 수 있다면, 더 많은 정보를 얻을 수 있고, 이를 기초로 제대로 된 결정을 내릴 수 있다.&lt;/li>
&lt;li>선택사항을 더 오랫동안 열어 둘 수 있다면 더 많은 실험을 해볼 수 있고 더 많은 것을 시도할 수 있다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>좋은 아케텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다.&lt;/p>
&lt;p>이를 통해 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다.&lt;/p>
&lt;p>좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.&lt;/p></description></item></channel></rss>