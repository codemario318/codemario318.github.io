<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Redis on Mario Blog</title><link>https://codemario318.github.io/tags/redis/</link><description>Recent content in Redis on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Sun, 18 Aug 2024 15:59:50 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/redis/index.xml" rel="self" type="application/rss+xml"/><item><title>2. 주변 친구</title><link>https://codemario318.github.io/post/system-design-interview-2/2/</link><pubDate>Sun, 18 Aug 2024 15:59:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/2/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/cover.png" alt="Featured image of post 2. 주변 친구" />&lt;p>이번 장에서는 &lt;strong>주변 친구&lt;/strong>(&lt;strong>nearby friends&lt;/strong>)라는 모바일 앱 기능을 지원하는 규모 확장이 용이한 백엔드 시스템을 설계해본다.&lt;/p>
&lt;blockquote>
&lt;p>앱 사용자 가운데 본인 위치 정보 접근 권한을 허락한 사용자에 한에 인근의 친구 목록을 보여주는 시스템&lt;/p>
&lt;/blockquote>
&lt;p>1장 &lt;strong>근접성 서비스&lt;/strong>와 &lt;strong>주변 친구&lt;/strong> 는 비슷해 보이지만 큰 차이가 있다.&lt;/p>
&lt;ul>
&lt;li>근접성 서비스의 사업장 주소는 정적이다.&lt;/li>
&lt;li>주변 친구 위치는 자주 바뀐다.&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>페이스북 규모를 지원하는 백엔드 시스템은 복잡하다. 따라서 설계 시작 전 질문을 통해 설계 범위를 좁혀야한다.&lt;/p>
&lt;ul>
&lt;li>Q. 지리적으로 얼마나 가까워야 &lt;strong>주변에 있다&lt;/strong>고 할 수 있는가?
&lt;ul>
&lt;li>A. 5마일. 이 수치는 설정 가능해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 두 사용자 사이의 직선 거리라고 가정?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 얼마나 많은 사용자가 이 앱을 사용하는가? 10억명을 가넝하고, 그 가운데 10% 정도가 이 기능을 활용한다고 생각해도 괜찮은가?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 사용자의 이동 이력을 보관해 둬야하는가?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 친구 관계에 있는 사용자가 10분 이상 비활성 상태면 해당 사용자를 주변 친구 목록에서 사라지도록 해야하는가? 마지막 확인 위치를 표시하는가?
&lt;ul>
&lt;li>A. 사라지게 할 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. GDPR, CCPA 같은 사생활 및 데이터 보호법도 고려해야하는가?
&lt;ul>
&lt;li>A. 과정이 너무 복잡해질 수 있으므로 배제&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="기능-요구사항">기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>사용자는 모바일 앱에서 &lt;strong>주변 친구를 확인&lt;/strong>할 수 있어야 한다.
&lt;ul>
&lt;li>&lt;strong>해당 친구까지의 거리&lt;/strong> 표시&lt;/li>
&lt;li>정보가 &lt;strong>마지막으로 갱신된 시간&lt;/strong>이 함께 표시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이 친구 목록은 &lt;strong>몇 초마다 한번 씩 갱신&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>낮은 지연 시간&lt;/strong>(low latency)
&lt;ul>
&lt;li>주변 친구의 위치 변화가 반영되는 데 너무 오랜 시간이 걸리지 않아야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>안정성&lt;/strong>
&lt;ul>
&lt;li>전반적으로 안정적이어야 하지만, 가끔 몇 개 데이터가 유실되는 것 정도는 용인 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>결과정 일관성&lt;/strong>
&lt;ul>
&lt;li>위치 데이터를 저장하기 위해 강한 일관성을 지원하는 데이터 저장소를 사용할 필요는 없다.&lt;/li>
&lt;li>복제본의 데이터가 원본과 동일하게 변경되기까지 몇 초 정도 걸리는 것은 용인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;p>제시할 솔루션이 풀어야 할 도전적 과제를 결정하기 위해, 개략적으로 문제 규모를 추정한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>주변 친구&lt;/strong>는 5마일(8km) 반경 이내 친구로 정의&lt;/li>
&lt;li>위치 정보는 &lt;strong>30초&lt;/strong> 주기로 갱신
&lt;ul>
&lt;li>사람의 걷는 속도가 &lt;code>4-6km/h&lt;/code> 정도로 느림&lt;/li>
&lt;li>30초 주기라면 주변 친구 검색 결과가 크게 달라지지는 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>평균적으로 매일 주변 친구 검색 기능을 활용하는 사용자는 &lt;strong>1억명&lt;/strong>으로 가정&lt;/li>
&lt;li>동시 접속 사용자의 수는 **DAU의 10%**로 가정
&lt;ul>
&lt;li>&lt;strong>천만명&lt;/strong>이 동시에 시스템을 이용한다고 가정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>평균적으로 한 사용자는 &lt;strong>400명&lt;/strong>의 친구를 갖는다고 가정&lt;/li>
&lt;li>모든 친구가 주변 친구 검색 기능을 활용한다고 가정&lt;/li>
&lt;li>이 기능을 제공하는 앱은 한 페이지당 20명의 주변 친구를 표시&lt;/li>
&lt;li>사용자의 요청이 있다면 더 많은 주변 친구를 노출&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>QPS 계산&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>1억 DAU&lt;/li>
&lt;li>동시 접속 사용자: &lt;code>10% * 1억 = 천만&lt;/code>&lt;/li>
&lt;li>사용자는 30초마다 자기 위치를 시스템에 전송&lt;/li>
&lt;li>&lt;code>위치 정보 갱신 QPS = 천만 / 30 = ~334,000&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>위치 정보를 모든 친구에게 전송해야 한다는 요구사항으로 인해 클라이언트와 서버 사이의 통신 프로토콜로 단순한 HTTP 프로토콜을 사용하지 못하게 될 수 있음을 감안해야한다.&lt;/p>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>이번 문제는 &lt;strong>메시지의 효과적 전송을 가능케 할 설계얀&lt;/strong>을 요구한다.&lt;/p>
&lt;p>개념적으로 보면 사용자는 근방의 모든 활성 상태 친구의 새 위치 정보를 수신하고자 한다. 이론적으로 순수한 P2P(peer-to-peer) 방식으로도 해결 가능한 문제이다.&lt;/p>
&lt;p>다시 말해, &lt;strong>활성 상태인 근방 모든 친구와 항구적 통신 상태를 유지&lt;/strong>하면 되는 것이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img.png"
width="898"
height="582"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_hudccc12625b6529e9eab4e26e4b039577_67180_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_hudccc12625b6529e9eab4e26e4b039577_67180_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="154"
data-flex-basis="370px"
>&lt;/p>
&lt;p>P2P 통신은 실용적인 아이디어는 아니지만 &lt;strong>추구해야 할 설계 방향에 대한 통찰&lt;/strong>은 얻을 수 있다.&lt;/p>
&lt;p>이보다 조금 더 실용적인 설계안은 &lt;strong>공용 백엔드&lt;/strong>를 사용하는 것이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_1.png"
width="1184"
height="552"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_1_hu5459bc5b3622841e964dbbf3c2d834b0_49710_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_1_hu5459bc5b3622841e964dbbf3c2d834b0_49710_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="214"
data-flex-basis="514px"
>&lt;/p>
&lt;p>백엔드는 다음과 같은 역할을 담당한다.&lt;/p>
&lt;ul>
&lt;li>모든 활성 상태 사용자의 위치 변화 내역을 수신&lt;/li>
&lt;li>사용자 위치 변경 내역을 수신할 때마다 해당 사용자의 모든 활성 상태 친구를 찾아 그 친구들의 단말로 변경 내역을 전달
&lt;ul>
&lt;li>두 사용자 사이의 거리가 특정 임계치보다 먼 경우 변경 내역을 전송하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>간단해 보이지만 문제의 가정이 활성 상태의 동시 접속 사용자 천만 명이므로 &lt;strong>큰 규모에 적용하기가 쉽지 않다&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>천만명이 자기 위치 정보를 30초마다 갱신하면 &lt;strong>334,000번&lt;/strong>의 위치 정보 갱신 처리가 필요하다.&lt;/li>
&lt;li>사용자 1명은 400명의 친구를 가지고, 그 중 10%가 인근에서 활성화 상태라면, 초당 &lt;code>334,000 * 400 * 10% = 1400만&lt;/code> 건의 위치 정보 갱신 요청을 처리해야한다.&lt;/li>
&lt;li>엄청난 양의 갱신 내역을 사용자 단말로 보내야한다.&lt;/li>
&lt;/ul>
&lt;h3 id="설계안">설계안&lt;/h3>
&lt;p>우선 소규모 백엔드를 위한 개략적 설계안에서 시작하여 더 큰 규모에 맞게 확장해나간다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_2.png"
width="1422"
height="1266"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="269px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>로드 밸런서&lt;/strong>&lt;/p>
&lt;p>&lt;strong>RESTful API&lt;/strong> 서버 및 양방향 유상태 웹소켓 서버 앞단에 위치한다.&lt;/p>
&lt;p>부하를 고르게 분산하기 위해 &lt;strong>트래픽을 서버들에 배분&lt;/strong>하는 역할을 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>RESTful API 서버&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>무상태 API 서버의 클러스터&lt;/li>
&lt;li>통상적인 요청/응답 트래픽을 처리&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>친구를 추가/삭제&lt;/strong>하거나 &lt;strong>사용자 정보를 갱신&lt;/strong>하는 등의 부가적인 작업을 처리한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>웹소켓 서버&lt;/strong>&lt;/p>
&lt;p>친구 위치 정보 변경을 거의 실시간에 가깝게 처리하는 &lt;strong>유상태 서버 클러스터&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>각 클라이언트는 클러스터 내 한 대 서버와 웹소켓 연결은 지속적으로 유지&lt;/li>
&lt;li>검색 반경 내 친구 위치가 변경되면 해당 내역은 이 연결을 통해 클라이언트로 전송&lt;/li>
&lt;li>주변 친구 기능을 이용하는 클라이언트의 초기화 담당
&lt;ul>
&lt;li>온라인 상태인 모든 주변 친구 위치를 해당 클라이언트로 전송&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>레디스 위치 정보 캐시&lt;/strong>&lt;/p>
&lt;p>활성 상태 사용자의 가장 최근 위치 정보를 캐시하는 데 사용한다.&lt;/p>
&lt;ul>
&lt;li>레디스에 보관하는 캐시 항목에는 TTL(Time-To-Live) 필드가 있어, 설정한 기간이 지나면 해당 사용자는 비활성으로 바뀌고 위치 정보는 캐시에서 삭제된다.&lt;/li>
&lt;li>캐시에 보관된 정보를 갱신할 때 TTL도 갱신한다.&lt;/li>
&lt;/ul>
&lt;p>레디스가 아니더라도 TTL을 지원하는 키-값 저장소는 캐시로 활용될 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>사용자 데이터 베이스&lt;/strong>&lt;/p>
&lt;p>&lt;strong>사용자 데이터&lt;/strong> 및 &lt;strong>사용자의 친구 관계 정보를 저장&lt;/strong>한다.&lt;/p>
&lt;p>관계형 데이터베이스, NoSQL 어느 쪽이든 사용 가능하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>위치 이동 이력 데이터베이스&lt;/strong>&lt;/p>
&lt;p>사용자의 위치 변동 이력을 보관한다.&lt;/p>
&lt;p>주변 친구 표시와 직접 관계된 기능은 아니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>레디스 펍/섭 서버&lt;/strong>&lt;/p>
&lt;p>레디스 펍/섭은 &lt;strong>초경량 메시지 버스&lt;/strong>(message bus)다.&lt;/p>
&lt;ul>
&lt;li>레디스 펍/섭에 새로운 채널을 생성하는 것은 아주 값싼 연결이다.&lt;/li>
&lt;li>기가바이트급 메모리를 갖춘 최신 레디스 서버에는 수백만 개의 채널(토픽)을 생성할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_4.png"
width="1380"
height="740"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_4_hu84b0294fda6052ece73743e1e4417308_92336_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_4_hu84b0294fda6052ece73743e1e4417308_92336_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="186"
data-flex-basis="447px"
>&lt;/p>
&lt;ol>
&lt;li>웹소켓 서버를 통해 수신한 &lt;strong>특정 사용자의 위치 정보 변경 이벤트&lt;/strong>는 &lt;strong>해당 사용자에게 배정된 펍/섭 채널에 발행&lt;/strong>한다.
&lt;ul>
&lt;li>해당 사용자의 친구 각각과 연결된 웹소켓 연결 핸들러는 해당 채널의 구독자로 설정되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>특정 사용자의 위치가 바뀌면 해당 사용자의 모든 친구의 웹소켓 연결 핸들러가 호출된다.&lt;/li>
&lt;li>핸들러는 위치 변경 이벤트를 수신할 친구가 활성 상태면 거리를 다시 계산한다.
&lt;ul>
&lt;li>검색 반경 이내면 갱신된 위치와 갱신 시간을 웹소켓 연결을 통해 해당 친구의 클라이언트 앱으로 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>다른 메시지 버스 기술도 경량의 통신 채널만 제공한다면 같은 형태로 사용 가능하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>주기적 위치 갱신&lt;/strong>&lt;/p>
&lt;p>모바일 클라이언트는 항구적으로 유지되는 웹소켓 연결을 통해 주기적으로 위치 변경 내역을 전송한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_2.png"
width="1422"
height="1266"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="269px"
>&lt;/p>
&lt;ol>
&lt;li>모바일 클라이언트가 위치가 변경된 사실을 로드밸런서에 전송&lt;/li>
&lt;li>로드밸런서는 그 위치 변경 내역을 해당 클라이언트와 웹소켓 서버 사이에 설정된 연결을 통해 웹소켓 서버로 보냄&lt;/li>
&lt;li>아래 작업을 병렬로 수행
&lt;ul>
&lt;li>웹소켓 서버는 해당 이벤트를 위치 이동 이력 데이터베이스에 저장&lt;/li>
&lt;li>웹소켓 서버는 새 위치를 위치 정보 캐시에 보관
&lt;ul>
&lt;li>TTL도 새롭게 갱신&lt;/li>
&lt;li>웹소켓 연결 핸들러 안의 변수에 해당 위치를 반영(거리 계산에 활용)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹소켓 서버는 레디스 펍/섭 서버의 해당 사용자 채널에 새 위치를 발행&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>레디스 펍/섭 채널에 발행된 새로운 위치 변경 이벤트는 모든 구독자(웹소켓 이벤트 핸들러)에게 브로드캐스트된다.
&lt;ul>
&lt;li>구독자는 위치 변경 이벤트를 보낸 사용자의 온라인 상태 친구들&lt;/li>
&lt;li>구독자의 웹소켓 연결 핸들러는 친구의 위치 변경 이벤트를 수신&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지를 받는 웹 소켓 서버, 즉 웹 소켓 연결 핸들러가 위치한 웹 소켓 서버는 새 위치를 보낸 사용자와 메시지를 받은 사용자 사이의 거리를 새로 계산
&lt;ul>
&lt;li>검색 반경을 넘지 않는다면 새 위치 및 해당 위치로의 이동이 발생한 시각을 나타내는 타임스탬프를 해당 구독자의 클라이언트 앱으로 전송&lt;/li>
&lt;li>넘은 경우에는 보내지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_5.png"
width="1362"
height="1182"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_5_huf8fa9909ecee52bd94a35a1416186d93_155836_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_5_huf8fa9909ecee52bd94a35a1416186d93_155836_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="276px"
>&lt;/p>
&lt;ol>
&lt;li>사용자 1의 위치가 변경되면 그 변경 내역은 사용자 1과의 연결을 유지하고 있는 웹소켓 서버에 전송됨&lt;/li>
&lt;li>해당 변경 내역은 레디스 펍/섭 서버 내의 사용자 1 전용 채널로 발행&lt;/li>
&lt;li>레디스 펍/섭 서버는 해당 변경 내역을 모든 구독자에게 브로드캐스트한다.
&lt;ul>
&lt;li>구독자는 사용자 1과 친구 관계에 있는 모든 웹소켓 연결 핸들러&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>위치 변경 내역을 보낸 사용자와 구독자 사이의 거리(사용자 1과 2 사이의 거리)가 검색 반경을 넘지 않을 경우 새로운 위치는 사용자 2의 클라이언트로 전송&lt;/li>
&lt;/ol>
&lt;p>이 계산 과정은 해당 채널의 모든 구독자에게 반복 적용된다.&lt;/p>
&lt;ul>
&lt;li>한 사용자의 위치가 바뀔 때마다 이치 정보 전송은 40건 정도 발생할 것이다.&lt;/li>
&lt;/ul>
&lt;h3 id="api-설계">API 설계&lt;/h3>
&lt;p>필요한 API를 나열해본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>웹소켓&lt;/strong>&lt;/p>
&lt;p>사용자는 웹소켓 프로토콜을 통해 위치 정보 변경 내역을 전송하고 수신하므로, 최소한 다음 API는 구비되어야 한다.&lt;/p>
&lt;ul>
&lt;li>[서버 API] 주기적인 위치 정보 갱신
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>위도, 경도, 시각 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[클라이언트 API] 클라이언트가 갱신된 친구 위치를 수신하는 데 사용할 API
&lt;ul>
&lt;li>전송되는 데이터
&lt;ul>
&lt;li>친구 위치 데이터와 변경된 시각을 나타내는 타임스탬프&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[서버 API] 웹소켓 초기화 API
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>위도, 경도, 시각 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>자기 친구들의 위치 데이터&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[클라이언트 API] 새 친구 구독 API
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>친구 ID&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>가장 최근의 위도, 경도, 시각 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[클라이언트 API] 구독 해지 API
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>친구 ID&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>HTTP 요청&lt;/strong>&lt;/p>
&lt;p>API 서버는 친구를 추가/삭제하거나 사용자 정보를 갱신하는 드으이 작업을 처리할 수 있어야 한다.&lt;/p>
&lt;p>아주 흔한 종류의 API이므로 상세한 내용은 다루지 않는다.&lt;/p>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>살펴봐야하는 중요한 주제중 하나는 데이터 모델이다.&lt;/p>
&lt;p>위치 정보 캐시와 위치 이동 이력 데이터베이스만 살펴본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>위치 정보 캐시&lt;/strong>&lt;/p>
&lt;p>위치 정보 캐시는 &lt;strong>주변 친구&lt;/strong>기능을 켠 활성 상태 친구의 가장 최근 위치를 보관한다.&lt;/p>
&lt;p>설계안에서는 레디스를 사용해 이 키새를 구현하며, 해당 캐시에 보관될 키/값 쌍은 아래와 같다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>키&lt;/th>
&lt;th>값&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>사용자 ID&lt;/td>
&lt;td>{위도, 경도, 시각}&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;p>&lt;strong>위치 정보 저장에 데이터베이스를 사용하지 않는 이유는?&lt;/strong>&lt;/p>
&lt;p>주변 친구 기능은 사용자의 &lt;strong>현재 위치&lt;/strong>만 사용하므로, 사용자 위치는 하나만 보관하면 충분하다.&lt;/p>
&lt;ul>
&lt;li>읽기 및 쓰기 연산 속도가 매우 빠르다.&lt;/li>
&lt;li>TTL을 지원하여 활성 상태가 아닌 사용자 정보를 자동으로 제거할 수 있다.&lt;/li>
&lt;li>활용하는 위치 정보는 영속성을 보장할 필요가 없다.&lt;/li>
&lt;li>장애 발생시 새 서버로 바꾼 후 갱신된 위치 정보가 캐시에 채워지기만 하면 충분하다.
&lt;ul>
&lt;li>캐시가 데워질 동안은 갱신 주기가 한두 번 정도 경과하여 변경 내역을 놓칠 수도 있지만 수용 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>위치 이동 이력 데이터베이스&lt;/strong>&lt;/p>
&lt;p>위치 이동 이력 데이터베이스는 사용자의 위치 정보 변경 이력을 다음 스키마를 따르는 테이블에 저장한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>user_id&lt;/th>
&lt;th>latitude&lt;/th>
&lt;th>longitude&lt;/th>
&lt;th>timestamp&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>필요로 하는 것은 &lt;strong>막대한 쓰기 연산 부하를 감당&lt;/strong>할 수 있고, &lt;strong>수평적 규모 확장이 가능&lt;/strong>한 데이터베이스다.&lt;/p>
&lt;p>&lt;strong>카산드라&lt;/strong>(Cassandra)는 이러한 요구에 잘 부합한다.&lt;/p>
&lt;ul>
&lt;li>관계형 데이터 베이스도 사용할 수는 있으나 &lt;strong>이력 데이터의 양이 서버 한 대에 보관하기에는 너무 많을 수 있으므로 샤딩이 필요하다&lt;/strong>.
&lt;ul>
&lt;li>사용자 ID를 기준 삼는 샤딩 방안이 가장 기본&lt;/li>
&lt;li>부하를 모든 샤드에 고르게 분산시킬 수 있고, 데이터베이스 운영 관리도 간편하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>개략적 설계안은 대부분의 경우 통하지만, 주어진 문제의 규모를 감당하기는 어려울 것이다.&lt;/p>
&lt;p>이번 절에서는 규모를 늘려 나가면서 병목 및 해결책을 찾는데 집중한다.&lt;/p>
&lt;h3 id="중요-구성요소별-규모-확장성">중요 구성요소별 규모 확장성&lt;/h3>
&lt;h4 id="api-서버">API 서버&lt;/h4>
&lt;p>RESTful API 서버의 규모 확장 방법은 널리 알려져있다.&lt;/p>
&lt;p>본 설계안의 API 서버는 무상태로 이런 서버로 구성된 클러스터의 규모를 CPU 사용률이나 부하, I/O 상태에 따라 자동으로 늘리는 방법은 다양하다.&lt;/p>
&lt;h4 id="웹소켓-서버">&lt;strong>웹소켓 서버&lt;/strong>&lt;/h4>
&lt;p>웹소켓 클러스터도 사용률에 따라 규모를 자동으로 늘리는 것은 그다지 어렵지 않다.&lt;/p>
&lt;p>하지만 웹소켓 서버는 &lt;strong>유상태&lt;/strong> 서버라 기존 서버를 제거할 때는 주의가 필요하다.&lt;/p>
&lt;ul>
&lt;li>노드를 제거하기 전 기존 연결부터 종료될 수 있도록 해야한다.
&lt;ul>
&lt;li>로드 밸런서가 인식하는 노드 상태를 **연결 종료 중(draining)**으로 변경해둔다.&lt;/li>
&lt;li>해당 서버로는 새로운 웹소켓 연결이 만들어지지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모든 연결이 종료되면(충분한 시간이 흐른 후) 서버를 제거한다.&lt;/li>
&lt;/ul>
&lt;p>웹소켓 서버에 새로운 버전의 애플리케이션 소프트웨어를 설치할 때도 마찬가지로 유의해야한다.&lt;/p>
&lt;blockquote>
&lt;p>유상태 서버 클러스터의 규모를 자동으로 확장하려면 좋은 로드밸런서가 있어야한다.&lt;/p>
&lt;/blockquote>
&lt;p>대부분의 클라우드 로드밸런서는 이런 일을 잘 처리한다.&lt;/p>
&lt;h4 id="클라이언트-초기화">&lt;strong>클라이언트 초기화&lt;/strong>&lt;/h4>
&lt;p>모바일 클라이언트는 기동되면 웹소켓 클러스터 내의 서버 가운데 하나와 지속성 웹소켓 연결을 맺는다.&lt;/p>
&lt;ul>
&lt;li>연결이 오랜 시간 유지된다.&lt;/li>
&lt;li>현대적 프로그래밍 언어는 이런 연결 유지에 많은 메모리를 필요로 하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>웹소켓 연결이 초기화되면 클라이언트는 해당 모바일 단말의 위치, 즉 해당 단말을 이용중인 사용자의 위치 정보를 전송한다.&lt;/p>
&lt;p>그 정보를 받은 웹 소켓 연결 핸들러는 다음 작업을 수행한다.&lt;/p>
&lt;ol>
&lt;li>위치 정보 캐시에 보관된 해당 사용자의 위치를 갱신
&lt;ul>
&lt;li>해당 위치 정보는 뒤이은 계산 과정에 이용되므로, 연결 핸들러 내의 변수에 저장해둔다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자 데이터베이스를 뒤져 해당 사용자의 모든 친구 정보를 조회&lt;/li>
&lt;li>위치 정보 캐시에 일괄(batch) 요청을 보내 모든 친구의 위치를 한번에 조회
&lt;ul>
&lt;li>비활성화 친구의 위치는 캐시에 없을 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>친구 위치 각각에 대해, 해당 친구와 사용자 사이의 거리를 계산
&lt;ul>
&lt;li>검색 반경 이내면 해당 친구의 상세 정보, 위치, 마지막으로 확인된 사각을 웹소켓 연결을 통해 클라이언트에 반환&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 친구의 레디스 서버 펍/섭 채널을 구독
&lt;ul>
&lt;li>채널 생성 및 구독 비용이 저렴하므로 활성 상태에 관계없이 모든 친구 채널을 구독할 수 있음&lt;/li>
&lt;li>비활성화 친구의 채널을 유지하기 위해 메모리가 필요하지만 매우 적고, 활성 전까지 CPU나 I/O를 전혀 이용하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자의 현재 위치를 레디스 펍/섭 서버의 전용 채널을 통해 모든 친구에게 전송&lt;/li>
&lt;/ol>
&lt;h4 id="사용자-데이터베이스">&lt;strong>사용자 데이터베이스&lt;/strong>&lt;/h4>
&lt;p>사용자 데이터베이스에는 두 가지 종류의 데이터가 보관된다.&lt;/p>
&lt;ul>
&lt;li>사용자 ID, 사용자명, 프로파일 이미지의 URL 등 사용자 상세 정보(프로필 데이터)&lt;/li>
&lt;li>친구 관계 데이터&lt;/li>
&lt;/ul>
&lt;p>이번 장에서 다루는 설계안의 규모를 감안하면 한 대의 관계형 데이터베이스 서버로는 감당할 수 없으나, 사용자 ID를 기준으로 데이터를 샤딩하면 관계형 데이터베이스라 해도 수평적 규모 확장이 가능하다.&lt;/p>
&lt;p>설계하고 있는 규모의 시스템을 실제로 운영하려면 사용자 및 친구 데이터를 관리하는 팀이 따로 필요할 것이다.&lt;/p>
&lt;p>웹소켓 서버는 데이터베이스를 직접 질의하는 대신 API를 호출하여 사용자 및 친구 관계 데이터를 가져와야 한다.&lt;/p>
&lt;h4 id="위치-정보-캐시">&lt;strong>위치 정보 캐시&lt;/strong>&lt;/h4>
&lt;p>활성화 상태 사용자의 위치 정보를 캐시하기 위해 레디스를 활용한다.&lt;/p>
&lt;ul>
&lt;li>각 항목의 키에는 TTL을 설정한다.
&lt;ul>
&lt;li>사용자의 위치 정보가 갱신될 때마다 초기화된다.&lt;/li>
&lt;li>따라서 최대 메모리 사용량은 일정 한도 아래로 유지된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>하지만 천 만명의 활성 사용자가 대략 30초마다 변경된 위치 정보를 전송한다고 가정하면 레디스 서버가 감당해야 하는 갱신 연산의 수는 초당 334K에 달하게되는데, 최신 고사양 서버를 쓴다 해도 부담되는 수치이다.&lt;/p>
&lt;p>다행히도 각 사용자의 위치 정보는 서로 독립적인 데이터이므로 사용자 ID를 기준으로 여러 서버에 샤딩하면 부하 또한 고르게 분배할 수 있다.&lt;/p>
&lt;ul>
&lt;li>가용성을 높이려면 각 샤드에 보고나하는 위치 정보를 대기(standby) 노드에 복제해 두면 된다.&lt;/li>
&lt;/ul>
&lt;h4 id="레디스-펍섭-서버">&lt;strong>레디스 펍/섭 서버&lt;/strong>&lt;/h4>
&lt;p>본 설계안에서 펍/섭 서버를 모든 온라인 친구에게 보내는 위치 변경 내역 메시지의 라우팅(routing)계층으로 활용한다.&lt;/p>
&lt;p>레디스 펍/섭 서버를 사용하는 이유는 채널을 만들고 유지하는 비용이 매우 저렴하기 때문이다.&lt;/p>
&lt;ul>
&lt;li>새 채널은 구독하려는 채널이 없을 때 생성한다.&lt;/li>
&lt;li>구독자가 없는 채널로 전송되 메시지는 그대로 버려지는데, 서버에 가해지는 부하는 거의 없다.&lt;/li>
&lt;li>채널 하나를 유지하기 위해서는 구독자 관계를 추적하기 위한 해시 테이블과 연결 리스트가 필요한데 아주 소량의 메모리만 사용한다.&lt;/li>
&lt;li>오프라인 사용자라 어떤 변경도 없는 채널의 경우에는 생성된 이후에 CPU 자원은 전혀 사용하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>본 설계안은 그 점을 활용하여 주변 친구 기능을 활용하는 모든 사용자에 채널 하나씩을 부여한다.&lt;/p>
&lt;ul>
&lt;li>해당 기능을 사용하는 사용자의 앱은 초기화 시에 모든 친구의 채널과 구독 관계를 설정한다.(친구가 비활성이라도)&lt;/li>
&lt;/ul>
&lt;p>활성화 상태로 바뀐 친구의 채널을 구독하거나 비활성 상태가 된 친구의 채널을 구독 중단하는 작업이 필요 없어지므로 설계가 간단해진다.&lt;/p>
&lt;p>더 많은 메모리를 사용하게 되지만, 메모리가 병목이 될 가능성은 매우 낮다. 아키텍처를 단순하게 만들 수 잇다면 더 많은 메모리를 투입할 가치는 충분하다.&lt;/p>
&lt;h4 id="얼마나-많은-레디스-펍섭-서버가-필요한가">&lt;strong>얼마나 많은 레디스 펍/섭 서버가 필요한가?&lt;/strong>&lt;/h4>
&lt;p>&lt;strong>메모리 사용량&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>주변 친구 찾기를 사용하는 모든 사용자에게 채널 하나씩 할당하면 채널 수는 &lt;strong>1억&lt;/strong>개&lt;/li>
&lt;li>구독자 한 명을 추적하기 위해 내부 해시 테이블과 연결 리스트에 20바이트 상당의 포인터들을 저장해야함
&lt;ul>
&lt;li>&lt;code>1억 * 20바이트 * 100명 친구 / 10^9 = 200GB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>100GB 메모리 서버 2대로 충분하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>CPU 사용량&lt;/strong>&lt;/p>
&lt;p>펍/섭 서버가 구독자에게 전송해야하는 위치 정보 업데이트 양은 초당 1400만 건에 달한다.&lt;/p>
&lt;p>최신 레디스 서버 한 대로 얼마나 많은 메시지를 전송할 수 있는지 정확히 알 수는 없지만, 서버 한 대로는 곤란할것이다.&lt;/p>
&lt;ul>
&lt;li>보수적으로 기가비트 네트워크 카드를 탑재한 현대적 아키텍처의 서버 한 대로 감당 가능한 구독자의 수는 100,000이라고 가정&lt;/li>
&lt;/ul>
&lt;p>이 추정치에 따르면 필요한 레디스 서버의 수는 &lt;code>1400만 / 100,000 = 140&lt;/code>이다.&lt;/p>
&lt;hr>
&lt;p>위 계산 결과를 통해 다음과 같은 결론을 내릴 수 있다.&lt;/p>
&lt;ul>
&lt;li>레디스 펍/섭 서버의 병목은 메모리가 아니라 CPU 사용량이다.&lt;/li>
&lt;li>문제의 규모를 감당하려면 분산 레디스 펍/섭 클러스터가 필요하다.&lt;/li>
&lt;/ul>
&lt;h4 id="분산-레디스-펍섭-서버-클러스터">분산 레디스 펍/섭 서버 클러스터&lt;/h4>
&lt;p>모든 채널을 서로 독립적이므로, 메시지를 발행할 사용자 ID를 기준으로 펍/섭 서버들을 샤딩한다.&lt;/p>
&lt;p>하지만 현실적으로는 수백 대의 펍/섭 서버가 관련된 문제이므로 동작 방식을 상세하게 집어볼 필요가 있다.&lt;/p>
&lt;ul>
&lt;li>서버에는 필연적으로 장애가 생기게 마련이므로, 매끄러운 운영을 위해 필요하다.&lt;/li>
&lt;/ul>
&lt;p>본 설계안에서는 &lt;strong>서비스 탐색&lt;/strong>(Service discovery) 컴포넌트를 도입하여 이 문제를 푼다.&lt;/p>
&lt;ul>
&lt;li>etcd&lt;/li>
&lt;li>주키퍼(ZooKeeper)&lt;/li>
&lt;/ul>
&lt;p>서비스 탐색 컴포넌트의 아래 기능을 활용한다.&lt;/p>
&lt;ul>
&lt;li>가용한 서버 목록을 유지하는 기능 및 해당 목록을 갱신하는 데 필요한 UI나 API
&lt;ul>
&lt;li>서비스 탐색 소프트웨어는 설정 데이터를 보관하기 위한 소규모의 키-값 저장소라고 보면 된다.&lt;/li>
&lt;li>키: &lt;code>/config/pub_sub_ring&lt;/code>&lt;/li>
&lt;li>값: &lt;code>[&amp;quot;p_1&amp;quot;, &amp;quot;p_2&amp;quot;, &amp;quot;p_3&amp;quot;, &amp;quot;p_4&amp;quot;]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클라이언트(웹소켓 서버)로 하여금 값에 명시된 레디스 펍/섭 서버에서 발생한 변경 내역을 구독할 수 있도록 하는 기능&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_7.png"
width="1096"
height="1254"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_7_hufa309bd8978651d9dab23e4c65bb98ec_107318_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_7_hufa309bd8978651d9dab23e4c65bb98ec_107318_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="87"
data-flex-basis="209px"
>&lt;/p>
&lt;p>키에 매달린 값에는 &lt;strong>활성 상태의 모든 레디스 펍/섭 서버&lt;/strong>로 구성된 &lt;strong>해시 링&lt;/strong>을 보관한다.&lt;/p>
&lt;p>레디스 펍/섭 서버는 메시지를 발행할 채널이나 구독할 채널을 정해야 할 때 이 해시링을 참조한다.&lt;/p>
&lt;hr>
&lt;p>웹소켓 서버가 특정 사용자 채널에 위치 정보 변경 내역을 발행하는 과정은 아래와 같다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_6.png"
width="1236"
height="1358"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_6_hue0f6159084a4fbd8c7b86af586fea184_111737_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_6_hue0f6159084a4fbd8c7b86af586fea184_111737_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="91"
data-flex-basis="218px"
>&lt;/p>
&lt;ol>
&lt;li>해시 링을 참조하여 메시지를 발행할 레디스 펍/섭 서버를 선정한다.
&lt;ul>
&lt;li>정확한 정보는 서비스 탐색 컴포넌트에 보관되어 있으나 해시 링 사본을 웹소켓 서버에 캐시한다면 성능을 높힐 수 있다.&lt;/li>
&lt;li>그 경우 웹소켓 서버는 해시 링 원본에 구독 관례를 설정하여 사본을 원본과 동일하게 유지하도록 해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹소켓 서버는 해당 서버가 관리하는 사용자 채널에 위치 정보 변경 내역을 발행한다.&lt;/li>
&lt;/ol>
&lt;p>구독할 채널이 존재하는 레디스 펍/섭 서버를 찾는 과정도 이와 동일하다.&lt;/p>
&lt;h4 id="레디스-펍섭-서버-클러스터의-규모-확장-고려사항">레디스 펍/섭 서버 클러스터의 규모 확장 고려사항&lt;/h4>
&lt;p>무상태 서버라면 트래픽 피턴에 따라 크기를 늘리거나 줄이는 방법이 위험성이 낮고 비용을 절감하기도 좋아 널리 활용되지만, 레디스 펍/섭 서버 클러스터 특성으로 인해 고려하기 어렵다.&lt;/p>
&lt;p>펍/섭 채널에 전송되는 메시지는 메모리나 디스크에 지속적으로 보관되지않지만, 채널에 대한 상태 정보를 보관한다.(각 채널의 구독자 목록)&lt;/p>
&lt;p>따라서 특정한 채널을 담당하던 펍/섭 서버를 교체하거나 해시 링에서 제거하는 경우 기존 채널에 대한 구독 관계를 해지하고 새 서버에 마련된 대체 채널을 다시 구독하기 위해 &lt;strong>채널을 다른 서버로 이동&lt;/strong>시켜야 하고, &lt;strong>해당 채널의 모든 구독자에게 그 사실을 알려야한다&lt;/strong>.&lt;/p>
&lt;p>유상태 서버 클러스터의 규모를 늘리거나 줄이는 것은 운영 부담과 위험이 큰 작업이므로 주의 깊게 계획하고 진행해야한다.&lt;/p>
&lt;ul>
&lt;li>유상태 서버 클러스터는 혼잡 시간대 트래픽을 무리 없이 감당하고 불필요한 크기 변화를 피할 수 있도록 어느 정도 여유를 두고 오버 프로비저닝(over provisioning)하는 것이 일반적이다.&lt;/li>
&lt;/ul>
&lt;p>불가피하게 규모를 늘려야 할 때는 다음과 같은 문제가 발생할 수 있음에 유의하여야 한다.&lt;/p>
&lt;ul>
&lt;li>클러스터의 크기를 조정하면 많은 채널이 같은 해시 링 위의 다른 여러 서버로 이동한다.
&lt;ul>
&lt;li>서비스 탐색 컴포넌트가 모든 웹소켓 서버에 해시 링이 갱신되었음을 알리면 &lt;strong>엄청난 재구독&lt;/strong> 요청이 발생할 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>재구독 요청을 처리하다 보면 &lt;strong>클라이언트가 보내는 위치 정보 변경 메시지의 처리가 누락&lt;/strong>될 수 있다.
&lt;ul>
&lt;li>어느 정도는 허용할 수 있으나 빈도는 반드시 최소화해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서비스의 상태가 불안정해질 가능성이 있으므로 클러스터 크기 조정은 하루 중 시스템 부하가 가장 낮은 시간을 골라 시행한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>클러스터의 크기 조정 자체는 꽤 간단하다.&lt;/p>
&lt;ul>
&lt;li>새로운 링 크기를 계산한다.
&lt;ul>
&lt;li>크기가 늘어난다면 새 서버를 준비한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>해시 링의 키에 매달린 값을 새로운 내용으로 갱신한다.&lt;/li>
&lt;li>대시보드를 모니터링한다.
&lt;ul>
&lt;li>웹소켓 클러스터의 CPU 사용량이 어느 정도 튀는 것이 보여야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>p_5&lt;/code>, &lt;code>p_6&lt;/code> 두 노드가 추가된다면 해시 링은 다음과 같이 바뀐다.&lt;/p>
&lt;ul>
&lt;li>변경 전
&lt;ul>
&lt;li>&lt;code>[p_1, p_2, p_3, p_4]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>변경 후
&lt;ul>
&lt;li>&lt;code>[p_1, p_2, p_3, p_4, p_5, p_6]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="운영-고려사항">운영 고려사항&lt;/h4>
&lt;p>기존 레디스 펍/섭 서버를 새 서버로 교체할 때는 교체되는 서버의 채널만 처리하므로 운영 문제가 발생할 가능성은 클러스터 크기를 조정할 때보다 훨씬 낮다.&lt;/p>
&lt;p>펍/섭 서버에 장애가 발생하면 &lt;strong>모니터링 소프트웨어&lt;/strong>는 온콜(on-call) 엔지니어에게 경보를 발송하며, 온콜 담당자는 아래와 같은 처리를 수행한다.&lt;/p>
&lt;ol>
&lt;li>서비스 탐색 컴포넌트의 해시 링 키에 매달린 값을 갱신하여 장애가 발생한 노드를 대기 중인 노드와 교체&lt;/li>
&lt;li>교체 사실은 모든 웹소켓 서버에 통지되고, 각 웹소켓 서버는 실행 중인 연결 핸들러에게 새 펍/섭 서버의 채널을 다시 구독하라고 알림&lt;/li>
&lt;li>각 연결 핸들러는 구독 중인 채널의 목록을 유지하고 있으므로, 모든 채널을 해시 링과 대조하여 새 서버로 구독 관계를 다시 설정해야 하는지 검토&lt;/li>
&lt;/ol>
&lt;h3 id="친구-추가삭제">친구 추가/삭제&lt;/h3>
&lt;p>새 친구를 추가하면 해당 클라이언트에 연결된 웹소켓 서버의 연결 핸들러에 그 사실을 알려 새 친구의 펍/섭 채널을 구독할 수 있도록 해야한다.&lt;/p>
&lt;ul>
&lt;li>주변 친구 기능은 큰 앱의 일부로, 새 친구가 추가되면 호출될 콜백을 해당 앱에 등록해 둘 수 있다.&lt;/li>
&lt;li>콜백이 호출되면 웹소켓 서버로 새 친구의 펍/섭 채널을 구독하라는 메시지를 보낸다.&lt;/li>
&lt;li>이 메시지를 처리한 웹소켓 서버는 해당 친구가 활성화 상태인 경우 가장 최근 위치 및 시각 정보를 응답 메시지에 담아 보낸다.&lt;/li>
&lt;/ul>
&lt;p>마찬가지로 친구가 삭제되면 호출될 콜백도 앱에 등록해 둘 수 있다.&lt;/p>
&lt;ul>
&lt;li>콜백이 호출되면 해당 친구의 펍/섭 채널 구독을 취소하라는 메시지를 웹소켓 서버로 보낸다.&lt;/li>
&lt;/ul>
&lt;p>친구가 위치 정보 정보 전성을 허가/취소하는 경우의 처리에도 활용될 수 있다.&lt;/p>
&lt;h3 id="친구가-많은-사용자">친구가 많은 사용자&lt;/h3>
&lt;p>친구가 많은 사용자가 시스템 성능 문제를 야기할 가능성이 있는지 논의해볼 만한 주제이다.&lt;/p>
&lt;ul>
&lt;li>친구 수의 상한이 있다고 가정(페이스북은 5,000명)&lt;/li>
&lt;li>친구 관계는 양방향&lt;/li>
&lt;li>팔로워 모델 같은 단방향 관계는 배제&lt;/li>
&lt;/ul>
&lt;p>수천 명의 친구를 구독하는 데 필요한 펍/섭 구독 관계는 클러스터 내의 많은 웹소켓 서버에 분산되어 있을 것이다.&lt;/p>
&lt;ul>
&lt;li>따라서 친구들의 위치 변경에서 오는 부하는 각 웹소켓 서버가 나누어 처리하므로 핫스팟 문제는 발생하지 않을 것 이다.&lt;/li>
&lt;/ul>
&lt;p>다만 많은 친구를 둔 사용자의 채널이 존재하는 펍/섭 서버의 경우는 조금 더 많은 부하를 감당하게 될 수 있지만, 클러스터 안에 100대가 넘는 펍/섭 서버가 있고, 그런 헤비 유저들의 채널들이 모든 펍/섭 서버에 분산된다는 점을 감안하면, 특정 서버에 막대한 부담을 줄 일은 없을 것이다.&lt;/p>
&lt;h3 id="주변의-임의-사용자">주변의 임의 사용자&lt;/h3>
&lt;p>정보 공유에 동의한 주변 사용자를 무작위로 보여줄 수 있도록 한다면 어떻게 해야할까?&lt;/p>
&lt;p>기존 설계안을 크게 훼손하지 않으면서 해당 기능을 지원하는 한 가지 방법은 &lt;strong>지오해시에 따라 구축된 펍/섭 채널 풀&lt;/strong>을 두는 것 이다.&lt;/p>
&lt;ul>
&lt;li>지오 해시 격자로 나눈 다음 격자 마다 채널을 하나씩 만들어 둔다.&lt;/li>
&lt;/ul>
&lt;p>해당 격자 내의 모든 사용자는 해당 격자에 할당된 채널을 구독한다.&lt;/p>
&lt;ol>
&lt;li>사용자의 위치가 변경되면 웹소켓 연결 핸들러는 해당 사용자의 지오해시 ID를 계산한 후, 해당 지오해시 ID를 담당하는 채널에 새 위치를 전송한다.&lt;/li>
&lt;li>근방에 있는 사용자 가운데 해당 채널을 구독하고 있는 사용자는 사용자 2의 위치가 변겨오디었다는 메시지를 수신한다.&lt;/li>
&lt;/ol>
&lt;p>경계에 위치한 사용자를 잘 처리하기 위해 모든 클라이언트는 사용자가 위치한 지오해시 뿐 아니라 주변 지오해시 격자를 담당하는 채널도 구독한다.&lt;/p>
&lt;h3 id="레디스-펍섭-외의-대안">레디스 펍/섭 외의 대안&lt;/h3>
&lt;p>얼랭(Erlang)은 이문제에 특히 유용한 해결책이 될 수 있다.&lt;/p>
&lt;ul>
&lt;li>오히려 더 좋은 솔루션이 될 수 있다.&lt;/li>
&lt;li>얼랭은 사용자가 적어 좋은 개발자를 구하기 어렵다&lt;/li>
&lt;li>얼랭 전문가가 있다면 좋은 선택지가 될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>얼랭&lt;/strong>은 고도로 분산된 병렬 애플리케이션을 위해 고안된 프로그래밍 언어이자 런타임 환경이다.&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>개념적으로 보자면 어떤 사용자의 위치 정보 변경 내역을 그 친구에게 효율적으로 전달하는 시스템을 설계했다.&lt;/p>
&lt;p>설계안의 핵심 컴포넌트는 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>웹소켓
&lt;ul>
&lt;li>클라이언트와 서버 사이의 실시간 통신을 지원한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>레디스
&lt;ul>
&lt;li>위치 데이터의 빠른 읽기/쓰기를 지원한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>레디스 펍/섭
&lt;ul>
&lt;li>한 사용자의 위치 정보 변경 내역을 모든 온라인 친구에게 전달하는 라우팅 계층&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>소규모 트래픽에 적합한 개략적 설계안부터 시작하여, 규모가 커짐에 따라 발생 가능한 도전적 문제들을 살펴보았다.&lt;/p>
&lt;ul>
&lt;li>RESTful API 서버&lt;/li>
&lt;li>웹소켓 서버&lt;/li>
&lt;li>데이터 계층&lt;/li>
&lt;li>레디스 펍/섭 서버 클러스터&lt;/li>
&lt;li>레디스 펍/섭 서버의 대안&lt;/li>
&lt;/ul>
&lt;p>친구가 많은 사용자에게 발생할 수 있는 잠재적 성능 병목문제와, 주변의 임의 사용자를 보여주는 기능의 설계안도 살펴보았다.&lt;/p>
&lt;h2 id="요약">요약&lt;/h2>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
nearby(주변 친구) --> first((1단계))
nearby --> second((2단계))
nearby --> third((3단계))
first --> giyogu[기능적 요구사항]
giyogu --> display[주변 친구 목록 표시]
giyogu --> update[주변 친구 목록 갱신]
first --> biyogu[비 기능적 요구사항]
biyogu --> low_latenty[낮은 지연 시간]
first --> choo[추정]
choo --> mile[5마일 검색 반경]
choo --> interval[위치 갱신 주기: 30초]
choo --> updatedata[위치 정보 갱신 QPS: 334k/s]
second --> rufh[개략적 설계안]
rufh --> rest[RESTful API 서버]
rufh --> websocket[웹소켓 서버]
rufh --> redis[레디스 위치 정보 캐시]
rufh --> casandra[위치 이동 이력 데이터베이스]
rufh --> pubsub[레디스 펍/섭 서버]
second --> intervalpos[주기적 위치 갱신]
second --> api[API 설계]
second --> datamodel[데이터 모델]
datamodel --> position[위치 정보 캐시]
datamodel --> positionlog[위치 이동 이력 데이터베이스]
third --> components[각 컴포넌트의 규모 확장]
components --> apiComponent[API 서버]
components --> websocket_cluster[웹소켓 서버 클러스터]
components --> userDB[사용자 정보 데이터베이스]
components --> positionCache[위치 정보 캐시]
components --> pubsubCluster[레디스 펍/섭 서버 클러스터]
components --> erlang[레디스 펍/섭 외 대안]
third --> friendUD[친구 추가/삭제]
third --> manyFriend[친구가 많은 사용자]
third --> random[주변 임의 사용자]
&lt;/pre></description></item><item><title>6. 키-값 저장소 설계</title><link>https://codemario318.github.io/post/system-design-interview/6/</link><pubDate>Mon, 27 May 2024 11:59:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/6/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/cover.png" alt="Featured image of post 6. 키-값 저장소 설계" />&lt;p>키-값 저장소(key-value store)는 키-값 데이터베이스라고도 불리는 비 관계형(non-relational) 데이터베이스이다.&lt;/p>
&lt;ul>
&lt;li>이 저장소에 저장되는 값은 &lt;strong>고유 식별자&lt;/strong>를 키로 가져야한다.&lt;/li>
&lt;li>키와 값 사이의 이런 연결 관계를 &lt;strong>키-값 쌍&lt;/strong>(key-value pair)이라고 지칭한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>키&lt;/strong>&lt;br>
키-값 쌍에서의 키는 &lt;strong>유일&lt;/strong>해야 하며 해당 키에 매달린 값은 &lt;strong>키를 통해서만 접근&lt;/strong>할 수 있다.&lt;/p>
&lt;p>키는 일반 텍스트일 수도 있고 해시 값일 수도 있지만, 성능상의 이유로 짧을수록 좋다.&lt;/p>
&lt;ul>
&lt;li>일반 텍스트 키: &amp;ldquo;last_logged_in_at&amp;rdquo;&lt;/li>
&lt;li>해시 키: 253DDEC4&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>값&lt;/strong>&lt;br>
키-값 저장소는 보통 &lt;strong>값으로 무엇이 오든 상관하지 않는다&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>문자열, 리스트, 객체 등&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>키-값 저장소로 널리 알려진 것은 아마존 다이나모, memcached, 레디스 같은 것들이 있다.&lt;/p>
&lt;p>또한 기본적으로 아래와 같은 연산을 지원해야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>put(key, value)&lt;/code>: 키-값 쌍을 저장소에 저장한다.&lt;/li>
&lt;li>&lt;code>get(key)&lt;/code>: 인자로 주어진 키에 매달린 값을 꺼낸다.&lt;/li>
&lt;/ul>
&lt;h2 id="문제-이해-및-설계-범위-확정">문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>완벽한 설계란 없다.&lt;/p>
&lt;p>읽기, 쓰기 그리고 메모리 사용량 사이에 어떤 균형을 찾고, 데이터의 일관성과 가용성 사이에서 타협적 결정을 내린 설계를 만들었다면 충분히 쓸만한 답이다.&lt;/p>
&lt;p>이번 장에서는 다음 특성을 갖는 키-값 저장소를 설계해본다.&lt;/p>
&lt;ul>
&lt;li>키-값 쌍의 크기는 10KB 이하이다.&lt;/li>
&lt;li>큰 데이터를 저장할 수 있어야 한다.&lt;/li>
&lt;li>높은 가용성을 제공해야한다.
&lt;ul>
&lt;li>시스템은 장애가 있더라도 빨리 응답해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>높은 규모 확장성을 제공해야 한다.
&lt;ul>
&lt;li>트래픽 양에 따라 자동적으로 서버 증설/삭제가 이루어져야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 일관성 수준은 조정이 가능해야 한다.&lt;/li>
&lt;li>응답 지연시간(latency)이 짧아야 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="단일-서버-키-값-저장소">단일 서버 키-값 저장소&lt;/h2>
&lt;p>한 대 서버만 사용하는 키-값 저장소는 설계가 쉽다.&lt;/p>
&lt;p>가장 직관적인 방법은 키-값 쌍 전부를 메모리에 해시 테이블로 저장하는 것이다.&lt;/p>
&lt;p>이 방법은 빠른 속도를 보장하지만 &lt;strong>모든 데이터를 메모리안에 두는 것이 불가능&lt;/strong>할 수도 있다.&lt;/p>
&lt;p>이 문제의 개선책은 다음과 같은 것들이 있다.&lt;/p>
&lt;ul>
&lt;li>데이터 압축&lt;/li>
&lt;li>자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장&lt;/li>
&lt;/ul>
&lt;p>이렇게 개선한다고 해도, 한 대 서버로 부족한 때가 찾아오며, 많은 데이터를 저장하기 위해서 &lt;strong>분산 키-값 저장소&lt;/strong>를 만들어야한다.&lt;/p>
&lt;h2 id="분산-키-값-저장소">분산 키 값 저장소&lt;/h2>
&lt;p>분산 키 값 저장소는 키-값 쌍을 여러 서버에 분산시키므로 &lt;strong>분산 해시 테이블&lt;/strong>이라고도 불린다.&lt;/p>
&lt;p>분산 시스템을 설계할 때는 &lt;strong>CAP 정리&lt;/strong>(Consistency, Availability, Partition Tolerance theorem)를 이해하고 있어야 한다.&lt;/p>
&lt;h3 id="cap-정리">CAP 정리&lt;/h3>
&lt;p>CAP 정리는 &lt;strong>데이터 일관성(consistency), 가용성(availability), 파티션 감내(partition tolerance)라는 세가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다&lt;/strong>는 정리이다.&lt;/p>
&lt;ul>
&lt;li>데이터 일관성
&lt;ul>
&lt;li>분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성
&lt;ul>
&lt;li>분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파티션 감내
&lt;ul>
&lt;li>파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다.&lt;/li>
&lt;li>네트워크에 파티션(분할)이 생기더라도 시스템은 계속 동작하여야 한다는 것을 뜻한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>네트워크 파티션?&lt;/strong>&lt;br>
테이터베이스 시스템의 일부 노드들이 서로 통신할 수 없는 상황으로 인해 각 노드들(파티션)이 독립적으로 동작하게 되어 각 파티션이 서로 다른 상태나 데이터를 가지게 되는 상황&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img.png"
width="828"
height="608"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_hu8399b985eaaab4d8c3cc5e2bfd3651de_149592_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_hu8399b985eaaab4d8c3cc5e2bfd3651de_149592_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="326px"
>&lt;/p>
&lt;p>따라서 이들 가운데 &lt;strong>어떤 두 가지를 충족하려면 나머지 하나는 반드시 희생되어야 한다&lt;/strong>는 것을 의미한다.&lt;/p>
&lt;p>키 값 저장소는 세 가지 요구사항 가운데 어느 두 가지를 만족하느냐에 따라 다음과 같이 분류할 수 있다.&lt;/p>
&lt;ul>
&lt;li>CP: 일관성과 파티션 감내를 지원(가용성 희생)&lt;/li>
&lt;li>AP: 가용성과 파티션 감내를 지원(데이터 일관성 희생)&lt;/li>
&lt;li>CA: 일관성과 가용성을 지원(파티션 감내 지원 안함)
&lt;ul>
&lt;li>통상 네트워크 장애는 피할 수 없는 일로 여겨지므로, 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야 한다.&lt;/li>
&lt;li>실세계에서 CA 시스템은 존재하지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="구체적-사례">구체적 사례&lt;/h3>
&lt;p>분산 시스템에서 데이터는 보통 여러 노드에 복제되어 보관된다.&lt;/p>
&lt;h4 id="이상적-상태">이상적 상태&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_1.png"
width="840"
height="592"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_1_hua0faa9aa952f92ab7c5a2fe27ee0e7c0_91753_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_1_hua0faa9aa952f92ab7c5a2fe27ee0e7c0_91753_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="340px"
>&lt;/p>
&lt;p>이상적인 환경이라면 &lt;strong>네트워크가 파티션되는 상황은 절대로 일어나지 않을 것&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>n1&lt;/strong>에 기록된 데이터는 자동적으로 &lt;strong>n2&lt;/strong>, &lt;strong>n3&lt;/strong>에 복제되며 데이터 일관성과 가용성도 만족한다.&lt;/li>
&lt;/ul>
&lt;h4 id="실세계의-분산-시스템">실세계의 분산 시스템&lt;/h4>
&lt;p>분산 시스템은 파티션 문제를 피할 수 없다.&lt;/p>
&lt;p>파티션 문제가 발생하면 &lt;strong>일관성과 가용성 사이에서 하나를 선택&lt;/strong>해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_2.png"
width="839"
height="605"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_2_hud8043c96815985a7c6b0f4ed2ff33b87_103442_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_2_hud8043c96815985a7c6b0f4ed2ff33b87_103442_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="138"
data-flex-basis="332px"
>&lt;/p>
&lt;p>&lt;strong>n3&lt;/strong>에 장애가 발생하여 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>와 통신 할 수 없는 상황에서&lt;/p>
&lt;ul>
&lt;li>클라이언트가 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>에 기록한 데이터는 &lt;strong>n3&lt;/strong>에 전달되지 않는다.&lt;/li>
&lt;li>&lt;strong>n3&lt;/strong>에 기록되었으나 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>로 전달되지 않은 데이터가 있다면 오래된 사본을 갖고 있을 것이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>CP 시스템&lt;/strong>&lt;/p>
&lt;p>가용성 대신 일관성을 선택한다면 세 서버 사이에 생길 수 있는 데이터 불일치 문제를 피하기 위해 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>에 대해 &lt;strong>쓰기 연산을 중단&lt;/strong>시켜야한다.&lt;/p>
&lt;p>이러한 경우 일부 노드가 장애가 발생하여도 동작해야 한다는 가용성이 깨진다.&lt;/p>
&lt;p>데이터 일관성을 양보할 수 없는 시스템은 이렇게 처리되어 상황이 해결될 때 까지 오류를 반환해야 한다.&lt;/p>
&lt;ul>
&lt;li>온라인 뱅킹 등&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>AP 시스템&lt;/strong>&lt;/p>
&lt;p>일관성 대신 가용성을 선택한 시스템은 &lt;strong>낡은 데이터를 반환할 위험이 있더라도 계속 읽기 연산을 허용&lt;/strong>해야한다.&lt;/p>
&lt;p>&lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>는 계속 쓰기 연산을 허용하고, 파티션 문제가 해결된 뒤 새 데이터를 &lt;strong>n3&lt;/strong>에 전송해야한다.&lt;/p>
&lt;hr>
&lt;p>분산 키-값 저장소를 만들 때는 그 요구사항에 맞도록 CAP 정리를 적용해야 한다.&lt;/p>
&lt;p>면접 상황에서는 이 문제에 대해 면접관과 상의하고, 그 결론에 따라 시스템을 설계하도록 하자.&lt;/p>
&lt;h3 id="시스템-컴포넌트">시스템 컴포넌트&lt;/h3>
&lt;p>키-값 저장소 구형에 사용되는 핵심 컴포넌트들 및 기술을 살펴본다.&lt;/p>
&lt;ul>
&lt;li>데이터 파티션&lt;/li>
&lt;li>데이터 다중화&lt;/li>
&lt;li>일관성&lt;/li>
&lt;li>일관성 불일치 해소&lt;/li>
&lt;li>장애 처리&lt;/li>
&lt;li>시스템 아키텍처 다이어그램&lt;/li>
&lt;li>쓰기 경로&lt;/li>
&lt;li>읽기 경로&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-파티션">데이터 파티션&lt;/h4>
&lt;p>대규모 애플리케이션의 경우 전체 데이터를 한 대 서버에 욱여넣는 것은 불가능하다.&lt;/p>
&lt;p>가장 단순한 해결책은 &lt;strong>데이터를 작은 파티션들로 분할한 다음 여러 대 서버에 저장하는 것&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>데이터를 여러 서버에 고르게 분산할 수 있는가&lt;/li>
&lt;li>노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가&lt;/li>
&lt;/ul>
&lt;p>5장에서 다룬 안정 해시는 이런 문제를 푸는 데 적합한 기술로 활용될 수 있다.&lt;/p>
&lt;p>안정 해시를 사용하여 데이터를 파티션하면 몇가지 장점이 있다.&lt;/p>
&lt;ul>
&lt;li>규모 확장 자동화(automatic scaling)
&lt;ul>
&lt;li>시스템 부하에 따라 서버가 자동으로 추가되거나 삭제되도록 만들 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다양성(heterogeneity)
&lt;ul>
&lt;li>각 서버의 용량에 맞게 가상 노드의 수를 조정할 수 있다.&lt;/li>
&lt;li>고성능 서버는 더 많은 가상노드를 갖도록&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-다중화">데이터 다중화&lt;/h4>
&lt;p>높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있다.&lt;/p>
&lt;p>어떤 키를 해시 링 위에 배치한 수, 그 지점으로부터 시계 방향으로 링을 순회하면서 만나는 첫 N개 서버에 데이터 사본을 보관한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_3.png"
width="843"
height="685"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_3_hu0675f294d26db8b4acf424a88b68b693_77163_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_3_hu0675f294d26db8b4acf424a88b68b693_77163_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="123"
data-flex-basis="295px"
>&lt;/p>
&lt;p>하지만 가상 노드를 사용한다면 선택한 N개의 노드가 대응될 실제 물리 서버의 개수가 N보다 작아질 수 있다.&lt;/p>
&lt;p>이 문제를 피하려면 노드를 선택할 때 같은 물리 서버를 중복으로 선택하지 않도록 해야한다.&lt;/p>
&lt;p>같은 데이터 센터에 속한 노드는 정전, 네트워크 이슈, 자연 재해 등의 문제를 동시에 같이 겪을 가능성이 있으므로, 안정성을 담보하기 위해 데이터의 사본은 다른 센터의 서버에 보관하고, 센터들은 고속 네트워크로 연결한다.&lt;/p>
&lt;h4 id="데이터-일관성">데이터 일관성&lt;/h4>
&lt;p>여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 한다.&lt;/p>
&lt;p>&lt;strong>정족수 합의&lt;/strong>(Quorum Consensus) 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>N&lt;/code>: 사본의 개수&lt;/li>
&lt;li>&lt;code>W&lt;/code>: 쓰기 연산에 대한 정족수
&lt;ul>
&lt;li>쓰기 연산이 성공한 것으로 간주되려면 적어도 &lt;code>W&lt;/code>개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R&lt;/code>: 읽기 연산에 대한 정족수
&lt;ul>
&lt;li>읽기 연산이 성공한 것으로 간주되려면 적어도 &lt;code>R&lt;/code>개의 서버로부터 응답을 받아야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>일반적으로 &lt;code>N = R + W &amp;gt; N&lt;/code> 조건을 만족하도록 설정하며, 읽기와 쓰기 요청이 적어도 하나의 공통 노드를 통해 일관성을 유지하도록 보장한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_4.png"
width="839"
height="579"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_4_huec6b456c1e9a98e57b711c077ef003c7_99493_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_4_huec6b456c1e9a98e57b711c077ef003c7_99493_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="N = 3"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;p>&lt;code>W = 1&lt;/code>는 쓰기 연산이 성공했다고 판단하기 위해 중재자(coordinator)는 최소 한 대 서버로부터 쓰기 성공 응답을 받아야한다는 뜻이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>s1&lt;/strong>으로 부터 성공 응답을 받았다면, 나머지 응답은 기다릴 필요가 없다.&lt;/li>
&lt;/ul>
&lt;p>중재자는 클라이언트와 노드 사이에서 프락시(proxy)역할을 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;code>W&lt;/code>, &lt;code>R&lt;/code>, &lt;code>N&lt;/code>의 값을 정하는 것은 응답 지연과 데이터 일관성 사이의 타협점을 찾는 전형정인 과정이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>W = 1&lt;/code> or &lt;code>R = 1&lt;/code>
&lt;ul>
&lt;li>중재자는 한 대 서버로부터의 응답만 받으면 되므로 응답속도는 빠르다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>W &amp;gt; 1&lt;/code> or &lt;code>R &amp;gt; 1&lt;/code>
&lt;ul>
&lt;li>데이터 일관성의 수준은 향상되지만 중재자의 응답 속도는 가장 느린 서버로부터의 응답을 기다려야 하므로 느려진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>따라서 &lt;code>W + R &amp;gt; N&lt;/code>인 경우에는 일관성을 보증할 최신 데이터를 가진 노드가 최소 하나는 겹치므로 강한 일관성이 보장된다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>R = 1&lt;/code>, &lt;code>W = N&lt;/code>
&lt;ul>
&lt;li>빠른 읽기 연산에 최적화된 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R = N&lt;/code>, &lt;code>W = 1&lt;/code>
&lt;ul>
&lt;li>빠른 쓰기 연산에 최적화된 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R + W &amp;gt; N&lt;/code>
&lt;ul>
&lt;li>강한 일관성이 보장됨
&lt;ul>
&lt;li>보통 &lt;code>N = 3&lt;/code>, &lt;code>W = R = 2&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R + W &amp;lt;= N&lt;/code>
&lt;ul>
&lt;li>강한 일관성이 보장되지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>요구되는 일관성 수준에 따라 &lt;code>W&lt;/code>, &lt;code>R&lt;/code>, &lt;code>N&lt;/code> 값을 조정한다.&lt;/p>
&lt;p>&lt;strong>일관성 모델&lt;/strong>&lt;/p>
&lt;p>일관성 모델(consistency model)은 키-값 저장소를 설계할 때 고려해야 할 요소로 데이터 일관성 수준을 결정한다.&lt;/p>
&lt;ul>
&lt;li>강한 일관성
&lt;ul>
&lt;li>모든 읽기 연산은 최신 결과를 반환한다.&lt;/li>
&lt;li>클라이언트는 절대로 낡은 데이터를 볼 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>약한 일관성
&lt;ul>
&lt;li>읽기 연산은 최신 결과를 반환하지 못할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>결과적 일관성
&lt;ul>
&lt;li>약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영(동기화)된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>강한 일관성&lt;/strong>을 달성하는 일반적인 방법은, &lt;strong>모든 사본에 현재 쓰기 연산의 결과가 반영될 때까지 해당 데이터에 대한 읽기/쓰기를 금지&lt;/strong>하는 것이다.&lt;/p>
&lt;ul>
&lt;li>새로운 요청의 처리가 중단되므로 고 가용성 시스템에는 적합하지 않다.&lt;/li>
&lt;/ul>
&lt;p>다이나모 또는 카산드라 같은 저장소는 결과적 일관성 모델을 택하고 있다.&lt;/p>
&lt;ul>
&lt;li>결과적 일관성 모델을 따를 경우 &lt;strong>쓰기 연산이 병렬적으로 발생하면 시스템에 저장된 값의 일관성이 깨어질 수 있는데&lt;/strong>, 이 문제는 클라이언트가 해결해야한다.&lt;/li>
&lt;li>클라이언트 측에서 데이터의 버전 정보를 활용해 일관성이 깨진 데이터를 읽지 않도록 해야한다.&lt;/li>
&lt;/ul>
&lt;p>데이터를 다중화하면 가용성은 높아지지만 사본 간 일관성이 깨질 가능성은 높아진다.&lt;/p>
&lt;p>&lt;strong>비 일관성 해소 기법: 데이터 버저닝&lt;/strong>&lt;/p>
&lt;p>버저닝은 데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만든다.&lt;/p>
&lt;ul>
&lt;li>각 버전은 변경 불가능하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_5.png"
width="838"
height="387"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_5_hu314294c50ed1dac3bf6da051bfbc696c_78353_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_5_hu314294c50ed1dac3bf6da051bfbc696c_78353_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="충돌하는 두 값"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="519px"
>&lt;/p>
&lt;p>서버 1, 2가 다른 노드의 같은&lt;code>name&lt;/code>의 값을 동시에 변경하여 충돌이 발생했다고 가정했을 때 각각을 버전 &lt;strong>v1&lt;/strong>, &lt;strong>v2&lt;/strong>로 볼 수 있다.&lt;/p>
&lt;p>이러한 충돌 문제를 해결하려면, 충돌을 발견하고 자동으로 해결해 낼 버저닝 시스템이 필요하다.&lt;/p>
&lt;p>&lt;strong>백터 시계&lt;/strong>(vector clock)는 &lt;strong>&lt;code>[서버, 버전]&lt;/code>의 순서 쌍을 데이터에 매단 것&lt;/strong>으로 충돌 문제를 푸는데 보편적으로 사용된다.&lt;/p>
&lt;ul>
&lt;li>어떤 버전이 선행 버전인지, 후행 버전인지, 충돌이 있는지 판별하는 데 쓰인다.&lt;/li>
&lt;/ul>
&lt;p>데이터 D를 서버 &lt;strong>Si&lt;/strong>에 기록하려면 아래 작업 가운데 하나를 수행해야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>[Si, Vi]&lt;/code>가 있으면 &lt;code>Vi&lt;/code>를 증가시킨다.&lt;/li>
&lt;li>그렇지 않다면 새 항목 &lt;code>[Si, 1]&lt;/code>을 만든다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_6.png"
width="717"
height="798"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_6_hu4d508b5e0485ac8ed5a6f6afc4aa05b9_112910_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_6_hu4d508b5e0485ac8ed5a6f6afc4aa05b9_112910_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="백터 시계"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="215px"
>&lt;/p>
&lt;ol>
&lt;li>클라이언트가 &lt;code>D1&lt;/code>을 시스템에 기록한다.
&lt;ul>
&lt;li>처리한 서버는 &lt;code>Sx&lt;/code>이므로 백터 시계는 &lt;code>D1[Sx, 1]&lt;/code>으로 변한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다른 클라이언트가 &lt;code>D1&lt;/code>을 읽고 &lt;code>D2&lt;/code>로 업데이트한 다음 기록한다.
&lt;ul>
&lt;li>&lt;code>D2&lt;/code>는 &lt;code>D1&lt;/code>의 변경이므로 덮어쓴다.&lt;/li>
&lt;li>&lt;code>Sx&lt;/code>가 처리했으므로 벡터 시계를 &lt;code>D2[Sx, 2]&lt;/code>로 변경한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다른 클라이언트가 &lt;code>D2&lt;/code>를 읽어 &lt;code>D3&lt;/code>로 갱신한 다음 기록한다.
&lt;ul>
&lt;li>&lt;code>Sy&lt;/code>가 처리했으므로 백터 시계 상태는 &lt;code>D3([Sx, 2], [Sy, 1])&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>또 다른 클라이언트가 &lt;code>D2&lt;/code>를 읽고 &lt;code>D4&lt;/code>로 갱신한 후 기록한다.
&lt;ul>
&lt;li>&lt;code>Sz&lt;/code>가 처리했으므로 백터 시계 상태는 &lt;code>D4([Sx, 2], [Sz, 1])&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>어떤 클라이언트가 D3과 D4를 읽으면 데이터 간 충돌이 있다는 것을 알게 되므로, 클라이언트가 해소한 후 서버에 기록한다.
&lt;ul>
&lt;li>&lt;code>Sx&lt;/code>가 처리했으므로 백터 시계는 &lt;code>D5([Sx, 3], [Sy, 1], [Sz, 1])&lt;/code>로 바뀐다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>벡터 시계를 이용하면 버전 Y에 포함된 모든 구성 요소의 값이 X에 포함된 모든 구성요소 값보다 같거나 큰지만 확인하면 어떤 버전 X가 버전 Y의 이전 버전인지 쉽게 판단할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>D([s0, 1], [s1, 1])&lt;/code>은 &lt;code>D([s0, 1], [s1, 2])&lt;/code>보다 이전 버전이다.(충돌 X)&lt;/li>
&lt;/ul>
&lt;p>어떤 버전 X와 Y 사이에 충돌이 있는지 보려면 &lt;strong>Y의 벡터 시계 구성 요소 가운데 X의 벡터 시계 동일 서버 구성요소보다 작은 값을 갖는 것이 있는지 확인&lt;/strong>한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>D([s0, 1], [s1, 2])&lt;/code>, &lt;code>D([s0, 2], [s1, 1])&lt;/code>는 서로 충돌한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>벡터 시계를 통해 충돌 감지하고 해소하는 방법에는 두 가지 단점이 있다.&lt;/p>
&lt;ul>
&lt;li>충돌 감지 및 해소 로직이 클라이언트에 들어가야 하므로, 클라이언트 구현이 복잡해진다.&lt;/li>
&lt;li>&lt;code>[서버: 버전]&lt;/code>의 순서쌍 개수가 굉장히 빨리 늘어난다.
&lt;ul>
&lt;li>순서쌍 개수에 임계치를 설정하고, 임계치 이상으로 길이가 길어지면 오래된 순서쌍을 백터 시계에서 제거한다.&lt;/li>
&lt;li>버전 간 선후 관계가 정확하게 결정될 수 없으므로 충돌 해소 과정의 효율성이 낮아질 수 있다.&lt;/li>
&lt;li>실제 서비스에서 그런 문제는 거의 발생하지 않으므로, 대부분 기업에서 괜찮다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="장애-처리">장애 처리&lt;/h4>
&lt;p>대규모 시스템에서 장애는 아주 흔하게 벌어지므로 장애를 어떻게 처리할 것이냐 하는 것은 굉장히 중요한 문제이다.&lt;/p>
&lt;h4 id="장애-감지">장애 감지&lt;/h4>
&lt;p>분산 시스템에서는 서버 A에 문제가 생겼을 때 바로 장애를 처리하지 않고, 보통 두 대 이상의 서버가 똑같이 서버 A에 대해 장애를 보고해야 해당 서버에 실제로 장애가 발생했다고 간주한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_7.png"
width="838"
height="636"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_7_hu135f183e800718526af99039ce9e186b_156879_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_7_hu135f183e800718526af99039ce9e186b_156879_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="멀티캐스팅 채널 구축"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="316px"
>&lt;/p>
&lt;p>모든 노드 사이에 멀티캐스팅 채널을 구축하는 것이 서버 장애를 감지하는 손쉬운 방법이나, 이 방법은 서버가 많을 때 비효율적이다.&lt;/p>
&lt;p>따라서 &lt;strong>가십 프로토콜&lt;/strong>(gossip protocol) 같은 분산형 장애 감지 솔루션을 채택하는 편이 보다 효율적이다.&lt;/p>
&lt;ul>
&lt;li>각 노드는 맴버십 목록을 유지한다.
&lt;ul>
&lt;li>맴버십 목록: 각 맴버 ID와 그 박동 카운터(heartbeat counter) 쌍의 목록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 노드는 주기적으로 자신의 박동 카운터를 증가시킨다.&lt;/li>
&lt;li>각 노드는 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터 목록을 보낸다.&lt;/li>
&lt;li>박동 카운터 목록을 받은 노드는 맴버십 목록을 최신 값으로 갱신한다.&lt;/li>
&lt;li>어떤 맴버의 박동 카운터 값이 지정된 시간 동안 갱신되지 않으면 해당 멤버는 장애 상태인 것으로 간주한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_8.png"
width="839"
height="382"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_8_hu90da88e3e0d0b1a6937865c76380943d_88593_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_8_hu90da88e3e0d0b1a6937865c76380943d_88593_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="가십 프로토콜"
class="gallery-image"
data-flex-grow="219"
data-flex-basis="527px"
>&lt;/p>
&lt;h4 id="일시적-장애-처리">일시적 장애 처리&lt;/h4>
&lt;p>장애를 감지한 시스템은 가용성을 보장하기 위해 필요한 조치를 해야한다.&lt;/p>
&lt;ul>
&lt;li>엄격한 정족수 접근법은 읽기와 쓰기 연산을 금지한다.&lt;/li>
&lt;li>느슨한 정족수 접근법은 쓰기 연산을 수행할 W개의 건강한 서버와 읽기 연산을 수행할 R개의 건강한 서버를 해시 링에서 고른다.(장애 서버는 무시)&lt;/li>
&lt;li>장애 상태인 서버로 가는 요청은 다른 서버가 잠시 맡아 처리한다.&lt;/li>
&lt;li>그동안 발생한 변경 사항은 장애 서버가 복구 되었을 때 일괄 반영하여 데이터 일관성을 보존한다.
&lt;ul>
&lt;li>임시로 쓰기 연산을 처리한 서버에는 그에 관한 단서를 남겨둔다.&lt;/li>
&lt;li>단서 후 임시 위탁(hinted handoff)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_9.png"
width="834"
height="718"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_9_hu115bfa1d5fe40c44de379ba88e53d6c2_127770_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_9_hu115bfa1d5fe40c44de379ba88e53d6c2_127770_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="116"
data-flex-basis="278px"
>&lt;/p>
&lt;p>장애 상태인 s2에 대한 읽기 및 쓰기 연산은 일시적으로 s3가 처리하며, s2가 복구되면 s3는 갱신된 데이터를 s2로 인계한다.&lt;/p>
&lt;h4 id="영구-장애-처리">영구 장애 처리&lt;/h4>
&lt;p>영구적인 노드의 장애 상태는 반-엔트로피(anti-entropy) 프로토콜을 구현하여 사본들을 동기화한다.&lt;/p>
&lt;p>반-엔트로피 프로토콜은 &lt;strong>사본들을 비교하여 최신 버전으로 갱신하는 과정을 포함&lt;/strong>한다.&lt;/p>
&lt;p>사본 간의 일관성이 망가진 상태를 탐지하고 전송 데이터의 양을 줄이기 위해서 머클(Merkle) 트리를 사용한다.&lt;/p>
&lt;blockquote>
&lt;p>머클 트리?&lt;br>
해시 트리라고 불리는 머클 트리는 각 노드에 그 자식 노드들의 보관된 값의 해시(자식 노드가 leaf인 경우) 또는 자식 노드들의 레이블로부터 계산된 해시 값을 레이블로 붙여두는 트리&lt;/p>
&lt;/blockquote>
&lt;p>해시 트리를 사용하면 &lt;strong>대규모 자료 구조의 내용을 효과적이면서도 보안상 안전한 방법으로 검증&lt;/strong>할 수 있다.&lt;/p>
&lt;p>&lt;strong>1 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_10.png"
width="844"
height="330"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_10_hu458e95c99f7dfcfac03b6157ee8c6e5b_44753_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_10_hu458e95c99f7dfcfac03b6157ee8c6e5b_44753_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="255"
data-flex-basis="613px"
>&lt;/p>
&lt;p>키 공간을 버킷으로 나눈다.&lt;/p>
&lt;p>&lt;strong>2 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_11.png"
width="842"
height="182"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_11_hu5646976f70d14d2033d017e53694f064_41493_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_11_hu5646976f70d14d2033d017e53694f064_41493_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="462"
data-flex-basis="1110px"
>&lt;/p>
&lt;p>버킷에 포함된 각각의 키에 균등 분포 해시 함수를 적용하여 해시 값을 계산한다.&lt;/p>
&lt;p>&lt;strong>3 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_12.png"
width="839"
height="260"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_12_hu38a58b95ad281add1c37ca9db00d3b58_73545_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_12_hu38a58b95ad281add1c37ca9db00d3b58_73545_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="322"
data-flex-basis="774px"
>&lt;/p>
&lt;p>버킷 별로 해시값을 계산한 후, 해당 해시 값을 레이블로 갖는 노드를 만든다.&lt;/p>
&lt;p>&lt;strong>4 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_13.png"
width="840"
height="445"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_13_hu8894cdbe47f2eb2880a4148ac1861de4_101648_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_13_hu8894cdbe47f2eb2880a4148ac1861de4_101648_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;p>자식 노드의 레이블로부터 새로운 해시값을 계산하여, 이진 트리를 상향식으로 구성해 나간다.&lt;/p>
&lt;hr>
&lt;p>두 머클 트리의 비교는 루트 노드의 해시값을 비교하는 것으로 시작하며, 다른 데이터를 갖는 버킷을 찾을 경우 그 버킷들만 동기화한다.&lt;/p>
&lt;p>머클 트리를 사용하면 동기화해야 하는 데이터 양은 실제로 존재하는 차이의 크기에 비례할 뿐, 두 서버에 보관된 데이터의 총량과는 무관해진다.&lt;/p>
&lt;ul>
&lt;li>실제로 쓰이는 시스템의 경우 버킷 하나의 크기가 꽤 크다.&lt;/li>
&lt;li>10억(1B) 개의 키를 백만(1M) 개의 버킷으로 관리하면, 하나의 버킷은 1,000개 키를 관리한다.&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-센터-장애-처리">데이터 센터 장애 처리&lt;/h4>
&lt;p>데이터 센터 장애는 정전, 네트워크 장애, 자연재해 등 다양한 이유로 발생할 수 있다.&lt;/p>
&lt;p>데이터 센터의 장애에 대응할 수 있는 시스템을 만드려면 데이터를 여러 데이터 센터에 다중화하는 것이 중요하다.&lt;/p>
&lt;h3 id="시스템-아키텍처-다이어그램">시스템 아키텍처 다이어그램&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_14.png"
width="842"
height="525"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_14_hu3a1f1cde060e244af1e3932a5858e642_94830_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_14_hu3a1f1cde060e244af1e3932a5858e642_94830_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="384px"
>&lt;/p>
&lt;ul>
&lt;li>클라이언트는 키-값 저장소가 제공하는 두 가지 단순한 API, &lt;code>get(key)&lt;/code>, &lt;code>put(key, value)&lt;/code>와 통신한다.&lt;/li>
&lt;li>중재자는 클라이언트에게 키-값 저장소에 대한 프락시 역할을 하는 노드다.&lt;/li>
&lt;li>노드는 안정 해시의 해시 링 위에 분포한다.&lt;/li>
&lt;li>노드를 자동으로 추가 또는 삭제할 수 있도록, 시스템은 완전히 분산된다.&lt;/li>
&lt;li>데이터는 여러 노드에 다중화된다.&lt;/li>
&lt;li>모든 노드가 같은 책임을 지므로, SPOF(Single Point of Failure)는 존재하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_15.png"
width="830"
height="656"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_15_hud90111428b56169725aae5ee0bdfc804_100802_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_15_hud90111428b56169725aae5ee0bdfc804_100802_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="303px"
>&lt;/p>
&lt;p>완전히 분산된 설계를 채택하였으므로 모든 노드는 제시된 기능을 전부 지원해야한다.&lt;/p>
&lt;h3 id="쓰기-경로">쓰기 경로&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_16.png"
width="845"
height="458"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_16_hu216694585a97b0bfbb508eaee3fd8e8a_77802_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_16_hu216694585a97b0bfbb508eaee3fd8e8a_77802_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="카산드라의 사례"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/p>
&lt;ol>
&lt;li>쓰기 요청이 커밋 로그 파일에 기록된다.&lt;/li>
&lt;li>데이터가 메모리 캐시에 기록된다.&lt;/li>
&lt;li>메모리 캐시가 가득 차거나 사전에 정의된 임계치에 도달하면 데이터는 디스크에 있는 SSTable에 기록된다.
&lt;ul>
&lt;li>SSTable: Sorted-String Table의 약어로 &amp;lt;키, 값&amp;gt; 의 순서쌍을 정렬된 리스트로 관리하는 테이블이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="읽기-경로">읽기 경로&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_17.png"
width="845"
height="446"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_17_huaac619f90ef719991892748c739fd616_71124_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_17_huaac619f90ef719991892748c739fd616_71124_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="189"
data-flex-basis="454px"
>&lt;/p>
&lt;p>읽기 요청을 받은 노드는 데이터가 메모리 캐시에 있는지부터 살핀 후 데이터를 클라이언트에게 반환한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_18.png"
width="843"
height="425"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_18_hub84a0c909dfc6b10b41bdf7efd5bb775_89775_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_18_hub84a0c909dfc6b10b41bdf7efd5bb775_89775_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="476px"
>&lt;/p>
&lt;p>데이터가 메모리에 없는 경우 디스크에서 가져온다.&lt;/p>
&lt;p>어느 SSTable에 찾는 키가 있는지 효율적으로 찾기 위해 블룸 필터(Bloom filter)가 흔히 사용된다.&lt;/p>
&lt;ol>
&lt;li>데이터가 메모리에 있는지 검사하고 있다면 반환한다.&lt;/li>
&lt;li>데이터가 메모리에 없으므로 블룸 필터를 검사한다.&lt;/li>
&lt;li>블룸 필터를 통해 어떤 SSTable에 키가 보관되어 있는지 알아낸다.&lt;/li>
&lt;li>SSTable에서 데이터를 가져온다.&lt;/li>
&lt;li>해당 데이터를 클라이언트에게 반환한다.&lt;/li>
&lt;/ol>
&lt;h2 id="요약">요약&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>목표/문제&lt;/th>
&lt;th>기술&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>대규모 데이터 저장&lt;/td>
&lt;td>안정 해시를 사용해 서버들에 부하 분산&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>읽기 연산에 대한 높은 가용성 보장&lt;/td>
&lt;td>데이터를 여러 데이터센터에 다중화&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>쓰기 연산에 대한 높은 가용성 보장&lt;/td>
&lt;td>버저닝 및 백터 시계를 사용한 충돌 해소&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 파티션&lt;/td>
&lt;td>안정 해시&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>점진적 규모 확장성&lt;/td>
&lt;td>안정 해시&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>다양성(heterogeneity)&lt;/td>
&lt;td>안정 해시&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>조절 가능한 데이터 일관성&lt;/td>
&lt;td>정족수 합의(quorum consensus)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>일시적 장애 처리&lt;/td>
&lt;td>느슨한 정족수 프로토콜(sloppy quorum)과 단서 후 임시 위탁(hinted handoff)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>영구적 장애 처리&lt;/td>
&lt;td>머클 트리(Merkle tree)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 센터 장애 대응&lt;/td>
&lt;td>여러 데이터 센터에 걸친 데이터 다중화&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item></channel></rss>