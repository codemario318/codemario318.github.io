<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Real-Time Service on Mario Blog</title><link>https://codemario318.github.io/tags/real-time-service/</link><description>Recent content in Real-Time Service on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Sun, 17 Nov 2024 14:41:50 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/real-time-service/index.xml" rel="self" type="application/rss+xml"/><item><title>10. 실시간 게임 순위표</title><link>https://codemario318.github.io/post/system-design-interview-2/10/</link><pubDate>Sun, 17 Nov 2024 14:41:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/10/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/cover.png" alt="Featured image of post 10. 실시간 게임 순위표" />&lt;p>이번 장에서는 &lt;strong>온라인 게임 리더보드&lt;/strong>, 즉 순위표를 설계해본다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>순위표?&lt;/strong>&lt;br>
누가 선두를 달리고 있는지 보여주기 위해 게임 등에서 흔히 사용하는 장치로, 가장 많은 포인트를 획득한 사람이 순위표의 맨 위에 자리한다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img.png"
width="1390"
height="560"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_hu968a6c0a83c3daa84d4ec97bc604aae0_41694_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_hu968a6c0a83c3daa84d4ec97bc604aae0_41694_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="순위표"
class="gallery-image"
data-flex-grow="248"
data-flex-basis="595px"
>&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;ul>
&lt;li>게임에 승리하면 포인트 획득&lt;/li>
&lt;li>모든 플레이어가 순위표에 포함&lt;/li>
&lt;li>새로운 토너먼트를 시작할 때 마다 새로운 순위표 생성&lt;/li>
&lt;li>상위 10명의 사용자와 특정 사용자의 순위를 순위표에 표시
&lt;ul>
&lt;li>특정 사용자의 순위를 보여줄 때 위, 아래로 4순위 차이 사용자 포함(추가 요구사항)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DAU 500만명, MAU 2,500만명&lt;/li>
&lt;li>각 선수는 하루에 평균 10 경기 진행&lt;/li>
&lt;li>실시간 또는 실시간에 가깝게 결과를 표시&lt;/li>
&lt;li>누적된 결과 이력을 보여주는건 바람직하지 않음&lt;/li>
&lt;/ul>
&lt;h3 id="기능-요구사항">기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>순위표에 상위 10명의 플레이어를 표시&lt;/li>
&lt;li>특정 사용자의 순위를 표시&lt;/li>
&lt;li>어떤 사용자보다 4순위 위, 아래에 있는 사용자를 표시(추가 요구 사항)&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>점수 업데이트는 실시간으로 순위표에 반영&lt;/li>
&lt;li>일반적인 확장성, 가용성 및 안정성 요구사항&lt;/li>
&lt;/ul>
&lt;h3 id="개략적인-규모-추정">개략적인 규모 추정&lt;/h3>
&lt;p>설계를 통해 해결해야 할 문제의 잠재적 규모와 과제를 결정하기 위한 몇가지 계산 결과를 살펴본다.&lt;/p>
&lt;p>게임은 대부분 사용량이 균등한 경우가 없으며, 북미 기준 저녁 시간이 피크 시간대일 가능성이 높다.&lt;/p>
&lt;p>이를 고려하여 최대 부하는 평균의 다섯배 정도로 가정한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>사용자 수&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>500만 / 10^5 초 =~ 50 * 5 = 초당 250 사용자&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>점수 획득 QPS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>한 사용자가 하루 평균 10개의 게임을 플레이한다고 가정&lt;/li>
&lt;li>점수를 획득하는 이벤트가 발생하는 평균 QPS는 &lt;code>50 * 10 =~ 500&lt;/code>&lt;/li>
&lt;li>최대 QPS는 평균의 5배로 가정하였으므로 &lt;code>500 * 5 = 2,500&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>상위 10명 순위표 가져오기&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>각 사용자가 하루 한 번 게임을 실행&lt;/li>
&lt;li>상위 10명 순위표는 사용자가 처음 게임을 열 때만 표시한다고 가정&lt;/li>
&lt;li>&lt;code>QPS =~ 50&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="api-설계">API 설계&lt;/h3>
&lt;p>개략적으로 3가지 API가 필요하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>POST /v1/scores&lt;/code>&lt;/strong>&lt;/p>
&lt;p>사용자가 게임에서 승리하면 순위표에서 사용자의 순위를 갱신한다.&lt;/p>
&lt;p>API는 게임 서버에서만 호출할 수 있는 내부 API로 클라이언트는 해당 API를 통하지 않고 순위표 점수를 직접 업데이트 할 수 없다.&lt;/p>
&lt;ul>
&lt;li>요청&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>필드&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>user_id&lt;/code>&lt;/td>
&lt;td>게임에서 승리한 사용자&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>points&lt;/code>&lt;/td>
&lt;td>사용자가 게임에서 승리하여 획득한 포인트 수&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>응답&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>이름&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>200 OK&lt;/code>&lt;/td>
&lt;td>사용자 점수를 성공적으로 갱신&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>400 Bad Request&lt;/code>&lt;/td>
&lt;td>잘못된 인자가 전달되어 사용자 점수를 갱신할 수 없음&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/scores&lt;/code>&lt;/strong>&lt;/p>
&lt;p>순위표에서 상위 10명의 플레이어를 조회&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;data&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;user_id1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;alice&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;rank&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;score&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">12543&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;user_id2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;bob&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;rank&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;score&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">11500&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;total&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>`GET /v1/scores/{:user_id}&lt;/strong>&lt;/p>
&lt;p>특정 사용자의 순위를 가져옴&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>필드&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>user_id&lt;/code>&lt;/td>
&lt;td>순위 정보를 가져올 사용자 ID&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_info&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;user5&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;score&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;rank&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>두 가지 서비스가 포함된다.&lt;/p>
&lt;ul>
&lt;li>게임 서비스
&lt;ul>
&lt;li>사용자가 게임을 플레이할 수 있도록 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>순위표 서비스
&lt;ul>
&lt;li>순위표를 생성하고 표시하는 역할 담당&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_1.png"
width="1102"
height="1066"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_1_hu51c0eaf019b910cb8404ff183ad3d839_54249_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_1_hu51c0eaf019b910cb8404ff183ad3d839_54249_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계"
class="gallery-image"
data-flex-grow="103"
data-flex-basis="248px"
>&lt;/p>
&lt;ol>
&lt;li>사용자가 게임에서 승리하면 클라이언트는 게임 서비스에 요청을 보낸다.&lt;/li>
&lt;li>게임 서비스는 해당 승리가 정당하고 유효한 것인지 확인한 다음 순위표 서비스에 점수 갱신 요청을 보낸다.&lt;/li>
&lt;li>순위표 서비스는 순위표 저장소에 기록된 해당 사용자의 점수를 갱신한다.&lt;/li>
&lt;li>해당 사용자의 클라이언트는 순위표 서비스에 직접 요청하여 다음과 같은 데이터를 가져온다.
&lt;ul>
&lt;li>상위 10명 순위표&lt;/li>
&lt;li>해당 사용자 순위&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>다른 대안들도 있지만 채택하지 않은 이유를 살펴보면 도움이 될 것이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>클라이언트가 순위표 서비스와 직접 통신해야 하나?&lt;/strong>&lt;/p>
&lt;p>클라이언트가 점수를 정하는 방식(클라이언트가 직접 순위표 서비스에 요청하는 방식)은, 사용자가 프락시를 설치하고 점수를 마음대로 바꾸는 중간자 공격을 할 수 있기 때문에 보안상 안전하지 않다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_2.png"
width="1366"
height="1108"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_2_hu9c2130220f7a6e4a19f502b9d6fb58c8_75990_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_2_hu9c2130220f7a6e4a19f502b9d6fb58c8_75990_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="순위표 점수는 누가 설정하는가"
class="gallery-image"
data-flex-grow="123"
data-flex-basis="295px"
>&lt;/p>
&lt;p>서버가 게임 전반을 통솔하는 경우 클라이언트가 점수를 설정하기 위해서 게임 서버를 명시적으로 호출할 필요가 없을수도 있다.&lt;/p>
&lt;ul>
&lt;li>게임 서버가 모든 게임 로직을 처리하고 게임이 언제 끝나는지 알기 때문에 클라이언트의 개입 없이도 점수를 정할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>게임 서비스와 순위표 서버 사이에 메시지 큐가 필요한가?&lt;/strong>&lt;/p>
&lt;p>게임 점수가 어떻게 사용되는지에 따라 크게 달라질 수 있다.&lt;/p>
&lt;p>해당 데이터가 다른 곳에서도 이용되거나 여러 기능을 지원해야 한다면 카프카에 데이터를 넣는 것이 합리적일 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_3.png"
width="1372"
height="516"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_3_hu1571b99ddafa8ab0beb62502c9444491_33359_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_3_hu1571b99ddafa8ab0beb62502c9444491_33359_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="게임 점수를 여러 서비스에서 사용하는 방안"
class="gallery-image"
data-flex-grow="265"
data-flex-basis="638px"
>&lt;/p>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>순위표 저장소는 시스템의 핵심 구성 요소 중 하나다.&lt;/p>
&lt;p>저장소 구현에 사용할 수 있는 세 가지 기술을 살펴본다.&lt;/p>
&lt;h4 id="관계형-데이터베이스">&lt;strong>관계형 데이터베이스&lt;/strong>&lt;/h4>
&lt;p>규모 확정성이 중요하지 않고, 사용자 수가 적다면 관계형 데이터베이스 시스템을 활용할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_4.png"
width="884"
height="580"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_4_hu87323fa7d86eb1b53840a0a18b78a259_68258_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_4_hu87323fa7d86eb1b53840a0a18b78a259_68258_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="leaderboard 테이블"
class="gallery-image"
data-flex-grow="152"
data-flex-basis="365px"
>&lt;/p>
&lt;p>각 &lt;strong>월별 순위표&lt;/strong>는 사용자 ID와 점수 열을 갖는 데이블로 표현할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>사용자가 점수를 딴 경우&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_5.png"
width="1354"
height="216"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_5_hu0a7ccfe89d76bf8da6055832ddc6d048_15214_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_5_hu0a7ccfe89d76bf8da6055832ddc6d048_15214_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="사용자가 점수를 획득한 경우"
class="gallery-image"
data-flex-grow="626"
data-flex-basis="1504px"
>&lt;/p>
&lt;p>점수가 1점씩만 늘어난다고 가정하면 해당 월의 순위표에 아직 햊당 사용자가 없다면 새로운 레코드를 만들어 넣고,&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leaderboard&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;mary1934&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>있다면 증가시킨다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">UPDATE leaderboard set score=score + 1 where user_id=&amp;#39;mary1934&amp;#39;;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>특정 사용자 순위 검색&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_6.png"
width="1364"
height="242"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_6_hu9653a2a00caf7b6c21525c7fedeabb71_17500_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_6_hu9653a2a00caf7b6c21525c7fedeabb71_17500_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="사용자의 순위 검색"
class="gallery-image"
data-flex-grow="563"
data-flex-basis="1352px"
>&lt;/p>
&lt;p>사용자의 순위를 가져오려면 순위표 테이블을 점수 기준으로 정렬한 후 순위를 매긴다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">@&lt;/span>&lt;span class="n">rownum&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@&lt;/span>&lt;span class="n">rownum&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rank&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leaderboard&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>이 방안은 데이터가 많지 않을 때는 효과적이지만, 레코드가 수백만 개 정도로 많아지면 성능이 너무 나빠지는 문제가 있다.&lt;/p>
&lt;ul>
&lt;li>사용자의 순위를 파악하려면 모든 플레이어를 순외표의 정확산 위치에 정렬해야한다.&lt;/li>
&lt;li>같은 점수를 받은 사용자가 여럿일 수 있으므로, 순위는 단순히 해당 목록 내의 사용자 위치라고도 할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>SQL 데이터베이스는 지속적으로 변화하는 대량의 정보를 신속하게 처리하지 못한다.&lt;/p>
&lt;ul>
&lt;li>수백만 개 레코드에 순위를 매기려면 대략 수십 초 정도가 걸린다.&lt;/li>
&lt;/ul>
&lt;p>따라서 실시간성을 요구하는 애플레키에션에는 적합하지 않고, 데이터가 지속적으로 변경되므로 캐시 도입도 어렵다.&lt;/p>
&lt;ul>
&lt;li>일괄 작업(배치)로 처리하면 가능할 수 있지만 실시간 순위를 보여주어야 한다는 요구사항에는 적절치 않다.&lt;/li>
&lt;/ul>
&lt;p>인덱스를 추가하고 &lt;code>LIMIT&lt;/code> 절을 사용하여 스캔할 페이지 수를 제한할 수 있지만, 확장성이 좋지 않다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">@&lt;/span>&lt;span class="n">rownum&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@&lt;/span>&lt;span class="n">rownum&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rank&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leaderboard&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>특정 사용자의 순위를 알아내려면 기본적으로 전체 테이블을 훑어야 한다.&lt;/li>
&lt;li>순위표 상단에 있지 않은 사용자의 순위를 간단히 찾을 수 없다.&lt;/li>
&lt;/ul>
&lt;h4 id="레디스">레디스&lt;/h4>
&lt;p>레디스는 메모리 기반 키-값 저장소 시스템으로 메모리에서 동작하여 빠른 읽기 및 쓰기가 가능하다.&lt;/p>
&lt;p>이를 통해 수백만 명의 사용자에 대해서도 예측 가능한 ㅅ어능ㅇ르 제공하고 복잡한 DB 쿼리 없이도 일반적인 순위표 작업을 쉽게 수행할 수 있다.&lt;/p>
&lt;p>아울러 순위표 시스템 설계 문제를 해결하는 데 이상적인 &lt;strong>정렬 집합&lt;/strong>(sorted set)이라는 자료형을 제공한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>정렬 집합이란?&lt;/strong>&lt;/p>
&lt;p>집합과 유사항 자료형으로 저장된 각 원소는 점수에 연결되어 있다.&lt;/p>
&lt;p>집합 내 원소는 고유해야 하지만 같은 점수는 있을 수도 있고, 정렬 집합 내 원소를 오름차순 정렬하는 데 이용된다.&lt;/p>
&lt;p>정렬 집합은 내부적으로 해시 테이블과 스킵 리스트라는 두 가지 자료 구조를 사용한다.&lt;/p>
&lt;ul>
&lt;li>해시 테이블: 사용자의 점수를 저장&lt;/li>
&lt;li>스킵 리스트: 특정 점수를 딴 사용자들의 목록을 저장&lt;/li>
&lt;/ul>
&lt;p>사용자는 점수를 기준으로 정렬한다.&lt;/p>
&lt;ul>
&lt;li>점수 및 사용자 열이 있는 테이블로 생각하면 이해하기 쉽다.
&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_7.png"
width="1352"
height="760"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_7_hu85fd85f56d1e350543434c4ec022a6b0_119803_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_7_hu85fd85f56d1e350543434c4ec022a6b0_119803_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="정렬 집합으로 표현한 2월 순위표"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>스킵 리스트&lt;/strong>&lt;/p>
&lt;p>빠른 검색을 가능하게 하는 자료구조로, 정렬된 연결 리스트에 다단계 색인을 두는 구조이다.&lt;/p>
&lt;p>이 자료 구조의 근간은 정렬된 단방향 연결 리스트로, 이 연결 리스트에 삽입, 삭제, 검색 연산을 실행하는 시간 복잡도는 &lt;code>O(n)&lt;/code>이다.&lt;/p>
&lt;p>연산이 더 빨리 실행할 수 있도록 하기 위해 이진 검색 알고리즘을 통해 중간 지점에 더 빨리 도달할 수 있도록 한다.&lt;/p>
&lt;ul>
&lt;li>중간 노드를 하나씩 건너뛰는 1차 색인과 1차 색인 노드를 하나씩 건너 뛰는 2차 색인을 추가한다.&lt;/li>
&lt;/ul>
&lt;p>새로운 색인을 추가할 때마다 이전 차수의 노드를 하나씩 건너뛸 수 있다.&lt;/p>
&lt;ul>
&lt;li>노드 사이의 거리가 &lt;code>n-1&lt;/code>이 되면 더 이상의 색인을 추가하지 않는다.&lt;/li>
&lt;li>n은 총 노드의 개수&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_8.png"
width="1342"
height="1182"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_8_hu61e3939b81b6b789001ba6d07810bb60_81509_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_8_hu61e3939b81b6b789001ba6d07810bb60_81509_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="스킵 리스트"
class="gallery-image"
data-flex-grow="113"
data-flex-basis="272px"
>&lt;/p>
&lt;p>다단계 색인을 사용하면 특정 값을 훨씬 빠르게 찾을 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_9.png"
width="1956"
height="322"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_9_hu9354600d37260ed8b8d530bf7b5a8225_24588_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_9_hu9354600d37260ed8b8d530bf7b5a8225_24588_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="5차 색인까지 사용하는 스킵 리스트"
class="gallery-image"
data-flex-grow="607"
data-flex-basis="1457px"
>&lt;/p>
&lt;p>데이터 양이 적을 때는 스킵 리스트의 속도 개선 효과가 분명하지 않지만, 5차 색인까지 사용하는 스킵 리스트를 예시로 들면 개선을 확인할 수 있다.&lt;/p>
&lt;p>기본 리스트만 있는 경우 찾는 노드에 도달하기 위해 62개의 노드를 거쳐야하지만, 스킵 리스트의 경우에는 11개의 노드만 통과하면 된다.&lt;/p>
&lt;p>정렬 집합은 삽입이나 갱신 연산을 할 때 모든 원소가 올바른 위치에 자동으로 배치되며 새 원소를 추가하거나 기존 원소를 검색하는 연산의 시간 복잡도가 &lt;code>O(log(n))&lt;/code>이므로 관계형 데이터베이스보다 성능이 좋다.&lt;/p>
&lt;p>관계형 데이터베이스에서 특정 사용자의 순위를 계산하려면 중첩 질의문을 수행해야한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">,(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COUNT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leaderboard&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lb2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lb2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lb1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RANK&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leaderboard&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lb1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lb1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">{&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>레디스 정렬 집합을 사용한 구현&lt;/strong>&lt;/p>
&lt;p>순위표 구현에 사용할 레디스 연산들을 살펴본다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>ZADD&lt;/code>
&lt;ul>
&lt;li>기존에 없던 사용자를 집합에 추가한다.&lt;/li>
&lt;li>기존 사용자의 경우에는 점수를 업데이트한다.&lt;/li>
&lt;li>&lt;code>O(log(n))&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ZINCRBY&lt;/code>
&lt;ul>
&lt;li>사용자 점수를 지정된 값 만큼 증가시킨다.&lt;/li>
&lt;li>집합에 없는 사용자는 0점으로 가정한다.&lt;/li>
&lt;li>&lt;code>O(log(n))&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ZRANGE&lt;/code>/&lt;code>ZREVRANGE&lt;/code>
&lt;ul>
&lt;li>점수에 따라 정렬된 사용자 중 특정 범위에 드는 사용자들을 가져온다.&lt;/li>
&lt;li>순서, 항목 수, 시작 위치를 지정할 수 있다.&lt;/li>
&lt;li>&lt;code>O(log(n) + m)&lt;/code>
&lt;ul>
&lt;li>&lt;code>m&lt;/code>: 가져올 항목 수&lt;/li>
&lt;li>&lt;code>n&lt;/code>: 정렬 집합의 크기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ZRANK&lt;/code>/&lt;code>ZREVRANK&lt;/code>
&lt;ul>
&lt;li>오름차순/내림차순 정렬하였을 때 특정 사용자의 위치를 가져온다.&lt;/li>
&lt;li>&lt;code>O(log(n))&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;code>ZREVRANGE&lt;/code>는 향후 사용이 중단될 명령으로, &lt;code>ZRANGE&lt;/code> 명령에 추가 속성을 전달하면 같은 결과를 얻을 수 있다.&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>&lt;strong>사용자가 점수를 획득한 경우&lt;/strong>&lt;/p>
&lt;p>매 월 새로운 순위표를 위한 정렬 집합을 만들고 이전 순위표는 이력 데이터 저장소로 보낸다.&lt;/p>
&lt;p>사용자는 승리하면 점수를 얻은데, &lt;code>ZINCRBY&lt;/code>를 호출하여 사용자 점수를 증가시키거나 순위표 세트에 없는 경우 사용자를 순위표 집합에 추가한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZINCRBY leaderboard_feb_2021 1 &amp;#39;mary1934&amp;#39;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>사용자가 순위표 상위 10명을 조회하는 경우&lt;/strong>&lt;/p>
&lt;p>가장 높은 점수를 받은 사용자로부터 내림차순으로 정렬한 결과를 가져와야 하므로 &lt;code>ZREVRANGE&lt;/code>를 호출한다.&lt;/p>
&lt;p>사용자 목록뿐 아니라 각 사용자의 현재 점수도 가져와야 하므로 &lt;code>WITHSCORES&lt;/code> 속성도 전달한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZREVRANGE leaderboard_feb_2021 0 9 WITHSCORES
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>다음과 같은 목록이 반환된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[(user2,score2),(user1,score1),(user5,score5)...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>사용자가 자기 순위를 조회하는 경우&lt;/strong>&lt;/p>
&lt;p>&lt;code>ZREVRANK&lt;/code>를 호출하면 특정 사용자의 순위를 가져올 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZREVRANGE leaderboard_feb_2021 357 365
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>특정 사용자 순위를 기준으로 일정 범위 내 사용자를 질의하는 경우&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_10.png"
width="1344"
height="1112"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_10_hucd013a2567009eacc82bc2b2f59fca18_84653_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_10_hucd013a2567009eacc82bc2b2f59fca18_84653_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="특정 사용자 직전 순위 사용자 4명, 직후 순위 사용자 4명"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="290px"
>&lt;/p>
&lt;p>&lt;code>ZREVRANGE&lt;/code>를 활용하면 특정한 사용자 전/후 순위 사용자 목록을 얻어낼 수 있다.&lt;/p>
&lt;p>&lt;code>Mallow007&lt;/code>의 사용자가 361등이고, 전 후로 4명씩 조회한다면&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZREVRANGE leaderboard_feb_2021 357 365
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="저장소-요구사항">저장소 요구사항&lt;/h3>
&lt;p>최소한 &lt;code>사용자 ID&lt;/code>와 &lt;code>점수&lt;/code>는 저장해야 한다.&lt;/p>
&lt;p>최악의 시나리오는 월간 활성 사용자 2,500만 명 모두가 최소 한 번 이상 게임에서 승리하는 바람에 모두 월 순위표에 올라야 하는 경우이다.&lt;/p>
&lt;ul>
&lt;li>ID: 24자 문자열&lt;/li>
&lt;li>점수: 16비트 정수&lt;/li>
&lt;li>순위표 한 항목당 26바이트 필요&lt;/li>
&lt;li>MAU 순위표 항목이 하나라는 최악의 시나리오를 가정하면 &lt;code>26바이트 * 2,500만 = 650MB&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>이 정도라면 스킵 리스트 구현에 필요한 오베헤드와 정렬 집합 해시를 고려해 메모리 사용량을 두 배로 늘린다고 해도 최신 레디스 서버 한 대만으로도 데이터를 충분히 저장할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>CPU 및 I/O 사용량&lt;/strong>&lt;/p>
&lt;p>개략적인 추정치에 따르면 갱신 연산의 최대 QPS는 2500/초 정도로 레디스 서버로도 충분히 감당할 수 있는 부하이다.&lt;/p>
&lt;p>하지만 레디스 노드에 장애 발생으로 인한 영속성을 고려해야한다.&lt;/p>
&lt;p>레디스는 데이터를 디스크에 영속적으로 보관하는 옵션도 지원하나, 디스크에서 데이터를 읽어 대규모 레디스 인스턴스를 재시작하려면 시간이 많이 걸린다.&lt;/p>
&lt;ul>
&lt;li>그래서 보통은 레디스에 읽기 사본을 두는 방식으로 구성한다.&lt;/li>
&lt;/ul>
&lt;p>MySQL과 같은 관계형 데이터베이스를 사용하는 경우에는 사용자와 점수 테이블이 필요하다.&lt;/p>
&lt;p>점수 테이블에는 사용자 ID, 점수, 게임에서 승리한 시각(타임스템프)를 저장하여 경연 기록 등과 같은 다른 게임 기능 구현에 활용될 수 있고, 인프라 장애 발생 시 레디스 순위표를 복구하는 데에도 활용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>가장 자주 검색되는 상위 10명의 사용자 정보를 캐시하면 쉽게 성능을 최적화 할 수 있다.&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="클라우드-서비스-사용-여부">클라우드 서비스 사용 여부&lt;/h3>
&lt;p>솔루션 배포 방식은 기존 인프라 구성 형태에 따라 일반적으로 두 가지로 나눌 수 있다.&lt;/p>
&lt;h4 id="자체-서비스-사용">자체 서비스 사용&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_11.png"
width="1836"
height="770"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_11_huc99aadd03e637796689cc9fe1c2d43ef_172903_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_11_huc99aadd03e637796689cc9fe1c2d43ef_172903_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="자체 서버스를 이용하는 방안"
class="gallery-image"
data-flex-grow="238"
data-flex-basis="572px"
>&lt;/p>
&lt;ul>
&lt;li>매월 정렬 집합을 생성하여 사용자 및 점수 정보를 이용해 해당 기간의 순위표를 저장한다.&lt;/li>
&lt;li>이름 및 프로필 이미지와 같은 사용자 세부 정보는 MySQL 데이터베이스에 저장한다.&lt;/li>
&lt;/ul>
&lt;p>순위표를 가져올 때 API 서버는 순위 데이터와 더불어 데이터베이스에 저장된 사용자 이름과 프로필 이미지도 가져온다.&lt;/p>
&lt;ul>
&lt;li>이 작업이 장기적으로 너무 비효율적이면 상위 사용자 10명의 세부 정보를 저장하는 프로필 캐시를 두어 해결할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="클라우드-서비스-이용">클라우드 서비스 이용&lt;/h4>
&lt;blockquote>
&lt;p>기존 인프라가 AWS에 있어 클라우드로 순위표를 구축하는 것이 자연스러운 상황이라 가정한다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>아마존 API 게이트웨이&lt;/strong>와 &lt;strong>AWS 람다&lt;/strong>(Lambda) 두 가지를 활용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>API 게이트웨이를 사용하면 RESTful API의 HTTP 엔드포인트를 정의하고 아무 백엔드 서비스에나 연결할 수 있다.&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>람다 함수&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>GET /v1/scores&lt;/code>&lt;/td>
&lt;td>&lt;code>LeaderboardFetchTop10&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>GET /v1/scores/{:user_id}&lt;/code>&lt;/td>
&lt;td>&lt;code>LeaderboardFetchPlayerRank&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>GET /v1/scores&lt;/code>&lt;/td>
&lt;td>&lt;code>LeaderboardUpdateScores&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>&lt;strong>AWS 람다&lt;/strong>&lt;br>
가장 인기있는 서버리스 컴퓨팅 플랫폼 중 하나로 서버를 직접 준비하거나 관리할 필요 없이 코드를 실행할 수 있다.&lt;br>
람다는 필요할 때만 실행되며 트래픽에 따라 규모가 자동으로 확장된다.&lt;/p>
&lt;/blockquote>
&lt;p>개략적으로 설명하면&lt;/p>
&lt;ol>
&lt;li>API 게이트웨이를 호출&lt;/li>
&lt;li>게이트웨이는 적절한 람다 함수를 호출&lt;/li>
&lt;li>스토리지 계층(레디스 및 MySQL)의 명령을 호출하여 얻은 결과를 API 게이트웨이에 반환&lt;/li>
&lt;li>API 게이트웨이는 그 결과를 애플리케이션에 전달&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>람다 함수를 사용하면 서버 인스턴스를 만들지 않아도 질의를 실행할 수 있다.
&lt;ul>
&lt;li>레디스를 호출할 수 있도록 하는 클라이언트를 제공한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>람다를 사용하면 DAU 성장세에 맞춰 자동으로 서비스 규모를 확장할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>점수 획득&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_12.png"
width="1978"
height="496"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_12_hua00e417a6ce8d46751065c258b5a49fc_148407_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_12_hua00e417a6ce8d46751065c258b5a49fc_148407_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="점수 획득"
class="gallery-image"
data-flex-grow="398"
data-flex-basis="957px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>순위 검색&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_13.png"
width="1964"
height="506"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_13_hud870a85155701f522546b2affcdafcf0_158178_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_13_hud870a85155701f522546b2affcdafcf0_158178_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="순위 검색"
class="gallery-image"
data-flex-grow="388"
data-flex-basis="931px"
>&lt;/p>
&lt;hr>
&lt;p>람다는 서비리스 접근 방식이라 인프라의 규모가 필요에 맞게 자동으로 확장되며, 환경 설정, 유지 보수 등의 문제를 직접 관리할 필요가 없다.&lt;/p>
&lt;h3 id="레디스-규모-확장">레디스 규모 확장&lt;/h3>
&lt;p>5백만 DAU 정도라면 한 대의 레디스 캐시 서버로도 충분히 지원 가능하나, 원래 규모의 100배인 5억 DAU를 처리해야한다면 규모 확장이 필요하다.&lt;/p>
&lt;ul>
&lt;li>저장 용량은 65GB&lt;/li>
&lt;li>250,000 QPS 처리&lt;/li>
&lt;/ul>
&lt;p>이 정도 규모를 감당하려면 샤딩이 필요하다.&lt;/p>
&lt;h4 id="데이터-샤딩-방안">데이터 샤딩 방안&lt;/h4>
&lt;p>고정 파티션과 해시 파티션 방식을 고려할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>고정 파티션&lt;/strong>&lt;/p>
&lt;p>순위표에 등장하는 점수의 범위에 따라 파티션을 나누는 방안이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_14.png"
width="1856"
height="206"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_14_hu7658f9e716ce647a0256027405e30bb0_20879_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_14_hu7658f9e716ce647a0256027405e30bb0_20879_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="고정 파티션"
class="gallery-image"
data-flex-grow="900"
data-flex-basis="2162px"
>&lt;/p>
&lt;ul>
&lt;li>획득할 수 있는 점수가 1~1000 이라면 데이터를 범위별로 나눈다.&lt;/li>
&lt;li>(1~100), (101~200) &amp;hellip;, (901, 1000)&lt;/li>
&lt;/ul>
&lt;p>이 기능이 제대로 작동하려면 순위표 전반에 점수가 고르게 분포되어야 하며, 그렇지 않다면 각 샤드에 할당되는 점수 범위를 조정하여 비교적 고른 분포가 되도록 해야한다.&lt;/p>
&lt;hr>
&lt;p>애플리케이션이 샤딩 처리의 추제라면 특정 사용자의 점수를 입력하거나 갱신할 때 해당 사용자가 어느 샤드에 있는지 알아야 한다.&lt;/p>
&lt;ul>
&lt;li>MySQL 질의로 사용자의 현재 점수를 계산하여 알아낼 수도 있다.&lt;/li>
&lt;li>사용자 ID와 점수 사이의 관계를 저장하는 2차 캐시를 활용하면 성능을 더 높일 수 있다.&lt;/li>
&lt;/ul>
&lt;p>사용자의 점수가 높아져서 다른 샤드로 옮겨야 할 때는 기존 샤드에서 해당 사용자를 제거한 다음 새 샤드로 옮겨야 한다.&lt;/p>
&lt;hr>
&lt;p>순위표에서 상위 10명의 플레이어를 가져오려면, 가장 높은 점수가 저장되는 샤드에서 상위 10명을 가져온다.&lt;/p>
&lt;p>특정 사용자의 순위를 알려면 해당 사용자가 속한 샤드 내 순위뿐 아니라 해당 샤드보다 높은 점수를 커버하는 모든 샤드의 모든 사용자 수를 알아야 한다.&lt;/p>
&lt;ul>
&lt;li>특정 샤드에 속한 모든 사용자 수는 &lt;code>info keyspace&lt;/code> 명령을 통해 &lt;code>O(1)&lt;/code>시간에 알아낼 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>해시 파티션&lt;/strong>&lt;/p>
&lt;p>레디스 클러스터를 사용하는 방법으로 사용자들의 점수가 특정 대역에 과도하게 모여있는 경우 효과적이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_15.png"
width="1694"
height="1344"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_15_huf77687aca255ea1376fddaaa280306c9_415936_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_15_huf77687aca255ea1376fddaaa280306c9_415936_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="해시 파티션"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="302px"
>&lt;/p>
&lt;blockquote>
&lt;p>레디스 클러스터&lt;br>
안정 해시는 사용하지 않지만 각 키가 특정한 해시 슬롯에 속하도록 하는 샤딩 기법을 사용한다.&lt;/p>
&lt;ul>
&lt;li>총 16384개 해시 슬롯이 있으며, &lt;code>CRC16(key) % 16384&lt;/code>의 연산을 수행하여 어떤 키가 어느 슬롯에 속하는지 계산한다.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>모든 키를 재분배하지 않아도 클러스터에 쉽게 노드를 추가하거나 제거할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>점수 갱신&lt;/strong>&lt;br>
점수를 갱신하려면 해당 사용자의 샤드를 찾아(&lt;code>CRC16(key) % 16394&lt;/code>) 해당 사용자의 점수를 변경한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>상위 10명 플레이어 검색&lt;/strong>&lt;/p>
&lt;p>모든 샤드에서 상위 10명을 받아 애플리케이션 내에서 다시 정렬하는 &lt;strong>분산-수집&lt;/strong>(scatter-gather) 접근법을 사용해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_16.png"
width="1460"
height="1388"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_16_hu1e8e084fe62cd2c4275cacc14a07a2eb_271118_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_16_hu1e8e084fe62cd2c4275cacc14a07a2eb_271118_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="분산-수집 방안"
class="gallery-image"
data-flex-grow="105"
data-flex-basis="252px"
>&lt;/p>
&lt;p>모든 샤드에 사용자를 질의하는 절차를 병렬화하면 지연 시간을 줄일수 있지만 다음과 같은 문제가 있다.&lt;/p>
&lt;ul>
&lt;li>상위 k개의 결과를 반환해야 하는 경우(k는 매우 큰 값) 각 샤드에서 많은 데이터를 읽고 정렬해야 하므로 지연 시간이 늘어난다.&lt;/li>
&lt;li>가장 느린 파티션에서 데이터를 다 읽고 나서야 질의 결과를 계산할 수 있으므로 지연 시간이 길어진다.&lt;/li>
&lt;li>특정 사용자의 순위를 결정할 간단한 방법이 없다.&lt;/li>
&lt;/ul>
&lt;p>따라서 고정 파티션 방안을 활용한다.&lt;/p>
&lt;h4 id="레디스-노드-크기-조정">&lt;strong>레디스 노드 크기 조정&lt;/strong>&lt;/h4>
&lt;p>레디스 노드의 크기를 조정할 때 여러가지를 고려해야한다.&lt;/p>
&lt;p>쓰기 작업이 많은 애플리케이션에서는 장애에 대비해 스냇숏을 생성할 때 필요한 모든 쓰기 연산을 감당할 수 있어야 하므로 많은 메모리가 필요하다.&lt;/p>
&lt;ul>
&lt;li>메모리를 두 배 더 할당하는 것이 안전하다.&lt;/li>
&lt;/ul>
&lt;p>레디스는 성능 밴체마킹을 위해 &lt;code>redis-benchmark&lt;/code>라는 도구를 제공하므로, 여러 클라이언트가 동시에 여러 질의를 실행하는 것을 실뮬레이션하여 주어진 하드웨어로 초당 얼마나 많은 요청을 처리할 수 있는지 측정할 수 있다.&lt;/p>
&lt;h4 id="대안-nosql">대안: NoSQL&lt;/h4>
&lt;p>NoSQL 데이터베이스를 다른 솔루션으로 고려할 수 있으며, 다음과 같은 데이터베이스가 이상적이다.&lt;/p>
&lt;ul>
&lt;li>쓰기 연산에 최적화&lt;/li>
&lt;li>같은 파티션 내의 항목을 점수에 따라 효율적으로 정렬 가능&lt;/li>
&lt;/ul>
&lt;p>아마존 DynamoDB, 카산드라, MongoDB 등을 고려할 수 있는데, DynamoDB를 예시로 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_17.png"
width="1344"
height="286"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_17_huc61d6265b699516ef39c14922102b774_97876_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_17_huc61d6265b699516ef39c14922102b774_97876_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="DynamoDB 기반 솔루션"
class="gallery-image"
data-flex-grow="469"
data-flex-basis="1127px"
>&lt;/p>
&lt;blockquote>
&lt;p>DynamoDB&lt;br>
안정적인 성능과 뛰어난 확장성을 제공하는 완전 관리형 NoSQL 데이터베이스로, 기본키 이외의 속성을 활용하여 데이터를 효과적으로 질의할 수 있도록, 전역 보조 색인을 제공한다.&lt;/p>
&lt;/blockquote>
&lt;p>전역 보조 색인은 부모 테이블의 속성들로 구성되지만 기본 키는 부모 테이블과는 다르다.&lt;/p>
&lt;hr>
&lt;p>체스 게임의 순위표를 설계하고, 데이터베이스 테이블은 순위표와 사용자 테이블을 비정규화 한 것으로 순위표를 화면에 표시하는 데 필요한 모든 정보를 담고 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_18.png"
width="1452"
height="532"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_18_hu9da5772d01231304c597cd3dfad33994_246694_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_18_hu9da5772d01231304c597cd3dfad33994_246694_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="순위표 및 사용자 테이블의 비정규화"
class="gallery-image"
data-flex-grow="272"
data-flex-basis="655px"
>&lt;/p>
&lt;p>이 방안은 레코드가 많아지면 상위 점수를 찾기 위해 전체 테이블을 뒤져야 하므로 사용자가 많아지면 성능이 떨어져 규모 확장이 어렵다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_19.png"
width="1464"
height="614"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_19_hua32ae9c65839c9e9bdba8742ab5270bb_257414_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_19_hua32ae9c65839c9e9bdba8742ab5270bb_257414_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="파티션 키 및 정렬 키"
class="gallery-image"
data-flex-grow="238"
data-flex-basis="572px"
>&lt;/p>
&lt;p>위와 같이 &lt;code>game_name#{year-month}&lt;/code>를 파티션 키로, 점수를 정렬 키로 사용하면 테이블 전체를 읽어야 하는 일을 피할 수 있지만, 부하가 높을 때 문제가 발생한다.&lt;/p>
&lt;p>DynamoDB는 안정 해시를 사용하여 여러 노드에 데이터를 분산하는데, 각 항목이 파티션 키에 따라 선정된 노드에 저장된다.&lt;/p>
&lt;p>위와 같이 테이블을 설계하면 가장 최근 한 달치 데이터가 동일한 파티션에 저장될 뿐 아니라 핫 파티션이 되고 만다.&lt;/p>
&lt;p>따라서 데이터를 n개 파티션으로 분할하고 파티션 번호(&lt;code>user_id % number_of_partitinons&lt;/code>)를 파티션 키에 추가하는 &lt;strong>쓰기 샤딩&lt;/strong>이라고 부르틑 패턴을 활용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>하지만 읽기 및 쓰기 작업 모두를 복잡하게 만드므로, 장단점을 꼼꼼히 따져봐야 한다.&lt;/li>
&lt;/ul>
&lt;p>쓰기 볼륨 또는 DAU를 기준으로 파티션의 수를 결정할 수 있으나 파티션이 받는 부하와 읽기 복잡도 사이에는 타협적인 부분이 있다.&lt;/p>
&lt;ul>
&lt;li>같은 달 데이터를 여러 파티션에 고르게 분산시키면 한 파티션이 받는 부하는 낮아짐&lt;/li>
&lt;li>특정한 달의 데이터를 읽으려고 하면 모든 파티션을 질의한 결과를 합쳐야 하므로 구현은 복잡해짐&lt;/li>
&lt;/ul>
&lt;p>파티션 키는 &lt;code>game#{year-moth}#p{partition_number}&lt;/code>와 같이 지정할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_20.png"
width="1450"
height="598"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_20_hu3a0e87c0bef2264457ba3bd9686d164f_269843_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_20_hu3a0e87c0bef2264457ba3bd9686d164f_269843_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="새로운 파티션 키"
class="gallery-image"
data-flex-grow="242"
data-flex-basis="581px"
>&lt;/p>
&lt;p>전역 보조 색인은 &lt;code>game#{year-moth}#p{partition_number}&lt;/code>를 파티션 키로, 점수를 정렬 키로 사용하게 구성한다.&lt;/p>
&lt;ul>
&lt;li>같은 파티션 내 데이터는 전부 점수 기준으로 정렬된 n개의 파티션이 만들어진다.&lt;/li>
&lt;/ul>
&lt;p>3개 파티션이 있다고 했을 때 상위 10명의 사용자를 가져오려면 &lt;strong>분산-수집&lt;/strong> 접근법을 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_21.png"
width="1744"
height="1284"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_21_hu7ef60b94fc6260de3accc6dec63a7cc1_363372_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_21_hu7ef60b94fc6260de3accc6dec63a7cc1_363372_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="분산 수집"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="325px"
>&lt;/p>
&lt;p>파티션 수는 신중한 벤치마킹이 필요할 수 있다.&lt;/p>
&lt;ul>
&lt;li>파티션이 많으면 각 파티션의 부하는 줄지만 최종 순위표를 만들기 위해 읽어야 하는 파티션은 더 많으므로 복잡성은 증가&lt;/li>
&lt;/ul>
&lt;p>그러나 앞서 언급한 레디스 파티션 기법과 마찬가지로, 사용자의 상대적 순위를 쉽게 정할 수 없다.&lt;/p>
&lt;p>하지만 사용자의 위치의 백분위수를 구하는 것은 가능하며, 충분히 괜찮은 방법일 수 있다.&lt;/p>
&lt;ul>
&lt;li>ex) 상위 10~20%에 속함&lt;/li>
&lt;li>규모가 충분히 커서 샤딩이 필요한 상황이라면 모든 샤드의 점수 분포는 거의 같다고 가정할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이 가정이 사실이라면 각 샤드의 점수 분포를 분석한 결과를 캐시하는 크론 작업을 만들어 볼 수도 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">10th percentile = score &amp;lt; 100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">20th percentile = score &amp;lt; 500
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">90th percentile = score &amp;lt; 6500
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이를 통해 사용자의 상대적 순위를 빠르게 계산할 수 있다.&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>이번 장에서는 수백만 DAU 규모의 실시간 게임 순위표를 구축하기 위한 솔루션을 설계해 보았다.&lt;/p>
&lt;ul>
&lt;li>MySQL 데이터베이스를 사용하는 간단한 솔루션부터 검토하여, 정렬 집합을 사용하여 순위표를 구현하기로 했다.&lt;/li>
&lt;li>여러 레디스 캐시에 데이터르 샤딩하여 5억 DAU도 지언할 수 있도록 규모를 확장하는 방안도 살펴보았다.&lt;/li>
&lt;li>대안으로 NoSQL 데이터베이스를 이용하는 방법도 살펴보았다.&lt;/li>
&lt;/ul>
&lt;p>시간이 남는다면 아래와 같은 주제도 살펴볼 수 있을것이다.&lt;/p>
&lt;h3 id="더-빠른-조회-및-동점자-순위-판정">더 빠른 조회 및 동점자 순위 판정&lt;/h3>
&lt;p>레디스 해시를 사용하면 문자열 필드와 값 사이의 대응 관계를 저장해 둘 수 있으며 아래와 같이 활용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>순위표에 표시할 사용자 ID와 사용자 객체 사이의 대응 관계를 저장하여 데이터베이스 질의를 줄일 수 있다.&lt;/li>
&lt;li>동점자는 누가 먼저 점수를 받았는지에 따라 순위를 정할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="시스템-장애-복구">시스템 장애 복구&lt;/h3>
&lt;p>레디스 클러스터에도 대규모 장애는 발생할 수 있다.&lt;/p>
&lt;p>지금까지 살펴본 설계안에서는 사용자가 게임에서 이길 때마다 MySQL 데이터베이스에 타임 스탬프와 함께 저장하므로, 이를 활용한 스크립트를 만들어 간단히 복구할 수 있다.&lt;/p>
&lt;ul>
&lt;li>사용자별로 모든 레코드를 훑으며 레코드당 한 번씩 &lt;code>ZINFRBY&lt;/code>를 호출&lt;/li>
&lt;/ul></description></item><item><title>12. 채팅 시스템 설계</title><link>https://codemario318.github.io/post/system-design-interview/12/</link><pubDate>Fri, 05 Jul 2024 10:02:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/12/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/cover.png" alt="Featured image of post 12. 채팅 시스템 설계" />&lt;p>이번 장에서는 채팅 시스템을 설계해본다.&lt;/p>
&lt;p>채팅 앱은 중점적으로 다뤄야하는 문제에 따라 방향성이 달라질 수 있으므로, 요구사항을 확실히 파악하는것이 매우 중요하기 때문에, 어떤 채팅 앱을 설계하려는지 확실히 해 두는것이 중요하다.&lt;/p>
&lt;ul>
&lt;li>1:1 채팅 중점
&lt;ul>
&lt;li>페이스북 메신저, 위챗, 왓츠앱 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>그룹 채팅 중점
&lt;ul>
&lt;li>슬랙 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>대규모 그룹의 소통과 음성 채팅
&lt;ul>
&lt;li>디스코드 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>질문을 통해 의도를 파악한다.&lt;/p>
&lt;ul>
&lt;li>Q. 1:1 채팅, 그룹 채팅?
&lt;ul>
&lt;li>A. 둘 다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 모바일? 웹?
&lt;ul>
&lt;li>A. 둘 다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 트래픽 규모는?
&lt;ul>
&lt;li>A. DAU 5천만&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 그룹 채팅의 인원 제한?
&lt;ul>
&lt;li>A. 최대 100명&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 중요 기능으로는?
&lt;ul>
&lt;li>A. 1:1 채팅, 그룹 채팅, 사용자 접속 상태 표시, 텍스트 메시지만 허용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 메시지 길이 제한은?
&lt;ul>
&lt;li>A. 100,000자 이하&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 종단 간 암호화(end-to-end encryption) 지원?
&lt;ul>
&lt;li>A. 현재로서는 불필요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 채팅 이력은 얼마나 보관?
&lt;ul>
&lt;li>A. 영원히.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위와 같은 질의응답을 통해 아래와 같은 요구사항을 찾을 수 있다.&lt;/p>
&lt;ul>
&lt;li>응답지연이 낮은 일대일 채팅기능(DAU)&lt;/li>
&lt;li>최대 100명까지 참여할 수 있는 그룹 채팅 기능&lt;/li>
&lt;li>사용자의 접속상태 표시 기능&lt;/li>
&lt;li>다양한 단말 지원, 하나의 계정으로 여러 단말에 동시 접속 지원(웹, 앱 둘다 고려)&lt;/li>
&lt;li>푸시 알림&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>채팅 시스템의 경우 클라이언트는 모바일 앱이거나 웹 애필리케이션이다.&lt;/p>
&lt;p>클라이언트는 서로 직접 통신하지 않는 대신, 각 클라이언트는 위에 나열한 모든 기능을 지우너하는 채팅 서비스와 통신한다.&lt;/p>
&lt;p>따라서 채팅 서비스는 아래 기능을 제공해야 한다.&lt;/p>
&lt;ul>
&lt;li>클라이언트들로부터 메시지 수진&lt;/li>
&lt;li>메시지 수신자(recipient) 결정 및 전달&lt;/li>
&lt;li>수신자가 접속 상태가 아닌 경우 접속할 때까지 해당 메시지 보관&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img.png"
width="831"
height="141"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_hu846a4193e09f6599f67011f5f29692cb_42945_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_hu846a4193e09f6599f67011f5f29692cb_42945_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클라이언트와 채팅 서비스 관계"
class="gallery-image"
data-flex-grow="589"
data-flex-basis="1414px"
>&lt;/p>
&lt;p>채팅을 시작하려는 클라이언트는 네트워크 통신 프로토콜을 사용하여 서비스에 접속하므로, 어떤 통신 프로토콜을 사용할 것인가도 중요한 문제다.&lt;/p>
&lt;p>대부분의 클라이언트/서버 애플리케이션에서 요청을 보내는 것은 클라이언트이며, 채팅 시스템도 마찬가지다.&lt;/p>
&lt;p>위 예시에서는 송신 클라이언트가 수신 클라이언트에게 전달 할 메시지를 보낼 때, 오랜 세월 검증된 &lt;strong>HTTP 프로토콜&lt;/strong>을 사용한다.&lt;/p>
&lt;p>HTTP를 사용한다면, 채팅 서비스에서는 클라이언트가 지속적으로 메시지를 보낸다는 특성을 고려하여, &lt;code>keep-alive&lt;/code> 헤더를 사용해 서버와 클라이언트가 연결을 끊지 않고 유지하는 것이 좋다.&lt;/p>
&lt;p>하지만 메시지 발신에 비해 수신 시나리오는 이것보다 복잡하기 때문에 HTTP가 적절치 않을 수 있다.&lt;/p>
&lt;ul>
&lt;li>서버가 채팅 발신 요청을 받게 되면, 서버가 수신자에게 메시지를 전달해야한다.&lt;/li>
&lt;li>HTTP는 클라이언트가 연결을 만드는 특성으로, 서버에서 클라이언트로 임의 시점에 메시지를 보내는 데 쉽게 쓰일 수 없다.&lt;/li>
&lt;/ul>
&lt;p>이러한 문제를 개선하기위해 서버가 연결을 만드는 것처럼 동작하는 많은 기법이 제안되었다.&lt;/p>
&lt;ul>
&lt;li>폴링, 롱폴링, 웹소켓&lt;/li>
&lt;/ul>
&lt;h3 id="폴링">폴링&lt;/h3>
&lt;p>폴링은 클라이언트가 주기적으로 서버에게 새 메시지가 있는냐고 물어보는 방법이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_1.png"
width="831"
height="879"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_1_huaa79ccbd5858bc013d0c473ceded0490_112044_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_1_huaa79ccbd5858bc013d0c473ceded0490_112044_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="폴링"
class="gallery-image"
data-flex-grow="94"
data-flex-basis="226px"
>&lt;/p>
&lt;p>폴링 비용은 폴링을 자주하면 할수록 올라가므로, 답해줄 메시지가 없는 경우에는 서버 자원이 불필요하게 낭비된다.&lt;/p>
&lt;h3 id="롱-폴링">롱 폴링&lt;/h3>
&lt;p>폴링의 비효율성을 개선하기위해 롱 폴링이 제안되었다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_2.png"
width="831"
height="746"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_2_hu9446a286a0026c1d57706962c9f7b24e_79065_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_2_hu9446a286a0026c1d57706962c9f7b24e_79065_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="롱 폴링"
class="gallery-image"
data-flex-grow="111"
data-flex-basis="267px"
>&lt;/p>
&lt;ul>
&lt;li>클라이언트는 새 메시지가 반환되거나 타임아웃 될 때가지 연결을 유지한다.&lt;/li>
&lt;li>새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내 모든 절차를 다시 시작한다.&lt;/li>
&lt;/ul>
&lt;p>이 방법은 다음과 같은 약점이 있다.&lt;/p>
&lt;ul>
&lt;li>메시지를 보내는 클라이언트가 수신하는 클라이언트가 같은 채팅 서버에 접속하지 않을 수 있다.
&lt;ul>
&lt;li>HTTP 서버들은 보통 무상태이다. 즉 로드 밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우(요청을 무작위로 분산하는 경우), 메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와의 롱 폴링 연결을 가지고 있지 않은 서버일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서버는 클라이언트가 연결을 해제했는지 알 수 있는 좋은 방법이 없다.&lt;/li>
&lt;li>여전히 비효율적이다.
&lt;ul>
&lt;li>메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 때마다 주기적으로 서버에 다시 접속한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="웹소켓">웹소켓&lt;/h3>
&lt;p>웹소켓은 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_3.png"
width="821"
height="498"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_3_huebfcb5cdfaf26f40aef3085b89b61c7b_77060_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_3_huebfcb5cdfaf26f40aef3085b89b61c7b_77060_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="웹소켓"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="395px"
>&lt;/p>
&lt;ul>
&lt;li>웹소켓 연결은 클라이언트가 시작하며, 한번 맺어진 연결은 항구적이며(변하지않고 오래가며) 양방향이다.&lt;/li>
&lt;li>처음에는 HTTP 연결이지만 특정 핸드셰이크 절차를 거져 웹소켓 연결로 업그레이드된다.
&lt;ul>
&lt;li>일반적으로 방화벽이 있는 환경에서도 잘 동작한다.&lt;/li>
&lt;li>HTTP, HTTPS 가 쓰는 포트를 그대로 활용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>연결이 만들어지고 나면, 서버는 클라이언트에게 비동기적으로 메시지를 전송할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>웹소켓은 메시지를 보내려는 클라이언트에게 준수한 HTTP 프로토콜의 특징에 더해 양방향 메시지 전송까지 가능하게 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_4.png"
width="607"
height="355"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_4_huc6205357ded82087fb2f30ab5b292d46_55256_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_4_huc6205357ded82087fb2f30ab5b292d46_55256_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="웹소켓 활용 예시"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="410px"
>&lt;/p>
&lt;ul>
&lt;li>웹소켓을 이용하면 메시지를 보낼 때나 받을 때 동일한 프로토콜을 사용할 수 있으므로, 설계와 구현이 단순하고 직관적이다.&lt;/li>
&lt;li>단, 웹소켓 연결은 항구적으로 유지되어야 하기 때문에 서버 측에서 연결 관리를 효율적으로 해야한다.&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>클라이언트와 서버 사이의 주 통신 프로토콜로 웹소켓을 사용하지만, 다른 부분에서는 굳이 웹소켓을 쓸 필요는 없다.&lt;/p>
&lt;p>대부분의 기능인 회원가입, 로그인, 사용자 프로파일 등은 기존 HTTP상에서 구현하는 것이 더 좋다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_5.png"
width="644"
height="853"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_5_hu3b37951fbb1bf15ccce6fcd26ff957e5_234991_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_5_hu3b37951fbb1bf15ccce6fcd26ff957e5_234991_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="75"
data-flex-basis="181px"
>&lt;/p>
&lt;p>채팅 시스템은 세 부분으로 나눠볼 수 있다.&lt;/p>
&lt;h4 id="무상태-서비스">무상태 서비스&lt;/h4>
&lt;p>이 설계안에서 무상태 서비스는 로그인, 회원가입, 사용자 프로파일 표시 등을 처리하는 &lt;strong>전통적인 요청/응답&lt;/strong> 서비스다.&lt;/p>
&lt;ul>
&lt;li>일반적인 웹과 앱이 제공하는 기능들&lt;/li>
&lt;/ul>
&lt;p>무상태 서비스는 로드밸런서 뒤에 위치한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>서비스 탐색(sevice discovery) 서비스&lt;/strong>
&lt;ul>
&lt;li>클라이언트가 접속할 채팅 서버의 DNS 호스트명을 클라이언트에게 알려주는 역할을 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="상태-유지-서비스">상태 유지 서비스&lt;/h4>
&lt;p>채팅 서비스는 각 클라이언트는 채팅 서버와 독립적인 네트워크를 유지해야한다.&lt;/p>
&lt;ul>
&lt;li>클라이언트는 보통 다른 서버로 연결을 변경하지 않는다.&lt;/li>
&lt;li>서비스 탐색 서비스가 채팅 서버스와 긴밀히 협력하여 특정 서버에 부하가 몰리지 않도록 한다.&lt;/li>
&lt;/ul>
&lt;h4 id="써드파티-서비스-연동">써드파티 서비스 연동&lt;/h4>
&lt;p>채팅 앱에서 가장 중요한 써드파티 서비스는 푸시 알림이다.&lt;/p>
&lt;ul>
&lt;li>새 메시지 수신시 앱이 실행중이지 않더라도 알림을 받아야한다.&lt;/li>
&lt;/ul>
&lt;p>따라서 푸시 알림 서비스와의 통합은 아주 중요하다.&lt;/p>
&lt;h4 id="규모-확장성">규모 확장성&lt;/h4>
&lt;p>이번 장에서 다루는 시스템은 동시 접속자가 1M 이라고 가정하는데, 접속당 10K 서버 메모리가 필요하다면, 10GB 메모리만으로도 처리 가능하다.&lt;/p>
&lt;p>하지만 이정도 규모의 트래픽을 서버 한대로 처리하는 것은 &lt;strong>SPOF&lt;/strong> 등의 이유로 적절치 않다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_6.png"
width="797"
height="872"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_6_hu2f66c0a05c004fc0f4d257e106c12a84_230686_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_6_hu2f66c0a05c004fc0f4d257e106c12a84_230686_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안 최종"
class="gallery-image"
data-flex-grow="91"
data-flex-basis="219px"
>&lt;/p>
&lt;p>유의할 것은 실시간으로 메시지를 주고받기 위해 클라이언트는 채팅 서버와 웹소켓 연결을 끊지 않고 유지한다는 것이다.&lt;/p>
&lt;ul>
&lt;li>채팅 서버
&lt;ul>
&lt;li>클라이언트 사이에 메시지를 중계하는 역할 담당&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>접속 상태 서버(Presence server)
&lt;ul>
&lt;li>사용자의 접속 여부 관리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>API 서버
&lt;ul>
&lt;li>로그인, 회원가입, 프로파일 변경 등 그 외 나머지를 전부 처리(무상태)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 서버
&lt;ul>
&lt;li>푸시 알림을 보냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>키-값 저장소
&lt;ul>
&lt;li>채팅 이력을 보관&lt;/li>
&lt;li>시스템에 접속한 사용자는 이전 채팅 이력을 전부 보게된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="저장소">저장소&lt;/h4>
&lt;p>채팅 시스템의 기술 스택중 가장 중요한 부분 중 하나는 데이터 계층으로, 이 계층을 올바르게 만드는 데는 노력이 필요하다.&lt;/p>
&lt;p>중요한 선택 중 하나는 어떤 데이터베이스를 쓰는가(관계형, NoSQL 등)이며, 고려해야 할 핵심 요인은 &lt;strong>데이터의 유형&lt;/strong>과 &lt;strong>읽기/쓰기 연산의 패턴&lt;/strong> 이다.&lt;/p>
&lt;p>채팅 시스템에서는 보통 두 가지다.&lt;/p>
&lt;p>&lt;strong>사용자 프로파일, 설정, 친구 목록과 같은 일반적인 데이터&lt;/strong>&lt;br>
안정성을 보장하는 관계형 데이터베이스가 적절하다.&lt;/p>
&lt;ul>
&lt;li>다중화(replication)와 샤딩(sharding)으로 이러한 데이터의 가용성과 규모확장성을 보증할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>채팅 시스템에 고유한 데이터(채팅 이력)&lt;/strong>&lt;br>
이러한 유형의 데이터를 어떻게 보관할 지 결정하려면 읽기/쓰기 연산 패턴을 이해해야한다.&lt;/p>
&lt;ul>
&lt;li>채팅 이력 데이터 양은 엄청나다.
&lt;ul>
&lt;li>페이스북 메신저나 왓츠앱은 매일 600억개 메시지를 처리함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>빈번하게 사용되는 것은 주로 최근에 주고받은 메시지이다.
&lt;ul>
&lt;li>대부분 사용자는 오래된 메시지는 확인하지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>검색 기능, 언급(mention)된 메시지, 특정 메시지로 점프 하는 등 무작위적인 데이터 접근을 하는 경우도 있다.&lt;/li>
&lt;li>1:1 채팅 앱의 경우 읽기:쓰기 비율은 대략 1:1&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>키-값 저장소&lt;/strong>가 이러한 패턴을 지원할 수 있는 데이터베이스이다.&lt;/p>
&lt;ul>
&lt;li>수평적 규모 확장이 쉽다.&lt;/li>
&lt;li>데이터 접근 지연시간이 낮다.&lt;/li>
&lt;li>관계형 데이터베이스는 롱 테일에 해당하는(넓고 적게 분포하는) 데이터를 잘 처리하지 못하는 경향이 있다.
&lt;ul>
&lt;li>인덱스가 커지면 무작위 접근을 처리하는 비용이 늘어난다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이미 많은 안정적인 채팅 시스템이 키-값 저장소를 채택하고있다.
&lt;ul>
&lt;li>페이스북: Hbase, 디스코드: 카산드라 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>롱테일 효과란?&lt;br>
&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_7.png"
width="487"
height="360"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_7_hub3d79bb345ad1bef179816c28fd060f6_45686_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_7_hub3d79bb345ad1bef179816c28fd060f6_45686_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="롱테일 효과"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="324px"
>&lt;br>
파레토 법칙에 의한 80:20 집중 현상을 그래프에 나타냈을 때 꼬리처림 긴 부분을 형성하는 80%의 부분&lt;/p>
&lt;/blockquote>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;h4 id="11-채팅을-위한-메시지-테이블">1:1 채팅을 위한 메시지 테이블&lt;/h4>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
Message {
message_id bigint
message_from bigint
message_to bigint
content text
created_at timestamp
}
&lt;/pre>
&lt;p>&lt;code>Message&lt;/code> 테이블의 기본키는 &lt;code>message_id&lt;/code>로, 메시지 순서를 쉽게 정할 수 있도록 하는 역할도 담당한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>created_at&lt;/code>은 메시지가 동시에 만들어 질 수 있으므로 순서를 정할 수 없다.&lt;/li>
&lt;/ul>
&lt;h4 id="그룹-채팅을-위한-메시지-테이블">그룹 채팅을 위한 메시지 테이블&lt;/h4>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
GroupMessage {
channel_id bigint
message_id bigint
message_to bigint
content text
created_at timestamp
}
&lt;/pre>
&lt;p>&lt;code>(channel_id, message_id)&lt;/code> 복합키를 기본 키로 사용한다.&lt;/p>
&lt;ul>
&lt;li>채널은 채팅 그룹과 같은 뜻&lt;/li>
&lt;li>그룹 채팅에 적용될 모든 질의는 특정 채널을 대상으로 하기 때문에 &lt;code>channel_id&lt;/code>는 파티션 키로 사용할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="메시지-id">메시지 ID&lt;/h4>
&lt;p>위에서 언급한 것 처럼 메시지 ID는 메시지들의 순서도 표현할 수 있어야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>messege_id&lt;/code>는 고유해야한다.&lt;/li>
&lt;li>ID는 정렬 가능해하하며, 시간 순서와 일치해야한다.
&lt;ul>
&lt;li>새로운 ID는 이전 ID 보다 큰 값이어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>RDMBS라면 &lt;code>auto_increment&lt;/code>가 대안이 될 수 있지만 NoSQL은 보통 해당 기능을 제공하지 않는다.&lt;/p>
&lt;ul>
&lt;li>스노 플레이크 같은 전역적 순서 번호 생성기를 이용한다.&lt;/li>
&lt;li>지역적 순서 번호 생성기를 이용한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>지역적 순서 번호 생성기(Local sequence number generator)&lt;/strong>
유일성은 같은 그룹 안에서만 보증하면 충분하다는 의미이다.&lt;/p>
&lt;ul>
&lt;li>채팅 서비스의 특징에 따라 메시지의 순서는 같은 채널, 혹은 1:1 채팅 세션 안에서만 유지되면 충분하다.&lt;/li>
&lt;li>전역적 ID 생성기에 비해 구현이 쉽다.&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>채팅 시스템의 &lt;strong>서비스 탐색&lt;/strong>(service discovery), 메시지 전달 흐름, 사용자 접속 상태 표시하는 법 정도가 세부적으로 살펴보기 적절하다.&lt;/p>
&lt;h3 id="서비스-탐색">서비스 탐색&lt;/h3>
&lt;p>서비스 탐색 기능의 주된 역할은 &lt;strong>클라이언트에게 가장 적합한 채팅 서버를 추천&lt;/strong>하는 것으로 아래의 기준을 활용하여 추천하게된다.&lt;/p>
&lt;ul>
&lt;li>클라이언트의 위치(Geographical location)&lt;/li>
&lt;li>서버의 용량 등&lt;/li>
&lt;/ul>
&lt;p>서비스 탐색 기능을 구현하는 데 널리 쓰이는 오픈 소스 솔루션으로 &lt;strong>아파치 주키퍼&lt;/strong>같은 것이 있다.&lt;/p>
&lt;ul>
&lt;li>사용 가능한 모든 채팅 서버를 등록시켜 두고, 클라이언트가 접속을 시도하면 사전에 정한 기준에 따라 최적의 채팅 서버를 골라준다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_8.png"
width="718"
height="698"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_8_hu68029a52e7e091c75ea09add17c7232a_109024_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_8_hu68029a52e7e091c75ea09add17c7232a_109024_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="주키퍼로 구현한 서비스 탐색 흐름"
class="gallery-image"
data-flex-grow="102"
data-flex-basis="246px"
>&lt;/p>
&lt;ol>
&lt;li>사용자 A가 시스템에 로그인 시도&lt;/li>
&lt;li>로드밸런서가 로그인 요청을 API 서버들 가운데 하나로 보냄&lt;/li>
&lt;li>API 서버가 사용자 인증을 처리하고 나면 서비스 탐색 기능이 동작하여 최적의 채팅 서버를 찾음&lt;/li>
&lt;li>찾은 서버와 웹소켓 연결&lt;/li>
&lt;/ol>
&lt;h3 id="메시지-흐름">메시지 흐름&lt;/h3>
&lt;p>채팅 시스템에 있어서 종단 간 메시지 흐름을 이해하는 것은 흥미로운 주제이다.&lt;/p>
&lt;p>1:1 채팅 메시지의 처리 흐름과 여러 단말 간 메시지 동기화 과정을 살펴본 후, 그룹 채팅 메시지의 처리 흐름을 살펴본다.&lt;/p>
&lt;h4 id="11-채팅-메시지-처리-흐름">1:1 채팅 메시지 처리 흐름&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_9.png"
width="675"
height="721"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_9_hu69fa1b06e4a527bf42d264a7bc16f467_126368_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_9_hu69fa1b06e4a527bf42d264a7bc16f467_126368_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="1:1 채팅 메시지 처리 흐름"
class="gallery-image"
data-flex-grow="93"
data-flex-basis="224px"
>&lt;/p>
&lt;ol>
&lt;li>사용자 A가 채팅 서버 1로 메시지 전송&lt;/li>
&lt;li>채팅 서버 1은 ID 생성기를 사용해 해당 메시지의 ID 결정&lt;/li>
&lt;li>채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송&lt;/li>
&lt;li>메시지가 키-값 저장소에 보관됨&lt;/li>
&lt;li>
&lt;ol>
&lt;li>사용자 B가 접속 중인 경우 메시지는 접속 중인 채팅 서버로 전송&lt;/li>
&lt;li>사용자가 B가 접속 중이 아닌 경우 푸시 알림 메시지를 푸시 알림 서버로 보냄&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>채팅 서버는 웹소켓 연결을 통해 메시지를 사용자 B에게 전송.&lt;/li>
&lt;/ol>
&lt;h4 id="여러-단말-사이의-메시지-동기화">여러 단말 사이의 메시지 동기화&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_10.png"
width="827"
height="601"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_10_hu237dc5988b99c0258bbc96b3a092c068_95136_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_10_hu237dc5988b99c0258bbc96b3a092c068_95136_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="메시지 동기화"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="330px"
>&lt;/p>
&lt;p>각 단말은 관측된 가장 최신 메시지의 ID를 추적하기 위한 &lt;code>cur_max_message_id&lt;/code> 라는 변수를 유지한다.&lt;/p>
&lt;ul>
&lt;li>수신자 ID가 현재 로그인한 사용자 ID와 같다.&lt;/li>
&lt;li>키-값 저장소에 보관된 메시지로서, 그 ID가 &lt;code>cur_max_message_id&lt;/code>보다 크다.&lt;/li>
&lt;/ul>
&lt;p>위 조건을 만족하는 메시지는 새 메시지로 간주된다.&lt;/p>
&lt;p>&lt;code>cur_max_message_id&lt;/code>는 단말마다 별도로 유지 관리하면 되는 값이라 키-값 저장소에서 새 메시지를 가져오는 동기화 작업도 쉽게 구현할 수 있다.&lt;/p>
&lt;h4 id="소규모-그룹-채팅에서의-메시지-흐름">소규모 그룹 채팅에서의 메시지 흐름&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_11.png"
width="747"
height="649"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_11_hu3912c41ccdd5c95c734f65d055df6d26_117861_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_11_hu3912c41ccdd5c95c734f65d055df6d26_117861_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="소규모 그룹 채팅 메시지 흐름"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="276px"
>&lt;/p>
&lt;p>1:1 채팅에 비해 조금 더 복잡하다.&lt;/p>
&lt;p>사용자 A가 그룹 채팅방에서 메시지를 보내면, 사용자 B, C의 &lt;strong>메시지 동기화 큐&lt;/strong>에 복사된다.&lt;/p>
&lt;p>이러한 설계는 소규모 그룹 채팅에 적합하다.&lt;/p>
&lt;ul>
&lt;li>새로운 메시지가 왔는지 확인하려면 자기 큐만 보면 되므로 메시지 동기화 플로가 단순하다.&lt;/li>
&lt;li>그룹이 크지 않으면 메시지를 수신자별로 복사해서 큐에 넣는 작업 비용이 문제되지 않는다.&lt;/li>
&lt;/ul>
&lt;p>많은 사용자를 지원해야 하는 경우라면 똑같은 메시지를 모든 사용자의 큐에 복사하는 게 바람직하지 않다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_12.png"
width="716"
height="620"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_12_hub1a8d58b86737e6dabf10d70f993bb1d_101204_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_12_hub1a8d58b86737e6dabf10d70f993bb1d_101204_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="수신자 관점 메시지 흐름"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="277px"
>&lt;/p>
&lt;p>위와 같은 흐름을 &lt;strong>메시지 수신자&lt;/strong> 관점에서 살펴보면, 한 수신자는 여러 사용자로부터 오는 메시지를 수신할 수 있어야 한다.&lt;/p>
&lt;h3 id="접속-상태-표시">접속 상태 표시&lt;/h3>
&lt;p>사용자 접속 상태를 표시하는 것은 상당수 채팅 애플리케이션의 핵심 기능이다.&lt;/p>
&lt;p>개략적 설계안의 &lt;strong>접속 상태 서버&lt;/strong>(presense server)를 통해 사용자의 상태를 관리하는데, 접속상태 서버는 클라이언트와 웹소켓으로 통신하는 실시간 서비스의 일부라는 점에 유의해야한다.&lt;/p>
&lt;p>&lt;strong>사용자 로그인&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_13.png"
width="766"
height="206"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_13_hub37db33c8b8c4205291185c196c0ce06_57084_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_13_hub37db33c8b8c4205291185c196c0ce06_57084_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="로그인"
class="gallery-image"
data-flex-grow="371"
data-flex-basis="892px"
>&lt;/p>
&lt;p>클라이언트와 실시간 서비스 사이에 웹소켓 연결이 맺어지고 나면 접속상태 서버는 A의 상태와 &lt;code>last_active_at&lt;/code> 타임스탬프 값을 키-값 저장소에 보관한다.&lt;/p>
&lt;p>이 절차가 끝나면 해당 사용자는 접속 중인 것으로 표시될 것이다.&lt;/p>
&lt;p>&lt;strong>로그아웃&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_14.png"
width="830"
height="167"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_14_huc82ec414ab58d2aa81718a978ef2720f_65884_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_14_huc82ec414ab58d2aa81718a978ef2720f_65884_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="로그아웃"
class="gallery-image"
data-flex-grow="497"
data-flex-basis="1192px"
>&lt;/p>
&lt;p>키-값 저장소에 보관된 사용자 상태가 &lt;code>online&lt;/code>에서 &lt;code>offline&lt;/code>으로 바뀐다.&lt;/p>
&lt;p>&lt;strong>접속 장애&lt;/strong>&lt;/p>
&lt;p>인터넷 연결이 끊어지는 상황에 대응할 수 있는 설계를 준비해야한다.&lt;/p>
&lt;p>사용자의 인터넷 연결이 끊어지면 클라이언트와 서버 사이에 맺어진 웹소켓 같은 지속성 연결도 끊어진다.&lt;/p>
&lt;p>이러한 경우 &lt;strong>사용자를 오프라인 상태로 표시하고 연결이 복구되면 온라인 상태로 변경&lt;/strong>하는 방법을 고려할 수 있지만, 짧은 시간 동안 인터넷 연결이 끊어졌다 복귀되는 현상이 흔하기 때문에 적절하지 않다.&lt;/p>
&lt;ul>
&lt;li>이런 현상마다 사용자의 접속 상태를 변경하는 것은 지나치며, 사용자 경험 측면에서도 바람직하지 않다.&lt;/li>
&lt;/ul>
&lt;p>이에 따라 &lt;strong>박동(heartbeat) 검사&lt;/strong>를 통해 이 문제를 해결한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_15.png"
width="753"
height="620"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_15_hu870405f6db98088b77813163c0a21c89_78387_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_15_hu870405f6db98088b77813163c0a21c89_78387_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="박동 검사"
class="gallery-image"
data-flex-grow="121"
data-flex-basis="291px"
>&lt;/p>
&lt;ol>
&lt;li>온라인 상태의 클라이언트로 하여금 주기적으로 박동 이벤트를 접속상태 서버로 보낸다.&lt;/li>
&lt;li>마지막 이벤트를 받은 지 x초 이내에 또 다른 박동 이벤트 메시지를 받으면 해당 사용자의 접속 상태를 계속 온라인으로 유지한다.&lt;/li>
&lt;/ol>
&lt;h3 id="상태-정보의-전송">상태 정보의 전송&lt;/h3>
&lt;p>상태정보 서버는 각각의 친구관게마다 채널을 하나씩 두는 발행-구독 모델을 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_16.png"
width="844"
height="399"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_16_huda3d97a35351d5c19e5533f1c287c481_139268_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_16_huda3d97a35351d5c19e5533f1c287c481_139268_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="상태 정보 전송"
class="gallery-image"
data-flex-grow="211"
data-flex-basis="507px"
>&lt;/p>
&lt;p>이러한 구조를 통해 친구 관계에 있는 사용자가 상태정보 변화를 쉽게 통지 받을 수 있게 된다(웹소켓 사용).&lt;/p>
&lt;p>이러한 방안은 그룹의 크기가 커지면 비용이나 시간이 많이 들게되므로 좋지 않다.&lt;/p>
&lt;ul>
&lt;li>그룹 하나의 100,000명이 있다면, 상태변화 1건당 100,000개의 이벤트 메시지가 발생한다.&lt;/li>
&lt;/ul>
&lt;p>이런 성능 문제를 해소하는 방법은&lt;/p>
&lt;ul>
&lt;li>사용자가 그룹 채팅에 입장하는 순간에만 상태 정보를 읽어가게 만든다.&lt;/li>
&lt;li>친구 리스트에 있는 사용자의 접속상태를 갱신하고 싶으면 수동으로 하도록 유도한다.&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>1:1 채팅과 그룹 채팅을 전부 지원하는 채팅 시스템의 아키텍처를 살펴보았다.&lt;/p>
&lt;ul>
&lt;li>클라이언트와 서버 사이의 통신을 가능하도록 하기 위해 웹소켓을 사용했다.&lt;/li>
&lt;li>주요 컴포넌트
&lt;ul>
&lt;li>실시간 메시징을 지원하는 채팅 서버&lt;/li>
&lt;li>접속 상태 서버&lt;/li>
&lt;li>푸시 알림 서버&lt;/li>
&lt;li>채팅 이력을 보관할 키-값 저장소&lt;/li>
&lt;li>이를 제외한 나머지 기을을 구현하는 데 쓰을 API 서버 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>시간이 남는다면 다음과 같은 내용을 논의해도 좋다.&lt;/p>
&lt;ul>
&lt;li>사진이나 비디오 등의 미디어를 지원하도록 하는 방법
&lt;ul>
&lt;li>압축 방식, 클라우드 저장소, 섬네일 생성 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>종단 간 암호화&lt;/li>
&lt;li>캐시
&lt;ul>
&lt;li>이미 읽은 메시지를 캐시해 두면 서버와 주고받는 데이터 양을 줄일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>로딩 속도 개선
&lt;ul>
&lt;li>슬랙은 사용자의 데이터, 채널 등을 지역적으로 분산하는 네트워크를 구축하여 앱 로딩 속도를 개선하였다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오류 처리
&lt;ul>
&lt;li>채팅 서버 오류
&lt;ul>
&lt;li>서버 하나가 죽으면 서비스 탐색 기능이 동작하여 클라이언트에게 새로운 서버를 배정하고 다시 접속할 수 있도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 재전송
&lt;ul>
&lt;li>재시도나 큐는 메시지의 안정적 전송을 보장하기 위해 흔히 사용되는 기법이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item></channel></rss>