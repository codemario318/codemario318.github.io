<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computer Science on Mario Blog</title><link>https://codemario318.github.io/tags/computer-science/</link><description>Recent content in Computer Science on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Sun, 27 Jul 2025 16:38:00 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/computer-science/index.xml" rel="self" type="application/rss+xml"/><item><title>Raft 합의 알고리즘</title><link>https://codemario318.github.io/post/common/raft/</link><pubDate>Sun, 27 Jul 2025 16:38:00 +0900</pubDate><guid>https://codemario318.github.io/post/common/raft/</guid><description>&lt;img src="https://codemario318.github.io/post/common/raft/cover.png" alt="Featured image of post Raft 합의 알고리즘" />&lt;p>오늘은 저번에 작성한 &lt;a class="link" href="https://codemario318.github.io/common/quorum-based-consensus" >정족수 합의&lt;/a>에 이어서 &lt;strong>Raft 합의 알고리즘&lt;/strong>을 살펴보려고 합니다.&lt;/p>
&lt;p>저번 글에도 설명했지만, 분산 시스템에서 가장 어려운 문제 중 하나는 &lt;strong>모든 노드가 하나의 동일한 결정을 내리는 것, 즉 &lt;em>합의(Consensus)&lt;/em>&lt;/strong> 입니다.&lt;/p>
&lt;p>이런 상황에서도 시스템이 정상적으로 동작하려면 신뢰할 수 있는 합의 메커니즘이 필요하며, 그 중 하나가 Raft입니다.&lt;/p>
&lt;h2 id="raft란">Raft란?&lt;/h2>
&lt;blockquote>
&lt;p>Raft는 Paxos와 동일한 목표를 가지면서도 &lt;strong>이해하기 쉽도록 설계된 합의 알고리즘&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>2014년 Diego Ongaro와 John Ousterhout가 발표한 논문 “In Search of an Understandable Consensus Algorithm” 에서는 Paxos의 복잡성을 극복할 수 있는 대안으로 Raft를 제시했습니다.&lt;/p>
&lt;p>Raft는 다음의 세 가지 주요 목표를 가지고 있습니다.&lt;/p>
&lt;ul>
&lt;li>이해하기 쉬울 것&lt;/li>
&lt;li>정상적인 상태 유지뿐 아니라 복구 절차도 직관적일 것&lt;/li>
&lt;li>실제 구현에 적합할 것&lt;/li>
&lt;/ul>
&lt;p>&lt;del>Paxos는 다음 글에 작성해보겠습니다.&lt;/del>&lt;/p>
&lt;h2 id="raft의-구조-리더-중심">Raft의 구조: 리더 중심&lt;/h2>
&lt;p>Raft는 노드 간의 역할을 명학히 나눕니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Leader(1개)&lt;/strong>: 모든 클라이언트 요청을 받고, 로그를 다른 노드에 전파&lt;/li>
&lt;li>&lt;strong>Follower(N개)&lt;/strong>: 리더의 명령을 따름&lt;/li>
&lt;li>&lt;strong>Candidate&lt;/strong>: 리더 선출을 위해 임시로 전환되는 상태&lt;/li>
&lt;/ul>
&lt;p>모든 노드는 기본적으로 팔로워로 싲가하며, 주기적으로 리더로부터 heartbeat를 받지 못하면 후보 상태가 되어 선거를 시작합니다.&lt;/p>
&lt;h3 id="리더-선출">리더 선출&lt;/h3>
&lt;p>리더는 항상 하나만 존재해야합니다. 이를 위해 임기(term) 개념이 도입하고 있습니다.&lt;/p>
&lt;ul>
&lt;li>일정 시간 동안 리더의 heartbeat를 받지 못하면, follower는 선거를 시작&lt;/li>
&lt;li>본인을 리더로 추천하고 다른 노드의 투표를 요청&lt;/li>
&lt;li>&lt;strong>과반수의 투표&lt;/strong>를 얻은 후보는 리더로 선출&lt;/li>
&lt;/ul>
&lt;p>이 과정을 토해 네트워크 지연이나 장애 상황에서도 안정적으로 새로운 리더를 선출할 수 있게 해줍니다.&lt;/p>
&lt;h3 id="로그-복제-log-replication">로그 복제 Log Replication&lt;/h3>
&lt;p>리더가 되면 클라이언트 요청을 받아 로그 항목으로 저장하고, 팔로워들에게 &lt;strong>AppendEntries RPC&lt;/strong>를 보냅니다.&lt;/p>
&lt;p>복제는 다음과 같은 방식으로 수행됩니다.&lt;/p>
&lt;ol>
&lt;li>리더는 새로운 로그 항목을 자신의 로그에 추가&lt;/li>
&lt;li>팔로워들에게 &lt;strong>AppendEntries&lt;/strong> 메시지 전송&lt;/li>
&lt;li>팔로워가 수신 성공 시 응답&lt;/li>
&lt;li>&lt;strong>과반수 이상&lt;/strong>의 팔로워가 응답하면 커밋(Commit) 처리&lt;/li>
&lt;li>리더가 커밋을 팔로워들에게 전파&lt;/li>
&lt;/ol>
&lt;p>로그 복제가 실패할 경우에는 이전 로그 상태로 되돌아가며 재동기화하여 결과적 일관성(eventually consistent)를 보장합니다.&lt;/p>
&lt;h3 id="안정성-보장">안정성 보장&lt;/h3>
&lt;p>Raft는 다음과 같은 메커니즘으로 안전성을 보장합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Log Matching Property&lt;/strong>
&lt;ul>
&lt;li>동일한 인덱스와 term의 로그 항목은 동일해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Leader Completeness Property&lt;/strong>
&lt;ul>
&lt;li>커밋된 로그는 다음 term의 리더 로그에 반드시 포함됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>팔로워는 오직 리더의 로그에 맞춰 자신을 수정함&lt;/li>
&lt;/ul>
&lt;p>이러한 동작으로 시스템은 리더가 바뀌어도 로그가 일관되게 유지될 수 있습니다.&lt;/p>
&lt;h3 id="시나리오-예시-클라이언트-요청-처리">시나리오 예시: 클라이언트 요청 처리&lt;/h3>
&lt;pre class="mermaid" style="text-align: center;">sequenceDiagram
participant Client
participant Leader
participant Follower1
participant Follower2
Client->>Leader: Append(command)
Leader->>Follower1: AppendEntries
Leader->>Follower2: AppendEntries
Follower1-->>Leader: Success
Follower2-->>Leader: Success
Leader->>All: Commit
Leader-->>Client: Success
&lt;/pre>
&lt;h2 id="raft-사용-시-주의할-점">Raft 사용 시 주의할 점&lt;/h2>
&lt;p>Raft는 이해하기 쉬운 구조 덕분에 많이 사용되지만, &lt;strong>실제 서비스에 적용할 때는 주의해야 할 점&lt;/strong>이 분명 존재합니다. 특히 고가용성과 성능, 데이터 일관성 측면에서 다양한 고려가 필요합니다.&lt;/p>
&lt;h3 id="과반수-장애-시-시스템-정지">과반수 장애 시 시스템 정지&lt;/h3>
&lt;p>Raft는 &lt;strong>과반수 노드의 응답&lt;/strong>이 있어야 리더를 선출하거나 로그를 커밋할 수 있습니다. 따라서 과반수 이상이 장애나 네트워크 격리로 인해 응답하지 못하면, &lt;strong>쓰기 작업이 모두 중단&lt;/strong>됩니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">graph TD
A[5개 노드 구성] --> B{3개 이상 응답 가능?}
B -- Yes --> C[정상적으로 리더 선출 및 커밋 가능]
B -- No --> D[쓰기 불가, 시스템 정지]
&lt;/pre>
&lt;blockquote>
&lt;p>최소 3개, 가능하면 5개 등 &lt;strong>홀수 구성&lt;/strong>을 유지하고, 과반수가 살아있도록 클러스터를 배치해야 합니다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="네트워크-분할partition-상황-대응">네트워크 분할(Partition) 상황 대응&lt;/h3>
&lt;p>리더가 일부 팔로워들과만 연결된 상태에서 나머지 노드와 &lt;strong>분리(network partition)&lt;/strong> 될 경우,
기존 리더는 자신이 리더인 줄 알고 요청을 받을 수 있지만, 로그 커밋은 실패합니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">sequenceDiagram
participant Leader (격리됨)
participant Client
participant Follower1
participant Follower2 (다수)
Client->>Leader (격리됨): 요청
Leader (격리됨)->>Follower1: AppendEntries
Note over Follower1: quorum 부족
Leader (격리됨)-->>Client: 실패 또는 타임아웃
&lt;/pre>
&lt;blockquote>
&lt;p>클라이언트 타임아웃을 짧게 잡고, 요청을 다른 노드로 재시도하게 하는 전략이 필요합니다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="로그-무한-증가와-스냅샷">로그 무한 증가와 스냅샷&lt;/h3>
&lt;p>Raft는 로그를 계속 누적하며 동작합니다. 아무 처리 없이 장시간 운영하면 &lt;strong>디스크 용량이 부족&lt;/strong>해질 수 있습니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart TD
A[로그 누적]
A --> B[용량 증가]
B --> C[디스크 부족]
C --> D[성능 저하 또는 장애]
A --> E[주기적 스냅샷 생성]
E --> F[이전 로그 압축/삭제]
F --> G[안정적인 운영]
&lt;/pre>
&lt;blockquote>
&lt;p>주기적으로 스냅샷을 생성하고, 오래된 로그를 안전하게 삭제하는 정책이 필요할 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="리더-선거-충돌">리더 선거 충돌&lt;/h3>
&lt;p>여러 노드가 &lt;strong>동시에 candidate가 되면&lt;/strong>, 과반수 득표에 실패하고 리더가 선출되지 않을 수 있습니다 (split vote).&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>election timeout&lt;/code>을 노드마다 &lt;strong>랜덤하게 설정&lt;/strong>하여 충돌 가능성을 줄일 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="느린-팔로워로-인한-성능-저하">느린 팔로워로 인한 성능 저하&lt;/h3>
&lt;p>느린 follower 노드가 로그 복제 타이밍을 따라가지 못하면, 리더의 커밋 속도도 느려질 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>비동기 전파로 느린 노드를 따로 관리하거나, 너무 뒤처진 follower는 로그 스냅샷으로 초기화가 도움이 될 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="클라이언트-요청-중복-처리">클라이언트 요청 중복 처리&lt;/h3>
&lt;p>리더 전환 중, 동일한 클라이언트 요청이 중복될 수 있습니다. 이 때 &lt;strong>같은 명령이 여러 번 실행&lt;/strong>될 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>클라이언트 요청마다 고유 ID를 부여하고(멱등성), &lt;strong>중복 요청은 캐싱&lt;/strong> 또는 &lt;strong>deduplication 로직&lt;/strong>으로 방지해야 합니다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="읽기-일관성-주의">읽기 일관성 주의&lt;/h3>
&lt;p>Raft 팔로워는 오래된 데이터를 가지고 있을 수 있기 때문에, &lt;strong>정확한 읽기(read-your-write)&lt;/strong> 를 보장하려면 리더에게 요청해야 합니다.&lt;/p>
&lt;blockquote>
&lt;p>Raft에서는 &lt;code>ReadIndex&lt;/code>, &lt;code>LeaseRead&lt;/code> 같은 기법을 사용해 &lt;strong>선거 없는 일관된 읽기&lt;/strong>를 구현할 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="raft-vs-정족수-합의-어떤-합의-방식이-더-적합할까">Raft vs 정족수 합의: 어떤 합의 방식이 더 적합할까?&lt;/h2>
&lt;p>분산 시스템에서 합의는 필수적인 요소입니다. 이전에 학습했던 정족수 합의와는 어떤 차이점이 있을까요?&lt;/p>
&lt;ul>
&lt;li>&lt;strong>정족수 기반 합의 (Quorum-based Consensus)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Raft 합의 알고리즘 (Log Replication with Leader Election)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>두 방식은 목적과 구현 방식이 다릅니다. 아래에서 차이점을 비교해보겠습니다.&lt;/p>
&lt;h3 id="기본-개념의-차이">기본 개념의 차이&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>정족수 합의&lt;/th>
&lt;th>Raft&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>합의 방식&lt;/td>
&lt;td>클라이언트가 직접 다수 노드로 읽기/쓰기 요청 후, 정족수 응답을 수집하여 결정&lt;/td>
&lt;td>리더가 모든 요청을 처리하고, 로그 복제를 통해 과반수에 커밋&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구조&lt;/td>
&lt;td>리더 없음 (모든 노드가 대등)&lt;/td>
&lt;td>리더 중심 구조&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>일관성 보장&lt;/td>
&lt;td>&lt;code>W + R &amp;gt; N&lt;/code>일 때 eventual consistency 보장&lt;/td>
&lt;td>리더 커밋 이후 응답 → strong consistency 보장&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>장애 허용성&lt;/td>
&lt;td>R 또는 W만 만족하면 일관성 일부 손해를 감수하고 처리 가능&lt;/td>
&lt;td>과반수 미만 장애 시 리더 선출 불가 → 쓰기 중단&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>성능 유연성&lt;/td>
&lt;td>클라이언트가 &lt;code>R&lt;/code>, &lt;code>W&lt;/code> 조정 가능&lt;/td>
&lt;td>구조적 한계로 조정 불가, but 일관성 명확&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="처리-흐름-비교">처리 흐름 비교&lt;/h3>
&lt;p>&lt;strong>정족수 합의 (예: DynamoDB)&lt;/strong>&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">sequenceDiagram
participant Client
participant A
participant B
participant C
Client->>A: Write(X)
Client->>B: Write(X)
Client->>C: Write(X)
A-->>Client: OK
B-->>Client: OK
Note right of Client: W = 2 → Write Success
Client->>A: Read()
Client->>B: Read()
A-->>Client: X
B-->>Client: X
Note right of Client: R = 2 → Read Success
&lt;/pre>
&lt;hr>
&lt;p>&lt;strong>Raft 합의&lt;/strong>&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">sequenceDiagram
participant Client
participant Leader
participant Follower1
participant Follower2
Client->>Leader: Write(X)
Leader->>Follower1: AppendEntries(X)
Leader->>Follower2: AppendEntries(X)
Follower1-->>Leader: OK
Follower2-->>Leader: OK
Leader->>All: Commit(X)
Leader-->>Client: Success
&lt;/pre>
&lt;h3 id="선택-기준-요약">선택 기준 요약&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>상황&lt;/th>
&lt;th>적합한 방식&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>일관성이 가장 중요 (예: 금융, 설정 저장소)&lt;/td>
&lt;td>&lt;strong>Raft&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>빠른 응답과 가용성 중시 (예: 추천 캐시, 로그 수집기)&lt;/td>
&lt;td>&lt;strong>정족수 합의&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>클라이언트가 유연한 조정 가능해야 하는 경우&lt;/td>
&lt;td>&lt;strong>정족수 합의&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>복잡한 충돌 해결 없이 안정된 흐름이 필요한 경우&lt;/td>
&lt;td>&lt;strong>Raft&lt;/strong>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="마무리">마무리&lt;/h3>
&lt;p>기존 Paxos의 복잡함을 단순함으로 대체한 합의 알고리즘이 바로 Raft는 분산 시스템 입니다.&lt;/p>
&lt;p>정족수 합의와 Raft는 서로 다른 철학과 목적을 가진 합의 방식입니다.&lt;/p>
&lt;p>어떤 방법이 더 좋다고 단정하기보다는, 서비스의 특성과 우선순위에 따라 적합한 방식을 선택하는 것이 중요합니다. 일관성이 핵심이라면 Raft, 가용성과 유연성이 필요하다면 정족수 합의가 더 적합할 수 있습니다.&lt;/p></description></item><item><title>정족수 합의</title><link>https://codemario318.github.io/post/common/quorum-based-consensus/</link><pubDate>Sun, 08 Jun 2025 15:42:00 +0900</pubDate><guid>https://codemario318.github.io/post/common/quorum-based-consensus/</guid><description>&lt;img src="https://codemario318.github.io/post/common/quorum-based-consensus/cover.png" alt="Featured image of post 정족수 합의" />&lt;h2 id="분산-시스템에서-합의의-필요성">분산 시스템에서 합의의 필요성&lt;/h2>
&lt;p>분산 시스템에서는 하나의 중앙 서버가 모든 결정을 내리지 않습니다. 대신 여러 노드가 함께 데이터를 저장하고 처리합니다.&lt;/p>
&lt;p>이때 문제가 되는 것은 &amp;ldquo;어느 노드의 응답을 믿을 것인가?&amp;ldquo;입니다.&lt;/p>
&lt;p>일부 노드가 장애를 일으키거나 서로 다른 데이터를 갖고 있을 때, 시스템은 어떤 기준으로 정답을 결정해야 할까요?&lt;/p>
&lt;p>이러한 상황에서 필요한 것이 바로 &amp;ldquo;&lt;strong>합의 알고리즘&lt;/strong>&amp;ldquo;이며, 그중 하나가 정족수 합의(quorum-based consensus)입니다.&lt;/p>
&lt;h2 id="정족수란">정족수란?&lt;/h2>
&lt;p>정족수(quorum)란, 시스템이 올바르게 동작하기 위해 필요한 최소한의 응답 수를 의미합니다. 예를 들어, 세 명이 의사결정을 내리는 회의에서 두 명 이상이 동의해야 결정을 내릴 수 있다면, 그 두 명이 바로 정족수입니다.&lt;/p>
&lt;p>분산 시스템에서도 비슷합니다. 노드가 3개 있을 때 2개 이상의 응답이 있어야 데이터가 유효하다고 판단한다면, 그 2개가 정족수가 되는 것입니다.&lt;/p>
&lt;blockquote>
&lt;p>예시: 노드 A, B, C가 있는 시스템에서 노드 C가 장애를 일으켜도, A와 B가 같은 응답을 보냈다면 이를 정답으로 간주할 수 있습니다. 이처럼 정족수를 만족하는 응답이 있으면 시스템은 계속 동작할 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="정족수-합의의-특징">정족수 합의의 특징&lt;/h2>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>구조가 단순하여 구현이 쉬움&lt;/li>
&lt;li>일부 노드 장애를 허용하므로 높은 가용성 확보&lt;/li>
&lt;li>읽기/쓰기 정족수를 조절해 성능을 유연하게 조정 가능&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>네트워크 분할 발생 시 일관성 유지 어려움&lt;/li>
&lt;li>중복 쓰기나 충돌 상황에서는 복잡한 처리 필요&lt;/li>
&lt;/ul>
&lt;h2 id="어떻게-구현되는가">어떻게 구현되는가?&lt;/h2>
&lt;p>정족수 합의에서 중요한 수식은 다음과 같습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>W + R &amp;gt; N&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>N: 전체 노드 수&lt;/li>
&lt;li>W: 쓰기 정족수 (쓰기 시 필요한 응답 수)&lt;/li>
&lt;li>R: 읽기 정족수 (읽기 시 필요한 응답 수)&lt;/li>
&lt;/ul>
&lt;p>이 조건이 만족되면 읽기와 쓰기 연산이 최소 한 노드에서 겹치므로 일관성을 확보할 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>예시: N = 3일 때, W = 2, R = 2 라면 항상 최소 한 노드에서 읽기와 쓰기가 교차하므로 최신 데이터를 읽을 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="어떤-시스템에서-사용되나">어떤 시스템에서 사용되나?&lt;/h2>
&lt;p>&lt;strong>DynamoDB&lt;/strong>, &lt;strong>Cassandra&lt;/strong> 같은 NoSQL 시스템은 정족수 기반의 유연한 일관성 모델을 제공합니다. 예를 들어 Cassandra에서는 클라이언트가 &lt;code>QUORUM&lt;/code>, &lt;code>ONE&lt;/code>, &lt;code>ALL&lt;/code> 같은 일관성 수준을 선택할 수 있습니다.&lt;/p>
&lt;p>이러한 시스템은 &lt;strong>쓰기와 읽기 성능&lt;/strong>, &lt;strong>지연 시간&lt;/strong>, &lt;strong>가용성&lt;/strong>을 조절할 수 있어 대규모 서비스에서 유용하게 사용됩니다.&lt;/p>
&lt;h2 id="dynamodb에서의-정족수-합의-과정">DynamoDB에서의 정족수 합의 과정&lt;/h2>
&lt;p>Amazon DynamoDB는 완벽한 일관성을 보장하기보다는 가용성과 확장성을 우선으로 하는 설계 철학을 따릅니다. 이 과정에서 정족수 합의(quorum-based consensus)는 핵심적인 역할을 합니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">sequenceDiagram
participant Client as 클라이언트
participant A as 노드 A
participant B as 노드 B
participant C as 노드 C (지연)
Client->>A: 쓰기 요청 (데이터 X)
Client->>B: 쓰기 요청 (데이터 X)
Client->>C: 쓰기 요청 (데이터 X)
A-->>Client: 쓰기 성공
B-->>Client: 쓰기 성공
Note right of Client: W = 2 → 쓰기 완료
Client->>A: 읽기 요청
Client->>B: 읽기 요청
A-->>Client: 데이터 X
B-->>Client: 데이터 X
Note right of Client: R = 2 → 읽기 완료, 최신 값 확정
&lt;/pre>
&lt;h3 id="배경-데이터-복제">배경: 데이터 복제&lt;/h3>
&lt;p>Dynamo는 데이터를 여러 노드(또는 파티션)에 복제하여 저장합니다. 일반적으로 N개의 복제본을 유지하며, 이들 중 일부는 읽기/쓰기 요청을 처리하는 데 참여합니다.&lt;/p>
&lt;h3 id="쓰기-요청-처리-w">쓰기 요청 처리 (W)&lt;/h3>
&lt;ul>
&lt;li>클라이언트는 데이터를 쓰기 위해 요청을 보냅니다.&lt;/li>
&lt;li>쓰기 정족수 W는 데이터를 성공적으로 저장해야 하는 노드 수입니다.&lt;/li>
&lt;li>Dynamo는 W개의 노드에 데이터가 저장되면 클라이언트에게 성공을 응답합니다.&lt;/li>
&lt;li>이때 W &amp;lt; N이면, 일부 노드에는 최신 데이터가 없을 수 있습니다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>예: N = 3, W = 2인 경우 → 3개의 복제본 중 2개에만 쓰기가 성공하면 OK로 간주&lt;/p>
&lt;/blockquote>
&lt;h3 id="읽기-요청-처리-r">읽기 요청 처리 (R)&lt;/h3>
&lt;ul>
&lt;li>클라이언트가 데이터를 읽기 위해 요청을 보내면, 시스템은 최대 R개의 노드에서 데이터를 조회합니다.&lt;/li>
&lt;li>응답값들 중 최신 값을 선택하거나 conflict resolution을 수행합니다.&lt;/li>
&lt;li>읽기 정족수 R이 W와 합쳐서 N보다 크다면, 최소 1개 노드는 최신 값을 반드시 갖고 있으므로 일관성을 확보할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>W + R &amp;gt; N: 정족수 기반 일관성 보장의 조건&lt;/p>
&lt;/blockquote>
&lt;h3 id="conflict-해결">Conflict 해결&lt;/h3>
&lt;p>Dynamo는 강한 정합성 대신 &amp;ldquo;eventual consistency&amp;quot;를 선택하기 때문에, 충돌이 발생할 수 있습니다. 이 경우 다음과 같은 방식으로 처리됩니다.&lt;/p>
&lt;ul>
&lt;li>각 버전의 데이터를 함께 반환&lt;/li>
&lt;li>클라이언트가 이를 병합&lt;/li>
&lt;li>서버 측에서 vector clock을 사용해 자동 병합&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>DynamoDB 자체는 내부적으로 이런 과정을 완전히 노출하진 않지만, 유사한 원리를 기반으로 하여 요청 처리와 복제, 동기화를 관리하고 있습니다. 개발자는 필요에 따라 &amp;ldquo;강력한 일관성(ReadConsistency = STRONG)&amp;ldquo;을 선택해 안전한 읽기도 요청할 수 있습니다.&lt;/p>
&lt;h2 id="paxos-raft와의-차이점">Paxos, Raft와의 차이점&lt;/h2>
&lt;p>Paxos나 Raft는 분산 시스템에서 강력한 일관성을 보장하기 위한 합의 알고리즘입니다. 반면 정족수 합의는 어느 정도의 일관성을 포기하고 가용성과 응답 속도를 높이는 데 집중합니다.&lt;/p>
&lt;blockquote>
&lt;p>글로벌 캐시 시스템에서는 일관성보다는 응답 속도가 중요하므로 정족수 기반 시스템이 적합한 반면, 금융 거래 시스템에서는 Paxos나 Raft가 더 적합합니다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="마무리">마무리&lt;/h2>
&lt;p>정족수 합의는 모든 시스템에 적합하진 않지만, 다음과 같은 경우에 효과적일 수 있습니다.&lt;/p>
&lt;ul>
&lt;li>약간의 일관성 손해를 감수하더라도 빠른 응답과 높은 가용성이 필요한 경우&lt;/li>
&lt;li>네트워크가 불안정하거나 노드 장애가 자주 발생하는 환경&lt;/li>
&lt;/ul>
&lt;p>정족수 기반 합의는 완벽한 정답을 요구하지 않고, 일부 노드의 응답만으로도 시스템을 안정적으로 운영할 수 있게 해주는 현실적인 접근 방법입니다.&lt;/p></description></item><item><title>논문으로 다시 이해한 CAP 정리</title><link>https://codemario318.github.io/post/common/cap/</link><pubDate>Wed, 21 May 2025 16:10:00 +0900</pubDate><guid>https://codemario318.github.io/post/common/cap/</guid><description>&lt;img src="https://codemario318.github.io/post/common/cap/cover.png" alt="Featured image of post 논문으로 다시 이해한 CAP 정리" />&lt;h2 id="들어가며">들어가며&lt;/h2>
&lt;p>분산 시스템 설계에 대해 학습하다보면, CAP 정리가 항상 언급되는 것 같습니다.&lt;/p>
&lt;p>CAP 정리는 일관성(Consistency), 가용성(Availability), 분할 내성(Partition Tolerance) 세 가지를 동시에 만족할 수 없다는 원칙으로 요약되는데요&lt;/p>
&lt;p>이 정리는 2000년 Eric Brewer가 학회 발표에서 처음 제안한 이후, 분산 시스템 설계의 기본 전제로 널리 인용되어 왔습니다.&lt;/p>
&lt;p>처음 봤을 땐 그렇구나 하고 넘어갔는데, 계속 등장하니 조금 더 깊은 내용이 궁금해졌습니다.&lt;/p>
&lt;p>그래서 이 글에서는 해당 추측을 이론적으로 증명한 논문, &lt;a class="link" href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;amp;type=pdf&amp;amp;doi=24cece61e2128780072bc58f90b8ba47f624bc27" target="_blank" rel="noopener"
>&lt;em>Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services&lt;/em>&lt;/a>를 바탕으로 CAP가 어떤 의미인지 정확히 파악해보려고 합니다.&lt;/p>
&lt;p>논문의 내용을 단락 단위로 해석하고, 그 의미를 함께 짚어보는 방식으로 살펴보겠습니다.&lt;/p>
&lt;h2 id="도입부">도입부&lt;/h2>
&lt;h3 id="brewer의-추측">Brewer의 추측&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>At PODC 2000, Brewer, in an invited talk, made the following conjecture: it is impossible for a web service to provide the following three guarantees: consistency, availability, and partition-tolerance.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>2000년 PODC 학회에서 Eric Brewer는 웹 서비스가 다음의 세 가지 특성을 동시에 만족시킬 수 없다는 추측을 언급했습니다.&lt;/p>
&lt;ul>
&lt;li>일관성 (Consistency)&lt;/li>
&lt;li>가용성 (Availability)&lt;/li>
&lt;li>분할 내성 (Partition tolerance)&lt;/li>
&lt;/ul>
&lt;p>이 세 가지는 각각의 의미도 중요하지만, 무엇보다 &amp;ldquo;동시에 만족시킬 수 없다&amp;quot;는 점이 핵심입니다. 처음엔 추측으로 제안된 이 주장은, 지금은 CAP 정리라는 이름으로 잘 알려져 있죠.&lt;/p>
&lt;p>그러한 이유로 CAP 정리를 브루어의 정리라고도 부르기도 합니다. 논문은 이 세 가지가 왜 동시에 만족될 수 없는지를 구체적인 모델 위에서 이론적으로 증명합니다.&lt;/p>
&lt;h3 id="일관성에-대한-기대">일관성에 대한 기대&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>Most web services today attempt to provide strongly consistent data. &amp;hellip; (중략) &amp;hellip; once a transaction is committed it is permanent (durable).&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>현실의 웹 서비스는 ACID 트랜잭션을 전제로 강한 일관성을 기본 기대값으로 두고 있다&lt;/strong>고 볼 수 있습니다.&lt;/p>
&lt;p>사용자는 데이터가 중간에 잘렸거나, 쓰기 도중 일부만 반영된 상태를 보는 것을 원하지 않습니다. 쓰기가 완료되었다면 어떤 노드에서 읽더라도 동일한 값을 받을 수 있어야 한다는 기대가 전제되어 있습니다.&lt;/p>
&lt;p>이런 이유로 대부분의 시스템은 트랜잭션을 기반으로 한 일관성 보장 메커니즘을 필수 요소로 고려하게 됩니다.&lt;/p>
&lt;h3 id="가용성에-대한-기대">가용성에 대한 기대&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>Web services are similarly expected to be highly available. &amp;hellip; (중략) &amp;hellip; The goal of most web services today is to be as available as the network on which they run: if any service on the network is available, then the web service should be accessible.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>웹 서비스는 언제든지 요청에 응답할 수 있어야 한다는 기대를 받는다&lt;/strong>고 정리할 수 있습니다.&lt;/p>
&lt;p>서비스 중단은 단순한 불편을 넘어서 실제 피해로 이어질 수 있습니다. 논문에서는 증권 거래 사이트(E-Trade)의 사례를 들어, 서비스가 중요한 시점에 응답하지 못할 경우 법적 문제까지 발생할 수 있다고 설명합니다.&lt;/p>
&lt;p>그만큼 가용성은 기술적 요구를 넘어 &lt;strong>서비스의 신뢰성과 직접 연결되는 특성&lt;/strong>입니다.&lt;/p>
&lt;p>이 때문에 대부분의 시스템은 네트워크 어딘가에 살아 있는 노드가 있다면, 전체 시스템 역시 반드시 응답할 수 있어야 한다는 전제를 갖고 설계됩니다.&lt;/p>
&lt;h3 id="분할-내성에-대한-필요">분할 내성에 대한 필요&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>Finally, on a highly distributed network, it is desirable to provide some amount of fault-tolerance. &amp;hellip; (중략) &amp;hellip; In this note we will not consider stopping failures, though in some cases a stopping failure can be modeled as a node existing in its own unique component of a partition.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>분산 시스템에서는 네트워크 분할 상황에서도 동작을 계속할 수 있는 능력, 즉 분할 내성이 요구된다&lt;/strong>고 볼 수 있습니다.&lt;/p>
&lt;p>노드나 통신 경로에 장애가 발생하는 상황은 실제 시스템에서 흔히 일어납니다. 이때 전체 시스템이 멈추지 않고 가능한 범위 내에서 계속 동작해야 한다는 요구가 생깁니다.&lt;/p>
&lt;p>논문에서는 일부 노드나 메시지가 단절된 상황을 &amp;ldquo;분할(partition)&amp;ldquo;로 간주하고, 이러한 환경에서도 서비스가 가능한 상태를 유지할 수 있어야 한다는 점을 분할 내성의 핵심으로 설명합니다.&lt;/p>
&lt;h2 id="논문에서-정의하는-세-가지-특성">논문에서 정의하는 세 가지 특성&lt;/h2>
&lt;p>앞에서 소개한 세 가지 특성은 모두 중요하지만, 그 의미가 모호하거나 해석에 따라 다르게 받아들여질 수 있습니다.&lt;/p>
&lt;p>따라서 논문에서는 본격적인 증명에 앞서, 이 세 가지 특성을 정확히 어떤 의미로 사용할지를 형식적으로 정의하고 있습니다.&lt;/p>
&lt;p>각 정의는 논문 전체에서 사용하는 모델의 핵심 가정이기도 하며, 이후 증명의 기반이 되는 전제 조건으로 작용합니다.&lt;/p>
&lt;h3 id="atomic-data-object">Atomic Data Object&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>The most natural way of formalizing the idea of a consistent service is as an atomic data object. &amp;hellip; (중략) &amp;hellip; See [6] for a more complete definition of atomic consistency.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>Atomic Data Object는 분산된 환경에서도 순차적으로 동작하는 것처럼 보이는 일관성을 모델링한 개념이다&lt;/strong>라고 이해할 수 있습니다.&lt;/p>
&lt;p>논문에서는 일관성을 형식적으로 정의하기 위해 &lt;strong>Atomic Data Object&lt;/strong>를 사용합니다.&lt;/p>
&lt;p>이 객체는 **atomic consistency (또는 linearizability)**를 만족해야 하며, 이는 모든 연산이 일관된 전역 순서를 따르는 것처럼 동작함을 의미합니다.&lt;/p>
&lt;p>예를 들어, 어떤 쓰기 연산이 완료된 이후 시작된 읽기 연산은 반드시 그 값 또는 그 이후의 값을 반환해야 합니다.&lt;/p>
&lt;p>이런 모델은 사용자 입장에서 시스템이 &lt;strong>단일 노드처럼 예측 가능하게&lt;/strong> 동작한다고 느낄 수 있게 해줍니다.&lt;/p>
&lt;h3 id="availability">Availability&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>For a distributed system to be continuously available, every request received by a non-failing node in the system must result in a response. &amp;hellip; (중략) &amp;hellip; even when severe network failures occur, every request must terminate.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>고장나지 않은 노드로 들어온 요청은 반드시 응답을 받아야 한다&lt;/strong>라고 이해할 수 있습니다.&lt;/p>
&lt;p>논문에서는 가용성을 &amp;ldquo;모든 요청이 언젠가는 응답을 받아야 한다&amp;quot;는 조건으로 정의합니다. 특히 이 정의는 &lt;strong>메시지가 유실될 수 있는 환경에서도 요청을 포기하지 않고 처리해야 함&lt;/strong>을 전제로 하고 있습니다.&lt;/p>
&lt;p>이는 단순한 성능 문제가 아니라 &lt;strong>시스템이 지속적으로 응답 가능하다는 보장&lt;/strong>, 즉 실시간으로 동작하는 서비스가 가져야 할 기본 조건으로 제시됩니다.&lt;/p>
&lt;p>또한 부분 실패 상황, 예를 들어 다른 모든 노드가 실패하더라도 하나의 노드만 살아 있다면 그 노드는 여전히 &lt;strong>요청에 응답할 수 있어야 한다&lt;/strong>는 점을 강조합니다.&lt;/p>
&lt;h3 id="partition-tolerance">Partition Tolerance&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>In order to model partition tolerance, the network will be allowed to lose arbitrarily many messages sent from one node to another. &amp;hellip; (중략) &amp;hellip; a valid (atomic) response must be generated.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>분할 내성은 네트워크 일부가 단절되어도 시스템이 동작을 멈추지 않아야 한다는 특성을 의미한다&lt;/strong>고 볼 수 있습니다.&lt;/p>
&lt;p>논문에서는 네트워크 분할을 모델링하기 위해, &lt;strong>일부 노드 간의 메시지가 영구적으로 손실되는 상황&lt;/strong>을 허용합니다. 이 경우 시스템은 전체가 멈추는 것이 아니라, &lt;strong>분리된 각 노드가 독립적으로 응답을 계속할 수 있어야 한다&lt;/strong>는 요구를 받습니다.&lt;/p>
&lt;p>분할 내성을 만족하는 시스템은 하나의 노드만 살아 있고 나머지 노드들과 통신할 수 없는 상황에서도, 해당 노드는 &lt;strong>자체적으로 요청을 처리하고 응답할 수 있어야 합니다.&lt;/strong>&lt;/p>
&lt;p>이 정의는 논문 전반에서 &lt;strong>Partition Tolerance를 &amp;lsquo;메시지 유실이 있는 환경에서의 정상 동작 보장&amp;rsquo;으로 해석한다&lt;/strong>는 점에서 중요합니다.&lt;/p>
&lt;h2 id="비동기-네트워크에서의-불가능성">비동기 네트워크에서의 불가능성&lt;/h2>
&lt;p>논문에서는 본격적인 증명에 앞서 정의한 세 가지 특성이 어떤 조건 하에서 동시에 만족될 수 없는지를 순차적으로 보여줍니다.&lt;/p>
&lt;p>이 섹션에서는 먼저 &lt;strong>비동기 네트워크 모델&lt;/strong>에서의 불가능성을 다루고 있으며, 이를 통해 CAP 정리가 단순한 직관이 아니라 &lt;strong>논리적으로 증명 가능한 제약&lt;/strong>임을 밝히고 있습니다.&lt;/p>
&lt;h3 id="정리-1-비동기-모델에서-cap-불가능성-증명">정리 1: 비동기 모델에서 CAP 불가능성 증명&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>In the asynchronous model, there is no clock, and nodes must make decisions based only on the messages received and local computation. &amp;hellip; (중략) &amp;hellip; Theorem 1: It is impossible in the asynchronous network model to implement a read/write data object that guarantees the following properties: Availability, Atomic consistency, in all fair executions (including those in which messages are lost).&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>비동기 네트워크 모델에서는 가용성과 원자적 일관성을 동시에 만족하는 읽기/쓰기 객체를 구현할 수 없다&lt;/strong>는 것이 이 정리의 핵심입니다.&lt;/p>
&lt;p>논문에서 사용하는 비동기 네트워크 모델은 다음과 같은 특징을 가집니다.&lt;/p>
&lt;ul>
&lt;li>시스템에는 전역 시계가 없음&lt;/li>
&lt;li>노드는 수신한 메시지와 로컬 상태만으로 동작을 결정&lt;/li>
&lt;li>메시지는 유실될 수 있고, 언제 도착할지 보장되지 않음&lt;/li>
&lt;/ul>
&lt;p>이러한 조건 아래에서, 논문은 &lt;strong>쓰기 연산이 완료된 후에도 일부 노드가 이전 값을 반환하는 상황이 발생&lt;/strong>할 수 있음을 보여줍니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">sequenceDiagram
participant Client
participant G1 as 노드 G1
participant G2 as 노드 G2
Note over G1, G2: 초기 상태: v₀ (G1 = v₀, G2 = v₀)
Client->>G1: 쓰기 요청 (v₁)
G1->>G1: v₁ 저장
G1-->>Client: 쓰기 완료 응답
G1-xG2: 메시지 유실 (v₁ 전달 실패)
Client->>G2: 읽기 요청
G2-->>Client: v₀ 반환
&lt;/pre>
&lt;ol>
&lt;li>노드 G1에서 쓰기 연산이 완료&lt;/li>
&lt;li>G1과 G2 사이의 네트워크가 분할되어, G2는 그 값을 전달받지 못함&lt;/li>
&lt;li>이후 클라이언트가 G2에 읽기 요청을 보냄&lt;/li>
&lt;li>G2는 여전히 초기 값을 반환&lt;/li>
&lt;/ol>
&lt;p>이 상황에서 시스템은 가용성을 만족하기 위해 G2의 요청에 응답하지만, 그 결과 일관성이 깨지는 응답을 줄 수밖에 없다는 모순이 발생합니다.&lt;/p>
&lt;p>이를 통해 CAP 정리에서 말하는 세 가지 특성이 &lt;strong>왜 동시에 만족될 수 없는지를, 수학적 모델을 통해 명확히 보여주는 출발점&lt;/strong>이 됩니다.&lt;/p>
&lt;h3 id="따름정리-11-메시지-유실-여부를-판단할-수-없는-상황">따름정리 1.1: 메시지 유실 여부를 판단할 수 없는 상황&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>Corollary 1.1: It is impossible in the asynchronous network model to implement a read/write data object that guarantees the following properties: Availability, in all fair executions, and Atomic consistency, in fair executions in which no messages are lost.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>메시지가 유실되지 않는 경우에도 가용성과 원자적 일관성을 동시에 만족하는 시스템은 구현할 수 없다&lt;/strong>는 것이 이 따름정리의 핵심입니다.&lt;/p>
&lt;p>정리 1에서는 메시지 유실이 가능한 상황을 통해 모순을 구성했지만, Corollary 1.1에서는 &lt;strong>메시지가 유실되지 않는 경우만 고려하더라도 동일한 모순이 발생&lt;/strong>함을 강조합니다.&lt;/p>
&lt;p>그 이유는 &lt;strong>비동기 모델에서는 메시지가 단순히 지연된 것인지, 실제로 유실된 것인지 시스템이 구분할 수 없기 때문&lt;/strong>입니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">sequenceDiagram
participant Client
participant G1 as 노드 G1
participant G2 as 노드 G2
Note over G1, G2: 초기 상태: v₀ (G1 = v₀, G2 = v₀)
Client->>G1: 쓰기 요청 (v₁)
G1->>G1: v₁ 저장
G1-->>Client: 쓰기 완료 응답
Client->>G2: 읽기 요청
G2-->>Client: v₀ 반환
G1->>G2: 메시지 수신
G2->>G2: v₁ 저장
&lt;/pre>
&lt;p>위 상황은 G1의 메시지가 클라이언트가 G2에게 보내는 요청 보다 빨리 도달했을 때를 가정해봤습니다.&lt;/p>
&lt;p>이처럼 메시지가 유실되지 않았더라도, 노드는 언제까지 기다려야 할지 알 수 없고, 결국 같은 방식의 일관성 위반이 발생하게 됩니다.&lt;/p>
&lt;p>이 따름정리는 비동기 모델에서의 &lt;strong>정보 부족의 한계&lt;/strong>를 명확히 드러냅니다. 즉, 유실 여부를 알 수 없다는 사실 하나만으로도, 어떤 실행에서는 일관성을 만족시키는 것이 불가능해질 수 있습니다.&lt;/p>
&lt;p>논문에서는 완전한 비동기 환경이라면 노드가 메시지가 지연되는지, 유실되었는지 판단할 수 없기 때문에 메시지가 유실되지 않는 경우 가용성과 원자적 일관성을 동시에 만족한다는 의미는 결과적으로 &lt;strong>모든 상황(유실, 지연)에 가용성과 원자적 일관성을 동시에 만족&lt;/strong>하는 상황이라고 강조합니다.&lt;/p>
&lt;h2 id="비동기-모델에서의-현실적인-조합">비동기 모델에서의 현실적인 조합&lt;/h2>
&lt;p>앞서 정리 1과 따름정리 1.1을 통해,&lt;br>
비동기 네트워크에서는 &lt;strong>Atomic consistency, Availability, Partition tolerance&lt;/strong>를 동시에 만족하는 것이 불가능하다는 점이 증명되었습니다.&lt;/p>
&lt;p>하지만 세 가지를 모두 만족할 수 없다면, 그중 두 가지 조합은 실현 가능할 수 있음을 언급하며, 이를 다음과 같이 세 가지 조합으로 구분하고, 각각 어떤 상황에서 가능한지를 간단한 모델을 통해 설명합니다.&lt;/p>
&lt;blockquote>
&lt;p>이때 사용되는 &amp;ldquo;Atomic&amp;quot;은 앞서 정의한 atomic consistency, 즉 선형화 가능한 일관성을 의미합니다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="atomic--available">Atomic + Available&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>If partition-tolerance is not required, then atomicity and availability are easy to guarantee. &amp;hellip; (중략) &amp;hellip; This technique only works if the centralized node is always accessible.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>Partition tolerance를 포기하면 atomic consistency와 availability는 함께 보장할 수 있습니다.&lt;/strong>&lt;/p>
&lt;p>이 조합은 Partition tolerance를 전제하지 않는 경우에 가능합니다.&lt;/p>
&lt;p>즉, 네트워크가 항상 안정적이며, 노드 간 통신이 절대 실패하지 않는 환경이라면 atomic consistency와 availability를 동시에 만족하는 시스템을 구현할 수 있습니다.&lt;/p>
&lt;p>논문에서는 이러한 조건 아래에서 중앙 집중형 알고리즘을 통해 모든 요청을 직렬화하고, 실패가 없는 한 모든 요청에 응답할 수 있는 구조를 예시로 제시합니다.&lt;/p>
&lt;p>다만 Partition tolerance가 없는 분산 시스템은 현실적으로 성립하기 어렵기 때문에, 이 조합은 제한된 환경(예: 단일 데이터센터, LAN 등)에서만 현실적으로 가능하다는 점도 강조하고 있습니다.&lt;/p>
&lt;h3 id="available--partition-tolerant">Available + Partition Tolerant&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>It is possible to provide high availability and partition tolerance, if atomic consistency is not required. &amp;hellip; (중략) &amp;hellip; Web caches are one example of a weakly consistent network.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>atomic consistency를 포기하면 availability와 partition tolerance는 동시에 만족할 수 있습니다.&lt;/strong>&lt;/p>
&lt;p>이 조합은 시스템이 항상 응답 가능해야 하면서도, 네트워크 분할 상황에서도 멈추지 않고 동작해야 할 때 선택할 수 있습니다. 대신 모든 노드가 동일한 시점의 값을 보장하는 일관성은 포기해야 합니다.&lt;/p>
&lt;p>논문에서는 이 조합을 만족시키는 극단적인 예로, 모든 읽기 요청에 초기값 &lt;code>v₀&lt;/code>만을 반환하는 시스템을 제시합니다.&lt;/p>
&lt;p>이 경우 일관성은 없지만, 어떤 상황에서도 요청은 처리됩니다.&lt;/p>
&lt;p>실제로는 이보다는 **약한 일관성(weak consistency)**을 부분적으로 유지하면서, 가능한 한 최신 데이터를 반환하려는 구조들이 현실적인 선택지로 사용됩니다.&lt;/p>
&lt;ul>
&lt;li>이러한 접근은 이후 논문에서 다루는 약한 일관성과 지연된 일관성 개념으로 이어집니다.&lt;/li>
&lt;/ul>
&lt;h3 id="atomic--partition-tolerant">Atomic + Partition Tolerant&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>If availability is not required, then it is easy to achieve atomic data and partition tolerance. &amp;hellip; (중략) &amp;hellip; If there are no failures, then liveness is guaranteed.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>가용성을 포기하면 atomic consistency와 partition tolerance는 동시에 만족시킬 수 있습니다.&lt;/strong>&lt;/p>
&lt;p>이 조합은 Availability를 포기한 경우에 가능합니다. 시스템이 일관성과 분할 내성을 만족해야 한다면, 일부 요청에 대해서는 응답하지 않아도 되는 상황을 허용해야 합니다.&lt;/p>
&lt;p>논문에서는 중앙 집중형 알고리즘을 예로 들며 이 조합이 어떻게 성립하는지를 설명합니다.&lt;/p>
&lt;p>요청을 받은 노드는 중앙 노드에 메시지를 전송하고, 중앙 노드로부터 응답을 받은 뒤에야 클라이언트에 응답합니다. 하지만 네트워크 분할로 인해 중앙 노드와 통신이 불가능한 경우, 클라이언트 요청에 대한 응답은 무한히 지연되거나 아예 실패할 수 있습니다.&lt;/p>
&lt;p>이 방식은 모든 메시지가 정상적으로 전달된다면 시스템은 응답 가능하지만, 분할이 발생하는 실행에서는 일관성을 보존하기 위해 가용성을 희생하게 됩니다.&lt;/p>
&lt;h2 id="부분-동기-모델에서의-논의">부분 동기 모델에서의 논의&lt;/h2>
&lt;p>비동기 네트워크에서는 CAP 세 가지를 동시에 만족할 수 없다는 점이 증명되었지만, 현실의 시스템은 대부분 &lt;strong>완전히 비동기적이지는 않습니다&lt;/strong>.&lt;/p>
&lt;p>일정 시간 안에 메시지가 도달하거나, 노드가 타임아웃을 기준으로 동작을 조정하는 식의 &lt;strong>부분적인 동기성&lt;/strong>이 존재합니다.&lt;/p>
&lt;p>논문에서는 이러한 현실적인 조건을 반영한 **부분 동기 네트워크 모델(partially synchronous model)**을 도입하여, 이 환경에서도 여전히 불가능한 것이 무엇인지 분석합니다.&lt;/p>
&lt;h3 id="정리-2-시계가-있어도-해결되지-않는-모순">정리 2: 시계가 있어도 해결되지 않는 모순&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>Theorem 2: It is impossible in the partially synchronous network model to implement a read/write data object that guarantees the following properties: Availability and Atomic consistency.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>부분 동기 모델에서도 Availability와 Atomic consistency는 동시에 만족시킬 수 없습니다.&lt;/strong>&lt;/p>
&lt;p>이 정리는 분산 시스템의 각 노드가 시계를 가지고 있고, 메시지가 일정 시간 내에 도착하거나 유실된다는 조건이 주어진 상황에서도 앞서와 같은 모순이 여전히 발생함을 보여줍니다.&lt;/p>
&lt;p>논문에서는 G1에서 쓰기 연산이 완료된 뒤 충분한 시간이 흐른 후, G2에서 읽기 연산이 수행되는 시나리오를 구성합니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">sequenceDiagram
participant Client
participant G1 as 노드 G1
participant G2 as 노드 G2
Note over G1, G2: 초기 상태: G1 = v₀, G2 = v₀
rect rgba(0, 200, 0, 0.05)
Note over G1: 쓰기 연산 α₁
Client->>G1: 쓰기 요청 (v₁)
G1->>G1: v₁ 저장
G1-->>Client: 쓰기 완료
end
G1-xG2: 메시지 손실 (v₁ 미전달)
rect rgba(255, 255, 0, 0.1)
Note over G1, G2: α₁ 이후 충분한 시간 간격 (α′₂)
end
rect rgba(0, 200, 0, 0.05)
Note over G2: 읽기 연산 α₂
Client->>G2: 읽기 요청
G2-->>Client: v₀ 반환 (최신 값 아님)
end
&lt;/pre>
&lt;ol>
&lt;li>G1에서 쓰기 연산 α₁이 발생하여 v₁을 저장&lt;/li>
&lt;li>G1과 G2 사이의 메시지는 손실됨&lt;/li>
&lt;li>α₁ 이후 충분한 시간 간격(α′₂)이 존재함&lt;/li>
&lt;li>G2에서 읽기 연산 α₂가 발생하지만, 여전히 v₀을 반환 (최신 값을 알 수 없음)&lt;/li>
&lt;li>G2는 가용성을 만족하기 위해 응답하지만, 일관성을 위반&lt;/li>
&lt;/ol>
&lt;p>이때 메시지가 손실된 경우, 읽기는 여전히 이전 값을 반환할 수밖에 없고, 이는 &lt;strong>일관성 위반&lt;/strong>이 됩니다.&lt;/p>
&lt;p>즉, 타임아웃을 통해 메시지 유실 여부를 추론할 수 있다 하더라도 CAP 세 가지를 동시에 만족시키는 것은 여전히 불가능하다는 점을 이 정리를 통해 강조합니다.&lt;/p>
&lt;h3 id="네트워크-안정-시-가능해지는-조건적-보장">네트워크 안정 시 가능해지는 조건적 보장&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>While it is not possible to implement an atomic read/write register in the partially synchronous model, if availability is required, it is still possible to implement such an object if atomicity is required only in executions in which all messages are delivered.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>부분 동기 모델에서도 모든 메시지가 전달되는 실행에 대해서는 atomic consistency를 만족할 수 있습니다.&lt;/strong>&lt;/p>
&lt;p>정리 2에서는 가용성과 일관성을 동시에 보장하는 것이 불가능하다고 했지만, &lt;strong>그 불가능은 모든 실행에 대해 동시에 만족시킬 수 없다는 의미&lt;/strong>입니다.&lt;/p>
&lt;p>만약 시스템이 &lt;strong>일관성을 제공해야 하는 상황을 &amp;ldquo;모든 메시지가 eventually 전달되는 실행&amp;quot;으로 한정&lt;/strong>한다면,그 범위 안에서는 atomicity를 구현하는 것이 가능합니다.&lt;/p>
&lt;p>논문에서는 중앙 집중형 알고리즘을 예로 들어 이 가능성을 설명합니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart TD
Client[클라이언트] --> A[로컬 노드 A]
A --> C[중앙 노드 C]
C --> A
A --> Client
C --> N1[다른 노드 1]
C --> N2[다른 노드 2]
C --> N3[다른 노드 3]
style C fill:#fdf6b2,stroke:#e0c000,stroke-width:2px
style A fill:#e0f7fa,stroke:#00acc1,stroke-width:1px
style Client fill:#eeeeee,stroke:#aaaaaa
&lt;/pre>
&lt;p>요청은 중앙 노드로 전달되고, 중앙 노드가 이를 직렬화하여 처리하는 구조로, 네트워크가 안정적이라면 모든 요청은 eventually 수락되고, 그 결과는 atomic하게 보장될 수 있습니다.&lt;/p>
&lt;p>이 조건부 보장은 완전한 불가능을 대체하지는 않지만, &lt;strong>현실적인 시스템 설계에서 atomicity를 제한적으로라도 달성할 수 있는 여지를 제공&lt;/strong>한다는 점에서 의미가 있습니다.&lt;/p>
&lt;h2 id="약한-일관성-조건">약한 일관성 조건&lt;/h2>
&lt;p>앞서 살펴본 바와 같이, 네트워크가 비동기적이거나 분할 상황이 존재한다면 원자적 일관성과 가용성, 분할 내성을 동시에 만족하는 것은 불가능합니다.&lt;/p>
&lt;p>이러한 제약을 인정하면서도 시스템이 제공하는 응답의 품질을 통제하기 위해, 논문은 이 섹션에서 &lt;strong>일관성을 약화시키되, 그 조건을 형식적으로 정의하는 모델&lt;/strong>을 제안합니다.&lt;/p>
&lt;p>이 모델은 Delayed-t Consistency라고 불리며, 약한 일관성 조건을 시간 기반으로 규정합니다.&lt;/p>
&lt;h3 id="완전한-일관성을-항상-보장할-수-없는-상황">완전한 일관성을 항상 보장할 수 없는 상황&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>While it is useful to guarantee that atomic data will be returned in executions in which all messages are delivered (within some time bound), it is equally important to specify what happens in executions in which some of the messages are lost.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>모든 메시지가 도달하는 경우만 고려해서는 충분하지 않으며, 메시지가 유실되는 실행에서는 어떤 값이 반환될 수 있는지도 명시해야 합니다.&lt;/strong>&lt;/p>
&lt;p>앞서 정리 1과 정리 2에서는, 비동기 및 부분 동기 네트워크 모델에서 atomic consistency와 availability를 동시에 만족할 수 없음을 보였습니다.&lt;/p>
&lt;p>그렇다고 해서 메시지가 유실되거나 지연되는 상황에서 시스템이 무조건 응답을 중단하거나, 무의미한 값을 반환하도록 내버려 둘 수는 없습니다.&lt;/p>
&lt;p>논문은 이 지점에서 **&amp;ldquo;약한 일관성 조건(weaker consistency conditions)&amp;rdquo;**이라는 방향을 제시합니다. 즉, 메시지 유실이 존재하는 환경에서도 &lt;strong>응답 값이 지켜야 할 최소한의 일관성 조건을 형식적으로 정의하는 방법&lt;/strong>을 제안하는 것입니다.&lt;/p>
&lt;h3 id="delayed-t-consistency란">Delayed-t Consistency란?&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>This consistency model ensures that if messages are delivered, then eventually some notion of atomicity is restored.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>일정 시간 동안 메시지가 안정적으로 전달된다면, 그 이후에는 atomic consistency가 다시 보장되어야 한다&lt;/strong>는 모델입니다.&lt;/p>
&lt;p>이 일관성 모델은 다음과 같은 전제를 가집니다.&lt;/p>
&lt;ul>
&lt;li>네트워크가 일시적으로 분할되거나 메시지가 손실될 수는 있지만,&lt;/li>
&lt;li>&lt;strong>일정 시간 t 이상 메시지 손실이 발생하지 않는 구간이 존재한다면&lt;/strong>,&lt;/li>
&lt;li>그 구간 이후부터는 시스템이 &lt;strong>다시 원자적(atomic)인 응답을 보장&lt;/strong>해야함&lt;/li>
&lt;/ul>
&lt;p>논문에서는 이를 &lt;strong>Delayed-t Consistency&lt;/strong>라고 정의하고, 그 조건을 만족하는 실행에 대해 어떤 순서 보장과 응답 품질이 필요한지를 형식적으로 정의합니다.&lt;/p>
&lt;p>이 모델은 완전한 atomic consistency를 제공하지는 않지만, &lt;strong>네트워크가 회복된 뒤 일정 시간이 지나면 다시 강한 일관성이 회복됨을 보장&lt;/strong>합니다.&lt;/p>
&lt;p>이는 eventually consistent 시스템보다 더 구체적이며, “언젠가 일관성이 회복된다”가 아니라 &amp;ldquo;&lt;strong>정해진 시간 이후에는 반드시 회복된다&lt;/strong>&amp;ldquo;는 점에서 의미 있는 차이가 있습니다.&lt;/p>
&lt;h3 id="definition-3-delayed-t-consistency의-형식적-정의">Definition 3: Delayed-t Consistency의 형식적 정의&lt;/h3>
&lt;blockquote>
&lt;p>*Definition 3: A timed execution, α, of a read-write object is Delayed-t Consistent if:&lt;/p>
&lt;ol>
&lt;li>P is a partial order that orders all write operations, and orders all read operations with respect to the write operations.&lt;/li>
&lt;li>The value returned by every read operation is exactly the one written by the previous write operation in P (or the initial value, if there is no such previous write in P).&lt;/li>
&lt;li>The order in P is consistent with the order of read and write requests submitted at each node.&lt;/li>
&lt;li>(Atomicity) If all messages in the execution are delivered, and an operation θ completes before an operation φ begins, then φ does not precede θ in the partial order P.&lt;/li>
&lt;li>(Weakly Consistent) Assume there exists an interval of time longer than t in which no messages are lost. Further, assume an operation, θ, completes before the interval begins, and another operation, φ, begins after the interval ends. Then φ does not precede θ in the partial order P.*&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>Delayed-t Consistency는 메시지 유실이 없는 일정 시간(t) 이후부터는 연산 순서가 atomic consistency에 부합하도록 제한되는 일관성 모델&lt;/strong>입니다.&lt;/p>
&lt;p>각 조건의 의미는 다음과 같습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>1. P는 모든 쓰기 연산을 순서화하고, 읽기 연산은 그에 대해 순서화되어야 한다.&lt;/strong>&lt;br>
→ 전체 실행을 정렬하는 하나의 순서가 있으며, 읽기/쓰기 간 순서 관계를 명확히 정의합니다.&lt;/p>
&lt;p>&lt;strong>2. 모든 읽기는 순서상 가장 가까운 직전 쓰기 값(또는 초기값)을 반환해야 한다.&lt;/strong>&lt;br>
→ 읽기가 이전 쓰기를 반드시 반영해야 함을 요구합니다.&lt;/p>
&lt;p>&lt;strong>3. 각 노드 내의 연산 순서는 부분 순서 P와 일치해야 한다.&lt;/strong>&lt;br>
→ 단일 노드 기준으로 볼 때, 로컬에서 일어난 순서는 전역 순서와 모순되지 않아야 합니다.&lt;/p>
&lt;p>&lt;strong>4. (Atomicity 조건)&lt;/strong>&lt;br>
→ 메시지가 유실되지 않은 실행에서, 어떤 연산 θ가 φ보다 먼저 끝났다면 φ는 절대 θ보다 앞선 순서에 위치할 수 없습니다. (순서가 뒤집히지 않아야 함)&lt;/p>
&lt;p>&lt;strong>5. (약한 일관성 조건)&lt;/strong>&lt;br>
→ 메시지 유실이 없는 구간이 t 이상 존재하고, 그 구간 이전에 끝난 연산 θ와 구간 이후 시작된 연산 φ가 있다면 φ는 θ보다 먼저 일어난 것처럼 간주되어서는 안 됩니다. 즉, &lt;strong>네트워크가 안정된 이후에는 순서를 지키라는 조건&lt;/strong>입니다.&lt;/p>
&lt;p>이 정의는 단순히 “eventually consistency”처럼 막연하게 일관성이 회복된다고 말하는 것이 아니라, &lt;strong>일관성 회복의 조건(시간, 순서, 메시지 전파 범위)을 명시적으로 제한&lt;/strong>하는 점에서 현실적인 구현 기준이 됩니다.&lt;/p>
&lt;h3 id="설계-가능성-중앙-집중형-알고리즘-설명">설계 가능성: 중앙 집중형 알고리즘 설명&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>A variant of the centralized algorithm described in Section 4.3 is Delayed-t consistent. Assume node C is the centralized node. The algorithm behaves as follows: &amp;hellip;&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>논문은 Definition 3을 만족하는 구조로 중앙 집중형 알고리즘의 변형을 제시합니다.&lt;/strong>&lt;/p>
&lt;p>이 알고리즘은 기존의 중앙 집중형 모델을 기반으로 하되, &lt;strong>시간 기반 메시지 처리&lt;/strong>와 &lt;strong>타임아웃에 따른 보조 흐름&lt;/strong>을 추가한 구조입니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">sequenceDiagram
participant Client
participant A as 로컬 노드 A
participant C as 중앙 노드 C
participant N1 as 다른 노드
%% 쓰기 요청 처리 흐름
Client->>A: 쓰기 요청 (v₁)
A->>C: 중앙 노드에 전달
C->>C: v₁ 저장, 시퀀스 번호 증가
C->>A: 응답
A->>Client: 쓰기 응답
C->>N1: v₁ 전파
%% 메시지 유실 시 타임아웃 처리
Note over C,N1: 메시지 손실 시 C는 일정 시간 내 재전송 시도
&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>쓰기 요청 처리&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>노드 A가 중앙 노드 C에 새로운 값을 보냄&lt;/li>
&lt;li>C는 시퀀스 번호를 증가시키고 값을 저장&lt;/li>
&lt;li>C는 모든 노드에 값을 전파&lt;/li>
&lt;li>메시지 유실이 의심되면 C는 t−2×timeout 시간 안에 재전송을 수행&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>읽기 요청 처리&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>노드 A는 C에 현재 값을 요청&lt;/li>
&lt;li>응답이 정상적으로 오면 그 값을 클라이언트에 전달&lt;/li>
&lt;li>응답이 없으면, 로컬에 저장된 가장 최신 값(또는 초기값)을 반환&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>이 구조는 메시지가 도달하지 않더라도 &lt;strong>가용성(응답)을 보장하면서&lt;/strong>, 네트워크가 안정된 이후에는 &lt;strong>atomic consistency로 회복되는&lt;/strong> 설계입니다.&lt;/p>
&lt;h3 id="theorem-4-이-알고리즘은-정의를-만족함">Theorem 4: 이 알고리즘은 정의를 만족함&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>Theorem 4: The modified centralized algorithm is Delayed-t consistent.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>요약하면, &lt;strong>앞서 설명한 중앙 집중형 알고리즘은 Delayed-t Consistency의 다섯 가지 조건을 모두 만족한다.&lt;/strong> 입니다.&lt;/p>
&lt;p>논문은 Definition 3에서 제시한 일관성 조건들을 하나씩 검토하며, 해당 알고리즘이 그것들을 모두 충족함을 논리적으로 설명합니다.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>부분 순서(P) 정의&lt;/strong>
&lt;ul>
&lt;li>중앙 노드 C가 모든 쓰기 요청에 시퀀스 번호를 부여하므로, 연산 간 전역 순서가 정해짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>읽기 연산은 이전 쓰기 값을 반환&lt;/strong>
&lt;ul>
&lt;li>각 읽기는 로컬 또는 중앙 노드로부터 가장 최근의 쓰기 값을 참조&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>로컬 순서와 부분 순서의 일치&lt;/strong>
&lt;ul>
&lt;li>각 노드는 자신의 연산 순서를 전역 순서와 동일하게 유지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>모든 메시지가 전달되는 실행에서 atomic consistency 보장&lt;/strong>
&lt;ul>
&lt;li>C가 직렬화하고 모든 노드에 전파하므로, 메시지 손실이 없는 경우에는 원자성을 만족&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>메시지 유실 없는 시간 구간 이후 순서 보장&lt;/strong>
&lt;ul>
&lt;li>일정 시간(t) 동안 모든 메시지가 전달되면, 그 이후 연산은 앞선 연산을 순서상 앞서지 않도록 설계&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>이로써 Delayed-t Consistency는 단순한 이론적 모델이 아니라, &lt;strong>구체적인 알고리즘을 통해 구현 가능하고 증명 가능한 약한 일관성 조건&lt;/strong>이라는 점이 논리적으로 뒷받침됩니다.&lt;/p>
&lt;h2 id="마무리">마무리&lt;/h2>
&lt;p>CAP 정리는 세 가지 특성을 모두 만족할 수 없다는 이야기로 자주 소개되지만, 이 논문을 통해 그 제약이 단순한 경험법칙이 아니라 모델과 조건이 주어졌을 때 논리적으로 증명 가능한 것임을 알 수 있었습니다. &lt;del>논문에서 논리로만 설명할 줄은 몰랐네요😂&lt;/del>&lt;/p>
&lt;p>정리에 따르면 비동기나 부분 동기 네트워크에서는 일관성과 가용성을 동시에 만족시키는 것이 원칙적으로 불가능하고, 이런 한계를 어떻게 받아들이고 설계할 것인지는 시스템마다 다를 수밖에 없다는 것을 강조하고 있습니다.&lt;/p>
&lt;p>논문에서 제시한 Delayed-t Consistency는 일관성을 완전히 포기하는 대신, 메시지 손실이 없는 구간 이후에는 다시 원자성을 회복할 수 있도록 제한하는 방식이 인상적이었습니다.&lt;/p>
&lt;p>정리하면서 CAP에 대해 그동안 놓치고 있었던 부분을 정리할 수 있어 좋았네요, 비슷한 고민을 하신 분께도 조금은 도움이 되었으면 합니다.&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다.😊&lt;/p></description></item><item><title>웹소켓 시스템의 성능 개선하기</title><link>https://codemario318.github.io/post/websocket-scale-out/</link><pubDate>Sat, 04 Jan 2025 14:57:49 +0900</pubDate><guid>https://codemario318.github.io/post/websocket-scale-out/</guid><description>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/cover.png" alt="Featured image of post 웹소켓 시스템의 성능 개선하기" />&lt;p>최근 실시간 다중 사용자 퀴즈 게임을 구현하면서 단순하게 서버 1대와 인메모리(이하 세션)를 이용한 방식으로 웹소켓을 이용해 게임 진행과 채팅 기능을 구현했었는데요.&lt;/p>
&lt;p>당시 부하 테스트 결과로 초당 5,000건 이상의 메시지 처리가 가능했기 때문에, 목표로 했던 300명 이상의 참여자 동시 진행이 가능했습니다.&lt;/p>
&lt;p>하지만 게임에 참여하는 사용자가 많아지면 현재 상황에서는 분명 한계가 있겠죠? 그래서 웹소켓 서버의 처리량을 늘리는 방법들에 대해서 알아보려 합니다.&lt;/p>
&lt;h2 id="수평-확장과-수직-확장">수평 확장과 수직 확장&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img.png"
width="1024"
height="659"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_hu1795940aac2814a197193d8fc3eed447_80445_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_hu1795940aac2814a197193d8fc3eed447_80445_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="img.png"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="372px"
>&lt;/p>
&lt;p>시스템의 성능을 향상시킬 때 기본적으로 &lt;strong>수평 확장&lt;/strong>과 &lt;strong>수직 확장&lt;/strong> 두 가지 접근 방식을 고려할 수 있습니다.&lt;/p>
&lt;h3 id="수직-확장-scale-up">수직 확장 (Scale Up)&lt;/h3>
&lt;p>단일 서버의 성능을 향상시키는 방법입니다. CPU, 메모리, 디스크 등 하드웨어 리소스를 증설하여 성능을 개선합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>장점:&lt;/strong>
&lt;ul>
&lt;li>구현이 간단하며 추가적인 아키텍처 변경이 필요 없음&lt;/li>
&lt;li>단일 서버이므로 데이터 일관성 유지가 쉬움&lt;/li>
&lt;li>네트워크 복잡도가 낮음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>단점:&lt;/strong>
&lt;ul>
&lt;li>하드웨어 비용이 기하급수적으로 증가&lt;/li>
&lt;li>물리적인 한계가 존재&lt;/li>
&lt;li>장애 발생 시 전체 시스템에 영향&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="수평-확장-scale-out">수평 확장 (Scale Out)&lt;/h3>
&lt;p>동일한 서버를 여러 대 추가하여 부하를 분산시키는 방법입니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>장점:&lt;/strong>
&lt;ul>
&lt;li>선형적인 비용 증가로 효율적&lt;/li>
&lt;li>무한한 확장이 이론적으로 가능&lt;/li>
&lt;li>고가용성과 장애 허용성 확보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>단점:&lt;/strong>
&lt;ul>
&lt;li>아키텍처가 복잡해짐&lt;/li>
&lt;li>데이터 일관성 유지가 어려움&lt;/li>
&lt;li>네트워크 오버헤드 발생&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>수직 확장은 단순히 서버 스펙을 올리는 것으로 한계가 명확하기 때문에(&lt;del>비싸기 때문에&lt;/del>), 수평 확장 위주로 성능을 개선하는 것이 바람직해보입니다.&lt;/p>
&lt;p>이제 수평 확장을 위한 구체적인 방법들을 살펴보겠습니다.&lt;/p>
&lt;h2 id="웹소켓의-특성">웹소켓의 특성&lt;/h2>
&lt;p>먼저 여러 시도를 하기 전 웹소켓의 연결 특성에 대해 이해할 필요가 있습니다.&lt;/p>
&lt;p>웹소켓은 클라이언트와 서버 간에 지속 &lt;strong>연결 상태를 유지&lt;/strong>하므로, 수평 확장 시 각 서버에 &lt;strong>클라이언트 연결이 분산&lt;/strong>됩니다.&lt;/p>
&lt;p>이를 해결하기 위해 &lt;strong>서버 간 상태를 동기화&lt;/strong>하거나 상황에 맞게 클라이언트가 &lt;strong>특정 서버에 고정&lt;/strong>되도록 설정해야 합니다.&lt;/p>
&lt;h2 id="로드-밸런싱">로드 밸런싱&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_1.png"
width="1650"
height="1275"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_1_hue58ad55d5fe691e3e59586d3994effac_81538_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_1_hue58ad55d5fe691e3e59586d3994effac_81538_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="로드 밸런싱"
class="gallery-image"
data-flex-grow="129"
data-flex-basis="310px"
>&lt;/p>
&lt;p>수평 확장을 통해 서비스의 요청을 분산하기 위해 여러 대의 서버를 배포하면 실제로 배포된 여러 서버로 요청을 분산해야겠죠&lt;/p>
&lt;p>로드 밸런싱은 들어오는 네트워크 트래픽을 여러 서버에 효율적으로 분산하는 기술입니다.&lt;/p>
&lt;h3 id="sticky-sessions-vs-non-sticky-sessions">Sticky Sessions vs Non-Sticky Sessions&lt;/h3>
&lt;p>네트워크 트래픽을 분산하기 위한 여러 알고리즘이 존재하는데, 클라이언트 요청이 같은 서버로 가는지 아닌지에 따라 나눌 수 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_2.png"
width="850"
height="400"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_2_hu00407f29da576d8704b9ee37e577ead4_25051_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_2_hu00407f29da576d8704b9ee37e577ead4_25051_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Sticky Sessions vs Non-Sticky Sessions"
class="gallery-image"
data-flex-grow="212"
data-flex-basis="510px"
>&lt;/p>
&lt;p>Non-Sticky Sessions은 클라이언트의 요청이 매번 다른 서버로 자유롭게 라우팅될 수 있는 방식으로 stateless 아키텍처를 구현할 때 선호되는 방식입니다.&lt;/p>
&lt;p>주요 차이점을 비교하면:&lt;/p>
&lt;ol>
&lt;li>상태 관리
&lt;ul>
&lt;li>Sticky Sessions: 서버가 클라이언트의 상태를 메모리에 보관&lt;/li>
&lt;li>Non-Sticky Sessions: 모든 상태를 Redis 같은 외부 저장소에 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>장애 대응
&lt;ul>
&lt;li>Sticky Sessions: 서버 장애 시 해당 서버의 모든 세션 손실&lt;/li>
&lt;li>Non-Sticky Sessions: 서버 장애와 무관하게 세션 유지 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장성
&lt;ul>
&lt;li>Sticky Sessions: 특정 서버에 부하가 집중될 수 있음&lt;/li>
&lt;li>Non-Sticky Sessions: 더 균등한 부하 분산 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>웹소켓의 경우 연결 자체가 stateful하기 때문에 일반적으로 Sticky Sessions을 사용하지만, &lt;strong>대규모 시스템&lt;/strong>에서는 Non-Sticky Sessions 방식을 채택하고 모든 상태를 외부 저장소에 보관하는 방식을 사용하기도 합니다.&lt;/p>
&lt;h2 id="서버-간-상태-동기화">서버 간 상태 동기화&lt;/h2>
&lt;p>저희 서비스에서는 사용자가 퀴즈존을 기반으로 서버의 세션을 통해 관리되기 때문에, 퀴즈존에 참여하고 있는 모든 사용자가 동일한 서버에 연결되어야 합니다.&lt;/p>
&lt;p>이는 상황에 따라 사용자가 많이 참여하고 있는 퀴즈존이 특정 서버에 집중되는 경우 수평 확장의 장점을 가져갈 수 없게 되는 문제를 발생시킬 수 있습니다.&lt;/p>
&lt;p>이렇게 특정 서버에 세션에 의존하지 않게 만들기 위해 &lt;strong>서버 간의 상태를 동기화&lt;/strong> 해야할 필요가 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_3.png"
width="385"
height="131"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_3_hufe3d7b7f11325482bb16b822eb0a78ec_8599_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_3_hufe3d7b7f11325482bb16b822eb0a78ec_8599_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Redis"
class="gallery-image"
data-flex-grow="293"
data-flex-basis="705px"
>&lt;/p>
&lt;p>단순히 서버 간의 상태를 동기화 한다면, 모든 사용자에 대한 정보를 모든 서버가 메모리로 가져야하고 이를 수시로 업데이트 해야하는 문제가 있습니다.&lt;/p>
&lt;p>이는 배포된 각각의 서버의 메모리가 충분해야는 것이 기본 전제이므로 메모리로 인한 서버 비용 절감은 의미가 없어질 뿐 아니라 상태 동기화를 위한 여러 오버헤드가 발생하므로 효과적인 방식으로 보긴 어렵습니다.&lt;/p>
&lt;p>그래서 더 단순한 방법으로 배포된 여러 서버가 같은 세션을 바라보게 만드는 방법을 활용하는 경우가 많고, 세션은 빠른 읽기/쓰기가 요구되므로 주로 &lt;code>Redis&lt;/code>를 활용합니다.&lt;/p>
&lt;h2 id="pubsub-패턴-적용">Pub/Sub 패턴 적용&lt;/h2>
&lt;p>위처럼 서버 간의 상태를 동기화했다고 하더라도, 웹소켓의 특성상 특정 서버에 연결된 클라이언트에게만 직접 메시지를 전송할 수 있습니다. 다른 서버에 연결된 클라이언트에게는 직접적인 메시지 전송이 불가능한 것이죠.&lt;/p>
&lt;p>이 문제를 해결하기 위해 메시지 브로커를 활용한 Pub/Sub 패턴을 적용할 수 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_4.png"
width="2050"
height="1168"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_4_hu3cc9ed0eaf825475f37e7ff59c7a86c6_734061_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_4_hu3cc9ed0eaf825475f37e7ff59c7a86c6_734061_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Pub/Sub 패턴"
class="gallery-image"
data-flex-grow="175"
data-flex-basis="421px"
>&lt;/p>
&lt;ul>
&lt;li>각 서버는 메시지 브로커(예: Redis, RabbitMQ, Kafka)의 채널을 구독(Subscribe)&lt;/li>
&lt;li>메시지 전송이 필요할 때는 해당 채널에 메시지를 발행(Publish)&lt;/li>
&lt;li>모든 서버가 메시지를 수신하고, 자신에게 연결된 클라이언트에게 필요한 메시지를 전달&lt;/li>
&lt;/ul>
&lt;p>이러한 방식을 통해 서버 간 직접적인 통신 없이도 모든 클라이언트에게 메시지를 전달할 수 있습니다.&lt;/p>
&lt;h2 id="auto-scaling">Auto Scaling&lt;/h2>
&lt;p>리소스를 효율적으로 관리하기 위해, 트래픽에 따라 서버를 동적으로 확장하고 축소하는 것이 이상적입니다.&lt;/p>
&lt;ul>
&lt;li>저희 서비스도 근본적으로는 게임이라서 저녁 시간대에 트래픽이 집중되지 않을까 예상해봅니다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_5.png"
width="560"
height="332"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_5_hu8d0a7bc59b0e5202eca4aab1e4c19efd_27969_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_5_hu8d0a7bc59b0e5202eca4aab1e4c19efd_27969_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Auto Scaling"
class="gallery-image"
data-flex-grow="168"
data-flex-basis="404px"
>&lt;/p>
&lt;p>하지만 웹소켓 서버의 동적 확장 시에는 몇 가지 고려해야 할 문제들이 있습니다.&lt;/p>
&lt;h3 id="서버-추가">서버 추가&lt;/h3>
&lt;p>새로운 서버가 추가되었을 때, 기존 클라이언트들은 이미 다른 서버들과 연결이 되어있는 상태입니다. 이로 인해 새로운 서버는 새로 접속하는 클라이언트의 연결만 받게 되어 서버 간 부하 분산이 균형있게 이루어지지 않을 수 있습니다.&lt;/p>
&lt;p>이를 해결하기 위해서는 다음과 같은 방법들을 고려할 수 있습니다:&lt;/p>
&lt;ul>
&lt;li>연결 재분배 (Connection Rebalancing)
&lt;ul>
&lt;li>주기적으로 서버 간 연결 수를 확인하고 불균형이 발생하면 일부 클라이언트에게 재연결 요청&lt;/li>
&lt;li>클라이언트는 재연결 시 로드밸런서를 통해 새로운 서버에 고르게 분배됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가중치 기반 라우팅
&lt;ul>
&lt;li>새로운 서버에 더 높은 가중치를 부여하여 신규 연결을 더 많이 할당&lt;/li>
&lt;li>점진적으로 서버 간 연결 수가 균형을 이루도록 조정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="서버-제거">서버 제거&lt;/h3>
&lt;p>서버를 제거할 때는 해당 서버에 연결된 클라이언트들의 연결을 적절히 처리해야 합니다. 갑작스러운 연결 종료는 사용자 경험을 해칠 수 있으며, 서비스의 안정성에도 영향을 미칩니다.&lt;/p>
&lt;p>이를 위한 해결 방안으로는:&lt;/p>
&lt;ul>
&lt;li>Draining Mode 구현
&lt;ul>
&lt;li>서버 제거 전에 해당 서버를 &amp;lsquo;draining&amp;rsquo; 상태로 전환&lt;/li>
&lt;li>더 이상 새로운 연결을 받지 않도록 로드밸런서 설정 변경&lt;/li>
&lt;li>기존 연결은 유지하면서 자연스럽게 감소하도록 유도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Graceful Shutdown with Notification
&lt;ul>
&lt;li>종료 예정인 서버의 클라이언트들에게 재연결 필요성을 알리는 메시지 전송&lt;/li>
&lt;li>클라이언트는 메시지 수신 후 다른 서버로 재연결 시도&lt;/li>
&lt;li>일정 시간 후 남아있는 연결을 정상적으로 종료&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="zookeeper">ZooKeeper&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_6.png"
width="921"
height="498"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_6_hu9638b0602de60e14c3a3201684f97ad9_138457_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_6_hu9638b0602de60e14c3a3201684f97ad9_138457_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Apache ZooKeeper"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="443px"
>&lt;/p>
&lt;p>이러한 처리들의 원활한 관리를 위해 서버들의 상태를 효과적으로 관리하고 모니터링하는 것이 중요합니다. Apache ZooKeeper와 같은 도구를 활용하면 이러한 분산 환경에서의 서버 관리를 효율적으로 수행할 수 있습니다.&lt;/p>
&lt;ul>
&lt;li>서버 상태 관리
&lt;ul>
&lt;li>각 서버는 ZooKeeper에 임시 노드(ephemeral node)를 생성하여 자신의 상태를 등록&lt;/li>
&lt;li>서버 장애 시 노드가 자동으로 삭제되어 빠른 장애 감지 가능&lt;/li>
&lt;li>현재 활성화된 서버 목록을 실시간으로 파악 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>부하 분산 정보 공유
&lt;ul>
&lt;li>각 서버의 현재 연결 수, 리소스 사용량 등을 ZooKeeper에 저장&lt;/li>
&lt;li>로드밸런서는 이 정보를 바탕으로 최적의 서버 선택 가능&lt;/li>
&lt;li>동적 가중치 조정에 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>설정 정보 관리
&lt;ul>
&lt;li>서버 구성 정보, 환경 설정 등을 중앙화된 저장소에서 관리&lt;/li>
&lt;li>설정 변경 시 모든 서버에 실시간으로 반영 가능&lt;/li>
&lt;li>일관된 설정 유지 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>Auto Scaling과의 연계&lt;/strong>&lt;/p>
&lt;p>ZooKeeper를 Auto Scaling과 연계하면 더욱 효과적인 서버 관리가 가능합니다:&lt;/p>
&lt;ul>
&lt;li>스케일 인/아웃 이벤트 발생 시 서버 목록 자동 업데이트&lt;/li>
&lt;li>새로운 서버 추가 시 기존 서버들과의 설정 동기화&lt;/li>
&lt;li>서버 제거 시 안전한 종료 절차 조율&lt;/li>
&lt;li>서버 간 부하 분산 상태 모니터링 및 재조정&lt;/li>
&lt;/ul>
&lt;p>이러한 ZooKeeper의 활용은 특히 Auto Scaling 환경에서 서버들의 동적인 변화를 안정적으로 관리하는 데 큰 도움이 될 수 있고, 서버의 추가와 제거가 자주 발생하는 환경에서도 서비스의 안정성과 가용성을 높은 수준으로 유지할 수 있다는 장점도 있습니다.&lt;/p>
&lt;h2 id="정리">정리&lt;/h2>
&lt;p>웹소켓 기반의 실시간 게임 서비스를 확장하면서 발생할 수 있는 문제들과 해결 방안들을 살펴보았습니다.&lt;/p>
&lt;ul>
&lt;li>서버 확장성 문제
&lt;ul>
&lt;li>수평적 확장을 통한 처리량 증가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>상태 관리 문제
&lt;ul>
&lt;li>Redis를 활용한 세션 저장소 외부화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 전달 문제
&lt;ul>
&lt;li>Pub/Sub 패턴 도입&lt;/li>
&lt;li>메시지 브로커를 통한 효율적인 메시지 전파&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>동적 확장 문제
&lt;ul>
&lt;li>서버의 동적 추가, 제거로 인한 문제&lt;/li>
&lt;li>ZooKeeper 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>연결이 유지되는 특성 때문에 발생하는 문제들이 많았네요&lt;/p>
&lt;p>어떤 방식들을 적용해야할지 고민을 더 해봐야겠습니다.&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다😊&lt;/p></description></item><item><title>아키텍처 관점에서 ORM을 사용하는 이유</title><link>https://codemario318.github.io/post/common/architect-orm/</link><pubDate>Sat, 02 Nov 2024 10:11:49 +0900</pubDate><guid>https://codemario318.github.io/post/common/architect-orm/</guid><description>&lt;img src="https://codemario318.github.io/post/common/architect-orm/cover.png" alt="Featured image of post 아키텍처 관점에서 ORM을 사용하는 이유" />&lt;p>안녕하세요😁 오늘은 제가 생각하는 &lt;strong>ORM&lt;/strong>(Object Relational Mapping)을 사용하는 이유에 대한 개인적인 생각을 써보려고 합니다.&lt;/p>
&lt;p>저는 현재 부스트캠프 웹 풀스택 9기 멤버십 과정에 참여중인데, 피어 세션이라던가 스터디 그룹에서 다른 분들과 ORM에 대한 이야기를 할 일이 많았어요&lt;/p>
&lt;p>이야기 나눴던 분들이 말하는 ORM은 아래와 같은 내용이 대부분이었습니다.&lt;/p>
&lt;ul>
&lt;li>ORM은 쿼리 빌더처럼 직접 SQL을 사용하지 않고도 쿼리를 작성해주는 도구이다.&lt;/li>
&lt;li>RDB 테이블을 객체 지향적으로 사용할 수 있게 만들어주는 도구이다.&lt;/li>
&lt;li>일관된 구조를 활용하기 때문에 유지보수가 편리해진다.&lt;/li>
&lt;/ul>
&lt;p>위 처럼 제가 이야기나눴던 분들은 대부분 편의성에 초점을 맞추시는 것 같았어요&lt;/p>
&lt;hr>
&lt;p>조금 깔끔하게 정리해보면 &lt;strong>ORM은 RDB 테이블에 저장된 데이터 조회하여 주요 관심사 단위인 엔티티 객체로 만들기 위해 사용&lt;/strong>됩니다.&lt;/p>
&lt;p>다른 분들이 말씀해주셨던 내용 모두 맞는 말 입니다. 그런데 위에서 언급했던 장점들이 ORM을 사용하는 &lt;strong>본질적인 이유&lt;/strong>일까요?&lt;/p>
&lt;p>이는 사실 ORM을 사용했을 때 &lt;strong>부가적으로 따라오는 장점&lt;/strong>이며 저는 조금 더 근본적인 이유가 바로 &lt;strong>아키텍처&lt;/strong>에 있다고 생각합니다.&lt;/p>
&lt;h2 id="rdbms와-아키텍처">RDBMS와 아키텍처&lt;/h2>
&lt;p>먼저 관계형 데이터베이스가 소프트웨어 아키텍처에 어떤 영향을 주는지 살펴보면 좋을 것 같아요&lt;/p>
&lt;p>아직까지도 관계형 데이터베이스는 웹서비스에서 가장 많이 활용되는 기술입니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/common/architect-orm/img_2.png"
width="866"
height="650"
srcset="https://codemario318.github.io/post/common/architect-orm/img_2_huc333306ede2f54d49d5eff7dc126e0c7_92178_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/common/architect-orm/img_2_huc333306ede2f54d49d5eff7dc126e0c7_92178_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="319px"
>&lt;img src="https://codemario318.github.io/post/common/architect-orm/img_3.png"
width="213"
height="237"
srcset="https://codemario318.github.io/post/common/architect-orm/img_3_hu875005b2d960dbb09b53d1a8c10ff308_9502_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/common/architect-orm/img_3_hu875005b2d960dbb09b53d1a8c10ff308_9502_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="PostgreSQL"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="215px"
>&lt;/p>
&lt;p>관계형 데이터베이스는 데이터를 표(table) 형식으로 구성하여 저장하고, 연관된 데이터는 각 테이블의 관계를 통해 관리할 수 있죠&lt;/p>
&lt;hr>
&lt;p>책 &lt;strong>클린 아키텍처&lt;/strong>에서는 소프트웨어 아키텍처는 세부사항에 의존하면 유연하지 못한 아키텍처가 된다는 것을 항상 강조하고 있습니다.&lt;/p>
&lt;p>&lt;strong>데이터베이스는 세부사항이다&lt;/strong> 단락을 보면 아래와 같은 내용들이 언급됩니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>아키텍처 관점에서 볼 때 &lt;strong>데이터베이스는 엔티티&lt;/strong>가 아니다.&lt;/em>&lt;br>
&lt;em>데이터 모델과는 달리 아키텍처 관점에서는 데이터베이스는 세부사항이라 &lt;strong>아키텍처의 구성 요소 수준으로 끌어올릴 수 없다&lt;/strong>.&lt;/em>&lt;br>
&lt;em>데이터베이스는 &lt;strong>소프트웨어&lt;/strong>일 뿐이며, &lt;strong>데이터에 접근할 방법을 제공하는 유틸리티&lt;/strong>다.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>그리고 아키텍처 관점의 &lt;strong>컴포넌트&lt;/strong>에 대해 중요하게 언급하는데요, &lt;strong>아키텍처 관점의 컴포넌트&lt;/strong>를 설명한다면 아래와 같습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>컴포넌트는 &lt;strong>시스템의 구성 요소로 배포할 수 있는 가장 작은 단위&lt;/strong>다.&lt;/em>&lt;br>
&lt;em>&amp;lt;중략&amp;hellip;&amp;gt;&lt;/em>&lt;br>
&lt;em>컴포넌트가 마지막에 어떤 형태로 배포되든, &lt;strong>잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야한다&lt;/strong>.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>이러한 이유 때문에 &lt;strong>Spring&lt;/strong> 같은 경우는 데이터 저장소에 대한 일관된 처리 추상화한 &lt;code>Spring Data&lt;/code>를 제공합니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이제 위에서 언급한 클린 아키텍처에서 언급했던 컴포넌트 그리고 세부사항을 중심으로 관계형 데이터베이스의 활용을 다시 생각해볼게요&lt;/p>
&lt;p>관계형 데이터베이스에서 외래키로 표현되는 &lt;strong>의존 관계&lt;/strong>는 각 데이터베이스 수준에서 &lt;strong>엔티티간 결합&lt;/strong>이 발생한다는 것을 의미합니다.&lt;/p>
&lt;p>이 때문에 아키텍처 관점에서 &lt;strong>데이터베이스를 사용한다는 것 자체&lt;/strong>와 &lt;strong>엔티티를 기준으로 분리될 수 있는 컴포넌트의 결합&lt;/strong>이 문제가 될 수 있습니다.&lt;/p>
&lt;h2 id="고전적인-처리-방식">고전적인 처리 방식&lt;/h2>
&lt;p>일단 ORM을 활용하지 않는 RDB를 사용하던 방식을 확인해보면 도움이 될 것 같아요&lt;/p>
&lt;p>이전에는 물리적인 제한으로 인해 발생하는 지연(네트워크 오버헤드 등)과 고전적인 SSR 같은 이유로 &lt;strong>페이지&lt;/strong>나 &lt;strong>API 엔드포인트&lt;/strong> 별로 하나의 큰 쿼리(한방 쿼리 라고도 한다고 하네요)를 사용하는 것이 정석이었습니다.&lt;/p>
&lt;p>게시글, 댓글을 예시로 확인해볼까요?&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
User {
int user_id PK
string user_name
}
Post {
int post_id PK
int user_id FK
string post_title
string post_content
}
Reply {
int reply_id PK
int user_id FK
int post_id FK
string reply_content
}
User ||--o{ Post : ""
User ||--o{ Reply : ""
Post ||--o{ Reply : ""
&lt;/pre>
&lt;p>위 테이블 구조에서 고전적인 SSR을 이용하여 게시글 상세 정보를 보여주는 페이지를 렌더링해야 한다고 가정해보겠습니다.&lt;/p>
&lt;ul>
&lt;li>게시글 정보&lt;/li>
&lt;li>게시글 작성자 정보&lt;/li>
&lt;li>댓글 정보&lt;/li>
&lt;li>댓글 작성자 정보&lt;/li>
&lt;li>게시글에 달린 댓글 수&lt;/li>
&lt;li>댓글 페이지네이션&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_title&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_content&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">post_author&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COUNT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply_count&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_content&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply_author&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">post&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">LEFT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">LEFT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="k">limit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">OFFSET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="k">offset&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>아마 위와 같은 쿼리로 모든 데이터를 조회한 후 서비스 로직에서의 처리를 통해 HTML을 그려줬을거에요&lt;/p>
&lt;p>만약 쿼리를 나누고 싶다던가, &lt;code>Ajax&lt;/code>로 댓글 정보만 별도로 불러온다면 &lt;code>reply&lt;/code> 테이블에 대한 조회를 분리할 수 있을겁니다. 아래처럼요!&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_title&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_content&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">author&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">post&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COUNT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply_count&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_content&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply_author&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="k">limit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">OFFSET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="k">offset&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위 예시는 간단한 편 이지만, 실제 운영되는 서비스는 복잡하고 연관된 데이터가 훨씬 많기 때문에 많은 수의 테이블을 &lt;code>JOIN&lt;/code> 해야할 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>이처럼 이전에는 서버와 데이터베이스간 통신 오버헤드, 서버의 응답 처리 방식, 분산 처리의 여러움(하드웨어 비용, 기술 부재) 등으로 인해 쿼리를 작게 나눠 조회하는 것 보다 한번에 조회하는 방식이 성능을 위해 더 좋은 방식으로 여겨졌습니다.&lt;/p>
&lt;p>한번에 조회해야 할 단위가 클라이언트에게 응답해야 할 데이터 전체이므로, 쿼리 자체도 제공해야할 뷰나 API 응답 결과에 종속적이 된다는 문제도 있었어요&lt;/p>
&lt;p>위와 같은 고전적인 방식을 활용할 때, 테이블에 저장되는 데이터가 너무 커져서 데이터베이스를 분리하고 싶다던가, NoSQL로 마이그레이션 하고 싶다던가, &lt;code>MSA&lt;/code>로 변경하여 각각을 독립적으로 운영해야한다면 어떤 문제가 있을까요?&lt;/p>
&lt;p>매우 귀찮고 복잡한 일 이므로, 서비스의 규모가 크다면 작업을 시작하기도 어려울겁니다🥲&lt;/p>
&lt;h2 id="처리-방식의-변화">처리 방식의 변화&lt;/h2>
&lt;p>시간이 흐르면서 하드웨어, 소프트웨어의 발전과 비용 감소 등 여러 이유로 &lt;strong>수평 확장&lt;/strong>이 쉬워지게 되었어요&lt;/p>
&lt;p>필요에 따라 서버를 많이 배포하는 것이 어려운 일이 아니게되었고, 데이터베이스도 많은 수의 &lt;code>Read Replica&lt;/code>를 확보해서 &lt;strong>조회 요청&lt;/strong>에 대한 트래픽에 비교적 쉽게 대응할 수 있게 되었습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/common/architect-orm/img_4.png"
width="640"
height="603"
srcset="https://codemario318.github.io/post/common/architect-orm/img_4_hu22a297eba345d3df949b53c8e2b3a027_170554_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/common/architect-orm/img_4_hu22a297eba345d3df949b53c8e2b3a027_170554_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Scale Out"
class="gallery-image"
data-flex-grow="106"
data-flex-basis="254px"
>&lt;/p>
&lt;p>이러한 이유로 위에서 살짝 보여드린 것 처럼 &lt;strong>커다란 쿼리를 작게 나누는 것&lt;/strong>이 성능 향상에 더 유리하다고 여겨지게 되었어요 &lt;del>쿼리 튜닝도 훨씬 쉬워집니다&lt;/del>&lt;/p>
&lt;p>이전과 달리 다뤄야하는 데이터의 범위와 크기도 작아졌기 때문에 &lt;strong>객체지향적으로 데이터를 관리&lt;/strong>하는 것이 비교적 용이해졌고, 비즈니스 요구사항들을 처리하기 위해 &lt;strong>엔티티 중심으로 설계&lt;/strong>하는 것이 적극적으로 고려되었습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/common/architect-orm/img.png"
width="1000"
height="1432"
srcset="https://codemario318.github.io/post/common/architect-orm/img_hufca2fe698ad69cd2a61645fa2aa0686a_2740195_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/common/architect-orm/img_hufca2fe698ad69cd2a61645fa2aa0686a_2740195_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="엔티티"
class="gallery-image"
data-flex-grow="69"
data-flex-basis="167px"
>&lt;/p>
&lt;p>소프트웨어 아키텍처에서 &lt;strong>엔티티&lt;/strong>(Entity)는 도메인 모델의 핵심 구성 요소로, 시스템이 다루는 중요한 개체 혹은 개념이에요&lt;/p>
&lt;p>조금 더 설명하면 시스템의 도메인에서 고유한 속성과 행동을 가진 데이터 단위로서, 시스템의 주체가되고 주요 비즈니스 로직의 기본 단위입니다.&lt;/p>
&lt;p>앞에서 언급했던 &lt;strong>아키텍처 관점의 컴포넌트&lt;/strong>의 단위가 될 수도 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/common/architect-orm/img_1.png"
width="940"
height="909"
srcset="https://codemario318.github.io/post/common/architect-orm/img_1_hu9b47f7a709a7aa24fdf2e6ddd0a86654_52592_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/common/architect-orm/img_1_hu9b47f7a709a7aa24fdf2e6ddd0a86654_52592_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="레이어드 아키텍처"
class="gallery-image"
data-flex-grow="103"
data-flex-basis="248px"
>&lt;/p>
&lt;p>위 그림은 레이어드 아키텍처의 데이터 흐름을 표현한 것 인데, &lt;code>Business Layer&lt;/code>에서 특정 &lt;strong>비즈니스 로직을 처리하기 위한 주요 속성을 묶은 단위&lt;/strong>(객체 등)를 &lt;strong>엔티티&lt;/strong>라고 표현할 수 있어요&lt;/p>
&lt;h2 id="orm과-아키텍처의-관계">ORM과 아키텍처의 관계&lt;/h2>
&lt;p>여기까지 쓰고나니 조금 돌아온 기분이 드는군요🤣 그래서 ORM과 아키텍처가 무슨 관계냐?!&lt;/p>
&lt;p>위에서 언급했던 내용을 다시 살펴보면 &lt;strong>ORM은 RDB의 데이터를 조회하여 엔티티 객체로 만들어주는 역할&lt;/strong>을 수행하게 되어요&lt;/p>
&lt;p>이 때문에 ORM을 사용하기 위해 &lt;strong>엔티티를 분리&lt;/strong>해야하고, 이는 &lt;strong>관심사에 대한 수직 분해&lt;/strong>가 되었다는 의미이기도 합니다.&lt;/p>
&lt;p>또한 관계형 데이터베이스를 사용한다는 사실은 변하지 않았지만 설정 값으로 특정 데이터베이스를 선택할 수 있는 기능을 제공하므로 어느정도 &lt;strong>수평 분해를 위한 추상화가 되었다&lt;/strong>고 볼 수 있어요&lt;/p>
&lt;p>여기해 더해 레이어드 아키텍처의 예시에서 &lt;code>Persistence Layer&lt;/code> 역할을 하는 계층을 분리했다면, &lt;strong>인터페이스&lt;/strong> 등을 통해 &lt;strong>의존성 역전&lt;/strong>을 활용하여 완전히 다른 유형의 데이터베이스(또는 API 응답)에 대해 거의 완전하게 관심사 분리가 가능해집니다.&lt;/p>
&lt;h2 id="연관-관계-분리">연관 관계 분리&lt;/h2>
&lt;p>연관 관계가 있는 테이블들도 마찬가지로 ORM을 사용하여 관계를 관리해주기 위해 별도 엔티티로 분리해줘야합니다.&lt;/p>
&lt;p>그렇기 때문에 자연스럽게 비즈니스 로직에서의 결합이 낮아지게 되어요&lt;/p>
&lt;p>따라서 완전히 다른 데이터 주체로 변경된다고 하더라도 연관 관계에 있는 엔티티에 변경 내역이 비교적 적어질 것을 기대할 수 있습니다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>그래서 제가 하고싶었던 말을 정리해보면 아래와 같습니다.&lt;/p>
&lt;ul>
&lt;li>ORM을 사용하기 위해서는 비즈니스의 주요 관심사인 엔티티에 대한 분리가 전제되어야한다.&lt;/li>
&lt;li>데이터를 조회 계층 분리를 통해 추상화를 쉽게 적용할 수 있고, 이를 통해 조회 주체에 대한 의존성이 없어진다.&lt;/li>
&lt;li>그러한 이유로 독립적으로 배포 가능한 단위인 아키텍처 관점의 컴포넌트로 분리된다.&lt;/li>
&lt;li>ORM 방식도 여러 문제가 있지만 아키텍처 관점에서 장점이 있기 때문에 계속해서 활용되고 있는 것 같다.&lt;/li>
&lt;/ul>
&lt;p>사실 ORM을 사용해서라기보다는 &lt;strong>&amp;ldquo;좋은 아키텍처를 만들기 위해 개별 배포 가능한 컴포넌트로 관심사를 분리가 필요한데, ORM이 이러한 방향을 추구하고 있고, 어느정도 강제하고 있기 때문에 자연스럽게 좋은 아키텍처를 만든다.&amp;rdquo;&lt;/strong> 가 이 글의 결론이겠네요&lt;/p>
&lt;p>추가로 &lt;strong>&amp;ldquo;ORM 라이브러리는 이러한 아키텍처를 지원하기 위해 사용되는 도구일 뿐이다.&amp;rdquo;&lt;/strong>, &lt;strong>&amp;ldquo;ORM을 사용하지 않더라도(직접 구현하더라도) 관심사를 잘 분리할 수 있는 구조를 만들어야 한다.&amp;rdquo;&lt;/strong> 라는 걸 말씀 드리고 싶었습니다.&lt;/p>
&lt;p>다 쓰고 보니 정말 많이 돌아왔네요&amp;hellip; 쓴게 아까워서 지우진 않겠습니다🤣&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다.&lt;/p></description></item></channel></rss>