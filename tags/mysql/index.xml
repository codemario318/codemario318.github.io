<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MySQL on Mario Blog</title><link>https://codemario318.github.io/tags/mysql/</link><description>Recent content in MySQL on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Tue, 23 May 2023 12:40:10 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/mysql/index.xml" rel="self" type="application/rss+xml"/><item><title>9.2 기본 데이터 처리(1) - ORDER BY 처리 (Using filesort)</title><link>https://codemario318.github.io/post/real_mysql_9_2/</link><pubDate>Tue, 23 May 2023 12:40:10 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_9_2/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_9_2/real_mysql.jpeg" alt="Featured image of post 9.2 기본 데이터 처리(1) - ORDER BY 처리 (Using filesort)" />&lt;p>레코드 1~2건을 가져오는 쿼리를 제외하면 대부분의 &lt;code>SELECT&lt;/code>쿼리에서 정렬은 필수적으로 사용된다. 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 &lt;strong>Filesort&lt;/strong>라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>인덱스 이용&lt;/td>
&lt;td>&lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 쿼리가 실행될 때 이미 인덱스가 정렬 돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다.&lt;/td>
&lt;td>&lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 작업 시 부가적인 인덱스 추가/삭제 작업으로 인해 디스크 공간이 더 많이 필요하다. 인덱스의 개수가 늘어날수록 InnoDB 버퍼풀을 위한 메모리가 많이 필요하다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Filesort 이용&lt;/td>
&lt;td>인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다. 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다.&lt;/td>
&lt;td>정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>레코드를 정렬하기 위해 항상 &lt;strong>Filesort&lt;/strong> 정렬 작업을 거쳐야 하는 것은 아니나, 모든 정렬을 인덱스를 이용하도록 튜닝하는 것은 거의 불가능하다.&lt;/p>
&lt;ul>
&lt;li>정렬 기준이 너무 많아 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우&lt;/li>
&lt;li>&lt;code>GROUP BY&lt;/code>의 결과 또는 &lt;code>DISTINT&lt;/code>같은 처리의 겨로가를 정렬해야 하는 경우&lt;/li>
&lt;li>&lt;code>UNION&lt;/code>의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우&lt;/li>
&lt;li>랜덤하게 결과 레코드를 가져와야 하는 경우&lt;/li>
&lt;/ul>
&lt;p>MySQL 서버에서 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 &lt;strong>Extra&lt;/strong>컬럼에 &lt;strong>Using filesort&lt;/strong> 메시지가 표시되는지 여부로 판단할 수 있다.&lt;/p>
&lt;p>MySQL의 정렬 특성을 이해하면 쿼리를 튜닝할 때 어떠헥 하면 조금이라도 더 빠른 쿼리가 될지 쉽게 판단할 수 있을것이다.&lt;/p>
&lt;h2 id="소트-버퍼">소트 버퍼&lt;/h2>
&lt;p>MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아 사용하는데, 이 메모리 공간을 소트 버퍼라고 한다. 소트 버퍼는 정렬이 필요한 경우에만 할당되며, 버퍼의 크기는 정렬해야 할 레코드의 크기에 다라 가변적으로 증가하지만 최대 사용 가능한 소트 버퍼의 공간은 &lt;code>sort_buffer_size&lt;/code> 시스템 변수로 설정할 수 있다. 소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 스스템으로 반납된다.&lt;/p>
&lt;p>정렬해야할 레코드가 적어 메모리에 할당된 소트 버퍼만으로 정렬할 수 있다면 빠르게 정렬이 처리되지만, 레코드 건수가 소트 버퍼로 할당된 공간보다 크면 정렬해야 할 레코드를 여러 조각으로 나누어 처리하게된다. 이 과정에서 메모리의 소트 버퍼에서 정렬을 수행하고 그 결과를 임시로 디스크에 기록하는 과정을 반복한다. 이처럼 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 하며(멀티 머지, Multi-merge) 수행된 멸티 머지 횟수는 &lt;code>Sort_merge_passes&lt;/code>라는 상태 변수에 누적해서 집계된다. 이러한 작업들이 모두 디스크의 쓰기와 읽기를 유발하게 되어 레코드 건수가 많을수록 반복 작업 횟수도 많아진다.&lt;/p>
&lt;p>소트 버퍼를 크게 설정하면 디스크를 사용하지 않아 더 빨라질 것으로 생각할 수 있지만, 실제 벤치마크 결과로는 큰 차이를 보이지 않는다. 그리고 리눅스 계열의 운영체제에서는 너무 큰 소트 버퍼 크기를 사용하는 경우, 큰 메모리 공간 할당 때문에 성능이 훨씬 떨어질 수 있다.&lt;/p>
&lt;p>또한 소트 버퍼는 세션 메모리 영역을 사용하여 여러 클라이언트가 공유해서 사용할 수 없다. 커넥션이 많을수록, 정렬 작업이 많을수록 소트 버퍼로 소비되는 메모리 공간이 커져 운영체제에서 메모리 부족 현상이 발생할 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>소트 버퍼를 설정해서 빠른 성능을 얻을 수는 없지만 디스크의 읽기와 쓰기 사용량은 줄일 수 있다. 따라서 MySQL 서버의 데이터가 많거나 디스크 I/O 성능이 낮은 장비라면 소트 버퍼의 크기를 더 크게 설정하는 것이 도움이 될 수도 있다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="정렬-알고리즘">정렬 알고리즘&lt;/h2>
&lt;p>레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라 &lt;strong>싱글 패스, Single-pass&lt;/strong>와 &lt;strong>투 패스, Two-pass&lt;/strong> 2가지 정렬 모드로 나눌 수 있다.&lt;/p>
&lt;p>정렬을 수행하는 쿼리가 어떤 정렬 모드를 사용하는지는 다음과 같이 옵티마이저 트레이스 기능으로 확인할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OPTIMIZER_TRACE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;enabled=on&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">END_MARKERS_IN_JSON&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">on&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OPTIMIZER_TRACE_MAX_MEM_SIZE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1000000&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">last_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">100000&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">INFORMATION_SCHEMA&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">OPTIMIZER_TRACE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="k">G&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>마지막 쿼리 실행 후 출력된 내용에서 &amp;ldquo;filesort_summary&amp;rdquo; 섹션의 &amp;ldquo;sort_algorithm&amp;rdquo; 필드에 정렬 알고리즘이 표시되고, &amp;ldquo;sort_mode&amp;rdquo; 필드에는 3가지 정렬 방식중 하나가 표시된다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>&amp;lt;sort_key, rowid&amp;gt;&lt;/code>: 정렬 키와 레코드의 로우 아이드만 가져와서 정렬하는 방식&lt;/li>
&lt;li>&lt;code>&amp;lt;sort_key, additional_fields&amp;gt;&lt;/code>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 컬럼들은 고정 사이즈로 메모리에 저장&lt;/li>
&lt;li>&lt;code>&amp;lt;sort_key, packed_additional_fields&amp;gt;&lt;/code>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 컬럼들은 가변 사이즈로 메모리 저장&lt;/li>
&lt;/ul>
&lt;p>여기서는 첫 번째 방식을 &lt;strong>투 패스&lt;/strong>정렬 방식이라 명명하고, 나머지 방식을 &lt;strong>싱글 패스&lt;/strong>정렬 방식이라고 명명하겠다. 세 번째 방식은 MySQL 5.7 버전부터 도입됐는데, 이는 정렬을 위한 메모리 공간의 효율적인 사용을 위해 추가 도입된 방식이다.&lt;/p>
&lt;h3 id="싱글-패스-정렬-방식">싱글 패스 정렬 방식&lt;/h3>
&lt;p>소트 버퍼에 정렬 기준 컬럼을 포함해 &lt;code>SELECT&lt;/code> 대상이 되는 컬럼 전부를 담아 정렬을 수행하는 방식이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_9_2/img.png"
width="776"
height="462"
srcset="https://codemario318.github.io/post/real_mysql_9_2/img_hu7ba9783b8b9dc18b0295061f72b59865_163286_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_9_2/img_hu7ba9783b8b9dc18b0295061f72b59865_163286_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="167"
data-flex-basis="403px"
>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">emp_no&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">last_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위 쿼리와 같이 &lt;code>first_name&lt;/code>으로 정렬해서 &lt;code>emp_no&lt;/code>, &lt;code>first_name&lt;/code>, &lt;code>last_name&lt;/code>을 &lt;code>SELECT&lt;/code>하는 쿼리를 싱글 패스 정렬 방식으로 처리하게 되면, 처음 employees 테이블을 읽을 때 정렬에 필요하지 않는 &lt;code>last_name&lt;/code> 컬럼까지 전부 읽어 소트 버퍼에 담고 정렬을 수행한다. 그리고 정렬이 완료되면 정렬 버퍼의 내용을 그대로 클라이언트로 넘겨준다.&lt;/p>
&lt;h3 id="투-패스-정렬-방식">투 패스 정렬 방식&lt;/h3>
&lt;p>정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 &lt;code>SELECT&lt;/code>할 컬럼을 가져오는 정렬 방식으로, 싱글 패스 정렬 방식이 도입되기 이전부터 사용하던 방식이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_9_2/img_1.png"
width="787"
height="555"
srcset="https://codemario318.github.io/post/real_mysql_9_2/img_1_hu74a11d1b0b3686c1814ecb3f55fd39f2_199453_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_9_2/img_1_hu74a11d1b0b3686c1814ecb3f55fd39f2_199453_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="340px"
>&lt;/p>
&lt;p>처음 &lt;code>employees&lt;/code> 테이블을 읽을 때는 정렬에 필요한 &lt;code>first_name&lt;/code>컬럼과 프라이머리 키인 &lt;code>emp_no&lt;/code>만 읽어서 정렬을 수행한다. 이 정렬이 완료되면 그 결과 순서대로 &lt;code>employees&lt;/code> 테이블을 한번 더 읽어서 &lt;code>last_name&lt;/code>을 가져오고, 최종적으로 그 결과를 클라이언트 쪽으로 넘기는 과정을 확인할 수 있다.&lt;/p>
&lt;h3 id="정리">정리&lt;/h3>
&lt;p>MySQL 예전 정렬 방식인 투 패스 방식은 테이블을 두 번 읽어야 하기 때문에 상당히 불합히하지만, 새로운 정렬 방식인 싱글 패스는 이러한 불합리가 없다. 하지만 싱글 패스 정렬 방식은 더 많은 소트 버퍼 공간이 필요하다.&lt;/p>
&lt;p>최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주로 사용하지만 경우에 따라 투 패스 정렬 방식을 이용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>레코드의 크기가 &lt;code>max_length_for_sort_data&lt;/code> 시스템 변수에 설정된 값보다 클 때&lt;/li>
&lt;li>BLOB이나 TEXT 타입의 컬럼이 &lt;code>SELECT&lt;/code> 대상에 포함할 때&lt;/li>
&lt;/ul>
&lt;p>싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보이며, 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이라고 볼 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>SELECT&lt;/code> 쿼리에서 꼭 필요한 컬럼만 조회하지 않고, 모든 컬럼을 가져오도록 개발하는 경우가 많은데, ㅇ리는 정렬 버퍼를 몇 배에서 몇십 배 까지 비효율 적으로 사용할 가능성이 크므로 정렬이 필요한 &lt;code>SELECT&lt;/code>는 불필요한 컬럼을 포함하지 않게 쿼리를 작성하는 것이 효율적이다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="정렬-처리-방법">정렬 처리 방법&lt;/h2>
&lt;p>쿼리에 &lt;code>ORDER BY&lt;/code>가 사용되면 반드시 다음 3가지 처리 방법 중 하나로 정렬이 처리된다. 일반적으로 아래쪽에 있는 정렬 방법으로 갈수록 처리 속도는 떨어진다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>정렬 처리 방법&lt;/th>
&lt;th>실행 계획 Extra 컬럼 내용&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>인덱스를 사용한 정렬&lt;/td>
&lt;td>별도 표기 없음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>조인에서 드라이빙 테이블만 정렬&lt;/td>
&lt;td>&amp;ldquo;Using filesort&amp;rdquo;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>조인에서 조인 결과를 임시 테이블로 저장 후 정렬&lt;/td>
&lt;td>&amp;ldquo;Using temporary; Using filesort&amp;rdquo;&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>옵티마이저는 정렬 처리를 위해 인덱스를 이용할 수 있을지 검토하는데, 사용할 수 있다면 &amp;ldquo;filesort&amp;rdquo; 과정 없이 인덱스를 순서대로 읽어 반환한다. 하지만 인덱스를 사용할 수 없다면 &lt;code>WHERE&lt;/code> 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리한다.&lt;/p>
&lt;p>이때 MySQL 옵티마이저는 정렬 대상 레코드를 최소화 하기 위해 다음 2가지 방법 중 하나를 선택한다.&lt;/p>
&lt;ul>
&lt;li>조인의 드라이빙 테이블만 정렬한 다음 조인을 수행&lt;/li>
&lt;li>조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행&lt;/li>
&lt;/ul>
&lt;p>일반적으로 조인이 수행되면서 레코드 건수와 레코드의 크기는 거의 배수로 불어나기 때문에 가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 방법이 효율적이다. 그래서 두 번째 방법보다는 첫 번째 방버버이 더 효율적으로 처리된다.&lt;/p>
&lt;h3 id="인덱스를-이용한-정렬">인덱스를 이용한 정렬&lt;/h3>
&lt;ul>
&lt;li>인덱스를 이용한 정렬을 위해서는 반드시 &lt;code>ORDER BY&lt;/code>에 명시된 컬럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, &lt;code>ORDER BY&lt;/code>의 순서대로 생성된 인덱스가 있어야 한다.&lt;/li>
&lt;li>&lt;code>WHERE&lt;/code>절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 &lt;code>ORDER BY&lt;/code>는 같은 인덱스를 사용할 수 있어야 한다.&lt;/li>
&lt;li>B-Tree 계열의 인덱스가 아닌 해시 인덱스나 전문 검색 인덱스 등에서는 인덱스를 이용한 정렬을 사용할 수 없다. (R-Tree 인덱스 불가)&lt;/li>
&lt;li>여러 테이블이 조인되는 경우에는 네스티드-루프(Nested-loop) 방식의 조인에서만 사용할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>인덱스를 이용해 정렬이 처리되는 경우에는 실제 인덱스의 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 되어 MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행하지는 않는다.&lt;/p>
&lt;p>하지만 조인이 사용된 쿼리의 실행 계획에 조인 버퍼가 사용되면 순서가 흐트러 질 수 있으므로 주의해야 한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>ORDER BY&lt;/code> 절을 넣지 않아도 자동으로 정렬되므로 &lt;code>ORDER BY&lt;/code> 자체를 쿼리에서 제거하기도 하지만, MySQL 서버는 정렬을 인덱스로 처리할 수 있는 경우 부가적으로 불필요한 정렬 작업을 수행하지 않기 때문에 &lt;code>ORDER BY&lt;/code>가 쿼리에 명시된다고 해서 작업량이 늘지는 않는다. 그리고 알 수 없는 이유로 실행 계획이 조금 변경된다면, 기대했던 순서대로 결과를 가져오지 못해 버그로 연결될 수 있으므로 &lt;code>ORDER BY&lt;/code> 절을 명시하는 것이 좋다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="조인의-드라이빙-테이블만-정렬">조인의 드라이빙 테이블만 정렬&lt;/h3>
&lt;p>일반적으로 조인이 수행되면 결과 레코드의 건수가 몇 배로 불어나고, 레코드 하나의 크기도 늘어나기 때문에 조인을 실행하기 전 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책이다. 이러한 방법으로 정렬이 처리되려면 조인에서 첫 번째로 읽히는 테이블(드라이빙 테이블)의 컬럼만으로 &lt;code>ORDER BY&lt;/code> 절을 작성해야 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">salaries&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emp_no&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emp_no&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emp_no&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BETWEEN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">100002&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">100010&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">last_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>WHERE&lt;/code> 절의 조건으로 인해 옵티마이저는 &lt;code>employees&lt;/code> 테이블을 드라이빙 테이블로 선택한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>WHERE&lt;/code> 절의 검색조건 &lt;code>emp_no&lt;/code>는 &lt;code>employees&lt;/code> 테이블의 파리이머리 키를 이용해 검색하면 작업량을 줄일 수 있다.&lt;/li>
&lt;li>드리븐 테이블의 조인 컬럼인 &lt;code>emp_no&lt;/code> 컬럼에 인덱스가 있다.&lt;/li>
&lt;/ul>
&lt;p>검색은 인덱스 레인지 스캔으로 처리할 수 있지만 &lt;code>ORDER BY&lt;/code> 절에 명시된 컬럼은 &lt;code>employees&lt;/code> 테이블의 프라이머리 키와 전혀 연관이 없으므로 인덱스를 이용한 정렬은 불가능하지만, 정렬 기준 컬럼이 드라이빙 테이블에 포함된 컬럼이므로 옵티마이저는 드라이빙 테이블만 검색해서 정렬을 먼저 수행하고, 그 결과와 &lt;code>salaries&lt;/code> 테이블을 조인하는 방식을 선택한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_9_2/img_2.png"
width="742"
height="597"
srcset="https://codemario318.github.io/post/real_mysql_9_2/img_2_hu848bd5ebfe4cf90ecee74647ec1cf9e6_233875_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_9_2/img_2_hu848bd5ebfe4cf90ecee74647ec1cf9e6_233875_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="124"
data-flex-basis="298px"
>&lt;/p>
&lt;ol>
&lt;li>인덱스를 이용해 &lt;code>BETWEEN&lt;/code> 조건을 만족하는 데이터 검색&lt;/li>
&lt;li>검색 결과를 &lt;code>last_name&lt;/code> 컬럼으로 정렬을 수행(Filesort)&lt;/li>
&lt;li>정렬된 결과를 순서대로 읽으며 &lt;code>sqlaries&lt;/code> 테입르과 조인을 수행해 최종 결과를 가져옴&lt;/li>
&lt;/ol>
&lt;h3 id="임시-테이블을-이용한-정렬">임시 테이블을 이용한 정렬&lt;/h3>
&lt;p>쿼리가 여러 테이블을 조인하지 않고, 하나의 테이블로 부터 &lt;code>SELECT&lt;/code>해서 정렬하는 경우라면 임시 테이블이 필요하지 않지만, 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수 있다.&lt;/p>
&lt;p>&amp;ldquo;조인 드라이빙 테이블만 정렬&amp;quot;하는 경우라면 2개 이상의 테이블이 조인되면서 정렬이 실행되지만 임시 테이블을 사용하지 않는다. 하지만 그 외 패턴의 쿼리에서는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다. 따라서 이 방법은 정렬 3가지 방식 중 정렬해야 할 레코드 건수가 가장 많기 때문에 가장 느리다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">salaries&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emp_no&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emp_no&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emp_no&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BETWEEN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">100002&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">100010&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">salary&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>table&lt;/th>
&lt;th>type&lt;/th>
&lt;th>key&lt;/th>
&lt;th>Extra&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>e&lt;/td>
&lt;td>range&lt;/td>
&lt;td>PRIMARY&lt;/td>
&lt;td>Using where; Using temporary; Using filesort&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>s&lt;/td>
&lt;td>ref&lt;/td>
&lt;td>PRIMARY&lt;/td>
&lt;td>NULL&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>쿼리 실행 계획 &amp;ldquo;Extra&amp;quot;컬럼에 &amp;ldquo;Using where; Using temporary; Using filesort&amp;quot;코멘트가 표시되는데, 이는 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬 처리했음을 의미한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_9_2/img_3.png"
width="706"
height="708"
srcset="https://codemario318.github.io/post/real_mysql_9_2/img_3_hue96011af0d56e981814f7fcadbfc8c3d_233651_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_9_2/img_3_hue96011af0d56e981814f7fcadbfc8c3d_233651_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="99"
data-flex-basis="239px"
>&lt;/p>
&lt;h3 id="정렬-처리-방법의-성능-비교">정렬 처리 방법의 성능 비교&lt;/h3>
&lt;p>주로 웹 서비스용 쿼리에서는 &lt;code>ORDER BY&lt;/code>와 함께 &lt;code>LIMIT&lt;/code>이 거의 필수로 사용되는 경우가 많은데, 일반적으로 &lt;code>LIMIT&lt;/code>은 테이블이나 처리 결과의 일부만 가져오기 때문에 MySQL 서버가 처리해야 할 작업량을 줄이는 역할을 한다.&lt;/p>
&lt;p>하지만 &lt;code>ORDER BY&lt;/code>, &lt;code>GROUP BY&lt;/code> 같은 작업은 &lt;code>WHERE&lt;/code> 족너을 만족하는 레코드를 &lt;code>LIMIT&lt;/code> 건수 만큼만 가져와서는 처리할 수 없고, 우선 조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그루핑 작업을 실행해야만 처리할 수 있다. 이로 인해 &lt;code>WHERE&lt;/code> 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 잘못된 &lt;code>ORDER BY&lt;/code>, &lt;code>GROUP BY&lt;/code> 때문에 쿼리가 느려지는 경우가 많이 발생한다.&lt;/p>
&lt;h4 id="스트리밍-방식">스트리밍 방식&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_9_2/img_4.png"
width="587"
height="342"
srcset="https://codemario318.github.io/post/real_mysql_9_2/img_4_hu54316a551e24229225ba558a713cce1e_55710_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_9_2/img_4_hu54316a551e24229225ba558a713cce1e_55710_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="171"
data-flex-basis="411px"
>&lt;/p>
&lt;p>서버 쪽에서 처리할 데이터가 얼마인지에 관계 없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전성해주는 방식으로, 클라이언트는 쿼리를 요청하고 곧바로 원했던 첫 번째 레코드를 전달받는다. (마지막 레코드는 언제 받을지 알 수 없다.)&lt;/p>
&lt;p>쿼리가 스트리빙 방식으로 처리될 수 있다면 클라이언트는 MySQL 서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터의 가공 작업을 시작할 수 있다. 웹서비스 같은 OLTP 환경에서는 쿼리의 요청에서 첫 번째 레코드를 전달받게 되기까지의 응답 시간이 중요한 경우가 많은데, 스트리빙 방식으로 처리되는 쿼리는 쿼리가 얼마나 많은 레코드를 조회하느냐에 상관없이 빠른 응답 시간을 보장해준다.&lt;/p>
&lt;p>또한 스트리밍 방식으로 처리되는 쿼리에서 &lt;code>LIMIT&lt;/code> 처럼 결과 건수를 제한하는 조건들은 풀 테이블 스캔의 결과가 아무런 버퍼링 처리나 필터링 과정 없이 바로 클라이언트로 스트리밍 되기 때문에 쿼리의 전체 실행 시간을 상당히 줄여줄 수 있다.&lt;/p>
&lt;h4 id="버퍼링-방식">버퍼링 방식&lt;/h4>
&lt;p>&lt;code>ORDER BY&lt;/code>, &lt;code>GROUP BY&lt;/code> 같은 처리는 &lt;code>WHERE&lt;/code> 조건에 일치하는 모든 레코드를 가져온 후, 정렬하거나 그루핑해서 차례대로 보내야 하므로 쿼리의 결과가 스트리밍되는 것이 불가능하다.&lt;/p>
&lt;p>또한 버퍼링 방식으로 처리되는 쿼리는 먼저 결과를 모아서 MySQL 서버에서 일괄 가옹해야 하므로 모든 결과를 스토리지 엔진으로부터 가져올 때가지 기다려야 한다. 따라서 &lt;code>LIMIT&lt;/code> 처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 별로 도움이 되지 않는다.&lt;/p>
&lt;hr>
&lt;p>정렬 처리 방버에서 소개한 &lt;code>ORDER BY&lt;/code>의 3가지 처리 방법 가운데 인덱스를 사용한 정렬 방식만 스트리밍 형태의 처리이며, 나머지는 모두 버퍼링된 후에 정렬된다. 즉 인덱스를 사용한 정렬 방식은 &lt;code>LIMIT&lt;/code>로 제한된 건수만큼만 읽으면서 바로 클라이언트로 결과를 전송해 줄 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> tb_test1의 레코드는 100건
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> tb_test2 테이블의 레코드가 1000건
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> (tb_test1의 레코드 1건당 tb_test2의 레코드가 10건씩 존재함)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tb_test1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tb_test2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">col1&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">t2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">col1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">col2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>&lt;code>tb_test1&lt;/code>가 드라이빙되는 경우&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>정렬 방법&lt;/th>
&lt;th>읽어야 할 건수&lt;/th>
&lt;th>조인 횟수&lt;/th>
&lt;th>정렬해야 할 대상 건수&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>인덱스 사용&lt;/td>
&lt;td>tb_test1: 1건, tb_test2: 10건&lt;/td>
&lt;td>1번&lt;/td>
&lt;td>0건&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>조인의 드라이빙 테이블만 정렬&lt;/td>
&lt;td>tb_test1: 100건, tb_test2: 10건&lt;/td>
&lt;td>1번&lt;/td>
&lt;td>100건(tb_test1 테이블의 레코드 건수 만큼 정렬 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>임시 테이블 사용 후 정렬&lt;/td>
&lt;td>tb_test1: 100건, tb_test2: 1000건&lt;/td>
&lt;td>100번&lt;/td>
&lt;td>1000건(조인된 결과 레코드 건수를 모두 정렬해야함)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>&lt;code>tb_test2&lt;/code>가 드라이빙되는 경우&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>정렬 방법&lt;/th>
&lt;th>읽어야 할 건수&lt;/th>
&lt;th>조인 횟수&lt;/th>
&lt;th>정렬해야 할 대상 건수&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>인덱스 사용&lt;/td>
&lt;td>tb_test2: 10건, tb_test1: 10건&lt;/td>
&lt;td>10번&lt;/td>
&lt;td>0건&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>조인의 드라이빙 테이블만 정렬&lt;/td>
&lt;td>tb_test2: 1000건, tb_test1: 1건&lt;/td>
&lt;td>10번&lt;/td>
&lt;td>1000건(tb_test2 테이블의 레코드 건수 만큼 정렬 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>임시 테이블 사용 후 정렬&lt;/td>
&lt;td>tb_test2: 1000건, tb_test2: 100건&lt;/td>
&lt;td>1000번(tb_test2 테이블의 레코드 건수만큼 조인 발생)&lt;/td>
&lt;td>1000건(조인된 결과 레코드 건수를 모두 정렬해야함)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>어느 테이블이 먼저 조인되는지도 중요하지만 어떤 정렬 방식으로 처리되는지는 더 큰 성능 차이를 만든다. 가능하다면 인덱스를 사용한 정렬로 유도하고, 그렇지 못하다면 최소한 드라이빙 테입르만 정렬해도 되는 수준으로 유도하는 것도 좋은 튜닝 방법이라고 할 수 있다.&lt;/p>
&lt;h2 id="정렬-관련-상태-변수">정렬 관련 상태 변수&lt;/h2>
&lt;p>MySQL 서버는 처리하는 주요 작업에 대해서는 해당 작업의 실행 횟수를 상태 변수로 저장한다. 정려로가 관련해서도 지금까지 몇 건의 레코드나 정렬 처리를 수행했는지, 소트 버퍼 간의 병합 작업(멀티 머지)은 몇 번이나 발생했는지 등을 다음과 같은 명령으로 확인해 볼 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FLUSH&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Sort%&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;code>Sort_merge_passes&lt;/code>: 멀티 머지 처리 횟수&lt;/li>
&lt;li>&lt;code>Sort_range&lt;/code>: 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수(누적)&lt;/li>
&lt;li>&lt;code>Sort_rows&lt;/code>: 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수(누적)&lt;/li>
&lt;li>&lt;code>Sort_rows&lt;/code>: 지금까지 정렬한 전체 레코드 건수&lt;/li>
&lt;/ul></description></item><item><title>9.2 기본 데이터 처리(2) - GROUP BY 처리</title><link>https://codemario318.github.io/post/real_mysql_9_2/</link><pubDate>Tue, 23 May 2023 12:40:10 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_9_2/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_9_2/real_mysql.jpeg" alt="Featured image of post 9.2 기본 데이터 처리(2) - GROUP BY 처리" /></description></item><item><title>9. 옵티마이저와 힌트 (1)</title><link>https://codemario318.github.io/post/real_mysql_9_1/</link><pubDate>Mon, 22 May 2023 16:09:10 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_9_1/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_9_1/real_mysql.jpeg" alt="Featured image of post 9. 옵티마이저와 힌트 (1)" />&lt;p>MySQL 서버로 요청된 쿼리는 결과는 동일하지만 내부적으로 그 결과를 만들어내는 방법은 매우 다양하며, 어떤 방법이 최적이고 최소의 비용이 소모될지 결정해야 한다. MySQL 옵티마이저는 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하며, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립한다.&lt;/p>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>어떤 DBMS든지 쿼리의 실행 계획을 수립하는 옵티마이저는 가장 복잡한 부분으로 알려져 있으며, 옵티마이저가 만들어 내는 실행 계획을 이해하는 것 또한 상당히 어려운 부분이다. 하지만 실행 계획을 이해할 수 있어야만 실행 계획의 불합리한 부분을 찾아내고, 더 최적화된 방법으로 실행 계획을 수립하도록 유도할 수 있다.&lt;/p>
&lt;h3 id="실행-절차">실행 절차&lt;/h3>
&lt;p>MySQL 서버에서 쿼리가 실행되는 과정은 크게 세 단계로 나눌 수 있다.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>SQL 파싱&lt;/strong>: 사용자로부터 요청된 SQL 문장을 잘게 쪼개어 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
&lt;ul>
&lt;li>&lt;strong>SQL 파서&lt;/strong>라는 모듈로 처리한다. 이때 문법적으로 잘못된다면 걸러진다. 이 단계에서 &lt;strong>SQL 파스 트리&lt;/strong>가 만들어지고, MySQL 서버는 SQL 문장 자체가 아닌 파스 트리를 이용해 쿼리를 실행한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>최적화 및 실행 계획 수립&lt;/strong>: MySQL 옵티마이저에 의해 SQL의 파싱 정보(파스 트리)를 확인하며 어떤 테이블 부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
&lt;ul>
&lt;li>불필요한 조건 제거 및 복잡한 연산 단순화&lt;/li>
&lt;li>여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정&lt;/li>
&lt;li>각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정&lt;/li>
&lt;li>가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>두 번째 단계에서 결정된 테이블의 일기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.&lt;/li>
&lt;/ol>
&lt;p>두 번째 단계가 완료되면 쿼리의 실행 계획이 만들어지며, 세 번째 단계에서 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고, MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.&lt;/p>
&lt;h3 id="옵티마이저의-종류">옵티마이저의 종류&lt;/h3>
&lt;p>옵티마이저는 데이터베이스 서버에서 두뇌와 같은 역할을 담당한다. 옵티마이저는 현재 대부분의 DBMS가 선택하고 있는 비용 기반 최적화(Cost-based optimizer, CBO) 방법과 예전 초기 버전의 오라클 DMBS에서 많이 사용했던 규칙 기반 최적화 방법(Rule-based optimizer, RBO)로 나눌 수 있다.&lt;/p>
&lt;ul>
&lt;li>RBO: 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식을 의미한다.
&lt;ul>
&lt;li>통계 정보(테이블의 레코드 건수나 컬럼 값의 분포도)를 조사하지 않고 실행 계획이 수립되기 때문에 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어 낸다.&lt;/li>
&lt;li>사용자의 데이터는 분포도가 매우 다양하기 때문에 규칙 기반의 최적화는 이미 오래전부터 사용되지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CBO: 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.
&lt;ul>
&lt;li>산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>규칙 기반 최적화는 각 테이블이나 인덱스의 통계 정보가 거의 없고 상대적으로 느린 CPU 연산 탓에 비용 계산 과정이 부담스럽다는 이유로 사용되는 최적화 방법이다. 현재는 MySQL을 포함한 대부분의 RDBMS가 비용 기반의 옵티마이저를 채택하고 있다.&lt;/p>
&lt;p>MySQL 서버를 포함한 모든 RDBMS는 데이터를 정렬하거나 그루핑하는 등 기본 데이터 가공 기능을 가지고 있다. 하지만 결과물은 동일하더라도 RDBMS 별로 그 결과를 만들어 내는 과정은 천차만별이다.&lt;/p>
&lt;h2 id="풀-테이블-스캔과-풀-인덱스-스캔">풀 테이블 스캔과 풀 인덱스 스캔&lt;/h2>
&lt;ul>
&lt;li>풀 테이블 스캔: 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어 요청된 작업을 처리하는 작업을 의미한다.
&lt;ul>
&lt;li>테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것 보다 풀 테이블 스캔을 하는 편이 더 빠른경우(테이블이 페이지 1개로 구성된 경우)&lt;/li>
&lt;li>&lt;code>WHERE&lt;/code> 절이나 &lt;code>ON&lt;/code> 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우&lt;/li>
&lt;li>인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스 B-Tree를 샘플링해서 조사한 통계 정보 기준)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>일반적으로 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요하다. 그래서 대부분 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다.&lt;/p>
&lt;p>하지만 MySQL에는 풀 테이블 스캔을 실행할 때 한꺼번에 몇 개씩 테이블을 읽어올지 설정하는 시스템 변수는 없다. 그래서 많은 사람들이 MySQL은 풀 테이블 스캔을 실행할 때 디스크로부터 페이지를 하나씩 읽어 오는 것으로 생각하지만 InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업이 자동으로 시작되며, 이를 통해 요청이 오기 전에 미리 디스크에서 필요할 데이터를 예측하여 읽어 버퍼불에 가저다둔다.&lt;/p>
&lt;p>즉, 풀 테이블 스캔이 실행되면 처음 몇개의 데이터 페이지는 포그라운드 스레드(Foreground thread, 클라이언트 스레드)가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다.&lt;/p>
&lt;p>백그라운드 스레드가 읽기를 넘겨받는 시점부터는 한번에 4개 또는 8개씩 페이지를 읽그면서 계속 그 수를 증가시키고, 한 번에 최대 64개의 데이터 페이지가지 읽어 버퍼풀에 저장해둔다. 포그라운드 스레드는 미리 버퍼풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 빠르게 처리된다.&lt;/p>
&lt;p>MySQL 서버에서는 &lt;code>innodb_read_ahead_threshold&lt;/code> 시스템 변수를 이용해 InnoDB 스토리지 엔진이 언제 리드 어헤드를 시작할지 임계값을 설정할 수 있다. 포그라운드 스레드에 의해 시스템 변수에 설정된 개수만큼의 연속된 데이터 페이지가 읽히면 InnoDB 스토리지 엔진은 백그라운드 스레드를 이용해 대량으로 그 다음 페이지들을 읽어서 버퍼풀로 적재한다. 일반적으로 기본 설정으로 충분하지만 데이터 웨어하우스용으로 MySQL을 사용한다면 이 옵션을 더 낮은 값으로 설정하여 더 빨리 리드 어헤드가 시작되게 유도하는 것도 성능을 향상시킬 수 있다.&lt;/p>
&lt;p>리드 어헤드는 풀 인덱스 스캔에서도 동일하게 사용된다.&lt;/p>
&lt;h2 id="병렬-처리">병렬 처리&lt;/h2>
&lt;p>MySQL 8.0 버전부터는 용도가 한정돼 있긴 하지만 쿼리 병렬 처리가 가능해졌다.&lt;/p>
&lt;blockquote>
&lt;p>여기서 말하는 병렬 처리는 하나의 쿼리를 여러 스레드가 나누어 동시에 처리한다는 것을 의미한다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>innodb_parallel_read_threads&lt;/code> 시스템 변수를 이용해 하나의 쿼리를 최대 몇개의 스레드를 이용해서 처리할지를 변경할 수 있다. 아직 MySQL 서버에서는 쿼리를 여러 개의 스레드를 이용해 병렬로 처리하게 하는 힌트나 옵션은 없으며, 아무런 &lt;code>WHERE&lt;/code>조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SESSION&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_parallel_read_threads&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="err">{&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COUNT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">salaries&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>병렬 처리용 스레드 개수가 늘어날수록 쿼리 처리에 걸리는 시간이 대체로 줄어들지만, 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수도 있으니 주의가 필요하다.&lt;/p></description></item><item><title>8. 인덱스 (4)</title><link>https://codemario318.github.io/post/real_mysql_8_4/</link><pubDate>Sun, 14 May 2023 19:24:10 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_8_4/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_8_4/real_mysql.jpeg" alt="Featured image of post 8. 인덱스 (4)" />&lt;h2 id="함수-기반-인덱스">함수 기반 인덱스&lt;/h2>
&lt;p>일반적인 인덱스는 컬럼의 값 일부(걸럽의 값 앞부분) 또는 전체에 대해서만 인덱스 생성이 허용되지만, 컬럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축해야 하는 경우도 있는데, 이러한 경우 함수 기반 인덱스를 활용할 수 있다.&lt;/p>
&lt;p>MySQL 서버의 함수 기반 인덱스는 인덱싱할 값을 계산하는 과정의 차이만 있을 뿐, 실제 인덱스의 내부적인 구조 및 유지 관리 방법은 B-Tree 인덱스와 동일하다.&lt;/p>
&lt;h3 id="가상-컬럼을-이용한-인덱스">가상 컬럼을 이용한 인덱스&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">BIGINT&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">last_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이전 버전의 MySQL은 해당 테이블에서 &lt;code>first_name&lt;/code>과 &lt;code>last_name&lt;/code>을 합쳐 검색해야 하는 요건이 생겼다면 &lt;code>full_name&lt;/code>이라는 컬럼을 추가하고 모든 레코드에 대해 해당 컬럼을 업데이트 하는 작업을 거처야 인덱스를 생성 할 수 있었다.&lt;/p>
&lt;p>하지만 MySQL 8.0 버전 부터는 가상 컬럼을 추가하고 해당 가상 컬럼에 인덱스를 생성할 수 있게 됐다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">ADD&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">full_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">30&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">CONCAT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">last_name&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">VIRTUAL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">ADD&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ix_fullname&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">full_name&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>가상 컬럼이 &lt;code>VIRTUAL&lt;/code>, &lt;code>STORED&lt;/code> 옵션 중 어떤 옵션으로 생성됐든 관계 없이 해당 가상 컬럼에 인덱스를 생성할 수 있다. 가상 컬럼은 테이블에 새로운 컬럼을 추가하는 것과 같은 효과를 내기 때문에 실제 테이블의 구조가 변경된다는 단점이 있다.&lt;/p>
&lt;h3 id="함수를-이용한-인덱스">함수를 이용한 인덱스&lt;/h3>
&lt;p>가상 컬럼은 MySQL 5.7 버전에서도 사용할 수 있었지만 함수를 직접 인덱스 생성 구문에 사용할 수는 없었다. 하지만 MySQL 8.0 버전 부터는 테이블 구조를 변경하지 않고, 함수를 직접 사용하는 인덱스를 생성할 수 있게 됐다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">BIGINT&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">last_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ix_fullname&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">CONCAT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">last_name&lt;/span>&lt;span class="p">)))&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>함수를 직접 사용하는 인덱스는 테이블의 구조는 변경하지 않고, 계산된 결괏값의 검색을 빠르게 만들어준다. 함수 기반 인덱스를 제대로 활용하려면 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용돼야 한다. 함수 생성 시 명시된 표현식과 쿼리의 &lt;code>WHERE&lt;/code> 조건절에 사용된 표현식이 다르다면 결과가 같다고 하더라도 MySQL 옵티마이저는 다른 표현식으로 간주해서 함수 기반 인덱스를 사용하지 못한다.&lt;/p>
&lt;blockquote>
&lt;p>가상 컬럼과 함수를 직접 이용하는 인덱스는 사용법과 문법에서 조금 차이가 있지만, 내부적으로 동일한 구현 방법을 사용하므로 어떤 방법을 사용하더라도 둘의 성능 차이는 발생하지 않는다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="멀티-밸류-인덱스">멀티 밸류 인덱스&lt;/h2>
&lt;p>전문 검색 인덱스를 제외한 모든 인덱스는 레코드 1건이 1개의 인덱스 키 값을 가지는 1:1 관계이다. 하지만 멀티 밸류 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스다. 일반적인 RDBMS를 기준으로 생각하면 이러한 인덱스는 정규화에 위배되는 형태이지만, 최근 RDBMS들이 JSON 데이터 타입을 지원하기 시작하면서 JSON의 배열 타입의 필드에 저장된 원소들에 대한 인덱스 요건이 발생한 것이다.&lt;/p>
&lt;p>JSON 포맷으로 데이터를 저장하는 MongoDB는 처음부터 이런 형태의 인덱스를 지원하고 있었지만 MySQL 서버는 멀티 밸류 인덱스에 대한 지원 없이 JSON 타입의 컬럼만 지원했다. 하지만 배열 형태에 대한 인덱스 생성이 되지 않아 MongoDB의 기능과 많이 비교되곤 했다.&lt;/p>
&lt;p>MySQL 8.0 버전으로 업그레이드되면서 JSON 관리 기능은 MongoDB에 비해서도 부족함이 없는 상태로 발전했다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">BIGINT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">AUTO_INCREMENT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">last_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">credit_info&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">JSON&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">imx_creditscores&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="k">CAST&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">credit_info&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="s1">&amp;#39;$.credit_scores&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">UNSIGNED&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">ARRAY&lt;/span>&lt;span class="p">)))&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;mario&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;lee&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;{&amp;#34;credit_scores&amp;#34;:[360, 353, 351]}&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>멀티 밸류 인덱스를 활용하기 위해서는 일반적인 조건 방식을 사용하면 안 되고, 반드시 다음 함수들을 이용해서 검색해야 옵티마이저가 인덱스를 활용한 실행 계획을 수립한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>MEMBER OF()&lt;/code>&lt;/li>
&lt;li>&lt;code>JSON_CONTAINS()&lt;/code>&lt;/li>
&lt;li>&lt;code>JSON_OVERLAPS()&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">360&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MEMBER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">OF&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">credit_info&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="s1">&amp;#39;$.credit_scores&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>MySQL 서버의 Worklog에는 &lt;code>DECIMAL&lt;/code>, &lt;code>INTEGER&lt;/code>, &lt;code>DATETIME&lt;/code>, &lt;code>VARCHAR/CHAR&lt;/code> 타입에 대해 멀티 밸류 인덱스를 지원한다고 명시돼 있지만 MySQL 8.0.21 버전에서는 &lt;code>VARCHAR/CHAR&lt;/code> 타입에 대해서는 지원하지 않는다. 하지만 곧 &lt;code>VARCHAR/CHAR&lt;/code>타입의 배열 형태 &lt;code>CAST&lt;/code>와 멀티 밸류 인덱스가 지원될 것으로 예상된다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="클러스터링-인덱스">클러스터링 인덱스&lt;/h2>
&lt;p>MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것(프라이머리 키를 기준으로)들끼리 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안되었다. MySQL에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원한다.&lt;/p>
&lt;h3 id="클러스터링-인덱스-1">클러스터링 인덱스&lt;/h3>
&lt;p>클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다. 즉 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현한다.&lt;/p>
&lt;p>따라서 프라이머리 키 값에 의해 레코드에 저장 위치가 결정되며, 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것을 의미한다.&lt;/p>
&lt;p>프라이머리 키 값으로 클러스터링 된 테이블은 프라이머리 키 값 자체에 대한 의존도가 상당히 크기 때문에 신중히 프라이머리 키를 결정해야한다.&lt;/p>
&lt;p>클러스터링 인덱스는 프라이커리 키 값에 의해 레코드의 저장 위치가 결정되므로 인덱스 알고리즘이라기 보다는 테이블 레코드의 저장 방식이라고 볼 수 있다, 그래서 클러스터링 인덱스와 클러스터링 테이블은 동의어로 사용되기도 한다. 일반적으로 InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반 검색이 매우 빠르며, 대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_8_4/img.png"
width="677"
height="472"
srcset="https://codemario318.github.io/post/real_mysql_8_4/img_hu0f5f38116678265441d9dcf98671fa4d_130453_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_8_4/img_hu0f5f38116678265441d9dcf98671fa4d_130453_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="143"
data-flex-basis="344px"
>&lt;/p>
&lt;p>클러스터링 인덱스 구조를 보면 클러스터링 테이블의 구조 자체는 일반 B-Tree와 비슷하다. 하지만 세컨더리 인덱스를 위한 B-Tree의 리프 노드와는 달리 클러스터링 인겟스의 리프 노드에는 레코드의 모든 컬럼이 같이 저장돼 있음을 알 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">UPDATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tb_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">emp_no&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">10002&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">emp_no&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">10007&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_8_4/img_1.png"
width="678"
height="552"
srcset="https://codemario318.github.io/post/real_mysql_8_4/img_1_hu896e1a2cf10a15f621e482a8890a1f26_151848_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_8_4/img_1_hu896e1a2cf10a15f621e482a8890a1f26_151848_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="122"
data-flex-basis="294px"
>&lt;/p>
&lt;p>프라이머리 키가 없는 InnoDB 테이블에서는 InnoDB 스토리지 엔진이 다음 우선순위대로 프라이머리 키를 대체할 컬럼을 선택한다.&lt;/p>
&lt;ol>
&lt;li>프라이머리 키가 있다면 기본적으로 프라이머리 키를 클러스터링 키로 선택&lt;/li>
&lt;li>NOT NULL옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택&lt;/li>
&lt;li>자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터링 키로 선택&lt;/li>
&lt;/ol>
&lt;p>InnoDB 스토리지 엔진이 적절한 클러스터링 키 후보를 찾지 못하는 경우 InnoDB 스토리지 엔진이 내부적으로 레코드의 일련번호 컬럼을 생성하는데, 자동으로 추가된 프라이머리 키는 사용자에게 노출되지 않으며, 쿼리 문장에 명시적으로 사용할 수 없다. 즉 프라이머리 키나 유니크 인덱스가 전혀 없는 InnoDB 테이블에서는 아무 의미 없는 숫자 값으로 클러스터링되어 사용자에게 아무런 혜택도 주지 않는다.&lt;/p>
&lt;p>따라서 InnoDB 테이블에서 클러스터링 인덱스는 테이블당 단 하나만 가질수 있는 엄청난 혜택이므로 가능하다면 프라이머리 키를 명시적으로 생성하는 것이 좋다.&lt;/p>
&lt;h3 id="세컨더리-인덱스에-미치는-영향">세컨더리 인덱스에 미치는 영향&lt;/h3>
&lt;p>MyISAM이나 MEMORY 테이블 같은 클러스터링되지 않은 테이블은 INSERT될 때 처음 저장된 공간에서 절대 이동하지 않는다. 데이터 레코드가 저장된 주소는 내부적인 레코드 아이디(ROWID) 역할을 하며, 프라이머리 키나 세컨더리 인덱스의 각 키는 그 주소를 이용해 실제 데이터를 찾아오기 때문에 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다.&lt;/p>
&lt;p>InnoDB는 클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 한다. 이런 오버헤드를 제거하기 위해 InnoDB 테이블(클러스터링 테이블)의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아닌 프라이머리 키 값을 저장하도록 구현돼 있다.&lt;/p>
&lt;p>InnoDB가 MyISAM보다 조금 더 복잡하게 처리되지만, InnoDB테이블에서 프라이머리 키는 더 큰 장점을 제공하기 때문에 성능 저하에 대해 걱정하지 않아도 된다.&lt;/p>
&lt;h3 id="클러스터링-인덱스의-장점과-단점">클러스터링 인덱스의 장점과 단점&lt;/h3>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>프라이머리 키로 검색할 때 처리 성능이 매우 빠름(특히, 프라이머리 키를 범위 검색하는 경우 매우 빠름)&lt;/li>
&lt;li>테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 잇는 경우가 많음(커버링 인덱스)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러시터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐&lt;/li>
&lt;li>세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림&lt;/li>
&lt;li>&lt;code>INSERT&lt;/code>할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림&lt;/li>
&lt;li>프라이머리 키를 변경할 때 레코드를 &lt;code>DELETE&lt;/code>하고 &lt;code>INSERT&lt;/code> 하는 작업이 필요하기 때문에 처리 성능이 느림&lt;/li>
&lt;/ul>
&lt;p>일반적으로 웹 서비스와 같은 온라인 트랜잭션 환경에서는 쓰기와 읽기 비율이 2:8, 1:9 정도이기 때문에 조금 느린 쓰기를 감수하고 읽기를 빠르게 유지하는 것은 매우 중요하다.&lt;/p>
&lt;h3 id="클러스터링-테이블-사용-시-주의사항">클러스터링 테이블 사용 시 주의사항&lt;/h3>
&lt;h4 id="클러스터링-인덱스-키의-크기">클러스터링 인덱스 키의 크기&lt;/h4>
&lt;p>클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키(클러스터링 키) 값을 포함한다. 그래서 프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커진다. 하지만 일반적으로 테이블에 세컨더리 인덱스가 4~5개 정도 생성된다는 것을 고려하며 ㄴ세컨더리 인덱스 크기는 급격히 증가한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">프라이머리 키의 크기&lt;/th>
&lt;th style="text-align:center">레코드당 증하가하는 인덱스 크기&lt;/th>
&lt;th style="text-align:center">100만 건 저장 시 증가하는 인덱스 크기&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">10바이트&lt;/td>
&lt;td style="text-align:center">10 바이트 * 5 = 50 바이트&lt;/td>
&lt;td style="text-align:center">50바이트 * 1,000,000 = 47MB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">50바이트&lt;/td>
&lt;td style="text-align:center">50 바이트 * 5 = 250 바이트&lt;/td>
&lt;td style="text-align:center">250바이트 * 1,000,000 = 238MB&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>레코드 한 건을 생각하면 커 보이지 않을 수 있으나 레코드 건수가 100만 건만 돼도 인덱스의 크기가 거의 190MB나 증가한다. 또한 인덱스가 커질수록 같은 성능을 내기 위해 그만큼의 메모리가 더 필요해지므로 InnoDB 테이블의 프라이머리 키는 신중하게 선택해야 한다.&lt;/p>
&lt;h4 id="프라이머리-키는-auto-increment-보다는-업무적인-컬럼으로-생성가능하면">프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 컬럼으로 생성(가능하면)&lt;/h4>
&lt;p>InnoDB의 프라이머리 키는 클러스터링 키로 사용되며, 이 값에 의해 레코드의 위치가 결정된다. 즉 프라이머리 키로 검색하는 경우 클러스터링 되지않은 테이블에 비해 매우 빠르게 처리될 수 있음을 의미한다. 프라이머리 키는 의미만큼이나 중요한 역할을 하기 때문에 대부분 검색에서 상당히 빈번하게 사용되는 것이 일반적이다. 그러므로 설령 컬럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 컬럼을 프라이머리 키로 설정하는 것이 좋다.&lt;/p>
&lt;h4 id="프라이머리-키는-반드시-명시할-것">프라이머리 키는 반드시 명시할 것&lt;/h4>
&lt;p>가능하면 &lt;code>AUTO_INCREMENT&lt;/code>컬럼을 이용해서라도 프라이머리 키는 생성하는 것을 권장한다. InnoDB에서 프라이머리 키를 정의하지 않으면 스토리지 엔진이 내부적으로 일련번호 컬럼을 추가하지만 사용자는 전혀 접근할 수 없으므로&lt;code>AUTO_INCREMENT&lt;/code> 컬럼을 생성하고 프라이머리 키로 설정하여 사용자가 활용할 수 있는 값으로 사용하는 것이 좋다. 또한 ROW 기반 복제나 InnoDB Cluster에서는 모든 테이블이 프라이머리 키를 가져야만 정상적인 복제 성능을 보장하기도 하므로 프라이머리 키는 꼭 생성해야 한다.&lt;/p>
&lt;h4 id="auto-increment-컬럼을-인조-식별자로-사용할-경우">AUTO-INCREMENT 컬럼을 인조 식별자로 사용할 경우&lt;/h4>
&lt;p>여러 개의 컬럼이 복합으로 프라이머리 키가 만들어지는 경우 프라이머리 키의 크기가 길어질 때가 가끔 있는데, 프라이머리 키의 크기가 길어도 세컨더리 인덱스가 필요하지 않다면 그대로 프라이머리 키를 사용하는 것이 좋다. 세컨더리 인덱스도 필요하고 프라이머리 키의 크기도 길다면 &lt;code>AUTO_INCREMENT&lt;/code>컬럼을 추가하고 이를 프라이머리 키로 설정한다.&lt;/p>
&lt;p>이렇게 프라이머리 키를 대체하기 위해 인위적으로 추가된 프라이머리 키를 인조 식별자(Surrogate key)라고 한다. 그리고 로그 테입르과 같이 조회보다는 &lt;code>INSERT&lt;/code> 위주의 테이블들은 &lt;code>AUTO_INCREMENT&lt;/code>를 이용한 인조 식별자를 프라이머리 키로 설정하는 것이 성능 향상에 도움이 된다.&lt;/p>
&lt;h2 id="유니크-인덱스">유니크 인덱스&lt;/h2>
&lt;p>유니크는 인덱스라기보다는 제약 조건에 가깝다. 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미하는데, MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다.&lt;/p>
&lt;p>유니크 인덱스에서 NULL도 저장될 수 있는데, NULL은 특정 값이 아니므로 2개 이상 저장될 수 있다. MySQL에서 프라이머리 키는 기본적으로 NULL을 허용하지 않는 유니크 속성이 자동으로 부여된다.&lt;/p>
&lt;h3 id="유니크-인덱스와-일반-세컨더리-인덱스의-비교">유니크 인덱스와 일반 세컨더리 인덱스의 비교&lt;/h3>
&lt;p>유니크 인덱스와 유니크하지 않은 일반 세컨더리 인덱스는 인덱스 구조상 아무런 차이점이 없다. 하지만 읽기와 쓰기에 대해 성능적으로 다른 부분이 있다.&lt;/p>
&lt;h4 id="인덱스-읽기">인덱스 읽기&lt;/h4>
&lt;p>많은 사람들이 유니크 인덱스가 빠르다고 생각하지만, 유니크하지 않은 세컨더리 인덱스에서 한 번 더 해야 하는 작업은 디스크 읽기가 아니라 CPU에서 컬럼 값을 비교하는 작업이기 때문에 성능상 영향이 거의 없다.&lt;/p>
&lt;p>유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린것이지, 인덱스 자체의 특성 때문에 느린 것이 아니다.&lt;/p>
&lt;p>하나의 값을 검색하는 경우, 유니크 인덱스와 일반 세컨더리 인덱스는 사용되는 실행 계획이 다르다. 하지만 이는 인덱스의 성격이 유니크한지 아닌지에 따른 차이일 뿐 큰 차이는 없다.&lt;/p>
&lt;h4 id="인덱스-쓰기">인덱스 쓰기&lt;/h4>
&lt;p>새로운 레코드가 &lt;code>INSERT&lt;/code> 되거나 인덱스 컬럼의 값이 변경되는 경우에는 인덱스 쓰기 작업이 필요하다. 그런데 유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요하다. 그래서 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다.&lt;/p>
&lt;p>MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데, 이 과정에서 데드락이 아주 빈번히 발생한다.&lt;/p>
&lt;p>또한 InnoDB 스토리지 엔진에는 인덱스 키의 저장을 버퍼링 하기 위해 체인지 버퍼(Change Buffer)를 사용하여 인덱스의 저장이나 변경 작업이 상당히 빨리 처리되지만, 유니크 인덱스는 반드시 중복 체크를 해야하므로 작업 자체를 버퍼링 하지 못한다. 이 때문에 유니크 인덱스는 일반 세컨더리 인덱스보다 변경 작업이 더 느리다.&lt;/p>
&lt;h3 id="유니크-인덱스-사용시-주의사항">유니크 인덱스 사용시 주의사항&lt;/h3>
&lt;ul>
&lt;li>꼭 필요한 경우라면 유니크 인덱스를 생성하는 것은 당연하나, 성능이 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 생성하지는 않는 것이 좋다.&lt;/li>
&lt;li>하나의 테이블에서 같은 컬럼에 유니크 인덱스와 일반 인덱스를 각각 중복해서 생성해 둔 경우가 가끔 있는데, 같은 역할을 하므로 중복해서 인ㄷ게스를 생성할 필요는 없다.&lt;/li>
&lt;li>똑같은 컬럼에 대해 프라이머리 키와 유니크 인덱스를 동일하게 생성하는 경우도 있는데 이 또한 중복이다.&lt;/li>
&lt;/ul>
&lt;p>결론적으로 유일성이 꼭 보장되어야 하는 컬럼에 대해서는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 유니크 인덱스 보다는 유니크하지 않은 세컨더리 인덱스를 생성하는 방법도 한 번씩 고려해보자.&lt;/p>
&lt;h2 id="외래키">외래키&lt;/h2>
&lt;p>MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있으며, 외래키 제약이 설정되면 자동으로 연관되는 테이블의 컬럼에 인덱스까지 생성된다. 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.&lt;/p>
&lt;p>InnoDB의 외래키 관리에는 중요한 두 가지 특징이 있다.&lt;/p>
&lt;ul>
&lt;li>테이블 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.&lt;/li>
&lt;li>외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경함(잠금 대기)를 발생시키지 않는다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tb_parant&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">InnoDB&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tb_child&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DEFAULT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DEFAULT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ix_parentid&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">CONSTRAINT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">child_ibfk_1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FOREIGN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">REFERENCES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tb_parant&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DELETE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">CASCADE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">InnoDB&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tb_parant&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;p1&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;p2&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tb_child&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;c100&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="자식-테이블의-변경이-대기하는-경우">자식 테이블의 변경이 대기하는 경우&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>작업 번호&lt;/th>
&lt;th>커넥션-1&lt;/th>
&lt;th>커넥션-2&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>BEGIN;&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>UPDATE tb_parent &lt;!-- raw HTML omitted -->SET fb=&amp;lsquo;changed-2&amp;rsquo; &lt;!-- raw HTML omitted -->WHERE id=2;&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>&lt;/td>
&lt;td>BEGIN;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>&lt;/td>
&lt;td>UPDATE tb_child &lt;!-- raw HTML omitted -->SET pid=2 &lt;!-- raw HTML omitted -->WHERE id=100;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>ROLLBACK;&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>&lt;/td>
&lt;td>Query OK, 1 row affected&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>2번 커넥션 는 부모 테이블의 변경 작업이 완료될 때까지 대기한다. 1번 커넥션에서 트랜잭션이 종료하면 2번 커넥션의 대기중이던 작업이 즉시 처리되는 것을 확인할 수 있다. 즉 자식 테이블의 외래 키 컬럼의 변경은 부모 테이블의 확인이 필요한데, 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려있으면 해당 쓰기 잠금이 해제될 때까지 기다리게 된다.&lt;/p>
&lt;p>자식 테이블의 외래키가 아닌 컬럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않는다.&lt;/p>
&lt;h3 id="부모-테이블의-변경-작업이-대기하는-경우">부모 테이블의 변경 작업이 대기하는 경우&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>작업 번호&lt;/th>
&lt;th>커넥션-1&lt;/th>
&lt;th>커넥션-2&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>BEGIN;&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>UPDATE tb_child &lt;!-- raw HTML omitted -->SET fb=&amp;lsquo;changed-100&amp;rsquo; &lt;!-- raw HTML omitted -->WHERE id=100;&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>&lt;/td>
&lt;td>BEGIN;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>&lt;/td>
&lt;td>DELETE FROM tb_parent &lt;!-- raw HTML omitted -->WHERE id=1;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>ROLLBACK;&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>&lt;/td>
&lt;td>Query OK, 1 row affected&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>1번 커넥션에서 부모 키를 참조하는 자식 테이블의 레코드를 변경하면 tb_child 테이블의 레코드에 대해 쓰기 잠금을 획득한다. 이 상태에서 2번 커넥션이 부모 테이블에서 해당 부모 레코드를 삭제하는 경우 이 쿼리는 자식 테이블의 레코드에 대한 쓰기 잠금이 해제될 때까지 기대려야 한다. 이는 자식 테이블이 생성될 때 적용된 외래키의 특성(&lt;code>ON DELETE CASCADE&lt;/code>) 때문에 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제되는 식으로 작동하기 때문이다.&lt;/p>
&lt;blockquote>
&lt;p>데이터베이스에서 외래 키를 물리적으로 생성하려면 이러한 현상으로 인한 잠금 경합까지 고려해 모델링을 진행하는 것이 좋다.&lt;br>
물리적으로 외래키를 생성하면 자식 테이블에 레코드가 추가되는 경우 해당 참조키가 부모 테이블에 있는지 확인하는데, 물리적인 외래키의 고려 사항은 이러한 체크 작업이 아니라 이러한 체크를 위해 연관 테이블에 읽기 잠금을 걸어야 한다는 점이다.&lt;br>
이렇게 잠금이 다른 테이블로 확장되면 그만큼 전체적으로 쿼리의 동시 처리에 영향을 미친다.&lt;/p>
&lt;/blockquote></description></item><item><title>8. 인덱스 (3) - 전문 검색 인덱스</title><link>https://codemario318.github.io/post/real_mysql_8_3/</link><pubDate>Sun, 14 May 2023 17:24:10 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_8_3/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_8_3/real_mysql.jpeg" alt="Featured image of post 8. 인덱스 (3) - 전문 검색 인덱스" />&lt;p>문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문(Full Text) 검색에는 InnoDB나 MyISAM 스토리지 엔진에서 제공하는 일반적인 용도의 B-Tree 인덱스를 사용할 수 없다.&lt;/p>
&lt;p>문서 전체에 대한 분석과 검색을 위한 인덱싱 알고리즘을 전문 검색(Full Text Search) 인덱스라고 하는데, 전문 검색 인덱스는 일반화된 기능의 명칭으로 알고리즘의 이름을 지칭하는 것은 아니다.&lt;/p>
&lt;h2 id="인덱스-알고리즘">인덱스 알고리즘&lt;/h2>
&lt;p>전문 검색에서는 문서 본문의 내용에서 사용자가 검색하게 될 키워드를 분석하고, 빠른 검색용으로 사용할 수 있게 이러한 키워드로 인덱스를 구축한다. 키워드의 분석 및 인덱스 구축에는 여러 가지 방법이 있을 수 있다.&lt;/p>
&lt;p>전문 검색 인덱스는 문서의 키워드를 인덱싱하는 기법에 따라 구분될 수 있다.&lt;/p>
&lt;ul>
&lt;li>어근 분석 알고리즘&lt;/li>
&lt;li>n-gram 알고리즘&lt;/li>
&lt;/ul>
&lt;h2 id="어근-분석-알고리즘">어근 분석 알고리즘&lt;/h2>
&lt;p>MySQL 서버의 전문 검색 인덱스는 다음과 같은 두 가지 중요한 과정을 거쳐서 색인 작업이 수행된다.&lt;/p>
&lt;ul>
&lt;li>불용어(Stop Word)처리
&lt;ul>
&lt;li>검색에서 별 가치가 없는 단어를 모두 필터링해서 제거하는 작업을 의미&lt;/li>
&lt;li>불용어의 개수가 많지 않기 때문에 알고리즘을 구현한 코드에 상수로 정의해 사용하는 경우가 많다.&lt;/li>
&lt;li>유연성을 위해 불용어 자체를 데이터베이스화해서 사용자가 추가하거나 삭제할 수 있게 구현하는 경우도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>어근 분석(Stemming)
&lt;ul>
&lt;li>검색어로 선정된 단어의 뿌리인 원형을 찾는 작업이다.&lt;/li>
&lt;li>MySQL 서버는 오픈소스 형태소 분석 라이브러리인 MeCab을 플러그인 형태로 사용할 수 있게 지원한다.&lt;/li>
&lt;li>한글이나 일본어의 경우 영어와 같이 단어의 변형 자체는 거의 없기 때문에 어근분석보다는 문장의 형태소를 분석해서 명사와 조사를 구분하는 기능이 더 중요한 편이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="n-gram-알고리즘">n-gram 알고리즘&lt;/h2>
&lt;p>MeCab을 위한 형태소 분석은 매우 전문적인 전문 검색 알고리즘이어서 만족할 만한 결과를 내기 위해서는 많은 노력과 시간을 필요로 한다. 전문적인 검색 엔진을 고려하는 것이 아니라면 범용적으로 적용하기는 쉽지 않기 때문에 이러한 단점을 보완하기 위한 방법으로 n-gram 알고리즘이 도입되었다.&lt;/p>
&lt;p>n-gram이란 본문을 무조건 몇 글자씩 잘라서 인덱싱하는 방법이다. 형태소 분석보다는 알고리즘이 단순하고 국가별 언어에 대한 이해와 준비 작업이 필요 없는 반면, 만들어진 인덱스의 크기는 상당히 큰 편이다. n은 인덱싱할 키워드의 최소 글자 수를 의미하는데, 일반적으로는 2글자 단위로 키워드를 쪼개서 인덱싱하는 2-gram(Bi-gram) 방식이 많이 사용된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">To be or not to be. That is the question
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>각 단어는 띄어쓰기와 마침표를 기준으로 10개의 단어로 구분되고, 2글자씩 중첩해서 토큰으로 분리된다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>단어&lt;/th>
&lt;th>bi-gram 토큰&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>To&lt;/td>
&lt;td>To&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>be&lt;/td>
&lt;td>be&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>or&lt;/td>
&lt;td>or&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>not&lt;/td>
&lt;td>no ot&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>to&lt;/td>
&lt;td>to&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>be&lt;/td>
&lt;td>be&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>that&lt;/td>
&lt;td>Th ha at&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>is&lt;/td>
&lt;td>is&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>the&lt;/td>
&lt;td>th he&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>question&lt;/td>
&lt;td>qu ue es st ti io on&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>각 글자가 중첩되어 토큰화 되기 때문에 Bi-gram 알고리즘에서는 &lt;code>글자수 - 1&lt;/code>개의 토큰으로 구분된다. 이렇게 구분된 토큰을 인덱스에 저장한다. 이때 중복된 토큰은 하나의 인덱스 엔트리로 병합되어 저장한다.&lt;/p>
&lt;p>MySQL 서버는 이렇게 생성된 토큰들에 대해서 불용어를 걸러내는 작업을 수행하는데, 이때 불용어와 동일하거나 불용어를 포함하는 경우 걸러서 버린다. 기본적으로 MySQL 서버에 내장된 불용어는 &lt;code>information_schema.innodb_ft_default_stopword&lt;/code> 테이블을 통해 확인 가능하다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">입력&lt;/th>
&lt;th style="text-align:center">불용어 일치&lt;/th>
&lt;th style="text-align:center">불용어 포함&lt;/th>
&lt;th style="text-align:center">출력(최종 인덱스 등록)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">at&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">O&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">be&lt;/td>
&lt;td style="text-align:center">O&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">be&lt;/td>
&lt;td style="text-align:center">O&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">es&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">et&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ha&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">O&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">he&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">he&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">he&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">io&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">O&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">is&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">O&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">no&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">no&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">on&lt;/td>
&lt;td style="text-align:center">O&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">or&lt;/td>
&lt;td style="text-align:center">O&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ot&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">ot&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">qu&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">qu&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">st&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">st&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Th&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">Th&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">th&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">th&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ti&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">O&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">To&lt;/td>
&lt;td style="text-align:center">O&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">to&lt;/td>
&lt;td style="text-align:center">O&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ue&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">ue&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>전문 검색을 더 빠르게 하기 위해 2단계 인덱싱(프론트엔드와 백엔드 인덱스)과 같은 방법도 있지만 MySQL 서버는 구분된 토큰을 단순한 B-Tree 인덱스에 저장한다.&lt;/p>
&lt;h3 id="불용어-변경-및-삭제">불용어 변경 및 삭제&lt;/h3>
&lt;p>n-gram의 토큰 파싱 및 불용어 처리 예시 결과를 보면 &amp;ldquo;ti&amp;rdquo;, &amp;ldquo;at&amp;rdquo;, &amp;ldquo;ha&amp;rdquo; 같은 토큰들은 &amp;ldquo;a&amp;rdquo;, &amp;ldquo;i&amp;rdquo; 철자가 불용어로 등록돼 있기 때문에 모두 걸러진다. 실제로 이 같은 불용어 처리는 사용자에게 도움이 되기보다는 사용자를 더 혼란스럽게 하는 기능일 수도 있다. 그래서 불용어 처리 자체를 완전히 무시하거나 MySQL 서버에 내장된 불용어 대신 사용자가 직접 불용어를 등록하는 방법을 권장한다.&lt;/p>
&lt;p>&lt;strong>전문 검색 인덱스의 불용어 처리 무시&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>스토리지 엔진과 관계 없이 MySQL 서버의 모든 전문 검색 인덱스에 대해 불용어를 완전히 제거한다.
&lt;ul>
&lt;li>MySQL 서버의 설정 파일(my.cnf)의 &lt;code>ft_storpword_file&lt;/code> 시스템 변수에 빈 문자열을 설정한다.&lt;/li>
&lt;li>해당 시스템 변수는 서버가 재시작될 때만 인지하기 때문에 설정 변경시 서버를 재시작해야 반영된다.&lt;/li>
&lt;li>사용자 정의 불용어를 적용할 때도 해당 파일 경로를 적용하여 반영할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>InnoDB 스토리지 엔진을 사용하는 테이블의 전문 검색 인덱스에 대해서만 불용어 처리 무시
&lt;ul>
&lt;li>&lt;code>innodb_ft_enable_stopword&lt;/code> 시스템 변수를 &lt;code>OFF&lt;/code>로 설정한다.&lt;/li>
&lt;li>해당 시스템 변수는 동적인 시스템 변수이므로 서버가 실행 중인 상태에서도 변경할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>사용자 정의 불용어 사용&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>불용어 목록을 파일로 저장하고, MySQL 서버 설정파일에서 파일의 경로를 &lt;code>ft_stopword_file&lt;/code> 설정에 등록한다.&lt;/li>
&lt;li>InnoDB 스토리지 엔진을 사용하는 테이블의 전문 검색 엔진에만 사용할 수 있는데, &lt;code>innodb_ft_server_stopword_table&lt;/code> 시스템 변수에 불용어 테이블을 설정한다.
&lt;ul>
&lt;li>이때 불용어 목록을 변경한 이후 전문 검색 인덱스가 생성돼야만 변경된 불용어가 적용된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_stopword&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">30&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">INNODB&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_stopword&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;MySQL&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_ft_server_stopword_table&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;mydb/my_stopword&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tb_bi_gram&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">ADD&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FULLTEXT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fx_title_body&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">title&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">body&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WITH&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PARSER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ngram&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>innodb_ft_user_stopword_table&lt;/code> 시스템 변수를 이용하는 방법도 있으며, &lt;code>innodb_ft_server_stopword_table&lt;/code>와 사용법이 동일하다. 여러 전문 검색 인덱스가 서로 다른 불용어를 사용해야 하는 경우에 활용할 수 있다.&lt;/p>
&lt;h3 id="전문-검색-엔진-인덱스의-가용성">전문 검색 엔진 인덱스의 가용성&lt;/h3>
&lt;p>전문 검색 인덱스를 사용하려면 반드시 2가지 조건을 만족해야 한다.&lt;/p>
&lt;ul>
&lt;li>쿼리 문장이 전문 검색을 위한 문법(&lt;code>MATCH ... AGAINST&lt;/code>)을 사용&lt;/li>
&lt;li>테이블이 전문 검색 대상 컬럼에 대해서 전문 인덱스 보유&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tb_test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">doc_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">doc_body&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">TEXT&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">doc_id&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">FULLTEXT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fx_docbody&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">doc_body&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WITH&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PARSER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ngram&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">InnoDB&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 풀 테이블 스캔으로 처리되는 쿼리
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tb_test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">doc_body&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;%애플%&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 전문 검색 인덱스로 처리되는 쿼리
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tb_test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">MATCH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">doc_body&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">AGAINST&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;애플&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">IN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">BOOLEAN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">MODE&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>전문 검색 인덱스를 사용하려면 반드시 &lt;code>MATCH ... AGAINST ...&lt;/code>구문으로 검색 쿼리를 작성해야 하며, 인덱스를 구성하는 컬럼들은 &lt;code>MATCH&lt;/code>절의 괄호 안에 모두 명시되어야 한다.&lt;/p></description></item><item><title>8. 인덱스 (2) - B-Tree 인덱스</title><link>https://codemario318.github.io/post/real_mysql_8_2/</link><pubDate>Sun, 07 May 2023 17:24:10 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_8_2/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_8_2/real_mysql.jpeg" alt="Featured image of post 8. 인덱스 (2) - B-Tree 인덱스" />&lt;p>B-Tree는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입되었지만 아직까지도 가장 범용적으로 사용되는 인덱스 알고리즘이다.&lt;/p>
&lt;p>B-Tree에는 여러 변형된 형대의 알고리즘이 있는데, 일반적으로 DMBS에서는 B+-Tree, B*-Tree가 사용된다.&lt;/p>
&lt;p>B-Tree는 컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다. 전문 검색같은 특수한 요건이 아닌 경우, 대부분 인덱스는 B-Tree를 사용한다.&lt;/p>
&lt;h2 id="구조-및-특성">구조 및 특성&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_8_2/img_1.png"
width="1168"
height="884"
srcset="https://codemario318.github.io/post/real_mysql_8_2/img_1_hu251c6ae64d7d90de5696088b141275a8_1856492_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_8_2/img_1_hu251c6ae64d7d90de5696088b141275a8_1856492_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="B-Tree 인덱스의 구조"
class="gallery-image"
data-flex-grow="132"
data-flex-basis="317px"
>&lt;/p>
&lt;p>B-Tree는 트리 구조의 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태이다. 트리 구조의 가장 하위에 있는 노드를 리프 노드라 하고, 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간 노드를 브랜치 노드라고 한다.&lt;/p>
&lt;p>데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가진다.&lt;/p>
&lt;p>인덱스의 키 값은 모두 정렬돼 있지만, 데이터 파일릐 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다. 레코드가 삭제되어 빈 공간이 생기면 그다음 &lt;code>INSERT&lt;/code>는 가능한 한 삭제된 공간을 재활용 하도록 DBMS가 설계되기 때문에, 항상 &lt;code>INSERT&lt;/code>순서대로 저장되는 것은 아니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_8_2/img_2.png"
width="1462"
height="842"
srcset="https://codemario318.github.io/post/real_mysql_8_2/img_2_hu7b3c22bf020200bd3cdee7811beafb13_1752782_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_8_2/img_2_hu7b3c22bf020200bd3cdee7811beafb13_1752782_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="B-Tree의 리프 노드와 테이블 데이터 레코드(MyISAM)"
class="gallery-image"
data-flex-grow="173"
data-flex-basis="416px"
>
&lt;img src="https://codemario318.github.io/post/real_mysql_8_2/img_3.png"
width="1548"
height="780"
srcset="https://codemario318.github.io/post/real_mysql_8_2/img_3_hu1c5f6032d99b8c52f1f8d347a8e170df_2414393_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_8_2/img_3_hu1c5f6032d99b8c52f1f8d347a8e170df_2414393_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="B-Tree의 리프 노드와 테이블 데이터 레코드(InnoDB)"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="476px"
>&lt;/p>
&lt;p>인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. 이를 위해 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가진다.&lt;/p>
&lt;ul>
&lt;li>MyISAM
&lt;ul>
&lt;li>레코드 주소는 MyISAM 테이블 생성 옵션에 따라 레코드가 테이블에 &lt;code>INSERT&lt;/code>된 순번이거나 데이터 파일 내의 위치다. (ROWID)&lt;/li>
&lt;li>세컨더리 인덱스가 물리적인 주소를 가진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>InnoDB
&lt;ul>
&lt;li>프라이머리 키가 ROWID 역할을 한다&lt;/li>
&lt;li>프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다.&lt;/li>
&lt;li>따라서 인덱스를 통해 레코드를 읽을때는 데이터 파일을 바로 찾아가지 못하고, 인덱스에 저장되어있는 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 특징으로 인해 InnoDB 스토리지 엔진을 사용하는 테이블의 성능이 떨어질 것 처럼 보이지만 각각 장단점을 가지고 있다.&lt;/p>
&lt;h2 id="b-tree-인덱스-키-추가-및-삭제">B-Tree 인덱스 키 추가 및 삭제&lt;/h2>
&lt;p>테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업이 발생한다. 이에따라 주의해야 할 사항이 있다.&lt;/p>
&lt;h3 id="인덱스-키-추가">인덱스 키 추가&lt;/h3>
&lt;p>새로운 키 값이 B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다. 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.&lt;/p>
&lt;p>리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리돼야 하는데, 이는 상위 브랜치 노드까지 처리 범위가 넓어진다. 이러한 작업 탓이 B-Tree는 상대적으로 쓰기 작업(새로운 키를 추가)에 비용이 많이 드는 것으로 알려졌다.&lt;/p>
&lt;p>인덱스 추가로 인해 &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code> 문장이 어떤 영향을 받을지 예상해보려면 테이블의 컬럼 수, 컬럼 크기, 인덱스 컬럼의 특성 등을 확인해야 한다. 대략적으로 테이블의 레코드를 추가하는 작업 비용을 1이라고 가정하면, 해당 테이블의 인덱스에 키를 추가하는 작업 비용을 1.5 정도로 예측한다. 테이블에 인덱스가 3개가 있다면 5.5(&lt;code>1.5 * 3 + 1&lt;/code>) 정도로 예측한다. 중요한 것은 이 비용의 대부분이 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야해서 걸리는 시간이다.&lt;/p>
&lt;p>MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블에서는 &lt;code>INSERT&lt;/code> 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 변경하지만, InnoDB 스토리지 엔진은 필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있다. 하지만 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제한다.&lt;/p>
&lt;h3 id="인덱스-키-삭제">인덱스 키 삭제&lt;/h3>
&lt;p>B-Tree의 키 값이 삭제되는 경우는 상당히 간단하다. 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다. 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재사용할 수 있다.&lt;/p>
&lt;p>인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하며, MySQL 5.5 이상 버전의 InnoDB 스토리지 엔진에서는 버퍼링 되어 지연 처리될 수 있다. 처리가 지연된 인덱스 키 삭제 또한 사용자에게는 특별한 악영향 없이 MySQL 서버가 내부적으로 처리하므로 특별히 걱정할 것은 없다.&lt;/p>
&lt;p>MyISAM이나 MEMORY 스토리지 엔진의 테이블에서는 체인지 버퍼와 같은 기능이 없으므로 인덱스 키 삭제가 완료된 후 쿼리 실행이 완료된다.&lt;/p>
&lt;h3 id="인덱스-키-변경">인덱스 키 변경&lt;/h3>
&lt;p>인덱스의 키 값은 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경하는 것은 불가능하다. 따라서 B-Tree의 키 값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.&lt;/p>
&lt;p>결국 인덱스 키 값을 변경하는 작업은 기존 인덱스 키 값을 삭제한 후 새로운 인덱스 키 값을 추가하는 작업으로 처리되고 InnoDB 스토리지 엔진을 사용하는 테이블에 대해서는 이 작업 모두 체인지 버퍼를 활용해 지연 처리 될 수 있다.&lt;/p>
&lt;h3 id="인덱스-키-검색">인덱스 키 검색&lt;/h3>
&lt;p>인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행하는데, 이 과정을 &lt;strong>트리 탐색&lt;/strong>이라고 한다.&lt;/p>
&lt;p>인덱스 트리 탐색은 &lt;code>SELECT&lt;/code>뿐만 아니라 &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code>를 처리하기 위해 해당 레코드를 검색해야 할 때도 사용된다.&lt;/p>
&lt;p>B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>부등호 비교 조건에서도 인덱스를 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 사용할 수 없다.&lt;/li>
&lt;li>인덱스를 키 값에 변형이 가해진 후 비교되는 경우 빠른 검색 기능을 활용할 수 없다.(변형된 값은 인덱스에 존재하는 값이 아니므로)
&lt;ul>
&lt;li>함수나 연산을 수행한 결과로 정렬 또는 검색&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼있어, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠그게 된다.&lt;/p>
&lt;h2 id="b-tree-인덱스-사용에-영향을-미치는-요소">B-Tree 인덱스 사용에 영향을 미치는 요소&lt;/h2>
&lt;ul>
&lt;li>컬럼 크기&lt;/li>
&lt;li>레코드의 건수&lt;/li>
&lt;li>유니크한 인덱스 키 값의 개수&lt;/li>
&lt;/ul>
&lt;h3 id="인덱스-키-값의-크기">인덱스 키 값의 크기&lt;/h3>
&lt;p>InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다. 또한 페이지는 InnoDB 스토리지 엔진의 버퍼풀에서 데이터를 버퍼링하는 기본 단위이기도 하다. 인덱스도 결국 페이지 단위로 관리되며, 루트와 브랜치 리프 노드를 구분한 기준이 페이지 단위이다.&lt;/p>
&lt;p>일반적으로 DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조다. 인덱스의 페이지 크기와 키 값의 크기에 따라 자식 노드의 최대 개수가 결정된다. MySQL 5.7 버전부터는 InnoDB 스토리지 엔진의 페이지 크기를 &lt;code>innodb_page_size&lt;/code> 시스템 변수를 이용해 4KB ~ 64KB 사이의 값을 결정 할 수 있으며, 기본값은 16KB 이다.&lt;/p>
&lt;p>인덱스 페이지는 인덱스 키 값과 해당하는 주솟값을 인덱스 페이지에 지정하게 되며, 페이지 크기가 변하지 않았을 경우 인덱스 키 값이 커지면 하나의 페이지에 저장되는 레코드의 개수는 줄어들게 된다. 키 크기가 커서 한 페이지에 300개의 레코드가 인덱스 페이지에 저장된다고 가정하면 &lt;code>SELECT&lt;/code> 쿼리를 통해 500개의 데이터를 조회해야 한다고 했을때 최소한 2번 읽기 작업이 발생하게 된다.&lt;/p>
&lt;p>따라서, 인덱스를 구성하는 키 값의 크기가 커지면 디스크로 부터 읽어와야 하는 횟수가 늘어날 수 있고, 그만큼 느려질 수 있다. 또한 인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것을 의미하기 때문에, 무한정 인덱스를 캐시해둘 수 없는 InnoDB의 버퍼풀, MyISAM의 키 캐시에 저장할 수 있는 공간이 부족해져 메모리 효율이 떨어질 수 있다.&lt;/p>
&lt;h3 id="b-tree-깊이">B-Tree 깊이&lt;/h3>
&lt;p>인덱스의 깊이는 상당히 중요하지만 제어할 방법은 없다.&lt;/p>
&lt;p>B-Tree의 깊이는 MySQL에서 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제다. 인덱스 키 값의 크기가 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 이에 따라 같은 개수의 인덱스 키값을 저장하게 되면 더 깊어지게된다. 따라서 디스크 읽기가 더 많이 필요하게 된다.&lt;/p>
&lt;p>인ㄷ게스 키 값의 크기는 가능한 작게 만드는 것이 좋지만, 실제로 아무리 대용량 데이터베이스라도 B-Tree의 깊이가 5단계 이상까지 깊어지는 경우는 흔하지 않다.&lt;/p>
&lt;h3 id="선택도기수성">선택도(기수성)&lt;/h3>
&lt;p>인덱스에서 선택도(Selectivity) 또는 기수성(Cardinality)은 거의 같은 의미로 사용되며, &lt;strong>모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.&lt;/strong>&lt;/p>
&lt;p>인덱스 키 값 가운데 중복된 값이 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어지게 된다. 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.&lt;/p>
&lt;blockquote>
&lt;p>선택도가 좋지 않다고 하더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 훨씬 나은 경우도 많다. 인덱스가 항상 검색에만 사용되는 것은 아니므로 여러 가지 용도를 고려해 적절히 인덱스를 설계해야한다.&lt;/p>
&lt;/blockquote>
&lt;p>선택도가 낮은 인덱스를 처리하면 MySQL 서버는 불필요한 데이터를 더 많이 읽어오게 된다.&lt;/p>
&lt;h3 id="읽어야-하는-레코드의-건수">읽어야 하는 레코드의 건수&lt;/h3>
&lt;p>인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것 보다 높은 비용이 드는 작업이다. 따라서 인덱스를 이용한 읽기의 손익 분기점이 얼마인지를 판단할 필요가 있다.&lt;/p>
&lt;p>일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업인 것으로 예측한다. 즉 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20%~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적이다.&lt;/p>
&lt;p>많은 레코드를 읽을 때는 강제로 인덱스를 사용하도록 힌트를 추가해도 성능상 얻을 수 있는 이점이 없다.&lt;/p>
&lt;h2 id="b-tree-인덱스를-통한-데이터-읽기">B-Tree 인덱스를 통한 데이터 읽기&lt;/h2>
&lt;p>어떤 경우에 인덱스를 사용하게 유도할지, 또는 사용하지 못하게 할지 판단하려면 MySQL이 어떻게 인덱스를 이용해서 레코드를 읽어 내는지 알아야 한다.&lt;/p>
&lt;h3 id="인덱스-레인지-스캔">인덱스 레인지 스캔&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BETWEEN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Ebbe&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Gad&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_8_2/img_4.png"
width="582"
height="558"
srcset="https://codemario318.github.io/post/real_mysql_8_2/img_4_hu301057c997b3b41ee80848125dd9db57_152006_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_8_2/img_4_hu301057c997b3b41ee80848125dd9db57_152006_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="인덱스 레인지 스캔"
class="gallery-image"
data-flex-grow="104"
data-flex-basis="250px"
>&lt;/p>
&lt;p>인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 대 사용하는 방식이다. 검색하려는 값의 수나 검색 결과 레코드 건수와 관계 없이 레인지 스캔이라고 표현한다.&lt;/p>
&lt;p>루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야만 비로소 필요한 레코드의 시작 지점을 찾을 수 있다. 이처럼 차례대로 죽 읽는 것을 스캔이라고 표현하며, 스캔하다가 리프 노드의 끝까지 읽으면 리프 노드의 구간은 실제 스캔하는 범위를 표현한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_8_2/img_5.png"
width="628"
height="557"
srcset="https://codemario318.github.io/post/real_mysql_8_2/img_5_hu766996a0529fd6a35a8cd6100064bbf2_220325_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_8_2/img_5_hu766996a0529fd6a35a8cd6100064bbf2_220325_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="270px"
>&lt;/p>
&lt;p>B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고, 그 지점부터 필요한 방향으로 인덱스를 읽어 나간다. 인덱스 자체 정렬 특성으로 인해 어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다.&lt;/p>
&lt;p>인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다. 이때 리프노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 단위로 랜덤 I/O가 한 번 씩 일어난다. 이러한 이유 때문에 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류된다.&lt;/p>
&lt;ol>
&lt;li>인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다.&lt;/li>
&lt;li>1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다.(인덱스 스캔)&lt;/li>
&lt;li>읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.&lt;/li>
&lt;/ol>
&lt;p>쿼리가 필요로 하는 데이터에 따라 3번 과정은 필요하지 않을 수도 있는데, 이를 커버링 인덱스라고 한다. 커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어들고 그만큼 빨라진다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Handler_%&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위 쿼리를 통해 읽은 레코드 건수를 조회할 수 있으나, 실제 인덱스만 읽었는지 인덱스를 통해 테이블의 레코드를 읽었는지(3번)은 구분할 수 없다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>Handler_read_key&lt;/code>: 1번 단계가 실행된 횟수&lt;/li>
&lt;li>&lt;code>Handler_read_next&lt;/code>: 인덱스 정순으로 읽은 레코드 건수&lt;/li>
&lt;li>&lt;code>Handler_read_prev&lt;/code>: 인덱스 역순으로 읽은 레코드 건수&lt;/li>
&lt;li>&lt;code>Handler_read_first&lt;/code>: 첫 번째 레코드를 읽은 횟수 (&lt;code>MIN&lt;/code>)&lt;/li>
&lt;li>&lt;code>Handler_read_last&lt;/code>: 마지막 레코드를 읽은 횟수 (&lt;code>MAX&lt;/code>)&lt;/li>
&lt;/ul>
&lt;h3 id="인덱스-풀-스캔">인덱스 풀 스캔&lt;/h3>
&lt;p>인덱스 레인지 스캔과는 달리 인덱스의 처음부터 끝까지 모두 읽는 방식이다. 대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_8_2/img_6.png"
width="575"
height="556"
srcset="https://codemario318.github.io/post/real_mysql_8_2/img_6_huab8bc2140b6b20b790aac6ab1b0d6466_163070_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_8_2/img_6_huab8bc2140b6b20b790aac6ab1b0d6466_163070_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="103"
data-flex-basis="248px"
>&lt;/p>
&lt;ul>
&lt;li>인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한다.&lt;/li>
&lt;li>인덱스의 리프 노드를 연결하는 링크드 리스트를 따라서 처음부터 끝까지 스캔한다.&lt;/li>
&lt;/ul>
&lt;p>인덱스 풀 스캔은 인덱스에 포함된 컬럼만으로 쿼리를 처리할 수 있는 경우 테이블의 레코드를 읽을 필요가 없어 테이블 풀 스캔보다는 효율적이다. 인덱스의 전체 크기는 테이블 자체의 크기보다는 훨씬 작으므로 더 적은 디스크 I/O로 처리할 수 있다.&lt;/p>
&lt;h3 id="루스-인덱스-스캔">루스 인덱스 스캔&lt;/h3>
&lt;p>오라클 DBMS의 &lt;strong>인덱스 스킵 스캔&lt;/strong>비슷하게 처리되는 방법으로 MySQL 5.7 버전 까지는 기능이 많이 제한적이었지만, MySQL 8.0 버전부터는 다른 상용 DBMS에서 지원하는 인덱스 스킵 스캔과 같은 최적화를 조금씩 지원하기 시작했다.&lt;/p>
&lt;blockquote>
&lt;p>인덱스 레인지 스캔과 인덱스 풀 스캔은 루스 인덱스 스캔과는 상반된 의미로 타이트 인덱스 스캔으로 분류한다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_8_2/img_7.png"
width="602"
height="730"
srcset="https://codemario318.github.io/post/real_mysql_8_2/img_7_hu994beec9ee7afb666dcc0c6049363bba_231238_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_8_2/img_7_hu994beec9ee7afb666dcc0c6049363bba_231238_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="82"
data-flex-basis="197px"
>&lt;/p>
&lt;p>루스 인덱스 스캔이란 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다. 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다. 일반적으로 &lt;code>GROUP BY&lt;/code> 또는 집합 함수 중 &lt;code>MIN()&lt;/code>, &lt;code>MAX()&lt;/code> 함수에 대해 최적화를 하는 경우 사용된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dept_no&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">MIN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">emp_no&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dept_emp&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dep_no&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BETWEEN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;d002&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;d004&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">GROUP&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dept_no&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>인덱스에서 &lt;code>WHERE&lt;/code>조건을 만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저는 알고 있기 때문에 조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 이동한다. 루스 인덱스 스캔을 사용하려면 여러가지 조건을 만족해야 한다.&lt;/p>
&lt;h3 id="인덱스-스킵-스캔">인덱스 스킵 스캔&lt;/h3>
&lt;p>데이터베이스 서버에서 인덱스의 핵심은 값이 정렬돼 있다는 것이며, 이로 인해 인덱스를 구성하는 컬럼의 순서가 매우 중요하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ADD&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ix_gender_birthdate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gender&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">birth_date&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>인덱스를 사용하려면 &lt;code>WHERE&lt;/code>조건절에 &lt;code>gender&lt;/code> 컬럼에 대한 비교 조건이 필수이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* 인덱스 X */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">birth_date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;1965-02-01&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/* 인덱스 O */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">gender&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;M&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">birth_date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;1965-02-01&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>따라서 위 두 쿼리중 gender 컬럼과 birth_date 컬럼의 조건을 모두 가진 두 번째 쿼리는 인덱스를 효율적으로 사용할 수 있지만, gender 컬럼에 대한 비교 조건이 없는 첫 번째 쿼리는 인덱스를 사용할 수 없어 birth_date 컬럼부터 시작하는 인덱스를 생성해야만 했다.&lt;/p>
&lt;p>MySQL 8.0 버전부터는 옵티마이저가 gender 컬럼을 건너 뛰어서 birth_date 컬럼만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이 도입됐다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">optimizer_switch&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;skip_scan=on&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">birth_date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;1965-02-01&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">gender&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;M&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">birth_date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;1965-02-01&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">gender&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;F&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">birth_date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;1965-02-01&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위의 쿼리는 아래의 쿼리로 나눠 실행한 것과 비슷한 형태로 최적화를 실행한다.&lt;/p>
&lt;p>인덱스 스킵 스캔은 새롭게 도입된 기능이어서 아직 다음과 같은 단점이 있다.&lt;/p>
&lt;ul>
&lt;li>WHERE 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야함&lt;/li>
&lt;li>쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야함(커버링 인덱스)&lt;/li>
&lt;/ul>
&lt;h3 id="다중-컬럼-인덱스">다중 컬럼 인덱스&lt;/h3>
&lt;p>실제 서비스용 데이터베이스에서는 2개 이상의 컬럼을 포함하는 인덱스가 더 많이 사용된다. 두개 이상의 컬럼으로 구성된 인덱스를 다중 컬럼 인덱스(복합 컬럼 인덱스, Concatenated Index)라고 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_8_2/img_8.png"
width="417"
height="676"
srcset="https://codemario318.github.io/post/real_mysql_8_2/img_8_hu52c72accbc20e94b4dc26061f37645f3_153808_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_8_2/img_8_hu52c72accbc20e94b4dc26061f37645f3_153808_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="61"
data-flex-basis="148px"
>&lt;/p>
&lt;p>인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬돼있다. 즉 두 번째 컬럼의 정렬은 첫 번째 컬럼이 똑같은 레코드에서만 의미가 있다. 위의 예제에서 emp_no 값의 정렬 순서가 빠르다고 하더라도 dept_no 컬럼의 정렬 순서가 늦다면 인덱스의 두쪽에 위치한다. 따라서 다중 컬럼 인덱스에서는 인덱스 내에서 각 컬럼의 위치(순서)가 상당히 중요하여 신중히 결정해야 한다.&lt;/p>
&lt;h2 id="b-tree-인덱스의-정렬-및-스캔-방향">B-Tree 인덱스의 정렬 및 스캔 방향&lt;/h2>
&lt;p>인덱스를 생성할 때 설정한 정렬 규칙에 따라 인덱스의 키 값은 항상 오름차순이거나 내림차순으로 정렬되어 저장된다. 하지만 읽을때는 반대로도 가능하며, 인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어 내는 실행 계획에 따라 결정된다.&lt;/p>
&lt;h3 id="인덱스의-정렬">인덱스의 정렬&lt;/h3>
&lt;p>MySQL 5.7 버전까지는 컬럼 단위로 정렬 순서를 혼합해서 인덱스를 생성할 수 없었지만, 8.0 버전부터는 순서를 혼합한 인덱스도 생성할 수 있게 되었다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ix_teamname_userscore&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">team_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ASC&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user_score&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="인덱스-스캔-방향">인덱스 스캔 방향&lt;/h3>
&lt;p>인덱스는 항상 오름차순으로만 정렬돼 있지만 인덱스를 최솟값부터 읽으면 오름차순으로 값을 가져올 수 있고, 최댓값부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는 것을 MySQL 옵티마이저는 이미 알고 있다. 즉 인덱스 생성 시점에 오름차순 또는 내림차순으로 정렬이 결정되지만 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.&lt;/p>
&lt;p>&lt;code>ORDER BY&lt;/code> 처리나 &lt;code>MIN&lt;/code>, &lt;code>MAX&lt;/code> 함수등의 최적화가 필요한 경우에도 인덱스의 읽기 방향을 전환해서 사용하도록 실행 계획을 만들어낸다.&lt;/p>
&lt;h3 id="내림차순-인덱스">내림차순 인덱스&lt;/h3>
&lt;p>MySQL 서버는 실제 내림차순인지 오름차순인지 관계없이 인덱스를 읽는 순서만 변경해서 해결할 수 있지만, 2개 이상의 컬럼으로 구성된 복합 인덱스에서 각각의 컬럼이 내림차순과 오름차순이 혼합된 경우는 내림차순 인덱스로만 해결될 수 있다.&lt;/p>
&lt;p>실제 역순 정려 쿼리가 정순 정렬 쿼리보다 더 시간이 많이 걸린다. MySQL 서버의 InnoDB 스토리지 엔진에서 정순 스캔과 역순 스캔은 페이지 간의 양방향 연결 고리를 통해 전진하느냐 후진하느냐의 차이만 있지만, 실제 내부적으로는 InnoDB에서 인덱스 역순 스캔이 더 느린 이유는 2가지가 있다.&lt;/p>
&lt;ul>
&lt;li>페이지 잠금이 인덱스 정순 스캔에 적합한 구조&lt;/li>
&lt;li>페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조&lt;/li>
&lt;/ul>
&lt;p>쿼리가 많은 레코드를 조회하면서 빈번하게 실행된다면 오름차순 인덱스보다는 내림차순 인덱스가 더 효율적이다. 또한 많은 쿼리가 인덱스의 한쪽만을 집중적으로 읽어 특정 페이지 잠금이 병목이 될 것으로 예상된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상은 완화하는 데 도움이 될 수 있다.&lt;/p>
&lt;h2 id="b-tree-인덱스의-가용성과-효율성">B-Tree 인덱스의 가용성과 효율성&lt;/h2>
&lt;p>쿼리의 &lt;code>WHERE&lt;/code> 조건이나 &lt;code>GROUP BY&lt;/code>, &lt;code>ORDER BY&lt;/code> 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 인덱스를 최적으로 생성할 수 있다.&lt;/p>
&lt;h3 id="비교-조건의-종류와-효율성">비교 조건의 종류와 효율성&lt;/h3>
&lt;p>다중 컬럼 인덱스에서 각 컬럼의 순서와 그 컬럼에 사용된 조건이 동등 비교인지 아니면 범위 조건인지에 따라 인덱스 컬럼 활용 형태가 달라지며, 효율 또한 다르다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dept_emp&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dept_no&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;d002&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">emp_no&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10114&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>A: &lt;code>INDEX (dept_no, emp_no)&lt;/code>
&lt;ul>
&lt;li>&lt;code>dept_no='d002' AND emp_no &amp;gt;=10114&lt;/code> 인 레코드들을 찾고 &lt;code>dept_no&lt;/code>가 &amp;lsquo;d002&amp;rsquo;가 아닐 때까지 인덱스를 읽는다.&lt;/li>
&lt;li>조건을 만족하는 레코드를 찾는데 필요한 비교 작업만 수행하므로 효율적으로 인덱스를 활용했다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>B: &lt;code>INDEX (emp_no, dept_no)&lt;/code>
&lt;ul>
&lt;li>&lt;code>emp_no &amp;gt;=10114 AND dept_no='d002'&lt;/code> 인 레코드들을 찾고 &lt;code>dept_no&lt;/code>가 모든 레코드가 &amp;lsquo;d002&amp;rsquo;인지 비교한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 필터링이라고 하며, 케이스 B 인덱스에서는 다중 컬럼 인덱스의 정렬 방식으로 인해 최종적인 조건을 만족하는 레코드를 찾기 위해 더 큰 범위의 데이터를 가져와 비교했다.&lt;/p>
&lt;p>공식적인 명칭은 아니지만 케이스 A 인덱스에서의 도 조건과 같이 작업의 범위를 결정하는 조건을 &lt;strong>작업 범위 결정 조건&lt;/strong>이라 하고 케이스 B 인덱스같이 비교 작업의 범위를 줄이지 못하고 거름종이 역할만 하는 조건을 &lt;strong>필터링 조건&lt;/strong>, &lt;strong>체크 조건&lt;/strong>이라고 표현한다.&lt;/p>
&lt;p>작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만 체크 조건은 많다고 해서 쿼리의 처리 성능을 높히지는 못한다.&lt;/p>
&lt;h3 id="인덱스의-가용성">인덱스의 가용성&lt;/h3>
&lt;p>B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬된다. 하나의 컬럼 내에서 뿐만 아니라 다우 컬럼 인덱스의 컬럼에 대해서도 함께 적용된다.&lt;/p>
&lt;ul>
&lt;li>A: &lt;code>INDEX (first_name)&lt;/code>&lt;/li>
&lt;li>B: &lt;code>INDEX (dept_no, emp_no)&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>인덱스 키 값의 이런 정렬 특성은 빠른 검색의 전제 조건이다. 즉 하나의 컬럼으로 검색해도 값의 왼쪽 부분이 없으면 인덱스 레인지 스캔 방식의 검색이 불가능하다. 또한 다중 컬럼 인덱스에서도 왼쪽 컬럼의 값을 모르면 인덱스 레인지 스캔을 사용할 수 없다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;%mer&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>first_name 컬럼에 저장된 값의 왼쪽부터 한 글자씩 비교해 가면서 일치하는 레코드를 찾아야 하는데, LIKE 조건으로 왼쪽 부분이 고정되지 않았기 때문에 인덱스 레인지 스캔 방식으로 인덱스를 사용할 수 없다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">dept_emp&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">emp_no&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10144&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>인덱스가 dept_no 기준으로 생성되었기 때문에 dept_no 조건 없이 검색하면 인덱스를 효율적으로 사용할 수 없다.&lt;/p>
&lt;h3 id="가용성과-효율성-판단">가용성과 효율성 판단&lt;/h3>
&lt;p>기본적으로 B-Tree 인덱스의 특성상 다음 조건에서는 사용할 수 없다. (작업 범위 결정 조거능로 사용할 수 없다.)&lt;/p>
&lt;ul>
&lt;li>NOT-EQUAL로 비교된 경우(&lt;code>&amp;lt;&amp;gt;&lt;/code>,&lt;code>NOT IN&lt;/code>, &lt;code>NOT BETWEEN&lt;/code>, &lt;code>IS NOT NULL&lt;/code>)&lt;/li>
&lt;li>&lt;code>LIKE '%??'&lt;/code> 형태로 문자열 패턴이 비교된 경우&lt;/li>
&lt;li>스토어드 함수나 다른 연산자로 인덱스 컬럼이변형된 후 비교된 경우
&lt;ul>
&lt;li>&lt;code>WHERE SUBSTRING(column, 1, 1) = 'X&lt;/code>&lt;/li>
&lt;li>&lt;code>WHERE DAYOFMONTH(column) = 1&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
&lt;ul>
&lt;li>&lt;code>WHERE column = deterministic_function()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 타입이 서로 다른 비교(인덱스 컬럼의 타입을 변환해야 비교가 가능한 경우)&lt;/li>
&lt;li>문자열 데이터 타입의 콜레이션이 다른 경우&lt;/li>
&lt;/ul>
&lt;p>다른 일반적은 DBMS에서는 NULL 값이 인덱스에 저장되지 않지만 MySQL 에서는 NULL 값도 인덱스에 저장된다. 다음과 같은 WHERE 조건도 작업 범위 결정 조건으로 인덱스를 사용한다. (&lt;code>WHERE column IS NULL&lt;/code>)&lt;/p>
&lt;h4 id="다중-컬럼-인덱스-1">다중 컬럼 인덱스&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ix_test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">column_1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">column_n&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
&lt;ul>
&lt;li>column_1 컬럼에 대한 조건이 없는 경우&lt;/li>
&lt;li>column_1 컬럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작업 범위 결정 조건으로 사용하는 경우
&lt;ul>
&lt;li>column_1 ~ column_(i-1)컬럼까지 동등 비교 형태(&lt;code>=&lt;/code>, &lt;code>IN&lt;/code>)&lt;/li>
&lt;li>column_i 컬럼에 대해 다음 연산자 중 하나로 비교
&lt;ul>
&lt;li>동등 비교&lt;/li>
&lt;li>크다 작다 형태&lt;/li>
&lt;li>LIKE로 좌특 일치 패턴&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>적업 범위 결정 조건으로 인덱스를 사용하는 쿼리 패턴은 이 밖에도 상당히 많지만, 대표적인 것을 기억해 두면 좀 더 효율적인 쿼리를 쉽게 작성할 수 있다.&lt;/p></description></item><item><title>8. 인덱스 (1)</title><link>https://codemario318.github.io/post/real_mysql_8_1/</link><pubDate>Sun, 07 May 2023 16:24:10 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_8_1/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_8_1/real_mysql.jpeg" alt="Featured image of post 8. 인덱스 (1)" />&lt;p>인덱스는 데이터베이스 쿼리의 성능을 언급하면서 뻬놓을 수 없는 부분이다. 각 인덱스의 특성과 차이는 상당히 중요하며, 물리 수준의 모델링을 할 때도 중요한 요소가 된다.&lt;/p>
&lt;p>MySQL 8.0 버전까지 업그레이드되어 오면서 다른 상용 RDBMS에서 제공하는 많은 기능을 지원하게 됐으며, 기존의 MyISAM 스토리지 엔진에서만 제공하던 전문 검색이나 위치 기반 검색 기능도 모두 InnoDB 스토리지 엔진에서 사용할 수 있게 개선되었다.&lt;/p>
&lt;p>하지만 아무리 MySQL 서버의 옵티마이저가 발전하고 성능이 개선됐다고 해도 여전히 관리자의 역할은 매우 중요하며, 인덱스에 대한 기본 지식은 지금도 앞으로도 개발자나 관리자에게 매우 중요하고 쿼리 튜닝의 기본이 될 것이다.&lt;/p>
&lt;h2 id="디스크-읽기-방식">디스크 읽기 방식&lt;/h2>
&lt;p>컴퓨터의 CPU나 메모리처럼 전기적 특성을 띤 장치의 성능은 짧은 시간동안 매우 빠른 속도로 발전했으나 디스크 같은 기계식 장치의 성능은 상당히 제한적으로 발전했다. 최근에는 자기 디스크 원판에 의존하는 하드 디스크보다 SSD 드라이브가 많이 활용되고 있지만, 여전히 데이터 저장 매체는 컴퓨터에서 가장 느린 부분이라는 사실에는 변함이 없다.&lt;/p>
&lt;blockquote>
&lt;p>데이터베이스나 쿼리 튜닝에 어느정도 지식을 사용자가 절감하고 있듯이 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관권일 때가 많다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="hdd와-ssd">HDD와 SSD&lt;/h3>
&lt;p>데이터베이스 서버에서는 항상 디스크 장치가 병목이 된다. SSD는 기존 하드 디스크 드라이브에서 데이터 저장용 원판을 제거하는 대신 플래시 메모리를 장착하고 있다. 따라서 원판을 물리적으로 회전시킬 필요가 없으므로 빠르게 데이터를 읽고 쓸 수 있다.&lt;/p>
&lt;p>플래시 메모리를 사용하는 SSD는 하드 디스크 드라이브보다 용량은 적지만 1000배 가량 빠른 성능을 보여주기 때문에 요즘은 DBMS용 서버는 SSD를 채택하고 있다.&lt;/p>
&lt;p>디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차 I/O 에서는 SSD가 압도적으로 빠르진 않지만 데이터베이스 서버에서는 대부분 랜덤 I/O가 발생하여 대부분의 상황에서 SSD 성능이 우수하다.&lt;/p>
&lt;h3 id="랜덤-io와-순차-io">랜덤 I/O와 순차 I/O&lt;/h3>
&lt;p>하드디스크 기준으로 랜덤 I/O는 그만큼 디스크 헤드를 자주 움직여야 한다는 뜻이며, SSD도 랜덤 I/O가 순차 I/O에 비해 스루풋이 떨어진다. 데이터베이스 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버에는 그룹 커밋이나 바이너리 로그 버퍼 도는 InnoDB 로그 버퍼 등의 기능으로 대응하고 있다.&lt;/p>
&lt;p>쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔 실행할 방법은 그다지 많지 않고, 일반적으로 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이다.&lt;/p>
&lt;blockquote>
&lt;p>랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O 사용하고 풀 테이블 스캔은 순차 I/O 사용한다. 따라서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다. &lt;br>
이런 형태는 온라인 서비스에서는 거의 활용되지 않으며 주로 데이터웨어하우스나 통계 작업에서 많이 활용된다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="인덱스란">인덱스란?&lt;/h2>
&lt;p>책의 맨 끝에 있는 색인으로 설명된다. 색인으로 찾는 페이지 번호는 데이터 파일에 저장된 레코드의 주소에 비유될 수 있다.&lt;/p>
&lt;p>DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸리기 때문에, 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들고, 빠른 검색을 위해 칼럼의 값을 기준으로 정렬해놓는다.&lt;/p>
&lt;p>자료구조로 비유하면, SortedList, ArrayList를 예로 들 수 있다.&lt;/p>
&lt;ul>
&lt;li>SortedList: DBMS의 인덱스와 같은 자료 구조. 저장된 값을 항상 정렬된 상태로 유지한다.
&lt;ul>
&lt;li>데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리다.&lt;/li>
&lt;li>이미 정렬돼 있어 원하는 값을 아주 빨리 찾아올 수 있다.&lt;/li>
&lt;li>&lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>는 느려지지만 &lt;code>SELECT&lt;/code>는 매우 빠르다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ArrayList: 데이터 파일과 같은 자료구조. 저장된 순서대로 별도 정렬 없이 그대로 저장한다.&lt;/li>
&lt;/ul>
&lt;h3 id="인덱스-추가시-주의사항">인덱스 추가시 주의사항&lt;/h3>
&lt;p>결론적으로 DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. 따라서 다음을 고려하여 인덱스 추가를 결정한다.&lt;/p>
&lt;ul>
&lt;li>데이터의 저장 속도를 어느정도까지 희생할 수 있는지&lt;/li>
&lt;li>읽기 속도를 얼마나 더 빠르게 만들어야 하는지&lt;/li>
&lt;/ul>
&lt;p>&lt;code>SELECT&lt;/code>쿼리 문장의 &lt;code>WHERE&lt;/code>조건절에 사용되는 컬럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과만 불러올 수 있다.&lt;/p>
&lt;h3 id="인덱스-분류">인덱스 분류&lt;/h3>
&lt;p>인덱스는 데이터를 관리하는 방식(알고리즘)과 중복 값의 허용 여부 등에 따라 여러가지로 나눠볼 수 있다.&lt;/p>
&lt;p>&lt;strong>역할 별 분류&lt;/strong>&lt;/p>
&lt;p>인덱스를 역할 별로 구분해 본다면 프라이머리키와 보조키(Secondary Index, Secondary Key)로 구분할 수 있다.&lt;/p>
&lt;ul>
&lt;li>프라이머리 키
&lt;ul>
&lt;li>레코드를 대표하는 컬럼의 값으로 만들어진 인덱스.&lt;/li>
&lt;li>테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 이를 식별자라고도 부른다.&lt;/li>
&lt;li>&lt;code>NULL&lt;/code>값과 중복값을 허용하지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>세컨더리 인덱스
&lt;ul>
&lt;li>프라이머리 키를 제외한 나머지 모든 인덱스.&lt;/li>
&lt;li>유니크 인덱스는 프라이머리 키와 성격이 비슷하고 프라이머리 키를 대체해서 사용할 수 있어 대체키로도 불린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>데이터 저장 방식(알고리즘) 분류&lt;/strong>&lt;/p>
&lt;p>대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다. 최근에는 Fractal-Tree 인덱스나 로그 기반의 Merge-Tree 인덱스와 같은 알고리즘을 사용하는 DBMS도 개발되고 있다.&lt;/p>
&lt;ul>
&lt;li>B-Tree 알고리즘
&lt;ul>
&lt;li>가장 일반적으로 사용되는 인덱스 알고리즘으로, 상당히 오래전에 도입된 만큼 성숙해진 상태이다.&lt;/li>
&lt;li>컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Hash 인덱스 알고리즘
&lt;ul>
&lt;li>컬럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.&lt;/li>
&lt;li>값을 변형해서 인덱싱하므로 전방(Prefix)일치와 같이 값의 일부만 검색하거나 범위 검색할 때에는 해시 인덱스를 사용할 수 없다.&lt;/li>
&lt;li>메모리 기반의 데이터베이스에서 많이 사용된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>데이터 중복 허용 여부로 분류&lt;/strong>&lt;/p>
&lt;p>데이터의 중복 허용 여부로 분류하면 유니크 인덱스와 유니크하지 않은 인덱스로 구분할 수 있다.&lt;/p>
&lt;p>인덱스가 유니크한지 아닌지는 단순히 같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만, 실제 DBMS의 쿼리를 실행할 때 유니크 인덱스에 대해 동등 조건으로 검색한다는 것은 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 내기 때문에 옵티마이저에게는 상당히 중요하다.&lt;/p></description></item><item><title>7. 데이터 암호화</title><link>https://codemario318.github.io/post/real_mysql_7/</link><pubDate>Mon, 01 May 2023 16:24:10 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_7/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_7/real_mysql.jpeg" alt="Featured image of post 7. 데이터 암호화" />&lt;p>데이터 암호화는 MySQL 5.7 버전부터 지원되기 시작했으며, 처음에는 데이터 파일(테이블스페이스)에서만 암호화 기능이 제공 되었으나 MySQL 8.0으로 업그레이드 리두 로그나 언두 로그, 복제를 위한 바이너리 로그 등도 모두 암호화 기능을 지원하기 시작했다.&lt;/p>
&lt;p>데이터 암호화 여부는 보안 감사에서 필수적으로 언급되는 부분이며, 핀테크 서비스처럼 중요한 정보를 저장하는 서비스에서는 응용 프로그램에서 암호화한 데이터를 데이터베이스 서버에서 다시 암호화하는 이중 암호화 방법을 선택하기도 한다.&lt;/p>
&lt;p>응용 프로그램의 암호화는 주로 중요 정보를 가진 칼럼 단위로 암호화를 수행하며, 데이터베이스 수준에서는 테입르 단위로 암호화를 적용한다.&lt;/p>
&lt;h2 id="mysql-서버의-데이터-암호화">MySQL 서버의 데이터 암호화&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_7/real_mysql_7_1.png"
width="746"
height="523"
srcset="https://codemario318.github.io/post/real_mysql_7/real_mysql_7_1_hu25fd17147a88de2c4ef9d22824b432ad_31685_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_7/real_mysql_7_1_hu25fd17147a88de2c4ef9d22824b432ad_31685_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="342px"
>&lt;/p>
&lt;p>MySQL 서버의 암호화 기능은 데이터베이스 서버와 디스크 사이의 데이터 읽고 쓰기 지점에서 암호화 또는 복호화를 수행한다. 즉 MySQL 서버(InnoDB 스토리지 엔진)의 I/O 레이어에서만 데이터의 암호화 및 복호화 과정이 실행되므로디스크 입출력 이외의 부분에서는 암호화 처리가 전혀 필요치 않다.&lt;/p>
&lt;p>MySQL 서버가 사용자의 쿼리를 처리하는 과정에서 테이블의 데이터가 암호화돼 있는지 여부를 식별할 필요가 없으며, 암호화된 테이블도 그렇지 않은 테이블과 동일한 처리 과정을 거친다.&lt;/p>
&lt;p>데이터 암호화 기능이 활성화돼 있다고 하더라도 MySQL 내부와 사용자의 입장에서는 아무런 차이가 없기 때문에 이러한 암호화 방식을 가리켜 TDE(Transparent Data Encryption)이라고 한다.&lt;/p>
&lt;h3 id="2단계-키-관리">2단계 키 관리&lt;/h3>
&lt;p>MySQL 서버의 TDE에서 암호화 키는 키링(KeyRing) 플러그인에 의해 관리되며, MySQL 8.0 버전에서 지왼되는 키링 플러그인은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>keyring_file&lt;/code> File-Based 플러그인&lt;/li>
&lt;li>&lt;code>keyring_encrypted_file&lt;/code> Keyring 플러그인&lt;/li>
&lt;li>&lt;code>keyring_okv&lt;/code> KMIP 플러그인&lt;/li>
&lt;li>&lt;code>keyring_aws&lt;/code> Amazon Web Services keyring 플러그인&lt;/li>
&lt;/ul>
&lt;p>MySQL커뮤니티 에디션에서는 &lt;code>keyring_file&lt;/code> 플러그인만 사용 가능하고, 나머지 플러그인은 모두 엔터프라이즈 에디션에서만 사용 가능하다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_7/real_mysql_7_2.png"
width="1078"
height="785"
srcset="https://codemario318.github.io/post/real_mysql_7/real_mysql_7_2_hu3b106e5a2b1e6e575b248ed5137a917c_45768_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_7/real_mysql_7_2_hu3b106e5a2b1e6e575b248ed5137a917c_45768_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="329px"
>&lt;/p>
&lt;p>다양한 플러그인이 제공되지만 마스터 키를 관리하는 방법만 다를 뿐 MySQL 서버 내부적으로 작동하는 방식은 모두 동일하다. MySQL 서버의 키링 플러그인은 2단계(2-Tier) 키 관리 방식을 사용한다.&lt;/p>
&lt;p>MySQL 서버의 데이터 암호화는 마스터 키(master key)와 테이블스페이스 키(tablespace key)라는 두 가지 종류의 키를 가지고 있는데, 테이블스페이스 키는 프라이빗 키(private key)라고도 한다.&lt;/p>
&lt;ul>
&lt;li>Hasicorp Vault 같은 외부 키 관리 솔루션(KMS, Key Management Service) 또는 디스크의 파일(Keyring_file 또는 keyring_encrypted_file 플러그인 사용시)에서 마스터 키를 가져오고, 암호화된 테이블이 생성될 때마다 해당 테이블을 위한 임의의 테이블스페이스 키를 발급한다.&lt;/li>
&lt;li>마스터 키를 이용해 테이블 스페이스키를 암호화해서 각 테이블의 데이터 파일 헤더에 저장한다.&lt;/li>
&lt;/ul>
&lt;p>이렇게 생성된 테이블스프에스 키는 테이블이 삭제되지 않는 이상 절대 변경되지 않지만, 테이블 스페이스키는 절대 MySQL 서버 외부로 노출되지 않기 때문에 테이블스페이스 키를 주기적으로 변경하지 않아도 보안상 취약점이 되지는 않는다.&lt;/p>
&lt;p>하지만 마스터 키는 외부의 파일을 이용하기 때문에 노출될 가능성이 있어 주기적으로 변경해야 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">INSTANCE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ROTATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">INNODB&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MASTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>마스터키를 변경하면 MySQL서버는 기존의 마스터 키를 이용해 각 테이블의 테이블스페이스 키를 복호화한 다음 새로운 마스터 키로 다시 암호화화한다. 마스터 키가 변경되는 동안 MySQL 서버의 테이블스페이스 키 자체와 데이터 파일의 데이터는 전혀 변경되지 않는다.&lt;/p>
&lt;p>MySQL 서버에서 이렇게 2단계 암호화 방식을 사용하는 이유는 암호화 키 변경으로 인한 과도한 시스템 부하를 피하기 위해서다.&lt;/p>
&lt;p>테이블스페이스 키가 변경된다면 MySQL 서버는 데이터 파일의 모든 데이터를 다시 복호화했다가 다시 암호화해야 하므로, 키를 변경할 때마다 매우 큰 작업을 수행해야 하며, 이에따라 사용자 쿼리를 처리하는 데도 상당한 영향을 미치게 된다.&lt;/p>
&lt;p>MySQL 서버의 TDE에서 지원되는 암호화 알고리즘은 AES 256bit이며, 이외의 알고리즘은 지원되지 않는다.&lt;/p>
&lt;ul>
&lt;li>테이블스페이스 키는 AES-256(Electronic CodeBook) 알고리즘을 이용해 암호화 되고, 실제 데이터 파일은 AES-256 CBC(Cipher Block Chaining) 알고리즘을 이용해 암호화 된다.&lt;/li>
&lt;/ul>
&lt;h3 id="암호화-성능">암호화 성능&lt;/h3>
&lt;p>MySQL 서버의 암호화는 TDE 방식이기 때문에 디스크로부터 한 번 읽은 데이터 페이지는 복호화되어 InnoDB 버퍼풀에 적재된다. 따라서 데이터 페이지가 한 번 메모리에 적재되면 암호화되지 않은 테이블과 동일한 성능을 보인다.&lt;/p>
&lt;ul>
&lt;li>쿼리가 InnoDB 버퍼풀에 존재하지 않는 데이터 페이지를 읽어야 하는 경우에는 복호화 과정을 거치기 때문에 복호화 시간동안 쿼리 처리가 지연될 수 있다.&lt;/li>
&lt;li>암호화된 테이블이 변경되면 다시 디스크로 동기화될 때 암호화돼야 하기 때문에 디스크에 저장할 때도 추가로 시간이 더 걸린다.
&lt;ul>
&lt;li>데이터 페이지 저장은 사용자의 쿼리를 처리하는 스레드가 아는 MySQL 서버으 백그라운드 스레드가 수행하기 때문에 실제 사용자 쿼리가 지연되는 것은 아니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 명령 또한 변경하고자 하는 레코드를 InnoDB 버퍼풀로 읽어와야 하기 대문에 새롭게 디스크에서 읽어야 하는 데이터 페이지의 개수에 따라서 복호화 지연이 발생할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>AES 암호화 알고리즘은 암호화하고자 하는 평문의 길이가 짧은 경우 암호화 키의 크기에 따라 암호화된 결과의 용량이 더 커질수도 있지만, 이미 데이터 페이지는 암호화 키보다 훨씬 크기 때문에 암호화 결과가 평문의 결과와 동일한 크기의 암호문을 반환한다. 따라서 TDE를 적용한다고 해도 데이터 파일의 크기는 암호화되지 않은 테입르과 동일한 크기를 가진다. 즉 암호화한다고 해서 InnoDB 버퍼풀의 효율이 달라지거나 메모리 사용 효율이 떨어지는 현상은 발생하지 않는다.&lt;/p>
&lt;p>같은 테이블에 대해 암호화와 압축이 동시에 적용되면 MySQL 서버는 압축을 먼저 실행하고 암호화를 적용한다.&lt;/p>
&lt;ul>
&lt;li>일반적으로 암호화된 결과문은 아주 랜덤한 바이트의 배열을 가지게 되는데, 이는 암축률을 상당히 떨어뜨린다.&lt;/li>
&lt;li>암호화된 테이블의 데이터 페이지는 복호화된 상태로 InnoDB 버퍼풀에 저장되지만, 압축된 데이터 페이지는 압축 또는 압축 해제의 모든 상태로 InnoDB 버퍼풀에 전재할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="암호화와-복제">암호화와 복제&lt;/h3>
&lt;p>MySQL 서버의 복제에서 레플리카 서버는 소스 서버의 모든 사용자 데이터를 동기화할 때 TDE를 이용한 암호화 사용 시 마스터 키와 테이블스페이스 키는 제외된다.&lt;/p>
&lt;p>MySQL 서버에서 기본적으로 모든 노드는 각자의 마스터 키를 할당해야 한다. 데이터베이스 서버의 로컬 디렉터리에 마스터 키를 관리하는 경우에는 소스 서버와 레플리카 서버는 서로 다른 마스터 키를 갖도록 설정해야 한다. 마스터 키 자체가 레플리카로 복제되지 않기 때문에 테이블스페이스 키 또한 레플리카로 복제되지 않는다.&lt;/p>
&lt;p>결국 소스 서버와 레플리카 서버는 서로 각자의 마스터 키와 테이블 스페이스 키를 관리하기 때문에 복제 멤버들의 데이터 파일은 암호화 되기 전의 값이 동일하더라도 실제 암호화된 데이터가 저장된 데이터 파일의 내용은 완전히 달라진다.&lt;/p>
&lt;p>복제 소스 서버의 마스터 키를 변경할 때는 &lt;code>ALERT INSTANCE ROTATE INNODB MASTER KEY&lt;/code> 명령을 실행하는데, 이때 명령 자체는 레플리카 서버로 복제되지만 실제 소스 서버의 마스터 키 자체가 레플리카 서버로 전다로디는 것은 아니다. 그래서 마스터 키 로테이션을 실행하면 소스 서버와 레플리카 서버가 각각 서로 다른 마스터 키를 새로 발급받는다.&lt;/p>
&lt;p>MySQL 서버의 백업에서 TDE의 키링(Keyr Ring)파일을 백업하지 않는 경우가 있는데, 이 경우 키링 파일을 찾지 못하면 데이터를 복구할 수 없게 된다. 키링 파일을 데이터 백업과 별도로 백업한다면 마스터 키 로테이션 명령으로 TDE의 마스터 키가 엊네 변경됐는지까지 기억하고 있어야 한다.&lt;/p>
&lt;h2 id="keyring_file-플러그인-설치">Keyring_file 플러그인 설치&lt;/h2>
&lt;p>MySQL 서버의 데이터 암호화 기능인 TDE의 암호화 키 관리는 플러그인 방식을 제공된다.&lt;/p>
&lt;p>&lt;code>Keyring_file&lt;/code>플러그인은 테이블스페이스 키를 암호화하기 위한 마스터 키를 디스크의 파일로 관리하는데, 이때 마스터 키는 평문으로 디스크에 저장된다. 즉 마스터키가 저장된 파일이 외부에 노출된다면 데이터 암호화는 무용지물이 된다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>keyring_file&lt;/code>플러그인은 마스터 키를 암호화하지 않은 상태의 평문으로 로컬 디스크에 저장하기 때문에 보안 요건을 충족시켜주지 않을 수 있다. 그럼에도 &lt;code>keyring_file&lt;/code> 플러그인을 사용하고자 한다면 MySQL 서버가 시작될 때만 키링 파일을 다른 서버로부터 다운로드해서 로컬 디스크에 저장한 후 MySQL 서버를 시작하는 방법을 고려할 수 있다. MySQL 서버가 시작되면 마스터 키를 메모리에 캐시하기 때문에 로컬 디스크의 키링 파일을 삭제해도 문제는 전혀 없다.
Percona Server는 HashiCorp Vault를 연동하는 키 관리 플러그인을 오픈소스로 제공하므로 함께 검토해보는 것을 권장한다.&lt;/p>
&lt;/blockquote>
&lt;p>TDE 플러그인의 경우 MySQL 서버가 시작되는 단계에서도 가장 빨리 초기화돼야 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">early-plugin-load = keyring_file.so
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">keyring_file_data = /very/secure/directory/tde_master.key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>그래서 다음과 같이 MySQL 서버의 설정 파일(my.cnf)에서 &lt;code>early-plugin-load&lt;/code> 시스템 변수에 &lt;code>keyring_file&lt;/code> 플러그인을 위한 라이브러리를 명시하면 된다. 그리고 &lt;code>keyring_file&lt;/code> 플러그인이 마스터 키를 저장할 키링 파일의 경로를 &lt;code>keyring_file_data&lt;/code> 설정에 명시하면 된다.&lt;/p>
&lt;p>설정 파일이 준비되면 MySQL 서버 시작시 자동으로 &lt;code>keyring_file&lt;/code>플러그인이 초기화된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PLUGINS&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>초기화와 동시에 지정한 경로에 빈 파일을 생성한다. 데이터 암호화 기능을 사용하는 테이블을 생성하거나 마스터 로테이션을 실행하면 키링 파일의 마스터 키가 초기화된다.&lt;/p>
&lt;h2 id="테이블-암호화">테이블 암호화&lt;/h2>
&lt;p>키링 플러그인은 마스터 키를 생성하고 관리하는 부분까지만 담당하기 때문에 어떤 키링 플러그인을 사용하든 관계 없이 암호화된 테이블을 생성하고 활용하는 방법은 모두 동일하다.&lt;/p>
&lt;h3 id="테이블-생성">테이블 생성&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tab_encrypted&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">data&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENCRYPTION&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;Y&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tab_encrypted&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;test&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tab_encrypted&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">+--+----+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">|id|data|
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">+--+----+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">| 1|test|
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">+--+----+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">*/&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>MySQL 서버에서 암호화된 테이블만 검색할 때는 &lt;code>information_schema&lt;/code>의 &lt;code>TABLES&lt;/code> 뷰를 이용한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">table_schema&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">table_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">create_options&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">information_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tables&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table_name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;tab_encrypted&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>테이블을 생성할 때마다 옵션을 설정하면 실수로 암호화 적용을 잊어버릴 수도 있으므로 MySQL 서버의 모든 테이블에 암호화를 적용하고자 한다면 &lt;code>default_table_encryption&lt;/code> 시스템 변수를 ON으로 설정하면 ENCRYPTION 옵션을 별도로 설정하지 않아도 암호화된 테이블로 생성된다.&lt;/p>
&lt;h3 id="응용-프로그램-암호화와의-비교">응용 프로그램 암호화와의 비교&lt;/h3>
&lt;p>응용 프로그램에서 직접 암호화해서 MySQL 서버에 저장하는 경우도 있는데, 이 경우 저장되는 칼럼의 값이 이미 암호화된 것인지 여부를 MySQL 서버는 인지하지 못한다. 그래서 응용 프로그램에서 암호화된 컬럼은 인덱스를 생성하더라도 인덱스의 기능을 100% 활용할 수 없다.&lt;/p>
&lt;p>응용 프로그램에서 직접 암호화하지 않고 MySQL 서버의 암호화 기능(TDE)을 사용한다면 MySQL 서버는 인덱스 관련된 작업을 모두 처리한 후 최종 디스크에 데이터 페이지를 저장할 때만 암호화 하기 때문에 제약이 줄어든다.&lt;/p>
&lt;p>응용 프로그램에서의 암호화 기능은 서비스의 요건과 성능을 고려해서 선택해야 하고, MySQL 서버의 암호화 기능과 혼합해서 사용한다면 더 안전한 서비스를 구축할 수 있을 것이다.&lt;/p>
&lt;h3 id="테이블스페이스-이동">테이블스페이스 이동&lt;/h3>
&lt;p>MySQL 서버의 데이터베이스 관리자라면 테이블스페이스만 이동하는 기능을 자주 사용하게 되는데, 테이블을 다른 서버로 복사해야 하는 경우 또는 특정 테이블의 데이터 파일만 백업했다가 복구하는 경우라면 테이블스페이스 이동(Export &amp;amp; Import) 기능이 레코드르 덤프했다가 복구하는 방식보다 훨씬 효율적이고 빠르다.&lt;/p>
&lt;p>그런데 TDE가 적용되어 암호화된 테이블의 원본 MySQL 서버와 목적지 MySQL 서버의 암호화 키(마스터 키)가 다르기 때문에 &lt;code>FLUSH TABLES&lt;/code> 명령으로 테입르스페이스를 익스포트 할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">FLUSH&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TABLES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">souce_table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FOR&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">EXPORT&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>MySQL 서버는 &lt;code>source_table&lt;/code>의 저장되지 않은 변경을 모드 디스크로 기록하고, 더이상 접근할 수 없게 잠금을 건다. 그와 동시에 &lt;code>source_table&lt;/code>의 구조를 &lt;code>source_table.cfg&lt;/code> 파일로 기록한다.&lt;/li>
&lt;li>암호화된 테이블의 테이블스페이스 키를 기존 마스터 키로 복호화한 후, 임시로 발급한 마스터 키를 이용해 다시 암호화해서 데이터 파일의 헤더 부분에 저장한다.&lt;/li>
&lt;/ol>
&lt;p>따라서 암호화된 테이블의 경우 테이블스페이스 이동 기능을 사용할 때는 반드시 데이터 파일과 임시 마스터 키가 저장된 &lt;code>*.cfp&lt;/code> 파일을 함께 복사해야 한다. &lt;code>*.cfg&lt;/code>파일은 단순히 테이블의 구조만 가지고 있기 때문에 파일이 없어져도 경고만 발생하지만, &lt;code>*.cfp&lt;/code> 파일이 없어지면 복구가 불가능해진다.&lt;/p>
&lt;h2 id="언두-로그-및-리두-로그-암호화">언두 로그 및 리두 로그 암호화&lt;/h2>
&lt;p>테이블의 암호화를 적용하더라도 디스크로 저장되는 데이터만 암호화되고 MySQL 서버의 메모리에 존재하는 데이터는 복호화된 평문으로 관리되며, 이 평문 데이터가 테이블의 데이터 파일 이외의 디스크 파일로 기록되는 경우에는 여전히 평문으로 저장된다.&lt;/p>
&lt;p>그래서 테이블 암호화를 적용해도 리두 로그나 언두 로그, 그리고 복제를 위한 바이너리 로그에는 평문으로 저장되는 것이다. MySQL 8.0.16 버전 부터는 &lt;code>innodb_undo_log_encrypt&lt;/code>, &lt;code>innodb_redo_log_encrypt&lt;/code> 시스템 변수를 이용해 언두 로그와 리두 로그를를 암호화 된 상태로 저장할 수 있게 개선되었다.&lt;/p>
&lt;p>MySQL 서버는 리두 로그나 언두 로그를 평문으로 저장하다가 암호화가 활성화되면 그때부터 생성되는 리두 로그와 언두 로그만 암호화해서 저장한다. 반대로 리두 로그와 언두 로그가 암호화되는 상태에서 암호화를 비활성화하면 그때부터 저장되는 로그만 평문으로 저장한다.&lt;/p>
&lt;p>따라서 리두 로그와 언두 로그는 암호화를 활성화 했다가 비활성화 한다고 해서 즉시 암호화에 사용된 키가 불필요해지는 것이 아니다. 특히 언두 로그의 경우 암호화를 비활성화 한다고 하더라도 새로 생성되는 언두 로그는 평문으로 저장되겠지만 기존 언두 로그는 여전히 암호화된 상태로 남아있어 상황에 따라 계속해서 암호화키가 필요할 수 있다.&lt;/p>
&lt;h2 id="바이너리-로그-암호화">바이너리 로그 암호화&lt;/h2>
&lt;p>테이블 암호화가 적용돼도 바이너리 로그와 릴레이 로그 파일 또한 리두 로그나 언두 로그처럼 평문을 저장한다. 일반적으로 언두 로그와 리두 로그는 기맂 않은 시간동안의 데이터만 가지기 때문에 보안에 민감하지 않을 수 있지만 바이너리 로그 파일의 암호화는 상황에 따라 중요도가 높아질 수 있다.&lt;/p>
&lt;ul>
&lt;li>바이너리 로그는 의도적으로 상당히 긴 시간동안 보관할 수도 있다.&lt;/li>
&lt;li>증분 백업(Incremental Backup)을 위해 바이너리 로그를 보관하기도 한다.&lt;/li>
&lt;/ul>
&lt;p>바이너리 로그와 릴레이 로그 파일 암호화 기능은 디스크에 저장된 로그 파일에 대한 암호화만 담당하고, MySQL 서버의 메모리 내부 또는 소스 서버와 레플리카 서버 간의 네트워크 구간에서 로그 데이터를 암호화하지는 않는다. 복제 멤버 간의 네트워크 구간에서도 바이너리 로그를 암호화하고자 한다면 MySQL 복제를 위한 계정이 SSL을 사용하도록 설정한다.&lt;/p>
&lt;h3 id="바이너리-로그-암호화-키-관리">바이너리 로그 암호화 키 관리&lt;/h3>
&lt;p>바이너리 로그와 릴레이 로그 파일 데이터의 암호화를 위해서도 MySQL 서버는 2단계 키 관리 방식을 사용한다.&lt;/p>
&lt;p>바이너리 로그와릴레이 로그 파일의 데이터는 파일 키(File Key)로 암호홰해서 디스크로 저장하고, 파일 키는 &amp;ldquo;바이너리 로그 암호화 키&amp;quot;로 암호화 해서 각 바이너리 로그와 릴레이 로그 파일의 헤더에 저장된다.&lt;/p>
&lt;p>즉 &amp;ldquo;바이너리 로그 암호화 키&amp;quot;는 테이블 암호화의 마스터 키와 동일한 역할을 하며, 파일 키는 바이너리 로그와 릴레이 로그 파일 단위로 자동으로 생성되어 해당 로그 파일의 데이터 암호화에만 사용된다.&lt;/p>
&lt;h3 id="바이너리-로그-암호화-키-변경">바이너리 로그 암호화 키 변경&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">INSTANCE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ROTATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">BINLOG&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MASTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>바이너리 로그 암호화 키가 변경되면 다음 과정을 거친다.&lt;/p>
&lt;ol>
&lt;li>증가된 시퀀스 번호와 함께 새로운 바이너리 로그 암호화 키 발금 후 키링 파일에 저장&lt;/li>
&lt;li>바이너리 로그 파일과 릴레이 로그 파일 스위치(새로운 로그 파일로 로테이션)&lt;/li>
&lt;li>새로 생성되는 바이너리 로그와 릴레이 로그 파일의 암호화를 위해 파일 키를 생성하고, 파일 키는 바이너리 로그 파일 키로 암호화해서 각 로그 파일에 저장&lt;/li>
&lt;li>기조 ㄴ바이너리 로그와 릴레이 로그 파일의 파일 키를 읽어서 새로운 바이너리 로그 파일 키로 암호화해서 다시 저장(암호화되지 않은 로그 파일은 무시)&lt;/li>
&lt;li>모든 바이너리 로그와 릴레이 로그 파일리 새로운 바이너리 로그 암호화 키로 다시 암호화됐다면 기조 ㄴ바이너리 로그 암호화 키를 키링 파일에서 제거&lt;/li>
&lt;/ol>
&lt;p>4번 과정은 상당히 시간이 걸릴 수 있는데, 이를 위해 키링 파일에서 &amp;ldquo;바이너리 로그 암호화 키&amp;quot;는 내부적으로 버전 관리가 이뤄진다.&lt;/p>
&lt;h3 id="mysqlbinlog-도구-활용">mysqlbinlog 도구 활용&lt;/h3>
&lt;p>MySQL 서버에서는 트랜잭션의 내용을 추적하거나 백업 복구를 위해 암호화된 바이너리 로그를 평문으로 복호화할 일이 자주 발생한다. 하지만 한 번 바이너리 로그 파일이 암호화되면 바이너리 로그 암호화 키가 없으면 복호화할 수 없다.&lt;/p>
&lt;p>그런데 바이너리 로그 암호화 키는 MySQL 서버만 가지고 있어서 복호화가 불가능하다. &lt;code>mysqlbinlog&lt;/code> 도구를 이용해 암호화된 바이너리 로그 파일을 직접 열어볼 수 없다는 에러 메시지를 출력하게 된다.&lt;/p>
&lt;p>바이너리 로그 암호화 키는 그 바이너리 로그나 릴레이 로그 파일을 생성한 MySQL 서버만 가지고 있기 때문에 MySQL 서버와 관게없이 mysqlbinlog 도구만으로는 복호화할 방법이 없다. 그래서 예전처럼 다른 서버로 복사하거나 바이너리 로그 파일을 백업하는 것은 소용없어졌다.&lt;/p>
&lt;p>바이너리 로그 파일의 내용을 확인할 방법은 MySQL 서버를 통해 가져오는 방법이 유일하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">mysqlbinlog --read-from-remote-server -uroot -p -vvv mysql-bin.000011
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>6. 데이터 압축</title><link>https://codemario318.github.io/post/real_mysql_6/</link><pubDate>Mon, 01 May 2023 14:12:10 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_6/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_6/real_mysql.jpeg" alt="Featured image of post 6. 데이터 압축" />&lt;p>MySQL 서버에서 디스크에 저장된 데이터 파일의 크기는 일반저긍로 쿼리의 처리 성능과도 직결되지만 백업 및 복구 시간과도 밀접하게 연결된다.&lt;/p>
&lt;ul>
&lt;li>디스크의 데이터 파일이 크면 클수록 쿼리를 처리하기 위해서 더 많은 데이터 페이지를 InnoDB 버퍼풀로 읽어야 할 수 있다.&lt;/li>
&lt;li>새로운 페이지가 버퍼풀로 적재되기 때문에 그만큼 더티 페이지가 더 자주 디스크로 기록돼야 한다.&lt;/li>
&lt;li>데이터 파일이 크면 클수록 백업 시간이 오래 걸리며, 복구하는 데도 그만큼의 시간이 걸린다.
&lt;ul>
&lt;li>그만큼 저장 공간이 필요하기 때문에 비용 문제도 있을 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>많은 DBMS가 이러한 문제점을 해결하기 위해 데이터 압축 알고리즘을 제공하면, MySQL 서버에서 사용 가능한 압축 방식은 크게 테이블 압축과 페이지 압축의 두 가지 종류로 구분할 수 있다.&lt;/p>
&lt;h2 id="페이지-압축">페이지 압축&lt;/h2>
&lt;p>페이지 압축은 MySQL 서버가 디스크에 저장하는 시점에 데이터 페이지가 압축되어 저장되고, 반대로 MySQL 서버가 디스크에서 데이터 페이지를 읽어올 때 압축이 해제되어, 버퍼풀에 데이터 페이지가 적재되면 InnoDB 스토리지 엔진은 압축이 해제된 상태로만 데이터 페이지를 관리한다. 이에 따라 서버의 내부 코드에서는 압축 여부와 관계없이 투명(Transparent)하게 작동하여 &lt;strong>Transparent Page Compression&lt;/strong>로 불리기도 한다.&lt;/p>
&lt;p>16KB 데이터 페이지를 압축한 결과가 용량이 얼마나 될지 예측이 불가능한데 적어도 하나의 테이블은 동일한 크기의 페이지(블록)로 통일돼야 한다. 따라서 페이지 압축 기능은 운영체제별로 특정 버전의 파일 시스템에서만 지원되는 펀치홀(Punch hole)이라는 방식을 사용한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>펀치홀이란?&lt;/strong>&lt;br>
운영체제에서 제공하는 파일 시스템 인터페이스 일부로, 파일 내용에서 일부 데이터 블록을 삭제하여 디스크 공간을 확보하는 기능이다.&lt;br>
이전에는 파일 전체를 복사하고 일부분을 수정하는 드으이 방법으로 파일을 수정해야 했으나 시간과 디스크 공간을 많이 소모하게 되어 펀치홀이 개발되었다.&lt;br>
펀치홀은 일부 운영체제에서만 지원되는 기능이며(리눅스), 대용량 파일 시스템에 사용되어 성능을 향상시키는데 도움을 준다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_6/real_mysql_6_1.png"
width="634"
height="323"
srcset="https://codemario318.github.io/post/real_mysql_6/real_mysql_6_1_hu9e1be328866812ff8360a547525aa20f_35207_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_6/real_mysql_6_1_hu9e1be328866812ff8360a547525aa20f_35207_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="196"
data-flex-basis="471px"
>&lt;/p>
&lt;hr>
&lt;ol>
&lt;li>16KB 페이지를 압축(압축 결과를 7KB로 가정)&lt;/li>
&lt;li>MySQL 서버는 디스크에 압축된 결과 7KB를 기록(이때 MySQL 서버는 압축 데이터 7KB에 9KB 빈 데이터를 기록)&lt;/li>
&lt;li>디스크에 데이터를 기록한 후, 7KB 이후의 공간 9KB에 대해 펀치 홀(Punch-hole) 생성&lt;/li>
&lt;li>파일 시스템은 7KB만 남기고 나머지 디스크의 9KB 공간은 다시 운영체제로 반납&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>운영체제(파일 시스템)의 블록 사이즈가 512바이트인 경우, MySQL 서버는 특정 테이블에 대해 16KB 크기의 페이지를 유지하면서도 압축된 다양한 크기의 데이터 페이지를 디스크에 저장하고 압축된 만큼의 공간을 절약할 수 있다.&lt;/p>
&lt;p>&lt;strong>문제점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>펀치홀 기능은 운영체제뿐만 아니라 하드웨어 자체에서도 지원을 해야 사용 가능하다.&lt;/li>
&lt;li>아직 파일 시스템 관련 명령어(유틸리티)가 펀치홀을 지원하지 못한다.&lt;/li>
&lt;/ul>
&lt;p>MySQL 서버의 데이터 파일은 해당 서버에만 머무는 것이 아니라 백업했다가 복구하는 과정에서 데이터 파일 복사 과정이 실행되고, 그 외에도 많은 파일 관련 유틸리티들을 활용한다. 이러한 이유로 실제 페이지 압축은 많이 사용되지 않는 상태이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* 테이블 생성시 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">COMPRESSION&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;zlib&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/* 테이블 변경 시 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">COMPRESSION&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;zlib&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">OPTIMAIZE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="테이블-압축">테이블 압축&lt;/h2>
&lt;p>테이블 압축은 운영체제나 하드웨어에 대한 제약 없이 사용할 수 있기 때문에 일반적으로 더 활용도가 높은편이다. 테이블 압축은 우선 디스크의 데이터 파일의 크기를 줄일 수 있기 때문에 그만큼의 이득은 있지만, 내부적인 처리 과정과 버퍼풀에서 처리 방식으로 인해 몇가지 단점이 존재한다.&lt;/p>
&lt;ul>
&lt;li>버퍼풀 공간 활용률이 낮음&lt;/li>
&lt;li>쿼리 처리 성능이 낮음&lt;/li>
&lt;li>빈번한 데이터 변경시 압축률 떨어짐&lt;/li>
&lt;/ul>
&lt;h3 id="압축-테이블-생성">압축 테이블 생성&lt;/h3>
&lt;p>테이블 압축을 사용하기 위해 압축을 사용하려는 테이블이 별도의 테이블 스페이스를 사용해야 한다.&lt;/p>
&lt;ul>
&lt;li>이를 위해서는 &lt;code>innodb_file_per_table&lt;/code> 시스템 변수가 &lt;code>ON&lt;/code>으로 설정된 상태에서 테이블이 생성돼야 한다.&lt;/li>
&lt;li>테이블 압축을 사용하는 테이블들은 테이블을 생성할 때 &lt;code>ROW_FORMAT=COMPRESSED&lt;/code> 옵션을 명시해야 한다.&lt;/li>
&lt;li>&lt;code>KEY_BLOCK_SIZE&lt;/code> 옵션을 이용해 압축된 페이지의 타깃 크기(목표 크기, 2n(n &amp;gt;= 2))를 명시해야 한다.
&lt;ul>
&lt;li>InnoDB 스토리지 엔진의 페이지 크기가(innodb_page_size)가 16KB 라면 &lt;code>KEY_BLOCK_SIZE&lt;/code>는 4KB 또는 8KB만 설정할 수 있다.&lt;/li>
&lt;li>페이지 크기(&lt;code>innodb_page_size&lt;/code>)가 32KB or 64KB인 경우에는 테이블 압축을 적용할 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_file_per_table&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/** ROW_FORMAT 옵션과 KEY_BLOCK_SIZE 옵션을 모두 명시 **/&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">compressed_table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">c1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">ROW_FORMAT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">COMPRESSED&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">KEY_BLOCK&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> KEY_BLOCK_SIZE 옵션을 모두 명시
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> ROW_FORMAT 옵션이 생략되면 자동으로 ROW_FORMAT=COMPRESSED 옵션이 추가되어 생성
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">**/&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">compressed_table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">c1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ROW_FORMAT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">COMPRESSED&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">KEY_BLOCK&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>&lt;code>innodb_file_per_table&lt;/code> 시스템 변수가 0 인 상태에서 제너럴 테이블스페이스(General Tablespace)에 생성되는 테이블도 테이블 압축을 사용할 수 있으나, 제너럴 테이블스페이스의 FILE_BLOCK_SIZE에 의해 압축을 사용하지 못할 수 있다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="테이블-압축-동작-방식">테이블 압축 동작 방식&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_6/real_mysql_6_2.png"
width="667"
height="564"
srcset="https://codemario318.github.io/post/real_mysql_6/real_mysql_6_2_hu1eec0e327e62387810554f727dd21d6c_42206_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_6/real_mysql_6_2_hu1eec0e327e62387810554f727dd21d6c_42206_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="118"
data-flex-basis="283px"
>&lt;/p>
&lt;p>현재 InnoDB스토리지 엔진의 데이터 페이지 크기가 16KB, &lt;code>KEY_BLOCk_SIZE&lt;/code>가 8로 설정되었다면,&lt;/p>
&lt;hr>
&lt;ol>
&lt;li>16KB의 데이터 페이지를 압축
&lt;ul>
&lt;li>압축된 결과가 8KB 이하이면 그대로 디스크에 저장&lt;/li>
&lt;li>압축된 결과가 8KB를 초과하면 원본 페이지를 스플릿(split)해서 2개의 페이지에 8KB씩 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>나뉜 페이지 각각에 대해 &amp;ldquo;1&amp;rdquo; 단계를 반복 실행&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>테이블 압축 방식에서 가장 중요한 것은 원본 데이터 페이지의 압축 결과가 목표 크기(KEY_BLOCK_SIZE)보다 작거나 같을 때까지 반복해서 페이지를 스플릿하는 것이다.&lt;br>
따라서 목표 크기가 잘못 설정되면 MySQL 서버의 처리 성능이 급격히 떨어질 수 있다.&lt;/p>
&lt;h3 id="key_block_size-결정">&lt;code>KEY_BLOCK_SIZE&lt;/code> 결정&lt;/h3>
&lt;p>테이블 압축에서 가장 중요한 부분은 압축된 결과가 어느 정도가 될지 예측해서 &lt;code>KEY_BLOCK_SIZE&lt;/code>를 결정하는 것이다.&lt;br>
따라서 테이블 압축을 적용하기 전에 먼저 &lt;code>KEY_BLOCK_SIZE&lt;/code>를 4KB 또는 8KB로 테이블을 생성하여 샘플 데이터를 저장해 보고 적절한지 판단하는 것이 좋다.&lt;/p>
&lt;p>이때 샘플 데이터는 많으면 많을수록 더 정확한 테스트가 가능한데, 최소한 테이블 데이터 페이지가 10개 정도는 생성되도록 테스트 데이터를 &lt;code>INSERT&lt;/code>해보는 것이 좋다.&lt;/p>
&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">USE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees_comp4k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">emp_no&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">varchar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">14&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">hire_date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">emp_no&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ix_firstname&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ix_hiredate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hire_date&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">ROW_FORMAT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">COMRESSED&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">KEY_BLOCK_SIZE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 테스트 실행 전 innodb_cmp_per_index_enabled 시스템 변수를 ON으로 변경해야 인덱습려로 압축 실행 횟수와 성공 횟수가 기록된다.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_cmp_per_index_enabled&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees_comp4k&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">table_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">index_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">compress_ops&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">compress_ops_ok&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">compress_ops&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">compress_ops_ok&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">compress_ops&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">compression_failure_pct&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">information_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">INNODB_CMP_PER_INDEX&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>결과&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&amp;hellip;&lt;/th>
&lt;th>index_name&lt;/th>
&lt;th>&amp;hellip;&lt;/th>
&lt;th>compression_failure_pct&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>PRIMARY&lt;/td>
&lt;td>&lt;/td>
&lt;td>27.6737&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>ix_firstname&lt;/td>
&lt;td>&lt;/td>
&lt;td>8.0168&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>ix_hiredate&lt;/td>
&lt;td>&lt;/td>
&lt;td>13.4561&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>실패율이 높다는 의미는 압축 결과가 4KB를 초과하여 데이터 페이지를 스플릿해서 다시 압축을 많이 했다는 뜻이다. 일반적으로 압축 실패율은 3~5%미만으로 유지하는 것이 좋으며 이에 맞추어 &lt;code>KEY_BLOCk_SIZE&lt;/code>를 적절히 조절해야 한다.&lt;/p>
&lt;p>&lt;code>KEY_BLOCk_SIZE&lt;/code>를 크게 설정하였는데도 압출 실패율이 높게 나타난다면, InnoDB 버퍼풀에서 디스크로 기록되기 전에 압축하는 과정에 꽤 오랜 시간이 걸릴 것으로 예측 가능하다. 성능에 민감한 서비스라면 압축을 적용하지 않는 것이 좋을 수 있다.&lt;/p>
&lt;p>압축 실패율이 높다고 해서 무조건 압축을 사용하지 말아야 한다는 것을 의미하지는 않는다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>INSERT&lt;/code>만 되는 로그 테이블은 실패율이 높다고 하더라도 데이터 파일의 크기가 큰 폭으로 줄어든다면 큰 손해는 아닐 수 있다.&lt;/li>
&lt;/ul>
&lt;p>반대로 실패율이 낮다고 해서 무조건 압축을 적용하는 것도 좋지 않을 수 있다.&lt;/p>
&lt;ul>
&lt;li>알고리즘 실행에 적지 않은 CPU 자원을 소비하므로, 테이블의 데이터가 빈번하게 조회되고 변경되는 경우 압축을 적용하지 않는 것이 좋을 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="압축된-페이지의-버퍼풀-적재-및-사용">압축된 페이지의 버퍼풀 적재 및 사용&lt;/h3>
&lt;p>InnoDB 스토리지 엔진은 압축된 테이블의 데이터 페이지를 버퍼풀에 적재하면 압축된 상태와 압축이 해제된 생태 2개 버전을 관리한다. 따라서 InnoDB 스토리지 엔진은 디스크에서 읽은 상태 그대로의 데이터 페이지 목록을 관리하는 LRU 리스트와 압축된 페이지들의 압축 해제 버전인 Unzip_LRU 리스트를 별도로 관리하게 된다.&lt;/p>
&lt;ul>
&lt;li>결국 InnoDB 스토리지 엔진은 압축된 테이블에 대해서는 버퍼풀의 공간을 이주응로 사용함으로써 메모리를 낭비하게 된다.&lt;/li>
&lt;li>압축된 페이지에서 데이터를 읽거나 변경하기 위해서 압축을 해제해야하므로 CPU를 상대적으로 많이 소모한다.&lt;/li>
&lt;/ul>
&lt;p>이러한 단점을 보완하기 위해 Unzip_LRU 리스트를 별도로 관리하고 있다가 MySQL 서버로 유입되는 요청 패턴에 따라 적절히 다음과 같은 처리를 수행한다.&lt;/p>
&lt;ul>
&lt;li>InnoDB 버퍼풀 공간이 필요한 경우에는 LRU 리스트에서 원본 데이터 페이지(압축)는 유지하고, Unzip_LRU 리스트에서 압축 해제된 버전은 제거해서 버퍼풀의 공간을 확보한다.&lt;/li>
&lt;li>압축된 데이터 페이지가 자주 사용되는 경우에는 Unzip_LRU 리스트에 압축 해제된 페이지를 계속 유지하면서 압축 및 압축 해제 작업을 최소화한다.&lt;/li>
&lt;li>압축된 데이터 페이지가 사용되지 않아서 LRU 리스트에서 제거되는 경우에는 Unzip_LRU 리스트에서도 함께 제거된다.&lt;/li>
&lt;/ul>
&lt;p>InnoDB 스토리지 엔진은 버퍼풀에서 압축 해제된 버전의 데이터 페이지를 적절한 수준으로 유지하기 위해 다음과 같은 어댑티브 알고리즘을 사용한다.&lt;/p>
&lt;ul>
&lt;li>CPU 사용량이 높은 서버에서는 가능하면 압축과 압축 헤제를 피하기 위해 Unzip_LRU의 비율을 높에서 유지한다.&lt;/li>
&lt;li>Disk IO 사용량이 높은 서버에서는 가능하면 Unzip_LRU 리스트의 비율을 낮춰 InnoDB 버퍼풀 공간을 더 확보하도록 작동한다.&lt;/li>
&lt;/ul>
&lt;h3 id="테이블-압축-관련-설정">테이블 압축 관련 설정&lt;/h3>
&lt;p>테입르 압축을 사용할 때 연관된 시스템 변수가 몇가지 있는데, 모두 페이지의 압축 실패율을 낮추기 위해 필요한 튜닝 포인트를 제공한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>innodb_cmp_index_enable&lt;/code>&lt;br>
테이블 압축이 사용된 테이블의 모든 인덱스별로 압축 성공 및 압축 실행 횟수를 수집하도록 설정한다.
&lt;ul>
&lt;li>비활성화시 테이블 단위의 압축 성공 및 실행 횟수만 수집&lt;/li>
&lt;li>테이블 단위 수집된 정보: &lt;code>infoamtion_schema.INNODB_CMP&lt;/code>테이블에 기록&lt;/li>
&lt;li>인덱스 단위 수집된 정보: &lt;code>infoamtion_schema.INNODB_CMP_PER_INDEX&lt;/code>테이블에 기록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>innodb_compression_level&lt;/code>&lt;br>
InnoDB의 데이터 압축은 &lt;code>zlib&lt;/code>알고리즘만 지원하는데, 시스템 변수를 이용해 압축률을 설정할 수 있다(0~9).
&lt;ul>
&lt;li>값이 커질수록 느려지고, 작아진다.&lt;/li>
&lt;li>기본값은 6&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>innodb_compression_failure_threshold_pct&lt;/code>&lt;br>
테이블 단위로 압축 실패율이 시스템 설정값 보다 커지면 압축을 실행하기 전 원본 데이터 페이지 끝에 의도적으로 일정 크기의 빈 공간을 추가한다.
&lt;ul>
&lt;li>추가된 빈 공간은 압축률을 높여서 압축 결과가 &lt;code>KEY_BLOCK_SIZE&lt;/code>보다 작아지게 만드는 효과를 낸다.&lt;/li>
&lt;li>추가하는 빈 공간을 패딩이라고 하며, 패딩 공간은 실패율이 높아질수록 계속 증가된 크기를 가진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>innodb_log_compressed_pages&lt;/code>&lt;br>
MySQL 서버가 비정상적으로 종료됐다가 다시 시작되는 경우 압축 알고리즘의 버전 차이가 있더라도 복구 과정이 실패하지 않도록 InnoDB 스토리지 엔진은 압축된 데이터 페이지를 그대로 리두 로그에 기록한다.
&lt;ul>
&lt;li>압축 알고리즘을 덥그레이드 할 대 도움이 되지만, 데이터 페이지를 통째로 로그에 저장하는 것은 리두 로그의 증가량에 상당한 영향을 미칠수도 있다.&lt;/li>
&lt;li>압축을 적용한 후 리두 로그 용량이 매우 빠르게 증가한다건아 버퍼풀로부터 더티 페이지가 한꺼번에 많이 기록되는 패턴으로 바뀌었다면, 해당 변수를 OFF로 설정하여 모니터링 해보는 것이 좋다.&lt;/li>
&lt;li>기본값은 ON, 가능하면 기본값 상태를 유지하자.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>5.3 MySQL의 격리 수준</title><link>https://codemario318.github.io/post/real_mysql_5_3/</link><pubDate>Sat, 22 Apr 2023 15:31:10 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_5_3/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_5_3/real_mysql.jpeg" alt="Featured image of post 5.3 MySQL의 격리 수준" />&lt;p>트랜잭션의 격리 수준(isolation level)이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정한다.&lt;/p>
&lt;ol>
&lt;li>&lt;code>READ UNCOMMITTED&lt;/code>&lt;br>
&lt;code>DIRTY READ&lt;/code>라고도 하며 일반적인 데이터베이스에서는 거의 사용하지 않는다.&lt;/li>
&lt;li>&lt;code>READ COMMITTED&lt;/code>&lt;/li>
&lt;li>&lt;code>REPEATABLE READ&lt;/code>&lt;/li>
&lt;li>&lt;code>SERIALIZABLE&lt;/code>&lt;br>
동시성이 중요한 데이터베이스에서는 거의 사용되지 않는다.&lt;/li>
&lt;/ol>
&lt;p>4개의 격리 수준에서 뒤로 갈수록 각 트랜잭션 간의 데이터 고립 정도가 높아진다. 격리 수준이 높아질수록 MySQL 서버의 처리 성능이 많이 떨어질 것으로 생각하지만, &lt;code>SERIALIZABLE&lt;/code> 격리 수준이 아니라면 크게 성능의 개선이나 저하는 발생하지 않는다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">&lt;/th>
&lt;th style="text-align:center">DIRTY READ&lt;/th>
&lt;th style="text-align:center">NON-REPEATABLE READ&lt;/th>
&lt;th style="text-align:center">PHANTOM READ&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">READ UNCOMMITTED&lt;/td>
&lt;td style="text-align:center">발생&lt;/td>
&lt;td style="text-align:center">발생&lt;/td>
&lt;td style="text-align:center">발생&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">READ COMMITTED&lt;/td>
&lt;td style="text-align:center">없음&lt;/td>
&lt;td style="text-align:center">발생&lt;/td>
&lt;td style="text-align:center">발생&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">REPEATABLE READ&lt;/td>
&lt;td style="text-align:center">없음&lt;/td>
&lt;td style="text-align:center">없음&lt;/td>
&lt;td style="text-align:center">발생(InnoDB X)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">SERIALIZABLE&lt;/td>
&lt;td style="text-align:center">없음&lt;/td>
&lt;td style="text-align:center">없음&lt;/td>
&lt;td style="text-align:center">없음&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>SQL-92, SQL-99 표준에 따르면 &lt;code>REPEATABLE READ&lt;/code> 격리 수준에서는 &lt;code>PHANTOM READ&lt;/code>가 발생할 수 있지만, InnoDB에서는 독특한 특성으로 인해 발생하지 않는다.&lt;/p>
&lt;p>일반적인 온라인 서비스 용도의 데이터베이스는 &lt;code>READ COMMITED&lt;/code>와 &lt;code>REPEATABLE READ&lt;/code> 중 하나를 사용한다.&lt;/p>
&lt;ul>
&lt;li>오라클: &lt;code>READ COMMITED&lt;/code>&lt;/li>
&lt;li>MySQL: &lt;code>REPEATABLE READ&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="read-uncommitted">READ UNCOMMITTED&lt;/h2>
&lt;p>&lt;code>READ UNCOMMITTED&lt;/code> 격리 수준에서는 각 트랜잭션에서 변경 내용이 &lt;code>COMMIT&lt;/code>, &lt;code>ROLLBACK&lt;/code> 여부에 상관 없이 다른 트랜잭션에서 보인다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_5_3/real_mysql_5_3_1.png"
width="483"
height="440"
srcset="https://codemario318.github.io/post/real_mysql_5_3/real_mysql_5_3_1_hu8bfedc3c815f101934f614175f765b59_81960_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_5_3/real_mysql_5_3_1_hu8bfedc3c815f101934f614175f765b59_81960_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="109"
data-flex-basis="263px"
>&lt;/p>
&lt;p>A가 &lt;code>emp_no&lt;/code>가 500000이고 &lt;code>first_name&lt;/code>이 Lara인 새로운 사원을 &lt;code>INSERT&lt;/code> 하는데, B가 변경된 내용을 커밋하기도 전에 &lt;code>emp_no=500000&lt;/code>인 사원을 검색해도 조회 가능하다.&lt;/p>
&lt;p>이에 따라 A의 &lt;code>INSERT&lt;/code>가 &lt;code>ROLLBACK&lt;/code> 되어도, B는 조회한 내용이 정상적인 사원이라고 생각하여 처리하게 된다.&lt;/p>
&lt;p>이처럼 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상을 더티 리드라고 하며, 더티 리드가 허용되는 격리 수준이 &lt;code>READ UNCOMMITTED&lt;/code>이다.&lt;/p>
&lt;p>더티 리드 현상은 데이터가 나타났다 사라지는 현상을 초래하므로 개발자와 사용자를 혼란스럽게 만들 수 있다. 더티 리드를 유발하는 &lt;code>READ UNCOMMITTED&lt;/code>는 &lt;code>RDBMS&lt;/code> 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많으므로 &lt;code>READ COMMITTED&lt;/code> 이상의 격리 수준을 사용할 것을 권장한다.&lt;/p>
&lt;h2 id="read-committed">READ COMMITTED&lt;/h2>
&lt;p>오라클 DBMS에서 기본으로 사용되는 격리 수준이며, 온라인 서비스에서 가장 많이 선택되는 격리 수준이다. 어떤 트랜잭션에서 데이터를 변경했더라도 &lt;code>COMMIT&lt;/code>이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있기 때문에 더티 리드 현상은 발생하지 않는다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_5_3/real_mysql_5_3_2.png"
width="507"
height="441"
srcset="https://codemario318.github.io/post/real_mysql_5_3/real_mysql_5_3_2_huf34101d31019847065ade1c20bab32d5_93822_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_5_3/real_mysql_5_3_2_huf34101d31019847065ade1c20bab32d5_93822_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="114"
data-flex-basis="275px"
>&lt;/p>
&lt;p>A가 &lt;code>emp_no=500000&lt;/code>인 사원의 &lt;code>first_name&lt;/code>을 &amp;ldquo;Lara&amp;quot;에서 &amp;ldquo;Toto&amp;quot;로 변경했는데, 이때 새로운 값인 &amp;ldquo;Toto&amp;quot;는 &lt;code>employees&lt;/code> 테이블에 즉시 기록되고 이전 값인 &amp;ldquo;Lara&amp;quot;는 언두 영역으로 백업된다.&lt;/p>
&lt;p>&lt;code>COMMIT&lt;/code>이 완료 되기 전 B가 &lt;code>emp_no=500000&lt;/code>인 사원의 &lt;code>first_name&lt;/code>을 조회하면, 언두 영역에 백업된 레코드에서 가져온 &amp;ldquo;Lara&amp;quot;를 조회하게 된다.&lt;/p>
&lt;h3 id="non-repeatable-read">NON-REPEATABLE READ&lt;/h3>
&lt;p>&lt;code>READ COMMITTED&lt;/code> 격리 수준에서도 &lt;code>NON-REPEATABLE READ&lt;/code>라는 부정합 문제가 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_5_3/real_mysql_5_3_3.png"
width="480"
height="461"
srcset="https://codemario318.github.io/post/real_mysql_5_3/real_mysql_5_3_3_hub45ba31922b305f9c247d678b3f895cf_95240_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_5_3/real_mysql_5_3_3_hub45ba31922b305f9c247d678b3f895cf_95240_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="104"
data-flex-basis="249px"
>&lt;/p>
&lt;p>B가 &lt;code>BEGIN&lt;/code> 명령으로 트랜잭션을 시작하고 &lt;code>first_name&lt;/code>이 &amp;ldquo;Toto&amp;quot;인 사용자를 검색했는데 일치하는 결과가 없었다. 하지만 A가 사원 번호가 500000인 사원의 이름을 &amp;ldquo;Toto&amp;quot;로 변경하고 커밋을 실행한 후, B가 똑같은 쿼리로 다시 조회하면 1건이 조회된다.&lt;/p>
&lt;p>중요한 포인트는 사용자가 동일 트랜잭션 내에서 같은 쿼리를 활용하여 조회했는데도 불구하고 다른 결과를 조회해 온 것이며, 이는 &lt;strong>하나의 트랜잭션 내에서 똑같은 &lt;code>SELECT&lt;/code> 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 &lt;code>REPEATABLE READ&lt;/code> 정합성&lt;/strong>에 어긋나는 것이다.&lt;/p>
&lt;p>이러한 부정합 현상은 일반적인 웹 프로그램에서는 크게 문제되지 않을 수 있지만 하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수도 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>트랜잭션 내에서 실행되는 SELECT 문장과 트랜잭션 없이 실행되는 SELECT 문장의 차이&lt;/strong>&lt;br>
&lt;code>READ COMMITTED&lt;/code> 격리 수준에서는 차이가 별로 없으나 &lt;code>REPEATABLE READ&lt;/code> 격리 수준에서는 &lt;code>SELECT&lt;/code> 쿼리도 트랜잭션 범위 내에서만 작동한다.&lt;br>
즉 트랜잭션을 시작한 상태에서 &lt;code>SELECT&lt;/code> 쿼리를 실행한다면, 다른 트랜잭션에서 데이터를 변경하고 &lt;code>COMMIT&lt;/code> 되었다고 하더라도 동일한 결과를 반환한다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="repeatable-read">REPEATABLE READ&lt;/h2>
&lt;p>MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다. 바이너리 로그를 가진 MySQL 서버에서는 최소 &lt;code>REPEATABLE READ&lt;/code> 격리 수준 이상을 사용해야 한다.&lt;/p>
&lt;p>InnoDB 스토리지 엔진의 &lt;code>REPEATABLE READ&lt;/code> 격리수준에서는 트랜잭션이 &lt;code>ROLLBACK&lt;/code>될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경하고(MVCC) 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장하므로 &lt;code>NON-REPEATABLE READ&lt;/code> 부정합이 발생하지 않는다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>REPEATABLE READ&lt;/code>와 &lt;code>READ COMMITTED&lt;/code>의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있다.&lt;/p>
&lt;/blockquote>
&lt;p>InnoDB의 모든 트랜잭션은 고유한 트랜잭션 번호(순차적으로 증가하는 값)를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션 번호가 포함되어 있다. 언두 영역에 백업된 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제한다.&lt;/p>
&lt;p>&lt;code>REPEATABLE READ&lt;/code> 격리 수준에서는 MVCC를 보장하기 위해 실행중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수가 없다. 그렇다고 가장 오래된 트랜잭션 번호 이전의 트랜잭션에 의해 변경된 모든 언두 데이터가 필요한 것은 아니며, 특정 트랜잭션 번호의 구간 내에서 백업된 언두 데이터가 보존 돼야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_5_3/real_mysql_5_3_4.png"
width="537"
height="612"
srcset="https://codemario318.github.io/post/real_mysql_5_3/real_mysql_5_3_4_hu3774675e9e7b708e8581ff00eef375a8_148898_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_5_3/real_mysql_5_3_4_hu3774675e9e7b708e8581ff00eef375a8_148898_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="87"
data-flex-basis="210px"
>&lt;/p>
&lt;p>12번 트랜잭션에서 사원 이름을 &amp;ldquo;Toto&amp;quot;로 변경하고 커밋을 수행했다. 하지만 10번 트랜잭션에서 12번 트랜잭션 커밋 전 후로 해당 사원을 조회해도 자신의 트랜잭션 번호보다 작은 트랜잭션에서 변경한 것만 보게 되므로, 이전 값인 &amp;ldquo;Lara&amp;quot;를 받아온다.&lt;/p>
&lt;blockquote>
&lt;p>트랜잭션을 시작하고 장시간 종료하지 않으면 언두 영역이 백업된 데이터로 무한정 커질 수도 있으며, 이로 인해 백업된 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="phantom-read">PHANTOM READ&lt;/h3>
&lt;p>&lt;code>REPEATABLE READ&lt;/code> 격리 수준에서도 부정합이 발생 가능하다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_5_3/real_mysql_5_3_5.png"
width="566"
height="592"
srcset="https://codemario318.github.io/post/real_mysql_5_3/real_mysql_5_3_5_hu957d9367aefd1e011547afa2e94b6d81_137043_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_5_3/real_mysql_5_3_5_hu957d9367aefd1e011547afa2e94b6d81_137043_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="95"
data-flex-basis="229px"
>&lt;/p>
&lt;p>A가 &lt;code>employees&lt;/code> 테이블에 &lt;code>INSERT&lt;/code>를 실행하는 도중 B가 &lt;code>SELECT ... FOR UPDATE&lt;/code> 쿼리로 테이블을 2번 조회하는데 다른 결과를 반환하고 있다.&lt;/p>
&lt;p>&lt;code>SELECT ... FOR UPDATE&lt;/code> 쿼리는 &lt;code>SELECT&lt;/code>하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없다. 따라서 &lt;code>SELECT ... FOR UPDATE&lt;/code>나 &lt;code>SELECT ... LOCK IN SHARE MODE&lt;/code>로 조회되는 레코드는 언두 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드의 값을 가져오게 된다.&lt;/p>
&lt;p>이렇게 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상을 &lt;code>PHANTOM READ(PHANTOM ROW)&lt;/code>라고 한다.&lt;/p>
&lt;h2 id="serializable">SERIALIZABLE&lt;/h2>
&lt;p>가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준이다. 그만큼 동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어진다.&lt;/p>
&lt;p>InnoDB 테이블에서 기본적으로 순수한 &lt;code>SELECT&lt;/code> 작업은 아무런 레코드 잠금도 설정하지 않고 실행(Non-locking consistent read: 잠금이 필요없는 일관된 읽기)되지만 트랜잭션의 격리 수준이 &lt;code>SERIALIZABLE&lt;/code>로 설정되면 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야만 하며, 동시에 다른 트랜잭션은 레코드를 변경하지 못하게 된다. 따라서 &lt;code>SERIALIZABLE&lt;/code> 격리 수준에서는 일반적인 DBMS에서 일어나는 &lt;code>PHANTOM READ&lt;/code> 문제가 발생하지 않는다.&lt;/p>
&lt;p>하지만 InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 &lt;code>REPEATABLE READ&lt;/code> 격리 수준에서도 &lt;code>PHANTOM READ&lt;/code>가 발생하지 않아 굳이 사용할 필요성은 없다.&lt;/p>
&lt;blockquote>
&lt;p>엄밀하게는 &lt;code>SELECT ... FOR UPDATE&lt;/code>, &lt;code>SELECT ... FOR SHARE&lt;/code> 쿼리의 경우 &lt;code>REPEATABLE READ&lt;/code> 격리수준에서 &lt;code>PHANTOM READ&lt;/code> 현상이 발생할 수 있다.&lt;br>
하지만 레코드의 변경 이력(언두 레코드)에 잠금을 걸 수는 없기 때문에, 이러한 잠금을 동반한 &lt;code>SELECT&lt;/code> 쿼리는 예외적인 상황으로 볼 수 있다.&lt;/p>
&lt;/blockquote></description></item><item><title>5.2 잠금</title><link>https://codemario318.github.io/post/real_mysql_5_2/</link><pubDate>Sat, 22 Apr 2023 15:30:10 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_5_2/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_5_2/real_mysql.jpeg" alt="Featured image of post 5.2 잠금" />&lt;p>잠금은 동시성을 제어하기 위한 기능으로 하나의 데이터를 여러 커넥션에서 동시에 동일한 자원(레코드나 테이블)을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>MySQL 엔진 레벨&lt;br>
모든 스토리지에 영향을 미친다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>스토리지 엔진 레벨&lt;br>
스토리지 엔진 간 상호 영향을 미치지는 않는다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="mysql-엔진의-잠금">MySQL 엔진의 잠금&lt;/h2>
&lt;h3 id="글로벌-락">글로벌 락&lt;/h3>
&lt;p>글로벌 락은 &lt;code>FLUSH TABLES WITH READ LOCK&lt;/code> 명령으로 획득할 수 있으며, MySQL에서 제공하는 잠금 가운데 가장 범위가 크다. 한 세션에서 글로벌 락을 획득하면 다른 세션에서 &lt;code>SELECT&lt;/code>를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우 락이 해제될 때까지 대기 상태로 남는다.&lt;/p>
&lt;p>글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이며, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다. 여러 데이터베이스에 존재하는 MyISAM이나 MEMORY 테이블에 대해 &lt;code>mysqldump&lt;/code>로 일관된 백업을 받아야 할 때는 글로벌 락을 사용해야 한다.&lt;/p>
&lt;blockquote>
&lt;p>글로벌 락을 거는 &lt;code>FLUSH TABLES WITH READ LOCK&lt;/code> 명령은 실행과 동시에 서버에 존재하는 모든 테이블을 닫고 잠금을 거는데, 읽기 잠금을 걸기 전에 먼저 테이블을 플러시 해야 하기 때문에 실행 중인 모든 종류의 쿼리가 완료돼야 한다. 명령이 실행되기 전에 테이블이나 레코드에 쓰기 잠금을 거는 SQL이 실행되었다면 해당 테이블의 읽기 잠금을 걸기 위해 먼저 실행된 SQL과 그 트랜잭션이 완료될 때 까지 기다려야 한다.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>장시간 실행되는 쿼리와 &lt;code>FLUSH TABLES WITH READ LOCK&lt;/code> 명령이 최악의 케이스로 실행되면 서버의 모든 쿼리가 오랜 시간 실행되지 못하고 대기할 수 있다.&lt;/p>
&lt;/blockquote>
&lt;h4 id="백업락">백업락&lt;/h4>
&lt;p>MySQL 8부터 InnoDB가 기본 스토리지 엔진으로 채택되었고, InnoDB 스토리지 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요는 없기 때문에 조금 더 가벼운 글로벌 락의 필요성이 생겼고, 백업 락이 도입되었다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">LOCK&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">INSTANCE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FOR&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">BACKUP&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">UNLOCK&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">INSTANCE&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>특정 세션에서 백업 락을 획득하면 모든 세션에서 다음과 같이 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 되지만, 일반적인 테이블의 데이터 변경은 허용된다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제&lt;/li>
&lt;li>&lt;code>REPAIR TABLE&lt;/code>과 &lt;code>OPTIMIZE TABLE&lt;/code> 명령&lt;/li>
&lt;li>사용자 관리 및 비밀번호 변경&lt;/li>
&lt;/ul>
&lt;h3 id="테이블-락">테이블 락&lt;/h3>
&lt;p>테이블락은 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획들할 수 있다.
MyISAM뿐 아니라 InnoDB 스토리지 엔진을 사용하는 테이블도 동일하게 설정 가능하다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>명시적: &lt;code>LOCK TABLES table_name [ READ | WRITE ]&lt;/code> 명령&lt;/p>
&lt;ul>
&lt;li>&lt;code>UNLOCK TABLES&lt;/code> 명령으로 해제&lt;/li>
&lt;li>특별한 상황이 아니면 애플리케이션에서 사용할 필요가 거의 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>묵시적: 테이블에 데이터를 변경하는 쿼리를 실행하면 발생&lt;/p>
&lt;ul>
&lt;li>MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고, 변경한 후 즉시 잠금을 해제한다.&lt;/li>
&lt;li>InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않고, DDL의 경우에만 영향을 미친다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="네임드-락">네임드 락&lt;/h3>
&lt;p>네임드 락은 &lt;code>GET_LOCK()&lt;/code> 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다. 잠금 대상이 테이블이나 레코드 또는 &lt;code>AUTO_INCREMENT&lt;/code>와 같은 데이터베이스 객체가 아니라 사용자가 지정한 문자열(String)에 대해 획득하고 반납하는 잠금이다.&lt;/p>
&lt;p>네임드 락은 자주 사용되지는 않지만, 여러 클라이언트가 상호 동기화를 처리해야 할 때 네임드 락을 이용하면 쉽게 해결할 수 있다.&lt;/p>
&lt;p>많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용할 수 있다.
배치 프로그램처럼 한꺼번에 많은 레코드를 변경하는 쿼리는 데드락의 원인이 되곤 하는데, 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 아주 간단히 해결할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- &amp;#34;mylock&amp;#34; 이라는 문자열에 대해 잠금을 획득
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">GET_LOCK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;mylock&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-- &amp;#34;mylock&amp;#34; 이라는 문자열에 대해 잠금 설정 확인
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">IS_FREE_LOCK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;mylock&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-- &amp;#34;mylock&amp;#34; 이라는 문자열에 대해 잠금을 반납(해제)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RELEASE_LOCK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;mylock&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>MySQL 8 버전부터는 네임드 락을 중첩해서 사용할 수 있게 되었으며, 현재 세션에서 획득한 네임드 락을 한번에 모두 해제하는 기능도 추가되었다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">GET_LOCK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;mylock_1&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">GET_LOCK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;mylock_2&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RELEASE_LOCK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;mylock_1&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RELEASE_LOCK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;mylock_2&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RELEASE_ALL_LOCKS&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="메타데이터-락">메타데이터 락&lt;/h3>
&lt;p>메타데이터 락은 데이터베이스 객체(테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우 획득하는 잠금이다. 명시적으로 획득하거나 해제할 수 없고, 테이블의 이름을 변경하는 경우 자동으로 획득한다.&lt;/p>
&lt;p>&lt;code>READ TABLE&lt;/code> 명령의 경우 원본 이름과 변경될 이름 두 개 모두 한꺼번에 잠금을 설정한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">RENAME&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rank&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rank_backup&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rank_new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rank&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위와 같이 하나의 &lt;code>RENAME TABLE&lt;/code> 명령문에 두 개의 &lt;code>RENAME&lt;/code> 작업을 한번에 실행하면 실제 애플리케이션에서는 &amp;ldquo;&lt;code>Table not found 'rank'&lt;/code>&amp;ldquo;같은 상황을 발생시키지 않고 적용하는 것이 가능하다.&lt;/p>
&lt;p>하지만 이 문장을 나누어 실행하면 아주 짧은 시간이지만 rank 테이블이 존재하지 않는 순간이 생기며, 그 순간에 실행되는 쿼리는 오류를 발생시킨다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">RENAME&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rank&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rank_backup&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">RENAME&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rank_new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rank&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="메타데이터-잠금과-트랜잭션-동시-활용">메타데이터 잠금과 트랜잭션 동시 활용&lt;/h4>
&lt;p>때로는 메타데이터 잠금과 InnoDB의 트랜잭션을 동시에 사용해야 하는 경우도 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">BIGINT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">AUTO_INCREMENT&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위와 같이 &lt;code>INSERT&lt;/code>만 실행되는 로그 테이블이 있을때, 이 테이블의 구조를 변경해야 한다면 Online DDL을 이용하여 변경할 수 도 있지만, 시간이 너무 오래 걸리는 경우 언두 로그의 증가와 Online DDL이 실행되는 동안 누적된 Online DDL 버퍼의 크기 등 고민해야 할 문제가 많다. 더 큰 문제는 MySQL서버의 DDL은 단일 스레드로 작동하기 대문에 상당히 많은 시간이 소모된다.&lt;/p>
&lt;p>이때는 새로운 구조의 테이블을 생성하고 먼저 최근 데이터까지는 프라이머리 키인 id 값을 범위별로 나눠서 여러 개의 스레드로 빠르게 복사하고, 나머지 데이터는 트랜잭션과 테이블 잠금, RENAME TABLE 명령으로 응용 프로그램의 중단 없이 실행할 수 있다.&lt;/p>
&lt;p>이때 남은 데이터를 복사 하는 시간 동안은 테이블의 잠금으로 인해 INSERT를 할 수 없게 되어 가능하면 미리 아주 최근 데이터까지 복사해 둬야 잠금 시간을 최소화하여 서비스에 미치는 영향을 줄일 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log_new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">BIGINT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">AUTO_INCREMENT&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">KEY_BLOCK_SIZE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log_new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10000&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log_new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10000&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">20000&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log_new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">20000&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">30000&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log_new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">30000&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">40000&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">autocommit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LOCK&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TABLES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WRITE&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log_new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WRITE&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">MAX&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@&lt;/span>&lt;span class="n">MAX_ID&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log_new&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log_new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">pk&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@&lt;/span>&lt;span class="n">MAX_ID&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">COMMIT&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">RENAME&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log_old&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log_new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">UNLOCK&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TABLES&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">DROP&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">access_log_old&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="innodb-스토리지-엔진-잠금">InnoDB 스토리지 엔진 잠금&lt;/h2>
&lt;p>InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다. 이러한 레코드 기반 잠금 방식 덕뿐에 MyISAM보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다.&lt;/p>
&lt;p>하지만 이원화된 잠금 처리로 인해 InnoDB 스토리지 엔진에서 사용되는 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기 까다롭고, 내용도 어셈블리 코드를 보는 것 같아서 이해하기 어려웠다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>lock_monitor&lt;/code>
&lt;ul>
&lt;li>&lt;code>innodb_lock_monitor&lt;/code>라는 이름의 InnoDB 테이블을 생성하여 잠금 정보를 덤프하는 방법&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>SHOW ENGINE INNODB STATUAS&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>최근 버전에서 InnoDB의 트랜잭션과 잠금, 잠금 대기중인 트랜잭션의 목록을 조회할 수 있는 방법이 도입되었다.&lt;/p>
&lt;ul>
&lt;li>MySQL 서버의 &lt;code>information_schema&lt;/code> 데이터베이스
&lt;ul>
&lt;li>&lt;code>INNODB_TRX&lt;/code>, &lt;code>INNODB_LOCKS&lt;/code>, &lt;code>INNODB_LOCK_WAITS&lt;/code> 테이블 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Performance Schema&lt;/code>
&lt;ul>
&lt;li>InnoDB 스토리지 엔진의 내부 잠금(세마포어)에 대한 모니터링&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="innodb-스토리지-엔진의-잠금">InnoDB 스토리지 엔진의 잠금&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_5_2/real_mysql_5_2_1.png"
width="568"
height="391"
srcset="https://codemario318.github.io/post/real_mysql_5_2/real_mysql_5_2_1_huce10c04fd991a9d92b7f64aa4285a0fb_125963_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_5_2/real_mysql_5_2_1_huce10c04fd991a9d92b7f64aa4285a0fb_125963_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="348px"
>&lt;/p>
&lt;p>InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락, 테이블 락으로 락 에스컬레이션 되는 경우는 없다.&lt;/p>
&lt;p>레코드 락 뿐만 아니라 레코드와 레코드 사이의 간격을 잠그는 갭 락도 존재한다.&lt;/p>
&lt;h4 id="레코드락">레코드락&lt;/h4>
&lt;p>레코드 자체만 잠그는 것을 레코드 락(Record lock, Record only lock)이라고 하며, 다른 상용 DBMS의 레코드 락과 동일한 역할을 한다. 중요한 차이는 InnoDB 스토리지 엔진은 &lt;strong>레코드 자체가 아니라 인덱스의 레코드를 잠근다&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.&lt;/li>
&lt;/ul>
&lt;p>따라서 InnoDB에서는 대부분 보조 인덱스를 이용한 변경 작업은 이어서 설명할 넥스트 키 락(Next key lock) 또는 갭 락(Gap lock)을 사용하지만 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.&lt;/p>
&lt;h4 id="갭-락">갭 락&lt;/h4>
&lt;p>갭 락은 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다. 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(&lt;code>INSERT&lt;/code>)되는 것을 제어한다.&lt;/p>
&lt;ul>
&lt;li>갭 락은 그 자체보다는 넥스트 키 락의 일부로 자주 사용된다.&lt;/li>
&lt;/ul>
&lt;h4 id="넥스트-키-락">넥스트 키 락&lt;/h4>
&lt;p>레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락(Next key lock)이라고 한다.&lt;/p>
&lt;p>&lt;code>STATEMENT 포맷&lt;/code>의 바이너리 로그를 사용하는 MySQL 서버에서는 &lt;code>REPEATABLE READ&lt;/code> 격리 수준을 사용해야 한다. 또한 &lt;code>innodb_locks_unsafe_for_binlog&lt;/code> 시스템 변수가 비활성화되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸린다.&lt;/p>
&lt;p>InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 &lt;strong>레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어 내도록 보장하는 것&lt;/strong>이 주목적이다.&lt;/p>
&lt;blockquote>
&lt;p>넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생하므로, 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.&lt;/p>
&lt;/blockquote>
&lt;h4 id="자동-증가-락">자동 증가 락&lt;/h4>
&lt;p>MySQL에서는 자동 증가하는 숫자 값을 추출하기 위해 &lt;code>AUTO_INCREMENT&lt;/code>라는 컬럼 속성을 제공한다. &lt;code>AUTO_INCREMENT&lt;/code> 컬럼이 사용된 테이블에 동시에 여러 레코드가 &lt;code>INSERT&lt;/code> 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 한다. 이를 위해 내부적으로 &lt;strong>AUTO_INCREMENT 락&lt;/strong>이라고 하는 테이블 수준의 잠금을 사용한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>AUTO_INCREMENT&lt;/code>락은 &lt;code>INSERT&lt;/code>, &lt;code>REPLACE&lt;/code> 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하다.&lt;/li>
&lt;li>InnoDB의 다른 잠금과 달리 트랜잭션과 관계 없이 &lt;code>INSERT&lt;/code>나 &lt;code>REPLACE&lt;/code> 문장에서 &lt;code>AUTO_INCREMENT&lt;/code> 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다.&lt;/li>
&lt;li>&lt;code>AUTO_INCREMENT&lt;/code> 락은 테이블에 단 하나만 존재하기 대문에 두 개의 &lt;code>INSERT&lt;/code> 쿼리가 동시에 실행되는 경우 하나의 쿼리가 락을 걸면 나머지 쿼리는 락을 기다려야 한다.
&lt;ul>
&lt;li>&lt;code>AUTO_INCREMENT&lt;/code> 컬럼에 명시적으로 값을 설정하더라도 자동 증가 락을 걸게 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&lt;code>innodb_autoinc_lock_mode&lt;/code>&lt;/strong>&lt;br>
MySQL 5.0 이하 버전에서는 AUTO_INCREMENT 락을 명시적으로 획득하고 해제하는 방법은 없다. 하지만 아주 짧은 시간동안 걸렸다가 해제되는 잠금이라서 대부분의 경우 문제가 되지 않는다.&lt;/p>
&lt;p>MySQL 5.1 이상 부터는 &lt;code>innodb_autoinc_lock_mode&lt;/code> 시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경할 수 있다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>innodb_autoinc_lock_mode=0&lt;/code>&lt;br>
모든 &lt;code>INSERT&lt;/code> 문장이 자동 증가 락을 사용한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>innodb_autoinc_lock_mode=1&lt;/code>&lt;br>
&lt;code>INSERT&lt;/code>하는 쿼리 중에서 MySQL 서버가 &lt;code>INSERT&lt;/code>되는 레코드의 건수를 정확히 예측할 수 있을 때는 자동 증가 락을 사용하지 않고, 훨씬 가볍고 빠른 래치(뮤텍스)를 이용해 처리한다.&lt;/p>
&lt;ul>
&lt;li>개선된 래치는 자동 증가 락과 달리 아주 짧은 시간 동안만 잠금을 걸고 필요한 자동 증가 값을 가져오면 즉시 잠금이 해제된다.&lt;/li>
&lt;li>건수를 예측할 수 없을때는 이전 같이 자동 증가 락을 사용한다.&lt;/li>
&lt;li>한번에 할당 받은 자동 증가 값이 남아서 사용되지 못하면 폐기하므로 레코드 자동 증가 값은 연속되지 않고 누락된 값이 발생할 수 있다.&lt;/li>
&lt;li>하나의 &lt;code>INSERT&lt;/code> 문장으로 &lt;code>INSERT&lt;/code> 되는 레코드는 연속된 자동 증가 값을 가지게 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>innodb_autoinc_lock_mode=2&lt;/code>&lt;br>
절대로 자동 증가 락을 걸지 않고 경량화된 래치(뮤텍스)를 사용한다.&lt;/p>
&lt;ul>
&lt;li>설정에서는 하나의 &lt;code>INSERT&lt;/code> 문장으로 &lt;code>INSERT&lt;/code> 되는 레코드라 하더라도 연속된 자동 증가값을 보장하지는 않는다.&lt;/li>
&lt;li>&lt;code>INSERT ... SELECT&lt;/code>와 같은 대량 &lt;code>INSERT&lt;/code> 문장이 실행되는 중에도 다른 커넥션에서 &lt;code>INSERT&lt;/code>를 수행할 수 있으므로 동시 처리 성능이 높아진다.&lt;/li>
&lt;li>자동 증가 기능은 유니크한 값이 생성된다는 것만 보장한다. 따라서 소스 서버와 레플리카 서버의 자동 증가 값이 달라질 수 있어 주의해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>MySQL 5.7 까지는 기본값이 1이었으나, 8버전 바이너리 로그 포맷이 &lt;code>STATEMENT&lt;/code>가 아니라 &lt;code>ROW&lt;/code>로 변경되었기 때문에 2로 바뀌었다. &lt;code>ROW&lt;/code> 포맷이 아니라 &lt;code>STATEMENT&lt;/code> 포맷의 바이너리 로그를 사용한다면 1로 변경해서 사용해야 한다.&lt;/p>
&lt;/blockquote>
&lt;p>자동 증가 값이 한 번 증가하면 절대 줄어들지 않는 이유는 &lt;code>AUTO_INCREMENT&lt;/code> 잠금을 최소화 하기 위해서다. &lt;code>INSERT&lt;/code> 쿼리가 실패했더라도 한 번 증가된 &lt;code>AUTO_INCREMENT&lt;/code> 값은 다시 줄어들지 않고 그대로 남는다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>래치(Latch)란?&lt;/strong>&lt;br>
DBMS에서 여러 스레드 혹은 프로세스가 동시에 접근할 수 있는 데이터에 대한 접근 제어 기술 중 하나이다.&lt;br>
래치는 뮤텍스(Mutex)와 유사한 개념이지만, 뮤텍스는 오직 한 스레드 혹은 프로세스만이 해당 자원에 접근할 수 있도록 하는 동기화 기술이고, &lt;em>&lt;strong>래치는 여러 개의 스레드 혹은 프로세스가 읽기만 가능하고 쓰기는 하나의 스레드 혹은 프로세스만 가능하도록 하는&lt;/strong>&lt;/em> 동기화 기술이다.&lt;br>
래치는 &lt;strong>읽기 래치&lt;/strong>와 &lt;strong>쓰기 래치&lt;/strong>로 구분되며, &lt;strong>읽기 래치&lt;/strong>는 여러 스레드 혹은 프로세스가 동시에 해당 데이터를 읽을 수 있게 하고, &lt;strong>쓰기 래치&lt;/strong>는 오직 하나의 스레드 혹은 프로세스만 해당 데이터를 변경할 수 있게 한다.&lt;br>
래치는 주로 인덱스 구조나 버퍼풀 등에서 사용되며, 동시성을 높이기 위해 적극적으로 활용된다. 그러나 래치를 과도하게 사용하거나 사용 방법이 부적절할 경우 데드락(deadlock) 등의 문제가 발생할 수 있으므로 주의해서 사용해야 한다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="인덱스와-잠금">인덱스와 잠금&lt;/h3>
&lt;p>InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다. 즉 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">--// KEY ix_firstname (first_name)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COUNT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;Georgi&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">+---+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">|253|
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">+---+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">*/&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COUNT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;Georgi&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">last_name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;Klassen&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">+---+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">| 1|
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">+---+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">*/&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">UPDATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">hire_date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">NOW&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;Georgi&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">last_name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;Klassen&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>UPDATE&lt;/code> 쿼리가 실행되면 1건의 레코드가 업데이트 되지만, &lt;code>UPDATE&lt;/code> 문장의 조건에서 인덱스를 이용할 수 있는 조건은 &lt;code>first_name&lt;/code>뿐이며, &lt;code>last_name&lt;/code> 컬럼은 인덱스가 없기 때문에 &lt;code>first_name='Georgi'&lt;/code>인 레코드 253건의 레코드가 모두 잠긴다.&lt;/p>
&lt;p>&lt;code>UPDATE&lt;/code> 문장을 위해 적절히 인덱스가 준비돼 있지 않다면 각 클라이언트 간의 동시성이 상당히 떨어져서 한 세션에서 &lt;code>UPDATE&lt;/code> 작업을 하는 중에는 다른 클라이언트는 테이블을 업데이트하지 못하고 기다려야 하는 상황이 발생한다.&lt;/p>
&lt;p>만약 &lt;code>employees&lt;/code> 테이블에 인덱스가 하나도 없다면, 테이블을 풀스캔 하면서 &lt;code>UPDATE&lt;/code>를 수행하기 때문에 테이블에 있는 모든 레코드를 잠그게 된다.&lt;/p>
&lt;h3 id="레코드-수준의-잠금-확인-및-해제">레코드 수준의 잠금 확인 및 해제&lt;/h3>
&lt;p>InnoDB 스토리지 엔진을 사용하는 테이블의 레코드 수준 잠금은 테이블 수준의 잠금보다는 조금 더 복잡하다.&lt;/p>
&lt;p>테이블 잠금에서는 잠금의 대상이 테이블 자체이므로 쉽게 문제의 원인이 발견되고 해결될 수 있으나, 레코드 수준의 잠금은 테이블의 레코드 각각에 잠금이 걸리므로 그 레코드가 자주 사용되지 않는다면 오랜 시간 동안 잠겨진 상태로 남아 있어도 잘 발견되지 않는다.&lt;/p>
&lt;p>예전 버전의 MySQL 서버에서는 레코드 잠금에 대한 메타 정보를 제공하지 않았기 때문에 어려웠지만, 5.1 버전부터는 레코드 잠금과 잠금 대기에 대한 조회가 가능하므로 쿼리 하나만 실행하면 잠금과 잠금 대기 상태를 바로 확인할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>MySQL 5.1 +&lt;/strong>&lt;br>
&lt;code>information_schema&lt;/code>라는 DB에 &lt;code>INNODB_TRX&lt;/code>, &lt;code>INNODB_LOCKS&lt;/code>, &lt;code>INNODB_LOCK_WAITS&lt;/code> 라는 테이블을 통해 확인&lt;/li>
&lt;li>&lt;strong>MySQL 8.0 +&lt;/strong>&lt;br>
&lt;code>information_schema&lt;/code>의 정보들은 조금씩 제거되고 있다.
&lt;ul>
&lt;li>&lt;code>performance_schema&lt;/code>의 &lt;code>data_locks&lt;/code>, &lt;code>data_lock_waits&lt;/code>로 확인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>5.1 트랜잭션</title><link>https://codemario318.github.io/post/real_mysql_5_1/</link><pubDate>Sat, 22 Apr 2023 15:29:10 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_5_1/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_5_1/real_mysql.jpeg" alt="Featured image of post 5.1 트랜잭션" />&lt;p>트랜잭션은 작업의 완전성을 보장해 주는 것이다.&lt;br>
논리적이 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상(Partial update)이 발생하지 않게 만들어주는 기능이다.&lt;/p>
&lt;p>트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합됐을 때만 의미있는 개념은 아니다. 트랜잭션은 하나의 논리적인 작업 셋이 100% 적용되거나(&lt;code>COMMIT&lt;/code>) 아무것도 적용되지 않아야(&lt;code>ROLLBACK&lt;/code>)함을 보장해 주는 것이다.&lt;/p>
&lt;h2 id="mysql에서의-트랜잭션">MySQL에서의 트랜잭션&lt;/h2>
&lt;p>MySQL에서 InnoDB와 달리 MyISAM과 MEMORY 스토리지 엔진은 트랜잭션을 제공하지않는다. 처리방식의 차이를 확인하고, 트랜잭션을 사용할 때 주의할 점을 알아야 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tab_myisam&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fdpk&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fdpk&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">MyISAM&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tab_myisam&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fdpk&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">VALUE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tab_myInnodb&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fdpk&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fdpk&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">INNODB&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tab_myInnodb&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fdpk&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">VALUE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">autocommit&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tab_myisam&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fdpk&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">ERROR 1062 (23000): Duplicate entry &amp;#39;3&amp;#39; for key &amp;#39;PRIMARY&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">+----+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">|fdpk|
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">+----+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">| 1|
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">+----+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">| 2|
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">+----+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">| 3|
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">+----+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">*/&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tab_myinnodb&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fdpk&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">ERROR 1062 (23000): Duplicate entry &amp;#39;3&amp;#39; for key &amp;#39;PRIMARY&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">+----+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">|fdpk|
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">+----+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">| 3|
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">+----+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">*/&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>두 테이블의 &lt;code>INSERT&lt;/code> 문장이 프라이머리 키 중복 오류로 실패했으나, MyISAM 테이블은 &lt;code>INSERT&lt;/code> 문장이 순차적으로 실행되고 즉시 반영된다. 따라서 1과 2를 저장하고 3을 저장할 때 오류가 발생하여 쿼리 실행이 종료되며, 기존에 실행되었던 &lt;code>INSERT&lt;/code>로 테이블에 1, 2가 저장되었고 오류로 실패해도 그대로 유지된다. MEMORY 스토리지 엔진도 동일한 방식으로 처리된다.&lt;/p>
&lt;p>반면 InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만든다는 트랜잭션의 원칙대로 &lt;code>INSERT&lt;/code> 문장을 실행하기 전 상태로 복구한다.&lt;/p>
&lt;p>MyISAM에서 발생한 이러한 현상을 부분 업데이트(Partial Update)라고 표현하며, 테이블 데이터의 정합성을 맞추기 위해 실패한 쿼리로 인해 남은 레코드를 다시 삭제하는 등 어려운 문제를 만들어 낸다.&lt;/p>
&lt;h2 id="주의사항">주의사항&lt;/h2>
&lt;p>트랜잭션 또한 DBMS의 커넥션과 동일하게 트랜잭션의 범위를 최소화 하여, 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.&lt;/p>
&lt;h3 id="as-is">AS-IS&lt;/h3>
&lt;hr>
&lt;ol>
&lt;li>처리 시작
&lt;ul>
&lt;li>데이터베이스 커넥션 생성&lt;/li>
&lt;li>트랜잭션 시작&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자의 로그인 여부 확인&lt;/li>
&lt;li>사용자의 글쓰기 내용의 오류 여부 확인&lt;/li>
&lt;li>첨부로 업로드된 파일 확인 및 저장&lt;/li>
&lt;li>사용자의 입력 내용을 DBMS에 저장&lt;/li>
&lt;li>첨부 파일 정보를 DBMS에 저장&lt;/li>
&lt;li>저장된 내용 또는 기타 정보를 DBMS에서 조회&lt;/li>
&lt;li>게시물 등록에 대한 알림 메일 발송&lt;/li>
&lt;li>알림 메일 발송 이력을 DBMS에 저장
&lt;ul>
&lt;li>트랜잭션 종료(&lt;code>COMMIT&lt;/code>)&lt;/li>
&lt;li>데이터베이스 커넥션 반납&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>처리완료&lt;/li>
&lt;/ol>
&lt;hr>
&lt;ul>
&lt;li>
&lt;p>데이터베이스의 커넥션 생성하고 트랜잭션을 시작하는 부분&lt;/p>
&lt;ul>
&lt;li>실제로 DBMS에 데이터를 저장하는 작업은 5번부터 시작되므로 2,3,4 작업이 아무리 빨리 처리된다고 하더라도 트랜잭션에 포함시킬 필요는 없다.&lt;/li>
&lt;li>일반적으로 데이터베이스 커넥션은 개수가 제한적이어서 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 여유 커넥션의 개수는 줄어든다. 이에 따라 커넥션을 기다려야 하는 상황이 발생할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>메일 전송이나 FTP 파일 전송 작업 또는 네트워크를 통해 원격 서버와 통신하는 작업&lt;/p>
&lt;ul>
&lt;li>8번에서 프로그램이 실행되는 동안 통신할 수 없는 상황이 발생한다면 웹 서버뿐 아니라 DBMS 서버까지 위험해지는 상황이 발생하게 될 수 있으므로 트랜잭션 내에서 제거하는 것이 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>작업 단위 분리&lt;/p>
&lt;ul>
&lt;li>처리 되어야 하는 DBMS 작업을 (5,6), (7), (9) 총 3개로 분리해서 트랜잭션을 만들 수 있고, 7번이 단순 조회라면 트랜잭션을 사용하지 않아도 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="to-be">TO-BE&lt;/h3>
&lt;hr>
&lt;ol>
&lt;li>처리 시작&lt;/li>
&lt;li>사용자의 로그인 여부 확인&lt;/li>
&lt;li>사용자의 글쓰기 내용의 오류 여부 확인&lt;/li>
&lt;li>첨부로 업로드된 파일 확인 및 저장
&lt;ul>
&lt;li>데이터베이스 커넥션 생성(또는 커넥션 풀에서 가져오기)&lt;/li>
&lt;li>트랜잭션 시작&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자의 입력 내용을 DBMS에 저장&lt;/li>
&lt;li>첨부 파일 정보를 DBMS에 저장
&lt;ul>
&lt;li>트랜잭션 종료(&lt;code>COMMIT&lt;/code>)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>저장된 내용 또는 기타 정보를 DBMS에서 조회&lt;/li>
&lt;li>게시물 등록에 대한 알림 메일 발송
&lt;ul>
&lt;li>트랜잭션 시작&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 메일 발송 이력을 DBMS에 저장
&lt;ul>
&lt;li>트랜잭션 종료(&lt;code>COMMIT&lt;/code>)&lt;/li>
&lt;li>데이터베이스 커넥션 반납&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>처리완료&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>위와 같은 방식으로 개선 될 수 있다.&lt;/p></description></item><item><title>4.4 MySQL 로그 파일</title><link>https://codemario318.github.io/post/real_mysql_4_4/</link><pubDate>Fri, 14 Apr 2023 16:31:23 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_4_4/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_4_4/real_mysql.jpeg" alt="Featured image of post 4.4 MySQL 로그 파일" />&lt;p>MySQL 서버는 서버의 상태를 진단할 수 있는 많은 도구들을 지원하지만 이러한 기능은 많은 지식을 필요로 하는 경우가 많다. 로그 파일을 활용하면 MySQL 서버에 대해 깊은 지식이 없어도 서버의 상태나 부하를 일으키는 원인을 쉽게 찾아 해결할 수 있다.&lt;/p>
&lt;h2 id="에러-로그-파일">에러 로그 파일&lt;/h2>
&lt;p>MySQL이 실행되는 도중 발생하는 에러나 경고 메시지가 출력되는 로그 파일이다. MySQL 설정 파일(&lt;code>my.cnf&lt;/code>)에서 &lt;code>log_error&lt;/code>라는 이름의 파라미터로 정의된 경로에 생성되는데 설정 파일에 별도로 정의도지 않은 경우 데이터 디렉터리(&lt;code>datadir&lt;/code> 파라미터에 설정된 디렉터리)에 &lt;code>.err&lt;/code>라는 확장자가 붙은 파일로 생성된다.&lt;/p>
&lt;h2 id="mysql이-시작하는-과정과-곤련된-정보성-및-에러-메시지">MySQL이 시작하는 과정과 곤련된 정보성 및 에러 메시지&lt;/h2>
&lt;p>MySQL 설정 파일을 변경하거나 데이터베이스가 비정상적으로 종료된 후 다시 시작하는 경우에는 반드시 MySQL 에러 로그 파일을 통해 설정된 변수의 이름이나 값이 명확하게 설정되고 의도한 대로 적용됐는지 확인해야 한다.&lt;/p>
&lt;p>MySQL 서버가 정상적으로 기동했고(&lt;code>mysqld: ready for commections&lt;/code> 메시지 확인), 새로 변경하거나 추가된 파라미터에 대한 에러나 경고성 메시지가 없다면 정상적으로 적용된 것으로 판단하면 된다.&lt;/p>
&lt;ul>
&lt;li>무시 &lt;code>ignore&lt;/code>: 서버는 정상적으로 기동하지만 해당 파라미터가 적용안됨.&lt;/li>
&lt;li>실패: 에러 메시지를 출력하고 시작하지 못했다는 메시지가 노출됨&lt;/li>
&lt;/ul>
&lt;h3 id="마지막으로-종료할-때-비정상적으로-종료된-경우-나타나는-트랜잭션-복구-메시지">마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 트랜잭션 복구 메시지&lt;/h3>
&lt;p>InnoDB의 경우 MySQL 서버가 비정상적으로 종료됐다면 다시 시작되면서 완료하지 못한 트랜잭션을 정리하고 디스크에 기록되지 못한 데이터가 있다면 다시 기록하는데, 이 과정에서 간단한 메시지가 출력된다.&lt;/p>
&lt;p>복구가 불가능한 경우 해당 에러메시지를 출력하고 MySQL은 다시 종료되며, 이 단계에서 발생하는 문제는 해결하기 어려운 문제점 일 때가 많고, &lt;code>innodb_force_recovery&lt;/code> 파라미터를 설정하여 재시작 해야 할 수 있다.&lt;/p>
&lt;h3 id="쿼리-처리-도중에-발생하는-문제에-대한-에러-메시지">쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지&lt;/h3>
&lt;p>쿼리 도중 발생하는 문제점은 사전 예방이 어려우며, 에러 로그 파일을 검토하는 과정에서 알게 된다.&lt;/p>
&lt;p>쿼리 실행 도중 발생한 에러나 복제에서 문제가 될 만한 쿼리에 대한 경고 메시지가 에러 로그에 기록되므로 자주 검토하는 것이 숨겨진 문제점을 해결하는데 많은 도움이 될 수 있다.&lt;/p>
&lt;h3 id="비정상적으로-종료된-커넥션-메시지aborted-connection">비정상적으로 종료된 커넥션 메시지(Aborted connection)&lt;/h3>
&lt;p>클라이언트 애플리케이션에서 정상적으로 접속 종료를 하지 못하고 프로그램이 종료된 경우 MySQL 서버의 에러 로그 파일에 이런 내용이 기록된다. (네트워크 문제로 인한 겨우 포함)&lt;/p>
&lt;p>이런 메시지가 아주 많이 기록된다면 애플리케이션의 커넥션 종료 로직을 한번 검토해볼 필요가 있다.&lt;/p>
&lt;p>&lt;code>max_connect_errors&lt;/code> 시스템 변숫값이 너무 낮게 설정된 경우 클라이언트 프로그램이 MySQL 서버에 접속하지 못하고 &lt;code>Host 'host_name' is blocked&lt;/code>라는 에러가 발생 가능하며, 이러한 경우는 에러가 어떻게 발생하게 됐는지 원인을 확인하고, 문제가 없다면 해당 시스템 변수의 값을 증가시키면 해결된다.&lt;/p>
&lt;h3 id="innodb의-모니터링-또는-상태-조회-명령의-결과-메시지">InnoDB의 모니터링 또는 상태 조회 명령의 결과 메시지&lt;/h3>
&lt;p>InnoDB 테이블 모니터링이나 락 모니터링, 또는 엔진 상태를 조회하는 명령은 상대적으로 큰 메시지를 로그 파일에 기록한다.&lt;/p>
&lt;p>InnoDB의 모니터링을 활성화 상태로 유지하는 경우에는 에러 로그 파일이 매우 커져서 파일 시스템의 공간을 많이 사용할 수 있으므로, 다시 비활성화하여 에러 로그 파일이 커지지 않게 만들어야 한다.&lt;/p>
&lt;h3 id="mysql의-종료-메시지">MySQL의 종료 메시지&lt;/h3>
&lt;p>가끔 MySQL이 아무도 모르게 종료돼 있거나 재시작 되는 경우가 있는데, 이러한 경우 에러 로그 파일에서 MySQL이 마지막으로 종료되면서 출력한 메시지를 확는 것이 서버가 종료된 이유를 확인하는 유일한 방법이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>Received SHOUTDOWN from user ...&lt;/code> 메시지: 특정 유저가 종료한 경우&lt;/li>
&lt;li>없거나 스택 트레이스(16진수 주소값이 잔뜩 출력되는) 메시지: 세그멘테이션 폴트로 비정상 종료된 경우
&lt;ul>
&lt;li>세그멘테이션 폴트로 종료된 경우 스택 트레이스 내용을 최대한 참조하여 MySQL의 버그와 연관이 있는지 조사 후 버전을 업그레이드 하거나 회피책(WorkAround)를 찾는다.&lt;/li>
&lt;li>MySQL &amp;ldquo;The Error Log&amp;quot;절을 확인한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="제너럴-쿼리-로그-파일">제너럴 쿼리 로그 파일&lt;/h2>
&lt;p>MySQL 서버에서 실행되는 쿼리 목륵을 검토하고 싶다면, 쿼리 로그를 활성화하여 실행 쿼리를 쿼리 로그 파일로 기록하게 한 다음, 해당 파일을 검토한다.&lt;/p>
&lt;p>슬로우 쿼리 로그와는 다르게 제너럴 로그는 실행되기 전에 MySQL이 요청을 받으면 바로 기록하기 때문에 쿼리 실행 중에 에러가 발생해도 일단 로그 파일에 기록된다.&lt;/p>
&lt;p>쿼리 로그 파일의 경로는 &lt;code>general_log_file&lt;/code> 파라미터에 설정되있으며, 쿼리 로그를 파일이 아닌 테이블에 저장하도록 설정할 수 있으므로 이 경우에는 테이블을 SQL로 조회해 검토해야 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">VARIABLES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;general_log_file&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="슬로우-쿼리-로그">슬로우 쿼리 로그&lt;/h2>
&lt;p>서비스 운영 중에 MySQL 서버의 전체적인 성능 저하를 검사하거나 정기적인 점검을 위한 튜닝이 필요할 때 어떤 쿼리가 문제인지를 판단하는데 많은 도움을 준다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>long_query_time&lt;/code>: 해당 시스템 변수에 설정한 시간 이상의 시간이 소요된 쿼리가 모두 기록된다.&lt;/li>
&lt;li>&lt;code>log_output&lt;/code>: 슬로우 커리 로그를 파일 또는 테이블에 기록할지 설정할 수 있다.
&lt;ul>
&lt;li>&lt;code>TABLE&lt;/code>: &lt;code>mysql&lt;/code> DB의 테이블에 제너럴로그나 슬로우 쿼리 로그를 테이블(&lt;code>slow_log&lt;/code>, &lt;code>general_log&lt;/code>)에 저장한다.&lt;/li>
&lt;li>&lt;code>FILE&lt;/code>: 로그 내용을 디스크의 파일로 저장한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>로그 파일의 분석이 완료되면 그 결과는 3개의 그룹으로 나뉘어 저장된다.&lt;/p>
&lt;h3 id="슬로우-쿼리-통계">슬로우 쿼리 통계&lt;/h3>
&lt;p>분석 결과의 최상단에 표시되며, 모든 쿼리를 대상으로 슬로우 쿼리 로그의 실행 시간(Exec time), 잠금 대기 시간(Lock time) 등에 대해 평균 및 최소/최대 값을 표시한다.&lt;/p>
&lt;h3 id="실행-빈도-및-누적-실행-시간순-랭킹">실행 빈도 및 누적 실행 시간순 랭킹&lt;/h3>
&lt;p>각 쿼리별로 응답 시간과 실행 횟수를 보여주는데, &lt;code>pt-query-digest&lt;/code> 명령 실행 시 &lt;code>--oorder-by&lt;/code>옵션으로 정렬 순서를 변경할 수 있다.&lt;/p>
&lt;p>&lt;code>Query ID&lt;/code>는 실행된 쿼리 문장을 정규화(쿼리에 사용된 리터럴을 제거)해서 만들어진 해시 값을 의미하는데, 같은 모양의 쿼리라면 동일한 &lt;code>Query ID&lt;/code>를 가지게 된다.&lt;/p>
&lt;h3 id="쿼리별-실행-횟수-및-누적-실행-시간-상세-정보">쿼리별 실행 횟수 및 누적 실행 시간 상세 정보&lt;/h3>
&lt;p>&lt;code>Query ID&lt;/code>별 쿼리를 쿼리 랭킹에 표시된 순서대로 자세한 내용을 보여준다. 랭킹별 쿼리에서는 대상 테이블에 대해 어떤 쿼리인지만을 표시하는데, 실제 상세한 쿼리 내용은 개별 쿼리의 정보를 확인해보면 된다.&lt;/p></description></item><item><title>4.3 MyISAM 스토리지 엔진 아키텍처</title><link>https://codemario318.github.io/post/real_mysql_4_3/</link><pubDate>Fri, 14 Apr 2023 15:52:19 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_4_3/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_4_3/real_mysql.jpeg" alt="Featured image of post 4.3 MyISAM 스토리지 엔진 아키텍처" />&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_3/mysql_myisam.png"
width="1280"
height="1077"
srcset="https://codemario318.github.io/post/real_mysql_4_3/mysql_myisam_hu3bc5a7e6ebcdb2648e2fccb3d445443f_121520_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_3/mysql_myisam_hu3bc5a7e6ebcdb2648e2fccb3d445443f_121520_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MyISAM 스토리지 엔진 구조"
class="gallery-image"
data-flex-grow="118"
data-flex-basis="285px"
>&lt;/p>
&lt;h2 id="키-캐시">키 캐시&lt;/h2>
&lt;p>키 버퍼라고도 불리는 MyISAM의 키 캐시는 InnoDB의 버퍼풀과 비슷한 역할을 수행한다. 키 캐시는 인덱스만을 대상으로 작동하며, 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을 한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>키 캐시 효율성 수식&lt;/strong>&lt;br>
키 캐시 히트율 = 100 - (Key_reads / Key_read_requests * 100)&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;code>Key_reads&lt;/code>: 인덱스를 디스크에서 읽어들인 횟수를 저장하는 상태 변수&lt;/li>
&lt;li>&lt;code>Key_read_requests&lt;/code>: 키 캐시로부터 인덱스를 읽은 횟수를 저장하는 상태변수&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Key%&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>메뉴얼에서는 키 캐시를 이용한 쿼리의 비율(Hit rate)을 99% 로 유지할 것을 권장하며, 99% 미만이라면 키 캐시를 조금 더 크게 설정하는 것이 좋다.&lt;/p>
&lt;p>32비트 운영체제에서는 하나의 키 캐시에 4GB 이상 메모리 공간을 설정할 수 없고, 64비트 운영체제에서는 &lt;code>OS_PER_PROCESS_LIMIT&lt;/code> 값에 설정된 크기만큼의 메모리를 할당할 수 있다.&lt;/p>
&lt;p>제한 값 이상의 키 캐시를 할당하고 싶다면 기본 키 캐시 이외에 별도 명명된 키 캐시 공간을 설정해야 하며, 기본 키 캐시 공간을 설정하는 파라미터는 &lt;code>key_buffer_size&lt;/code>다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">key_buffer_size = 4GB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kbuf_board.key_buffer_size = 2GB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kbuf_comment.key_buffer_size = 2GB
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위 같이 설정하면 기본 키 캐시 4GB와 &lt;code>kbuf_board&lt;/code>, &lt;code>kbuf_comment&lt;/code>라는 이름의 키 캐시가 각각 2GB씩 생성된다.&lt;/p>
&lt;p>기본 키 캐시 영역외 키 캐시 영역은 아무런 설정이 없다면 할당만 해두고 사용하지 않아 추가된 키 캐시는 어떤 인덱스를 캐시할지 MySQL에 알려야 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CACHE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">db1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">board&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">db2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">board&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">IN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">kbuf_board&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CACHE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">db1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">comment&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">db2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">comment&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">IN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">kbuf_comment&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="운영체제의-캐시-및-버퍼">운영체제의 캐시 및 버퍼&lt;/h2>
&lt;p>MyISAM 테이블의 인덱스는 키 캐시를 이용해 디스크를 검색하지 않고도 빠르게 검색될 수 있으나, 디스크 데이터 I/O를 성능을 위한 캐시나 버퍼링 기능은 없다. 따라서 MyISAM 테이블의 데이터 읽기나 쓰기 작업은 항상 운영체제의 디스크 읽기 또는 쓰기 작업으로 요청된다.&lt;/p>
&lt;p>운영체제의 캐시 공간은 남는 메모리를 사용하는 것이 기본 원칙이어서 남는 공간이 없다면 MyISAM 스토리지 엔진 데이터 I/O에 사용될 메모리를 확보할 수 없어 느려진다.&lt;/p>
&lt;p>MyISAM이 주로 사용되는 MySQL에서 일반적으로 키 캐시는 최대 물리 메모리의 40% 이상을 넘지 않게 설정하고, 나머지 메모리 공간은 운영체제가 자체적은 파일 시스템을 위한 캐시 공간을 마련할 수 있게 해주는 것이 좋다.&lt;/p>
&lt;h2 id="데이터-파일과-프라이머리-키인덱스-구조">데이터 파일과 프라이머리 키(인덱스) 구조&lt;/h2>
&lt;p>InnoDB 스토리지 엔진을 사용하는 테이블은 프라이머리 키에 의해서 클러스터링되어 저장되지만, MyISAM 테이블은 프라이머리 키에 의한 클러스터링 없이 데이터 파일이 Heap 공간처럼 활용된다. (프라이머리 키 값과 무관하게 INSERT되는 순서대로 데이터 파일에 저장된다.)&lt;/p>
&lt;p>MyISAM 테이블에 저장되는 레크드는 모두 ROWID라는 물리적인 주소값을 가지는데, 프라이머리 키와 세컨더리 인덱스는 모두 데이터 파일에 저장된 레코드의 ROWID 값을 포인터로 가진다.&lt;/p>
&lt;p>ROWID는 두가지 방법으로 저장된다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>고정 길이 ROWID&lt;br>
자주 사용되지는 않지만 MyISAM 테이블을 생성할 때 MAX_ROWS 옵션을 사용해 명시하면 MySQL 서버는 쵀대로 가질 수 있는 레코드가 한정된 테이블을 생성한다. 레코드 개수가 한정되면 MyISAM 테이블은 ROWID값으로 4바이트 정수를 사용하여 INSERT된 순번으로 ROWID를 사용한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>가변 길이 ROWID&lt;br>
MAX_ROWS 옵션을 사용하지 않으면 MyISAM 테이블의 ROWID는 최대 &lt;code>myisam_data_pointer_size&lt;/code> 시스템 변수에 설정된 바이트 수 만큼에 공간을 사용할 수 있다. 기본값은 7이며 최소 2byte 부터 7byte 까지 가변적인 ROWID를 갖게 된다. 첫 바이트는 ROWID의 길이를 저장하는 용도로 사용되고 나머지 공간은 실제 ROWID를 저장하는데 사용한다. 가변적인 ROWID를 가지면 데이터 파일에서 레코드의 위치가 ROWID로 사용되어, 가변 길이 ROWID인 테이블일때 최대 크기 256TB(2**(8(7-1)))가질 수 있다.&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>4.2 InnoDB 스토리지 엔진 아키텍처(3)</title><link>https://codemario318.github.io/post/real_mysql_4_2_3/</link><pubDate>Thu, 13 Apr 2023 12:39:01 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_4_2_3/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_3/real_mysql.jpeg" alt="Featured image of post 4.2 InnoDB 스토리지 엔진 아키텍처(3)" />&lt;h2 id="double-write-buffer">Double Write Buffer&lt;/h2>
&lt;p>InnoDB 스토리지 엔진의 리두 로그는 공간 낭비를 막기 위해 페이지의 변경된 내용만 기록한다. 이로인해 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생하면 그 페이지의 내용은 복구할 수 없을 가능성이 있다.&lt;/p>
&lt;p>이런 현상을 파셜 페이지 또는 톤 페이지라고 하는데, 하드웨어의 오작동이나 시스템의 비정상 종료 등으로 발생할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>파셜 페이지(Partial-Page)&lt;/strong>&lt;br>
데이터 베이스 페이지 중에서 데이터가 일부만 채워진 페이지. 레코드가 페이지의 크기보다 작을 때 발생하며, 레코드가 페이지를 벗어나지 않은 상태에서 페이지의 일부만 사용하게 된다.&lt;/li>
&lt;li>&lt;strong>톤 페이지(Tone-Page)&lt;/strong>&lt;br>
디스크에 기록 중인 페이지의 기록 작업이 중간에 중단되어 발생하는 문제. 페이지 일부가 디스크에 기록되지 않아 데이터 무결성이 손상되는 문제를 일으킬 수 있다.&lt;/li>
&lt;/ul>
&lt;p>InnoDB 스토리지 엔진은 이러한 문제를 막기 위해 Double-Write 기법을 활용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_3/mysql_4_15.png"
width="577"
height="469"
srcset="https://codemario318.github.io/post/real_mysql_4_2_3/mysql_4_15_hud9759c13d9680ee964cf64ca3b80fcce_99858_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_3/mysql_4_15_hud9759c13d9680ee964cf64ca3b80fcce_99858_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Double Write 작동 방식"
class="gallery-image"
data-flex-grow="123"
data-flex-basis="295px"
>&lt;/p>
&lt;p>InnoDB 스토리지 엔진은 실제 데이터 파일에 변경 내용을 기록하기 전에 기록될 더티 페이지들을 묶어 시스템 테이블 스페이스의 DoubleWrite 버퍼에 기록한다.&lt;/p>
&lt;p>더티 페이지 플러싱 중 오류등으로 서버가 종료되었다면 InnoDB 스토리지 엔진은 재시작 될 때 항상 Double Write 버퍼의 내용을 데이터 파일의 페이지로 복사하게 된다.&lt;/p>
&lt;p>DoubleWrite 기능을 사용할지 여부는 &lt;code>Innodb_doublewrite&lt;/code> 시스템 변수로 제어할 수 있다.&lt;/p>
&lt;p>이처럼 DoubleWrite 버퍼는 데이터의 안정성을 위해 사용되는데, HDD처럼 자기 원판이 회전하는 저장 시스템에서는 한 번의 순차 디스크 쓰기를 하는 것으로 부담스럽지 않지만 SSD처럼 랜덤 IO와 순차 IO의 비용이 비슷한 저장 시스템에서는 부담스럽다.&lt;/p>
&lt;blockquote>
&lt;p>SSD는 HDD와 다르게 내부적으로 물리적인 섹터 단위로 데이터를 읽고 쓰지 않는다. 따라서 메모리에 복사된 내용이 SSD의 섹터 크기보다 작은 경우에도(순차 디스크 쓰기) 여러번 기록되어야 한다.&lt;/p>
&lt;/blockquote>
&lt;p>하지만 데이터의 무결성이 매우 중요한 서비스에서는 DoubleWrite의 활성화를 고려하는 것도 좋다. 만약 데이터베이스 서버의 성능을 위해 InnoDB 리두 로그 동기화 설정(&lt;code>innodb_flush_log_at_trx_commit&lt;/code> 시스템 변수)을 1이 아닌 값으로 설정했다면, DoubleWrite도 비활성화 하는 것이 좋다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>&lt;code>innodb_flush_log_at_trx_commit&lt;/code>&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>0: 커밋 후 로그 버퍼를 디스크에 즉시 플러시 하지 않고, 로그 버퍼가 일정 수준 채워지거나 데이터베이스 서버가 종료될 때 플러시한다. 데이터 일관성이 보장되지 않을 수 있다.&lt;/li>
&lt;li>1(default): 컷밋 후 로그 버퍼를 디스크에 즉시 플러시한다. 데이터 일관성은 보장하지만 디스크 IO가 부하를 발생시킬 수 있다.&lt;/li>
&lt;li>2: 커밋 후 로그 버퍼를 디스크에 즉시 플러시 하지 않고, 로그를 별도 파일에 쓴 후 파일을 주기적으로 플러시 한다. 0과 1의 중간 정도로 데이터 일관성과 디스크 IO 부하 감소를 균형있게 유지할 수 있다.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="언두-로그">언두 로그&lt;/h2>
&lt;p>InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업한다. 이렇게 백업된 데이터를 언두 로그(Undo Log)라고 한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>트랜잭션 보장&lt;/strong>&lt;br>
트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구한다.&lt;/li>
&lt;li>&lt;strong>격리 수준 보장&lt;/strong>&lt;br>
특정 커넥션에서 데이터를 변경하는 도중 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 한다.&lt;/li>
&lt;/ul>
&lt;h3 id="언두-로그-모니터링">언두 로그 모니터링&lt;/h3>
&lt;p>언두 로그로 인해 여러가지 성능 이슈가 발생할 수 있어 모니터링이 필요하다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>대용량 처리 트랜잭션&lt;/strong>&lt;br>
1억 건의 레코드가 저장된 100GB 크기의 테이블을 &lt;code>DELETE&lt;/code>로 삭제한다고 가정했을때, 언두 로그에 삭제전 값을 저장해야 하므로 언두 로그 공간은 100GB가 된다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>장시간 활성화된 트랜잭션&lt;/strong>&lt;br>
트랜잭션이 완료됐다고 해서 해당 트랜잭션이 생성한 언두 로그를 즉시 삭제할수 없을 수 있다. 먼저 시작된 트랜잭션보다 이후 발생한 트랜잭션이 완료된 경우, 먼저 시작된 완료된 트랜적션이 완료되기 전 까지 언두 로그는 삭제되지 않는다. 이러한 경우 언두 로그의 이력을 필요한 만큼 스캔해야만 필요한 레코드를 찾을 수 있기 때문에 쿼리의 성능이 전반적으로 떨어질 수 있다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* MySQL 모든 버전 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGING&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">INNODB&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="k">G&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/* MySQL 8.0 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">count&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">information_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">innodb_metrics&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SUBSYSTEM&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;transaction&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">NAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;trx_rseg_history_len&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>MySQL 서버에서 실행되는 &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 문장이 얼마나 많은 데이터를 변경하느냐에 따라 평상시 언두 로그 건수는 상이할 수 있어, 안정적인 시점의 언두 로그 건수를 확인하고 이를 기중으로 언두 로그의 급증 여부를 모니터링하는 것이 좋다.&lt;/p>
&lt;blockquote>
&lt;p>MySQL 서버에서 &lt;code>INSERT&lt;/code> 문장으로 인한 언두 로그와 &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 문장으로 인한 언두 로그는 별도로 관리된다. &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 문장으로 인한 언두 로그는 MVCC와 데이터 복구(롤백 등)에 모두 사용되지만, &lt;code>INSERT&lt;/code> 문장으로 인한 언두 로그는 롤백, 데이터 복구만을 위해 사용된다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="언두-테이블스페이스-관리">언두 테이블스페이스 관리&lt;/h3>
&lt;p>언두 로그가 저장되는 공간을 언두 테이블스페이스(Undo Tablespace)라고 한다.&lt;/p>
&lt;p>MySQL 5.6 이전 버전에서는 언두 로그가 모두 시스템 테이블스페이스(&lt;code>ibdata.idb&lt;/code>)에 저장되었었지만, 시스템 테이블스페이스의 언두 로그는 MySQL서버가 초기화될 때 생성되기 때문에 확장의 한계가 있었다.
이에 따라 5.6 버전에서는 &lt;code>innodb_undo_tablespaces&lt;/code> 시스템 변수가 도입되어 별도 로그 파일을 사용할 수 있게 되었고, 8.0으로 업그레이드되면서 언두 로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에만 기록되도록 개선되었다.&lt;/p>
&lt;p>하나의 언두 테이블스페이스는 1~128개의 롤백 세그먼트를 가지며, 롤백 세크먼트는 1개 이상의 언두 슬롯(Undo Slot)을 가진다.&lt;/p>
&lt;p>최대 동시 처리 가능한 트랜잭션의 개수는 다음 수식으로 예측할 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>(InnDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블 스페이스 수)&lt;/p>
&lt;/blockquote>
&lt;p>InnoDB 기본 설정(innodb_undo_tablespace=2, innodb_rollback_segments=128)을 사용한다면 131,072개 정도의 트랜잭션이 동시에 처리 가능해진다. 일반적인 서비스에서 이 정도까지 동시 트랜잭션이 필요하진 않겠지만 기본값으로 해서 크게 문제될 건 없다.&lt;/p>
&lt;p>언두 로그 슬롯이 부족한 경우에는 트래잭션을 시작할 수 없는 심각한 문제가 발생하기 때문에 적절히 정해야 한다.&lt;/p>
&lt;p>MySQL 8.0 부터 &lt;code>CREATE UNDO TABLESPACE&lt;/code>나 &lt;code>DROP TABLESPACE&lt;/code>같은 명령으로 새로운 언두 테이블 스페이스를 동적으로 추가하고 삭제할 수 있게 개선되었다.&lt;/p>
&lt;p>언두 테이블스페이스 공간을 필요한 만큼만 남기고 불필요하거나 과도하게 할당된 공간을 운영체제로 반납하는 것을 &amp;lsquo;Undo tablespace truncate&amp;rsquo;라고 하며 자동, 수동 두가지 방법이 있다.&lt;/p>
&lt;h2 id="체인지-버퍼">체인지 버퍼&lt;/h2>
&lt;p>RDBMS에서 레코드가 추가, 변경될 때 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다. 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 상당히 많은 자원을 소모하게 된다. 따라서 InnoDB는 변경해야 할 인덱스 페이지가 버퍼풀에 있으면 바로 업데이트를 수행하지만, 그렇지 않고 디스크로부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 되는데, 이때 사용하는 임시 메모리 공간을 체인지 버퍼(Change Buffer)라고 한다.&lt;/p>
&lt;p>사용자에게 결과를 반환하기 전에 반드시 중복 여부를 체크해야 하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없다.&lt;/p>
&lt;p>체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데, 이 스레드를 체인지 버퍼 머지 스레드라고 한다.&lt;/p>
&lt;p>MySQL 5.5 이전 버전까지는 &lt;code>INSERT&lt;/code> 작업에 대해서만 이러한 버퍼링이 가능했는데, 이후 조금씩 개선되며 &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code>로 인해 키를 추가하거나 삭제하는 작업에 대해서도 버퍼링이 될 수 있게 개선되었다.&lt;/p>
&lt;p>또한 &lt;code>innodb_change_buffering&lt;/code>이라는 시스템 변수가 새로 도입되어 작업의 종류별로 체인지 버퍼를 활성화할 수 있으며, 체인지 버퍼가 비효일적일 때는 체인지 버퍼를 사용하지 않게 설정할 수 있게 개선되었다.&lt;/p>
&lt;ul>
&lt;li>all: 모든 인덱스 관련 작업을 버퍼링(inserts + deletes + purges)&lt;/li>
&lt;li>none: 버퍼링 안함&lt;/li>
&lt;li>inserts: 인덱스에 새로운 아이템을 추가하는 작업만 버퍼링&lt;/li>
&lt;li>deletes: 인덱스에서 기존 아이템을 삭제하는 작업(삭제됐다는 마킹 작업)만 버퍼링&lt;/li>
&lt;li>changes: 인덱스에 추가하고 삭제하는 작업만(inserts + deletes) 버퍼링&lt;/li>
&lt;li>purges: 인덱스 아이템을 영구적으로 삭제하는 작업만 버퍼링(백그라운드 작업)&lt;/li>
&lt;/ul>
&lt;p>체인지 버퍼는 기본적으로 InnoDB 버퍼풀로 설정된 메모리 공간의 25%까지 활용할 수 있게 설정돼있으며, 필요하다면 50%까지 설정할 수 있다. &lt;code>innodb_change_buffer_max_size&lt;/code> 시스템 변수에 비율을 조정하여 바꿀 수 있다.&lt;/p>
&lt;h2 id="리두-로그-및-로그-버퍼">리두 로그 및 로그 버퍼&lt;/h2>
&lt;p>리두 로그는 트랜잭션의 4가지 요소인 ACID 중에서 D(Durable)에 해당하는 영속성과 가장 밀점하게 연관돼 있다. 리두 로그는 &lt;strong>하드웨어나 소프트웨어 등 문제로 인해 MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치&lt;/strong>이다.&lt;/p>
&lt;p>대부분 데이터베이스 서버는 데이터 변경 내용을 로그로 먼저 기록한다. 대부분 DBMS에서 데이터 파일은 쓰기보다 읽기 성능을 고려한 자료 구조를 가지고 있기 때문에 데이터 파일 쓰기는 디스크의 랜덤 액세스가 필요하여 상대적으로 큰 비용이 필요하다.&lt;/p>
&lt;p>이로 인한 성능 저하를 막기 위해 쓰기 비용이 낮은 자료구조인 리두 로그를 가지고 있으며, 비정상 종료가 발생하면 리두 로그의 내용을 이용해 데이터 파일을 다시 서버가 종료되기 직전 상태로 복구한다.&lt;/p>
&lt;p>또한 성능을 위해 리두 로그를 버퍼링 할 수 있는 InnoDB 버퍼풀이나, 리두 로그를 버퍼링할 수 있는 로그 버퍼와 같은 자료 구조도 가지고 있다.&lt;/p>
&lt;p>MySQL 서버가 비정상으로 종료되는 경우 InnoDB 스토리지 엔진의 데이터 파일은 두 가지 일관되지 않은 데이터를 가질 수 있다.&lt;/p>
&lt;ul>
&lt;li>커밋됐지만 데이터 파일에 기록되지 않은 데이터&lt;/li>
&lt;li>롤백됐지만 데이터 파일에 이미 기록된 데이터&lt;/li>
&lt;/ul>
&lt;p>리두로그를 활용하여 변경이 커밋, 롤백, 트랜잭션의 실행 중간 상태였는지 확인하고, 적절히 처리한다.&lt;/p>
&lt;p>데이터베이스 서버에서 리두 로그는 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 시스템 변수를 설정하는 것을 권장한다. 그래야만 서버가 비정상적으로 종료되었을때 직전까지의 트랜잭션 커밋 내용이 리두 로그에 기록될 수 있고, 그 리두 로그를 이용해 장애 직전 시점까지 복구가 가능해진다.&lt;/p>
&lt;p>하지만 트랜잭션이 커밋될 때마다 리두 로그를 디스크에 기록하면 부하가 생길 수 있어, InnoDB 스토리지 엔진에서 리두 로그를 어느 주기로 디스크에 동기화할지를 결정하는 &lt;code>innodb_flush_log_trx_commit&lt;/code> 시스템 변수를 제공한다.&lt;/p>
&lt;ul>
&lt;li>0: 1초에 한 번씩 리두 로그를 디스크로 기록하고 동기화를 실행한다. 서버가 비정상 종료되면 최대 1초 동안의 트랜잭션은 커밋됐더라도 데이터는 사라질 수 있다.&lt;/li>
&lt;li>1: 매번 트랜잭션이 커밋될 때마다 디스크로 기록되고 동기화까지 수행한다.&lt;/li>
&lt;li>2: 트랜잭션이 커밋될 때마다 디스크로 기록은 되지만 실질적인 동기화는 1초에 한번씩 실행된다. 커밋이 되면 변경 내용이 운영체제의 메모리 버퍼로 기롤되는 것이 보장되기 때문에 MySQL 서버가 비정상 종료되더라도 트랜잭션 데이터는 사라지지 않는다.&lt;/li>
&lt;/ul>
&lt;p>리두 로그 파일들의 전체 크기는 버버풀의 효율성을 결정하기 때문에 신중히 결정해야한다. 리두 로그 파일의 크기는 innodb_log_file_size 시스템 변수로 결정하며, innodb_log_files_in_group 시스템 뼌수는 리두 로그 파일 개수를 결정한다.&lt;/p>
&lt;p>리두 로그 파일의 전체 크기를 버퍼풀의 크기에 맞게 설정해야 적절히 변경된 내용을 버퍼풀에 모아 한번에 디스크에 기록할 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>ACID는 데이터베이스에서 트랜잭션의 무결성을 보장하기 위해 꼭 필요한 4가지 요소(기능)을 의미한다.&lt;/p>
&lt;ul>
&lt;li>A(Atomic): 트랜잭션은 원자성 작업이어야 함.&lt;/li>
&lt;li>C(Consistent): 일관성&lt;/li>
&lt;li>I(Isolated): 격리성&lt;/li>
&lt;li>D(Durable): 영속성. 한 번 저장된 데이터는 지속적으로 유지되어야 함.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="리두-로그-아카이빙">리두 로그 아카이빙&lt;/h3>
&lt;p>MySQL 8.0부터 InnoDB 스토리지 엔진의 리두 로그를 아카이빙 할 수 있는 기능이 추가됐다.&lt;/p>
&lt;p>백업 툴이 리두 로그 아카이빙을 사용하려면 먼저 MySQL 서버에서 아카이빙된 리두 로그가 저장될 디렉터리를 innodb_redo_log_archive_dirs 시스템 변수에 설정해야 하며, 디렉터리는 운영체제의 MySQL 서버를 실행하는 유저만 접근이 가능해야 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">mkdir /var/log/mysql_redo_archive
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> /var/log/mysql_redo_archive
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mkdir &lt;span class="m">20230413&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">chmod &lt;span class="m">700&lt;/span> &lt;span class="m">20230413&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_redo_log_archive_dirs&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;backup:/var/log/mysql_redo_archive&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>디렉터리가 준비되면 리두 로그 아카이빙을 시작하도록 &lt;code>innodb_redo_log_archive_start&lt;/code> UDF(사용자 정의 함수)를 실행한다. 해당 UDF는 리두 로그를 아카이빙할 디렉터리에 대한 레이블과 선택적으로 서브 디렉터리 이름 총 두가지의 매개 변수를 받는다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">DO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_redo_log_archive_start&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;backup&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;20230413&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>리두 아카이빙을 종료할 때는 &lt;code>innodb_redo_log_archive_stop&lt;/code> UDF를 실행한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">DO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_redo_log_archive_stop&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>innodb_redo_log_archive_start&lt;/code> UDF를 실행한 세션의 연결이 끊어지면 InnoDB 스토리지 엔진은 리두 로그 아카이빙을 멈추고 아카이빙 파일도 자동으로 삭제하므로 커넥션을 유지해야 하고, &lt;code>innodb_redo_log_archive_stop&lt;/code> UDF를 호출하여 정상적으로 종료돼야 한다.&lt;/p>
&lt;h3 id="리두-로그-활성화-및-비활성화">리두 로그 활성화 및 비활성화&lt;/h3>
&lt;p>InnoDB 스토리지 엔진의 리두 로그는 MySQL 서버가 비정상 종료됐을때 데이터 파일에 기록되지 못한 트랜잭션을 복구하기 위해 항상 활성화되어있다. MySQL 서버에서 트랜잭션이 커밋돼도 데이터 파일은 즉시 디스크로 동기화되지 않는 반면, 리두 로그는 항상 디스크로 기록된다.&lt;/p>
&lt;p>MySQL 8.0 버전부터 수동으로 리두 로그를 비활성화 할 수 있어, 대용량 데이터를 한번에 적재하는 경우 사용하여 적재 시간을 단축할 수 있다.&lt;/p>
&lt;h3 id="어댑티브-해시-인덱스">어댑티브 해시 인덱스&lt;/h3>
&lt;p>어댑티브 해시 인덱스는 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스로, &lt;code>innodb_adaptive_hash_index&lt;/code> 시스템 변수를 이용하여 활성화, 비활성화 할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-btree-index.png"
width="854"
height="359"
srcset="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-btree-index_hu7ca498aefa34ff05f0faa56ead14966c_53504_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_3/mysql-btree-index_hu7ca498aefa34ff05f0faa56ead14966c_53504_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL B-Tree Index"
class="gallery-image"
data-flex-grow="237"
data-flex-basis="570px"
>&lt;/p>
&lt;p>InnoDB 스토리지 엔진의 대표적인 인덱스는 B-Tree로 데이터는 PK 순으로 정렬되어 관리되고, Secondary Key는 &lt;code>인덱스키 + PK&lt;/code> 조합으로 정렬되어 있다. 특정 데이터를 찾기 위해 Secondary Key에서 PK를 찾고, 찾은 PK를 통해 원하는 데이터를 찾는 형태로 처리된다.&lt;/p>
&lt;blockquote>
&lt;p>PK 사용시 데이터에 접근되는 비용은 &lt;code>O(logN)&lt;/code>이고, Secondary Key를 사용해 데이터에 접근은 PK에 대한 접근도 필요하므로 &lt;code>2 * O(logN)&lt;/code>이다.&lt;/p>
&lt;/blockquote>
&lt;p>따라서 B-Tree 자료구조 특성으로 데이터가 많아진다 하더라도 탐색 비용이 크게 증가하지 않지만, 동시에 많은 스레드에서 탐색 작업이 발생할 경우 Lock 등으로 인해 성능 저하가 발생할 수 있다.&lt;/p>
&lt;p>어댑티브 해시 인덱스는 B-Tree의 검색 시간을 줄여주기 위해 도입된 기능으로, 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고, 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있다.&lt;/p>
&lt;h4 id="구조">구조&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-adaptive-hash-index.png"
width="509"
height="345"
srcset="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-adaptive-hash-index_hu35636e5b1bec8218b375a53611c0cccc_35239_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_3/mysql-adaptive-hash-index_hu35636e5b1bec8218b375a53611c0cccc_35239_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL Adaptive Hash Index"
class="gallery-image"
data-flex-grow="147"
data-flex-basis="354px"
>&lt;/p>
&lt;p>해시 인덱스는 &lt;strong>인덱스 키 값&lt;/strong>과 해당 인덱스 키 값이 저장된 &lt;strong>데이터 페이지 주소&lt;/strong>의 쌍으로 관리된다.&lt;/p>
&lt;ul>
&lt;li>인덱스 키 값:&lt;br>
B-Tree 인덱스의 고유번호 + B-Tree 인덱스의 실제 키 값
&lt;ul>
&lt;li>인덱스의 고유번호가 포함되는 이유는 InnoDB 스토리지 엔진에서 어댑티브 해시 인덱스는 하나만 존재하기 때문이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 페이지 주소:&lt;br>
실제 키 값이 저장된 데이터 페이지의 메모리 주소, 버퍼풀에 로딩된 페이지의 주소를 의미&lt;/li>
&lt;/ul>
&lt;p>어댑티브 해시 인덱스는 버퍼풀에 올려진 데이터 페이지에 대해서만 괸리되고, 버퍼풀에서 해당 데이터 페이지가 없어지면 어댑티브 해시 인덱스에서도 해당 페이지의 정보는 사라진다.&lt;/p>
&lt;h4 id="성능">성능&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-adaptive-hash-search.png"
width="665"
height="226"
srcset="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-adaptive-hash-search_hu531e6a3f072257a601880d914189c4d5_19765_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_3/mysql-adaptive-hash-search_hu531e6a3f072257a601880d914189c4d5_19765_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="쿼리 처리 수 변화"
class="gallery-image"
data-flex-grow="294"
data-flex-basis="706px"
>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_3/mysql_adaptive_hash_index_cpu.png"
width="664"
height="226"
srcset="https://codemario318.github.io/post/real_mysql_4_2_3/mysql_adaptive_hash_index_cpu_hu1567471173400d56b803e008a98f0c2b_10894_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_3/mysql_adaptive_hash_index_cpu_hu1567471173400d56b803e008a98f0c2b_10894_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="CPU 사용률 변화"
class="gallery-image"
data-flex-grow="293"
data-flex-basis="705px"
>&lt;/p>
&lt;p>어댑티브 해시 인덱스를 활성화 후 처리량은 2배 가까이 늘었음에도 불구하고 CPU 사용량은 오히려 떨어진다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-semaphores.png"
width="763"
height="252"
srcset="https://codemario318.github.io/post/real_mysql_4_2_3/mysql-semaphores_hu1335a30742e00261da10a60e6c5fce19_21643_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_3/mysql-semaphores_hu1335a30742e00261da10a60e6c5fce19_21643_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="세마포어 변화"
class="gallery-image"
data-flex-grow="302"
data-flex-basis="726px"
>&lt;/p>
&lt;p>InnoDB 내부잠금(세마포어)의 횟수도 획기적으로 줄어든다.&lt;/p>
&lt;p>추가로 MySQL 8.0 부터는 내부 잠금을 줄이기 위해 어댑티브 해시 인덱스의 파티션 기능을 제공하며 &lt;code>innodb_adaptive_hash_index_parts&lt;/code> 시스템 변수를 통해 파티션 개수를 변경할 수 있다(기본값 8개).&lt;/p>
&lt;p>어댑티브 해시 인덱스가 성능에 많은 도음이 된다면 파티션 개수를 더 많이 설정하는 것도 도움이 될 수 있다.&lt;/p>
&lt;h4 id="한계">한계&lt;/h4>
&lt;p>상황에 따라 어댑티브 해시 인덱스가 성능 향상에 크게 도움이 되지 않는 경우도 있다.&lt;/p>
&lt;ul>
&lt;li>성능 향상에 도움이 되는 경우
&lt;ul>
&lt;li>디스크의 데이터가 InnoDB 버퍼풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)&lt;/li>
&lt;li>동등 조건 검색(동등 비교 및 &lt;code>IN&lt;/code> 연산)이 많은 경우&lt;/li>
&lt;li>쿼리가 일부 데이터에만 집중 되는 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>성능 향상에 크게 도움이 되지 않는 경우
&lt;ul>
&lt;li>디스크 읽기가 많은 경우&lt;/li>
&lt;li>특정 패턴의 쿼리가 많은 경우(&lt;code>JOIN&lt;/code>, &lt;code>LIKE&lt;/code> 패턴 검색)&lt;/li>
&lt;li>매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>어댑티브 해시 인덱스는 데이터 페이지를 메모리(버퍼풀) 내에서 접근하는 것을 더 빠르게 만드는 기능으로 데이터 페이지를 디스크에서 읽어오는 경우가 많은 경우 데이터베이스 서버에서는 큰 도움이 되지 않는다.&lt;/p>
&lt;ul>
&lt;li>어댑티브 해시 인덱스 또한 메모리를 사용하며, 때로는 상당히 큰 메모리 공간을 사용할 수 있다.&lt;/li>
&lt;li>데이터 페이지의 인덱스 키가 해시 인덱스로 만들어져야 하기 때문에 불필요한 경우 제거되어야 한다.&lt;/li>
&lt;li>활성화되면 InnoDB 스토리지 엔진이 필수적으로 검색에 활용해야 하기 때문에 불필요한 접근이 발생할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="주의할-점">주의할 점&lt;/h4>
&lt;p>테이블 삭제(&lt;code>DROP&lt;/code>), 변경(&lt;code>ALTER&lt;/code>)시 해당 테이블이 가진 모든 데이터 페이지의 내용을 어댑티브 해시 인덱스에서 제거해야한다. 이로 인해 테이블이 삭제되거나 스키마가 변경되는 동안 상당히 많은 CPU 자원을 사용하게되어 데이터베이스 서버의 처리 성능이 떨어진다.&lt;/p>
&lt;h4 id="모니터링">모니터링&lt;/h4>
&lt;p>MySQL 서버의 상태 값들을 통해 어댑티브 해시 인덱스가 불필요한 오버헤드만 만들고 있는지 확인할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">INNODB&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="k">G&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">Hash table size 8747, node heap has 1 buffers(s)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">Hash table size 8747, node heap has 0 buffers(s)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">1.03 hash searches/s, 2.64 non-hash searches/s
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>&lt;code>searches&lt;/code>: 쿼리가 처리되기 위해 내부적으로 키 값의 검색이 몇 번 실행되었는지를 의미함&lt;/p>
&lt;/blockquote>
&lt;p>어댑티브 해시 인덱스의 효율은 검색 횟수가 아니라 &lt;strong>해시 인덱스 히트율&lt;/strong>과 &lt;strong>인덱스가 사용 중인 메모리 공간&lt;/strong>, &lt;strong>서버의 CPU 사용량&lt;/strong>을 종합해서 판단해야 한다.&lt;/p>
&lt;p>위 실행 쿼리 결과에서는 28% 정도가 어댑티브 해시 인덱스를 이용했다는 것을 알 수 있는데, 서버의 CPU 사용량이 100%에 근접한다면 효율적이라고 볼 수 있다. 하지만 CPU 사용량이 낮고 어댑티브 해시 인덱스의 메모리 사용량이 높다면 비활성화하여 버퍼풀이 더 많은 메모리를 사용할 수 있게 유도하는 것도 좋은 방법이다.&lt;/p>
&lt;p>어댑티브 해시 인덱스의 메모리 사용량은 performance_schema를 이용해서 확인 가능하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">EVENT_NAME&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">CURRENT_NUMBER_OF_BYTES_USED&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">memory_summary_global_by_event_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">EVENT_NAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;memory/innodb/adaptive hash index&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="myisam-memory-스토리지-엔진-비교">MyISAM, MEMORY 스토리지 엔진 비교&lt;/h2>
&lt;h3 id="myisam">MyISAM&lt;/h3>
&lt;p>MySQL 5.5부터는 InnoDB 스토리지 엔진이 기본 스토리지 엔진으로 채택 되었지만, 이전까지는 MyISAM이 기본 스토리지 엔진으로 사용되는 경우가 많았다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>MySQL 서버의 시스템 테이블의 기본 스토리지 엔진&lt;/strong>
MySQL 8.0 부터는 MyISAM이 기본 설정되었던 서버의 시스템 테이블(사용자 인증 관련 정보, 복제 관련 정보가 저장된 mysql DB의 테이블) 등 서버의 모든 기능을 InnoDB 스토리지 엔진으로 교체되었다.&lt;/li>
&lt;li>&lt;strong>전문 검색 및 공간 좌표 검색 기능 제공.&lt;/strong>
InnoDB 스토리지 엔진에서도 전문 검색과 공간 좌표 검색 기능을 모두 지원하도록 개선되었다.&lt;/li>
&lt;/ul>
&lt;p>이러한 이유로 MyISAM 스토리지 엔진은 InnoDB 스토리지 엔진으로 대체될 것으로 예상된다.&lt;/p>
&lt;h3 id="memory">MEMORY&lt;/h3>
&lt;p>MEMORY 스토리지 엔진이 메모리라는 이름 때문에 과대 평가를 받는 경우가 있다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>단일 스레드 처리 성능
단일 스레드 처리 성능은 MEMORY 스토리지 엔진이 빠를 수 있으나, MySQL 서버는 일반적으로 온라인 트랜잭션 처리를 위한 목적으로 사용되어 동시 처리 성능이 매우 중요하다. MEMORY 스토리지 엔진에서 동시에 많은 클라이언트 쿼리 요청이 실행되는 상황이라면 테이블 수준의 잠금으로 인해 InnoDB 스토리지 엔진을 따라갈 수 없다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>임시 테이블 용도로 활용
MySQL 5.7 버전까지 내부 임시 테이블 용도로 활용되었으나, 가변 길이 타입의 컬럼을 지원하지 않는다는 문제점으로 MySQL 8.0 부터는 TempTable 스토리지 엔진이 대체되어 사용된다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>이러한 이유로 MEMORY 스토리지 엔진을 선택해서 얻을 수 있는 장점이 없어져, 향후 버전에서는 제거될 것으로 예상된다.&lt;/p></description></item><item><title>4.2 InnoDB 스토리지 엔진 아키텍처(2) - InnoDB 버퍼풀</title><link>https://codemario318.github.io/post/real_mysql_4_2_2/</link><pubDate>Wed, 12 Apr 2023 14:27:41 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_4_2_2/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_2/real_mysql.jpeg" alt="Featured image of post 4.2 InnoDB 스토리지 엔진 아키텍처(2) - InnoDB 버퍼풀" />&lt;p>버퍼풀은 InnoDB 스토리지 엔진의 핵심으로 디스크에서 데이터를 읽어 메모리에 보관하고, 필요할 때 메모리에서 데이터를 읽어와 처리하는 역할을 수행한다. 또한 디스크와 메모리 사이에서 데이터 읽기 및 쓰기를 관리하여 데이터 베이스의 성능을 향상시킨다.&lt;/p>
&lt;ul>
&lt;li>디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다.&lt;/li>
&lt;li>쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 수행한다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>일반적인 애플리케이션에서는 &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code>처럼 데이터를 변경하는 쿼리는 데이터 파일의 흩어져있는 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킨다. 변경을 모아 처리하여 랜덤 디스크 접근 작업 수를 줄일 수 있다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="버퍼풀의-크기-설정">버퍼풀의 크기 설정&lt;/h2>
&lt;p>운영체제와 각 클라이언트 스레드가 사용할 메모리도 충분히 고려하여 설정한다. MySQL 서버 내에서 메모리를 필요로 하는 부분은 크게 없지만 아주 독특한 경우 레코드 버퍼가 상당한 메모리를 사용하기도 한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>레코드버퍼&lt;/strong>&lt;br>
각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간으로 커넥션이 많고 사용하는 테이블도 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 많이 필요할 수 있다.&lt;/p>
&lt;/blockquote>
&lt;p>MySQL 서버가 사용하는 레코드 버퍼 공간은 별도로 설정할 수 없어, 전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 테이블의 개수에 따라 결정되고, 동적으로 해제되기도 하므로 정확히 필요한 메모리의 크기를 계산할 수 없다.&lt;/p>
&lt;h3 id="버퍼풀-동적-크기-조절">버퍼풀 동적 크기 조절&lt;/h3>
&lt;p>MySQL 5.7 버전부터 InnoDB 버퍼풀의 크기를 동적으로 조절할 수 있게 개선되어 가능하면 InnoDB 버퍼풀의 크기를 적절히 작은 값으로 설정하고 상황을 봐가며 증가시키는 방법이 최적이다.&lt;/p>
&lt;p>&lt;code>innodb_buffer_pool_size&lt;/code> 시스템 변수로 크기를 설정할 수 있으며, 동적으로 버퍼풀의 크기를 확장할 수 있다.&lt;/p>
&lt;ul>
&lt;li>크리티컬한 변경이므로 가능하며 MySQL 서버가 한가한 시점을 골라 실행한다.&lt;/li>
&lt;li>버퍼풀의 크기를 줄이는 작업은 서비스 영향도가 매우 크므로 주의해야한다.&lt;/li>
&lt;li>버퍼풀은 내부적으로 128MB 청크 단위로 쪼개어 관리되어 조절된다.&lt;/li>
&lt;/ul>
&lt;h3 id="버퍼풀-나누기">버퍼풀 나누기&lt;/h3>
&lt;p>InnoDB 버퍼풀은 정통적으로 버퍼풀 전체를 관리하는 잠금(세마포어)으로 인해 내부 잠금 경합을 많이 유발해왔는데, 이런 경함을 줄이기 위해 버퍼풀을 여러개로 쪼개어 관리할 수 있게 개선되었다.&lt;/p>
&lt;blockquote>
&lt;p>버퍼풀이 여러 개의 작은 버퍼풀로 쪼개지면서 개별 버퍼풀을 관리하는 잠금 자체도 경합이 분산되는 효과를 얻을 수 있게 된다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>innodb_buffer_pool_instances&lt;/code> 시스템 변수를 이용해 버퍼풀을 여러개로 분리하여 관리할 수 있다.&lt;/p>
&lt;h2 id="버퍼풀-구조">버퍼풀 구조&lt;/h2>
&lt;p>InnoDB 스토리지 엔진은 버퍼풀이라는 거대한 메모리 공간을 페이지 크기(&lt;code>innodb_page_size&lt;/code> 시스템 변수에 설정된)의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다.&lt;/p>
&lt;p>버퍼풀의 페이지 조각을 관리하기 위해 LRU(least Recently Used) 리스트와, 플러시(Flush) 리스트, 프리(Free) 리스트라는 3개의 자료 구조를 관리한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>LRU 리스트: 디스크로부터 읽어온 페이지 저장하는 자료구조. 읽어온 페이지를 최대한 오랫동안 버퍼풀의 메모리에 유지하여 디스크 읽기를 최소화 한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>플러시 리스트: 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>프리리스트: 버퍼풀에서 실제 사용자 데이터로 채워지지 않은 비어있는 페이지들의 목록. 사용자의 쿼리가 새로벡 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="lru-리스트-구조">LRU 리스트 구조&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_2/mysql_4_13.png"
width="316"
height="292"
srcset="https://codemario318.github.io/post/real_mysql_4_2_2/mysql_4_13_hue0f5dcd0b58a4f8a7118d2c75e37f46e_29762_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_2/mysql_4_13_hue0f5dcd0b58a4f8a7118d2c75e37f46e_29762_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="LRU 리스트 구조"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="259px"
>&lt;/p>
&lt;p>LRU 리스트는, &lt;strong>Old 서브리스트 영역&lt;/strong>은 LRU, &lt;strong>New 서브리스트 영역&lt;/strong>은 MRU(Most Recently Used)가 합쳐진 방식으로 동작한다.&lt;/p>
&lt;p>New 서브리스트의 Tail과 Old 서브리스트의 Head가 만나는 지점을 MidPoint라 하며 버퍼풀에 새로운 페이지가 들어올 경우 Old 서브리스트의 Head 부분에 저장한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>New 서브리스트와 Old 서브리스트로 나눈 이유는?&lt;/strong>&lt;br>
하나의 큐를 사용하여 페이지를 관리할 경우에 Head 또는 Tail에 페이지를 저장하는 방식을 생각해 볼 수 있다. Head에 저장될 경우 새로 관리되는 페이지가 사용되지 않더라도 오랜 시간동안 리스트에 남아 있게되고, Tail에 저장될경우 해당 페이지를 즉시 읽지 않는다면 리스트에 남아있지 않게 되어 의미가 없어질 수 있다.&lt;br>
이를 위해 두개의 서브리스트로 나누고, 경험적으로 얻은 5/8 지점을 활용한 중간점 삽입 전략을 사용하는 것 같다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="데이터를-찾는-과정">데이터를 찾는 과정&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>필요한 레코드가 저장된 데이터 페이지가 버퍼풀에 있는지 검사&lt;/p>
&lt;ol>
&lt;li>InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색&lt;/li>
&lt;li>해당 테이블의 인덱스(B-Tree)를 이용해 버퍼풀에서 페이지를 검색&lt;/li>
&lt;li>버퍼풀에 이미 데이터 페이지가 있다면 해당 페이지의 포인터를 MRU 방향으로 승급&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>디스크에서 필요한 데이터 페이지를 버퍼풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가&lt;/p>
&lt;/li>
&lt;li>
&lt;p>버퍼풀의 LRU 헤더에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동(Read Ahead와 같이 대량 읽기의 경우 디스크 페이지가 버퍼풀로 적재는 되지만 실제 쿼리에서 사용되지는 않을수도 있으며, 이련 경우는 MRU로 이동되지 않음)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>버퍼풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이가 부여되며, 버퍼풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 오래된 페이지는 버퍼풀에서 제거됨. 버퍼풀의 페이지가 쿼리에 의해 사용되면 나이가 초기회되고 MRU헤더 부분으로 옮겨진다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>처음 한번 읽힌 데이터 페이지가 이후 자주 사용된다면 버퍼풀의 MRU 영역에서 살아남게 되고, 그렇지 않은 경우 새롭게 읽히는 데이터 페이지에 밀려 결과적으로 버퍼풀에서 제거된다.&lt;/p>
&lt;h2 id="버퍼풀과-리두-로그">버퍼풀과 리두 로그&lt;/h2>
&lt;p>버퍼풀은 데이터 베이스 서버의 성능 향상을 위해 &lt;strong>데이터 캐시&lt;/strong>와 &lt;strong>쓰기 버퍼링&lt;/strong>이라는 두가지 용도가 있다.
따라서 메모리가 허용하는 만큼 크게 설정하면 데이터 캐시 공간을 키워 쿼리의 성능 높힐 수 있지만, 쓰기 버퍼링 성능 향상을 위해서는 버퍼풀과 리두 로그의 관계에 대해 이해하는 것이 중요하다.&lt;/p>
&lt;h3 id="리두-로그redo-log란">리두 로그(Redo Log)란?&lt;/h3>
&lt;p>리두 로그는 데이터베이스에 대한 모든 변경 내용을 기록하는 파일셋이다. 시스템 장애나 충돌이 발생했을 때 데이터의 내구성과 일관성을 보장하기 위해 사용된다.&lt;/p>
&lt;p>데이터베이스에 변경 사항이 발생하면, 먼저 선로깅(write-ahead logging)프로세스로 리두 로그에 쓰여지고 변경 내용이 리두 로그에 기록되면 데이터베이스에 적용된다.&lt;/p>
&lt;p>리두 로그 파일은 일반적으로 디스크에 저장되며, MySQL은 변경 사항을 순차적으로 기록한다. 리두 로그 파일이 가득 차면 MySQL은 &amp;ldquo;체크포인트(checkpoint)&amp;ldquo;를 수행하여 데이터베이스의 모든 더티 페이지(버퍼풀에서 수정된 페이지)를 디스크에 기록한 후, 로그 파일을 잘라내어 공간을 확보하게 된다.&lt;/p>
&lt;p>MySQL에서 리두 로그는 원형 버퍼 형식으로 저장되며, 채워지면 다음 변경 사항은 순환 방식으로 다음 사용 가능한 리두 로그 파일에 기록된다. 이를 통해 리두 로그에 변경 사항이 지속적으로 기록되어 시스템 충돌이나 장애가 발생하더라도 변경 사항을 손실하지 않도록 보장한다.&lt;/p>
&lt;h3 id="버퍼풀과-리두-로그의-관계">버퍼풀과 리두 로그의 관계&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_2/mysql_4_14.png"
width="254"
height="212"
srcset="https://codemario318.github.io/post/real_mysql_4_2_2/mysql_4_14_hu12b3affca177d60e9363f94fd37fd0f1_14755_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_2/mysql_4_14_hu12b3affca177d60e9363f94fd37fd0f1_14755_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="버퍼풀과 리두 로그의 관계"
class="gallery-image"
data-flex-grow="119"
data-flex-basis="287px"
>&lt;/p>
&lt;p>버퍼풀은 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지(Clean Page)와 함께 &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code>를 통해 변경된 데이터를 가진 더티 페이지(Duty Page)를 가지고 있다.&lt;/p>
&lt;p>데이터 변경이 발생하면 먼저 리두 로그에 기록되고 리두 로그는 더티 페이지와 대응하게 된다.&lt;br>
데이터 변경이 반복되면 결국 리두 로그 파일을 기록할 수 없거나 버퍼풀 용량이 부족해지는데, 이를 대응하기 위해 체크포인트를 수행하여 모든 더티페이지를 디스크에 기록한 후, 리두 로그 파일을 잘라내어 공간을 확보한다.&lt;/p>
&lt;p>이러한 방식이 버퍼풀이 쓰기 버퍼의 역할을 수행하게 만들게 되는데, 이에 따라서 리두 로그 파일의 크기가 작을수록 버퍼풀의 크기가 크더라도 대응되는 더티 페이지가 적으므로 버퍼링으로 얻을 수 있는 효과가 적어지고, 리두 로그 파일이 클수록 체크포인트를 통해 디스크에 기록되는 데이터가 많아져 갑자기 많은 디스크 I/O를 발생 시킬 수 있다.&lt;/p>
&lt;p>따라서, 리두 로그 파일의 크기를 적절히 선택해야하며, 어렵다면 버퍼풀의 크기가 100GB 이하의 MySQL 서버에서는 리두 로그 파일의 전체 크기를 대략 5~10GB 수준으로 선택하고 필요할 때마다 조금씩 늘려가며 최적값을 찾는 것이 좋다.&lt;/p>
&lt;h2 id="버퍼풀-플러시buffer-pool-flush">버퍼풀 플러시(Buffer Pool Flush)&lt;/h2>
&lt;p>버퍼풀에서 수정된 데이터 페이지를 디스크로 쓰는 과정으로 MySQL 5.6 버전까지는 InnoDB 스토리지 더티 페이지 플러시 기능이 급작스럽게 디스크 기록이 폭증해서 MySQL 서버의 사용자 쿼리 처리 성능에 영향을 받는 등 그다지 부드럽게 처리되지 않았다.&lt;/p>
&lt;p>MySQL 5.7 버전을 거쳐 8.0 버전으로 업그레이드되면서 대부분의 서비스에서는 더티 페이지 프러시에서 예전과 같이 폭증 현상은 발생하지 않았다. 따라서 InnoDB 스토리지 엔진의 더티 페이지 플러시 성능 문제가 발생하지 않는다면 관련 시스템 변수는 조절하지 않아도 괜찮다.&lt;/p>
&lt;p>InnoDB 스토리지 엔진은 버퍼풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상 악영향 없이 디스크에 동기화하기 위해 다음과 같이 2개의 플러시 기능을 백그라운드로 실행한다.&lt;/p>
&lt;ul>
&lt;li>플러시 리스트(Flush_list) 플러시&lt;/li>
&lt;li>LRU 리스트(LRU_list) 플러시&lt;/li>
&lt;/ul>
&lt;h3 id="플러시-리스트-플러시">플러시 리스트 플러시&lt;/h3>
&lt;p>InnoDB 스토리지 엔진은 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비운다. 이때 오래된 리두 로그 공간이 지워지려면 반드시 InnoDB 버퍼풀의 더티 페이지가 먼저 디스크로 동기화 돼야 한다.&lt;/p>
&lt;p>이를 위해 InnoDB 스토리지 엔진은 주기적으로 플러시 리스트(Flush_list) 플러시 함수를 호출하여 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화 하는 작업을 수행한다.&lt;/p>
&lt;p>이때 언제부터 얼마나 많은 더티 페이지를 한번에 디스크로 기록하느냐에 따라 사용자의 쿼리 처리가 악영향을 받지 않으면서 부드럽게 처리된다. 리를 위해 InnoDB 스토리지 엔진은 여러 시스템 변수를 제공한다.&lt;/p>
&lt;h4 id="innodb_page_cleaners">&lt;code>innodb_page_cleaners&lt;/code>&lt;/h4>
&lt;p>InnoDB 스토리지 엔진에서 더티 페이지를 디스크로 동기화하는 스레드를 클리너 스레드(Cleaner Thread)라고 하고, 클리너 스레드의 개수를 조정할 수 있게 해준다.&lt;/p>
&lt;p>설정값이 버퍼풀 인스턴스 개수보다 많은 경우 &lt;code>innodb_buffer_pool_instances&lt;/code> 설정값으로 자동으로 변경하여, 하나의 클리너 스레드가 하나의 버퍼풀 인스턴스를 처리하도록 한다.&lt;/p>
&lt;p>시스템 변수의 설정값이 버퍼풀 인스턴스 개수보다 적은 경우 하나의 클리너 스레드가 여러 개의 버퍼풀 인스턴스를 처리하므로, &lt;code>innodb_page_cleaners&lt;/code> 설정값은 &lt;code>innodb_buffer_pool_instances&lt;/code> 설정 값과 동일하게 설정하는 것이 좋다.&lt;/p>
&lt;h4 id="innodb_max_dirty_pages_pct">&lt;code>innodb_max_dirty_pages_pct&lt;/code>&lt;/h4>
&lt;p>InnoDB 버퍼풀은 클린 페이지와 더티 페이지를 함께 가지고 있어 뭏란정 더티 페이지를 그대로 유지할 수 없다.
기본적으로 InnoDB 스토리지 엔진은 전체 버퍼풀이 가진 페이지의 90%까지 더티페이지를 가질 수 있는데, &lt;code>innodb_max_dirty_pct&lt;/code> 시스템 변수를 이용해 더티페이지의 비율을 조절할 수 있다.&lt;/p>
&lt;p>일반적으로 버퍼풀이 더티페이지를 많이 가지고 있을수록 디스크 쓰기 작업을 버퍼링함으로써 I/O 작업을 줄일 수 있으므로 기본값으로 유지하는 것이 좋다.&lt;/p>
&lt;h4 id="innodb_max_dirty_pages_pct_lwm">&lt;code>innodb_max_dirty_pages_pct_lwm&lt;/code>&lt;/h4>
&lt;p>InnoDB 스토리지 엔진은 &lt;code>innodb_io_capacity&lt;/code> 시스템 변수에 설정된 값을 기준으로 더티 페이지 쓰기를 실행하는데, 디스크로 기록되는 더티페이지 개수보다 더 많은 더티페이지가 발생하면 버퍼풀에 더티페이지가 계속 증가하게 되고, 지정한 비율이 넘어가면 더티페이지를 디스크로 기록하여 디스크 쓰기 폭발(Dist IO Bust) 현상이 발생할 가능성이 있다.&lt;/p>
&lt;p>이런 문제를 완화하기 위해 &lt;code>innodb_max_dirty_pages_pct_lwm&lt;/code> 시스템 설정 변수를 이용해 일정 수준 이상의 더티페이지가 발생하면 조금씩 더티 페이지를 디스크로 기록한다.&lt;/p>
&lt;p>기본값은 10% 정도로, 디스크 쓰기가 많이 발생하고 더티 페이지 비율이 낮은 상태를 유지한다면 높은 값으로 조정할 수 있다.&lt;/p>
&lt;h4 id="innodb_io_capacity-innodb_io_capacity_max">&lt;code>innodb_io_capacity&lt;/code>, &lt;code>innodb_io_capacity_max&lt;/code>&lt;/h4>
&lt;p>데이터베이스 서버에서 어느정도의 디스크 IO가 가능한지 설정하는 값이다.
&lt;code>innodb_io_capacity는&lt;/code> 일반적인 상황에서 디스크가 적절히 처리할 수 있는 수준의 값을 설정하며, &lt;code>innodb_io_capacity_max&lt;/code>는 디스크가 최대 성능을 발휘할 때 어느 정도 IO가 가능한지를 설정한다.&lt;/p>
&lt;p>여기서 언급되는 IO는 InnoDB 스토리지 엔진의 백그라운드 스레드가 수행하는 디스크 작업을 의미하며, 대부분 더티페이지 쓰기이다.&lt;/p>
&lt;p>스토리지 엔진은 사용자의 쿼리를 처리하기 위해 디스크를 읽기도 해야하므로 하드웨어 성능에 무조건 맞추는 것은 좋지 않다.&lt;/p>
&lt;h4 id="innodb_adaptive_flushing-innodb_adaptive_flushing_lwm">&lt;code>innodb_adaptive_flushing&lt;/code>, &lt;code>innodb_adaptive_flushing_lwm&lt;/code>&lt;/h4>
&lt;p>어댑티브 플러시를 활성화 하면 InnoDB 스토리지 엔진은 버퍼불의 더티 페이지 비율이나 &lt;code>innodb_io_capacity&lt;/code>, &lt;code>innodb_io_capacity_max&lt;/code> 설정 값에 의존하지 않고 알고리즘을 사용한다.&lt;/p>
&lt;p>더티 페이지는 리두 로그와 대응하므로, 리두 로그가 어느정도 증가하는지 분석하여 확인할 수 있다. 어댑티브 플러시 알고리즘은 리두 로그의 증가 속도를 분석하여 적절한 수준의 더티 페이지가 버퍼풀에 유지될 수 있도록 디스크 쓰기를 실행한다.&lt;/p>
&lt;p>&lt;code>innodb_adaptive_flushing&lt;/code>는 기본값이 활성이며, &lt;code>innodb_adaptive_flushing_lwm&lt;/code>는 어댑티브 플러시 알고리즘 활성을 위한 활성 리두 공간의 하한 비율을 의미한다.&lt;/p>
&lt;h4 id="innodb_flush_neighbors">&lt;code>innodb_flush_neighbors&lt;/code>&lt;/h4>
&lt;p>더티페이지를 디스크에 기록할 때 디스크에서 근접한 페이지 중 더티페이지가 있다면 InnoDB 스토리지 엔진이 함께 묶어 디스크로 기록하게 해주는 기능을 활성화 할지 결정한다.&lt;/p>
&lt;p>과거에는 HDD의 경우 IO 비용이 높아 최대한 줄이기 위해 만들어졌다.&lt;/p>
&lt;p>데이터 저장을 하드디스크로 하고있다면 1, 2 정도로 활성화 하고, SSD를 사용한다면 기본값인 비활성으로 유지하는 것이 좋다.&lt;/p>
&lt;h3 id="lru-리스트-플러시">LRU 리스트 플러시&lt;/h3>
&lt;p>InnoDB 스토리지 엔진은 LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거하여 새로운 페이지들을 읽어올 공간을 만들어야 하는데, 이를 위해 LRU 리스트 플러시 함수가 사용된다.&lt;/p>
&lt;p>리스트 끝부분 부터 시작하여 최대 &lt;code>innodb_lru_scan_depth&lt;/code> 시스템 변수에 설정된 수만큼의 페이지들을 스캔하는데, 이때 더티체이지는 디스크에 동기화하고, 클린 페이지는 즉시 프리 리스트로 페이지를 옮긴다.&lt;/p>
&lt;p>InnoDB 스토리지 엔진은 버퍼풀 인스턴스 별로 최대 &lt;code>innodb_lru_scan_depth&lt;/code> 개수만큼 스캔하기 때문에 실질적으로 LRU 리스트의 스캔은 (&lt;code>innodb_buffer_pool_instances&lt;/code> * &lt;code>innodb_lru_scan_depth&lt;/code>) 수만큼 수행하게 된다.&lt;/p>
&lt;h2 id="버퍼풀-상태-백업-및-복구">버퍼풀 상태 백업 및 복구&lt;/h2>
&lt;p>InnoDB 서버의 버퍼풀은 쿼리의 성능에 매우 밀접하게 연결돼 있다. 서버 재실행시 버퍼풀에 쿼리들이 사용할 데이터가 없어 성능이 매우 떨어지게 된다.&lt;/p>
&lt;p>디스크의 데이터가 버퍼풀에 적재돼 있는 상태를 위밍업(Warming Up)이라고 표현하는데, 워밍업 상태에 따라 몇십 배 쿼리 처리속도 차이가 발생하게 된다.&lt;/p>
&lt;p>MySQL 5.5 버전은 재실행시 강제 워밍업을 위해 주요 테이블과 인덱스에 대해 풀스캔을 실행하고 서비스를 오픈했었다. 하지만 5.6 버전부터는 버퍼풀 덤프 및 적재 기능이 도입되어 MySQL 서버 셧다운 전 &lt;code>innodb_buffer_pool_dump_now&lt;/code> 시스템 변수를 이용해 현재 InnoDB 버퍼풀 상태를 백업할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* 버퍼풀 상태 백업 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_buffer_pool_dump_now&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/* 백업된 버퍼풀 상태 복구 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_buffer_pool_load_now&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>버퍼풀 백업을 수행하면 데이터 디렉터리에 ib_buffer_pool이라는 파일로 생성되는데, InnoDB 스토리지 엔진이 버퍼풀의 LRU 리스트에서 적재된 데이터 페이지의 메타 정보만 가져와 저장하여, 버퍼풀이 크다고 하더라도 몇십 MB 이하로 작다.&lt;/p>
&lt;p>하지만 버퍼풀로 복구하는 과정에서 각 테이블의 데이터 페이지를 디스크에서 다시 읽어와야 하기 때문에 버퍼풀의 크기에 따라 매우 오래 걸릴 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Innodb_buffer_pool_dump_status&amp;#39;&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="k">G&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>InnoDB의 버퍼풀을 복구하는 작업은 상당히 많은 디스크 읽기를 필요로 하기 때문에, 복구중 서비스 재개하는 것은 좋지 않을 수 있다. 버퍼풀 적재 작업을 중지하려면 &lt;code>innodb_buffer_pool_load_abort&lt;/code> 시스템 변수를 통해 중지하여 재개하는 것을 권장한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">innodb_buffer_pool_load_abort&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="백업-및-복구-자동화">백업 및 복구 자동화&lt;/h3>
&lt;p>InnoDB 스토리지 엔진은 &lt;code>innodb_buffer_pool_dump_at_shutdown&lt;/code>, &lt;code>innodb_buffer_pool_load_at_shutdown&lt;/code> 설정을 MySQL 설정 파일에 넣으면 서버가 셧다운 되기 직전에 버퍼풀의 백업을 실행하고, MySQL 서버가 시작되면 자동으로 백업된 버퍼풀의 상태를 복구할 수 있는 기능을 제공한다.&lt;/p>
&lt;h2 id="버퍼풀의-적재-내용-확인">버퍼풀의 적재 내용 확인&lt;/h2>
&lt;p>MySQL 5.6 버전부터 MySQL 서버의 &lt;code>information_schema&lt;/code> 데이터베이스의 &lt;code>innodb_buffer_page&lt;/code> 테이블을 이용해 InnoDB 버퍼풀의 메모리에 어떤 테이블의 페이지들이 적재돼 있는지 확인할 수 있었다. 하지만 버퍼풀이 큰 경우에는 테이블 조회가 상당히 큰 부하를 일으키면서 서비스 쿼리가 많이 느려지는 문제가 있어, 실제 서비스용으로 사용되는 MySQL 서버에서는 버퍼풀의 상태를 확인하는 것이 거의 불가능했다.&lt;/p>
&lt;p>MySQL 8.0 버전에서는 &lt;code>information_schema&lt;/code> 데이터베이스에 &lt;code>innodb_cached_indexes&lt;/code> 테이블이 새로 추가되어, 테이블의 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼풀에 적재돼 있는지 확인할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ii&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">index_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ici&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">n_cached_pages&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">n_cached_pages&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">information_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">innodb_tables&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">information_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">innodb_indexes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ii&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ii&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">table_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">table_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">information_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">innodb_cached_indexes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ici&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ici&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">index_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ii&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">index_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">CONCAT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;employees&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;/&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;employees&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>아직 MySQL 서버는 개별 인덱스별로 전체 페이지 개수가 몇 개인지는 사용자에게 알려주지 않기 때문에 &lt;code>information_schema&lt;/code>의 테이블을 이용해도 테이블의 인덱스별로 페이지가 InnoDB 버퍼풀에 적재된 비율은 확인할 수가 없다.&lt;/p></description></item><item><title>4.2 InnoDB 스토리지 엔진 아키텍처(1)</title><link>https://codemario318.github.io/post/real_mysql_4_2_1/</link><pubDate>Tue, 11 Apr 2023 19:15:11 +0900</pubDate><guid>https://codemario318.github.io/post/real_mysql_4_2_1/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_1/real_mysql.jpeg" alt="Featured image of post 4.2 InnoDB 스토리지 엔진 아키텍처(1)" />&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_1/mysql_4_9.png"
width="430"
height="388"
srcset="https://codemario318.github.io/post/real_mysql_4_2_1/mysql_4_9_hu105976b7b8154af6ae8266098f664ca6_57568_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_1/mysql_4_9_hu105976b7b8154af6ae8266098f664ca6_57568_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="InnoDB 구조"
class="gallery-image"
data-flex-grow="110"
data-flex-basis="265px"
>&lt;/p>
&lt;p>InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.&lt;/p>
&lt;h2 id="프라이머리-키에-의한-클러스터링">프라이머리 키에 의한 클러스터링&lt;/h2>
&lt;p>InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 자장된다.&lt;/p>
&lt;ul>
&lt;li>프라이머리 키 값의 순서대로 디스크에 저장되며, 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.&lt;/li>
&lt;li>프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.&lt;/li>
&lt;li>쿼리의 실행계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다.&lt;/li>
&lt;/ul>
&lt;h2 id="외래-키-지원">외래 키 지원&lt;/h2>
&lt;p>외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.&lt;/p>
&lt;p>외래 키는 데이터베이스 서버 운영의 불편함 때문에 서비스용 데이터베이스에서는 생성하지 않는 경우도 자주 있다. 그렇다 하더라도 개발 환경의 데이터베이스에서는 좋은 가이드 역할을 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요함&lt;/li>
&lt;li>변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로, 잠금이 여러 테이블로 전파됨&lt;/li>
&lt;li>그로인한 데드락이 발생할 때가 많으므로 개발할때도 외래 키의 존재에 주의하는 것이 좋음&lt;/li>
&lt;/ul>
&lt;p>수동으로 데이터를 적재하거나 스키마 변경 등의 관리 작업이 실패할 수 있다. 부모 테이블과 자식 테이블의 관계를 명확히 파악해서 순서대로 작업한다면 문제없이 실행될 수 있지만 외래키가 복잡하게 얽힌 경우에는 간단하지 않다.&lt;/p>
&lt;p>&lt;code>foreign_key_checks&lt;/code> 시스템 변수를 &lt;code>OFF&lt;/code>로 설정하면 외래키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다. 외래키 체크 작업을 일시적으로 멈추면 대략 레코드 적재나 삭제 등의 작업도 부가적인 체크가 필요 없기 때문에 훨씬 빠르게 처리할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">foreign_key_checks&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">OFF&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/* 작업 수행 ... */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">foreign_key_checks&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>외래키 체크를 일시적으로 중지한 상태에서 외래키 관계를 가진 부모 테이블의 레코드를 삭제했다면 반드시 자식 테이블의 레코드도 살제하여 일관성을 맞춰준 후 다시 외래키 체크 기능을 활성화 해야 한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>foreign_key_checks&lt;/code>가 비활성화되면 외래키 관계의 부모 테이블에 대한 작업도 무시한다.(&lt;code>ON DELETE CASCADE&lt;/code>, &lt;code>ON UPDATE CASCADE&lt;/code>)&lt;/p>
&lt;/blockquote>
&lt;h2 id="mvcc---multi-version-concurrency-control">MVCC - Multi Version Concurrency Control&lt;/h2>
&lt;p>일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 &lt;em>&lt;strong>잠금을 사용하지 않는 일관된 읽기&lt;/strong>&lt;/em>를 제공하는 데 있다.&lt;/p>
&lt;p>InnoDB는 언두 로그(Undo log)를 이용해 이 기능을 구현한다.&lt;/p>
&lt;ul>
&lt;li>멀티 버전: 하나의 레코드에 대해 여러 개의 버전이 동시에 관리&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">member&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">m_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">m_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">m_area&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m_id&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ix_area&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m_area&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">member&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">m_name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">m_area&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;홍길동&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;서울&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">COMMIT&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">UPDATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">member&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">m_area&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;경기&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">m_id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_2_1/mysql_4_11.png"
width="381"
height="336"
srcset="https://codemario318.github.io/post/real_mysql_4_2_1/mysql_4_11_hu900f8d0207e527c4c59056077a732b18_46489_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_2_1/mysql_4_11_hu900f8d0207e527c4c59056077a732b18_46489_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="113"
data-flex-basis="272px"
>&lt;/p>
&lt;p>UPDATE 문장이 실행되면 커밋 실행 여부와 관계 없이 InnoDB의 버퍼풀은 새로운 값인 ‘경기’로 업데이트 된다. 그리고 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 스레드에 의해 새로운 값으로 업데이트돼 있을 수도 있고 아닐 수도 있다.(InnoDB가 ACID를 보장하기 때문에 일반적으로는 InnoDB의 버퍼풀과 데이터 파일은 동일한 상태라고 가정해도 무방함)&lt;/p>
&lt;p>아직 COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 다음 같은 쿼리로 작업 중인 레코드를 조회한다면, MySQL 서버의 시스템 변수(&lt;code>transaction_isolation&lt;/code>)에 설정된 격리 수준(Isolation level)에 따라 다르다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>READ_UNCOMMITED&lt;/code>: InnoDB 버퍼풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환한다.&lt;/li>
&lt;li>&lt;code>READ_COMMITTED&lt;/code>, &lt;code>REPEATABLE_READ&lt;/code>, &lt;code>SERIALIZABLE&lt;/code>: 아직 커밋되지 않았기 때문에 InnoDB 버퍼풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환한다.&lt;/li>
&lt;/ul>
&lt;p>이러한 과정을 DBMS에서는 MVCC라고 표현한다. 즉 하나의 레코드(회원번호가 12인 레코드)에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 다르다.&lt;/p>
&lt;p>트랜잭션이 길어지면 언두에서 관리하는 예전 데이터가 삭제되지 못하고 오랫동안 관리되어야 하며, 자연히 언두 영역이 저장되는 시스템 테이블 스페이스의 공간이 많이 늘어나는 상황이 발생할 수 있다.&lt;/p>
&lt;p>&lt;code>UPDATE&lt;/code> 쿼리가 실행되면 InnoDB 버퍼 풀은 즉시 새로운 데이터로 변경되고 기존 데이터는 언두영역으로 복사된다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>COMMIT&lt;/code>: InnoDB는 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어 버린다.&lt;/li>
&lt;li>&lt;code>ROLLBACK&lt;/code>: 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제한다.&lt;/li>
&lt;/ul>
&lt;p>커밋이 된다고 언두 영역의 백업 데이터가 항상 바로 삭제되지는 않고, 언두 영역을 필요로 하는 트랜잭션이 없을때 삭제된다.&lt;/p>
&lt;h2 id="잠금-없는-일관된-읽기---non-locking-consistent-read">잠금 없는 일관된 읽기 - Non-Locking Consistent Read&lt;/h2>
&lt;p>InnoDB 스토리지 엔진은 MVCC 기술을 이용해 감금을 걸지 않고 읽기 작업을 수행한다. 잠금을 걸지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능하다.&lt;/p>
&lt;p>격리수준이 &lt;code>SERIALIZABLE&lt;/code>이 아닌 &lt;code>READ_UNCOMMITED&lt;/code>나 &lt;code>READ_COMMITED&lt;/code>, &lt;code>REPEATEABLE_READ&lt;/code> 수준인 경우 &lt;code>INSERT&lt;/code>와 연결되지 않은 순수한 읽기(&lt;code>SELECT&lt;/code>) 작업은 다른 트랜잭션의 변경 작업과 관계 없이 항상 잠금을 대기하지 않고 바로 실행된다.&lt;/p>
&lt;p>특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 변경 트랜잭션이 다른 사용자의 &lt;code>SELECT&lt;/code> 작업을 방해하지 않는다. 이를 ‘잠금 없는 일관된 읽기’ 라고 표현하며, InnoDB에서는 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다.&lt;/p>
&lt;p>오랜 시간 동안 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 문제가 발생할 때가 가끔 있는데, 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생하는 문제이다.&lt;/p>
&lt;p>따라서 트랜잭션이 시작됐다면 가능한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋다.&lt;/p>
&lt;h2 id="자동-데드락-감지">자동 데드락 감지&lt;/h2>
&lt;p>InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 &lt;strong>잠금 대기 목록&lt;/strong>(Wait-for List)을 그래프 형태로 관리한다. InnoDB 스토리지 엔진은 데드락 감지 스레드를 통해 주기적으로 잠금 대기를 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를 &lt;strong>강제 종료&lt;/strong>한다.&lt;/p>
&lt;blockquote>
&lt;p>트랜잭션의 언두 로그양이 적은 트랜잭션이 롤백 해도 처리한 내용이 적기 때문에 선택된다.&lt;/p>
&lt;/blockquote>
&lt;p>InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금(&lt;code>LOCK TABLES&lt;/code> 명령으로 잠긴 테이블)은 볼 수가 없어 데드락 감지가 불확실 할 수 있는데, &lt;code>innodb_table_locks&lt;/code> 시스템 변수를 활성화 하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 &lt;strong>테이블 레벨의 잠금&lt;/strong> 까지 감지할 수 있게 된다.&lt;/p>
&lt;p>일반적인 서비스에서는 데드락 감지 스레드가 데드락을 찾아내는 작업은 부담되지 않지만, 동시 처리 스레드가 매우 많아지거나 트랜잭션이 가진 잠금 개수가 많아지면 데드락 감지 스레드가 느려진다.&lt;/p>
&lt;p>데드락 감지 스레드는 잠금 목록을 검사해야 하기 때문에 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트(잠금 테이블)에 새로운 잠금을 걸고 데드락 스레드를 찾게 되는데, 데드락 감시 스레드가 느려지면 서비스 쿼리를 처리중인 스레드는 더는 작업을 진행하지 못하고 대기하며 서비스에 악영항을 미치게 된다. 이렇게 동시 처리 스레드가 매우 많은 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있다.&lt;/p>
&lt;p>&lt;code>innodb_deadlock_detect&lt;/code> 시스템 변수를 활용하여 데드락 감지 스레드를 비활성화 할 수 있다. 이럴 경우 데드락 상황 발생시 무한정 대기할 수도 있지만, &lt;code>innodb_lock_wait_timeout&lt;/code> 시스템 변수를 활성화하면 일정 시간이 지났을 경우 요청 실패하고 에러 메시지를 반환하게 만들 수 있다.&lt;/p>
&lt;p>데드락 감시 스레드가 부담되어 &lt;code>innodb_deadlock_detect&lt;/code>를 OFF로 설장해서 비활성화 하는 경우에는 &lt;code>innodb_lock_time_wait_timeout&lt;/code>을 기본값인 50초보다 훨씬 낮은 시간으로 변경하여 사용할 것을 권장한다.&lt;/p>
&lt;h2 id="자동화된-장애-복구">자동화된 장애 복구&lt;/h2>
&lt;p>InnoDB에는 손실이나 장애로 부터 데이터를 보호하기 위한 여러가지 메커니즘이 탑재돼있다. 그러한 메커니즘을 이용해 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된(Partial write)데이터 페이지 등에 대한 인련의 복구 작업이 자동으로 진행된다.&lt;/p>
&lt;p>InnoDB 스토리지 엔진은 매우 견고해서 데이터 파일이 손상되거나 MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않지만, 디스크나 하드웨어 이슈로 InnoDB 스토리지 엔진이 자동으로 복구를 못 하는 경우도 발생할 수 있는데, 한번 문제가 생기면 복구하기 쉽지 않다.&lt;/p>
&lt;p>InnoDB 데이터 파일은 기본적으로 서버가 시작될 때 자동 복구를 수행하며, 자동으로 복구될 수 없는 손상이 있다면 서버가 종료된다.&lt;/p>
&lt;h3 id="장애-복구-대응">장애 복구 대응&lt;/h3>
&lt;p>MySQL 서버의 설정 파일에 &lt;code>innodb_force_recovery&lt;/code> 시스템 변수를 설정하여 시작해야 한다.&lt;/p>
&lt;ul>
&lt;li>6: 로그 파일 손상&lt;/li>
&lt;li>1: 테이블의 데이터 파일이 손상&lt;/li>
&lt;li>어떤 부분이 문제인지 알 수 없다면 1~6까지 변경하며 재실행&lt;/li>
&lt;/ul>
&lt;p>이후 서버가 가동되고 InnoDB 테이블이 인식된다면 &lt;code>mysqldump&lt;/code>를 이용해 데이터를 가능한 만큼 백업하고 그 데이터로 MySQL 서버의 DB와 테이블을 다시 생성하는 것이 좋다.&lt;/p>
&lt;h3 id="innodb_force_recovery-옵션">&lt;code>InnoDB_force_recovery&lt;/code> 옵션&lt;/h3>
&lt;ul>
&lt;li>1(&lt;code>SRV_FORCE_IGNORE_CORRUPT&lt;/code>):&lt;br>
테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분이 발견되도 무시하고 서버를 시작한다.
&lt;ul>
&lt;li>&lt;strong>&amp;lsquo;Database page corruption on disk or a failed&amp;rsquo;&lt;/strong> 출력되는 경우가 많다.&lt;/li>
&lt;li>&lt;code>mysqldump&lt;/code>나 &lt;code>SELECT INTO OUTFILE ...&lt;/code>를 이용해 덤프하여 데이터베이스를 다시 구축하는 것이 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>2(&lt;code>SRV_FORCE_NO_BACKGROUND&lt;/code>):&lt;br>
백그라운드 스레드 가운데 메인 스레드를 시작하지 않고 MySQL 서버를 시작한다.
&lt;ul>
&lt;li>메인 스레드가 언두 데이터를 삭제하는 과정에서 장애가 발생했을때 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>3(&lt;code>SRV_FORCE_NO_TRX_UNDO&lt;/code>):&lt;br>
일반적으로 MySQL 서버는 재실행시 언두 영역의 데이터를 먼저 파일에 적용하고 리두 로그의 내용을 다시 덮어써서 장애 시점의 데이터 상태를 만들어 낸 후, 최종적으로 커밋되지 않은 트랜잭션의 작업을 롤백하지만 3으로 설정시 롤백하지 않고 그대로 나둔다.
&lt;ul>
&lt;li>커밋되지 않고 종료된 트랜잭션은 계속 그 상태로 남아있게 된다.&lt;/li>
&lt;li>백업 후 데이터베이스를 다시 구축하는 것이 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>4(&lt;code>SRV_FORCE_NO_IBUF_MERGE&lt;/code>):&lt;br>
InnoDB는 &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 등의 데이터 변경으로 인한 인덱스 변경 작업을 상황에 따라 즉시처리 혹은 버퍼에 두고 나중에 처리할 수 있다. 인서트 버퍼를 통해 처리가 될 경우, 비정상 종료시 병합 될지 알 수 없기 때문에, 인서트 버퍼의 손상을 감지하면 에러를 발생시켜 MySQL 서버의 실행을 막는다.
&lt;ul>
&lt;li>인서트 버퍼의 내용을 무시하고 강제로 MySQL을 실행시킨다.&lt;/li>
&lt;li>인서트 버퍼는 실제 데이터와 관련된 부분이 아니라, 인덱스에 관련된 부분이므로 테이블을 텀프한 후 다시 데이터베이스를 구축하면 데이터의 손실 없이 복구할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>5(&lt;code>SRV_FORCE_NO_UNDO_LOG_SCAN&lt;/code>):&lt;br>
MySQL 서버가 종료되는 시점에 처리중인 트랜잭션이 있을 경우 별도의 처리 없이 커넥션을 강제로 끊어버리고 종료된다. MySQL 서버가 재실행되면 InnoDB 엔진은 언두 레코드를 이용해 데이터 페이지를 복구하고 리두 로그를 적용해 종료 시점의 상태로 만들고, 커밋되지 않은 트랜잭션에서 변경한 작업은 모두 롤백 처리한다. 이때 InnoDB 스토리지 엔진이 언두 로그를 사용할 수 없다면 에러가 발생하여 MySQL 서버가 실행될 수 없다.
&lt;ul>
&lt;li>언두 로그를 모두 무시하고 실행한다.&lt;/li>
&lt;li>MySQL 서버가 종료되던 시점에 커밋되지 않았던 작업도 모두 커밋된 것처럼 처리되어 잘못된 데이터가 남을 수 있다.&lt;/li>
&lt;li>데이터를 백업하고, 데이터베이스를 새로 구축해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>6(&lt;code>SRV_FORCE_NO_LOG_REDO&lt;/code>):&lt;br>
InnoDB 스토리지 엔진의 리두 로그가 손상되면 MySQL 서버가 실행되지 못한다. 해당 복구 모드로 실행하면 리두 로그를 무시하고 서버가 실행된다.&lt;br>
트랜잭션이 커밋됐다 하더라도 리두 로그에만 기록되고 데이터 파일에 기록되지 않은 데이터는 모두 무시되므로 마지막 체크 포인트시점의 데이터만 남게 된다.
&lt;ul>
&lt;li>기존 InnoDB의 리두 로그는 모두 삭제 또는 백업하고 MySQL 서버를 시작하는 것이 좋다.&lt;/li>
&lt;li>데이터를 백업하고 MySQL 서버를 새로 구축하는 것이 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위 방법을 수행해도 MySQL서버가 시작되지 않으면 백업을 이용해 다시 구축하는 방법밖에 없다. 백업이 있다면 마지막 백업으로 데이터베이스를 다시 구축하고, 바이너리 로그를 사용해 최대한 장애 시점까지의 데이터를 복구할 수도 있다.&lt;/p>
&lt;blockquote>
&lt;p>마지막 풀 백업 시점부터 장애 시점까지의 바이너리 로그가 있다면 이용하는 것이 데이터 손실이 더 적을 수 있다.&lt;/p>
&lt;/blockquote>
&lt;p>백업은 있지만 복제의 바이너리 로그가 없거나 손실되었다면, 마지막 백업 시점가지만 복구할 수 있다.&lt;/p></description></item><item><title>4.1 MySQL 엔진 아키텍처</title><link>https://codemario318.github.io/post/real_mysql_4_1/</link><pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate><guid>https://codemario318.github.io/post/real_mysql_4_1/</guid><description>&lt;img src="https://codemario318.github.io/post/real_mysql_4_1/real_mysql.jpeg" alt="Featured image of post 4.1 MySQL 엔진 아키텍처" />&lt;h2 id="mysql의-전체-구조">MySQL의 전체 구조&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_1/mysql_4_1.png"
width="780"
height="802"
srcset="https://codemario318.github.io/post/real_mysql_4_1/mysql_4_1_hu83fe18d660041abfde171686de4da5cf_206729_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_1/mysql_4_1_hu83fe18d660041abfde171686de4da5cf_206729_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL 전체 구조"
class="gallery-image"
data-flex-grow="97"
data-flex-basis="233px"
>
MySQL 서버는 크게 &lt;strong>MySQL 엔진&lt;/strong>과 &lt;strong>스토리지 엔진&lt;/strong>으로 구분할 수 있다.&lt;br>
사람으로 비유하면 MySQL 엔진은 머리 역할을 담담하고, 스토리지 엔진은 손과 발의 역할을 담당한다.&lt;/p>
&lt;h2 id="mysql-엔진">MySQL 엔진&lt;/h2>
&lt;p>MySQL 엔진은 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행한다.&lt;/p>
&lt;ul>
&lt;li>커넥션 핸들러: 클라이언트 요청에 따라 새로운 연결을 생성하고 관리&lt;/li>
&lt;li>SQL 파서 및 전처리기: SQL 쿼리를 최적화 및 실행하기 전에 구문 분석 및 전처리를 담당&lt;/li>
&lt;li>옵티마이저: 쿼리의 최적화&lt;/li>
&lt;/ul>
&lt;p>MySQL은 표준 SQL(ANSI SQL) 문법을 지원하기 때문에 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환되어 실행될 수 있다.&lt;/p>
&lt;h2 id="스토리지-엔진">스토리지 엔진&lt;/h2>
&lt;p>스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 역할 수행한다.&lt;/p>
&lt;p>MySQL 서버에서 MySQL엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">test_table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fd2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">INNODB&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위처럼 테이블이 사용할 스토리지 엔진을 지정하면 해당 테이블의 모든 읽기 작업과 변경 작업은 정의된 스토리지 엔진이 처리한다.&lt;/p>
&lt;p>각 스토리지 엔진은 성능 향상을 위해 &lt;code>키 캐시&lt;/code>(MyISAM), &lt;code>버퍼풀&lt;/code>(InnoDB) 같은 기능을 내장하고 있다.&lt;/p>
&lt;h2 id="핸들러-api">핸들러 API&lt;/h2>
&lt;p>MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러 요청이라고 하며, 사용되는 API를 핸들러 API라고 한다.&lt;/p>
&lt;p>InnoDB 스토리지 엔진 또한 이 핸들러 API를 이용해 MySQL 엔진과 데이터를 주고 받는다.&lt;/p>
&lt;p>핸들러 API를 통해 발생한 작업은 아래 쿼리로 확인 가능하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Handler%&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="mysql-스레딩-구조">MySQL 스레딩 구조&lt;/h2>
&lt;p>MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 동작한다.&lt;/p>
&lt;p>MySQL 서버에서 실행 중인 스레드 목록은 &lt;code>performance_schema&lt;/code> 데이터베이스에 &lt;code>threads&lt;/code> 테이블을 통해 확인할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">thread_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">type&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">processlist_user&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">processlist_host&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">threads&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">type&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">thread_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>백그라운드 스레드의 개수는 MySQL 서버의 설정 내용에 따라 가변적일 수 있다. 동일한 스레드가 2개 이상씩 보이는 것은 MySQL 서버의 설정 내용에 의해 여러 스레드가 동일 작업을 병렬로 처리하는 경우이다.&lt;/p>
&lt;h3 id="포그라운드-스레드클라이언트-스레드">포그라운드 스레드(클라이언트 스레드)&lt;/h3>
&lt;p>포그라운드 스레드는 클라이언트 연결 요청을 처리하고 데이터베이스 작업을 수행한다. 이러한 스레드는 쿼리 실행 중에 CPU 및 I/O 리소스를 사용하므로, 성능에 중요한 역할을 한다.&lt;/p>
&lt;p>포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다.&lt;/p>
&lt;p>클라이언트 사용자가 작업을 마치고 커넥션을 종료하면, 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 돌아간다.&lt;/p>
&lt;p>이때 이미 스레드 캐시에 일정 개수 이상의 대기중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 한다.&lt;/p>
&lt;p>스레드 캐시에 유지할 수 있는 최대 스레드 개수는 &lt;code>thread_cache_size&lt;/code> 시스템 변수로 설정한다.&lt;/p>
&lt;p>포그라운드 스레드는 데이터를 MySQL 데이터 버퍼나 캐시로 부터 가져오며, 버퍼나 캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.&lt;/p>
&lt;ul>
&lt;li>MyISAM: 디스크 쓰기 작업까지 포그라운드 스레드가 처리&lt;/li>
&lt;li>InnoDB: 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리&lt;/li>
&lt;/ul>
&lt;h3 id="백그라운드-스레드">백그라운드 스레드&lt;/h3>
&lt;p>MyISAM의 경우 해당 사항이 별로 없지만, InnoDB는 다음과 같이 여러가지 작업이 백그라운드로 처리된다.&lt;/p>
&lt;ul>
&lt;li>인서트 버퍼(Insert Buffer)를 병합하는 스레드&lt;/li>
&lt;li>로그를 디스크로 기록하는 스레드&lt;/li>
&lt;li>InnoDB 버퍼풀의 데이터를 디스크에 기록하는 스레드&lt;/li>
&lt;li>데이터 버퍼로 읽어 오는 스레드&lt;/li>
&lt;li>잠금이나 데드락을 모니터링 하는 스레드&lt;/li>
&lt;/ul>
&lt;p>모두 중요한 역할을 수행하지만 로그 스레드와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리하는 쓰기 스레드(Write thread)가 특히 중요하다.&lt;/p>
&lt;p>MySQL 5.5 버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 2개 이상 지정할 수 있게 됐으며, &lt;code>innodb_write_io_thread&lt;/code>, &lt;code>innodb_read_io_threads&lt;/code> 시스템 변수로 스레드의 개수를 설정한다.&lt;/p>
&lt;blockquote>
&lt;p>InnoDB에서도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드는 많이 설정할 필요는 없지만, 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 일반적인 내장 디스크를 사용할때는 2~4 정도, DAS, SAN과 같은 스토리지를 사용할 때는 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다.&lt;/p>
&lt;/blockquote>
&lt;p>사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다. 일반적인 상용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 있다.&lt;/p>
&lt;ul>
&lt;li>InnoDB: &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다.&lt;/li>
&lt;li>MyISAM: 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계되어, 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.&lt;/li>
&lt;/ul>
&lt;h2 id="메모리-할당-및-사용-구조">메모리 할당 및 사용 구조&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_1/mysql_4_3.png"
width="640"
height="423"
srcset="https://codemario318.github.io/post/real_mysql_4_1/mysql_4_3_huc090c2efafb1abf5a9a425a77bd2dd06_96981_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_1/mysql_4_3_huc090c2efafb1abf5a9a425a77bd2dd06_96981_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL 메모리 할당 구조"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="363px"
>&lt;/p>
&lt;p>글로벌 메모리 영역과 로컬 메모리 영역으로 구분되며, 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분된다.&lt;/p>
&lt;h3 id="글로벌-메모리-영역">글로벌 메모리 영역&lt;/h3>
&lt;p>일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다. 필요에 따라 2개 이상의 메모리 공간을 할당받을 수도 있지만 클라이언트의 스레드 수와 무관하며, 생성된 글로벌 영역이 N개라 하더라도 모든 스레드에 의해 공유된다.&lt;/p>
&lt;ul>
&lt;li>테이블 캐시&lt;/li>
&lt;li>InnoDB 버퍼풀&lt;/li>
&lt;li>InnoDB 어댑티드 해시 인덱스&lt;/li>
&lt;li>InnoDB 리두 로그 버퍼&lt;/li>
&lt;/ul>
&lt;p>등이 대표적인 글로벌 메모리 영역이다.&lt;/p>
&lt;h3 id="로컬-메모리-영역">로컬 메모리 영역&lt;/h3>
&lt;p>세션 메모리 영역이라고도 표현하며, MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다.&lt;/p>
&lt;ul>
&lt;li>정렬 버퍼&lt;/li>
&lt;li>조인 버퍼&lt;/li>
&lt;li>바이너리 로그 캐시&lt;/li>
&lt;li>네트워크 버퍼&lt;/li>
&lt;/ul>
&lt;p>MySQL 서버에 클라이언트가 접속하면, 클라이언트 커넥션(세션)으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당하게 되는데, 클라이언트 스레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리 영역이라고도 한다.&lt;/p>
&lt;p>로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다.&lt;/p>
&lt;p>일반적으로 글로벌 메모리 영역의 크기는 주의해서 설정하지만 소트 버퍼와 같은 오컬 메모리 영역은 크게 신경 쓰지 않고 설정하는데, 최악의 경우 MySQL 서버가 메모리 부족으로 멈춰 버릴수도 있으므로 적절한 메모리 공간을 설정하는 것이 중요하다.&lt;/p>
&lt;ul>
&lt;li>커넥션이 열러있는 동안 계속 할당된 상태로 남아있는 경우: 커넥션 버퍼, 결과 버퍼&lt;/li>
&lt;li>쿼리를 실행하는 순간에만 할당: 소트 버퍼, 조인 버퍼&lt;/li>
&lt;/ul>
&lt;h2 id="플러그인-스토리지-엔진-모델">플러그인 스토리지 엔진 모델&lt;/h2>
&lt;p>MySQL의 독특한 구조 중 대표적인 중 하나가 플러그인 모델이다.&lt;/p>
&lt;ul>
&lt;li>스토리지 엔진&lt;/li>
&lt;li>검색 엔진을 위한 검색어 파서&lt;/li>
&lt;li>사용자의 인증을 위한 Native Authentication, Caching SHA-2 Authentication 등&lt;/li>
&lt;/ul>
&lt;p>MySQL은 이미 기본적으로 많은 스토리지 엔진을 가지고 있지만, 필요에 의해 직접 스토리지 엔진을 만드는 것도 가능하다.&lt;/p>
&lt;p>MySQL에서 쿼리가 실행되는 과정을 보면 대부분 작업이 MySQL엔진에서 처리되고, 마지막 &lt;strong>데이터 읽기, 쓰기&lt;/strong> 작업만 스토리지 엔진에 의해 처리한다.&lt;/p>
&lt;p>&lt;code>GROUP BY&lt;/code>, &lt;code>ORDER BY&lt;/code> 등 복잡한 처리는 스토리지 엔진 영역이 아니라 MySQL 엔진의 처리 영역인 &lt;strong>쿼리 실행기&lt;/strong>에서 처리된다.&lt;/p>
&lt;p>스토리지 엔진에 따라 데이터 읽기/쓰기 작업 처리 방식이 크게 달라질 수 있다.&lt;/p>
&lt;p>하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 MySQL 엔진 영역에서 처리되는지 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* 스토리지 엔진 조회 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINES&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>서버에 포함되지 않은 스토리지 엔진을 사용하려면 MySQL 서버를 다시 빌드해야 한다. 준비만 되어있다면 플러그인 형태로 빌드된 스토리지 엔진 라이브러리를 다운로드해서 끼워넣기만 하면 사용할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* 플러그인 조회 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PLUGINS&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="컴포넌트">컴포넌트&lt;/h2>
&lt;p>플러그인 아키텍처는 다음과 같은 단점이 있다.&lt;/p>
&lt;ul>
&lt;li>오직 MySQL 서버와 인테페이스할 수 있고, 플러그인끼리는 통신할 수 없음&lt;/li>
&lt;li>MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안됨)&lt;/li>
&lt;li>플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어려움&lt;/li>
&lt;/ul>
&lt;p>이러한 문제를 개선하기 위해 MySQL 8.0 부터는 기존의 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원된다.&lt;/p>
&lt;p>예를 들면, MySQL 5.7 버전까지는 비밀번호 검증 기능이 플러그인 형태로 제공됐지만 MySQL8.0의 비밀번호 검증 기능은 컴포넌트로 개선됐다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* validate_password 설치 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">INSTALL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">COMPONENT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;file://component_validate_password&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="cm">/* 설치된 컴포넌트 확인 */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">component&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="쿼리-실행-구조">쿼리 실행 구조&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/real_mysql_4_1/mysql_4_6.png"
width="411"
height="302"
srcset="https://codemario318.github.io/post/real_mysql_4_1/mysql_4_6_hue3f22860c2cd0cfc88afa48f7566f2b3_32277_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/real_mysql_4_1/mysql_4_6_hue3f22860c2cd0cfc88afa48f7566f2b3_32277_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="쿼리 실행 구조"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="326px"
>&lt;/p>
&lt;h3 id="쿼리-파서">쿼리 파서&lt;/h3>
&lt;p>쿼리 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태의 구조로 만들어 내는 작업을 의미한다.&lt;/p>
&lt;ul>
&lt;li>쿼리 문장의 기본 문법 오류는 이 과정에서 발견되고 사용자에게 오류 메시지를 전달하게 된다.&lt;/li>
&lt;/ul>
&lt;h3 id="전처리기">전처리기&lt;/h3>
&lt;p>파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.&lt;/p>
&lt;p>각 토큰을 테이블 이름이나 컬럼 이름, 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인하는 과정을 수행한다.&lt;/p>
&lt;ul>
&lt;li>실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰(컬럼, 내장 함수)은 이 단계에서 걸러진다.&lt;/li>
&lt;/ul>
&lt;h3 id="옵티마이저">옵티마이저&lt;/h3>
&lt;p>사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할을 담당한다.&lt;/p>
&lt;p>DBMS의 두뇌에 비유되며, 옵티마이저가 더 나은 선택을 하도록 유도하는 것이 매우 중요하다.&lt;/p>
&lt;h3 id="실행-엔진">실행 엔진&lt;/h3>
&lt;p>옵티마이저가 두뇌라면 실행 엔진과 핸들러는 손과 발에 비유할 수 있다.&lt;/p>
&lt;p>옵티마이저가 &lt;code>GROUP BY&lt;/code>를 처리하기 위해 임시 테이블을 사용하기로 결정했다면 아래 과정을 거칠 수 있다.&lt;/p>
&lt;ol>
&lt;li>실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청&lt;/li>
&lt;li>실행 엔진은 &lt;code>WHERE&lt;/code> 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청&lt;/li>
&lt;li>읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 핸들러에게 요청&lt;/li>
&lt;li>데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 요청&lt;/li>
&lt;li>결과를 사용자나 다른 모듈로 넘김&lt;/li>
&lt;/ol>
&lt;p>즉, 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.&lt;/p>
&lt;h3 id="핸들러스토리지-엔진">핸들러(스토리지 엔진)&lt;/h3>
&lt;p>MySQL 서버의 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당한다.&lt;/p>
&lt;p>핸들러는 결국 스토리지 엔진을 의미하며, MyISAM 테이블을 조작하는 경우 핸들러가 MyISAM 스토리지 엔진이 되고, InnoDB 테이블을 조작하는 경우 InnoDB 스토리지 엔진이 된다.&lt;/p>
&lt;h2 id="복제">복제&lt;/h2>
&lt;p>MySQL 서버에서 복제(Replication)는 매우 중요한 역할을 담당하며, 지금까지 MySQL 서버에서 복제는 많은 발전을 거듭해왔다.(16장)&lt;/p>
&lt;h2 id="쿼리-캐시">쿼리 캐시&lt;/h2>
&lt;p>쿼리 캐시는 빠른 응답을 필요로 하는 웹 기반의 응용 프로그램에서 매우 중요한 역할을 담당했다. 쿼리 캐시는 SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환하기 때문에 매우 빠른 성능을 보였다.&lt;/p>
&lt;p>하지만 쿼리 캐시는 테이블의 데이터가 변경되면 캐시에 저장된 결과 중에서 변경된 테이블과 관련된 테이블과 관련된 것들은 모두 삭제(Invalidate)해야 하므로, 심각한 동시 처리 성능 저하를 유발한다. 또한 MySQL 서버가 발전하면서 성능이 개선되는 과정에서 쿼리 캐시는 계속된 동시 처리 성능 저하와 많은 버그의 원인이 되기도 했다.&lt;/p>
&lt;blockquote>
&lt;p>다수의 클라이언트가 동시에 같은 쿼리를 실행하는 경우 쿼리 캐시 락(query cache lock)이 발생 가능하다. 이는 쿼리 캐시에 새로운 결과를 저장하거나 기존 결과를 반환하기 위해 필요한 락(lock)으로, 동시 처리가 많은 시스템에서는 쿼리 캐시를 사용하지 않는 것이 더 나은 성능을 보일 수 있다.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>MySQL 5.6 이하 버전에서는 쿼리 캐시가 InnoDB 또는 NDB Cluster 스토리지 엔진을 사용하는 경우에만 동작하는데 MyISAM 스토리지 엔진을 사용하는 경우에도 쿼리 캐시를 켜면 쿼리 결과가 무한정 캐시될 수 있는 버그가 있었다. 이러한 버그는 시스템의 부하를 높일 뿐만 아니라, 캐시 메모리의 공간을 차지해 다른 쿼리의 실행에 영향을 미칠 수 있다.&lt;/p>
&lt;/blockquote>
&lt;p>이러한 이유로 MySQL 8.0으로 올라오면서 &lt;em>완전히 제거되고, 관련 시스템 변수도 모두 제거&lt;/em>되었다.&lt;/p>
&lt;h2 id="스레드-풀">스레드 풀&lt;/h2>
&lt;p>MySQL 서버 엔터프라이즈 에디션은 스레드풀 기능을 제공하지만 커뮤니티 에디션은 지원하지 않는다. 따라서 Percona Server 플러그인에서 제공하는 스레드풀 기능을 살펴본다.&lt;/p>
&lt;p>스레드풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다 하더라도 MySQL 서버의 CPU가 &lt;strong>제한된 개수의 스레드 처리에만 집중할 수 있게 하여 서버의 자원 소모를 줄이는것이 목적&lt;/strong>이다.&lt;/p>
&lt;p>하지만 스레드풀이 실제 서비스에서 눈에띄는 성능 향상을 보여준 경우는 드물다.&lt;/p>
&lt;p>실행 중인 스레드들을 CPU가 최대한 잘 처리해낼 수 있는 수준으로 줄여서 빨리 처리하게 하는 기능으므로 스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하는 경우 쿼리 처리가 더 느려지는 사례도 발생할 수 있다.&lt;/p>
&lt;p>제한된 수의 스레드만으로 CPU가 처리하도록 적절히 유도하면 CPU의 프로세서 친화도(Processor affinity)도 높히고 불필요한 컨텍스트 스위치를 줄여 오버헤드를 낮출 수 있다.&lt;/p>
&lt;h3 id="스레드-그룹-개수">스레드 그룹 개수&lt;/h3>
&lt;p>Percona Server의 스레드 풀은 기본적으로 CPU 코어의 개수만큼 스레드 그룹을 생성하며 일반적으로 CPU 코어의 개수와 맞추는것이 CPU 프로세서 친화도를 높이는 데 좋다.&lt;/p>
&lt;p>MySQL 서버가 처리해야할 요청이 생기면 스레드풀로 처리를 이관하는데, 이미 스레드풀이 처리중인 작업이 있는 경우 시스템 변수에 설정된 개수만큼 추가로 더 받아들여서 처리한다. 너무 많으면 스케줄링해야 할 수레드가 많아져 비효율적으로 작동할 수 있다.&lt;/p>
&lt;h3 id="타이머-스레드">타이머 스레드&lt;/h3>
&lt;p>스레드 그룹의 모든 스레드가 일을 처리하고 있다면 스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드를 추가할지, 기존 작업 스레드가 처리를 완료할 때가지 기다릴지 여부를 판단해야 한다.&lt;/p>
&lt;p>주기적으로 스레드 그룹의 상태를 체크해서 &lt;code>thread_pool_stall_limit&lt;/code> 시스템 변수에 정의된 시간에 작업을 끝내지 못했다면 새로운 스레드를 생성해 스레드 그룹에 추가한다.&lt;/p>
&lt;p>모든 스레드 그룹의 스레드가 작업을 수행중이라면 시스템 변수에 설정된 개수를 넘어설 수 없어 대기해야 한다.&lt;/p>
&lt;p>응답 시간이 아주 민감한 서비스라면 시스템 변수를 적절히 낮춰 설정해야하며, 0에 가까운 값으로 설정하는 것은 좋지 않고 이런 경우는 스레드풀을 사용하지 않는 것이 좋을 수 있다.&lt;/p>
&lt;h3 id="우선순위-큐">우선순위 큐&lt;/h3>
&lt;p>선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능도 제공한다. 먼저 시작된 트랜잭션 내에 속한 SQL을 빨리 처리해주면 해당 트랜잭션이 가지고 있던 잠금이 빨리 해제되고 잠금 경합을 낮춰 전체적인 처리 성능을 향상시킬 수 있다.&lt;/p>
&lt;h1 id="트랜잭션-지원-메타데이터">트랜잭션 지원 메타데이터&lt;/h1>
&lt;p>데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보를 데이터 딕셔너리 또는 메타데이터라고 하는데, MySQL 서버는 5.7 버전까지 테이블의 구조를 FRM 파일에 저장하고 일부 스토어드 프로그램 또한 파일 기반으로 관리 되었다.&lt;/p>
&lt;p>이러한 파일 기반의 메타데이터는 생성 및 변경 작업이 트랜잭션을 지원하지 않기 때문에 테이블의 생성 또는 변경 도중에 MySQL 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남게되는 문제가 있었다.&lt;/p>
&lt;p>이에따라 8버전 부터는 테이블의 구조 정보나 스토어드 프로그램의 코드 관련 정보를 모두 InnoDB의 테이블에 저장하도록 개선되었다.&lt;/p></description></item></channel></rss>