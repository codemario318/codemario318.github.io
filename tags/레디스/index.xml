<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>레디스 on Mario Blog</title><link>https://codemario318.github.io/tags/%EB%A0%88%EB%94%94%EC%8A%A4/</link><description>Recent content in 레디스 on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Sat, 24 Aug 2024 16:38:50 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/%EB%A0%88%EB%94%94%EC%8A%A4/index.xml" rel="self" type="application/rss+xml"/><item><title>3. 구글 맵</title><link>https://codemario318.github.io/post/system-design-interview-2/3/</link><pubDate>Sat, 24 Aug 2024 16:38:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/3/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/cover.png" alt="Featured image of post 3. 구글 맵" />&lt;p>구글 맵은 위성 이미지, 거리 뷰, 실시간 교통 상항, 경로 계획 등 다양한 서비스를 제공하고 있다.&lt;/p>
&lt;p>엄청나게 복잡한 제품이므로, 설계에 앞서 어떤 기능에 초점을 맞추어야 하는지 확인해야 한다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;ul>
&lt;li>Q. 일간 능동 사용자 수는?
&lt;ul>
&lt;li>A. 10억 DAU&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 초점을 두어야하는 기능은?
&lt;ul>
&lt;li>A. 위치 갱신, 경로 안내, ETA, 지도 표시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 도로 데이터는 어느정도, 데이터는 확보 되었다고 가정?
&lt;ul>
&lt;li>A. 도로 데이터는 다양한 결로로 확보해 두었다고 가정, 수 TB 수준의 가공되지 않은 데이터&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 교통 상황도 고려해야하는가?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 여러 이동 수단 고려?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 경유지 선택 가능?
&lt;ul>
&lt;li>A. N&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 사업장 정보도 포함?
&lt;ul>
&lt;li>A. N&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="기능-요구사항">기능 요구사항&lt;/h3>
&lt;p>이번 장에서는 3가지 기능에 집중 할 것이며, 지원할 주 단말은 스마트폰이다.&lt;/p>
&lt;ul>
&lt;li>사용자 위치 갱신&lt;/li>
&lt;li>경로 안내 서비스(ETA 포함)&lt;/li>
&lt;li>지도 표시&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항-및-제약사항">비기능 요구사항 및 제약사항&lt;/h3>
&lt;ul>
&lt;li>정확도
&lt;ul>
&lt;li>사용자에게 잘못된 경로를 안내하면 안됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>부드러운 경로 표시
&lt;ul>
&lt;li>제공되는 경로는 화면에 부드럽게 표시되고 갱신되어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 및 배터리 사용량
&lt;ul>
&lt;li>클라이언트가 최소한의 데이터와 배터리를 사용해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>일반적으로 널리 통용되는 가용성 및 규모 확장성 요구사항을 만족해야함&lt;/li>
&lt;/ul>
&lt;h3 id="지도-101">지도 101&lt;/h3>
&lt;p>&lt;strong>측위 시스템&lt;/strong>&lt;/p>
&lt;p>측위 시스템은 구 표면상의 위치를 표현하는 체계를 말한다.&lt;/p>
&lt;p>위경도 기반 측위 시스템의 경우, 최상단에는 북극이 있고 최하단에는 남극이 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img.png"
width="469"
height="460"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_hu4ecfd35b0eaef394414174e94c849f4b_312747_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_hu4ecfd35b0eaef394414174e94c849f4b_312747_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="위도와 경도"
class="gallery-image"
data-flex-grow="101"
data-flex-basis="244px"
>&lt;/p>
&lt;ul>
&lt;li>위도(Latitude, Lat.)
&lt;ul>
&lt;li>주어진 위치가 얼마나 남/북쪽인지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>경도(Longitude)
&lt;ul>
&lt;li>얼마나 동/서 쪽인지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>3차원 위치를 2차원 변환&lt;/strong>&lt;/p>
&lt;p>3차원 구 위의 위치를 2차원 평면에 대응시키는 절차를 &lt;strong>지도 투영법&lt;/strong>(map projection)또는 &lt;strong>도법&lt;/strong>이라 부른다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_1.png"
width="1920"
height="1108"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_1_hu6679b85ef3a54a92f40f68b74cd7f354_2863712_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_1_hu6679b85ef3a54a92f40f68b74cd7f354_2863712_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="지도 투영법 사이의 차이점"
class="gallery-image"
data-flex-grow="173"
data-flex-basis="415px"
>&lt;/p>
&lt;p>여러 도법이 있으며 각각 차별되는 장점이 있으나 공통적으로 실제 지형의 기하학적 틍성을 왜곡한다는 공통점을 갖는다.&lt;/p>
&lt;p>구글 맵은 메르카토르 도법을 조금 변경한 &lt;strong>웹 메르카토르&lt;/strong>(WebMercator) 도법을 사용한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>지오코딩&lt;/strong>&lt;/p>
&lt;p>지오코딩은 주소를 지리적 측위 시스템의 좌표로 변환하는 프로세스이다.&lt;/p>
&lt;p>지오 코딩을 수행하는 한 가지 방법은 GIS와 같은 다양한 시스템이 제공하는 데이터를 결합하는 인터폴레이션(interpolation)이 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>GIS - Geographic Information System&lt;/strong>&lt;br>
도로망을 지리적 좌표 공간에 대응시키는 방법을 제공하는 시스템들 중 하나&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>&lt;strong>지오해싱&lt;/strong>&lt;/p>
&lt;p>지도 위 특정 영역을 영문자와 숫자로 구성된 짧은 문자열에 대응시키는 인코딩 체계이다.&lt;/p>
&lt;p>2차원의 평면 공간으로 표현된 지리적 영역 위의 격자를 더 작은 격자로 재귀적으로 분할해나간다.&lt;/p>
&lt;ul>
&lt;li>각 격자는 정사각형, 사각형 일 수 있다.&lt;/li>
&lt;/ul>
&lt;p>격자를 재귀적으로 분할한 결과로 생성된 더 작은 격자에는 0~3의 번호를 부여한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_2.png"
width="623"
height="365"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_2_hue1d5f8bcb8e879d614ad41727ff0e80a_250766_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_2_hue1d5f8bcb8e879d614ad41727ff0e80a_250766_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="지오해싱"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="409px"
>&lt;/p>
&lt;p>이번 설계에서는 &lt;strong>맵 타일&lt;/strong>관리를 위해 지오해싱을 활용한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>지도 표시&lt;/strong>&lt;/p>
&lt;p>지도를 화면에 표시하는 데 가장 기본이 되는 개념은 &lt;strong>타일&lt;/strong>(Tile)이다.&lt;/p>
&lt;ul>
&lt;li>지도 전부를 하나의 이미지로 표시하는 대신, 작은 타일로 쪼개어 표현한다.&lt;/li>
&lt;li>클라이언트는 보려는 영역에 관계된 타일만 다운받아 모자이크처럼 이어 붙인 다음 화면에 뿌린다.&lt;/li>
&lt;/ul>
&lt;p>확대/축소를 지원하기 위해 확대 수준에 따라 다른 종류의 타일을 준비한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>경로 안내 알고리즘을 위한 도로 데이터 처리&lt;/strong>&lt;/p>
&lt;p>대부분의 경로 탐색 알고리즘은 &lt;strong>데이크스트라 알고리즘&lt;/strong>이나 &lt;strong>A* 알고리즘&lt;/strong>의 변종이다.(그래프 기반 최단거리 탐색)&lt;/p>
&lt;p>따라서 모든 경로 탐색 알고리즘은 교차로를 노드, 도로를 간선으로 표현하는 그래프 자료 구조를 가정한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_3.png"
width="1400"
height="639"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_3_hu7451bd66519cb9a67ca931e55612e325_1658967_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_3_hu7451bd66519cb9a67ca931e55612e325_1658967_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="그래프로 표현한 지도"
class="gallery-image"
data-flex-grow="219"
data-flex-basis="525px"
>&lt;/p>
&lt;p>대부분 경로 탐색 알고리즘은 주어진 그래프 크기에 성능이 좌우된다.&lt;/p>
&lt;p>따라서 성능을 위해 전 세계 도로망을 하나의 그래프로 표현하는 것이 아닌 &lt;strong>관리 가능 단위로 분할&lt;/strong>해야한다.&lt;/p>
&lt;p>타일 기반 분할법을 적용하여 세계를 작은 격자로 나누고, 각 격자 안의 도로망을 노드와 간선으로 구성된 그래프 자료구조로 변환한다.&lt;/p>
&lt;ul>
&lt;li>경로 안내 타일로 분할한다.&lt;/li>
&lt;li>각 타일은 도로로 연결된 다른 타일에 대한 참조를 유지한다.&lt;/li>
&lt;/ul>
&lt;p>도로망을 언제든 불러올 수 있는 경로 안내 타일로 분할해 놓으면 여러 장점이 있다.&lt;/p>
&lt;ul>
&lt;li>경로 탐색 알고리즘이 동ㅈ가하는 데 필요한 메모리 요구량을 낮출 수 있다.&lt;/li>
&lt;li>한 번에 처리해야 하는 경로의 양이 준다.&lt;/li>
&lt;li>필요한 만큼 만 불러오면 되므로 경로 탐색 성능도 좋아진다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>경로 안내 타일은 지도와 다르게 도로 데이터로 이루어진 이진 파일(binary file)이다.&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>&lt;strong>계층적 경로 안내 타일&lt;/strong>&lt;/p>
&lt;p>경로 안내가 효과적으로 동작하려면 &lt;strong>필요한 수준의 구체성&lt;/strong>을 갖춘 도로 데이터가 필요하다.&lt;/p>
&lt;p>보통 구체성 정도를 상, 중, 하로 구분하여 세 가지 종류의 경로 안내 타일을 준비한다.&lt;/p>
&lt;ul>
&lt;li>상
&lt;ul>
&lt;li>지방도(local roads) 데이터를 둔다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>중
&lt;ul>
&lt;li>규모가 비교적 큰 관할구(district)를 잇는 간선 도로 데이터를 둔다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>하
&lt;ul>
&lt;li>도시와 주를 연결하는 주요 고속도로 데이터만 둔다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_4.png"
width="1109"
height="910"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_4_hu07eab4d6f4ef51d47536904f92e584d5_498010_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_4_hu07eab4d6f4ef51d47536904f92e584d5_498010_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="크기가 서로 다른 경로 안내 타일"
class="gallery-image"
data-flex-grow="121"
data-flex-basis="292px"
>&lt;/p>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;p>설계 초점이 모바일 단말이므로, 데이터 사용량과 배터리 효율을 중요하게 따져 봐야 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>저장소 사용량 - 세계 지도&lt;/strong>&lt;/p>
&lt;p>지원하는 확대 수준(Zoom level)별로 지도 타일을 한 벌씩 두어야 한다.&lt;/p>
&lt;p>지도를 확대할 때 마다 하나의 타일을 네 장의 타일로 펼친다고 가정하면, 세계 지도를 21번 확대하여 볼 수 있으려면 최대 확대 수준을 대산으로 하였을 때 약 &lt;strong>4.4조&lt;/strong>개의 타일이 필요하다.&lt;/p>
&lt;ul>
&lt;li>한 장의 타일이 &lt;code>256 * 256&lt;/code> PNG 파일이라면 장당 100KB의 저장 공간이 필요하므로 440PB 만큼의 저장 공간이 필요하다.&lt;/li>
&lt;/ul>
&lt;p>하지만 지구 표면 가운데 90%는 인간이 살지 않는 자연 그대로의 바다, 사막, 호수, 산간 지역이라 아주 높은 비유롤 압축할 수 있다.&lt;/p>
&lt;p>보수적으로 80% ~ 90% 저장 용량을 절감할 수 있다고 가정하면, 50PB 정도 필요하다.&lt;/p>
&lt;p>1 ~ 21 까지 수준을 지원하기 위해 &lt;code>50 + (50/4) + (50/16) ... = ~ 67PB&lt;/code> 정도로 대충 100PB 정도가 소요된다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>서버 대역폭&lt;/strong>&lt;/p>
&lt;p>서버 대역폭을 추정하기 위해서는 어떤 유형의 요청을 처리해야 하는지 살펴 봐야 한다.&lt;/p>
&lt;ul>
&lt;li>경로 안내 요청
&lt;ul>
&lt;li>클라이언트가 경로 안내 세션을 시작할 때 전송하는 메시지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>위치 갱신 요청
&lt;ul>
&lt;li>클라이언트가 경로 안내를 진행하는 동안 변경된 사용자 위치를 전송하는 메시지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>경로 안내 요청을 처리하기 위한 대역폭을 계산해본다.&lt;/p>
&lt;ul>
&lt;li>DAU 10억, 평균 주당 35분 사용한다고 가정
&lt;ul>
&lt;li>하루에 50억 분&lt;/li>
&lt;li>요청을 클라이언트 쪽에 모아두었다가 덜 자주보내도록 하면 QPS를 낮출 수 있다.&lt;/li>
&lt;li>15초마다 한 번씩 보낸다고 가정하면 QPS는 20만&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_5.png"
width="710"
height="489"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_5_hu4e7e3e07d71836bb687df78814d2fbb6_116709_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_5_hu4e7e3e07d71836bb687df78814d2fbb6_116709_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="348px"
>&lt;/p>
&lt;ul>
&lt;li>위치 서비스&lt;/li>
&lt;li>경로 안내 서비스&lt;/li>
&lt;li>지도 표시&lt;/li>
&lt;/ul>
&lt;h3 id="위치-서비스">위치 서비스&lt;/h3>
&lt;p>사용자의 위치를 기록하는 역할을 담당한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart TD
mobile([모바일 사용자]) -->
loadBalancer[로드밸런서] -->
location[위치 서비스] -->
db[(사용자 위치 DB)]
&lt;/pre>
&lt;p>클라이언트가 &lt;strong>t&lt;/strong>초마다 자기 위치를 전송한다고 가정하는데, 주기적으로 위치 정보를 전송하면 몇 가지 좋은 점이 있다.&lt;/p>
&lt;ul>
&lt;li>해당 데이터 스트림을 활용하여 시스템을 점차 개선할 수 있다.
&lt;ul>
&lt;li>실시간 교통 상황 모니터링&lt;/li>
&lt;li>새로 만들어진 도로나 폐쇄된 도로 탐지&lt;/li>
&lt;li>사용자 행동 양태를 분석하여 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클라이언트가 보내는 위치 정보가 실시간 정보에 가까우므로 ETA를 좀 더 정확하게 산출할 수 있다.
&lt;ul>
&lt;li>교통 상황에 따라 다른 경로를 안내할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위치 이력을 클라이언트에 버퍼링해 두었다가 일괄 요청하면 전송 빈도를 줄일 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_6.png"
width="768"
height="230"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_6_hu4c9106ced49971975257ab1b7be74bab_135532_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_6_hu4c9106ced49971975257ab1b7be74bab_135532_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="일괄 요청"
class="gallery-image"
data-flex-grow="333"
data-flex-basis="801px"
>&lt;/p>
&lt;p>위치 갱신 요청 빈도를 줄여도 여전히 많은 쓰기 요청을 처리해야하므로 아주 높은 쓰기 요청 빈도에 최적화되어 있고 규모 확장이 용이한 카산드라같은 데이터베이스가 필요하다.&lt;/p>
&lt;p>카프카 같은 스트림 처리 엔진을 활용하여 위치 데이터를 로깅해야 할 수도 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">POST /v1/locations
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">body:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> locs: JSON으로 인코딩한 (위도, 경도, 시각) 순서쌍 배열
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="경로-안내-서비스">경로 안내 서비스&lt;/h3>
&lt;p>A에서 B 지점으로 가는 합리적으로 빠른 경로를 찾아 주는 역할을 담당한다.&lt;/p>
&lt;ul>
&lt;li>결과를 얻는 데 드는 시간 지연은 어느 정도 감내할 수 있다.&lt;/li>
&lt;li>최단 시간 경로일 필요는 없으나 정확도는 보장되어야 한다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GET /v1/nav?origin=1355+market+street,SF&amp;amp;destination=Disneyland
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="지도-표시">지도 표시&lt;/h3>
&lt;p>확대 수준별로 한 벌씩 지도 타일을 저장하려면 수백 PB가 필요하므로, 그 모두를 클라이언트가 가지고 있는 것은 실용적이지 않다.&lt;/p>
&lt;p>클라이언트의 위치 및 현재 클라이언트가 보는 확대 수준에 따라 필요한 타을을 서버에서 가져오는 접근법이 바람직하다.&lt;/p>
&lt;ul>
&lt;li>사용자가 지도를 확대 또는 이동시키며 주변을 탐색&lt;/li>
&lt;li>경로 안내가 진행되는 동안 사용자의 위치가 현재 지도 타일을 벗어나 인접한 타일로 이동&lt;/li>
&lt;/ul>
&lt;p>다량의 지도 타일 데이터를 효과적으로 가져오기 위해 아래와 같은 방법들을 고려할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>선택지 1&lt;/strong>&lt;/p>
&lt;p>클라이언트가 보는 지도의 확대 수준에 근거하여 필요한 지도 타일을 즉석에서 만든다.&lt;/p>
&lt;p>사용자 위치 및 확대 수준의 조합이 무한하므로 몇 가지 심각한 문제가 있다.&lt;/p>
&lt;ul>
&lt;li>모든 지도 타일을 동적으로 만들어야 하는 서버 클러스터에 심각한 부하가 걸린다.&lt;/li>
&lt;li>캐시를 활용하기 어렵다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>선택지 2&lt;/strong>&lt;/p>
&lt;p>미리 만들어 둔 지도 타일을 클라이언트에 전달하기만 한다.&lt;/p>
&lt;p>지도 타일이 담당하는 지리적 영역은 지오해싱 같은 분할법을 사용해 만든 고정된 사각형의 격자로 표현되어 정적이다.&lt;/p>
&lt;ul>
&lt;li>지도 타일이 필요할 경우 현재 확대 수준에 근거하여 필요한 지도 타일 집합을 결정하고, 각 위치를 지오해시 URL로 변환하여 보낸다.&lt;/li>
&lt;li>미리 만들어 둔 정적 이미지를 CDN을 통해 서비스한다.&lt;/li>
&lt;/ul>
&lt;p>이 접근법은 규모 확장이 용이하고 성능 측면에서도 유리하다.&lt;/p>
&lt;ul>
&lt;li>가장 가까운 POP에서 파일을 서비스한다.&lt;/li>
&lt;li>지도 타일은 정적이므로 캐시를 통해 서비스하기 아주 적합하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_7.png"
width="659"
height="633"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_7_hu95af23d21653015c716fa288ebdc0b72_148322_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_7_hu95af23d21653015c716fa288ebdc0b72_148322_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="CDN 기반 서비스 구조의 강점"
class="gallery-image"
data-flex-grow="104"
data-flex-basis="249px"
>&lt;/p>
&lt;p>지도 타일은 이미 정의된 격자에 맞게 확대 수준별로 한 벌식 미리 만들어 둔 것을 사용하게 된다.&lt;/p>
&lt;p>지오해시를 사용해 격자를 나누므로 모든 격자는 고유한 지오해시 값을 갖는다.&lt;/p>
&lt;p>따라서 위도/경도로 표현된 클라이언트의 위치 및 현재 지도 확대 수준을 입력으로 화면에 표시할 지도 타일에 대응되는 지오해시는 아주 쉽게 계산해 낼 수 있다.&lt;/p>
&lt;p>이 계산은 클라이언트가 수행하며, 해당 지오해시 및 URL로 CDN에서 지도 타일을 가져오면 된다.&lt;/p>
&lt;hr>
&lt;p>지오해시 계산은 클라이언트가 수행해되 괜찮지만, 알고리즘을 클라이언트 단에 구현할 경우 지원해야 할 플랫폼이 많을 때 문제가 될 수 있다.&lt;/p>
&lt;p>모바일 앱 업데이트 배포는 시간도 많이 걸리고 때로는 위험하므로 앞으로 오랫동안 맵 타일 인코딩에는 지오해싱을 사용해야한다는 전제가 있어야 한다.&lt;/p>
&lt;ul>
&lt;li>다른 방식으로 변경이 필요하다면 많은 노력과 위험이 따른다.&lt;/li>
&lt;/ul>
&lt;p>이에따라 주어진 위도/경도 및 확대 수준을 타일 URL로 변환하는 알고리즘 구현을 &lt;strong>별도 서비스&lt;/strong>에 두는 방법을 고려할 수 있다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart
user([user])
lb[로드밸런서]
service[지도 타일 서비스&lt;br/> 3. 타일 URL들을 생성]
cdn((CDN))
user---|'1. 타일 URL 집합 요청'| lb
lb---|'2. 요청 전달'| service
user---|'4. 타일 다운로드'| cdn
&lt;/pre>
&lt;p>새로운 위치로 이동하거나 확대 수준을 변경하면 지도 타일 서비스는 어떤 타일이 필요한지 결정하여 해당 타일들을 가져오는 데 필요한 URL 집합을 계산하여 응답한다.&lt;/p>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;h4 id="경로-안내-타일">경로 안내 타일&lt;/h4>
&lt;p>확보한 도로 데이터는 가공되지 않았기 때문에 &lt;strong>경로 안내 타일 처리 서비스&lt;/strong>라 불리는 오프라인 데이터 가공 파이프라인을 주기적으로 실행하여 경로 안내 타일로 변환해야한다.&lt;/p>
&lt;ul>
&lt;li>도로 데이터에 발생한 새로운 변경사항을 반영하기 위해 주기적으로 실행한다.&lt;/li>
&lt;/ul>
&lt;p>경로 안내 타일을 만들 때는 해당도를 달리 하여 세 벌(상, 중, 하) 만든다.&lt;/p>
&lt;ul>
&lt;li>그래프의 노드와 간선으로 표현된 해당 지역 내 교차로와 도로 정보&lt;/li>
&lt;li>다른 타일의 도로와 연결되는 경우 해당 타일에 대한 참조 정보 포함&lt;/li>
&lt;/ul>
&lt;p>경로 안내 알고리즘은 이들 타일이 모인 결과로 만들어지는 도로망 데이터를 점진적으로 소비한다.&lt;/p>
&lt;p>가공 결과로 만들어진 타일은 어디에 저장해야 할까?&lt;/p>
&lt;p>일반적으로 그래프 데이터는 메모리에 인접 리스트 형태로 보관하나, 메모리에 두기에는 양이 너무 많다.&lt;/p>
&lt;p>그래프의 노드와 간선을 데이터베이스 레코드로 저장하는 것 도 방법이겠지만 비용이 많이 들 것이며, 경로 안내 타일의 경우 데이터베이스가 제공하는 기능이 필요 없다.&lt;/p>
&lt;p>따라서 &lt;strong>S3 같은 객체 저장소에 파일을 보관&lt;/strong>하고 그 파일을 이용할 &lt;strong>경로 안내 서비스에서 적극적으로 캐싱&lt;/strong>하는 방법을 고려할 수 있다.&lt;/p>
&lt;p>위도와 경도가 주어졌을 때 타일을 신속하게 찾기 위해 지오해시 기준으로 분류해 두는 것이 좋다.&lt;/p>
&lt;h4 id="사용자-위치-데이터">사용자 위치 데이터&lt;/h4>
&lt;p>사용자의 위치 정보는 아주 값진 데이터다.&lt;/p>
&lt;ul>
&lt;li>도로 데이터 및 경로 안내 타일을 갱신하는데 이용된다.&lt;/li>
&lt;li>실시간 교통 상황 데이터나 교통 상황 이력 데이터베이스를 구축하는 데도 활용된다.&lt;/li>
&lt;li>데이터 스트림 프로세싱 서비스는 이 위치 데이터를 처리하여 지도 데이터를 갱신한다.&lt;/li>
&lt;/ul>
&lt;p>사용자 위치 데이터를 저장하려면 엄청난 양의 쓰기 연산을 잘 처리할 수 있으면서 수평적 규모 확장이 가능한 데이터베이스가 필요하다.&lt;/p>
&lt;ul>
&lt;li>카산드라&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>user_id&lt;/th>
&lt;th>timestamp&lt;/th>
&lt;th>user_mode&lt;/th>
&lt;th>driving_mode&lt;/th>
&lt;th>location&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>101&lt;/td>
&lt;td>1635740977&lt;/td>
&lt;td>active&lt;/td>
&lt;td>driving&lt;/td>
&lt;td>(20.0, 30.5)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="지오코딩-데이터베이스">지오코딩 데이터베이스&lt;/h4>
&lt;p>주소를 위도/경도 쌍으로 변환하는 정보를 보관한다.&lt;/p>
&lt;p>읽기 연산은 빈번한 반면 쓰기 연산은 드물게 발생하는 특성으로 레디스와 같이 빠른 읽기 연산을 제공하는 키-값 저장소가 적합하다.&lt;/p>
&lt;p>출발지와 목적지 주소는 경로 계획 서비스에 전달하기 전 이 데이터베이스를 통해 위도/경도 쌍으로 변환된다.&lt;/p>
&lt;h4 id="미리-만들어-둔-지도-이미지">미리 만들어 둔 지도 이미지&lt;/h4>
&lt;p>단말이 특정 영역의 지도를 요청하면 인근 도로 정보를 취합하여 모든 도로 및 관련 상세 정보가 포함된 이미지를 만들어 내야 한다.&lt;/p>
&lt;ul>
&lt;li>계산 자원을 많이 사용한다.&lt;/li>
&lt;li>같은 이미지를 중복 요청하는 경우가 많다.&lt;/li>
&lt;/ul>
&lt;p>이미지느 ㄴ한 번만 계산하고 그 결과는 캐시해 두는 전략을 쓰는 것이 좋다.&lt;/p>
&lt;p>이미지는 지도 표시에 사용하는 확대 수준 별로 미리 만들어 두고 CDN을 통해 전송한다.&lt;/p>
&lt;h3 id="서비스">서비스&lt;/h3>
&lt;h4 id="위치-서비스-1">위치 서비스&lt;/h4>
&lt;p>데이터베이스 설계 및 사용자 위치 정보가 이용되는 방식에 초점을 맞추어 상세 설계를 진행해본다.&lt;/p>
&lt;p>사용자 위치 데이터 저장에는 키-값 저장소를 활용한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart TD
mobile([모바일 사용자]) -->
loadBalancer[로드밸런서] -->
location[위치 서비스] -->
db[(사용자 위치 DB)]
&lt;/pre>
&lt;ul>
&lt;li>초당 백만 건의 위치 정보 업데이트가 발생한다는 점을 감안하면 쓰기 연산 지원에 탁월한 데이터베이스가 필요하다.&lt;/li>
&lt;li>사용자 위치는 계속 변화하며, 일단 변경되고 나면 이전 정보는 바로 무용해지므로, 데이터 일관성 보다는 가용성이 더 중요하다.
&lt;ul>
&lt;li>CAP 정리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 요구사항에는 &lt;strong>NoSQL 키-값 데이터베이스&lt;/strong>나 &lt;em>&lt;em>열-중심&lt;/em> 데이터베이스&lt;/em>(column-oriented database)가 적합하며, 이 중 가용성과 분할 내성 두가지를 만족 시키는 데이터베이스에는 &lt;strong>카산드라&lt;/strong>가 있다.&lt;/p>
&lt;hr>
&lt;p>데이터 베이스 키로는 &lt;code>(user_id, timestamp)&lt;/code> 조합을 사용하며, 해당 키에 매달리는 값으로 &lt;code>위도/경도&lt;/code> 쌍을 저장한다.&lt;/p>
&lt;ul>
&lt;li>user_id는 파티션 키
&lt;ul>
&lt;li>같은 파티션 키를 갖는 데이터는 함께 저장됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>timestamp는 클러스터링 키
&lt;ul>
&lt;li>클러스터링 키 값에 따라 정렬된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이렇게 해 두면 특정 사용자의 특정 기간 내 위치도 효율적으로 읽어낼 수 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>key(uesr_id)&lt;/th>
&lt;th>timestamp&lt;/th>
&lt;th>lat&lt;/th>
&lt;th>long&lt;/th>
&lt;th>user_mode&lt;/th>
&lt;th>navigation_mode&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>51&lt;/td>
&lt;td>132053000&lt;/td>
&lt;td>21.9&lt;/td>
&lt;td>89.8&lt;/td>
&lt;td>active&lt;/td>
&lt;td>driving&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="사용자-위치-데이터는-어떻게-이용되는가">사용자 위치 데이터는 어떻게 이용되는가&lt;/h4>
&lt;p>사용자 위치는 쓰임새가 다양한 중요 데이터다.&lt;/p>
&lt;ul>
&lt;li>새로 개설되었거나 폐쇄된 도로를 감지할 수 있다.&lt;/li>
&lt;li>지도 데이터의 정확성을 점차로 개선하는 입력으로 활용될 수 있다.&lt;/li>
&lt;li>실시간 교통 현황을 파악하는 입력이 될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이러한 용례를 지원하기 위해 사용자 위치를 데이터베이스에 기록하는 것과 별도로 &lt;strong>카프카&lt;/strong>와 같은 메시지 큐에 로깅한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_8.png"
width="802"
height="437"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_8_hu7e5de397c61cacf1f854f32e04691977_149242_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_8_hu7e5de397c61cacf1f854f32e04691977_149242_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="여러 서비스에 위치 데이터 제공"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="440px"
>&lt;/p>
&lt;p>개별 서비스들은 카프카를 통해 전달되는 사용자 위치 데이터 스트림을 각자 용도에 맞게 활용할 수 있다.&lt;/p>
&lt;h3 id="지도-표시-1">지도 표시&lt;/h3>
&lt;p>지도 타일을 미리 만들어 놓는 방법과 지도 표시 최적화 기법을 살펴본다.&lt;/p>
&lt;h4 id="지도-타일-사전-계산">지도 타일 사전 계산&lt;/h4>
&lt;p>사용자가 보는 지도 크기나 확대 수준에 맞는 세부사항을 보여주기 위해 확대 수준별 지도 타일을 미리 만들어 둘 필요가 있다.&lt;/p>
&lt;ul>
&lt;li>구글맵은 21단계로 지도를 확대할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>확대 수준 0은 세계 전부를 256 * 256 픽셀짜리 타일 하나로 표현하며, 1단계 올릴 때마다 동서, 남북 방향으로 2배 씩 늘어난다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_9.png"
width="623"
height="365"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_9_hufe332efd68ce7553509f6a6bfaaa3fd6_248243_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_9_hufe332efd68ce7553509f6a6bfaaa3fd6_248243_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="확대 수준별 지도"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="409px"
>&lt;/p>
&lt;p>따라서 해상도도 4배 증가하게 된다.&lt;/p>
&lt;p>이렇게 늘어난 해상도 덕에 사용자에게 더 상세한 정보를 제공할 수 있으며, 클라이언트는 해당 정보를 제공하기 위한 타을을 다운 받는 데 많은 네트워크 대역폭을 소진하지 않고도 클라이언트에 설정된 확대 수준에 최적인 크기의 지도를 표시할 수 있다.&lt;/p>
&lt;h4 id="최적화-벡터-사용">최적화: 벡터 사용&lt;/h4>
&lt;p>지도 표시에 WebGL 기술을 채택하여 이미지 대신 경로와 다각형 등의 벡터 정보를 보낸다.&lt;/p>
&lt;ul>
&lt;li>벡터 타일은 이미지에 비해 월등한 압축률을 가지므로 네트워크 대역폭을 많이 아낄 수 있다.&lt;/li>
&lt;li>레스터 방식 이미지(Rasterized image)는 확대 수준을 높이는 순간 이미지가 늘어지고 픽셀이 도드라져 보이는 것과 달리 벡터화 된 이미지는 이러한 단점이 없다.&lt;/li>
&lt;/ul>
&lt;h3 id="경로-안내-서비스-1">경로 안내 서비스&lt;/h3>
&lt;p>경로 안내 서비스는 가장 빠른 경로를 안내하는 역할을 담당한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart
ac(모바일 사용자)
lb[로드밸런서]
ns[경로 안내 서비스]
gs[지오코딩 서비스]
nps[경로 계획 서비스]
rnks[순위 결정 서비스]
fsns[최단 경로 서비스]
arrs[예상 도착 서비스]
pss[실시간 교통 상황 서비스]
gdb(지오코딩 DB)
ndb(경로 안내 타일 DB)
pdb(교통량 DB)
udb(사용자 위치 DB)
ac-->lb
lb-->ns
ns-->gs
ns-->nps
gs-->gdb
nps-->fsns
nps-->rnks
nps-->arrs
fsns-->ndb
arrs-->pdb
pss-->pdb
pss-->udb
&lt;/pre>
&lt;h4 id="지오코딩-서비스">지오코딩 서비스&lt;/h4>
&lt;p>주소를 위도와 경도 쌍으로 바꾸어준다.&lt;/p>
&lt;p>주소의 표현 방식은 다양할 수 있다는 점을 고려해야한다.&lt;/p>
&lt;ul>
&lt;li>장소 이름으로 나타낸 주소&lt;/li>
&lt;li>지번 형태로 나타낸 주소 등&lt;/li>
&lt;/ul>
&lt;p>경로 안내 서비스는 이 서비스를 호출하여 출발지와 목적지 주소를 위도/경도 쌍으로 변환한 뒤 추후 다른 서비스 호출에 이용한다.&lt;/p>
&lt;h4 id="경로-계획-서비스">경로 계획 서비스&lt;/h4>
&lt;p>경로 계획 서비스(route planner service)는 현재 교통 상황과 도로 상태에 입각하여 이동 시간 측면에서 최적화된 경로를 제안한다.&lt;/p>
&lt;h4 id="최단-경로-서비스">최단 경로 서비스&lt;/h4>
&lt;p>최단 경로 서비스(shortest path service)는 출발지와 목적지 위도/경도를 입력으로 받아 k개의 최단 경로를 반환하는 서비스이다.&lt;/p>
&lt;p>이때 교통이나 도로 상황은 고려하지 않고, 도로 구조에만 의존하여 계산을 수행한다.&lt;/p>
&lt;ul>
&lt;li>도로망 그래프는 거의 정적이므로 캐시해 두면 좋다.&lt;/li>
&lt;/ul>
&lt;p>최단 경로 서비스는 객체 저장소에 저장된 경로 안내 타일에 대해 A* 경로 탐색 알고리즘의 한 형태를 실행한다.&lt;/p>
&lt;ol>
&lt;li>입력으로 출발지와 목적지의 위도/경도를 받는다.
&lt;ul>
&lt;li>이 위치 정보를 지오해시로 변호나한 다음 출발지와 목적지 경로 안내 타일을 얻는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>출발지 타일에서 시작하여 그래프 자료 구조를 탐색해 나간다.
&lt;ul>
&lt;li>탐색 범위를 넓히는 과정에서 필요한 주변 타일은 객체 저장소(캐시)에서 가져온다.&lt;/li>
&lt;li>같은 지역의 다른 확대 수준 타일로도 연결이 존재할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>최단 경로가 충분히 확보될 때까지 알고리즘은 검색 범위를 계속 확대해 나가면서 필요한 만큼 타일을 가져오는 작업을 반복한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_11.png"
width="1080"
height="458"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_11_huf7f7afc7caa46f16dc28ef7b8c08d390_800218_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_11_huf7f7afc7caa46f16dc28ef7b8c08d390_800218_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="그래프 탐색"
class="gallery-image"
data-flex-grow="235"
data-flex-basis="565px"
>&lt;/p>
&lt;h4 id="예상-도착-시간-서비스">예상 도착 시간 서비스&lt;/h4>
&lt;p>경로 계획 서비스는 최단 경로 목록을 수신하면 예상 도착 시간 서비스를 호출하여 그 경로 각각에 대한 소요 시간 추정치를 구한다.&lt;/p>
&lt;p>기계 학습을 활용해 현재 교통 상황 및 과거 이력에 근거하여 예상 도착 시간을 계산한다.&lt;/p>
&lt;p>이 때 실시간 교통 상황 데이터 뿐만 아니라 앞으로 10분에서 20분 뒤의 교통 상황이 어떻게 달라질지도 예측해야한다.&lt;/p>
&lt;h4 id="순위-결정-서비스">순위 결정 서비스&lt;/h4>
&lt;p>ETA 예상치를 구하고 나면 순위 결정 서비스(ranker)에 관련 정보를 모두 전달하여 사용자가 정의한 필터링 조건을 적용한다.&lt;/p>
&lt;ul>
&lt;li>유료 도로 제외, 고속도로 제외 등&lt;/li>
&lt;/ul>
&lt;p>필터링이 끝나고 남은 경로를 소요 시간 순으로 정렬하여 최단 시간 경로 k개를 구한 후 경로 안내 서비스에 결과를 반환한다.&lt;/p>
&lt;h4 id="중요-정보-갱신-서비스들">중요 정보 갱신 서비스들&lt;/h4>
&lt;p>이 부류의 서비스는 &lt;strong>카프카 위치 데이터 스트림&lt;/strong>을 구독하고 있다가 중요 데이터를 비동기적으로 업데이트하여 그 상태를 항상 최신으로 유지하는 역할을 담당한다.&lt;/p>
&lt;ul>
&lt;li>실시간 교통 정보 데이터베이스
&lt;ul>
&lt;li>활성화 상태 사용자가 보내는 위치 데이터 스트림에서 교통 상황 정보를 추출&lt;/li>
&lt;li>실시간 교통 상황 데이터베이스에 반영되어 예상 도착 시간 서비스가 더욱 정확한 결과를 내는데 쓰인다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>경로 안내 타일
&lt;ul>
&lt;li>도로 데이터에 새로 발견된 도로, 폐쇄되었음이 확인된 도로 정보를 반영하여 경로 안내 타일을 지속적으로 갱신&lt;/li>
&lt;li>최단 경로 서비스는 더 정확한 결과를 낼 수 있게 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="적응형-eta와-경로-변경">적응형 ETA와 경로 변경&lt;/h4>
&lt;p>이 문제를 해결하려면 서버는 현재 경로 안내를 받고 있는 모든 사용자를 추적하면서 교통 상황이 달라질 때마다 각 사용자의 ETA를 변경해 주어야 한다.&lt;/p>
&lt;ul>
&lt;li>현재 경로 안내를 받고 있는 사용자는 어떻게 추적하나?&lt;/li>
&lt;li>수백만 경로 가운데 교통 상황 변화에 영향을 받는 경로와 사용자를 효율적으로 가려낼 방법은?&lt;/li>
&lt;/ul>
&lt;p>사용자 &lt;code>user_1&lt;/code>이 안내받은 경로가 경로 안내 타일 &lt;code>r_1&lt;/code> &amp;hellip; &lt;code>r_7&lt;/code> 구성되어 있다고 가정한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_12.png"
width="460"
height="179"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_12_hu280e0708fed9cf1f12a8aef8bbdf84a8_41297_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_12_hu280e0708fed9cf1f12a8aef8bbdf84a8_41297_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="안내된 경로"
class="gallery-image"
data-flex-grow="256"
data-flex-basis="616px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>효율적이지 않은 방법&lt;/strong>&lt;/p>
&lt;p>사용자와 경로 정보를 데이터 베이스에 저장한다고 하면 아래와 같을 것 이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">user_1: r_1, r_2 ..., r_k
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">user_2: r_1, r_2 ..., r_n
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">user_3: r_2, r_3 ..., r_m
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">user_4: r_3, r_10 ..., r_l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이 때 r_2에서 교통 사고가 발생했다면, 어떤 사용자가 영향을 받는지 알아내기 위해 레코드를 전수 조사해야한다.&lt;/p>
&lt;p>테이블에 보관된 레코드 수가 n이고 안내되는 경로의 평균 길이가 m이라면 모든 사용자 검색의 시간 복잡도는 &lt;code>O(n * m)&lt;/code>이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>개선된 방법&lt;/strong>&lt;/p>
&lt;p>경로 안내를 받는 사용자 각가의 현재 경로 안내 타일, 그 타일을 포함하는 상위 타일(확대 수준이 더 낮은 타일), 그 상위 타일의 상위 타일을 출발지와 목적지가 모두 포함된 타일을 찾을 때까지 재귀적으로 더하여 보관한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">user_1, r_1, super(r_1), super(super(r_1)), ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_13.png"
width="626"
height="576"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_13_hue7d0c9d50a34906b9535c0723874c0aa_123912_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_13_hue7d0c9d50a34906b9535c0723874c0aa_123912_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="재귀적인 경로 타일 수집"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="260px"
>&lt;/p>
&lt;p>어떤 타일의 교통 상황이 변했을 때 경로 안내 ETA가 달라지는 사용자는, 해당 사용자의 데이터베이스 레코드 마지막 타일에 그 타일이 속하는 사용자가 된다.&lt;/p>
&lt;p>그 이외의 사용자에게는 아무런 영향이 없으므로 검색 시간 복잡도가 &lt;code>O(n)&lt;/code>으로 줄어들어 좀 더 효율적이다.&lt;/p>
&lt;p>그러나 이 접근법은 교통 상황이 개선되었을 때 해야 하는 일까지 해결해 주지는 않는다.&lt;/p>
&lt;p>예를 들어 타일 2의 교통 상황이 회복되어서 사용자가 옛날 경로로 돌아가도 된다고 할 때 경로 재설정이 가능하다는 사실을 감지하고 알려야한다.&lt;/p>
&lt;p>한 가지 방안은 현재 경로 안내를 받는 사용자가 이용 가능한 경로의 ETA를 주기적으로 재계산하여 더 짧은 ETA를 간즞 경로가 발견되면 알리는 것 이다.&lt;/p>
&lt;h4 id="전송-프로토콜">전송 프로토콜&lt;/h4>
&lt;p>경로 안내 중에 경로 상황이 변경될 수 있으므로, 데이터를 모바일 클라이언트에 전송할 안정적인 방법이 필요하다.&lt;/p>
&lt;p>이 경우 서버에서 클라이언트로 데이터를 보내는 데 활용할 수 있는 프로토콜로는 모바일 푸시 알림, 롱 폴링, 웹소켓, 서버 전송 이벤트 등이 있다.&lt;/p>
&lt;ul>
&lt;li>모바일 푸시 알림
&lt;ul>
&lt;li>메시지 크기가 매우 제한적이므로 사용하지 않는 게 바람직하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹소켓
&lt;ul>
&lt;li>서버에 주는 부담이 크지 않아 일반적으로 롱 폴링보다 좋은 방안으로 본다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>웹소켓 SSE 모두 괜찮은 방법이지만 본 설계안에서는 웹소켓을 사용한다.&lt;/p>
&lt;ul>
&lt;li>양방향 통신을 지원하여 패키지나 상품이 목적지에 가까워졌을 때는 실시간 양방향 통신이 필요한 경우도 있기 때문&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_10.png"
width="1540"
height="1240"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_10_huef52c7d9d52a678b3a7058ace4c6f3a8_129189_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_10_huef52c7d9d52a678b3a7058ace4c6f3a8_129189_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="최종 설계안"
class="gallery-image"
data-flex-grow="124"
data-flex-basis="298px"
>&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>시스템의 확장에 관심이 있다면, 기업 고객 대상으로 중간 경유지 설정 기능을 제공하는 것을 고려해보면 좋다.&lt;/p>
&lt;ul>
&lt;li>하나가 아닌 여러 목적지를 입력으로 하면 그 모두를 어떤 순서로 방문해야 가장 빨리 경유할 수 있을지 실시간 교통 상황을 고려하여 안내&lt;/li>
&lt;li>도어대시, 우버, 리프트 같은 배달 서비스에 유용&lt;/li>
&lt;/ul></description></item><item><title>2. 주변 친구</title><link>https://codemario318.github.io/post/system-design-interview-2/2/</link><pubDate>Sun, 18 Aug 2024 15:59:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/2/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/cover.png" alt="Featured image of post 2. 주변 친구" />&lt;p>이번 장에서는 &lt;strong>주변 친구&lt;/strong>(&lt;strong>nearby friends&lt;/strong>)라는 모바일 앱 기능을 지원하는 규모 확장이 용이한 백엔드 시스템을 설계해본다.&lt;/p>
&lt;blockquote>
&lt;p>앱 사용자 가운데 본인 위치 정보 접근 권한을 허락한 사용자에 한에 인근의 친구 목록을 보여주는 시스템&lt;/p>
&lt;/blockquote>
&lt;p>1장 &lt;strong>근접성 서비스&lt;/strong>와 &lt;strong>주변 친구&lt;/strong> 는 비슷해 보이지만 큰 차이가 있다.&lt;/p>
&lt;ul>
&lt;li>근접성 서비스의 사업장 주소는 정적이다.&lt;/li>
&lt;li>주변 친구 위치는 자주 바뀐다.&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>페이스북 규모를 지원하는 백엔드 시스템은 복잡하다. 따라서 설계 시작 전 질문을 통해 설계 범위를 좁혀야한다.&lt;/p>
&lt;ul>
&lt;li>Q. 지리적으로 얼마나 가까워야 &lt;strong>주변에 있다&lt;/strong>고 할 수 있는가?
&lt;ul>
&lt;li>A. 5마일. 이 수치는 설정 가능해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 두 사용자 사이의 직선 거리라고 가정?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 얼마나 많은 사용자가 이 앱을 사용하는가? 10억명을 가넝하고, 그 가운데 10% 정도가 이 기능을 활용한다고 생각해도 괜찮은가?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 사용자의 이동 이력을 보관해 둬야하는가?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 친구 관계에 있는 사용자가 10분 이상 비활성 상태면 해당 사용자를 주변 친구 목록에서 사라지도록 해야하는가? 마지막 확인 위치를 표시하는가?
&lt;ul>
&lt;li>A. 사라지게 할 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. GDPR, CCPA 같은 사생활 및 데이터 보호법도 고려해야하는가?
&lt;ul>
&lt;li>A. 과정이 너무 복잡해질 수 있으므로 배제&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="기능-요구사항">기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>사용자는 모바일 앱에서 &lt;strong>주변 친구를 확인&lt;/strong>할 수 있어야 한다.
&lt;ul>
&lt;li>&lt;strong>해당 친구까지의 거리&lt;/strong> 표시&lt;/li>
&lt;li>정보가 &lt;strong>마지막으로 갱신된 시간&lt;/strong>이 함께 표시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이 친구 목록은 &lt;strong>몇 초마다 한번 씩 갱신&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>낮은 지연 시간&lt;/strong>(low latency)
&lt;ul>
&lt;li>주변 친구의 위치 변화가 반영되는 데 너무 오랜 시간이 걸리지 않아야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>안정성&lt;/strong>
&lt;ul>
&lt;li>전반적으로 안정적이어야 하지만, 가끔 몇 개 데이터가 유실되는 것 정도는 용인 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>결과정 일관성&lt;/strong>
&lt;ul>
&lt;li>위치 데이터를 저장하기 위해 강한 일관성을 지원하는 데이터 저장소를 사용할 필요는 없다.&lt;/li>
&lt;li>복제본의 데이터가 원본과 동일하게 변경되기까지 몇 초 정도 걸리는 것은 용인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;p>제시할 솔루션이 풀어야 할 도전적 과제를 결정하기 위해, 개략적으로 문제 규모를 추정한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>주변 친구&lt;/strong>는 5마일(8km) 반경 이내 친구로 정의&lt;/li>
&lt;li>위치 정보는 &lt;strong>30초&lt;/strong> 주기로 갱신
&lt;ul>
&lt;li>사람의 걷는 속도가 &lt;code>4-6km/h&lt;/code> 정도로 느림&lt;/li>
&lt;li>30초 주기라면 주변 친구 검색 결과가 크게 달라지지는 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>평균적으로 매일 주변 친구 검색 기능을 활용하는 사용자는 &lt;strong>1억명&lt;/strong>으로 가정&lt;/li>
&lt;li>동시 접속 사용자의 수는 **DAU의 10%**로 가정
&lt;ul>
&lt;li>&lt;strong>천만명&lt;/strong>이 동시에 시스템을 이용한다고 가정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>평균적으로 한 사용자는 &lt;strong>400명&lt;/strong>의 친구를 갖는다고 가정&lt;/li>
&lt;li>모든 친구가 주변 친구 검색 기능을 활용한다고 가정&lt;/li>
&lt;li>이 기능을 제공하는 앱은 한 페이지당 20명의 주변 친구를 표시&lt;/li>
&lt;li>사용자의 요청이 있다면 더 많은 주변 친구를 노출&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>QPS 계산&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>1억 DAU&lt;/li>
&lt;li>동시 접속 사용자: &lt;code>10% * 1억 = 천만&lt;/code>&lt;/li>
&lt;li>사용자는 30초마다 자기 위치를 시스템에 전송&lt;/li>
&lt;li>&lt;code>위치 정보 갱신 QPS = 천만 / 30 = ~334,000&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>위치 정보를 모든 친구에게 전송해야 한다는 요구사항으로 인해 클라이언트와 서버 사이의 통신 프로토콜로 단순한 HTTP 프로토콜을 사용하지 못하게 될 수 있음을 감안해야한다.&lt;/p>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>이번 문제는 &lt;strong>메시지의 효과적 전송을 가능케 할 설계얀&lt;/strong>을 요구한다.&lt;/p>
&lt;p>개념적으로 보면 사용자는 근방의 모든 활성 상태 친구의 새 위치 정보를 수신하고자 한다. 이론적으로 순수한 P2P(peer-to-peer) 방식으로도 해결 가능한 문제이다.&lt;/p>
&lt;p>다시 말해, &lt;strong>활성 상태인 근방 모든 친구와 항구적 통신 상태를 유지&lt;/strong>하면 되는 것이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img.png"
width="898"
height="582"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_hudccc12625b6529e9eab4e26e4b039577_67180_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_hudccc12625b6529e9eab4e26e4b039577_67180_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="154"
data-flex-basis="370px"
>&lt;/p>
&lt;p>P2P 통신은 실용적인 아이디어는 아니지만 &lt;strong>추구해야 할 설계 방향에 대한 통찰&lt;/strong>은 얻을 수 있다.&lt;/p>
&lt;p>이보다 조금 더 실용적인 설계안은 &lt;strong>공용 백엔드&lt;/strong>를 사용하는 것이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_1.png"
width="1184"
height="552"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_1_hu5459bc5b3622841e964dbbf3c2d834b0_49710_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_1_hu5459bc5b3622841e964dbbf3c2d834b0_49710_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="214"
data-flex-basis="514px"
>&lt;/p>
&lt;p>백엔드는 다음과 같은 역할을 담당한다.&lt;/p>
&lt;ul>
&lt;li>모든 활성 상태 사용자의 위치 변화 내역을 수신&lt;/li>
&lt;li>사용자 위치 변경 내역을 수신할 때마다 해당 사용자의 모든 활성 상태 친구를 찾아 그 친구들의 단말로 변경 내역을 전달
&lt;ul>
&lt;li>두 사용자 사이의 거리가 특정 임계치보다 먼 경우 변경 내역을 전송하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>간단해 보이지만 문제의 가정이 활성 상태의 동시 접속 사용자 천만 명이므로 &lt;strong>큰 규모에 적용하기가 쉽지 않다&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>천만명이 자기 위치 정보를 30초마다 갱신하면 &lt;strong>334,000번&lt;/strong>의 위치 정보 갱신 처리가 필요하다.&lt;/li>
&lt;li>사용자 1명은 400명의 친구를 가지고, 그 중 10%가 인근에서 활성화 상태라면, 초당 &lt;code>334,000 * 400 * 10% = 1400만&lt;/code> 건의 위치 정보 갱신 요청을 처리해야한다.&lt;/li>
&lt;li>엄청난 양의 갱신 내역을 사용자 단말로 보내야한다.&lt;/li>
&lt;/ul>
&lt;h3 id="설계안">설계안&lt;/h3>
&lt;p>우선 소규모 백엔드를 위한 개략적 설계안에서 시작하여 더 큰 규모에 맞게 확장해나간다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_2.png"
width="1422"
height="1266"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="269px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>로드 밸런서&lt;/strong>&lt;/p>
&lt;p>&lt;strong>RESTful API&lt;/strong> 서버 및 양방향 유상태 웹소켓 서버 앞단에 위치한다.&lt;/p>
&lt;p>부하를 고르게 분산하기 위해 &lt;strong>트래픽을 서버들에 배분&lt;/strong>하는 역할을 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>RESTful API 서버&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>무상태 API 서버의 클러스터&lt;/li>
&lt;li>통상적인 요청/응답 트래픽을 처리&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>친구를 추가/삭제&lt;/strong>하거나 &lt;strong>사용자 정보를 갱신&lt;/strong>하는 등의 부가적인 작업을 처리한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>웹소켓 서버&lt;/strong>&lt;/p>
&lt;p>친구 위치 정보 변경을 거의 실시간에 가깝게 처리하는 &lt;strong>유상태 서버 클러스터&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>각 클라이언트는 클러스터 내 한 대 서버와 웹소켓 연결은 지속적으로 유지&lt;/li>
&lt;li>검색 반경 내 친구 위치가 변경되면 해당 내역은 이 연결을 통해 클라이언트로 전송&lt;/li>
&lt;li>주변 친구 기능을 이용하는 클라이언트의 초기화 담당
&lt;ul>
&lt;li>온라인 상태인 모든 주변 친구 위치를 해당 클라이언트로 전송&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>레디스 위치 정보 캐시&lt;/strong>&lt;/p>
&lt;p>활성 상태 사용자의 가장 최근 위치 정보를 캐시하는 데 사용한다.&lt;/p>
&lt;ul>
&lt;li>레디스에 보관하는 캐시 항목에는 TTL(Time-To-Live) 필드가 있어, 설정한 기간이 지나면 해당 사용자는 비활성으로 바뀌고 위치 정보는 캐시에서 삭제된다.&lt;/li>
&lt;li>캐시에 보관된 정보를 갱신할 때 TTL도 갱신한다.&lt;/li>
&lt;/ul>
&lt;p>레디스가 아니더라도 TTL을 지원하는 키-값 저장소는 캐시로 활용될 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>사용자 데이터 베이스&lt;/strong>&lt;/p>
&lt;p>&lt;strong>사용자 데이터&lt;/strong> 및 &lt;strong>사용자의 친구 관계 정보를 저장&lt;/strong>한다.&lt;/p>
&lt;p>관계형 데이터베이스, NoSQL 어느 쪽이든 사용 가능하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>위치 이동 이력 데이터베이스&lt;/strong>&lt;/p>
&lt;p>사용자의 위치 변동 이력을 보관한다.&lt;/p>
&lt;p>주변 친구 표시와 직접 관계된 기능은 아니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>레디스 펍/섭 서버&lt;/strong>&lt;/p>
&lt;p>레디스 펍/섭은 &lt;strong>초경량 메시지 버스&lt;/strong>(message bus)다.&lt;/p>
&lt;ul>
&lt;li>레디스 펍/섭에 새로운 채널을 생성하는 것은 아주 값싼 연결이다.&lt;/li>
&lt;li>기가바이트급 메모리를 갖춘 최신 레디스 서버에는 수백만 개의 채널(토픽)을 생성할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_4.png"
width="1380"
height="740"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_4_hu84b0294fda6052ece73743e1e4417308_92336_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_4_hu84b0294fda6052ece73743e1e4417308_92336_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="186"
data-flex-basis="447px"
>&lt;/p>
&lt;ol>
&lt;li>웹소켓 서버를 통해 수신한 &lt;strong>특정 사용자의 위치 정보 변경 이벤트&lt;/strong>는 &lt;strong>해당 사용자에게 배정된 펍/섭 채널에 발행&lt;/strong>한다.
&lt;ul>
&lt;li>해당 사용자의 친구 각각과 연결된 웹소켓 연결 핸들러는 해당 채널의 구독자로 설정되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>특정 사용자의 위치가 바뀌면 해당 사용자의 모든 친구의 웹소켓 연결 핸들러가 호출된다.&lt;/li>
&lt;li>핸들러는 위치 변경 이벤트를 수신할 친구가 활성 상태면 거리를 다시 계산한다.
&lt;ul>
&lt;li>검색 반경 이내면 갱신된 위치와 갱신 시간을 웹소켓 연결을 통해 해당 친구의 클라이언트 앱으로 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>다른 메시지 버스 기술도 경량의 통신 채널만 제공한다면 같은 형태로 사용 가능하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>주기적 위치 갱신&lt;/strong>&lt;/p>
&lt;p>모바일 클라이언트는 항구적으로 유지되는 웹소켓 연결을 통해 주기적으로 위치 변경 내역을 전송한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_2.png"
width="1422"
height="1266"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="269px"
>&lt;/p>
&lt;ol>
&lt;li>모바일 클라이언트가 위치가 변경된 사실을 로드밸런서에 전송&lt;/li>
&lt;li>로드밸런서는 그 위치 변경 내역을 해당 클라이언트와 웹소켓 서버 사이에 설정된 연결을 통해 웹소켓 서버로 보냄&lt;/li>
&lt;li>아래 작업을 병렬로 수행
&lt;ul>
&lt;li>웹소켓 서버는 해당 이벤트를 위치 이동 이력 데이터베이스에 저장&lt;/li>
&lt;li>웹소켓 서버는 새 위치를 위치 정보 캐시에 보관
&lt;ul>
&lt;li>TTL도 새롭게 갱신&lt;/li>
&lt;li>웹소켓 연결 핸들러 안의 변수에 해당 위치를 반영(거리 계산에 활용)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹소켓 서버는 레디스 펍/섭 서버의 해당 사용자 채널에 새 위치를 발행&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>레디스 펍/섭 채널에 발행된 새로운 위치 변경 이벤트는 모든 구독자(웹소켓 이벤트 핸들러)에게 브로드캐스트된다.
&lt;ul>
&lt;li>구독자는 위치 변경 이벤트를 보낸 사용자의 온라인 상태 친구들&lt;/li>
&lt;li>구독자의 웹소켓 연결 핸들러는 친구의 위치 변경 이벤트를 수신&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지를 받는 웹 소켓 서버, 즉 웹 소켓 연결 핸들러가 위치한 웹 소켓 서버는 새 위치를 보낸 사용자와 메시지를 받은 사용자 사이의 거리를 새로 계산
&lt;ul>
&lt;li>검색 반경을 넘지 않는다면 새 위치 및 해당 위치로의 이동이 발생한 시각을 나타내는 타임스탬프를 해당 구독자의 클라이언트 앱으로 전송&lt;/li>
&lt;li>넘은 경우에는 보내지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_5.png"
width="1362"
height="1182"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_5_huf8fa9909ecee52bd94a35a1416186d93_155836_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_5_huf8fa9909ecee52bd94a35a1416186d93_155836_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="276px"
>&lt;/p>
&lt;ol>
&lt;li>사용자 1의 위치가 변경되면 그 변경 내역은 사용자 1과의 연결을 유지하고 있는 웹소켓 서버에 전송됨&lt;/li>
&lt;li>해당 변경 내역은 레디스 펍/섭 서버 내의 사용자 1 전용 채널로 발행&lt;/li>
&lt;li>레디스 펍/섭 서버는 해당 변경 내역을 모든 구독자에게 브로드캐스트한다.
&lt;ul>
&lt;li>구독자는 사용자 1과 친구 관계에 있는 모든 웹소켓 연결 핸들러&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>위치 변경 내역을 보낸 사용자와 구독자 사이의 거리(사용자 1과 2 사이의 거리)가 검색 반경을 넘지 않을 경우 새로운 위치는 사용자 2의 클라이언트로 전송&lt;/li>
&lt;/ol>
&lt;p>이 계산 과정은 해당 채널의 모든 구독자에게 반복 적용된다.&lt;/p>
&lt;ul>
&lt;li>한 사용자의 위치가 바뀔 때마다 이치 정보 전송은 40건 정도 발생할 것이다.&lt;/li>
&lt;/ul>
&lt;h3 id="api-설계">API 설계&lt;/h3>
&lt;p>필요한 API를 나열해본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>웹소켓&lt;/strong>&lt;/p>
&lt;p>사용자는 웹소켓 프로토콜을 통해 위치 정보 변경 내역을 전송하고 수신하므로, 최소한 다음 API는 구비되어야 한다.&lt;/p>
&lt;ul>
&lt;li>[서버 API] 주기적인 위치 정보 갱신
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>위도, 경도, 시각 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[클라이언트 API] 클라이언트가 갱신된 친구 위치를 수신하는 데 사용할 API
&lt;ul>
&lt;li>전송되는 데이터
&lt;ul>
&lt;li>친구 위치 데이터와 변경된 시각을 나타내는 타임스탬프&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[서버 API] 웹소켓 초기화 API
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>위도, 경도, 시각 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>자기 친구들의 위치 데이터&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[클라이언트 API] 새 친구 구독 API
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>친구 ID&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>가장 최근의 위도, 경도, 시각 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[클라이언트 API] 구독 해지 API
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>친구 ID&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>HTTP 요청&lt;/strong>&lt;/p>
&lt;p>API 서버는 친구를 추가/삭제하거나 사용자 정보를 갱신하는 드으이 작업을 처리할 수 있어야 한다.&lt;/p>
&lt;p>아주 흔한 종류의 API이므로 상세한 내용은 다루지 않는다.&lt;/p>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>살펴봐야하는 중요한 주제중 하나는 데이터 모델이다.&lt;/p>
&lt;p>위치 정보 캐시와 위치 이동 이력 데이터베이스만 살펴본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>위치 정보 캐시&lt;/strong>&lt;/p>
&lt;p>위치 정보 캐시는 &lt;strong>주변 친구&lt;/strong>기능을 켠 활성 상태 친구의 가장 최근 위치를 보관한다.&lt;/p>
&lt;p>설계안에서는 레디스를 사용해 이 키새를 구현하며, 해당 캐시에 보관될 키/값 쌍은 아래와 같다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>키&lt;/th>
&lt;th>값&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>사용자 ID&lt;/td>
&lt;td>{위도, 경도, 시각}&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;p>&lt;strong>위치 정보 저장에 데이터베이스를 사용하지 않는 이유는?&lt;/strong>&lt;/p>
&lt;p>주변 친구 기능은 사용자의 &lt;strong>현재 위치&lt;/strong>만 사용하므로, 사용자 위치는 하나만 보관하면 충분하다.&lt;/p>
&lt;ul>
&lt;li>읽기 및 쓰기 연산 속도가 매우 빠르다.&lt;/li>
&lt;li>TTL을 지원하여 활성 상태가 아닌 사용자 정보를 자동으로 제거할 수 있다.&lt;/li>
&lt;li>활용하는 위치 정보는 영속성을 보장할 필요가 없다.&lt;/li>
&lt;li>장애 발생시 새 서버로 바꾼 후 갱신된 위치 정보가 캐시에 채워지기만 하면 충분하다.
&lt;ul>
&lt;li>캐시가 데워질 동안은 갱신 주기가 한두 번 정도 경과하여 변경 내역을 놓칠 수도 있지만 수용 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>위치 이동 이력 데이터베이스&lt;/strong>&lt;/p>
&lt;p>위치 이동 이력 데이터베이스는 사용자의 위치 정보 변경 이력을 다음 스키마를 따르는 테이블에 저장한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>user_id&lt;/th>
&lt;th>latitude&lt;/th>
&lt;th>longitude&lt;/th>
&lt;th>timestamp&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>필요로 하는 것은 &lt;strong>막대한 쓰기 연산 부하를 감당&lt;/strong>할 수 있고, &lt;strong>수평적 규모 확장이 가능&lt;/strong>한 데이터베이스다.&lt;/p>
&lt;p>&lt;strong>카산드라&lt;/strong>(Cassandra)는 이러한 요구에 잘 부합한다.&lt;/p>
&lt;ul>
&lt;li>관계형 데이터 베이스도 사용할 수는 있으나 &lt;strong>이력 데이터의 양이 서버 한 대에 보관하기에는 너무 많을 수 있으므로 샤딩이 필요하다&lt;/strong>.
&lt;ul>
&lt;li>사용자 ID를 기준 삼는 샤딩 방안이 가장 기본&lt;/li>
&lt;li>부하를 모든 샤드에 고르게 분산시킬 수 있고, 데이터베이스 운영 관리도 간편하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>개략적 설계안은 대부분의 경우 통하지만, 주어진 문제의 규모를 감당하기는 어려울 것이다.&lt;/p>
&lt;p>이번 절에서는 규모를 늘려 나가면서 병목 및 해결책을 찾는데 집중한다.&lt;/p>
&lt;h3 id="중요-구성요소별-규모-확장성">중요 구성요소별 규모 확장성&lt;/h3>
&lt;h4 id="api-서버">API 서버&lt;/h4>
&lt;p>RESTful API 서버의 규모 확장 방법은 널리 알려져있다.&lt;/p>
&lt;p>본 설계안의 API 서버는 무상태로 이런 서버로 구성된 클러스터의 규모를 CPU 사용률이나 부하, I/O 상태에 따라 자동으로 늘리는 방법은 다양하다.&lt;/p>
&lt;h4 id="웹소켓-서버">&lt;strong>웹소켓 서버&lt;/strong>&lt;/h4>
&lt;p>웹소켓 클러스터도 사용률에 따라 규모를 자동으로 늘리는 것은 그다지 어렵지 않다.&lt;/p>
&lt;p>하지만 웹소켓 서버는 &lt;strong>유상태&lt;/strong> 서버라 기존 서버를 제거할 때는 주의가 필요하다.&lt;/p>
&lt;ul>
&lt;li>노드를 제거하기 전 기존 연결부터 종료될 수 있도록 해야한다.
&lt;ul>
&lt;li>로드 밸런서가 인식하는 노드 상태를 **연결 종료 중(draining)**으로 변경해둔다.&lt;/li>
&lt;li>해당 서버로는 새로운 웹소켓 연결이 만들어지지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모든 연결이 종료되면(충분한 시간이 흐른 후) 서버를 제거한다.&lt;/li>
&lt;/ul>
&lt;p>웹소켓 서버에 새로운 버전의 애플리케이션 소프트웨어를 설치할 때도 마찬가지로 유의해야한다.&lt;/p>
&lt;blockquote>
&lt;p>유상태 서버 클러스터의 규모를 자동으로 확장하려면 좋은 로드밸런서가 있어야한다.&lt;/p>
&lt;/blockquote>
&lt;p>대부분의 클라우드 로드밸런서는 이런 일을 잘 처리한다.&lt;/p>
&lt;h4 id="클라이언트-초기화">&lt;strong>클라이언트 초기화&lt;/strong>&lt;/h4>
&lt;p>모바일 클라이언트는 기동되면 웹소켓 클러스터 내의 서버 가운데 하나와 지속성 웹소켓 연결을 맺는다.&lt;/p>
&lt;ul>
&lt;li>연결이 오랜 시간 유지된다.&lt;/li>
&lt;li>현대적 프로그래밍 언어는 이런 연결 유지에 많은 메모리를 필요로 하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>웹소켓 연결이 초기화되면 클라이언트는 해당 모바일 단말의 위치, 즉 해당 단말을 이용중인 사용자의 위치 정보를 전송한다.&lt;/p>
&lt;p>그 정보를 받은 웹 소켓 연결 핸들러는 다음 작업을 수행한다.&lt;/p>
&lt;ol>
&lt;li>위치 정보 캐시에 보관된 해당 사용자의 위치를 갱신
&lt;ul>
&lt;li>해당 위치 정보는 뒤이은 계산 과정에 이용되므로, 연결 핸들러 내의 변수에 저장해둔다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자 데이터베이스를 뒤져 해당 사용자의 모든 친구 정보를 조회&lt;/li>
&lt;li>위치 정보 캐시에 일괄(batch) 요청을 보내 모든 친구의 위치를 한번에 조회
&lt;ul>
&lt;li>비활성화 친구의 위치는 캐시에 없을 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>친구 위치 각각에 대해, 해당 친구와 사용자 사이의 거리를 계산
&lt;ul>
&lt;li>검색 반경 이내면 해당 친구의 상세 정보, 위치, 마지막으로 확인된 사각을 웹소켓 연결을 통해 클라이언트에 반환&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 친구의 레디스 서버 펍/섭 채널을 구독
&lt;ul>
&lt;li>채널 생성 및 구독 비용이 저렴하므로 활성 상태에 관계없이 모든 친구 채널을 구독할 수 있음&lt;/li>
&lt;li>비활성화 친구의 채널을 유지하기 위해 메모리가 필요하지만 매우 적고, 활성 전까지 CPU나 I/O를 전혀 이용하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자의 현재 위치를 레디스 펍/섭 서버의 전용 채널을 통해 모든 친구에게 전송&lt;/li>
&lt;/ol>
&lt;h4 id="사용자-데이터베이스">&lt;strong>사용자 데이터베이스&lt;/strong>&lt;/h4>
&lt;p>사용자 데이터베이스에는 두 가지 종류의 데이터가 보관된다.&lt;/p>
&lt;ul>
&lt;li>사용자 ID, 사용자명, 프로파일 이미지의 URL 등 사용자 상세 정보(프로필 데이터)&lt;/li>
&lt;li>친구 관계 데이터&lt;/li>
&lt;/ul>
&lt;p>이번 장에서 다루는 설계안의 규모를 감안하면 한 대의 관계형 데이터베이스 서버로는 감당할 수 없으나, 사용자 ID를 기준으로 데이터를 샤딩하면 관계형 데이터베이스라 해도 수평적 규모 확장이 가능하다.&lt;/p>
&lt;p>설계하고 있는 규모의 시스템을 실제로 운영하려면 사용자 및 친구 데이터를 관리하는 팀이 따로 필요할 것이다.&lt;/p>
&lt;p>웹소켓 서버는 데이터베이스를 직접 질의하는 대신 API를 호출하여 사용자 및 친구 관계 데이터를 가져와야 한다.&lt;/p>
&lt;h4 id="위치-정보-캐시">&lt;strong>위치 정보 캐시&lt;/strong>&lt;/h4>
&lt;p>활성화 상태 사용자의 위치 정보를 캐시하기 위해 레디스를 활용한다.&lt;/p>
&lt;ul>
&lt;li>각 항목의 키에는 TTL을 설정한다.
&lt;ul>
&lt;li>사용자의 위치 정보가 갱신될 때마다 초기화된다.&lt;/li>
&lt;li>따라서 최대 메모리 사용량은 일정 한도 아래로 유지된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>하지만 천 만명의 활성 사용자가 대략 30초마다 변경된 위치 정보를 전송한다고 가정하면 레디스 서버가 감당해야 하는 갱신 연산의 수는 초당 334K에 달하게되는데, 최신 고사양 서버를 쓴다 해도 부담되는 수치이다.&lt;/p>
&lt;p>다행히도 각 사용자의 위치 정보는 서로 독립적인 데이터이므로 사용자 ID를 기준으로 여러 서버에 샤딩하면 부하 또한 고르게 분배할 수 있다.&lt;/p>
&lt;ul>
&lt;li>가용성을 높이려면 각 샤드에 보고나하는 위치 정보를 대기(standby) 노드에 복제해 두면 된다.&lt;/li>
&lt;/ul>
&lt;h4 id="레디스-펍섭-서버">&lt;strong>레디스 펍/섭 서버&lt;/strong>&lt;/h4>
&lt;p>본 설계안에서 펍/섭 서버를 모든 온라인 친구에게 보내는 위치 변경 내역 메시지의 라우팅(routing)계층으로 활용한다.&lt;/p>
&lt;p>레디스 펍/섭 서버를 사용하는 이유는 채널을 만들고 유지하는 비용이 매우 저렴하기 때문이다.&lt;/p>
&lt;ul>
&lt;li>새 채널은 구독하려는 채널이 없을 때 생성한다.&lt;/li>
&lt;li>구독자가 없는 채널로 전송되 메시지는 그대로 버려지는데, 서버에 가해지는 부하는 거의 없다.&lt;/li>
&lt;li>채널 하나를 유지하기 위해서는 구독자 관계를 추적하기 위한 해시 테이블과 연결 리스트가 필요한데 아주 소량의 메모리만 사용한다.&lt;/li>
&lt;li>오프라인 사용자라 어떤 변경도 없는 채널의 경우에는 생성된 이후에 CPU 자원은 전혀 사용하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>본 설계안은 그 점을 활용하여 주변 친구 기능을 활용하는 모든 사용자에 채널 하나씩을 부여한다.&lt;/p>
&lt;ul>
&lt;li>해당 기능을 사용하는 사용자의 앱은 초기화 시에 모든 친구의 채널과 구독 관계를 설정한다.(친구가 비활성이라도)&lt;/li>
&lt;/ul>
&lt;p>활성화 상태로 바뀐 친구의 채널을 구독하거나 비활성 상태가 된 친구의 채널을 구독 중단하는 작업이 필요 없어지므로 설계가 간단해진다.&lt;/p>
&lt;p>더 많은 메모리를 사용하게 되지만, 메모리가 병목이 될 가능성은 매우 낮다. 아키텍처를 단순하게 만들 수 잇다면 더 많은 메모리를 투입할 가치는 충분하다.&lt;/p>
&lt;h4 id="얼마나-많은-레디스-펍섭-서버가-필요한가">&lt;strong>얼마나 많은 레디스 펍/섭 서버가 필요한가?&lt;/strong>&lt;/h4>
&lt;p>&lt;strong>메모리 사용량&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>주변 친구 찾기를 사용하는 모든 사용자에게 채널 하나씩 할당하면 채널 수는 &lt;strong>1억&lt;/strong>개&lt;/li>
&lt;li>구독자 한 명을 추적하기 위해 내부 해시 테이블과 연결 리스트에 20바이트 상당의 포인터들을 저장해야함
&lt;ul>
&lt;li>&lt;code>1억 * 20바이트 * 100명 친구 / 10^9 = 200GB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>100GB 메모리 서버 2대로 충분하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>CPU 사용량&lt;/strong>&lt;/p>
&lt;p>펍/섭 서버가 구독자에게 전송해야하는 위치 정보 업데이트 양은 초당 1400만 건에 달한다.&lt;/p>
&lt;p>최신 레디스 서버 한 대로 얼마나 많은 메시지를 전송할 수 있는지 정확히 알 수는 없지만, 서버 한 대로는 곤란할것이다.&lt;/p>
&lt;ul>
&lt;li>보수적으로 기가비트 네트워크 카드를 탑재한 현대적 아키텍처의 서버 한 대로 감당 가능한 구독자의 수는 100,000이라고 가정&lt;/li>
&lt;/ul>
&lt;p>이 추정치에 따르면 필요한 레디스 서버의 수는 &lt;code>1400만 / 100,000 = 140&lt;/code>이다.&lt;/p>
&lt;hr>
&lt;p>위 계산 결과를 통해 다음과 같은 결론을 내릴 수 있다.&lt;/p>
&lt;ul>
&lt;li>레디스 펍/섭 서버의 병목은 메모리가 아니라 CPU 사용량이다.&lt;/li>
&lt;li>문제의 규모를 감당하려면 분산 레디스 펍/섭 클러스터가 필요하다.&lt;/li>
&lt;/ul>
&lt;h4 id="분산-레디스-펍섭-서버-클러스터">분산 레디스 펍/섭 서버 클러스터&lt;/h4>
&lt;p>모든 채널을 서로 독립적이므로, 메시지를 발행할 사용자 ID를 기준으로 펍/섭 서버들을 샤딩한다.&lt;/p>
&lt;p>하지만 현실적으로는 수백 대의 펍/섭 서버가 관련된 문제이므로 동작 방식을 상세하게 집어볼 필요가 있다.&lt;/p>
&lt;ul>
&lt;li>서버에는 필연적으로 장애가 생기게 마련이므로, 매끄러운 운영을 위해 필요하다.&lt;/li>
&lt;/ul>
&lt;p>본 설계안에서는 &lt;strong>서비스 탐색&lt;/strong>(Service discovery) 컴포넌트를 도입하여 이 문제를 푼다.&lt;/p>
&lt;ul>
&lt;li>etcd&lt;/li>
&lt;li>주키퍼(ZooKeeper)&lt;/li>
&lt;/ul>
&lt;p>서비스 탐색 컴포넌트의 아래 기능을 활용한다.&lt;/p>
&lt;ul>
&lt;li>가용한 서버 목록을 유지하는 기능 및 해당 목록을 갱신하는 데 필요한 UI나 API
&lt;ul>
&lt;li>서비스 탐색 소프트웨어는 설정 데이터를 보관하기 위한 소규모의 키-값 저장소라고 보면 된다.&lt;/li>
&lt;li>키: &lt;code>/config/pub_sub_ring&lt;/code>&lt;/li>
&lt;li>값: &lt;code>[&amp;quot;p_1&amp;quot;, &amp;quot;p_2&amp;quot;, &amp;quot;p_3&amp;quot;, &amp;quot;p_4&amp;quot;]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클라이언트(웹소켓 서버)로 하여금 값에 명시된 레디스 펍/섭 서버에서 발생한 변경 내역을 구독할 수 있도록 하는 기능&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_7.png"
width="1096"
height="1254"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_7_hufa309bd8978651d9dab23e4c65bb98ec_107318_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_7_hufa309bd8978651d9dab23e4c65bb98ec_107318_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="87"
data-flex-basis="209px"
>&lt;/p>
&lt;p>키에 매달린 값에는 &lt;strong>활성 상태의 모든 레디스 펍/섭 서버&lt;/strong>로 구성된 &lt;strong>해시 링&lt;/strong>을 보관한다.&lt;/p>
&lt;p>레디스 펍/섭 서버는 메시지를 발행할 채널이나 구독할 채널을 정해야 할 때 이 해시링을 참조한다.&lt;/p>
&lt;hr>
&lt;p>웹소켓 서버가 특정 사용자 채널에 위치 정보 변경 내역을 발행하는 과정은 아래와 같다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_6.png"
width="1236"
height="1358"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_6_hue0f6159084a4fbd8c7b86af586fea184_111737_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_6_hue0f6159084a4fbd8c7b86af586fea184_111737_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="91"
data-flex-basis="218px"
>&lt;/p>
&lt;ol>
&lt;li>해시 링을 참조하여 메시지를 발행할 레디스 펍/섭 서버를 선정한다.
&lt;ul>
&lt;li>정확한 정보는 서비스 탐색 컴포넌트에 보관되어 있으나 해시 링 사본을 웹소켓 서버에 캐시한다면 성능을 높힐 수 있다.&lt;/li>
&lt;li>그 경우 웹소켓 서버는 해시 링 원본에 구독 관례를 설정하여 사본을 원본과 동일하게 유지하도록 해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹소켓 서버는 해당 서버가 관리하는 사용자 채널에 위치 정보 변경 내역을 발행한다.&lt;/li>
&lt;/ol>
&lt;p>구독할 채널이 존재하는 레디스 펍/섭 서버를 찾는 과정도 이와 동일하다.&lt;/p>
&lt;h4 id="레디스-펍섭-서버-클러스터의-규모-확장-고려사항">레디스 펍/섭 서버 클러스터의 규모 확장 고려사항&lt;/h4>
&lt;p>무상태 서버라면 트래픽 피턴에 따라 크기를 늘리거나 줄이는 방법이 위험성이 낮고 비용을 절감하기도 좋아 널리 활용되지만, 레디스 펍/섭 서버 클러스터 특성으로 인해 고려하기 어렵다.&lt;/p>
&lt;p>펍/섭 채널에 전송되는 메시지는 메모리나 디스크에 지속적으로 보관되지않지만, 채널에 대한 상태 정보를 보관한다.(각 채널의 구독자 목록)&lt;/p>
&lt;p>따라서 특정한 채널을 담당하던 펍/섭 서버를 교체하거나 해시 링에서 제거하는 경우 기존 채널에 대한 구독 관계를 해지하고 새 서버에 마련된 대체 채널을 다시 구독하기 위해 &lt;strong>채널을 다른 서버로 이동&lt;/strong>시켜야 하고, &lt;strong>해당 채널의 모든 구독자에게 그 사실을 알려야한다&lt;/strong>.&lt;/p>
&lt;p>유상태 서버 클러스터의 규모를 늘리거나 줄이는 것은 운영 부담과 위험이 큰 작업이므로 주의 깊게 계획하고 진행해야한다.&lt;/p>
&lt;ul>
&lt;li>유상태 서버 클러스터는 혼잡 시간대 트래픽을 무리 없이 감당하고 불필요한 크기 변화를 피할 수 있도록 어느 정도 여유를 두고 오버 프로비저닝(over provisioning)하는 것이 일반적이다.&lt;/li>
&lt;/ul>
&lt;p>불가피하게 규모를 늘려야 할 때는 다음과 같은 문제가 발생할 수 있음에 유의하여야 한다.&lt;/p>
&lt;ul>
&lt;li>클러스터의 크기를 조정하면 많은 채널이 같은 해시 링 위의 다른 여러 서버로 이동한다.
&lt;ul>
&lt;li>서비스 탐색 컴포넌트가 모든 웹소켓 서버에 해시 링이 갱신되었음을 알리면 &lt;strong>엄청난 재구독&lt;/strong> 요청이 발생할 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>재구독 요청을 처리하다 보면 &lt;strong>클라이언트가 보내는 위치 정보 변경 메시지의 처리가 누락&lt;/strong>될 수 있다.
&lt;ul>
&lt;li>어느 정도는 허용할 수 있으나 빈도는 반드시 최소화해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서비스의 상태가 불안정해질 가능성이 있으므로 클러스터 크기 조정은 하루 중 시스템 부하가 가장 낮은 시간을 골라 시행한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>클러스터의 크기 조정 자체는 꽤 간단하다.&lt;/p>
&lt;ul>
&lt;li>새로운 링 크기를 계산한다.
&lt;ul>
&lt;li>크기가 늘어난다면 새 서버를 준비한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>해시 링의 키에 매달린 값을 새로운 내용으로 갱신한다.&lt;/li>
&lt;li>대시보드를 모니터링한다.
&lt;ul>
&lt;li>웹소켓 클러스터의 CPU 사용량이 어느 정도 튀는 것이 보여야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>p_5&lt;/code>, &lt;code>p_6&lt;/code> 두 노드가 추가된다면 해시 링은 다음과 같이 바뀐다.&lt;/p>
&lt;ul>
&lt;li>변경 전
&lt;ul>
&lt;li>&lt;code>[p_1, p_2, p_3, p_4]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>변경 후
&lt;ul>
&lt;li>&lt;code>[p_1, p_2, p_3, p_4, p_5, p_6]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="운영-고려사항">운영 고려사항&lt;/h4>
&lt;p>기존 레디스 펍/섭 서버를 새 서버로 교체할 때는 교체되는 서버의 채널만 처리하므로 운영 문제가 발생할 가능성은 클러스터 크기를 조정할 때보다 훨씬 낮다.&lt;/p>
&lt;p>펍/섭 서버에 장애가 발생하면 &lt;strong>모니터링 소프트웨어&lt;/strong>는 온콜(on-call) 엔지니어에게 경보를 발송하며, 온콜 담당자는 아래와 같은 처리를 수행한다.&lt;/p>
&lt;ol>
&lt;li>서비스 탐색 컴포넌트의 해시 링 키에 매달린 값을 갱신하여 장애가 발생한 노드를 대기 중인 노드와 교체&lt;/li>
&lt;li>교체 사실은 모든 웹소켓 서버에 통지되고, 각 웹소켓 서버는 실행 중인 연결 핸들러에게 새 펍/섭 서버의 채널을 다시 구독하라고 알림&lt;/li>
&lt;li>각 연결 핸들러는 구독 중인 채널의 목록을 유지하고 있으므로, 모든 채널을 해시 링과 대조하여 새 서버로 구독 관계를 다시 설정해야 하는지 검토&lt;/li>
&lt;/ol>
&lt;h3 id="친구-추가삭제">친구 추가/삭제&lt;/h3>
&lt;p>새 친구를 추가하면 해당 클라이언트에 연결된 웹소켓 서버의 연결 핸들러에 그 사실을 알려 새 친구의 펍/섭 채널을 구독할 수 있도록 해야한다.&lt;/p>
&lt;ul>
&lt;li>주변 친구 기능은 큰 앱의 일부로, 새 친구가 추가되면 호출될 콜백을 해당 앱에 등록해 둘 수 있다.&lt;/li>
&lt;li>콜백이 호출되면 웹소켓 서버로 새 친구의 펍/섭 채널을 구독하라는 메시지를 보낸다.&lt;/li>
&lt;li>이 메시지를 처리한 웹소켓 서버는 해당 친구가 활성화 상태인 경우 가장 최근 위치 및 시각 정보를 응답 메시지에 담아 보낸다.&lt;/li>
&lt;/ul>
&lt;p>마찬가지로 친구가 삭제되면 호출될 콜백도 앱에 등록해 둘 수 있다.&lt;/p>
&lt;ul>
&lt;li>콜백이 호출되면 해당 친구의 펍/섭 채널 구독을 취소하라는 메시지를 웹소켓 서버로 보낸다.&lt;/li>
&lt;/ul>
&lt;p>친구가 위치 정보 정보 전성을 허가/취소하는 경우의 처리에도 활용될 수 있다.&lt;/p>
&lt;h3 id="친구가-많은-사용자">친구가 많은 사용자&lt;/h3>
&lt;p>친구가 많은 사용자가 시스템 성능 문제를 야기할 가능성이 있는지 논의해볼 만한 주제이다.&lt;/p>
&lt;ul>
&lt;li>친구 수의 상한이 있다고 가정(페이스북은 5,000명)&lt;/li>
&lt;li>친구 관계는 양방향&lt;/li>
&lt;li>팔로워 모델 같은 단방향 관계는 배제&lt;/li>
&lt;/ul>
&lt;p>수천 명의 친구를 구독하는 데 필요한 펍/섭 구독 관계는 클러스터 내의 많은 웹소켓 서버에 분산되어 있을 것이다.&lt;/p>
&lt;ul>
&lt;li>따라서 친구들의 위치 변경에서 오는 부하는 각 웹소켓 서버가 나누어 처리하므로 핫스팟 문제는 발생하지 않을 것 이다.&lt;/li>
&lt;/ul>
&lt;p>다만 많은 친구를 둔 사용자의 채널이 존재하는 펍/섭 서버의 경우는 조금 더 많은 부하를 감당하게 될 수 있지만, 클러스터 안에 100대가 넘는 펍/섭 서버가 있고, 그런 헤비 유저들의 채널들이 모든 펍/섭 서버에 분산된다는 점을 감안하면, 특정 서버에 막대한 부담을 줄 일은 없을 것이다.&lt;/p>
&lt;h3 id="주변의-임의-사용자">주변의 임의 사용자&lt;/h3>
&lt;p>정보 공유에 동의한 주변 사용자를 무작위로 보여줄 수 있도록 한다면 어떻게 해야할까?&lt;/p>
&lt;p>기존 설계안을 크게 훼손하지 않으면서 해당 기능을 지원하는 한 가지 방법은 &lt;strong>지오해시에 따라 구축된 펍/섭 채널 풀&lt;/strong>을 두는 것 이다.&lt;/p>
&lt;ul>
&lt;li>지오 해시 격자로 나눈 다음 격자 마다 채널을 하나씩 만들어 둔다.&lt;/li>
&lt;/ul>
&lt;p>해당 격자 내의 모든 사용자는 해당 격자에 할당된 채널을 구독한다.&lt;/p>
&lt;ol>
&lt;li>사용자의 위치가 변경되면 웹소켓 연결 핸들러는 해당 사용자의 지오해시 ID를 계산한 후, 해당 지오해시 ID를 담당하는 채널에 새 위치를 전송한다.&lt;/li>
&lt;li>근방에 있는 사용자 가운데 해당 채널을 구독하고 있는 사용자는 사용자 2의 위치가 변겨오디었다는 메시지를 수신한다.&lt;/li>
&lt;/ol>
&lt;p>경계에 위치한 사용자를 잘 처리하기 위해 모든 클라이언트는 사용자가 위치한 지오해시 뿐 아니라 주변 지오해시 격자를 담당하는 채널도 구독한다.&lt;/p>
&lt;h3 id="레디스-펍섭-외의-대안">레디스 펍/섭 외의 대안&lt;/h3>
&lt;p>얼랭(Erlang)은 이문제에 특히 유용한 해결책이 될 수 있다.&lt;/p>
&lt;ul>
&lt;li>오히려 더 좋은 솔루션이 될 수 있다.&lt;/li>
&lt;li>얼랭은 사용자가 적어 좋은 개발자를 구하기 어렵다&lt;/li>
&lt;li>얼랭 전문가가 있다면 좋은 선택지가 될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>얼랭&lt;/strong>은 고도로 분산된 병렬 애플리케이션을 위해 고안된 프로그래밍 언어이자 런타임 환경이다.&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>개념적으로 보자면 어떤 사용자의 위치 정보 변경 내역을 그 친구에게 효율적으로 전달하는 시스템을 설계했다.&lt;/p>
&lt;p>설계안의 핵심 컴포넌트는 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>웹소켓
&lt;ul>
&lt;li>클라이언트와 서버 사이의 실시간 통신을 지원한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>레디스
&lt;ul>
&lt;li>위치 데이터의 빠른 읽기/쓰기를 지원한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>레디스 펍/섭
&lt;ul>
&lt;li>한 사용자의 위치 정보 변경 내역을 모든 온라인 친구에게 전달하는 라우팅 계층&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>소규모 트래픽에 적합한 개략적 설계안부터 시작하여, 규모가 커짐에 따라 발생 가능한 도전적 문제들을 살펴보았다.&lt;/p>
&lt;ul>
&lt;li>RESTful API 서버&lt;/li>
&lt;li>웹소켓 서버&lt;/li>
&lt;li>데이터 계층&lt;/li>
&lt;li>레디스 펍/섭 서버 클러스터&lt;/li>
&lt;li>레디스 펍/섭 서버의 대안&lt;/li>
&lt;/ul>
&lt;p>친구가 많은 사용자에게 발생할 수 있는 잠재적 성능 병목문제와, 주변의 임의 사용자를 보여주는 기능의 설계안도 살펴보았다.&lt;/p>
&lt;h2 id="요약">요약&lt;/h2>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
nearby(주변 친구) --> first((1단계))
nearby --> second((2단계))
nearby --> third((3단계))
first --> giyogu[기능적 요구사항]
giyogu --> display[주변 친구 목록 표시]
giyogu --> update[주변 친구 목록 갱신]
first --> biyogu[비 기능적 요구사항]
biyogu --> low_latenty[낮은 지연 시간]
first --> choo[추정]
choo --> mile[5마일 검색 반경]
choo --> interval[위치 갱신 주기: 30초]
choo --> updatedata[위치 정보 갱신 QPS: 334k/s]
second --> rufh[개략적 설계안]
rufh --> rest[RESTful API 서버]
rufh --> websocket[웹소켓 서버]
rufh --> redis[레디스 위치 정보 캐시]
rufh --> casandra[위치 이동 이력 데이터베이스]
rufh --> pubsub[레디스 펍/섭 서버]
second --> intervalpos[주기적 위치 갱신]
second --> api[API 설계]
second --> datamodel[데이터 모델]
datamodel --> position[위치 정보 캐시]
datamodel --> positionlog[위치 이동 이력 데이터베이스]
third --> components[각 컴포넌트의 규모 확장]
components --> apiComponent[API 서버]
components --> websocket_cluster[웹소켓 서버 클러스터]
components --> userDB[사용자 정보 데이터베이스]
components --> positionCache[위치 정보 캐시]
components --> pubsubCluster[레디스 펍/섭 서버 클러스터]
components --> erlang[레디스 펍/섭 외 대안]
third --> friendUD[친구 추가/삭제]
third --> manyFriend[친구가 많은 사용자]
third --> random[주변 임의 사용자]
&lt;/pre></description></item><item><title>6. 키-값 저장소 설계</title><link>https://codemario318.github.io/post/system-design-interview/6/</link><pubDate>Mon, 27 May 2024 11:59:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/6/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/cover.png" alt="Featured image of post 6. 키-값 저장소 설계" />&lt;p>키-값 저장소(key-value store)는 키-값 데이터베이스라고도 불리는 비 관계형(non-relational) 데이터베이스이다.&lt;/p>
&lt;ul>
&lt;li>이 저장소에 저장되는 값은 &lt;strong>고유 식별자&lt;/strong>를 키로 가져야한다.&lt;/li>
&lt;li>키와 값 사이의 이런 연결 관계를 &lt;strong>키-값 쌍&lt;/strong>(key-value pair)이라고 지칭한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>키&lt;/strong>&lt;br>
키-값 쌍에서의 키는 &lt;strong>유일&lt;/strong>해야 하며 해당 키에 매달린 값은 &lt;strong>키를 통해서만 접근&lt;/strong>할 수 있다.&lt;/p>
&lt;p>키는 일반 텍스트일 수도 있고 해시 값일 수도 있지만, 성능상의 이유로 짧을수록 좋다.&lt;/p>
&lt;ul>
&lt;li>일반 텍스트 키: &amp;ldquo;last_logged_in_at&amp;rdquo;&lt;/li>
&lt;li>해시 키: 253DDEC4&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>값&lt;/strong>&lt;br>
키-값 저장소는 보통 &lt;strong>값으로 무엇이 오든 상관하지 않는다&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>문자열, 리스트, 객체 등&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>키-값 저장소로 널리 알려진 것은 아마존 다이나모, memcached, 레디스 같은 것들이 있다.&lt;/p>
&lt;p>또한 기본적으로 아래와 같은 연산을 지원해야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>put(key, value)&lt;/code>: 키-값 쌍을 저장소에 저장한다.&lt;/li>
&lt;li>&lt;code>get(key)&lt;/code>: 인자로 주어진 키에 매달린 값을 꺼낸다.&lt;/li>
&lt;/ul>
&lt;h2 id="문제-이해-및-설계-범위-확정">문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>완벽한 설계란 없다.&lt;/p>
&lt;p>읽기, 쓰기 그리고 메모리 사용량 사이에 어떤 균형을 찾고, 데이터의 일관성과 가용성 사이에서 타협적 결정을 내린 설계를 만들었다면 충분히 쓸만한 답이다.&lt;/p>
&lt;p>이번 장에서는 다음 특성을 갖는 키-값 저장소를 설계해본다.&lt;/p>
&lt;ul>
&lt;li>키-값 쌍의 크기는 10KB 이하이다.&lt;/li>
&lt;li>큰 데이터를 저장할 수 있어야 한다.&lt;/li>
&lt;li>높은 가용성을 제공해야한다.
&lt;ul>
&lt;li>시스템은 장애가 있더라도 빨리 응답해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>높은 규모 확장성을 제공해야 한다.
&lt;ul>
&lt;li>트래픽 양에 따라 자동적으로 서버 증설/삭제가 이루어져야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 일관성 수준은 조정이 가능해야 한다.&lt;/li>
&lt;li>응답 지연시간(latency)이 짧아야 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="단일-서버-키-값-저장소">단일 서버 키-값 저장소&lt;/h2>
&lt;p>한 대 서버만 사용하는 키-값 저장소는 설계가 쉽다.&lt;/p>
&lt;p>가장 직관적인 방법은 키-값 쌍 전부를 메모리에 해시 테이블로 저장하는 것이다.&lt;/p>
&lt;p>이 방법은 빠른 속도를 보장하지만 &lt;strong>모든 데이터를 메모리안에 두는 것이 불가능&lt;/strong>할 수도 있다.&lt;/p>
&lt;p>이 문제의 개선책은 다음과 같은 것들이 있다.&lt;/p>
&lt;ul>
&lt;li>데이터 압축&lt;/li>
&lt;li>자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장&lt;/li>
&lt;/ul>
&lt;p>이렇게 개선한다고 해도, 한 대 서버로 부족한 때가 찾아오며, 많은 데이터를 저장하기 위해서 &lt;strong>분산 키-값 저장소&lt;/strong>를 만들어야한다.&lt;/p>
&lt;h2 id="분산-키-값-저장소">분산 키 값 저장소&lt;/h2>
&lt;p>분산 키 값 저장소는 키-값 쌍을 여러 서버에 분산시키므로 &lt;strong>분산 해시 테이블&lt;/strong>이라고도 불린다.&lt;/p>
&lt;p>분산 시스템을 설계할 때는 &lt;strong>CAP 정리&lt;/strong>(Consistency, Availability, Partition Tolerance theorem)를 이해하고 있어야 한다.&lt;/p>
&lt;h3 id="cap-정리">CAP 정리&lt;/h3>
&lt;p>CAP 정리는 &lt;strong>데이터 일관성(consistency), 가용성(availability), 파티션 감내(partition tolerance)라는 세가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다&lt;/strong>는 정리이다.&lt;/p>
&lt;ul>
&lt;li>데이터 일관성
&lt;ul>
&lt;li>분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성
&lt;ul>
&lt;li>분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파티션 감내
&lt;ul>
&lt;li>파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다.&lt;/li>
&lt;li>네트워크에 파티션(분할)이 생기더라도 시스템은 계속 동작하여야 한다는 것을 뜻한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>네트워크 파티션?&lt;/strong>&lt;br>
테이터베이스 시스템의 일부 노드들이 서로 통신할 수 없는 상황으로 인해 각 노드들(파티션)이 독립적으로 동작하게 되어 각 파티션이 서로 다른 상태나 데이터를 가지게 되는 상황&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img.png"
width="828"
height="608"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_hu8399b985eaaab4d8c3cc5e2bfd3651de_149592_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_hu8399b985eaaab4d8c3cc5e2bfd3651de_149592_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="326px"
>&lt;/p>
&lt;p>따라서 이들 가운데 &lt;strong>어떤 두 가지를 충족하려면 나머지 하나는 반드시 희생되어야 한다&lt;/strong>는 것을 의미한다.&lt;/p>
&lt;p>키 값 저장소는 세 가지 요구사항 가운데 어느 두 가지를 만족하느냐에 따라 다음과 같이 분류할 수 있다.&lt;/p>
&lt;ul>
&lt;li>CP: 일관성과 파티션 감내를 지원(가용성 희생)&lt;/li>
&lt;li>AP: 가용성과 파티션 감내를 지원(데이터 일관성 희생)&lt;/li>
&lt;li>CA: 일관성과 가용성을 지원(파티션 감내 지원 안함)
&lt;ul>
&lt;li>통상 네트워크 장애는 피할 수 없는 일로 여겨지므로, 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야 한다.&lt;/li>
&lt;li>실세계에서 CA 시스템은 존재하지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="구체적-사례">구체적 사례&lt;/h3>
&lt;p>분산 시스템에서 데이터는 보통 여러 노드에 복제되어 보관된다.&lt;/p>
&lt;h4 id="이상적-상태">이상적 상태&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_1.png"
width="840"
height="592"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_1_hua0faa9aa952f92ab7c5a2fe27ee0e7c0_91753_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_1_hua0faa9aa952f92ab7c5a2fe27ee0e7c0_91753_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="340px"
>&lt;/p>
&lt;p>이상적인 환경이라면 &lt;strong>네트워크가 파티션되는 상황은 절대로 일어나지 않을 것&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>n1&lt;/strong>에 기록된 데이터는 자동적으로 &lt;strong>n2&lt;/strong>, &lt;strong>n3&lt;/strong>에 복제되며 데이터 일관성과 가용성도 만족한다.&lt;/li>
&lt;/ul>
&lt;h4 id="실세계의-분산-시스템">실세계의 분산 시스템&lt;/h4>
&lt;p>분산 시스템은 파티션 문제를 피할 수 없다.&lt;/p>
&lt;p>파티션 문제가 발생하면 &lt;strong>일관성과 가용성 사이에서 하나를 선택&lt;/strong>해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_2.png"
width="839"
height="605"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_2_hud8043c96815985a7c6b0f4ed2ff33b87_103442_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_2_hud8043c96815985a7c6b0f4ed2ff33b87_103442_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="138"
data-flex-basis="332px"
>&lt;/p>
&lt;p>&lt;strong>n3&lt;/strong>에 장애가 발생하여 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>와 통신 할 수 없는 상황에서&lt;/p>
&lt;ul>
&lt;li>클라이언트가 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>에 기록한 데이터는 &lt;strong>n3&lt;/strong>에 전달되지 않는다.&lt;/li>
&lt;li>&lt;strong>n3&lt;/strong>에 기록되었으나 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>로 전달되지 않은 데이터가 있다면 오래된 사본을 갖고 있을 것이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>CP 시스템&lt;/strong>&lt;/p>
&lt;p>가용성 대신 일관성을 선택한다면 세 서버 사이에 생길 수 있는 데이터 불일치 문제를 피하기 위해 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>에 대해 &lt;strong>쓰기 연산을 중단&lt;/strong>시켜야한다.&lt;/p>
&lt;p>이러한 경우 일부 노드가 장애가 발생하여도 동작해야 한다는 가용성이 깨진다.&lt;/p>
&lt;p>데이터 일관성을 양보할 수 없는 시스템은 이렇게 처리되어 상황이 해결될 때 까지 오류를 반환해야 한다.&lt;/p>
&lt;ul>
&lt;li>온라인 뱅킹 등&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>AP 시스템&lt;/strong>&lt;/p>
&lt;p>일관성 대신 가용성을 선택한 시스템은 &lt;strong>낡은 데이터를 반환할 위험이 있더라도 계속 읽기 연산을 허용&lt;/strong>해야한다.&lt;/p>
&lt;p>&lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>는 계속 쓰기 연산을 허용하고, 파티션 문제가 해결된 뒤 새 데이터를 &lt;strong>n3&lt;/strong>에 전송해야한다.&lt;/p>
&lt;hr>
&lt;p>분산 키-값 저장소를 만들 때는 그 요구사항에 맞도록 CAP 정리를 적용해야 한다.&lt;/p>
&lt;p>면접 상황에서는 이 문제에 대해 면접관과 상의하고, 그 결론에 따라 시스템을 설계하도록 하자.&lt;/p>
&lt;h3 id="시스템-컴포넌트">시스템 컴포넌트&lt;/h3>
&lt;p>키-값 저장소 구형에 사용되는 핵심 컴포넌트들 및 기술을 살펴본다.&lt;/p>
&lt;ul>
&lt;li>데이터 파티션&lt;/li>
&lt;li>데이터 다중화&lt;/li>
&lt;li>일관성&lt;/li>
&lt;li>일관성 불일치 해소&lt;/li>
&lt;li>장애 처리&lt;/li>
&lt;li>시스템 아키텍처 다이어그램&lt;/li>
&lt;li>쓰기 경로&lt;/li>
&lt;li>읽기 경로&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-파티션">데이터 파티션&lt;/h4>
&lt;p>대규모 애플리케이션의 경우 전체 데이터를 한 대 서버에 욱여넣는 것은 불가능하다.&lt;/p>
&lt;p>가장 단순한 해결책은 &lt;strong>데이터를 작은 파티션들로 분할한 다음 여러 대 서버에 저장하는 것&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>데이터를 여러 서버에 고르게 분산할 수 있는가&lt;/li>
&lt;li>노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가&lt;/li>
&lt;/ul>
&lt;p>5장에서 다룬 안정 해시는 이런 문제를 푸는 데 적합한 기술로 활용될 수 있다.&lt;/p>
&lt;p>안정 해시를 사용하여 데이터를 파티션하면 몇가지 장점이 있다.&lt;/p>
&lt;ul>
&lt;li>규모 확장 자동화(automatic scaling)
&lt;ul>
&lt;li>시스템 부하에 따라 서버가 자동으로 추가되거나 삭제되도록 만들 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다양성(heterogeneity)
&lt;ul>
&lt;li>각 서버의 용량에 맞게 가상 노드의 수를 조정할 수 있다.&lt;/li>
&lt;li>고성능 서버는 더 많은 가상노드를 갖도록&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-다중화">데이터 다중화&lt;/h4>
&lt;p>높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있다.&lt;/p>
&lt;p>어떤 키를 해시 링 위에 배치한 수, 그 지점으로부터 시계 방향으로 링을 순회하면서 만나는 첫 N개 서버에 데이터 사본을 보관한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_3.png"
width="843"
height="685"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_3_hu0675f294d26db8b4acf424a88b68b693_77163_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_3_hu0675f294d26db8b4acf424a88b68b693_77163_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="123"
data-flex-basis="295px"
>&lt;/p>
&lt;p>하지만 가상 노드를 사용한다면 선택한 N개의 노드가 대응될 실제 물리 서버의 개수가 N보다 작아질 수 있다.&lt;/p>
&lt;p>이 문제를 피하려면 노드를 선택할 때 같은 물리 서버를 중복으로 선택하지 않도록 해야한다.&lt;/p>
&lt;p>같은 데이터 센터에 속한 노드는 정전, 네트워크 이슈, 자연 재해 등의 문제를 동시에 같이 겪을 가능성이 있으므로, 안정성을 담보하기 위해 데이터의 사본은 다른 센터의 서버에 보관하고, 센터들은 고속 네트워크로 연결한다.&lt;/p>
&lt;h4 id="데이터-일관성">데이터 일관성&lt;/h4>
&lt;p>여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 한다.&lt;/p>
&lt;p>&lt;strong>정족수 합의&lt;/strong>(Quorum Consensus) 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>N&lt;/code>: 사본의 개수&lt;/li>
&lt;li>&lt;code>W&lt;/code>: 쓰기 연산에 대한 정족수
&lt;ul>
&lt;li>쓰기 연산이 성공한 것으로 간주되려면 적어도 &lt;code>W&lt;/code>개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R&lt;/code>: 읽기 연산에 대한 정족수
&lt;ul>
&lt;li>읽기 연산이 성공한 것으로 간주되려면 적어도 &lt;code>R&lt;/code>개의 서버로부터 응답을 받아야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>일반적으로 &lt;code>N = R + W &amp;gt; N&lt;/code> 조건을 만족하도록 설정하며, 읽기와 쓰기 요청이 적어도 하나의 공통 노드를 통해 일관성을 유지하도록 보장한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_4.png"
width="839"
height="579"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_4_huec6b456c1e9a98e57b711c077ef003c7_99493_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_4_huec6b456c1e9a98e57b711c077ef003c7_99493_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="N = 3"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;p>&lt;code>W = 1&lt;/code>는 쓰기 연산이 성공했다고 판단하기 위해 중재자(coordinator)는 최소 한 대 서버로부터 쓰기 성공 응답을 받아야한다는 뜻이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>s1&lt;/strong>으로 부터 성공 응답을 받았다면, 나머지 응답은 기다릴 필요가 없다.&lt;/li>
&lt;/ul>
&lt;p>중재자는 클라이언트와 노드 사이에서 프락시(proxy)역할을 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;code>W&lt;/code>, &lt;code>R&lt;/code>, &lt;code>N&lt;/code>의 값을 정하는 것은 응답 지연과 데이터 일관성 사이의 타협점을 찾는 전형정인 과정이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>W = 1&lt;/code> or &lt;code>R = 1&lt;/code>
&lt;ul>
&lt;li>중재자는 한 대 서버로부터의 응답만 받으면 되므로 응답속도는 빠르다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>W &amp;gt; 1&lt;/code> or &lt;code>R &amp;gt; 1&lt;/code>
&lt;ul>
&lt;li>데이터 일관성의 수준은 향상되지만 중재자의 응답 속도는 가장 느린 서버로부터의 응답을 기다려야 하므로 느려진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>따라서 &lt;code>W + R &amp;gt; N&lt;/code>인 경우에는 일관성을 보증할 최신 데이터를 가진 노드가 최소 하나는 겹치므로 강한 일관성이 보장된다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>R = 1&lt;/code>, &lt;code>W = N&lt;/code>
&lt;ul>
&lt;li>빠른 읽기 연산에 최적화된 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R = N&lt;/code>, &lt;code>W = 1&lt;/code>
&lt;ul>
&lt;li>빠른 쓰기 연산에 최적화된 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R + W &amp;gt; N&lt;/code>
&lt;ul>
&lt;li>강한 일관성이 보장됨
&lt;ul>
&lt;li>보통 &lt;code>N = 3&lt;/code>, &lt;code>W = R = 2&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R + W &amp;lt;= N&lt;/code>
&lt;ul>
&lt;li>강한 일관성이 보장되지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>요구되는 일관성 수준에 따라 &lt;code>W&lt;/code>, &lt;code>R&lt;/code>, &lt;code>N&lt;/code> 값을 조정한다.&lt;/p>
&lt;p>&lt;strong>일관성 모델&lt;/strong>&lt;/p>
&lt;p>일관성 모델(consistency model)은 키-값 저장소를 설계할 때 고려해야 할 요소로 데이터 일관성 수준을 결정한다.&lt;/p>
&lt;ul>
&lt;li>강한 일관성
&lt;ul>
&lt;li>모든 읽기 연산은 최신 결과를 반환한다.&lt;/li>
&lt;li>클라이언트는 절대로 낡은 데이터를 볼 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>약한 일관성
&lt;ul>
&lt;li>읽기 연산은 최신 결과를 반환하지 못할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>결과적 일관성
&lt;ul>
&lt;li>약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영(동기화)된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>강한 일관성&lt;/strong>을 달성하는 일반적인 방법은, &lt;strong>모든 사본에 현재 쓰기 연산의 결과가 반영될 때까지 해당 데이터에 대한 읽기/쓰기를 금지&lt;/strong>하는 것이다.&lt;/p>
&lt;ul>
&lt;li>새로운 요청의 처리가 중단되므로 고 가용성 시스템에는 적합하지 않다.&lt;/li>
&lt;/ul>
&lt;p>다이나모 또는 카산드라 같은 저장소는 결과적 일관성 모델을 택하고 있다.&lt;/p>
&lt;ul>
&lt;li>결과적 일관성 모델을 따를 경우 &lt;strong>쓰기 연산이 병렬적으로 발생하면 시스템에 저장된 값의 일관성이 깨어질 수 있는데&lt;/strong>, 이 문제는 클라이언트가 해결해야한다.&lt;/li>
&lt;li>클라이언트 측에서 데이터의 버전 정보를 활용해 일관성이 깨진 데이터를 읽지 않도록 해야한다.&lt;/li>
&lt;/ul>
&lt;p>데이터를 다중화하면 가용성은 높아지지만 사본 간 일관성이 깨질 가능성은 높아진다.&lt;/p>
&lt;p>&lt;strong>비 일관성 해소 기법: 데이터 버저닝&lt;/strong>&lt;/p>
&lt;p>버저닝은 데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만든다.&lt;/p>
&lt;ul>
&lt;li>각 버전은 변경 불가능하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_5.png"
width="838"
height="387"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_5_hu314294c50ed1dac3bf6da051bfbc696c_78353_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_5_hu314294c50ed1dac3bf6da051bfbc696c_78353_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="충돌하는 두 값"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="519px"
>&lt;/p>
&lt;p>서버 1, 2가 다른 노드의 같은&lt;code>name&lt;/code>의 값을 동시에 변경하여 충돌이 발생했다고 가정했을 때 각각을 버전 &lt;strong>v1&lt;/strong>, &lt;strong>v2&lt;/strong>로 볼 수 있다.&lt;/p>
&lt;p>이러한 충돌 문제를 해결하려면, 충돌을 발견하고 자동으로 해결해 낼 버저닝 시스템이 필요하다.&lt;/p>
&lt;p>&lt;strong>백터 시계&lt;/strong>(vector clock)는 &lt;strong>&lt;code>[서버, 버전]&lt;/code>의 순서 쌍을 데이터에 매단 것&lt;/strong>으로 충돌 문제를 푸는데 보편적으로 사용된다.&lt;/p>
&lt;ul>
&lt;li>어떤 버전이 선행 버전인지, 후행 버전인지, 충돌이 있는지 판별하는 데 쓰인다.&lt;/li>
&lt;/ul>
&lt;p>데이터 D를 서버 &lt;strong>Si&lt;/strong>에 기록하려면 아래 작업 가운데 하나를 수행해야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>[Si, Vi]&lt;/code>가 있으면 &lt;code>Vi&lt;/code>를 증가시킨다.&lt;/li>
&lt;li>그렇지 않다면 새 항목 &lt;code>[Si, 1]&lt;/code>을 만든다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_6.png"
width="717"
height="798"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_6_hu4d508b5e0485ac8ed5a6f6afc4aa05b9_112910_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_6_hu4d508b5e0485ac8ed5a6f6afc4aa05b9_112910_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="백터 시계"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="215px"
>&lt;/p>
&lt;ol>
&lt;li>클라이언트가 &lt;code>D1&lt;/code>을 시스템에 기록한다.
&lt;ul>
&lt;li>처리한 서버는 &lt;code>Sx&lt;/code>이므로 백터 시계는 &lt;code>D1[Sx, 1]&lt;/code>으로 변한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다른 클라이언트가 &lt;code>D1&lt;/code>을 읽고 &lt;code>D2&lt;/code>로 업데이트한 다음 기록한다.
&lt;ul>
&lt;li>&lt;code>D2&lt;/code>는 &lt;code>D1&lt;/code>의 변경이므로 덮어쓴다.&lt;/li>
&lt;li>&lt;code>Sx&lt;/code>가 처리했으므로 벡터 시계를 &lt;code>D2[Sx, 2]&lt;/code>로 변경한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다른 클라이언트가 &lt;code>D2&lt;/code>를 읽어 &lt;code>D3&lt;/code>로 갱신한 다음 기록한다.
&lt;ul>
&lt;li>&lt;code>Sy&lt;/code>가 처리했으므로 백터 시계 상태는 &lt;code>D3([Sx, 2], [Sy, 1])&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>또 다른 클라이언트가 &lt;code>D2&lt;/code>를 읽고 &lt;code>D4&lt;/code>로 갱신한 후 기록한다.
&lt;ul>
&lt;li>&lt;code>Sz&lt;/code>가 처리했으므로 백터 시계 상태는 &lt;code>D4([Sx, 2], [Sz, 1])&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>어떤 클라이언트가 D3과 D4를 읽으면 데이터 간 충돌이 있다는 것을 알게 되므로, 클라이언트가 해소한 후 서버에 기록한다.
&lt;ul>
&lt;li>&lt;code>Sx&lt;/code>가 처리했으므로 백터 시계는 &lt;code>D5([Sx, 3], [Sy, 1], [Sz, 1])&lt;/code>로 바뀐다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>벡터 시계를 이용하면 버전 Y에 포함된 모든 구성 요소의 값이 X에 포함된 모든 구성요소 값보다 같거나 큰지만 확인하면 어떤 버전 X가 버전 Y의 이전 버전인지 쉽게 판단할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>D([s0, 1], [s1, 1])&lt;/code>은 &lt;code>D([s0, 1], [s1, 2])&lt;/code>보다 이전 버전이다.(충돌 X)&lt;/li>
&lt;/ul>
&lt;p>어떤 버전 X와 Y 사이에 충돌이 있는지 보려면 &lt;strong>Y의 벡터 시계 구성 요소 가운데 X의 벡터 시계 동일 서버 구성요소보다 작은 값을 갖는 것이 있는지 확인&lt;/strong>한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>D([s0, 1], [s1, 2])&lt;/code>, &lt;code>D([s0, 2], [s1, 1])&lt;/code>는 서로 충돌한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>벡터 시계를 통해 충돌 감지하고 해소하는 방법에는 두 가지 단점이 있다.&lt;/p>
&lt;ul>
&lt;li>충돌 감지 및 해소 로직이 클라이언트에 들어가야 하므로, 클라이언트 구현이 복잡해진다.&lt;/li>
&lt;li>&lt;code>[서버: 버전]&lt;/code>의 순서쌍 개수가 굉장히 빨리 늘어난다.
&lt;ul>
&lt;li>순서쌍 개수에 임계치를 설정하고, 임계치 이상으로 길이가 길어지면 오래된 순서쌍을 백터 시계에서 제거한다.&lt;/li>
&lt;li>버전 간 선후 관계가 정확하게 결정될 수 없으므로 충돌 해소 과정의 효율성이 낮아질 수 있다.&lt;/li>
&lt;li>실제 서비스에서 그런 문제는 거의 발생하지 않으므로, 대부분 기업에서 괜찮다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="장애-처리">장애 처리&lt;/h4>
&lt;p>대규모 시스템에서 장애는 아주 흔하게 벌어지므로 장애를 어떻게 처리할 것이냐 하는 것은 굉장히 중요한 문제이다.&lt;/p>
&lt;h4 id="장애-감지">장애 감지&lt;/h4>
&lt;p>분산 시스템에서는 서버 A에 문제가 생겼을 때 바로 장애를 처리하지 않고, 보통 두 대 이상의 서버가 똑같이 서버 A에 대해 장애를 보고해야 해당 서버에 실제로 장애가 발생했다고 간주한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_7.png"
width="838"
height="636"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_7_hu135f183e800718526af99039ce9e186b_156879_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_7_hu135f183e800718526af99039ce9e186b_156879_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="멀티캐스팅 채널 구축"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="316px"
>&lt;/p>
&lt;p>모든 노드 사이에 멀티캐스팅 채널을 구축하는 것이 서버 장애를 감지하는 손쉬운 방법이나, 이 방법은 서버가 많을 때 비효율적이다.&lt;/p>
&lt;p>따라서 &lt;strong>가십 프로토콜&lt;/strong>(gossip protocol) 같은 분산형 장애 감지 솔루션을 채택하는 편이 보다 효율적이다.&lt;/p>
&lt;ul>
&lt;li>각 노드는 맴버십 목록을 유지한다.
&lt;ul>
&lt;li>맴버십 목록: 각 맴버 ID와 그 박동 카운터(heartbeat counter) 쌍의 목록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 노드는 주기적으로 자신의 박동 카운터를 증가시킨다.&lt;/li>
&lt;li>각 노드는 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터 목록을 보낸다.&lt;/li>
&lt;li>박동 카운터 목록을 받은 노드는 맴버십 목록을 최신 값으로 갱신한다.&lt;/li>
&lt;li>어떤 맴버의 박동 카운터 값이 지정된 시간 동안 갱신되지 않으면 해당 멤버는 장애 상태인 것으로 간주한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_8.png"
width="839"
height="382"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_8_hu90da88e3e0d0b1a6937865c76380943d_88593_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_8_hu90da88e3e0d0b1a6937865c76380943d_88593_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="가십 프로토콜"
class="gallery-image"
data-flex-grow="219"
data-flex-basis="527px"
>&lt;/p>
&lt;h4 id="일시적-장애-처리">일시적 장애 처리&lt;/h4>
&lt;p>장애를 감지한 시스템은 가용성을 보장하기 위해 필요한 조치를 해야한다.&lt;/p>
&lt;ul>
&lt;li>엄격한 정족수 접근법은 읽기와 쓰기 연산을 금지한다.&lt;/li>
&lt;li>느슨한 정족수 접근법은 쓰기 연산을 수행할 W개의 건강한 서버와 읽기 연산을 수행할 R개의 건강한 서버를 해시 링에서 고른다.(장애 서버는 무시)&lt;/li>
&lt;li>장애 상태인 서버로 가는 요청은 다른 서버가 잠시 맡아 처리한다.&lt;/li>
&lt;li>그동안 발생한 변경 사항은 장애 서버가 복구 되었을 때 일괄 반영하여 데이터 일관성을 보존한다.
&lt;ul>
&lt;li>임시로 쓰기 연산을 처리한 서버에는 그에 관한 단서를 남겨둔다.&lt;/li>
&lt;li>단서 후 임시 위탁(hinted handoff)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_9.png"
width="834"
height="718"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_9_hu115bfa1d5fe40c44de379ba88e53d6c2_127770_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_9_hu115bfa1d5fe40c44de379ba88e53d6c2_127770_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="116"
data-flex-basis="278px"
>&lt;/p>
&lt;p>장애 상태인 s2에 대한 읽기 및 쓰기 연산은 일시적으로 s3가 처리하며, s2가 복구되면 s3는 갱신된 데이터를 s2로 인계한다.&lt;/p>
&lt;h4 id="영구-장애-처리">영구 장애 처리&lt;/h4>
&lt;p>영구적인 노드의 장애 상태는 반-엔트로피(anti-entropy) 프로토콜을 구현하여 사본들을 동기화한다.&lt;/p>
&lt;p>반-엔트로피 프로토콜은 &lt;strong>사본들을 비교하여 최신 버전으로 갱신하는 과정을 포함&lt;/strong>한다.&lt;/p>
&lt;p>사본 간의 일관성이 망가진 상태를 탐지하고 전송 데이터의 양을 줄이기 위해서 머클(Merkle) 트리를 사용한다.&lt;/p>
&lt;blockquote>
&lt;p>머클 트리?&lt;br>
해시 트리라고 불리는 머클 트리는 각 노드에 그 자식 노드들의 보관된 값의 해시(자식 노드가 leaf인 경우) 또는 자식 노드들의 레이블로부터 계산된 해시 값을 레이블로 붙여두는 트리&lt;/p>
&lt;/blockquote>
&lt;p>해시 트리를 사용하면 &lt;strong>대규모 자료 구조의 내용을 효과적이면서도 보안상 안전한 방법으로 검증&lt;/strong>할 수 있다.&lt;/p>
&lt;p>&lt;strong>1 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_10.png"
width="844"
height="330"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_10_hu458e95c99f7dfcfac03b6157ee8c6e5b_44753_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_10_hu458e95c99f7dfcfac03b6157ee8c6e5b_44753_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="255"
data-flex-basis="613px"
>&lt;/p>
&lt;p>키 공간을 버킷으로 나눈다.&lt;/p>
&lt;p>&lt;strong>2 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_11.png"
width="842"
height="182"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_11_hu5646976f70d14d2033d017e53694f064_41493_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_11_hu5646976f70d14d2033d017e53694f064_41493_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="462"
data-flex-basis="1110px"
>&lt;/p>
&lt;p>버킷에 포함된 각각의 키에 균등 분포 해시 함수를 적용하여 해시 값을 계산한다.&lt;/p>
&lt;p>&lt;strong>3 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_12.png"
width="839"
height="260"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_12_hu38a58b95ad281add1c37ca9db00d3b58_73545_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_12_hu38a58b95ad281add1c37ca9db00d3b58_73545_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="322"
data-flex-basis="774px"
>&lt;/p>
&lt;p>버킷 별로 해시값을 계산한 후, 해당 해시 값을 레이블로 갖는 노드를 만든다.&lt;/p>
&lt;p>&lt;strong>4 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_13.png"
width="840"
height="445"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_13_hu8894cdbe47f2eb2880a4148ac1861de4_101648_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_13_hu8894cdbe47f2eb2880a4148ac1861de4_101648_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;p>자식 노드의 레이블로부터 새로운 해시값을 계산하여, 이진 트리를 상향식으로 구성해 나간다.&lt;/p>
&lt;hr>
&lt;p>두 머클 트리의 비교는 루트 노드의 해시값을 비교하는 것으로 시작하며, 다른 데이터를 갖는 버킷을 찾을 경우 그 버킷들만 동기화한다.&lt;/p>
&lt;p>머클 트리를 사용하면 동기화해야 하는 데이터 양은 실제로 존재하는 차이의 크기에 비례할 뿐, 두 서버에 보관된 데이터의 총량과는 무관해진다.&lt;/p>
&lt;ul>
&lt;li>실제로 쓰이는 시스템의 경우 버킷 하나의 크기가 꽤 크다.&lt;/li>
&lt;li>10억(1B) 개의 키를 백만(1M) 개의 버킷으로 관리하면, 하나의 버킷은 1,000개 키를 관리한다.&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-센터-장애-처리">데이터 센터 장애 처리&lt;/h4>
&lt;p>데이터 센터 장애는 정전, 네트워크 장애, 자연재해 등 다양한 이유로 발생할 수 있다.&lt;/p>
&lt;p>데이터 센터의 장애에 대응할 수 있는 시스템을 만드려면 데이터를 여러 데이터 센터에 다중화하는 것이 중요하다.&lt;/p>
&lt;h3 id="시스템-아키텍처-다이어그램">시스템 아키텍처 다이어그램&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_14.png"
width="842"
height="525"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_14_hu3a1f1cde060e244af1e3932a5858e642_94830_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_14_hu3a1f1cde060e244af1e3932a5858e642_94830_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="384px"
>&lt;/p>
&lt;ul>
&lt;li>클라이언트는 키-값 저장소가 제공하는 두 가지 단순한 API, &lt;code>get(key)&lt;/code>, &lt;code>put(key, value)&lt;/code>와 통신한다.&lt;/li>
&lt;li>중재자는 클라이언트에게 키-값 저장소에 대한 프락시 역할을 하는 노드다.&lt;/li>
&lt;li>노드는 안정 해시의 해시 링 위에 분포한다.&lt;/li>
&lt;li>노드를 자동으로 추가 또는 삭제할 수 있도록, 시스템은 완전히 분산된다.&lt;/li>
&lt;li>데이터는 여러 노드에 다중화된다.&lt;/li>
&lt;li>모든 노드가 같은 책임을 지므로, SPOF(Single Point of Failure)는 존재하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_15.png"
width="830"
height="656"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_15_hud90111428b56169725aae5ee0bdfc804_100802_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_15_hud90111428b56169725aae5ee0bdfc804_100802_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="303px"
>&lt;/p>
&lt;p>완전히 분산된 설계를 채택하였으므로 모든 노드는 제시된 기능을 전부 지원해야한다.&lt;/p>
&lt;h3 id="쓰기-경로">쓰기 경로&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_16.png"
width="845"
height="458"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_16_hu216694585a97b0bfbb508eaee3fd8e8a_77802_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_16_hu216694585a97b0bfbb508eaee3fd8e8a_77802_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="카산드라의 사례"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/p>
&lt;ol>
&lt;li>쓰기 요청이 커밋 로그 파일에 기록된다.&lt;/li>
&lt;li>데이터가 메모리 캐시에 기록된다.&lt;/li>
&lt;li>메모리 캐시가 가득 차거나 사전에 정의된 임계치에 도달하면 데이터는 디스크에 있는 SSTable에 기록된다.
&lt;ul>
&lt;li>SSTable: Sorted-String Table의 약어로 &amp;lt;키, 값&amp;gt; 의 순서쌍을 정렬된 리스트로 관리하는 테이블이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="읽기-경로">읽기 경로&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_17.png"
width="845"
height="446"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_17_huaac619f90ef719991892748c739fd616_71124_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_17_huaac619f90ef719991892748c739fd616_71124_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="189"
data-flex-basis="454px"
>&lt;/p>
&lt;p>읽기 요청을 받은 노드는 데이터가 메모리 캐시에 있는지부터 살핀 후 데이터를 클라이언트에게 반환한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_18.png"
width="843"
height="425"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_18_hub84a0c909dfc6b10b41bdf7efd5bb775_89775_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_18_hub84a0c909dfc6b10b41bdf7efd5bb775_89775_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="476px"
>&lt;/p>
&lt;p>데이터가 메모리에 없는 경우 디스크에서 가져온다.&lt;/p>
&lt;p>어느 SSTable에 찾는 키가 있는지 효율적으로 찾기 위해 블룸 필터(Bloom filter)가 흔히 사용된다.&lt;/p>
&lt;ol>
&lt;li>데이터가 메모리에 있는지 검사하고 있다면 반환한다.&lt;/li>
&lt;li>데이터가 메모리에 없으므로 블룸 필터를 검사한다.&lt;/li>
&lt;li>블룸 필터를 통해 어떤 SSTable에 키가 보관되어 있는지 알아낸다.&lt;/li>
&lt;li>SSTable에서 데이터를 가져온다.&lt;/li>
&lt;li>해당 데이터를 클라이언트에게 반환한다.&lt;/li>
&lt;/ol>
&lt;h2 id="요약">요약&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>목표/문제&lt;/th>
&lt;th>기술&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>대규모 데이터 저장&lt;/td>
&lt;td>안정 해시를 사용해 서버들에 부하 분산&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>읽기 연산에 대한 높은 가용성 보장&lt;/td>
&lt;td>데이터를 여러 데이터센터에 다중화&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>쓰기 연산에 대한 높은 가용성 보장&lt;/td>
&lt;td>버저닝 및 백터 시계를 사용한 충돌 해소&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 파티션&lt;/td>
&lt;td>안정 해시&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>점진적 규모 확장성&lt;/td>
&lt;td>안정 해시&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>다양성(heterogeneity)&lt;/td>
&lt;td>안정 해시&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>조절 가능한 데이터 일관성&lt;/td>
&lt;td>정족수 합의(quorum consensus)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>일시적 장애 처리&lt;/td>
&lt;td>느슨한 정족수 프로토콜(sloppy quorum)과 단서 후 임시 위탁(hinted handoff)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>영구적 장애 처리&lt;/td>
&lt;td>머클 트리(Merkle tree)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 센터 장애 대응&lt;/td>
&lt;td>여러 데이터 센터에 걸친 데이터 다중화&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item></channel></rss>