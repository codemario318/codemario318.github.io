<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>System Design on Mario Blog</title><link>https://codemario318.github.io/tags/system-design/</link><description>Recent content in System Design on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Wed, 05 Mar 2025 11:27:49 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/system-design/index.xml" rel="self" type="application/rss+xml"/><item><title>전략적 설계: 도메인 지식 찾아내기</title><link>https://codemario318.github.io/post/learning-domain-driven-design/2/</link><pubDate>Wed, 05 Mar 2025 11:27:49 +0900</pubDate><guid>https://codemario318.github.io/post/learning-domain-driven-design/2/</guid><description>&lt;img src="https://codemario318.github.io/post/learning-domain-driven-design/2/cover.png" alt="Featured image of post 전략적 설계: 도메인 지식 찾아내기" />&lt;blockquote>
&lt;p>&lt;em>&amp;ldquo;운영환경에 배포되는 것은 도메인 전문가의 지식이 아니라 개발자의 이해 혹은 오해다.&amp;rdquo; - Alberto Brandolini&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>이번 장에서는 비즈니스 도메인 분석 주제를 좀 더 깊이 있게 &lt;strong>하위 도메인 내부에서 일어나는 일&lt;/strong>, 즉 &lt;strong>비즈니스 기능&lt;/strong>과 &lt;strong>로직&lt;/strong>에 초첨을 맞춘다.&lt;/p>
&lt;p>효과적인 커뮤니케이션과 지식 공유를 위한 도메인 주도 설계 도구인 &lt;strong>유비쿼터스 언어&lt;/strong>를 배우고, 이를 통해 비즈니스 도메인의 복잡성을 배우며, 비즈니스 로직을 소프트웨어 모델로 만들고 구현하는데 이를 활용한다.&lt;/p>
&lt;h2 id="비즈니스-문제">비즈니스 문제&lt;/h2>
&lt;p>소프트웨어 시스템은 &lt;strong>비즈니스 문제를 해결하는 솔루션&lt;/strong>이다.&lt;/p>
&lt;p>비즈니스 도메인에서 &lt;strong>문제&lt;/strong>(problem)의 의미는 광범위하다.&lt;/p>
&lt;ul>
&lt;li>워크플로와 프로세스 최적화&lt;/li>
&lt;li>수작업 최소화&lt;/li>
&lt;li>자원 관리&lt;/li>
&lt;li>의사결정 지원&lt;/li>
&lt;li>데이터 관리 등&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>비즈니스 문제&lt;/strong>는 &lt;strong>비즈니스 도메인과 하위 도메인의 모든 수준에서 발생&lt;/strong>할 수 있다.&lt;/p>
&lt;p>하위 도메인은 &lt;strong>세분화된 문제 도메인&lt;/strong>(problem domain)으로 특정 비즈니스 기능에 대한 솔루션을 제공하는 것이 목적이다.&lt;/p>
&lt;ul>
&lt;li>지식 관리 하위 도메인: 정보를 저장하고 추출하는 프로세스&lt;/li>
&lt;li>어음 교환 하위 도메인: 재무 거래 실행 프로세스를 최적화하는 솔루션&lt;/li>
&lt;li>회계 하위 도메인: 기업의 자금을 관리하는 솔루션&lt;/li>
&lt;/ul>
&lt;h2 id="도메인-지식-찾아내기">도메인 지식 찾아내기&lt;/h2>
&lt;p>효과적인 소프트웨어 솔루션을 서례하려면 적어도 &lt;strong>기본적인 비즈니스 도메인 지식&lt;/strong>이 있어야한다.&lt;/p>
&lt;p>이러한 지식은 도메인 전문가의 몫으로, 개발자가 도메인 전문가가 되는 것은 비효율적이다.&lt;/p>
&lt;p>따라서 &lt;strong>도메인 전문가를 이해&lt;/strong>하는 것이 더 효율적이며, 이를 위해 그들이 쓰는 &lt;strong>동일한 비즈니스 용어&lt;/strong>를 사용하는 것이 중요하다.&lt;/p>
&lt;p>효과적은 소프트웨어는 도메인 전문가가 &lt;strong>문제를 생각하는 방식&lt;/strong>, 즉 &lt;strong>멘탈 모델&lt;/strong>을 모방해야한다.&lt;/p>
&lt;p>비즈니스 문제와 요구사항 이면에 있는 이유에 대한 이해가 없다면 솔루션은 비즈니스 요구사항을 소스코드로 &amp;lsquo;번역&amp;rsquo;한 것에 불과하다.&lt;/p>
&lt;p>알베르토 브랜돌리니는 &lt;strong>소프트웨어 개발&lt;/strong>은 &lt;strong>배우는 과정&lt;/strong>이고, &lt;strong>작동하는 코드&lt;/strong>는 그 부산물이라고 설명한다.&lt;/p>
&lt;p>이는 소프트웨어 프로젝트의 성공은 문제 해결을 위해 문제를 배우는(이해하는) 것이 중요하다고 해석될 수 있고, 이는 도메인 전문가와 소프트웨어 엔지니어 간의 &lt;strong>효과적인 지식 공유&lt;/strong>에 달렸다.&lt;/p>
&lt;p>결국 소프트웨어 엔지니어와 도메인 전문가의 효과적인 지식 공유를 위해 &lt;strong>효과적인 커뮤니케이션&lt;/strong>이 필요하다.&lt;/p>
&lt;h2 id="커뮤니케이션">커뮤니케이션&lt;/h2>
&lt;p>거의 모든 소프트웨어 프로젝트에는 도메인 전문가를 비롯한 다양한 역할의 이해관계자의 협업이 필요하다.&lt;/p>
&lt;ul>
&lt;li>엔지니어, 디자이너, 프로젝트 매니저, 테스터, 분석가 등&lt;/li>
&lt;/ul>
&lt;p>좋은 결과물은 모든 참여자가 얼마나 잘 협력할 수 있느냐에 달려있다.&lt;/p>
&lt;ul>
&lt;li>해결하려는 문제에 대해 모든 이해관계자가 동의하고 있는가?&lt;/li>
&lt;li>개발하고 있는 솔루션의 기능 또는 비기능 요구사항 중 서로 충돌하는 가정이 있는가? 등&lt;/li>
&lt;/ul>
&lt;p>모든 참여자의 협력을 이끌어내기 위해 프로젝트와 연관된 모든 것에 대한 합의와 일치는 프로젝트의 성공에 필수이다.&lt;/p>
&lt;p>효과적인 커뮤니케이션이 필수적이지만 소프트웨어 프로젝트에서 찾기는 여러운데, 그 이유중 하나는 비즈니스 담당자와 엔지니어가 서로 직접 협업하지 않는 것이다.&lt;/p>
&lt;p>대부분 도메인 전문가가 여러 이해 관계자를 거쳐 도메인 지식을 일반적으로 엔지니어에게 전달한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/learning-domain-driven-design/2/img.png"
width="724"
height="289"
srcset="https://codemario318.github.io/post/learning-domain-driven-design/2/img_huc2dda173e2ce7892d3c1c9e316e63c7f_120237_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/learning-domain-driven-design/2/img_huc2dda173e2ce7892d3c1c9e316e63c7f_120237_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="소프트웨어 프로젝트에서의 지식 공유 흐름"
class="gallery-image"
data-flex-grow="250"
data-flex-basis="601px"
>&lt;/p>
&lt;p>이러한 과정에서 도메인 지식은 &lt;strong>분석 모델&lt;/strong>(analysis model, 명세?)로 알려진 엔지니어 친화적인 형태로 &lt;strong>변환&lt;/strong>되어 전달되며, 이러한 과정에서 비즈니스 문제 해결에 중요한 도메인 지식이 손실된다. (반대로도 마찬가지)&lt;/p>
&lt;p>이러한 문서화된 커뮤니케이션은 최신 정보를 담아내지 못하며, 결국 소스코드가 이후 프로젝트 유지관리할 엔지니어에게까지도 비즈니스 도메인 지식을 전달하는 데 사용되기 때문에 비즈니스 도메인에 대한 이해는 더욱 멀어진다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/learning-domain-driven-design/2/img_1.png"
width="723"
height="245"
srcset="https://codemario318.github.io/post/learning-domain-driven-design/2/img_1_hucb3fcbc7e85658086ab64513b0e94320_105756_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/learning-domain-driven-design/2/img_1_hucb3fcbc7e85658086ab64513b0e94320_105756_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="모델 변환"
class="gallery-image"
data-flex-grow="295"
data-flex-basis="708px"
>&lt;/p>
&lt;p>이런 소프트웨어 개발 과정은 전화 게임과 비슷하게 점점 왜곡된 형태로 전달될 수 있고, 이런 정보는 소프트웨어 엔지니어가 잘못된 솔루션을 구현하게 하거나, 솔루션이 올바르더라도 해결하려는 문제가 잘못된 경우로 이어질 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/learning-domain-driven-design/2/img_2.png"
width="1280"
height="720"
srcset="https://codemario318.github.io/post/learning-domain-driven-design/2/img_2_hu077d8b1cc3d9451694c409f982a6d8df_975481_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/learning-domain-driven-design/2/img_2_hu077d8b1cc3d9451694c409f982a6d8df_975481_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="고요속 외침"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;p>이 같은 문제를 해결하기 위해 도메인 주도 설계는 도메인 전문가가 소프트웨어 엔지니어에게 지식을 전달하기 위한 더 나은 방법을 제안하며, 유비쿼터스 언어가 바로 그것이다.&lt;/p>
&lt;h2 id="유비쿼터스-언어란-무엇인가">유비쿼터스 언어란 무엇인가?&lt;/h2>
&lt;p>유비쿼터스 언어는 프로젝트 참가자들이 효과적으로 소통하기 위해 변환에 의존하지 말고 같은 언어를 사용하는 것을 의미하며, 이는 도메인 주도 설계의 초석이 된다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>&amp;ldquo;우리가 말하는 상식은 실제로 일반적이지 않다.&amp;rdquo; - Voltaire&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>전통적인 소프트웨어 개발 생애 주기에서 변호나이 어떻게 일어나는지 정리해보면 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>도메인 지식 -&amp;gt; 분석 모델&lt;/li>
&lt;li>분석 모델 -&amp;gt; 요구사항&lt;/li>
&lt;li>요구사항 -&amp;gt; 시스템 설계&lt;/li>
&lt;li>시스템 설계 -&amp;gt; 소스코드&lt;/li>
&lt;/ul>
&lt;p>도메인 주도 설계에서는 도메인 지식을 계속해서 변환하는 대신, 비즈니스 도메인을 설명하기 위한 단일화된 언어 체계를 세운다(유비쿼터스 언어).&lt;/p>
&lt;p>소프트웨어 프로젝트의 모든 이해 관계자는 비즈니스 도메인을 설명할 때 유비쿼터스 언어를 사용해야 하며, 핵심은 도메인 전문가가 유비쿼터스 언어를 사용해 비즈니스 도메인을 추론하는 데 편안함을 느껴야 하ㄴ다는 점이다.&lt;/p>
&lt;p>모든 프로젝트 참가자의 공통된 이해는 오직 유비쿼터스 언어와 그 용어의 지속적인 사용을 통해서만 함양될 수 있다.&lt;/p>
&lt;h2 id="비즈니스-언어">비즈니스 언어&lt;/h2>
&lt;p>유비쿼터스 언어는 비즈니스 언어이므로 기술 용어는 빼고 비즈니스 도메인에 관련된 용어로만 구성해야 한다.&lt;/p>
&lt;p>유비쿼터스 언어는 도메인 전문가의 이해와 비즈니스 도메인에 대한 멘탈 모델을 쉽게 이해할 수 있는 관점으로 표현하는 것을 목표로 한다.&lt;/p>
&lt;h3 id="시나리오">시나리오&lt;/h3>
&lt;p>광고 캠페인 관리 시스템 예시를 살펴본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>비즈니스 언어&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>광고 캠페인은 다양한 창의적인 자료를 전시할 수 있다.&lt;/li>
&lt;li>캠페인은 최소한 하나의 광고 할당이 활성화되어야 게시된다.&lt;/li>
&lt;li>판매 커미션은 거래가 승인된 후 회계 처리된다.&lt;/li>
&lt;/ul>
&lt;p>모든 문장은 비즈니스 도메인을 바라보는 도메인 전문가의 시각을 반영한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>기술적 언어&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>광고의 아이프레임(iframe)은 HTML 파일을 표시한다.&lt;/li>
&lt;li>캠페인은 &amp;lsquo;활성-할당(active-placement)&amp;rsquo; 테이블에 하나의 연관 레코드가 있어야 게시된다.&lt;/li>
&lt;li>판매 커미션은 거래(transaction) 테이블과 판매-승인(aspproved-sales) 테이블의 연관 레코드에 근거하여 처리된다.&lt;/li>
&lt;/ul>
&lt;p>순수하게 기술적이어서 도메인 전문가가 이해하기에 명확하지 않을 것이다.&lt;/p>
&lt;hr>
&lt;p>개발자가 기술적인 관점에서만 비즈니스 도메인을 바라보는게 익숙하다면, 비즈니스 로직을 완전히 이해할 수 없거나, 비즈니스 로직이 왜 그렇게 운영되는지 이해할 수 없어 결국 효과적으로 솔루션을 구현하는 능력이 제한될 것이다.&lt;/p>
&lt;ul>
&lt;li>실제 비즈니스에서 해결하려는 문제의 를 자체적인 해석을 통해 변환되므로 근본적인 이해와 멀어질 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="일관성">일관성&lt;/h3>
&lt;p>유비쿼터스 언어는 반드시 정확하고 일관성이 있어야 한다.&lt;/p>
&lt;ul>
&lt;li>가정할 필요가 없어야 하고 비즈니스 도메인의 로직을 명료하게 표현해야 함&lt;/li>
&lt;/ul>
&lt;p>모호성이 커뮤니케이션을 방해하기 때문에 용어는 오직 하나의 의미를 가져야한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>모호한 용어&lt;/strong>&lt;/p>
&lt;p>비즈니스 도메인에서는 &lt;strong>정책&lt;/strong>(policy)이라는 용어가 여러 의미를 가지며, 정확한 의미는 맥락에 따라 사람 간의 상호작용을 통해서만 알 수 있다.&lt;/p>
&lt;p>규제 규칙, 보험 계약 이라는 정책을 예시로 들면,&lt;/p>
&lt;p>소프트웨어는 이러한 모호성에 잘 대처하지 못하며, &amp;ldquo;정책&amp;quot;이라는 개체(entity)를 코드로 모델링하기가 어려울 수 있다.&lt;/p>
&lt;p>유비쿼터스 언어는 용어마다 단일 의미를 갖게 하기 때문에 &amp;ldquo;정책&amp;quot;의 경우 &lt;strong>규제 규칙&lt;/strong>(regulatory rule)과 &lt;strong>보험 계약&lt;/strong>(insurance contract) 두 용어를 사용하여 명확한 모델을 만들어야 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>동의어&lt;/strong>&lt;/p>
&lt;p>유비쿼터스 언어에서 두 용어는 서로 바꿔 사용할 수 없다.&lt;/p>
&lt;p>&lt;strong>사용자&lt;/strong>라는 용어는 수많은 시스템에서 사용하지만, 도메인 전문가의 언어로 신중하게 설명하면 &lt;strong>사용자&lt;/strong>와 &lt;strong>방문자&lt;/strong>, &lt;strong>관리자&lt;/strong>, &lt;strong>계정&lt;/strong> 등의 다른 용어가 혼용된다는 것을 발견할 수 있다.&lt;/p>
&lt;p>&lt;strong>사용자&lt;/strong>가 맥락에 따라 다른 역할을 가지고 다른 행동을 하는 것 처럼 동의어는 대부분 맥락에 따라 다른 개념을 가지며, 이는 비즈니스 도메인에 대한 이해를 복잡하게 만들 수 있다.&lt;/p>
&lt;p>따라서 특정 컨텍스트 안에서 각각의 용어를 사용해야하며, 용어의 차이점을 이해해야 간단하고 명확한 모델을 구축하고 비즈니스 도메인 객체의 구현이 가능해진다.&lt;/p>
&lt;h2 id="비즈니스-도메인-모델">비즈니스 도메인 모델&lt;/h2>
&lt;p>모델링 관점에서 유비쿼터스 언어를 살펴보자&lt;/p>
&lt;h3 id="모델이란-무엇인가">모델이란 무엇인가?&lt;/h3>
&lt;blockquote>
&lt;p>&lt;em>&amp;ldquo;모델이란 사물이나 현상에서 의도한 관점만 강조하고 다른 측면은 무시하여 간략히 표현한 것이다. 즉 특정 용도를 마음에 둔 추상화의 결과다.&amp;rdquo; - Rebecca Wirfs-Brock&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>모델은 실세계의 복제가 아니라 &lt;strong>실제 시스템을 이해하는 데 우움을 주는 인간의 창조물&lt;/strong>이다.&lt;/p>
&lt;p>좋은 예시로 지도가 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/learning-domain-driven-design/2/img_3.png"
width="723"
height="349"
srcset="https://codemario318.github.io/post/learning-domain-driven-design/2/img_3_hu17fce62deaeef7427ef9cc3a81256c34_643147_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/learning-domain-driven-design/2/img_3_hu17fce62deaeef7427ef9cc3a81256c34_643147_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="목적에 따른 지도들"
class="gallery-image"
data-flex-grow="207"
data-flex-basis="497px"
>&lt;/p>
&lt;p>각 지도는 특정 목적을 지원하는 데 충분한 자료만 담고 있으며, 이 특정 목적이 해당 지도가 풀고자 하는 문제이다.&lt;/p>
&lt;h3 id="효과적인-모델링">효과적인 모델링&lt;/h3>
&lt;p>모든 모델에는 목적이 있고 효과적인 모델은 그 목적을 달성하는 데 필요한 세부사항만 포함한다.&lt;/p>
&lt;ul>
&lt;li>지하철 노선도는 거리를 측정할 수 없음&lt;/li>
&lt;/ul>
&lt;p>유용한 모델은 실세계의 복사본이 아니라 문제를 해결하려는 의도가 있으며, 그 목적에 필요한 정보만을 제공해야 한다.&lt;/p>
&lt;p>모델은 본질적으로 추상화의 결과이며, 추상화는 &lt;strong>불필요한 상세 정보를 생략&lt;/strong>하여 복잡한 문제를 다룰 수 있게하고 당면한 문제를 푸는 데 필요한 정보만 남게 한다.&lt;/p>
&lt;p>반대로 비효과적인 추상화는 &lt;strong>필요한 정보를 제거&lt;/strong>하거나, &lt;strong>불필요한 정보를 포함&lt;/strong>해 잡음을 유발하는 것이다.&lt;/p>
&lt;p>추상화의 목적은 모호함이 아니라 절대적으로 정확할 수 있는 새로운 의미론적 수준을 만드는 것이다.&lt;/p>
&lt;h3 id="비즈니스-도메인-모델링">비즈니스 도메인 모델링&lt;/h3>
&lt;p>유비쿼터스 언어를 발전시키는 것은 사실상 비즈니스 도메인 모델을 구축하는 것이다.&lt;/p>
&lt;ul>
&lt;li>비즈니스가 기능을 어떻게 구현하느냐에 대한 도메인 전문가의 사고 프로세스인 멘탈 모델을 포착해야함&lt;/li>
&lt;li>관련된 비즈니스 엔티티와 그것의 행동, 인과 관계, 불변성 등을 반영해야함&lt;/li>
&lt;/ul>
&lt;p>유비쿼터스 언어는 도메인의 모든 가능한 상세 정보를 포함하는게 아닌 소프트웨어가 해결하고자 하는 특정 문제를 해결하는 데 필요한 만큼의 비즈니스 도메인 관점을 포함하면 된다.&lt;/p>
&lt;p>이 때문에 엔지니어링 팀과 도메인 전문가의 효과적인 커뮤니케이션은 필수적이며, 비즈니스 도메인이 복잡할 수록 커뮤니케이션의 중요성은 커진다.&lt;/p>
&lt;h3 id="지속적인-노력">지속적인 노력&lt;/h3>
&lt;p>유비쿼터스 언어를 정형화(formulation) 하려면 언어의 소유자인 도메인 전문가와의 상호작용이 필요하다.&lt;/p>
&lt;p>오직 실제 도메인 전문가와의 상호작용만이 비즈니스 도메인에 대한 부정확함이나 잘못된 가정, 또는 전체적인 이해 오류를 발견할 수 있다.&lt;/p>
&lt;p>모든 이해관계자는 모든 커뮤니케이션에 유비쿼터스 언어를 지속적으로 사용해서 지식 공유를 확산하고 비즈니스 도메인에 대한 공유된 이해를 강화해야한다.&lt;/p>
&lt;ul>
&lt;li>테스트, 문서화, 소스코드 자체 등&lt;/li>
&lt;/ul>
&lt;p>가장 중요한 점은 유비쿼터스 언어를 발전시키는 것은 진행형이라는 것으로, 지속해서 검증하고 발전시켜야 한다.&lt;/p>
&lt;h3 id="도구">도구&lt;/h3>
&lt;p>유비쿼터스 언어를 수집하고 관리하는 과정을 돕는 도구와 기술이 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>위키&lt;/strong>&lt;/p>
&lt;p>유비쿼터스 언어를 수집하고 관리하는 &lt;strong>용어집&lt;/strong>(glossary)으로 사용될 수 있다.&lt;/p>
&lt;ul>
&lt;li>도메인의 용어에 대한 정보를 얻을 수 있는 거점 역할&lt;/li>
&lt;li>새로운 팀원이 쉽게 적응하게 해줌&lt;/li>
&lt;/ul>
&lt;p>용어집을 유지보수하는 것이 매우 중요하기 때문에 유비쿼터스 언어가 변경되면 모든 팀원이 수정할 수 있게 독려해야 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>유스케이스 또는 거킨테스트&lt;/strong>&lt;br>
용어집은 장점이 명백하지만 엔티티의 이름, 과정, 역할 등의 명사(noun)에만 효과적이라는 본질적인 한계가 존재한다.&lt;/p>
&lt;p>행동(behavior)은 단순히 명사와 관련된 동사의 목록이 아닌 &lt;strong>규칙&lt;/strong>, &lt;strong>가정&lt;/strong>, &lt;strong>불변성&lt;/strong>을 가진 실제 비즈니스 로직이다.&lt;/p>
&lt;p>이러한 개념은 용어집으로 문서화하기 훨씬 어렵기 때문에 용어집은 &lt;strong>유스케이스&lt;/strong>또는 &lt;strong>거킨테스트&lt;/strong>(Gherkin test)처럼 행동을 포착하는 데 적합한 다른 도구와 함께 사용하는 것이 좋다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>거킨테스트&lt;/strong>&lt;br>
거킨테스트(Gherkin Test)는 행동 주도 개발(BDD, Behavior-Driven Development)에서 사용하는 테스트 명세 언어로 개발자가 아닌 이해관계자들도 쉽게 이해할 수 있는 자연어에 가까운 형태로 테스트 시나리오를 작성할 수 있게 해줌&lt;/p>
&lt;ul>
&lt;li>Feature: 테스트할 기능이나 사용자 스토리를 설명합니다.&lt;/li>
&lt;li>Scenario: 특정 상황이나 테스트 케이스를 정의합니다.&lt;/li>
&lt;li>Given: 테스트의 전제 조건을 설명합니다.&lt;/li>
&lt;li>When: 사용자의 행동이나 이벤트를 설명합니다.&lt;/li>
&lt;li>Then: 예상되는 결과나 상태를 설명합니다.&lt;/li>
&lt;li>And, But: 추가적인 조건이나 결과를 설명할 때 사용합니다.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>거긴 언어(Gherkin language)로 작성된 자동화 테스트는 유비쿼터스 언어를 포착하기에 좋은 언어일 뿐 아니라 도메인 전문가와 소프트웨어 엔지니어의 간극을 메우는 보조 도구로서의 역할을 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>도메인 전문가가 테스트를 읽고 시스템의 기대 행동을 검증할 수 있다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Scenario: 에이전트에게 새로운 지원 케이스에 대해 알린다.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Given: 빈센트 줄스는 다음 내용을 담은 새로운 지원 케이스를 제출한다.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;&amp;#34;&amp;#34; 나는 AWS Infinidash를 설정하는 데 도움이 필요하다 &amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> When: 티켓이 울프 에게 할당된다.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Then: 에이전트는 새로운 티켓에 대해 알림을 받는다.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>거킨 기반의 테스트 스위트를 관리하는 것은 어려운 일이지만 복잡한 비즈니스 도메인의 경우 확실히 가치가 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>정적 코드 분석 도구&lt;/strong>&lt;/p>
&lt;p>유비쿼터스 언어의 용어의 사용을 검증할 수 있는 정적 코드 분석 도구도 있다. (NDepend)&lt;/p>
&lt;hr>
&lt;p>이런 도구들이 유용하긴 하지만 &lt;strong>일상적인 상호작용에서 실제로 유비쿼터스 언어를 사용하는 것&lt;/strong>보다는 못하다.&lt;/p>
&lt;p>애자일 매니페스토에서는 &amp;ldquo;프로세스나 도구보다 개인과의 상호작용이 우선이다.&amp;ldquo;라고 강조한다.&lt;/p>
&lt;h3 id="도전과제">도전과제&lt;/h3>
&lt;hr>
&lt;p>&lt;strong>질문하기&lt;/strong>&lt;/p>
&lt;p>도메인 지식을 수집하는 신뢰할 만한 유일한 방법은 도메인 전문가와 대화를 하는 것이다.&lt;/p>
&lt;p>대부분의 경우 가장 중요한 지식은 암묵지 이며, 이는 도메인 전문가의 정신에만 존재하므로, 여기에 접근하는 유일한 방법은 질문하는 것이다.&lt;/p>
&lt;p>도메인 전문가에게 질문하는 것에 경험이 쌓이면 이 과정이 단순히 존재하는 지식을 발견하는 것뿐만 아니라 도메인 전문가와 협력해서 모델을 함께 만들어가는 것이 자주 포함된다는 사실을 알게된다.&lt;/p>
&lt;p>도메인 전문가라도 자신의 비즈니스 도메인에 대한 이해가 모호하거나 공백이 있을 수 있으며, 명시적 정의가 없는 비즈니스 도메인 개념을 발견할 수도 있다.&lt;/p>
&lt;p>그러므로 비즈니스 도메인 특성에 대해 질문하면 종종 숨어있던 충돌과 공백을 찾아내 명확하게 할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>개선하기&lt;/strong>&lt;/p>
&lt;p>이미 프로젝트에 사용중인 도메인 관련 언어들이 DDD 원칙을 따르지 않아 비즈니스 도메인을 효과적으로 반영하지 않을 수 있다.&lt;/p>
&lt;p>이러한 경우 필요한 도구는 인내심으로, 문서화나 소스코드와 같이 제어하기 쉬운 부분부터 올바른 언어를 사용한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>영어 명사&lt;/strong>&lt;/p>
&lt;p>회사에서 영어를 사용하지 않는다고 하더라도, 비즈니스 도메인의 엔티티(entity) 만큼은 영어 명사로 사용하는 것이 좋다.&lt;/p>
&lt;ul>
&lt;li>자연스럽게 코드에서도 쉽게 동일한 용어를 사용하게 된다.&lt;/li>
&lt;/ul>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>효과적인 커뮤니케이션과 지식 공유는 성공적인 소프트웨어 프로젝트에 필수이며, 소프트웨어 엔지니어가 소프트웨어 솔루션을 설계하고 개발하기 위해서는 반드시 비즈니스 도메인을 이해해야한다.&lt;/p>
&lt;p>유비쿼터스 언어는 도메인 전문가와 소프트웨어 엔지니어의 지식 간극을 메워주는 효과적인 도구이다.&lt;/p>
&lt;ul>
&lt;li>대화, 문서화, 테스트, 다이어그램, 소스코드 등 프로젝트 전반에 걸쳐 모든 이해관계자가 공유된 언어를 사용함으로써 커뮤니케이션과 지식 공유를 강화할 수 있음&lt;/li>
&lt;/ul>
&lt;p>효과적인 커뮤니케이션을 위해 유비쿼터스 언어에서 반드시 모호성과 암묵적 가정을 제거해야한다.&lt;/p>
&lt;ul>
&lt;li>모든 용어는 일관성이 있어야함&lt;/li>
&lt;li>모호하지 않고 동의허가 없어야함&lt;/li>
&lt;/ul>
&lt;p>유비쿼터스 언어를 육성하는 것은 지속적인 과정이다.&lt;/p>
&lt;ul>
&lt;li>프로젝트가 발전함에 따라 더 많은 도메인 지식이 발견되며 이러한 통찰이 유비쿼터스 언어에 반영되는 것이 중요함&lt;/li>
&lt;/ul>
&lt;p>위키 기반 용어집, 거킨 테스트 같은 도구는 유비쿼터스 언어를 문서화하고 유지보수 하는 과정을 상당히 쉽게 해주지만, 효과적인 유비쿼터스 언어의 전제 조건은 언어를 사용해야한다는 것이다.&lt;/p>
&lt;ul>
&lt;li>모든 프로젝트 관련 커뮤니케이션에서 유비쿼터스 언어를 일관되게 사용해야함&lt;/li>
&lt;/ul></description></item><item><title>3.1. 저장소와 검색: 데이터베이스를 강력하게 만드는 데이터 구조</title><link>https://codemario318.github.io/post/designing-data-intensive-application/3/1/</link><pubDate>Tue, 04 Mar 2025 13:51:49 +0900</pubDate><guid>https://codemario318.github.io/post/designing-data-intensive-application/3/1/</guid><description>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/cover.png" alt="Featured image of post 3.1. 저장소와 검색: 데이터베이스를 강력하게 만드는 데이터 구조" />&lt;p>가장 기본적인 수준에서 데이터베이스는 &lt;strong>데이터 저장&lt;/strong>, &lt;strong>데이터 제공&lt;/strong> 두 가지 작업을 수행한다.&lt;/p>
&lt;p>애플리케이션 개발자가 처음부터 자신의 저장소 엔진을 구현하기보다는 사용 가능한 여러 저장소 엔진 중에 애플리케이션에 적합한 엔진을 선택하는 작업이 필요하다.&lt;/p>
&lt;p>따라서 특정 &lt;strong>작업부하&lt;/strong>(workload) 유형에서 좋은 성능을 내게끔 저장소 엔지을 조정하려면 저장소 엔진이 내부에서 수행되는 작업에 대해 대략적인 개념을 이해할 필요가 있다.&lt;/p>
&lt;p>특히 &lt;strong>트랜잭션&lt;/strong> 작업부하에 맞춰 최적화된 저장소 엔진과 &lt;strong>분석&lt;/strong>을 위해 최적화된 엔진 간에는 큰 차이가 있으므로, 우선 &lt;strong>관계형 데이터베이스&lt;/strong>와 &lt;strong>NoSQL&lt;/strong>이라 불리는 데이터베이스에 사용되는 저장소
엔진에 대해 간략히 살펴보고, &lt;strong>로그 구조&lt;/strong>(log-structured) 계열 저장소 엔진(B-tree 같은)과 &lt;strong>페이지 지향&lt;/strong>(page-oriented) 계열 저장소 엔진을 검토한다.&lt;/p>
&lt;h2 id="로그와-색인">로그와 색인&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>db_set &lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">,&lt;/span>&lt;span class="nv">$2&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &amp;gt;&amp;gt; database
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">db_get &lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> grep &lt;span class="s2">&amp;#34;^&lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">,&amp;#34;&lt;/span> database &lt;span class="p">|&lt;/span> sed -e &lt;span class="s2">&amp;#34;s/^&lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">,//&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> tail -n &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위는 매우 간단한 데이터베이스로 키-값 저장소를 함수 두 개로 구현되었으며, 기본적인 저장소 형식은 매 라인마다 쉼표로 구분된 키-값 쌍을 포함한 텍스트 파일이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>db_set&lt;/code>을 호출할 때마다 파일의 끝에 추가하므로 키를 여러 번 갱신해도 값의 예전 버전을 덮어 쓰지 않음&lt;/li>
&lt;li>최신 값을 찾기 위해 파일에서 키의 가장 마지막 항목 확인 (&lt;code>tail -n 1&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>일반적으로 &lt;strong>파일 추가&lt;/strong> 작업은 매우 효율적이기 때문에 &lt;code>db_set&lt;/code> 함수는 매우 간단한 작업의 경우 꽤 좋은 성능을 보이는데, 이 때문에 많은 데이터베이스는 내부적으로 추가 전용(append-only) 데이터
파일인 &lt;strong>로그&lt;/strong>(log)를 사용한다.&lt;/p>
&lt;ul>
&lt;li>실제 데이터베이스는 동시성 제어, 디스크 공간 최적화, 요류 처리 등 여러 많은 문제를 다루지만 기본 원리는 같음&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>로그(log)&lt;/strong> 란?&lt;br>
일반적인 의미로 연속된 추가 전용 레코드&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>db_set&lt;/code>에 비해 &lt;code>db_get&lt;/code> 함수는 데이터베이스에 많은 레코드가 존재하는 경우 성능이 매우 좋지 않다.&lt;/p>
&lt;ul>
&lt;li>키를 찾을 때마다 키가 있는지 찾기 위해 전체 데이터베이스 파일을 처음부터 끝까지 스캔해야함(&lt;code>O(n)&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>이 때문에 데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서는 다른 데이터 구조 즉 &lt;strong>색인&lt;/strong>이 필요하다.&lt;/p>
&lt;p>색인의 일반적인 개념은 어떤 &lt;strong>부가적인 메타데이터를 유지하는 것&lt;/strong> 이다.&lt;/p>
&lt;p>이 메타데이터는 이정표 역할을 해서 원하는 데이터의 위치를 찾는데 도움을 주며, 동일한 데이터를 여러 가지 다양한 방법으로 검색하고 싶다면 데이터의 각 부분에 다양한 색인이 필요하다.&lt;/p>
&lt;p>색인은 기본 데이터(primary data)에서 파생된 &lt;strong>추가적인&lt;/strong> 구조로, 많은 데이터베이스는 색인의 추가와 삭제를 허용한다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스의 내용에는 영향을 미치지 않음&lt;/li>
&lt;li>질의 성능에만 영향을 줌&lt;/li>
&lt;/ul>
&lt;p>이러한 추가적인 구조로 인해 특히 쓰기 과정에서 오버헤드가 발생하며, 위 예시의 로그처럼 단순히 파일에 추가하는 작업이 가장 간단한 쓰기 작업이므로 성능을 앞서기 어렵다.&lt;/p>
&lt;p>어떤 종류의 색인이라도 데이터를 쓸 때마다 색인을 갱신하기 때문에 대개 쓰기 속도를 느리게 만든다.&lt;/p>
&lt;p>이러한 성능 저하는 저장소 시스템의 중요한 트레이드 오프이며 색인을 잘 선택했다면 &lt;strong>읽기 질의 속도가 향상&lt;/strong>되지만, &lt;strong>쓰기 성능은 저하&lt;/strong> 된다.&lt;/p>
&lt;p>때문에 보통 데이터베이스는 자동으로 색인을 생성하지 않으므로, 개발자나 관리자가 애플리케이션의 질의 패턴에 대한 지식을 통해 수동으로 색인을 선택해야한다.&lt;/p>
&lt;h2 id="해시-색인">해시 색인&lt;/h2>
&lt;p>디스크 상의 데이터를 색인하기 위해 인메모리 데이터 구조를 사용할 수 있다.&lt;/p>
&lt;p>단순히 파일에 추가하는 방식으로 데이터 저장소를 구성한다고 가정할때, 가장 간단하게 가능한 색인 전략은 &lt;strong>키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지하는 전략&lt;/strong>이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img.png"
width="766"
height="387"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_hu10802d0377ceddec2b44e8f20547cd27_67858_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_hu10802d0377ceddec2b44e8f20547cd27_67858_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="인메모리 해시맵으로 키-값 쌍의 로그 저장하기"
class="gallery-image"
data-flex-grow="197"
data-flex-basis="475px"
>&lt;/p>
&lt;ul>
&lt;li>파일에 새로운 키-값 쌍을 추가할 때마다 방금 기록한 데이터의 오프셋을 반영하기 위해 해시 맵도 갱신&lt;/li>
&lt;li>값을 조회하려면 해시 맵을 사용해 데이터 파일에서 오프셋을 찾아 해당 위치를 구하고 값을 읽음&lt;/li>
&lt;/ul>
&lt;p>이 방식은 매우 단순해 보이지만 실제로 많이 사용하는 접근법이다.&lt;/p>
&lt;ul>
&lt;li>해시 맵을 전부 메모리에 유지하기 때문에 사용 가능한 램에 모든 키가 저장된다는 조건을 전제로 고성능으로 읽기, 쓰기를 보장&lt;/li>
&lt;li>값은 한 번의 디스크 탐색으로 디스크에서 적재할 수 있기 때문에 사용 가능한 메모리보다 더 많은 공간을 사용&lt;/li>
&lt;/ul>
&lt;p>이러한 저장소 엔진은 각 키의 값이 자주 갱신되는 상황에 매우 적합하다.&lt;/p>
&lt;ul>
&lt;li>쓰기가 많지만 고유 키는 많지 않은 작업부하&lt;/li>
&lt;li>ex) 키가 특정 영상의 URL, 값이 영상의 재생 횟수 인 경우&lt;/li>
&lt;/ul>
&lt;p>하지만 파일에 항상 추가만 할 경우 결국 디스크 공간이 부족해지며, 이를 위해 특정 크기의 &lt;strong>세그먼트&lt;/strong>(segment)로 로그를 나누는 방식이 좋은 해결책으로 사용된다.&lt;/p>
&lt;ul>
&lt;li>특정 크기에 도달하면 세그먼트 파일을 닫고, 새로운 세그먼트 파일에 이후 쓰기를 수행&lt;/li>
&lt;li>세그먼트 파일들에 대해 컴팩션(compaction)을 수행할 수 있음
&lt;ul>
&lt;li>로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_1.png"
width="765"
height="293"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_1_hu0bae992a8b87768d26a804495794cdcd_41454_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_1_hu0bae992a8b87768d26a804495794cdcd_41454_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="키-값 갱신 로그를 컴팩션하여 각 키의 최신 값만 유지"
class="gallery-image"
data-flex-grow="261"
data-flex-basis="626px"
>&lt;/p>
&lt;p>컴팩션은 보통 세그먼트를 더 작게 만들기 때문에 컴팩션을 수행할 때 동시에 여러 세그먼트들을 병합할 수 있다.&lt;/p>
&lt;ul>
&lt;li>이 때 세그먼트가 쓰여진 후에는 절대 변경할 수 없기 때문에 병합할 세그먼트는 새로운 파일로 만듦&lt;/li>
&lt;li>고정된 세그먼트의 병합과 컴팩션은 백그라운드 스레드에서 수행할 수 있음&lt;/li>
&lt;li>컴팩션을 수행하는 동안 이전 세그먼트 파일을 사용해 읽기와 쓰기 요청의 처리를 정상적으로 계속 수행할 수 있음&lt;/li>
&lt;/ul>
&lt;p>병합 과정이 끝난 이후에는 일기 요청은 이전 세그먼트 대신 새로 병합한 세그먼트를 사용하게끔 전환하고, 이전 세그먼트 파일을 삭제한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_2.png"
width="767"
height="401"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_2_hu7c9ff548df2e8f3ee88f72377b5e69a1_71238_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_2_hu7c9ff548df2e8f3ee88f72377b5e69a1_71238_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="컴팩션과 세그먼트 병합을 동시에 수행"
class="gallery-image"
data-flex-grow="191"
data-flex-basis="459px"
>&lt;/p>
&lt;p>각 세그먼트는 키를 파일 오프셋에 매핑한 자체 인메모리 해시 테이블을 갖게된다.&lt;/p>
&lt;ul>
&lt;li>키의 값을 찾으려면 최신 세그먼트 해시 맵을 먼저 확인&lt;/li>
&lt;li>키가 없다면 두 번째 최신 세그먼트 등을 확인&lt;/li>
&lt;/ul>
&lt;p>병합 과정을 통해 세그먼트 수를 적게 유지하므로 조회할 때 많은 해시 맵을 확인할 필요가 없다.&lt;/p>
&lt;hr>
&lt;p>이러한 아이디어를 실제로 구현하려면 세부적으로 많은 사항을 고려해야 한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>파일 형식&lt;/strong>
&lt;ul>
&lt;li>CSV는 로그에 가장 적합한 형식은 아님&lt;/li>
&lt;li>바이트 단위의 문자열 길이를 부호화한 다음 원시 문자열(이스케이핑할 필요 없이)을 부호화하는 바이너리 형식을 사용하는 편이 더 빠르고 간단함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>레코드 삭제&lt;/strong>
&lt;ul>
&lt;li>키와 관련된 값을 삭제하려면 데이터 파일에 특수한 삭제 레코드(툼스톤(tombstone))를 추가해야함&lt;/li>
&lt;li>로그 세그먼트가 병합될 때 툼스톤은 병합 과정에서 삭제된 키의 이전 값을 무시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>고장(Crash) 복구&lt;/strong>
&lt;ul>
&lt;li>데이터베이스가 재시작되면 인메모리 해시 맵은 손실&lt;/li>
&lt;li>전체 세그먼트 파일을 처음부터 끝가지 읽고 각 키에 대한 최신 값의 오프셋을 확인해서 각 세그먼트 해시 맵을 복원 가능&lt;/li>
&lt;li>하지만 세그먼트 파일이 크면 해시 맵 복원은 오랜 시간이 걸리 수 있음(서버 재시작을 고통스럽게함)&lt;/li>
&lt;li>비트캐스크 같은 경우 각 세그먼트 해시 맵을 메모리로 조금 더 빠르게 로딩할 수 있게 스냅숏을 디스크에 저장해 복수 속도를 높임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>부분적 레코드 쓰기&lt;/strong>
&lt;ul>
&lt;li>로그에 레코드를 추가하는 도중 데이터베이스가 죽을 수 있음&lt;/li>
&lt;li>비트캐스크 파일은 체크섬을 포함하고 있어 로그의 손상된 부분을 탐지해 무시할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>동시성 제어&lt;/strong>
&lt;ul>
&lt;li>쓰기를 엄격하게 순차적으로 로그에 추가할 때 일반적으로 하나의 쓰기 쓰레드만 사용&lt;/li>
&lt;li>데이터 파일 세그먼트는 추가 전용이거나 불변(immutable)이므로 다중 스레드로 동시에 읽기 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;p>추가 전용 로그는 같은 키의 여러개의 쓰기가 발생하므로 비효율 적으로 보일 수 있다.&lt;/p>
&lt;p>예전 값을 새로운 값으로 덮어써 정해진 자리에 파일을 갱신하는 방법도 있지만, 추가 전용 설계는 여러 측면에서 장점이 있다.&lt;/p>
&lt;ul>
&lt;li>추가와 세그먼트 병합은 순차적인 쓰기 작업이므로 보통 무작위 쓰기보다 훨씬 빠름
&lt;ul>
&lt;li>특히 HDD에서 두드러지며, 일부 확장된 순차 쓰기는 SSD에서도 빠름&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>세그먼트 파일이 추가 전용이나 불변이면 동시성과 고장 복구는 훨씬 간단
&lt;ul>
&lt;li>이전 값 부분과 새로운 값 부분을 포함한 파일을 나누어 담으므로, 값을 덮어 쓰는 동안 데이터베이스가 죽는 경우에 대해 걱정할 필요가 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오래된 세그먼트 병합은 시간이 지남에 따라 조각화되는 데이터 파일 문제를 피할 수 있음&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;p>하지만 해시 테이블 색인 또한 제한 사항이 있다.&lt;/p>
&lt;ul>
&lt;li>해시 테이블은 메모리에 저장해야 하므로 키가 너무 많으면 문제가 발생함
&lt;ul>
&lt;li>디스크에 해시 맵을 유지할 수 있지만 디스크 상의 해시ㅣ 맵에 좋은 성능을 기대하기 어려움
&lt;ul>
&lt;li>무작위 접근 I/O가 많이 필요함&lt;/li>
&lt;li>디스크가 가득 찼을 때 확장하는 비용이 비쌈&lt;/li>
&lt;li>해시 충돌 해소를 위해 추가 로직 필요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>점위 질의(Range query)에 적합하지 않음
&lt;ul>
&lt;li>키 값이 연속적이어도 쉽게 스캔할 수 없어 모든 개별 키를 조회해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="ss테이블과-lsm-트리">SS테이블과 LSM 트리&lt;/h2>
&lt;p>각 로그 구조화 저장소 세그먼트는 키-값 쌍의 연속이다.&lt;/p>
&lt;p>이 쌍은 쓰여진 순서대로 나타나므로, 로그에서 같은 키를 갖는 값 중 나중의 값이 이전 값보다 우선 한다는 점만 제외하면 파일에서 키-값 쌍의 순서는 문제가 되지 않는다.&lt;/p>
&lt;p>이를 개선하기 위해 키-값 쌍을 키로 정렬하는 방법을 고려할 수 있다.&lt;/p>
&lt;p>이처럼 키로 정렬된 형식을 &lt;strong>정렬된 문자열 테이블&lt;/strong>(Sorted String Table), 짧게 &lt;strong>SS테이블&lt;/strong>이라 부른다.&lt;/p>
&lt;ul>
&lt;li>각 키는 각 병합된 세그먼트 파일 내에 한 번만 나타나함
&lt;ul>
&lt;li>컴팩션 과정은 이미 이를 보장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>SS테이블은 해시 색인을 가진 로그 세그먼트보다 몇 가지 큰 장점이 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>세그먼트 병합은 파일이 사용 가능한 메모리보다 크더라도 간단하고 효율적&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_3.png"
width="729"
height="483"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_3_hu7c722957ba7cfb7350c21df09c1076e8_90335_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_3_hu7c722957ba7cfb7350c21df09c1076e8_90335_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="SS 테이블 세그먼트 병합하고 각 키의 최신 값만 유지"
class="gallery-image"
data-flex-grow="150"
data-flex-basis="362px"
>&lt;/p>
&lt;ol>
&lt;li>입력 파일을 함께 읽고 각 파일의 첫 번째 키를 확인(정렬된 순서에 따라)&lt;/li>
&lt;li>가장 낮은 키를 출력 파일로 복사한 뒤 이 과정 반복&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>이 과정에서 새로운 병합 세그먼트 파일이 생성되며, 새로 만든 세그먼트 파일도 역시 키로 정렬&lt;/li>
&lt;li>각 세그먼트는 일정 기간 동안 쓰여진 모든 값이 포함되므로, 여러 세그먼트의 같은 값이 포함될 수 있지만, 가장 최근에 만들어진 값이 최신&lt;/li>
&lt;li>따라서 다중 세그먼트가 동일한 키를 포함하는 경우 가장 최근 세그먼트의 값을 유지하고 오래된 세그먼트의 값은 버림&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>파일에서 특정 키를 찾기 위해 메모리에 모든 키의 색인을 유지할 필요가 없음&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_4.png"
width="732"
height="369"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_4_huc566f05f79666e2208f2a7a43b254dbf_70982_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_4_huc566f05f79666e2208f2a7a43b254dbf_70982_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="인메모리 색인을 가진 SS테이블"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="476px"
>&lt;/p>
&lt;p>&lt;code>handiwork&lt;/code> 키를 찾으려 하지만 세그먼트 파일에서 키의 정확한 오프셋을 알지 못한다고 가정해도, &lt;code>handbag&lt;/code>과 &lt;code>handsome&lt;/code> 키의 오프셋을 알고 있다면, 이미 정렬되어있다는 특성을 활용하여 두 키 사이에 있다는 사실을 알 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>handbag&lt;/code> 오프셋으로 이동해 &lt;code>handiwork&lt;/code>가 나올 때까지 스캠하면 됨(키가 존재하지 않는 경우 찾을 수 없음)&lt;/li>
&lt;li>일부 키에 대한 오프셋을 알려주는 인메모리 색인은 여전히 필요&lt;/li>
&lt;li>하지만 색인 내용이 희소할 수 있는 경우, 수 킬로파이트 정도는 매우 빠르게 스캔할 수 있기 때문에 세그먼트 파일 내 수 킬로바이트당 키 하나로 충분&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>압축&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>읽기 요청은 요청 범위 내에서 여러 키-값 쌍을 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기 전 압축함&lt;/li>
&lt;li>희소 인메모리 색인의 각 항목은 압축된 블록의 시작을 가리키게 됨&lt;/li>
&lt;li>디스크 공간을 절약할 수 있고, 이로 인해 I/O 대역폭 사용을 줄일 수 있음&lt;/li>
&lt;/ul>
&lt;h3 id="ss테이블-생성과-유지">SS테이블 생성과 유지&lt;/h3>
&lt;p>유입되는 쓰기가 임의 순서로 발생하기 때문에 데이터를 키로 정렬하려면 고민이 필요하다.&lt;/p>
&lt;p>디스크 상에 정렬된 구조를 유지하는 일은 가능하지만 메모리에 유지하는 편이 훨씬 쉽다.&lt;/p>
&lt;ul>
&lt;li>레드 블랙 트리, AVL 트리 등&lt;/li>
&lt;/ul>
&lt;p>이런 데이터 구조를 이용하면 &lt;strong>임의 순서로 키를 삽입하고 정렬된 순서로 해당 키를 다시 읽을 수&lt;/strong>있다.&lt;/p>
&lt;ul>
&lt;li>쓰기가 들어오면 인메모리 균형 트리 데이터 구조에 추가
&lt;ul>
&lt;li>이 인메모리 트리는 멤테이블(memtable)이라고도 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>멤테이블이 보통 수 메가바이트 정도의 임곗값보다 커지면 SS테이블 파일로 디스크에 기록
&lt;ul>
&lt;li>트리가 이미 키로 정렬된 키-값 쌍을 유지하므로 효율적으로 수행 가능&lt;/li>
&lt;li>새로운 SS테이블 파일은 데이터베이스의 가장 최신 세그먼트가 됨&lt;/li>
&lt;li>SS테이블을 기록하는 동안 쓰기는 새로운 멤테이블 인스턴스에 기록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>읽기 요청을 제공하려면 먼제 멤테이블에서 키를 찾고 없다면 디스크 상의 가장 최신 세그먼트에서 부터 차례대로 확인&lt;/li>
&lt;li>가끔 세그먼트 파일을 합치고 덮어 쓰여지거나 삭제된 값을 버리는 병합과 컴팩션 과정을 수행
&lt;ul>
&lt;li>이 과정은 백그라운드에서 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 계획은 데이터베이스가 고장나면 &lt;strong>아직 디스크로 기록되지 않고 멤테이블에 있는 가장 최신 쓰기는 손실되는 문제&lt;/strong>가 있다.&lt;/p>
&lt;p>이를 대비하기위해 매번 쓰기를 즉시 추가할 수 있게 분리된 로그를 디스크 상 유지해야한다.&lt;/p>
&lt;ul>
&lt;li>이 로그는 멤테이블을 복원할 때만 필요하므로 순서가 정렬되지 않아도 문제되지 않음&lt;/li>
&lt;/ul>
&lt;p>멤테이블을 SS테이블로 기록하고 나면 해당 로그는 버릴 수 있다.&lt;/p>
&lt;h3 id="ss테이블에서-lsm-트리-만들기">SS테이블에서 LSM 트리 만들기&lt;/h3>
&lt;p>여기에 기술된 알고리즘은 기본적으로 레벨DB(LevelDB)와 록스DB(RocksDB), 그리고 다른 애플리케이션에내장하기 이ㅜ해 설계된 키-값 저장소 엔진 라이브러리에서 사용한다.&lt;/p>
&lt;p>구글의 빅테이블(Bigtable)논문에서 영감을 얻은 카산드라와 HBase에서도 유사한 저장소 엔진을 사용한다.&lt;/p>
&lt;p>원래 이 색인 구조는 &lt;strong>로그 구조화 병합 트리&lt;/strong>(Log-Structured Merge-Table, LSM 트리)란 이름으로 발표되었으며, 이 색인 구조는 로그 구조화 파일 시스템의 초기 작업의 기반이 됐다.&lt;/p>
&lt;p>&lt;strong>정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진&lt;/strong>을 &lt;strong>LSM 저장소 엔진&lt;/strong>이라 부른다.&lt;/p>
&lt;h3 id="성능-최적화">성능 최적화&lt;/h3>
&lt;p>LSM 트리 알고리즘은 데이터베이스에 존재하지 않는 키를 찾는 경우 느릴 수 있다.&lt;/p>
&lt;ul>
&lt;li>멤테이블을 확인한 다음 키가 존재하지 않는 사실을 확인하기 전 까지 오래된 세그먼트까지 거슬러 올라야함(디스크 I/O 발생 가능)&lt;/li>
&lt;/ul>
&lt;p>이런 종류의 접근을 최적화하기 위해 저장소 엔진은 보통 &lt;strong>블룸 필터&lt;/strong>(Bloom filter)를 추가적으로 사용한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>블룸 필터(Bloom filter)?&lt;/strong>&lt;br>
집합 내용을 근사한(approximating) 메모리 효율적 데이터 구조&lt;/p>
&lt;/blockquote>
&lt;p>블룸 필터는 키가 데이터베이스에 존재하지 않음을 알려주므로 존재하지 않는 키를 위한 불필요한 디스크 읽기를 많이 절약할 수 있다.&lt;/p>
&lt;hr>
&lt;p>SS테이블을 압축하고 병합하는 순서와 시기를 결정하는 다양한 전략이 있다.&lt;/p>
&lt;p>가장 일반적으로 선택하는 전략은 &lt;strong>크기 계층 컴팩션&lt;/strong>(size-tiered compaction)과 &lt;strong>레벨 컴팩션&lt;/strong>(leveled compaction)이다.&lt;/p>
&lt;ul>
&lt;li>크기 게층 컴팩션
&lt;ul>
&lt;li>상대적으로 새롭고 작은 SS테이블을 상대적으로 오래됐고 큰 SS테이블에 연이어 병합&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>레벨 컴팩션
&lt;ul>
&lt;li>키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 &amp;ldquo;레벨&amp;quot;로 이동&lt;/li>
&lt;li>컴팩션을 점진적으로 진행해 디스크 공간을 덜 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>여러 중요한 세부 사항이 있지만 LSM 트리의 기본 개념은 간단하고 효과적이다.&lt;/p>
&lt;ul>
&lt;li>백그라운드에서 연쇄적으로 SS테이블을 지속적으로 병합하는 것&lt;/li>
&lt;/ul>
&lt;p>이 개념은 데이터셋이 가능한 메모리보다 훨씬 크더라도 여전히 효과적이고, 데이터가 정렬된 순서로 저장돼 있다면 범위 질의를 효율적으로 수행할 수 있다.&lt;/p>
&lt;ul>
&lt;li>최소에서 최대까지 모든 키를 스캔&lt;/li>
&lt;/ul>
&lt;p>이 접근법의 디스크 쓰기는 순차적이기 때문에 LSM 트리가 매우 높은 쓰기 처리량을 보장할 수 있다.&lt;/p>
&lt;h2 id="b-트리">B 트리&lt;/h2>
&lt;p>지금까지 설명한 로그 구조화 색인이 점점 보편화되고 있지만 가장 일반적인 색인 유형은 아니며, 가장 널리 사용되는 색인 구조는 &lt;strong>B 트리&lt;/strong>(B-Tree)로 구조가 &lt;strong>로그 구조화 색인&lt;/strong>과는 상당히 다르다.&lt;/p>
&lt;p>B 트리는 SS테이블과 같이 키로 정렬된 키-값 쌍을 유지하기 때문에 키-값 검색과 범위 질의에 효율적이지만, 설계 철학이 매우 다르다.&lt;/p>
&lt;ul>
&lt;li>로그 구조화 색인
&lt;ul>
&lt;li>데이터베이스를 일반적으로 수 메가바이트 이상의 가변 크기를 가진 &lt;strong>세그먼트&lt;/strong>로 나누고 항상 순차적으로 세그먼트를 기록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>B 트리
&lt;ul>
&lt;li>전통적으로 4KB 크기의 고정 크기 &lt;strong>블록&lt;/strong>이나 &lt;strong>페이지&lt;/strong>로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기 수행&lt;/li>
&lt;li>디스크가 고정 크기 블록으로 배열되기 때문에 근본적으로 하드웨어와 조금 더 밀접한 관련이 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>B 트리의 각 페이지는 주소나 위치를 통해 식별할 수 있으며, 이러한 방식으로 하나의 페이지가 다른 페이지를 참조할 수 있다.&lt;/p>
&lt;ul>
&lt;li>포인터와 비슷하지만 메모리 대신 디스크에 있음&lt;/li>
&lt;/ul>
&lt;p>이러한 페이지 참조는 페이지 트리를 구성하는 데 사용할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_5.png"
width="766"
height="432"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_5_hu276247de4dbbe3c9ef294590e9d78f86_61955_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_5_hu276247de4dbbe3c9ef294590e9d78f86_61955_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="B 트리 색인을 이용한 키 검색"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="425px"
>&lt;/p>
&lt;p>한 페이지는 B 트리의 &lt;strong>루트&lt;/strong>(root)로 지정되며, 색인에서 키를 찾으려면 루트에서 시작한다.&lt;/p>
&lt;p>페이지는 여러 &lt;strong>키&lt;/strong>와 &lt;strong>하위 페이지의 참조&lt;/strong>를 포함되며, 각 하위 페이지는 &lt;strong>키가 계속 이어지는 범위&lt;/strong>를 담당하고 참조 사이의 키는 &lt;strong>해당 범위의 경계가 어디인지&lt;/strong> 나타낸다.&lt;/p>
&lt;p>최종적으로는 개별 키(&lt;strong>리프 페이지&lt;/strong>(leaf page))를 포함하는 페이지에 도달하게되며, 이 페이지는 각 키의 값을 포함하거나 값을 찾을 수 있는 페이지의 참조를 포함하게된다.&lt;/p>
&lt;ul>
&lt;li>B 트리의 한 페이지에서 하위 페이지를 참조하는 수를 &lt;strong>분기 계수&lt;/strong>(branching factor)라 부름&lt;/li>
&lt;li>실제로 분기 계수는 페이지 참조와 범위 경계를 저장할 공간의 양에 의존적(보통 수백개)&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_6.png"
width="767"
height="438"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_6_hu89ce2a7004a0b1a5586f285cb94aff3a_56106_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_6_hu89ce2a7004a0b1a5586f285cb94aff3a_56106_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="페이지 분리로 커진 B 트리"
class="gallery-image"
data-flex-grow="175"
data-flex-basis="420px"
>&lt;/p>
&lt;p>이 알고리즘은 트리가 계속 &lt;strong>균형&lt;/strong>을 유지하는 것을 보장한다.&lt;/p>
&lt;ul>
&lt;li>n개의 키를 가진 B 트리의 깊이가 항상 &lt;code>O(log n)&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>대부분 데이터베이스는 B 트리의 깊이가 3 ~ 4 정도면 충분하므로 검색하려는 페이지를 찾기 위해 많은 페이지 참조를 따라가지 않아도 된다.&lt;/p>
&lt;ul>
&lt;li>분기 계수 500의 4KB 페이지의 4단계 트리는 256TB까지 저장할 수 있음&lt;/li>
&lt;/ul>
&lt;h3 id="신뢰할-수-있는-b-트리-만들기">신뢰할 수 있는 B 트리 만들기&lt;/h3>
&lt;p>B 트리의 기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어쓰며, 덮어쓰기가 페이지 위치를 변경하지 않는다고 가정한다.&lt;/p>
&lt;ul>
&lt;li>페이지를 덮어쓰더라도 페이지를 가르키는 모든 참조는 온전히 남음&lt;/li>
&lt;li>LSM 트리와 같은 로그 구조화 색인은 파일에 추가 할 뿐(더 이상 쓸모 없는 파일은 삭제) 같은 위치의 파일은 변경하지 않음&lt;/li>
&lt;/ul>
&lt;p>디스크의 페이지를 덮어 쓰는 일은 실제 하드웨어가 처리한다.&lt;/p>
&lt;ul>
&lt;li>하드드라이브
&lt;ul>
&lt;li>디스크 헤드를 적절한 곳으로 옮기고, 회전하는 플래터의 올바른 위치가 돌아올 때까지 기다린 다음 적합한 섹터에 새로운 데이터를 덮어씀&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>SSD
&lt;ul>
&lt;li>SSD가 저장소 칩의 상당한 블록을 한번에 지우고 다시 쓰기를 수행&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>일부 동작은 여러 다양한 페이지의 덮어쓰기를 필요로 한다.&lt;/p>
&lt;p>예를 들어, 삽입 때문에 페이지가 너무 많아져 페이지를 나눠야 하는 경우 분할된 두 페이지를 기록하고 두 하위 페이지의 참조를 갱신하게끔 상위 페이지를 덮어쓰기를 해야한다.&lt;/p>
&lt;ul>
&lt;li>이러한 처리 중 일부 페이지만 기록하고 데이터베이스가 고장난다면 결국 색인이 훼손되므로 위험함&lt;/li>
&lt;/ul>
&lt;p>데이터베이스가 고장 상황에서 스스로 복구할 수 있도록 일반적으로 디스크 상에 &lt;strong>쓰기 전 로그&lt;/strong>(write-ahead log, WAL, 재실행 로그, redo log)라는 데이터 구조를 추가해 B 트리를 구현한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>쓰기 전 로그&lt;/strong>&lt;br>
트리 페이지에 변경된 내용을 적용하기 전 모든 B 트리의 변경 사항을 기록하는 추가 전용 파일&lt;br>
데이터베이스가 복구될 때 일관성 있는 상태로 B 트리를 복원하는 데 사용됨&lt;/p>
&lt;/blockquote>
&lt;p>같은 자리의 페이지를 갱신하는 작업은 추가적인 골칫거리다.&lt;/p>
&lt;p>다중 스레드가 동시에 B 트리에 접근할 때 동시성 제어를 하지 않는다면 스레드가 일관성이 깨진 상태의 트리에 접근할 수 있다.&lt;/p>
&lt;p>동시성 제어는 보통 &lt;strong>래치&lt;/strong>(latch, 가벼운 잠금)로 트리의 데이터 구조를 보호한다.&lt;/p>
&lt;ul>
&lt;li>로그 구조화 접근 방식에서는 유입 질의의 간섭 없이 백그라운드에서 모든 병합을 수행하고 가끔 원자적으로 새로운 세그먼트를 이전 세그먼트로 바꾸기 때문에 훨씬 간단함&lt;/li>
&lt;/ul>
&lt;h3 id="b-트리-최적화">B 트리 최적화&lt;/h3>
&lt;p>B 트리는 오랫동안 사용된만큼 많은 최적화 기법이 있다.&lt;/p>
&lt;ul>
&lt;li>페이지 덮어 쓰기와 고장 복구를 위한 WAL 유지 대신, (LMDB 같은)일부 데이터베이스는 쓰기 시 복사 방식(copy-on-write scheme)을 사용함
&lt;ul>
&lt;li>변경된 페이지는 다른 위치에 기록하고 트리에 상위 페이지의 새로운 버전을 만들어 새로운 위치를 가르키게 함&lt;/li>
&lt;li>동시성 제어에도 유용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>페이지에 전체 키를 저장하는 것이 아니라 &lt;strong>키를 축약&lt;/strong>해 쓰면 공간을 절약할 수 있음
&lt;ul>
&lt;li>트리 내부 페이지에서 키가 키 범위 사이의 경계 역할을 하는 데 충분한 정보만 제공하면 됨&lt;/li>
&lt;li>페이지 하나에 키를 더 많이 채우면 트리는 더 높은 분기 계수를 얻어 트리 깊이 수준을 낮출 수 있음(B+ 트리라 부르기도 함)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>일반적으로 페이지는 디스크 상 어디에나 위치할 수 있기 때문에(키 범위가 가깝다고 가까운 위치애 페이지를 배치하지 않음) 질의가 정렬된 순서로 키 범위의 상당 부분을 스캔해야 한다면 모든 페이지에 대해 디스크 찾기가 필요하기 때문에 페이지 단위 배치는 비효율적임
&lt;ul>
&lt;li>많은 B 트리 구현에서 리프 페이지를 디스크 상에 연속된 순서로 나타나게끔 트리를 배치하려 시도하지만 트리가 커지면 순서를 유지하기 어려움&lt;/li>
&lt;li>LSM 트리는 병합하는 과정에서 저장소의 큰 세그먼트를 한 번에 다시 쓰기 때문에 디스크에서 연속된 키를 서로 가깝게 유지하기 더 쉬움&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>트리에 포인터를 추가
&lt;ul>
&lt;li>각 리프 페이지가 양쪽 형제 페이지에 대한 참조를 가지면 상위 페이지로 다시 이동하지 않아도 순서대로 키를 스캔할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>프랙탈 트리(fractal tree) 같은 변형은 디스크 찾기를 줄이기 위해 로그 구조하 개념을 일부 빌렸음
&lt;ul>
&lt;li>기하학의 프랙탈과는 아무 의미 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="b-트리와-lsm-트리-비교">B 트리와 LSM 트리 비교&lt;/h2>
&lt;p>일반적으로 B 트리가 LSM 트리보다 구현 성숙도가 더 높지만 LSM 트리도 그 성능 특성 때문에 관심을 받고 있다.&lt;/p>
&lt;p>LSM 트리는 보통 쓰기에서 더 빠르고, B 트리는 읽기에서 더 빠르다고 여겨진다.&lt;/p>
&lt;ul>
&lt;li>LSM 트리는 각 컴팩션 단계에 있는 여러 가지 데이터 구조와 SS테이블을 확인해야하므로 읽기가 보통 더 느림&lt;/li>
&lt;/ul>
&lt;p>하지만 벤치마크는 보통 결정적이지 않고 작업부하의 세부 사항에 민감하므로 정확한 비교를 위해 실제 필요한 작업부하로 시스템을 테스트해야한다.&lt;/p>
&lt;h3 id="lsm-트리의-장점">LSM 트리의 장점&lt;/h3>
&lt;p>&lt;strong>B 트리 색인&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>모든 데이터 조각을 최소한 두 번 기록해야한다. (쓰기 전 로그, 트리 페이지)&lt;/li>
&lt;li>해당 페이지 내 몇 바이트만 바뀌어도 한 번에 전체 페이지를 기록해야 하는 오버헤드&lt;/li>
&lt;li>일부 저장소 엔진은 전원에 장애가 발생했을 때 일부만 갱신된 페이지로 끝나지 않게 동일한 페이즈를 두 번 덮어씀&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>로그 구조화 색인&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>SS테이블의 반복된 컴팩션과 병함으로 인해 여러 번 데이터를 다시 씀
&lt;ul>
&lt;li>쓰기 증폭(write amplification)
&lt;ul>
&lt;li>데이터베이스에 쓰기 한 번이 데이터베이스 수명 동안 디스크에 여러 번의 쓰기를 야기하는 효과&lt;/li>
&lt;li>SSD는 수명 동안 블록 덮어쓰기 횟수가 정해져 있으므로 주의해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>쓰기가 많은 애플리케이션에서 성능 병목은 데이터베이스가 디스크에 쓰는 속도일 수 있는데, 이 경우 쓰기 증폭은 성능 비용이다.&lt;/p>
&lt;ul>
&lt;li>저장소 엔진이 디스크에 기록할수록 디스크 대역폭 내 처리할 수 있는 초당 쓰기는 점점 줄어듦&lt;/li>
&lt;/ul>
&lt;p>LSM 트리가 상대적으로 쓰기 증폭이 더 낮고, 트리에서 여러 페이지를 덮어쓰는 것이 아닌 순차적으로 컴팩션된 SS 테이블을 쓰기 때문에, 보통 B 트리보다 쓰기 처리량을 높게 유지할 수 있다.&lt;/p>
&lt;ul>
&lt;li>특히 하드디스크는 순차 쓰기가 임의 쓰기 보다 훨씬 더 빠르다.&lt;/li>
&lt;/ul>
&lt;p>LSM 트리는 압축률이 더 좋다.&lt;/p>
&lt;ul>
&lt;li>보통 B 트리보다 디스크에 더 적은 파일을 생성한다.&lt;/li>
&lt;/ul>
&lt;p>B 트리 저장소 엔진은 파편화로 인해 사용하지 않는 디스크 공간 일부가 남는다.&lt;/p>
&lt;ul>
&lt;li>페이지를 나누거나 로우가 기존 페이지에 맞지 않을 때 페이지의 일부 공간은 사용하지 않게됨&lt;/li>
&lt;li>LSM 트리는 페이지 지향적이지 않고 주기적으로 파편화를 없애기 위해 SS테이블을 다시 기록하기 때문에 저장소 오버헤드가 더 낮다.(레벨 컴팩션 사용시 특히 더)&lt;/li>
&lt;/ul>
&lt;p>대다수의 SSD 펌웨어는 내장 저장소 칩에서 임의 쓰기를 순차 쓰기로 전환하기 우해 내부적으로 로그 구조화 알고리즘을 사용한다.&lt;/p>
&lt;ul>
&lt;li>그래서 저장소 엔진의 쓰기 패턴이 SSD에 미치는 영향은 분명하지 않음&lt;/li>
&lt;li>하지만 낮은 쓰기 증폭과 파편화 감소는 SSD의 경우 훨씬 유리함&lt;/li>
&lt;/ul>
&lt;p>데이터를 더 밀집해 표현하면 가능한 I/O 대역폭 내에서 더 많은 읽기와 쓰기 요청이 가능하다.&lt;/p>
&lt;h3 id="lms-트리의-단점">LMS 트리의 단점&lt;/h3>
&lt;p>로그 구조화 저장소의 단점은 &lt;strong>컴팩션 과정&lt;/strong>이 때로는 진행 중인 읽기와 쓰기의 성능에 영향을 준다는 점이다.&lt;/p>
&lt;p>저장소 엔진은 컴팩션을 점진적으로 수행하고 동시 접근의 영향이 없게 수행하려 하지만, 디스크가 가진 자원은 한계가 있으므로 디스크에서 비싼 &lt;strong>컴팩션 연산이 끝날 때까지 요청이 대기해야하는 상황&lt;/strong>이 발생하기 쉽다.&lt;/p>
&lt;p>처리량과 평균 응답 시간이 성능에 미치는 영향은 대개 작으나 로그 구조화 저장소 엔진의 상위 백분위 질의의 응답 시간은 때때로 길다.&lt;/p>
&lt;p>반면 B 트리의 성능은 로그 구조화 저장소 엔진보다 예측하기 쉽다.&lt;/p>
&lt;hr>
&lt;p>또 다른 컴팩션 문제는 높은 쓰기 처리량에서 발생한다.&lt;/p>
&lt;p>디스크의 쓰기 대역폭은 유한하기 때문에 초기 쓰기(로깅(logging)과 멤테이블을 디스크로 방출(flushing))와 백그라운드에서 수행되는 컴팩션 스레드가 이 대역폭을 공유해야한다.&lt;/p>
&lt;p>빈 데이터베이스에 쓰는 경우 전체 디스크 대역폭을 초기 쓰기만을 위해 사용할 수 있지만, 데이터베이스가 커질수록 컴팩션을 위해 더 많은 디스크 대역폭이 필요하다.&lt;/p>
&lt;p>쓰기 처리량이 높음에도 컴팩션 설정을 주의 깊게 하지 않으면 컴팩션이 유입 쓰기 속도를 따라갈 수 없다.&lt;/p>
&lt;ul>
&lt;li>디스크 상에 병합되지 않은 세그먼트 수는 디스크 공간이 부족할 때 까지 증가할 수 있음&lt;/li>
&lt;li>더 많은 세그먼트 파일을 확인해야 하기 때문에 읽기 또한 느려짐&lt;/li>
&lt;/ul>
&lt;p>보통 SS테이블 기반 저장소 엔진은 컴팩션이 유입 속도를 따라가지 못해도 유입 쓰기의 속도를 조절하지 않으므로 이런 상황을 감지하기 위한 명시적 모니터링이 필요하다.&lt;/p>
&lt;hr>
&lt;p>B 트리의 장점은 &lt;strong>각 키가 색인의 한 곳에만 정확하게 존재한다는 점&lt;/strong>이다. 하지만 로그 구조화 저장소 엔진은 다른 세그먼트에 같은 키의 다중 복사본이 존재할 수 있다.&lt;/p>
&lt;p>이런 측면 때문에 강력한 트랜잭션 시맨틱(semantic)를 제공하는 데이터베이스에는 B 트리가 훨씬 매력적이다.&lt;/p>
&lt;ul>
&lt;li>많은 관계형 데이터베이스에서 트랜잭션 격리(transactional isolation)는 키 범위의 잠금을 사용해 구현한 반면 B 트리 색인에서는 &lt;strong>트리에 직접 잠금을 포함&lt;/strong>시킴&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>B 트리는 데이터베이스 아키텍처에 아주 깊게 뿌리내렸고, 많은 작업부하에 대해 지속적으로 좋은 성능을 제공하므로 금방 사라질 가능성은 거의 없으며, 새로운 데이터 저장소에서는 로그 구조화 색인이 점점 인기를 얻고 있다.&lt;/p>
&lt;p>사용 사례에 적합한 저장소 엔진의 유형을 결정하기 위한 빠르고 쉬운 규칙은 없기 때문에 테스트를 통해 경험적으로 결정하는 방법도 나쁘지 않다.&lt;/p>
&lt;h2 id="기타-색인-구조">기타 색인 구조&lt;/h2>
&lt;p>지금까지는 키-값 색인을 살펴봤다.&lt;/p>
&lt;p>대표적인 기-값 색인 예시는 관계형 모델의 &lt;strong>기본키(primary-key)&lt;/strong> 색인이다.&lt;/p>
&lt;ul>
&lt;li>기본키로 관계형 테이블에서 하나의 로우를, 문서 데이터베이스에서 하나의 문서를, 그래프 데이터베이스에서 하나의 정점을 고유하게 식별&lt;/li>
&lt;li>데이터베이스에서 다른 레코드는 기본키로 로우/문서/정점을 참조할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>보조 색인(secondary index)&lt;/strong> 을 사용하는 방식도 매우 일반적이다.&lt;/p>
&lt;ul>
&lt;li>관계형 데이터베이스에서 &lt;code>CREATE INDEX&lt;/code> 명령을 통해 보조 색인을 생성할 수 있음&lt;/li>
&lt;li>보조 색인은 보통 효율적인 조인을 수행하는 데 결정적인 역할을 함&lt;/li>
&lt;/ul>
&lt;p>보조 색인은 키-값 색인에서 쉽게 생성할 수 있는데, 기본키 색인과의 주요 차이점은 키가 고유하지 않다는 점이다.&lt;/p>
&lt;ul>
&lt;li>같은 키를 가진 많은 로우(문서, 정점)이 있을 수 있음&lt;/li>
&lt;/ul>
&lt;p>이 점은 두 가지 방법으로 개선될 수 있다.&lt;/p>
&lt;ul>
&lt;li>색인의 각 값에 일치하는 로우 식별자 목록을 만들기&lt;/li>
&lt;li>로우 식별자를 추가해 각 키를 고유하게 만들기&lt;/li>
&lt;/ul>
&lt;p>어느 쪽이든 보조 색인으로 B 트리와 로그 구조화 색인 둘 다 사용할 수 있다.&lt;/p>
&lt;h3 id="색인-안에-값-저장하기">색인 안에 값 저장하기&lt;/h3>
&lt;p>색인에서 키는 질의가 검색하는 대상이지만, 값은 다음의 두 가지 중 하나에 해당한다.&lt;/p>
&lt;ul>
&lt;li>질문의 실제 로우&lt;/li>
&lt;li>다른 곳에 저장된 로우를 가르키는 참조&lt;/li>
&lt;/ul>
&lt;p>후자의 경우 로우가 저장된 곳을 &lt;strong>힙 파일&lt;/strong>(heap file)이라 하고 특정 순서 없이 데이터를 저장함&lt;/p>
&lt;p>힙 파일 접근은 여러 보조 색인이 존재할 때 데이터 중복을 피할 수 있기 때문에 일반적인 방식이다.&lt;/p>
&lt;ul>
&lt;li>각 색인은 힙 파일에서 위치만 참조하고 실제 데이터는 일정한 곳에 유지함&lt;/li>
&lt;/ul>
&lt;p>힙 파일 접근 방식은 키를 변경하지 않고 값을 갱신할 때 꽤 효율적이다.&lt;/p>
&lt;ul>
&lt;li>새로운 값이 이전 값보다 많은 공간을 필요로 하지 않으면 레코드를 제자리에 덮어쓸 수 있음&lt;/li>
&lt;/ul>
&lt;p>하지만 새로운 값이 많은 공간을 필요로 한다면 힙에서 충분한 공간이 있는 새로운 곳으로 위치를 이동해야한다.&lt;/p>
&lt;ul>
&lt;li>이러한 경우 모든 색인이 레코드의 새로운 힙 위치를 가르키게끔 갱신하거나 이전 힙 위치에 전방향 포인터를 남겨야함&lt;/li>
&lt;/ul>
&lt;p>색인에서 힙 파일로 다시 이동하는 일은 읽기 성능에 불이익이 너무 많기 때문에, 어떤 상황에서는 색인 안에 바로 색인된 로우를 저장하는 편이 바람직 할 수 있다.&lt;/p>
&lt;p>이를 &lt;strong>클러스터드 색인&lt;/strong>(clustered index)라고 하며, MySQL의 InnoDB 저장소 엔진에서는 테이블의 기본키가 언제가 클러스터드 색인이고 보조 색인은 (힙 파일의 위치가 아닌) 기본키를 참조한다.&lt;/p>
&lt;p>클러스터드 색인과 비 클러스터드 색인 사이의 절충안을 커버링 색인(covering index)이나 포괄열이 있는 색인(index with included column)이라 한다.&lt;/p>
&lt;ul>
&lt;li>색인 안에 테이블의 컬럼 일부를 저장&lt;/li>
&lt;li>색인만 사용해 일부 질의에 응답이 가능함(색인이 질의를 커버했다고 말함)&lt;/li>
&lt;/ul>
&lt;p>모든 종류의 데이터 복제와 마찬가지로 클러스터드 색인과 커버링 색인은 읽기 성능을 높일 수 있지만 추가적인 저장소가 필요하고 쓰기 과정에 오버헤드가 발생한다.&lt;/p>
&lt;p>또한 애플리케이션 단에서 복제로 인한 불일치를 파악할 수 없기 때문에 데이터베이스는 트랜잭션 보장을 강화하기 위해 별도의 노력이 필요하다.&lt;/p>
&lt;h3 id="다중-컬럼-색인">다중 컬럼 색인&lt;/h3>
&lt;p>지금까지 설명한 색인은 하나의 키만 값에 대응하므로 테이블의 다중 컬럼에 동시에 질의를 해야한다면 충분하지 않다.&lt;/p>
&lt;p>다중 컬럼 색인의 가장 일반적인 유형은 &lt;strong>결합 색인&lt;/strong>(concatenated index)이라고 한다.&lt;/p>
&lt;ul>
&lt;li>하나의 컬럼에 다른 컬럼을 추가하는 방식으로 하나의 키에 여러 필드를 단순히 결합&lt;/li>
&lt;li>필드가 결합하는 순서는 색인 정의에 명시&lt;/li>
&lt;/ul>
&lt;p>이 방법은 &lt;code>(성, 이름)&lt;/code>을 키로 전화번호 값으로 하는 색인을 제공하는 전화번호부와 유사하다.&lt;/p>
&lt;ul>
&lt;li>순서가 정렬돼 있으므로 특정 성을 가진 모든 사람, 특정 성 이름 조합을 가진 모든 사람을 찾을 때도 이 색인을 활용할 수 있음&lt;/li>
&lt;li>하지만 특정 이름을 가진 모든 사람을 찾을 때는 쓸모 없음&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>다차원 색인은 한 번에 여러 컬럼에 질의하는 조금 더 일반적인 방법이다.&lt;/p>
&lt;ul>
&lt;li>지리 공간 데이터 등&lt;/li>
&lt;/ul>
&lt;p>레스토랑 검색 웹 사이트에 각 레스토랑의 위도와 경도를 포함한 데이터베이스가 있다고 가정하면, 사용자가 지도에서 레스토랑을 찾을 때 웹 사이트는 사용자가 현재 보는 네모단 지도 영역 내 모든 레스토랑을 찾아야 하므로 다음과 같은 이차원 범위 질의가 필요하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">restaurants&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">latitude&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">51&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">4946&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">latitude&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">51&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">5079&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">longitude&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">1162&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">longitude&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">1004&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>표준 B 트리나 LSM 트리 색인은 이런 유형의 질의에 효율적으로 응답할 수 없다.&lt;/p>
&lt;ul>
&lt;li>위도 범위 안의 모든 레스토랑이나 경도 범위 안의 모든 레스토랑을 줄 수는 있지만 둘을 동시에 주진 못함&lt;/li>
&lt;/ul>
&lt;p>한 가지 방법은 이차원 위치를 공간 채움 곡선(space-filling curve)을 이용해 단일 숫자로 변환한 다음 일반 B 트리 색인을 사용하는 것이다.&lt;br>
좀 더 일반적인 방법은 R 트리처럼 전문 공간 색인(specialized spatial index)을 사용하는 것이다.&lt;/p>
&lt;p>다차원 색인의 활용은 지리학적인 위치에만 국한되지 않는다.&lt;/p>
&lt;ul>
&lt;li>색상(RGB), 날씨(날짜, 기온)&lt;/li>
&lt;/ul>
&lt;h3 id="전문-검색과-퍼지-색인">전문 검색과 퍼지 색인&lt;/h3>
&lt;p>지금까지 설명한 모든 색인은 정확한 데이터를 대상으로 키의 정확한 값이나 정렬된 키의 값의 범위를 질의할 수 있다고 가정하므로, 철자가 틀린 단어와 같이 &lt;strong>유사한&lt;/strong> 키에 대해서는 검색 할 수 없다.&lt;/p>
&lt;p>이처럼 &lt;strong>애매모호한&lt;/strong>(fuzzy) 질의에는 다른 기술이 필요하다.&lt;/p>
&lt;hr>
&lt;p>전문 검색 엔진은 일반적으로 특정 단어를 검색할 때 해당 단어의 동의어로 질의를 확장한다.&lt;/p>
&lt;p>그리고 단어의 문법적 활용을 무시하고 동일한 문서에서 서로 인접해 나타난 단어를 검색하거나 언어학적으로 텍스트를 분석해 사용하는 등 다양한 기능을 제공한다.&lt;/p>
&lt;p>아파치 루씬은 문서나 질의의 오타에 대처하기 위해 특정 편집 거리(edit distance) 내 단어를 검색할 수 있다.&lt;/p>
&lt;ul>
&lt;li>편집 거리 1은 한 글자가 추가되거나 삭제되거나 교체됐음을 의미&lt;/li>
&lt;/ul>
&lt;p>루씬은 용어 사전을 위해 SS테이블 같은 구조를 사용한다. 이 구조는 작은 인메모리 색인이 필요하며, 이 색인은 키를 찾는데 필요한 정렬 파일의 오프셋을 질의에 알려주는 데 사용한다.&lt;/p>
&lt;p>레벨DB에서 이 인메로리 색인은 일부 키의 희소 컬렉션이지만, 루씬에서 인메모리 색인은 여러 키 내 문자에 대한 &lt;strong>유한 상태 오토마톤&lt;/strong>(finite state automaton)으로 &lt;strong>트라이&lt;/strong>(trie)와 유사하다.&lt;/p>
&lt;ul>
&lt;li>이 오토마톤은 &lt;strong>레벤슈타인 오토마톤&lt;/strong>(levenshtein automaton)으로 변환할 수 있다.&lt;/li>
&lt;li>특정 편집 거리 내에서 효율적인 단어 검색을 제공&lt;/li>
&lt;/ul>
&lt;p>그 밖의 퍼지 검색 기술은 문서 분류 및 머신러닝의 방향으로 진행되고 있다.&lt;/p>
&lt;h3 id="모든-것을-메모리에-보관">모든 것을 메모리에 보관&lt;/h3>
&lt;p>지금까지 설명한 데이터 구조는 모두 디스크 한계에 대한 해결책 이었다.&lt;/p>
&lt;p>디스크는 메인 메모리와 비교해 대루기 어렵다.&lt;/p>
&lt;ul>
&lt;li>자기 디스크와 SSD를 사용할 때 읽기와 쓰기에서 좋은 성능을 원한다면 주의해서 데이터를 디스크에 배치해야 함&lt;/li>
&lt;/ul>
&lt;p>이런 불편함을 참을 수 있는 이유는 디스크의 장점 때문이다.&lt;/p>
&lt;ul>
&lt;li>지속성: 디스크 내용은 전원이 꺼져도 손실되지 않음&lt;/li>
&lt;li>가격: 램보다 훨씬 더 저렴&lt;/li>
&lt;/ul>
&lt;p>하지만 과거에 비해 메인 메모리의 가격이 매우 저렴해졌고, 데이터셋의 대부분은 그다지 크지 않기 때문에 &lt;strong>메모리에 전체를 보관하는 방식&lt;/strong>도 고려할 수 있게 되었으며, 이러한 이유로 &lt;strong>인메모리 데이터베이스&lt;/strong>가 개발되었다.&lt;/p>
&lt;hr>
&lt;p>맴캐시드 같은 일부 인베모리 키-값 저장소는 장비가 재시작되면 데이터 손실을 허용하는 캐시 용도로만 활용되었으나, 다른 인메모리 데이터베이스는 지속성을 목표로 한다.&lt;/p>
&lt;ul>
&lt;li>배터리 전원 공급 RAM 같은 특수 하드웨어 사용&lt;/li>
&lt;li>디스크에 변경 사항의 로그를 기록&lt;/li>
&lt;li>디스크에 주기적인 스냅숏 기록&lt;/li>
&lt;li>다른 장비에 인메모리 상태를 복제&lt;/li>
&lt;/ul>
&lt;p>인메모리 데이터베이스가 재시작 되는 경우 디스크나 네트워크를 통해 복제본에서 상태를 다시 적재해야 한다.&lt;/p>
&lt;p>디스크는 전적으로 지속성을 위한 추가 전용 로그로 사용되고, 읽기는 전적으로 메모리에서 제공되기 때문에 디스크에 기록하더라도 여전히 인메모리 데이터베이스이다.&lt;/p>
&lt;hr>
&lt;p>직관에 어긋나지만 인메모리 데이터베이스의 &lt;strong>성능 강점은 디스크에서 읽지 않아도 된다는 사실 때문은 아니다.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>디스크 기반 저장소 엔진도 운영체제가 최근에 사용한 디스크 블록을 메모리에 캐시하기 때문에 충분한 메모리를 가진 경우에는 디스크에서 읽을 필요 없음&lt;/li>
&lt;li>오히려 인메모리 데이터 구조를 디스크에 기록하기 위한 형태로 부호화하는 오버헤드를 피할 수 있어 더 빠를 수도 있음&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>성능 외에도 인메모리 데이터베이스는 또 다른 재미있는 영역으로서 디스크 기반 색인으로 구현하기 어려운 데이터 모델을 제공한다.&lt;/p>
&lt;ul>
&lt;li>레디스
&lt;ul>
&lt;li>우선순위 큐와 셋 같은 다양한 데이터 구조를 데이터베이스 같은 인터페이스로 제공&lt;/li>
&lt;li>메모리에 모든 데이터를 유지하기 때문에 고현이 비교적 간단&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>최근 연구에 따르면 인메모리 데이터베이스 아키텍처가 디스크 중심 아키텍처에서 발생하는 오버헤드 없이 가용한 메모리보다 더 큰 데이터셋을 지원하게끔 확장할 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>안티 캐싱(anti-caching)&lt;/strong>&lt;br>
메모리가 충분하지 않을 때 가장 최근에 사용하지 않은 데이터를 메모리에서 디스크로 보내고 나중에 다시 접근할 때 메모리에 적재하는 방식으로 동작&lt;/p>
&lt;/blockquote>
&lt;p>운영체제가 가상 메모리와스왑 파일에서 수행하는 방식과 유사하지만 데이터베이스는 전체 메모리 페이지보다 개별 레코드 단위로 작업할 수 있기 때문에 OS보다 효율적으로 메모리를 관리할 수 있다.&lt;/p>
&lt;p>하지만 이 접근 방식은 여전히 전체 색인이 메모리에 있어야 한다.&lt;/p></description></item><item><title>전략적 설계: 비즈니스 도메인 분석하기</title><link>https://codemario318.github.io/post/learning-domain-driven-design/1/</link><pubDate>Thu, 27 Feb 2025 09:54:49 +0900</pubDate><guid>https://codemario318.github.io/post/learning-domain-driven-design/1/</guid><description>&lt;img src="https://codemario318.github.io/post/learning-domain-driven-design/1/cover.png" alt="Featured image of post 전략적 설계: 비즈니스 도메인 분석하기" />&lt;p>도메인 주도 설계 방법론(Domain-Driven Design: DDD)은 크게 두 가지 주요 부분으로 나눌 수 있다.&lt;/p>
&lt;ul>
&lt;li>전략적 설계
&lt;ul>
&lt;li>&lt;strong>What&lt;/strong>과 &lt;strong>Why&lt;/strong> 질문에 대한 답을 찾는 것&lt;/li>
&lt;li>어떤 소프트웨어를 만드는지, 왜 그 소프트웨어를 만드는지에 대한 해답을 찾는 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>전술적 설계
&lt;ul>
&lt;li>&lt;strong>How&lt;/strong> 라는 방법에 대한 것&lt;/li>
&lt;li>소프트웨어 각각의 구성 요소가 구현되는 방법을 찾는 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이번 장에서는 &lt;strong>기업이 존재하는 이유&lt;/strong>와 &lt;strong>추구하는 목표&lt;/strong>가 무엇이며, 그 &lt;strong>목표를 달성하기 위한 전략&lt;/strong>을 논의한다.&lt;/p>
&lt;p>효과적인 솔루션을 설계하고 구축하기 위해서는 그것의 &lt;strong>바탕이 되는 문제&lt;/strong>를 이해해야 하고, 해결하고자 하는 문제를 이해하려면 그것이 &lt;strong>존재하는 맥락&lt;/strong>을 이해해야햔다.&lt;/p>
&lt;blockquote>
&lt;p>즉, 그 조직의 비즈니스 전략과 소프트웨어를 만들면서 얻고자 하는 가치를 이해해야 한다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="비즈니스-도메인이란">비즈니스 도메인이란?&lt;/h2>
&lt;p>비즈니스 도메인은 &lt;strong>기업의 주요 활동 영역을 정의&lt;/strong>한다. (회사가 고객에게 제공하는 서비스)&lt;/p>
&lt;ul>
&lt;li>페덱스: 배송 서비스&lt;/li>
&lt;li>스타벅스: 커피&lt;/li>
&lt;li>월마트: 소매업체&lt;/li>
&lt;/ul>
&lt;p>기업은 &lt;strong>여러 비즈니스 도메인&lt;/strong>을 운영할 수 있으며, 비즈니스 도메인을 자주 변경할 수 있다는 점도 주목해야한다.&lt;/p>
&lt;h2 id="하위-도메인">하위 도메인&lt;/h2>
&lt;p>기업은 비즈니스 도메인의 목표를 달성하기 위해 여러가지 &lt;strong>하위 도메인&lt;/strong>(subdomain)을 운영해야한다.&lt;/p>
&lt;p>하위 도메인은 &lt;strong>비즈니스 활동의 세분화된 영역&lt;/strong>으로 전체 시스템의 하나의 구성요소로, 각각의 하위 도메인은 회사의 비즈니스 도메인에서 목표를 달성하기 위해 서로 상호작용해야 한다.&lt;/p>
&lt;ul>
&lt;li>스타벅스
&lt;ul>
&lt;li>훌륭한 커피&lt;/li>
&lt;li>좋은 위치의 부동산&lt;/li>
&lt;li>직원 관리&lt;/li>
&lt;li>재정 관리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>하위 도메인 중 어느 것도 자체적으로 수익을 낼 수 없기 때문에, 회사가 비즈니스 도메인에서 경쟁하려면 이 모든 것이 함께 필요하다.&lt;/p>
&lt;h3 id="하위-도메인의-유형">하위 도메인의 유형&lt;/h3>
&lt;p>하위 도메인은 서로 다른 전략적 비즈니스 가치를 가진다.&lt;/p>
&lt;p>도메인 주도 설계에서 하위 도메인은 &lt;strong>핵심&lt;/strong>, &lt;strong>일반&lt;/strong>, &lt;strong>지원&lt;/strong> 세가지 유형으로 구분한다.&lt;/p>
&lt;h4 id="핵심-하위-도메인">핵심 하위 도메인&lt;/h4>
&lt;p>핵심 하위 도메인(core subdomain)은 &lt;strong>회사가 경쟁업체와 다르게 수행하고 있는 것&lt;/strong>을 의미한다.&lt;/p>
&lt;ul>
&lt;li>새로운 재품이나 서비스&lt;/li>
&lt;li>기존 프로세스를 최적화하여 비용을 줄이는 것 등&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>우버: 승차 공유 서비스&lt;/li>
&lt;li>구글: 검색 순위 알고리즘
&lt;ul>
&lt;li>구글 애즈는 많은 수익을 내는 하위 도메인에 있는 별도의 비즈니스 도메인&lt;/li>
&lt;li>검색 엔진을 통해 트래픽을 유도함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>&lt;strong>복잡성&lt;/strong>&lt;/p>
&lt;p>누구나 구현할 수 있는 핵심 하위 도메인은 일시적인 경쟁 우위만 제공하므로, 핵심 하위 도메인은 자연스럽게 복잡해진다.&lt;/p>
&lt;p>회사의 핵심 비즈니스는 &lt;strong>높은 진입장벽&lt;/strong>이 있어야 경쟁력을 유지할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>경쟁 우위의 원천&lt;/strong>&lt;/p>
&lt;p>핵심 하위 도메인에 반드시 기술이 들어가야하는 것은 아니며, 회사의 경쟁 우위는 다양한 원천에서 나올 수 있다.&lt;/p>
&lt;ul>
&lt;li>모든 비즈니스 문제가 알고리즘이나 기술 솔루션으로 해결되지 않음&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>온라인으로 제품을 판매하는 보석 제조 업체: 보석의 디자인이 회사의 경쟁력&lt;/li>
&lt;li>수동 사기 탐지를 전문으로 하는 회사: 분석가가 수행하는 작업&lt;/li>
&lt;/ol>
&lt;h4 id="일반-하위-도메인">일반 하위 도메인&lt;/h4>
&lt;p>일반 하위 도메인(generic subdomain)은 &lt;strong>모든 회사가 같은 방식으로 수행하는 비즈니스 활동&lt;/strong>을 말한다.&lt;/p>
&lt;p>핵심 하위 도메인 처럼 복잡하고 구현하기 어려우나, 회사에 경쟁력을 제공하지 않는다.&lt;/p>
&lt;ul>
&lt;li>이미 실무에서 검증된 솔루션으로 널리 이용 가능&lt;/li>
&lt;li>모든 회사에서 사용하고 있어 더 이상 혁신이나 최적화가 필요 없음&lt;/li>
&lt;/ul>
&lt;p>대표 적인 예시로 아래와 같은 것 들이 있다:&lt;/p>
&lt;ul>
&lt;li>사용자 인증 및 권한 부여 등&lt;/li>
&lt;li>온라인으로 제품을 판매하는 보석 제조 업체의 온라인 소핑몰 자체&lt;/li>
&lt;/ul>
&lt;h4 id="지원-하위-도메인">지원 하위 도메인&lt;/h4>
&lt;p>지원 하위 도메인(supporting subdomain)은 &lt;strong>회사의 비즈니스를 지원하는 활동&lt;/strong>을 말하며, 핵심 하위 도메인과 달리 어떠한 경쟁 우위도 제공하지 않는다.&lt;/p>
&lt;p>지원 하위 도메인은 대부분 비즈니스 로직이 간단하다.&lt;/p>
&lt;ul>
&lt;li>데이터 입력 화면과 ETL(extract, transform, load)&lt;/li>
&lt;li>CRUD 인터페이스&lt;/li>
&lt;/ul>
&lt;p>회사에 어떠한 경쟁 우위도 제공하지 않으므로 높은 진입장벽이 필요하지 않다.&lt;/p>
&lt;h3 id="하위-도메인-비교">하위 도메인 비교&lt;/h3>
&lt;p>다른 각도에서 차이점을 살펴보고, 전략적인 소프트웨어 설계 의사결정에 미치는 영향을 살펴본다.&lt;/p>
&lt;h4 id="경쟁-우위">경쟁 우위&lt;/h4>
&lt;ul>
&lt;li>핵심 하위 도메인: 경쟁 우위 제공
&lt;ul>
&lt;li>경쟁사와 차별화하기 위한 회사의 전략&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>일반 하위 도메인: 경쟁 우위의 원천이 될 수는 없음
&lt;ul>
&lt;li>일반적인 솔루션&lt;/li>
&lt;li>경쟁 업체가 동일한 솔루션을 활용하므로 경쟁 우위를 제공할 수 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지원 하위 도메인: 진입 장벽이 낮으며, 경쟁 우위도 제공할 수 없음
&lt;ul>
&lt;li>경쟁력에 영향을 주지 않음&lt;/li>
&lt;li>일반적인 솔루션을 사용하는 것을 선호&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>회사가 해결할 수 있는 문제가 더 복잡할수록 더 많은 비즈니스 가치를 제공할 수 있지만, 복잡한 문제는 소비자에게 서비스를 제공하는 것에 국한되지는 않는다.&lt;/p>
&lt;ul>
&lt;li>비즈니스 최적화는 낮은 운영 비용으로 경쟁 우위를 얻을 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="복잡성">복잡성&lt;/h4>
&lt;p>조금 더 기술적인 관점에서 하위 도메인의 유형에 따라 복잡성의 수준이 다르고, 소프트웨어를 설계할 때 비즈니스 요구사항의 복잡성을 수용할 수 있는 도구와 기술을 선택해야하므로, &lt;strong>견고한 소프트웨어 솔루션을 설계&lt;/strong>하기 위해 하위 도메인을 식별하는 것이 반드시 필요하다.&lt;/p>
&lt;ul>
&lt;li>지원 하위 도메인: 일반적으로 비즈니스 로직이 매우 간단
&lt;ul>
&lt;li>기본적인 ETL 작업과, CRUD 인터페이스&lt;/li>
&lt;li>입력의 유효성 검증 또는 다른 구조의 데이터로 변환하는 정도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>일반하위 도메인: 훨씬 더 복잡
&lt;ul>
&lt;li>지식 가용성 관점에서 &amp;lsquo;알려진 미지&amp;rsquo;에 해당(모른 다는 사실을 알고있음)&lt;/li>
&lt;li>지식 자체는 쉽게 구할 수 있음&lt;/li>
&lt;li>업계에서 인정하는 모범 사례를 사용하거나 전문 컨설턴트를 고용하여 맞춤형 솔루션을 설계할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>핵심 하위 도메인: 복잡함
&lt;ul>
&lt;li>회사의 수익성이 좌우되므로 경쟁업체가 최대한 모방하기 어려워야함&lt;/li>
&lt;li>전략적으로 핵심 하위 도메인으로 복잡한 문제를 해결하려고함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 특성으로 &lt;strong>복잡성&lt;/strong>은 하위 도메인을 구별하는 기준으로 활용될 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/learning-domain-driven-design/1/img.png"
width="728"
height="455"
srcset="https://codemario318.github.io/post/learning-domain-driven-design/1/img_hu4f32797cb34ef597bfcf264f2fe48bcc_65622_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/learning-domain-driven-design/1/img_hu4f32797cb34ef597bfcf264f2fe48bcc_65622_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="세 가지 유형의 하위 도메인의 비즈니스 차별화 및 비즈니스 로직 복잡성"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="384px"
>&lt;/p>
&lt;ul>
&lt;li>하위 도메인을 부업으로 전환할 수 있는가? -&amp;gt; 핵심 하위 도메인&lt;/li>
&lt;li>외부 솔루션을 연동하는 것 보다 자체 솔루션을 구현하는 것이 더 간단하고 저렴한가? -&amp;gt; 지원 하위 도메인&lt;/li>
&lt;/ul>
&lt;p>또 다른 방법으로 &lt;strong>코드로 구현해야 하는 비즈니스 로직의 복잡성&lt;/strong>을 기준으로 삼을 수 있다.&lt;/p>
&lt;ul>
&lt;li>데이터 입력을 위한 CRUD 인터페이스와 유사한가? -&amp;gt; 지원 하위 도메인&lt;/li>
&lt;li>복잡한 알고리즘 또는 비즈니스 프로세스 규칙과 변하지 않는 속성에 의해 조정되는 비즈니스 프로세스를 구현해야 하는가? -&amp;gt; 핵심 하위 도메인&lt;/li>
&lt;li>기능 자체를 구현하기보다 일반적인 솔루션을 연동하는 편이 더 간단하거나 저렴한가? -&amp;gt; 일반 하위 도메인&lt;/li>
&lt;li>자체 구현이 더 간단하고 저렴한가? -&amp;gt; 지원 하위 도메인&lt;/li>
&lt;/ul>
&lt;h4 id="변동성">변동성&lt;/h4>
&lt;ul>
&lt;li>핵심 하위 도메인: 자주 변경될 수 있다.
&lt;ul>
&lt;li>한 번의 시도로 문제가 해결될 수 있다면 경쟁자들도 빠르게 따라잡을 수 있기 때문에 경쟁 우위에서 좋은 위치는 아닐 것&lt;/li>
&lt;li>다양한 구현 방법을 시도하고 개선하고 최적해야 핵심 하위 도메인에 대한 솔루션을 찾을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지원 하위 도메인: 자주 변경되지 않는다.
&lt;ul>
&lt;li>어떠한 경쟁 우위를 제공하지 않기 때문에 투자한 노력에 비해 아주 작은 비즈니스 가치를 제공&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>일반 하위 도메인: 시간이 지남에 따라 변경될 수 있다.
&lt;ul>
&lt;li>보안 패치, 버그 수정&lt;/li>
&lt;li>일반적인 문제에 대한 새로운 솔루션으로 대체&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="솔루션-전략">솔루션 전략&lt;/h4>
&lt;p>하위 도메인은 기본적인 구성요소이므로 하나를 제거하면 전체 구조가 무너질 수 있다.&lt;/p>
&lt;p>하위 도메인 가각의 고유한 속성을 활용하면 서로 다른 유형의 하위 도메인을 구현하기 위한 가장 효율적인 전략을 선택할 수 있다.&lt;/p>
&lt;ul>
&lt;li>핵심 하위 도메인: 사내에서 구현되어야 한다.
&lt;ul>
&lt;li>솔루션을 구매하거나 외부에서 도입 가능한 경우 경쟁업체들이 똑같이 할 수 있기 때문에 우위 개념을 약화시킨다.&lt;/li>
&lt;li>핵심 하위 도메인 구현은 전략적인 투자이므로 하청은 현명하지 않다.&lt;/li>
&lt;li>절차를 무시하고 대충 진행하는 것은 위험하며 장기적으로 치명적이다.
&lt;ul>
&lt;li>유지보수가 불가능한 코드는 회사의 목표를 지원할 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>조직의 가장 숙련된 인재는 핵심 하위 도메인에서 일하도록 업무가 할당되어야 한다.&lt;/li>
&lt;li>사내에서 핵심 하위 도메인을 개발하면 더 빠르게 변경하고 발전시킬 수 있기 때문에 더 짧은 시간에 경쟁 우위를 갖출 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>핵심 하위 도메인의 요구사항은 자주, 지속적으로 변경될 것으로 예사오디므로 솔루션은 유지보수가 가능하고 쉽게 개선될 수 있어야 한다. 따라서 핵심 하위 도메인은 가장 진보된 엔지니어링 기술로 구현해야한다.&lt;/p>
&lt;ul>
&lt;li>일반 하위 도메인: 어렵지만 이미 문제가 해결된 것들
&lt;ul>
&lt;li>사내에서 구현하는 데 시간과 노력을 투자하는 것 보다 이미 만들어진 제품을 구입하거나 오픈소스 솔루션을 채택하는 것이 비용 면에서 더 효율적&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지원 하위 도메인: 경쟁 우위가 없음
&lt;ul>
&lt;li>사내에서 지원 하위 도메인을 구현하지 않는 것이 합리적&lt;/li>
&lt;li>일반 하위 도메인과 달리 솔루션이 없는 경우가 있고, 이러한 경우 직접 구현&lt;/li>
&lt;li>비즈니스 로직이 단순하고 변경의 빈도가 적기 때문에 원칙을 생략하고 적당히 진행하기 쉬움&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>지원 하위 도메인에는 정교한 디자인 패턴이나 고급 엔지니어링 기술이 필요 없다. 인력 관점에서도 고도로 숙련된 기술이 필요하지 않기 때문에 새로운 인재를 양성할 수 있는 좋은 연습 기회를 제공한다.&lt;/p>
&lt;hr>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>하위 도메인 유형&lt;/th>
&lt;th>경쟁 우위&lt;/th>
&lt;th>복잡성&lt;/th>
&lt;th>변동성&lt;/th>
&lt;th>구현 방식&lt;/th>
&lt;th>문제&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>핵심&lt;/td>
&lt;td>예&lt;/td>
&lt;td>높음&lt;/td>
&lt;td>높음&lt;/td>
&lt;td>사내 개발&lt;/td>
&lt;td>흥미로움&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>일반&lt;/td>
&lt;td>아니오&lt;/td>
&lt;td>높음&lt;/td>
&lt;td>낮음&lt;/td>
&lt;td>구매/도입&lt;/td>
&lt;td>해결됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>지원&lt;/td>
&lt;td>아니오&lt;/td>
&lt;td>낮음&lt;/td>
&lt;td>낮음&lt;/td>
&lt;td>사내 가발/하청&lt;/td>
&lt;td>뻔함&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="하위-도메인-경계-식별">하위 도메인 경계 식별&lt;/h3>
&lt;p>하위 도메인과 해당 유형으로 식별하면 설계와 관련된 의사결정에 상당한 도움이 된다.&lt;/p>
&lt;p>하위 도메인과 그 유형은 &lt;strong>기업의 비즈니스 전략&lt;/strong>에 따라 정의되며, 이를 동일한 분야에서 다른 회사와 경쟁하기 위해 자신을 차별화하는 방법으로 대다수의 소프트웨어 프로젝트에서 하위 도메인은 어떤 식으로든 &lt;strong>이미 존재&lt;/strong>한다. 이미 존재하는 하위 도메인을 식별하고 분류하려면 도메인 분석을 직접 수행해야 한다.&lt;/p>
&lt;p>회사의 부서와 기타 조직 단위는 좋은 출발점이다.&lt;/p>
&lt;h4 id="하위-도메인-정제">하위 도메인 정제&lt;/h4>
&lt;p>하위 도메인을 식별하기 위한 문제는 세부사항에 있으므로 비즈니스 기능의 복잡한 내용에 숨겨진 중요한 정보를 놓치지 말아야한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/learning-domain-driven-design/1/img_1.png"
width="729"
height="308"
srcset="https://codemario318.github.io/post/learning-domain-driven-design/1/img_1_hu9e5571290e517d4dbda2cbea95316a6f_128302_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/learning-domain-driven-design/1/img_1_hu9e5571290e517d4dbda2cbea95316a6f_128302_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="내부 업부를 분석하여 세분하된 하위 도메인으로 나눈 결과"
class="gallery-image"
data-flex-grow="236"
data-flex-basis="568px"
>&lt;/p>
&lt;ul>
&lt;li>고객 서비스 부서
&lt;ul>
&lt;li>헬프데스크 시스템: 일반 하위 도메인&lt;/li>
&lt;li>교대 근무 관리 및 일정: 지원 하위 도메인&lt;/li>
&lt;li>전화 시스템: 일반 하위 도메인&lt;/li>
&lt;li>상담 사례 라우팅: 핵심 하위 도메인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>과거 비슷한 상담 사례를 성공적으로 처리한 상담원에게 상담을 전달할 수 있는 알고리즘은 데이터를 분석하여 알고리즘을 설계해야하고, 경쟁업체보다 더 나은 고객 서비스를 제공할 수 있게 하므로 핵심 하위 도메인으로 볼 수 있다.&lt;/p>
&lt;h4 id="응집된-유스케이스를-하위-도메인으로">응집된 유스케이스를 하위 도메인으로&lt;/h4>
&lt;p>기술적 관점에서 하위 도메인은 상호 연관되고 응집된 유스케이스의 집합과 유사하다.&lt;/p>
&lt;ul>
&lt;li>유스케이스 집합
&lt;ul>
&lt;li>동일한 행위자(actor)&lt;/li>
&lt;li>비즈니스 엔티티(business entity)&lt;/li>
&lt;li>두 요소 모두 밀접하게 관련된 데이터의 집합을 다룸&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>세분화된 하위 도메인을 찾는 것을 중단하는 시점을 결장하기 위한 지침으로 &lt;strong>응집된 유스케이스의 집합인 하위 도메인&lt;/strong>이라는 정의를 사용할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/learning-domain-driven-design/1/img_2.png"
width="727"
height="360"
srcset="https://codemario318.github.io/post/learning-domain-driven-design/1/img_2_hu41f77d34d0ad981d442dc552154bd7d7_190213_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/learning-domain-driven-design/1/img_2_hu41f77d34d0ad981d442dc552154bd7d7_190213_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="신용카드 결제 하위 도메인의 유스케이스 다이어그램"
class="gallery-image"
data-flex-grow="201"
data-flex-basis="484px"
>&lt;/p>
&lt;p>위 유스케이스는 작업 중인 데이터 및 관련된 행위자와 밀접한 연관이 있으므로, 모든 유스케이스는 신용카드 결제 하위 도메인을 형성한다.&lt;/p>
&lt;p>핵심 하위 도메인은 가장 중요하고 변동성이 있고 복잡하므로, 경계를 식별하기 위해 큰 노력을 기울여야한다.&lt;/p>
&lt;p>이를 통해 일반 및 지원 기능 모두를 추출하고 훨씬 더 집중하고 있는 기능에 시간을 투자할 수 있게 한다.&lt;/p>
&lt;p>하지만 지원 및 일반 하위 도메인의 경우 이러한 정제 작업을 완화해도 괜찮다.&lt;/p>
&lt;ul>
&lt;li>의사 결정을 내리는 데 도움이 될 수 있는 새로운 통찰이 나오지 않으면 중단하는 것이 좋다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/learning-domain-driven-design/1/img_3.png"
width="726"
height="197"
srcset="https://codemario318.github.io/post/learning-domain-driven-design/1/img_3_hue273eaac2e98d17046a7986b5189cfe7_105476_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/learning-domain-driven-design/1/img_3_hue273eaac2e98d17046a7986b5189cfe7_105476_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="헬프 데스크 시스템의 하위 도메인을 정제해서 일반적인 내부 구성요소를 보여줌"
class="gallery-image"
data-flex-grow="368"
data-flex-basis="884px"
>&lt;/p>
&lt;p>위처럼 헬프 데스크 시스템의 하위 도메인을 추가로 정리한다고 전략적으로 유용한 정보가 나오지 않으므로, 하위 도메인을 크게 나눠서 이미 만들어져 있는 도구를 솔루션으로 사용한다.&lt;/p>
&lt;h4 id="핵심에-집중">핵심에 집중&lt;/h4>
&lt;p>하위 도메인을 식별할 때 하위 도메인이 모두 필요한지 여부를 고려해야한다.&lt;/p>
&lt;p>하위 도메인은 &lt;strong>소프트웨어 설계 의사결정을 내리는 프로세스의 어려움을 쉽게 해결하도록 돕는 도구&lt;/strong>로, 모든 조직에는 경쟁 우위를 제공하기는 하지만 소프트웨어와는 아무 관련이 없는 비즈니스 기능이 많이 존재한다.&lt;/p>
&lt;p>하위 도메인을 찾을 때 소프트웨어와 관련되지 않은 비즈니스 기능을 식별하고, 그 자체로 인정하며, 작업 중인 소프트웨어 시스템과 관련된 비즈니스에 집중하는 것이 중요하다.&lt;/p>
&lt;h2 id="도메인-전문가란">도메인 전문가란?&lt;/h2>
&lt;p>도메인 전문가는 &lt;strong>모델링하고 코드로 구현할 비즈니스의 모든 복잡성을 알고 있는 주제 전문가&lt;/strong>이다.(소프트웨어 비즈니스 도메인에 대한 권위자)&lt;/p>
&lt;p>비즈니스 지식의 근원이 되는 비즈니스 문제를 처음 파악한 사람들로, 시스템 분석가와 엔지니어는 비즈니스 도메인의 &lt;strong>멘탈 모델&lt;/strong>을 소프트웨어 요구사항과 소스코드로 변환한다.&lt;/p>
&lt;p>일반적으로 도메인 전문가는 &lt;strong>요구사항을 제시하는 사람&lt;/strong> 또는 &lt;strong>소프트웨어의 최종 사용자&lt;/strong>이며 소프트웨어는 그들의 문제를 해결해야한다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>비즈니스가 운영되는 영역과 고객에 제공하는 서비스는 모두 비즈니스 도메인과 함께 시작한다.&lt;/p>
&lt;p>비즈니스 도메인에서 성공하고 기업이 경쟁업체와 차별화하는 데 필요한 구성 요소를 확인했다.&lt;/p>
&lt;ul>
&lt;li>핵심 하위 도메인
&lt;ul>
&lt;li>흥미로운 문제들&lt;/li>
&lt;li>기업이 경쟁자로부터 차별화하고 경쟁 우위를 얻는 활동&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>일반 하위 도메인
&lt;ul>
&lt;li>해결된 문제들, 모든 회사가 같은 방식으로 하고 있는 일&lt;/li>
&lt;li>혁신이 필요하지 않음&lt;/li>
&lt;li>직접 개발하기 보다는 기존 솔루션을 사용하는 것이 더 효과적&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지원 하위 도메인
&lt;ul>
&lt;li>분명한 해결책이 있는 문제들&lt;/li>
&lt;li>사내에서 구현해야할 수 있지만 경쟁 우위를 제공하지는 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>도메인 전문가는 비즈니스의 주제 전문가로 회사의 비즈니스 도메인 또는 하나 이상의 하위 도메인에 대한 심층적인 지식을 가지고 있으며 프로젝트 성공에 매우 중요한 역할을 한다.&lt;/p></description></item><item><title>2.3 데이터 모델과 질의 언어 - 그래프형 데이터 모델</title><link>https://codemario318.github.io/post/designing-data-intensive-application/2/3/</link><pubDate>Sun, 16 Feb 2025 15:56:49 +0900</pubDate><guid>https://codemario318.github.io/post/designing-data-intensive-application/2/3/</guid><description>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/3/cover.png" alt="Featured image of post 2.3 데이터 모델과 질의 언어 - 그래프형 데이터 모델" />&lt;h2 id="그래프형-데이터-모델">그래프형 데이터 모델&lt;/h2>
&lt;p>애플리케이션이 주로 일대다 관계(트리 구조 데이터)이거나 레코드 간 관계가 없다면 문서 모델이 적합하다.&lt;/p>
&lt;p>하지만 데이터에서 다대다 관계가 매우 일반적이라면 어떻게 해야 할까? 관게형 모델은 &lt;strong>단순한 다대다 관계&lt;/strong>를 다룰 수 있지만, 데이터 간 연결이 더 복잡해지면 그래프로 데이터를 모델링하기 시작하는 편이 더
자연스럽다.&lt;/p>
&lt;p>그래프는 두 유형의 객체로 이뤄지며 이를 통해 많은 유형의 데이터를 그래프로 모델링할 수 있다.&lt;/p>
&lt;ul>
&lt;li>정점(vertex)(노드, 엔티티)&lt;/li>
&lt;li>간선(edge)(관계, 호(arc))&lt;/li>
&lt;/ul>
&lt;p>일반적인 예는 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>소셜 그래프
&lt;ul>
&lt;li>정점은 사람, 간선은 사람들이 알고 있음을 나타냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 그래프
&lt;ul>
&lt;li>정점은 웹 페이지, 간선은 다른 페이지에 대한 링크&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>도로나 철도 네트워크
&lt;ul>
&lt;li>정점은 교차로, 간선은 도로나 철로&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>하지만 그래프는 정점이 모든 같은 유형인 형식, 동종 데이터에 국한되지 않는다. 그래프를 동종 데이터와 마찬가지 방식으로 사용하면 단일 데이터 저장소에 완전히 다른 유형의 객체를 일관성 있게 저장할 수 있는 강력한
방법을 제공한다.&lt;/p>
&lt;ul>
&lt;li>페이스북
&lt;ul>
&lt;li>정점: 사람, 장소, 이벤트, 체크인, 사용자가 작성한 코멘드 등&lt;/li>
&lt;li>간선:
&lt;ul>
&lt;li>어떤 사람이 서로 친구인지&lt;/li>
&lt;li>어떤 위치에서 체크인이 발생했는지&lt;/li>
&lt;li>누가 어떤 포스트에 코멘트를 했는지&lt;/li>
&lt;li>누가 이벤트에 참여했는지 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="속성-그래프">속성 그래프&lt;/h3>
&lt;p>그래프에서 데이터를 구조화하고 질의하는 몇 가지 다른(하지만 관련된) 방법이 있다.&lt;/p>
&lt;p>속성 그래프 모델에서 각 정점은 다음과 같은 요소로 구성된다.&lt;/p>
&lt;ul>
&lt;li>고유한 식별자&lt;/li>
&lt;li>유출(outgoing) 간선 집합&lt;/li>
&lt;li>유입(incoming) 간선 집합&lt;/li>
&lt;li>속성 컬렉션(키-값 쌍)&lt;/li>
&lt;/ul>
&lt;p>각 간선은 다음과 같은 요소로 구성된다.&lt;/p>
&lt;ul>
&lt;li>고유한 식별자&lt;/li>
&lt;li>간선이 시작하는 정점(꼬리 정점)&lt;/li>
&lt;li>간선이 끝나는 정점(머리 정점)&lt;/li>
&lt;li>두 정점 간 관계 유형을 설명하는 레이블&lt;/li>
&lt;li>속성 컬렉션(키-값 쌍)&lt;/li>
&lt;/ul>
&lt;p>아래와 같이 두 개의 관계형 테이블(하나는 정점, 하나는 간선)로 구성된 그래프 저장소를 생각해보면, 머리와 꼬리 정점은 각 간선마다 저장된다. 따라서 정점을 위한 유입 간선과 유출 간선의 집합이 필요하다면
&lt;code>edges&lt;/code> 테이블에 &lt;code>head_vertex&lt;/code>나 &lt;code>tail_vertex&lt;/code>로 각각 질의할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">json&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">edge_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">REFERENCES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">REFERENCES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">text&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">json&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges_tails&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges_heads&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이 모델의 몇 가지 중요한 면은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>정점은 다른 정점과 간선으로 연결된다.
&lt;ul>
&lt;li>특정 유형과 관련 여부를 제한하는 스키마는 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>정점이 주어지면 정점의 유입과 유출 간선을 효율적으로 찾을 수 있고 그래프를 순회할 수 있다.
&lt;ul>
&lt;li>일련의 정점을 따라 앞뒤 방향으로 순회한다.&lt;/li>
&lt;li>이를 위해 &lt;code>tali_vertex&lt;/code>와 &lt;code>head_vertex&lt;/code> 컬럼에 대해 색인을 생성했다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다른 유형의 관계에 서로 다른 레이블을 사용하면 단일 그래프에 다른 유형의 정보를 저장하면서도 데이터 모델을 깔끔하게 유지할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이러한 기능을 통해 그래프는 데이터 모델링을 위한 많은 유연성을 제공한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img.png"
width="925"
height="564"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_hue7842d50d38e3b2e6ac6ca2ece9154d3_90342_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_hue7842d50d38e3b2e6ac6ca2ece9154d3_90342_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="그래프 구조 데이터"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="393px"
>&lt;/p>
&lt;p>위 그림에서 전통적인 관계형 스키마에서 표현하기 어려운 사례 몇 가지를 살펴볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>국가마다 다른 지역 구조
&lt;ul>
&lt;li>프랑스에서는 주(departement)와 도(region)&lt;/li>
&lt;li>미국에서는 군(country)과 주(state)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위 예시에서 루시와 알랭 또는 그 밖의 사람에 대한 다른 여러 사실을 포함시키기 위해 그래프를 확장해야한다면, 새로운 관심사를 정점으로 만들고 연결하기만 하면 된다.&lt;/p>
&lt;p>그래프는 발전성이 좋아서 애플리케이션에 기능을 추가하는 경우 애플리케이션의 데이터 구조 변경을 수용하게끔 그래프를 쉽게 확장할 수 있다.&lt;/p>
&lt;h3 id="사이퍼-질의-언어">사이퍼 질의 언어&lt;/h3>
&lt;p>사이퍼(Cypher)는 속성 그래프를 위한 선언형 질의 언어로, Neo4j 그래프 데이터베이스용으로 만들어졌다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img.png"
width="925"
height="564"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_hue7842d50d38e3b2e6ac6ca2ece9154d3_90342_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_hue7842d50d38e3b2e6ac6ca2ece9154d3_90342_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="그래프 구조 데이터"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="393px"
>&lt;/p>
&lt;p>사이퍼로 왼쪽 부분을 그래프 데이터베이스로 삽입하려면 아래와 같은 질의가 필요하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">CREATE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (NAmerica:Location {name:&amp;#39;North America&amp;#39;, type:&amp;#39;continent&amp;#39;}),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (USA:Location
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Idaho:Location
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Lucy:Person
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Idaho) -[:WITHIN]-&amp;gt; (USA) -[:WITHIN]-&amp;gt; (NAmerica),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Lucy) -[:BORN_IN]-&amp;gt; (Idaho)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>각 정점에는 USA나 Idaho 같은 상징적인 이름이 지정돼있고, 질의의 다른 부분에서 이 이름을 사용해 정점간 간선을 화살표 표기를 사용해 만들 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>미국에서 유럽으로 이민 온 모든 사람들의 이름 찾기&lt;/strong>&lt;/p>
&lt;p>더 정확하게 말하면 미국 내 위치의 &lt;code>BORN_IN&lt;/code> 간선을 가진 정점과 유럽 내 위치의 &lt;code>LIVING_IN&lt;/code> 간선을 갖는 모든 정점을 찾아서 이 정점들의 &lt;code>name&lt;/code> 속성을 반호나하는 문제이다.&lt;/p>
&lt;p>&lt;code>MATCH&lt;/code> 문에서는 같은 화살표 표기를 이용해 그래프에서 패턴을 찾는다.&lt;/p>
&lt;p>&lt;code>(person) -[:BORN_IN]-&amp;gt; ()&lt;/code>는 &lt;code>BORN_IN&lt;/code> 레이블을 가진 간선과 관련된 두 정점을 찾는다. 이 간선의 꼬리 정점은 &lt;code>person&lt;/code> 변수에 묶여 있고 머리 정점은 명기하지 않는 채로
남아있게된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">MATCH
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (person) -[:BORN_IN]-&amp;gt; () -[:WITHIN*0..]-&amp;gt; (us:Location {name:&amp;#39;United States&amp;#39;}),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (person) -[:LIVES_IN]-&amp;gt; () -[:WITHIN*0..]-&amp;gt; (eu:Location {name:&amp;#39;Europe&amp;#39;})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RETURN person.name
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>&lt;code>person&lt;/code>은 어떤 정점을 향하는 &lt;code>BORN_IN&lt;/code> 유출 간선을 가지며, 이 정점에서 &lt;code>name&lt;/code> 속성이 &amp;ldquo;United States&amp;quot;인 &lt;code>Location&lt;/code> 유형의 정점에 도달할 때까지 일련의 &lt;code>WITHIN&lt;/code>
유출 간선을 따라간다.&lt;/li>
&lt;li>같은 &lt;code>person&lt;/code>의 정점은 &lt;code>LIVES_IN&lt;/code> 유출 간선도 가지는데, 이 간선과 &lt;code>WITHIN&lt;/code> 유출 간선을 따라가면 결국 &lt;code>name&lt;/code> 속성이 &amp;ldquo;Europe&amp;quot;인 &lt;code>Location&lt;/code> 유형의 정점에
도달하게된다.&lt;/li>
&lt;li>각 &lt;code>person&lt;/code> 정점마다 &lt;code>name&lt;/code> 속성을 반환한다.&lt;/li>
&lt;/ol>
&lt;p>질의를 실행하는 데는 여러 가지 방법이 있다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스에서 모든 사람을 홅어보는 작업을 시작으로 사람들의 출생지와 거주지를 확인해 기준에 맞는 사람들만 반환&lt;/li>
&lt;li>두 개의 &lt;code>Location&lt;/code> 정점에서 시작해 반대 방향으로 수행
&lt;ul>
&lt;li>&lt;code>name&lt;/code> 속성에 색인이 있다면 미국과 유럽을 나타내는 두 개의 정점을 효율적으로 찾을 수 있음&lt;/li>
&lt;li>&lt;code>WITHIN&lt;/code> 유입 간선을 따라겨 미국과 유럽의 모든 위치 찾기를 진행&lt;/li>
&lt;li>위치를 나타내는 정점 중 하나에서 &lt;code>BORN_IN&lt;/code>이나 &lt;code>LIVE_IN&lt;/code> 유입 간선을 통해 발견된 사람을 구함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>보통 선언형 질의 언어는 질의를 작성할 때 이처럼 수행에 대해 자세히 지정할 필요가 없다. 질의 최적화기가 가장 효율적이라고 예측한 전략을 자동으로 선택하므로 작성자는 나머지 애플리케이션만 작성하면 된다.&lt;/p>
&lt;h3 id="sql의-그래프-질의">SQL의 그래프 질의&lt;/h3>
&lt;p>위에서 언급한 것 처럼 관계형 데이터베이스에서 그래프 데이터를 표현할 수 있음을 제안하였다.&lt;/p>
&lt;p>그래프를 관계형 구조로 넣어도 SQL을 통해 질의할 수 있지만, &lt;strong>어렵다&lt;/strong>. 관계형 데이터베이스에서는 대개 질의에 필요한 조인을 미리 알고 있는데, 그래프 질의에서는 찾고자 하는 정점을 찾기 전에 가변적인 여러
간선을 순회해야하기 때문이다.&lt;/p>
&lt;ul>
&lt;li>미리 조인 수를 고정할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>예제에서 간선 순회는 사이퍼 질의의 &lt;code>() -[:WITHIN*0..]-&amp;gt; ()&lt;/code> 문에서 발생한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>person&lt;/code>의 &lt;code>LIVES_IN&lt;/code> 간선은 위치 유형(거리, 도시, 지구, 군, 주 등)을 가리킨다.&lt;/li>
&lt;li>각각 &amp;ldquo;도시 -&amp;gt; 군 -&amp;gt; 주 -&amp;gt; 주 -&amp;gt; 국가&amp;rdquo; 순으로 &lt;code>WITHIN&lt;/code> 간선으로 이어진다.
&lt;code>LIVES_IN&lt;/code> 간선은 찾고자 하는 위치 정점을 직접 가르킬 수 있으나 위치 계층 구조에서 제거된 일부 수준일 수도 있다.&lt;/li>
&lt;/ul>
&lt;p>사이퍼에서 &lt;code>:WITHIN*0..&lt;/code>은 0회 이상 &lt;code>WITHIN&lt;/code> 간선을 따라가라는 의미로 이를 간결하게 표현한다.&lt;/p>
&lt;p>SQL:1999 이후 가변 순회 경로에 대한 질의 개념은 &lt;strong>재귀 공통 테이블 식&lt;/strong>(recursive common table expression, &lt;code>WITH RECURSIVE&lt;/code>)을 사용해서 표현할 수 있지만
사이퍼와 비교했을 때 문법이 어렵다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">WITH&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">RECURSIVE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">-- in_usa is the set of vertex IDs of all locations within the United States
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_usa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&amp;gt;&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;name&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;United States&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">UNION&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- 2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_usa&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;within&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">-- in_europe is the set of vertex IDs of all locations within Europe
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_europe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- 3
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&amp;gt;&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;name&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Europe&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">UNION&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_europe&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_europe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;within&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">-- born_in_usa is the set of vertex IDs of all people born in the US
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">born_in_usa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- 4
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_usa&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;born_in&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">-- lives_in_europe is the set of vertex IDs of all people living in Europe
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lives_in_europe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- 5
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_europe&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_europe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;lives_in&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&amp;gt;&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;name&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-- join to find those people who were both born in the US *and* live in Europe
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">born_in_usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">born_in_usa&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- 6
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lives_in_europe&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lives_in_europe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;code>name&lt;/code> 속성이 &amp;ldquo;United States&amp;quot;인 정점을 찾아 &lt;code>in_usa&lt;/code> 정점 집합의 첫 번째 엘리먼트로 만든다.&lt;/li>
&lt;li>&lt;code>in_usa&lt;/code> 집합의 모든 정점들의 모든 &lt;code>within&lt;/code> 유입 간선을 따라가 같은 집합에 추가한다.
&lt;ul>
&lt;li>모든 &lt;code>within&lt;/code> 간선을 방문할 때까지 수행한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>name&lt;/code> 속성이 &amp;ldquo;Europe&amp;quot;인 정점을 시작으로 동일하게 수행해 &lt;code>in_europe&lt;/code> 집합을 만든다.&lt;/li>
&lt;li>미국에서 태어난 사람을 찾기 위해 &lt;code>in_usa&lt;/code> 집합의 각 정점에 대해 &lt;code>born_in&lt;/code> 유입 간선을 따라간다.&lt;/li>
&lt;li>비슷하게 유럽에서 사는 사람을 찾기 위해 &lt;code>in_europe&lt;/code> 집합의 각 정점에 대해 &lt;code>lives_in&lt;/code> 유입 간선을 따라간다.&lt;/li>
&lt;li>마지막으로 조인을 이용해 미국에서 태어난 사람 집합과 유럽에서 사는 사람 집합의 교집합을 구한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>동일한 질의를, cypher는 4줄로 작성하고, SQL은 29줄로 작성해야 한다. 이는 다양한 데이터 모델이 서로 다른 사용 사례를 만족하기 위해 설계되었다는 사실을 반증한다.&lt;/p>
&lt;p>따라서 애플리케이션에 적합한 데이터 모델 선택 작업은 중요하다.&lt;/p>
&lt;h3 id="트리플-저장소와-스파클">트리플 저장소와 스파클&lt;/h3>
&lt;p>트리플 저장소 모델은 속성 그래프 모델과 거의 동등하다.&lt;/p>
&lt;p>이 모델은 같은 생각을 다른 용어를 사용해 설명한다. 그럼에도 애플리케이션 구축에 유용한 도구일지도 모를 트리플 저장소를 위한 ㄷ양한 도구와 언어가 있기 때문에 논의할 만한 가치가 있다.&lt;/p>
&lt;p>트리플 저장소에서는 모든 정보를 &lt;strong>주어&lt;/strong>(subject), &lt;strong>서술어&lt;/strong>(predicate), 목적어(object) 처럼 매우 간단한 &lt;strong>세 부분 구문&lt;/strong>(three-part statements) 형식으로
저장한다.&lt;/p>
&lt;p>트리플의 주어는 그래프의 정점과 종등하며, 목적어는 두 가지중 하나이다.&lt;/p>
&lt;ul>
&lt;li>문자열이나 숫자 같은 원시 데이터타입의 값
&lt;ul>
&lt;li>트리플의 서술어와 목적어는 주어 정점에서 속성의 키, 값과 동등하다.&lt;/li>
&lt;li>(루시, 나이, 33)은 &lt;code>{&amp;quot;age&amp;quot;:33}&lt;/code> 속성을 가진 정점 lucy와 같다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>그래프의 다른 정점
&lt;ul>
&lt;li>서술어는 그래프의 간선이고 주어는 꼬리 정점이며 목적어는 머리 정점이다.&lt;/li>
&lt;li>(루시, 결혼하다, 알랭)에서 주어와 목적어인 루시와 알랭은 정점이고, 서술어 결혼하다는 두 정점을 잇는 간선의 레이블이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img.png"
width="925"
height="564"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_hue7842d50d38e3b2e6ac6ca2ece9154d3_90342_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_hue7842d50d38e3b2e6ac6ca2ece9154d3_90342_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="그래프 구조 데이터"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="393px"
>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-turtle" data-lang="turtle">&lt;span class="line">&lt;span class="cl">&lt;span class="k">@prefix&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nv">&amp;lt;urn:example:&amp;gt;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">lucy&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Person&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">lucy&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Lucy&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">lucy&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">bornIn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">idaho&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">idaho&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Location&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">idaho&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Idaho&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">idaho&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;state&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">idaho&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">within&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">usa&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Location&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;United States&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;country&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">within&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">namerica&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">namerica&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Location&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">namerica&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;North America&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">namerica&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;continent&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위 예제는 그림의 일부를 보여주며 &lt;strong>터틀&lt;/strong>(Turtle) 형식의 트리플로 작성되었다.(터틀은 &lt;strong>Notation3&lt;/strong>(N3)의 부분 집합이다.)&lt;/p>
&lt;p>그래프의 정점을 &lt;code>_:someName&lt;/code>으로 작성했는데 이 파일 외부의 것을 의미하지 않는다, &lt;code>_:someName&lt;/code>은 트리플이 같은 정점을 참조하는지 달리 알지 못하기 때문에 존재한다.&lt;/p>
&lt;p>서술어가 간선을 나타내면 목적어는 &lt;code>_:usa :within _:usa&lt;/code> 처럼 정점이 되고, 서술어가 속성이라면 목적어는 &lt;code>_:usa :name &amp;quot;United States&amp;quot;&lt;/code> 처럼 문자열 리터럴이된다.&lt;/p>
&lt;p>동일한 주어를 반복하는 작업은 단순 반복 작업으로, 세미콜론을 사용해 동일한 주어에 대해 여러 경우를 잘 표한할 수 있게되어 터틀 형식을 읽기 쉽게 만든다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-turtle" data-lang="turtle">&lt;span class="line">&lt;span class="cl">&lt;span class="k">@prefix&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nv">&amp;lt;urn:example:&amp;gt;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">lucy&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Person&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Lucy&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">bornIn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">idaho&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">idaho&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Location&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Idaho&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;state&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">within&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">usa&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Location&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;United States&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;country&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">within&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">namerica&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">namerica&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Location&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;North America&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;continent&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="시맨틱-웹">시맨틱 웹&lt;/h3>
&lt;p>트리플 저장소에 관한 내용을 읽다보면 &lt;strong>시맨틱 웹&lt;/strong>관련 기사들을 많이 접할 수 있지만, 트리플 저장소 데이터 모델은 시맨틱 웹과는 완전히 독립적이다.&lt;/p>
&lt;p>하지만 많은 사람들이 이 둘이 매우 밀접한 관계가 있다고 생각하기때문에 간략화게 논의할 필요가 있다.&lt;/p>
&lt;p>시맨틱 웹은 즉 웹 사이트는 이미 사람이 읽을 수 있는 텍스트와 그림으로 정보를 게시하고 있으니 &lt;strong>컴퓨터가 읽게끔 기계가 판독 가능한 데이터로도 정보를 게시하는 건 어떨까&lt;/strong>?라는 개념이다.&lt;/p>
&lt;p>&lt;strong>자원 기술 프레임워크(Resource Description Framework, RDF)&lt;/strong> 는 서로 다른 웹 사이트가 일관된 형식으로 데이터를 게시하기 위한 방법을 제안한다.&lt;/p>
&lt;p>RDF는 서로 다른 웹 사이트의 데이터가 일종의 전 인터넷 &amp;ldquo;만물 데이터베이스(database of everything)&amp;ldquo;인 &lt;strong>데이터 웹(web of data)&lt;/strong> 에 자동으로 결함할 수 있게 한다.&lt;/p>
&lt;p>시맨틱 웹은 2000년대 초반에 과대평가됐고 지금까지 현실에서 실현된 흔적이 없어 많은 사람이 부정적인 견해를 보였다.&lt;/p>
&lt;ul>
&lt;li>어지러운 약어의 과잉과 지나치게 복잡한 표준 제안, 자만심으로 어려움을 겪었다.&lt;/li>
&lt;/ul>
&lt;p>하지만 이런 단점들이 있음에도 시맨틱 웹 프로젝트에서 유래한 좋은 작업이 많이 있으며, 시맨틱 웹에서 RDF 데이터를 게시하는 일어 관심이 없다고 하더라도 트리플은 &lt;strong>애플리케이션의 훌륭한 내부 데이터 모델&lt;/strong>이 될
수 있다.&lt;/p>
&lt;h3 id="rdf-데이터-모델">RDF 데이터 모델&lt;/h3>
&lt;p>터틀 언어는 RDF 데이터를 사람이 읽을 수 있는 형식으로 표현한다. XML 형식으로 쓰기도 하지만, XML 형식은 같은 내용을 훨씬 장황하게 만든다.&lt;/p>
&lt;p>한눈에 쉽게 보기 위해서는 터틀/N3를 선호하며 아파치 제나 같은 도구는 필요한 경우 서로 다른 RDF 형식으로 자동 변환할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;rdf:RDF&lt;/span> &lt;span class="na">xmlns=&lt;/span>&lt;span class="s">&amp;#34;urn:example:&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">xmlns:rdf=&lt;/span>&lt;span class="s">&amp;#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Location&lt;/span> &lt;span class="na">rdf:nodeID=&lt;/span>&lt;span class="s">&amp;#34;idaho&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;name&amp;gt;&lt;/span>Idaho&lt;span class="nt">&amp;lt;/name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;type&amp;gt;&lt;/span>state&lt;span class="nt">&amp;lt;/type&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;within&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Location&lt;/span> &lt;span class="na">rdf:nodeID=&lt;/span>&lt;span class="s">&amp;#34;usa&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;name&amp;gt;&lt;/span>United States&lt;span class="nt">&amp;lt;/name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;type&amp;gt;&lt;/span>country&lt;span class="nt">&amp;lt;/type&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;within&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Location&lt;/span> &lt;span class="na">rdf:nodeID=&lt;/span>&lt;span class="s">&amp;#34;namerica&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;name&amp;gt;&lt;/span>North America&lt;span class="nt">&amp;lt;/name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;type&amp;gt;&lt;/span>continent&lt;span class="nt">&amp;lt;/type&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Location&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/within&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Location&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/within&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Location&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Person&lt;/span> &lt;span class="na">rdf:nodeID=&lt;/span>&lt;span class="s">&amp;#34;lucy&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;name&amp;gt;&lt;/span>Lucy&lt;span class="nt">&amp;lt;/name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;bornIn&lt;/span> &lt;span class="na">rdf:nodeID=&lt;/span>&lt;span class="s">&amp;#34;idaho&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Person&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/rdf:RDF&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>RDF는 인터넷 전체의 데이터 교환을 위해 설계했기 때문에 약간 이상한 점이 있다.&lt;/p>
&lt;p>첫 번째로 트리플의 주어, 서술어, 목적어는 주로 URI다.&lt;/p>
&lt;p>서술어는 &lt;code>WITHIN&lt;/code>이나 &lt;code>LIVES_IN&lt;/code>이 아니라 &lt;code>&amp;lt;http://my-company.com/namespace#within&amp;gt;&lt;/code>, &lt;code>&amp;lt;http://my-company.com/namespace#lives_in&amp;gt;&lt;/code>
같은 URL일 수 있는데, 이러한 설계의 배경은 데이터를 다른 사람의 데이터와 결합하기 위함이다.&lt;/p>
&lt;p>만약 &lt;code>within&lt;/code>이나 &lt;code>lives_in&lt;/code> 단어에 다른 의미를 붙이면 서술어는 &lt;code>&amp;lt;http://other.org/foo#within&amp;gt;&lt;/code>, &lt;code>&amp;lt;http://other.org/foo#lives_in&amp;gt;&lt;/code>이므로 충돌이
발생하지 않게된다.&lt;/p>
&lt;p>두 번째로 URL은 반드시 실제 접속 가능한 주소일 필요는 없다는 점으로, RDF의 관점에서는 하나의 네임 스페이스를 의미할 뿐이다.&lt;/p>
&lt;h3 id="스파클-질의-언어">스파클 질의 언어&lt;/h3>
&lt;p>스파클(SPARQL)은 RDF 데이터 모델을 사용한 트리플 저장소 질의 언어이다.(SPARQL Protocol and RDF Query Language)&lt;/p>
&lt;p>스파클을 사이퍼보다 먼저 만들었고 사이퍼의 패턴 매칭을 스파클에서 차용했기 때문에 매우 유사해보인다.&lt;/p>
&lt;p>앞에서 살펴본 무국에서 유럽으로 이주한 사람을 찾는 질의는 사이퍼보다 스파클에서 더욱 간결해진다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">PREFIX : &amp;lt;urn:example:&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT ?personName
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WHERE {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ?person :name ?personName.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ?person :bornIn / :within* / :name &amp;#34;United States&amp;#34;.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ?person :livesIn / :within* / :name &amp;#34;Europe&amp;#34;.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>구조는 매우 유사하며 다음 두 표현식은 동등하다.&lt;/p>
&lt;ul>
&lt;li>스파클에서 변수는 물음표로 시작&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(person) -[:BORN_IN]-&amp;gt; () -[:WITHIN*0..]-&amp;gt; (location) # Cypher
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">?person :bornIn / :within* ?location. # SPARQL
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>RDF는 속성과 간선을 구별하지 않고 서술어만 사용하기 때문에 속성 매칭을 위해 동일한 구문을 사용할 수 있다.&lt;/p>
&lt;p>다음 표현식에 따르면 &lt;code>usa&lt;/code> 변수는 문자열 값이 &lt;code>&amp;quot;United States&amp;quot;&lt;/code>인 &lt;code>name&lt;/code> 속성을 가진 모든 정점이어야 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(usa {name:&amp;#39;United States&amp;#39;}) # Cypher
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">?usa :name &amp;#34;United States&amp;#34;. # SPARQL
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>스파클은 훌륭한 질의 언어로 시멘틱 웹이 아니더라도 애플리케이션이 내부적으로 사용하는 강력한 도구가 될 수 있다.&lt;/p>
&lt;h3 id="초석-데이터로그">초석: 데이터로그&lt;/h3>
&lt;p>&lt;strong>데이터로그(Datalog)&lt;/strong> 는 스파클이나 사이퍼보다 훨씬 오래된 언어로 1980년대 학계에서 광범위하게 연구되었다.&lt;/p>
&lt;p>소프트웨어 엔지니어 사이에서는 잘 알려져 있지 않지만 그럼에도 중요한 이유는 이후 질의 언어의 기반이 되는 초석을 제공하기 때문이다.&lt;/p>
&lt;p>데이터로그의 데이터 모델은 트리플 저장소 모델과 유사하지만 조금 더 일반화되었다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>(주어, 서술어, 목적어)&lt;/code>로 트리플을 작성하는 대신 &lt;code>서술어(주어, 목적어)&lt;/code>로 작성한다.&lt;/li>
&lt;/ul>
&lt;p>지금까지 예시로 주어졌던 데이터를 데이터로그로 표현아면 아래와 같다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">name(namerica, &amp;#39;North America&amp;#39;).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">type(namerica, continent).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">name(usa, &amp;#39;United States&amp;#39;).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">type(usa, country).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">within(usa, namerica).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">name(idaho, &amp;#39;Idaho&amp;#39;).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">type(idaho, state).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">within(idaho, usa).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">name(lucy, &amp;#39;Lucy&amp;#39;).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">born_in(lucy, idaho).
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>데이터를 위와 같이 정의했다면, 데이터로그를 이용해서 이전과 동일한 질의를 작성할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">within_recursive(Location, Name) :- name(Location, Name). /* Rule 1 */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">within_recursive(Location, Name) :- within(Location, Via), /* Rule 2 */ within_recursive(Via, Name).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">migrated(Name, BornIn, LivingIn) :- name(Person, Name), /* Rule 3 */ born_in(Person, BornLoc),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> within_recursive(BornLoc, BornIn),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lives_in(Person, LivingLoc),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> within_recursive(LivingLoc, LivingIn).
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>사이퍼와 스파클은 &lt;code>SELECT&lt;/code>로 바로 질의하는 반면 데이터로그는 단계를 나눠 한 번에 조금씩 질의로 나아간다.&lt;/p>
&lt;p>먼저 새로운 서술어를 데이터베이스에 전달하는 &lt;strong>규칙(rule)&lt;/strong> 을 정의한다.&lt;/p>
&lt;ul>
&lt;li>이 예제에서는 &lt;code>within_recursive&lt;/code>와 &lt;code>migrated&lt;/code> 두 개를 새로 정의&lt;/li>
&lt;/ul>
&lt;p>서술어는 데이터베이스에 저장된 트리플이 아니며, 데이터나 다른 규칙으로 부터 파생되며, 규칙(rule)은 함수가 다른 함수를 호출하거나 재귀적으로 자신을 호출하는 것 처럼 다른 규칙을 참조할 수 있다.&lt;/p>
&lt;ul>
&lt;li>이처럼 복잡한 질의를 작은 부분으로 나눠 차례차례 구성할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>규칙에서 대문자로 시작하는 단어는 변수이고 서술어는 사이퍼와 스파클의 서술어와 대응된다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>name(Location, Name)&lt;/code>은 변수 &lt;code>Location = namerica&lt;/code>, &lt;code>Name = 'North America'&lt;/code>를 가진 트리플 &lt;code>name(namerica, 'North America')&lt;/code>에 대응&lt;/li>
&lt;/ul>
&lt;p>시스템이 &lt;code>:-&lt;/code> 연산자의 오른편에 있는 모든 서술어의 대응을 찾으면 규칙이 적용된다. 규칙이 적용될 때 &lt;code>:-&lt;/code>의 왼편이 데이터베이스에 추가된다.(변수는 대응된 값으로 대체)&lt;/p>
&lt;p>다음은 이 규칙을 적용할 수 있는 방법 중 하나다.&lt;/p>
&lt;ol>
&lt;li>데이터베이스에 &lt;code>name(namerica, 'North America')&lt;/code>가 존재하면 규칙 1을 적용하고, 규칙 1은 &lt;code>within_recursive(namerica, 'North America')&lt;/code>를 생성한다.&lt;/li>
&lt;li>데이터베이스에 &lt;code>within(usa, namerica)&lt;/code>가 존재하고 이전 단계에서 &lt;code>within_recursive(namerica, 'North America')&lt;/code>를 생성했으면 규칙 2를 적용한다. 규칙 2는 &lt;code>within_recursive(usa, 'North America')&lt;/code>를 생성한다.&lt;/li>
&lt;li>데이터베이스에 &lt;code>within(idaho, usa)&lt;/code>가 존재하고 이전 단계에서 &lt;code>within_recursive(usa, 'North America')&lt;/code>를 생성했으면 규칙 2를 적용한다. 규칙 2는 &lt;code>within_recursive(idaho, 'North America')&lt;/code>를 생성한다.&lt;/li>
&lt;/ol>
&lt;p>&lt;code>within_recursive&lt;/code> 서술어는 규칙 1과 2를 반복 적용해 데이터베이스에 포함된 북아메리카(또는 다른 장소 이름)의 모든 위치를 찾을 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_1.png"
width="923"
height="312"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_1_hucbf885bc5c024331c2bd06108b34aaca_93746_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_1_hucbf885bc5c024331c2bd06108b34aaca_93746_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터로그 규칙을 사용해 아이다호가 북아메리카에 있는지 확인"
class="gallery-image"
data-flex-grow="295"
data-flex-basis="710px"
>&lt;/p>
&lt;p>이제 규칙 3으로 특정 &lt;code>LivingIn&lt;/code> 장소에 살면서 특정 &lt;code>BornIn&lt;/code> 장소에서 태어난 사람을 찾을 수 있다.&lt;/p>
&lt;p>질의는 &lt;code>BornIn = 'United State'&lt;/code>와 &lt;code>LivingIn = 'Europe'&lt;/code>이고 변수 &lt;code>Who&lt;/code>에 사람을 남기게 한 다음 데이터로그 시스템에 어떤 값이 변수 &lt;code>Who&lt;/code>에 나타날 수 있는지 물어본 후 최종적으로 이전 사이퍼나 스파클 질의와 같은 답을 얻는다.&lt;/p>
&lt;p>데이터로그 접근 방식은 이번 장에서 이전에 설명한 질의 언어와는 다른 사고가 필요하지만 다른 질의 규칙을 결합하거나 재사용할 수 있기 때문에 매우 강력한 접근 방식이다.&lt;/p>
&lt;p>간단한 일회성 질의에 사용하기는 편리하지 않지만 데이터가 복잡하면 더 효과적으로 대체할 수 있다.&lt;/p>
&lt;h2 id="정리">정리&lt;/h2>
&lt;p>데이터 모델은 광범위한 주제다. 이번 장에서는 다양한 종류의 모델을 간략하게 살펴봤다.&lt;/p>
&lt;p>역사적으로 데이터를 하나의 큰 트리(계층 모델)로 표현하려고 노력했지만 &lt;strong>다대다 관계를 표현하기에는 트리 구조가 적절하지 않았다.&lt;/strong> 이 문제를 해결하기 위해 &lt;strong>관계형 모델&lt;/strong>이 고안되었으며, 최근 개발자들은 관계형 모델에도 적합하지 않은 애플리케이션이 있다는 사실을 발견했다.&lt;/p>
&lt;p>새롬게 등장한 비관계형 데이터 저장소인 &lt;strong>NoSQL&lt;/strong>은 다음과 같은 두 가지 주요 갈래가 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>문서 데이터베이스&lt;/strong>
&lt;ul>
&lt;li>데이터가 문서 자체에 포함돼 있으면서 하나의 문서와 다른 문서 간 관계가 거의 없는 사용 사례를 대상으로 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>그래프 데이터베이스&lt;/strong>
&lt;ul>
&lt;li>문서 데이터베이스와는 정 반대로 모든 것이 잠재적으로 관련이 있다는 사용 사례를 대상으로 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>세 가지 모델(문서, 관계형, 그래프) 모두 현재 널리 사용하고 있으며 각 모델은 &lt;strong>각자의 영역에서 훌륭하다&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>한 모델을 다른 모델로 흉내 낼 수 있지만 그 결과는 대부분 엉망이며, 이것이 단일 만능 솔루션이 아닌 각기 목적에 맞는 다양한 시스템을 보유해야 하는 이유이다.&lt;/p>
&lt;/blockquote>
&lt;p>문서 및 그래프 데이터베이스가 가진 공통점 중 하나는 일반적으로 저장할 데이터를 위한 스키마를 강제하지 않아 변화하는 요구사항에 맞춰 애플리케이션을 쉽게 변경할 수 있지만, 애플리케이션은 데이터가 특정 구조를 갖는다고 가정할 가능성이 높다.&lt;/p>
&lt;ul>
&lt;li>이는 스키마가 명시적인지(쓰기에 강요) 암시적인지(읽기에 다뤄짐)의 문제일 뿐이다.&lt;/li>
&lt;/ul>
&lt;p>각 데이터 모델은 고유한 질의 언어나 프레임 워크를 제공한다.&lt;/p>
&lt;ul>
&lt;li>SQL, 맵리듀스, MongoDB의 집계 파이프라인, 사이퍼, 스파클, 데이터로그 등&lt;/li>
&lt;li>CSS, XSL/XPath: 데이터베이스 질의 언어는 아니지만 흥미로운 유사점이 있다.&lt;/li>
&lt;/ul>
&lt;p>아직 언급되지 않은 데이터 모델은 몇 가지는 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>게놈(Genome) 데이터베이스&lt;/li>
&lt;li>대형 강입자 충돌기를 위한 하드웨어 비용이 통제되는 사용자 정의 솔루션&lt;/li>
&lt;li>전문 검색(full-text)&lt;/li>
&lt;/ul></description></item><item><title>2.2 데이터 모델과 질의 언어 - 데이터를 위한 질의 언어</title><link>https://codemario318.github.io/post/designing-data-intensive-application/2/2/</link><pubDate>Mon, 03 Feb 2025 21:06:49 +0900</pubDate><guid>https://codemario318.github.io/post/designing-data-intensive-application/2/2/</guid><description>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/2/cover.png" alt="Featured image of post 2.2 데이터 모델과 질의 언어 - 데이터를 위한 질의 언어" />&lt;h2 id="데이터를-위한-질의-언어">데이터를 위한 질의 언어&lt;/h2>
&lt;p>관계형 모델이 등장했을 때 데이터를 질의하는 새로운 방법도 함께 나타났다. SQL은 &lt;strong>선언형&lt;/strong> 질의 언어인 반면 IMS와 코다실은 &lt;strong>명령형&lt;/strong> 코드를 사용해 데이터베이스에 질의한다.&lt;/p>
&lt;p>일반적으로 많이 사용하는 프로그래밍 언어는 명령형 언어다. 예를 들어 동물의 종 목록이 있을 때 목록에서 상어만 반환하는 코드는 아래와 같다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">getSharks&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">sharks&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">animals&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">animals&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">family&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;Sharks&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sharks&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">animals&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">sharks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>SQL로 표현하면 아래와 같다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">animals&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">family&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Sharks&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>명령형 언어는 특정 순서로 특정 연산을 수행하게끔 컴퓨터에게 지시한다.&lt;/p>
&lt;ul>
&lt;li>코드르 한줄씩 단계별로 실행&lt;/li>
&lt;li>조건을 평가&lt;/li>
&lt;li>변수를 갱신&lt;/li>
&lt;li>루프를 실행할지 여부를 결정&lt;/li>
&lt;/ul>
&lt;p>SQL이나 관계 대수 같은 선언형 질의 언어에서는 &lt;strong>목표를 달성하기 위한 방법&lt;/strong>이 아니라 알고자 하는 데이터의 패턴, 즉 &lt;strong>결과&lt;/strong>가 충족해야 하는 조건과 데이터를 어떻게 변환(ex. 정렬, 그룹화, 집계)할 지 지정하기만 하면 된다.&lt;/p>
&lt;p>어떤 색인과 어떤 조인 함수를 사용할지, 질의의 다양한 부분을 어떤 순서로 실행할지를 결정하는 일은 데이터베이스 시스템의 질의 최적화기가 할 일이다.&lt;/p>
&lt;p>선언형 질의 언어는 일반적으로 명령형 API보다 더 간결하고 쉽게 작업할 수 있기 때문에 매력적이다. 하지만 더 중요한 점은 &lt;strong>데이터베이스 엔진의 상세 구현이 숨겨져 있어 질의를 변경하지 않고도 데이터베이스 시스템의 성능을 향상시킬 수 있다는 점&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>선언형 질의는 특정 순서를 보장하지 않으므로 순서가 바뀌어도 상관없으나, 질의가 명령형으로 작성되었다면 데이터베이스는 코드가 순서에 의존하는지 여부를 확신할 수 없다.&lt;/li>
&lt;li>SQL이 기능적으로 더 제한적이라는 사실은 데이터베이스에게 자동으로 최적화할 수 있는 여지를 더 많이 준다는 의미이다.&lt;/li>
&lt;/ul>
&lt;p>선언형 언어는 종종 병렬 실행에 적합하다. 명령형 코드는 명령어를 특정 순서로 수행하게끔 지정하기 때문에 다중 코어나 다중 장비에서 병렬 처리가 매우 어렵다. 선언형 언어는 결과를 결정하기 위한 알고리즘을 지정하는 게 아니라 결과의 패턴만 지정하므로 병렬 실행으로 더 빨라질 가능성이 크다.&lt;/p>
&lt;h3 id="웹에서의-선언형-질의">웹에서의 선언형 질의&lt;/h3>
&lt;p>선언형 질의 언어의 장점은 데이터베이스에만 국한되지 않는다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-html" data-lang="html">&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span> &lt;span class="na">class&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;selected&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Sharks&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Great White Shark&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Tiger Shark&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Hammerhead Shark&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Whales&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Blue Whale&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Humpback Whale&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Fin Whale&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위와 같은 HTML 문서에서 선택된 리스트의 요소인 &lt;code>&amp;lt;p&amp;gt;Sharks&amp;lt;p&amp;gt;&lt;/code>의 배경을 파란색으로 변경하고 싶다면 아래와 같이 CSS를 작성할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-css" data-lang="css">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">li&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nc">selected&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nt">p&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">background-color&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">blue&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>CSS는 대표적인 선언형 언어로 만약 명령형 접근 방식을 활용해야한다면, 아래와 같은 JS 코드가 필요하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">liElements&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getElementsByTagName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;li&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">liElements&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">liElements&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">className&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;selected&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">children&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">liElements&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">childNodes&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">children&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">children&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">j&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nodeType&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">Node&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ELEMENT_NODE&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">tagName&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;P&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">setAttribute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;style&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;background-color: blue&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위 자바스크립트 코드는 CSS보다 이해하기 어려울 뿐더러 심각한 문제를 가지고 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>selected&lt;/code> 클래스가 삭제된 경우 코드가 재실행되더라도 파란색은 삭제되지 않음
&lt;ul>
&lt;li>CSS의 경우는 규칙이 적용되지 않을 때 바로 다시 그려짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>새로운 API의 장점을 취하고 싶다면 코드를 재작성해야함
&lt;ul>
&lt;li>브라우저 밴더는 호환성을 깨트리지 않고 CSS의 성능을 향상시킬 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>웹 브라우저에서 선언형 CSS 스타일을 사용하는 편이 자바스크립트에서 명령형으로 스타일을 다루기보다 훨씬 편리하다.&lt;/p>
&lt;p>마찬가지로 데이터베이스에서는 SQL 같은 선언형 질의 언어가 명령형 질의 API 보다 훨씬 좋다고 나타났다.&lt;/p>
&lt;h3 id="맵리듀스-질의">맵리듀스 질의&lt;/h3>
&lt;p>&lt;strong>맵리듀스&lt;/strong>(MapReduce)는 많은 컴퓨터에서 대랴으이 데이터를 처리하기 위한 프로그래밍 모델로, 구글에 의해 널리 알려졌다. 이 메커니즘은 많은 문서를 대상으로 읽기 전용(read-only) 질의를 수행할 때 사용한다.&lt;/p>
&lt;p>맵리듀스는 선언형 질의 언어도 완전한 명령형 질의 API도 아닌 그 중간 정도에 있다. 질의 로직은 처리 프레임워크가 반복적으로 호출하는 &lt;strong>조각 코드로 표현&lt;/strong>한다.&lt;/p>
&lt;ul>
&lt;li>함수형 프로그래밍 언어에 있는 map(collect)과 reduce(fold, inject) 함수를 기반으로 함&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>한 달에 얼마나 자주 상어를 발견하는지 보고서를 작성하는 상황&lt;/strong>을 가정하고 예시를 살펴본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>Postgresql&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">date_trunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;month&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">observation_timestamp&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">observation_month&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_animals&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_animals&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">observations&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">family&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Sharks&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">GROUP&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">observation_month&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>상어과에 속하는 종만 보이도록 관측치를 필터링한 다음, 관측ㄱ치가 발생한 달력의 우러로 그룹화하고 마지막으로 해당 달의 모든 관측치에 보여진 동물 수를 합함&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>MongoDB&lt;/strong>&lt;/p>
&lt;p>맵리듀스 기능을 활용하여 다음과 같이 표현할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">db&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">observations&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mapReduce&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">function&lt;/span> &lt;span class="nx">map&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">year&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">observationTimestamp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getFullYear&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">month&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">observationTimestamp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getMonth&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">year&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s2">&amp;#34;-&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">month&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">numAnimals&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 3
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">function&lt;/span> &lt;span class="nx">reduce&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">values&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 4
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">Array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">values&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 5
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">query&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">family&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;Sharks&amp;#34;&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">out&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;monthlySharkReport&amp;#34;&lt;/span> &lt;span class="c1">// 6
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>상어 종만 거르기 위한 필터를 선언적으로 지정&lt;/li>
&lt;li>질의와 일치하는 모든 문서에 대해 한 번씩 호출&lt;/li>
&lt;li>키와 값을 방출&lt;/li>
&lt;li>방출한 키-값 쌍은 키로 그룹화됨
&lt;ul>
&lt;li>같은 키를 갖는 모든 키-값 쌍은 &lt;code>reduce&lt;/code> 함수를 한 번 호출함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>특정 월의 모든 관측치에서 동물 수를 합침&lt;/li>
&lt;li>최종 출력을 &lt;code>monthlySharkReport&lt;/code> 컬렉션에 기록&lt;/li>
&lt;/ol>
&lt;p>MongoDB의 &lt;code>map&lt;/code>과 &lt;code>reduce&lt;/code> 함수는 수행할 때 두 함수는 순수 함수여야 한다는 제약이 있다.&lt;/p>
&lt;ul>
&lt;li>입력으로 전달된 데이터만 사용하고, 추가적인 데이터베이스 질의를 수행할 수 없어야함&lt;/li>
&lt;li>부수 효과(side effect)가 없어야함&lt;/li>
&lt;/ul>
&lt;p>이러한 제약 사항 때문에 데이터베이스가 임의 순서로 어디서나 이 함수를 실행할 수 있고 장애가 발생해도 함수를 재실행 할 수 있다. 이런 제약 사항이 있어도 여전히 강력하며, 문자열을 파싱하고 라이브러리 함수를 호출하고 계산을 실행하는 등의 작업을 &lt;code>map&lt;/code>과 &lt;code>reduce&lt;/code> 함수에서 실행할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>집계 파이프라인 언어&lt;/strong>&lt;/p>
&lt;p>맵리듀스의 사용성 문제는 연계된 자바스크립트 함수 두 개를 신중하게 작성해야 한다는 점인데 이는 종종 하나의 질의를 작성하는 것보다 어렵다. 반면 선언형 질의 언어는 질의 최적화기가 질의 성능을 높일 수 있는 기회를 제공한다.&lt;/p>
&lt;p>이러한 이유로 MongoDB는 &lt;strong>집게 파이프라인&lt;/strong>(aggregation pipeline)이라 부르는 선언형 질의 언어 지원을 추가했다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">db&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">observations&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">aggregate&lt;/span>&lt;span class="p">([&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span> &lt;span class="nx">$match&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">family&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;Sharks&amp;#34;&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span> &lt;span class="nx">$group&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">_id&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">year&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">$year&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;$observationTimestamp&amp;#34;&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">month&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">$month&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;$observationTimestamp&amp;#34;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">totalAnimals&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">$sum&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;$numAnimals&amp;#34;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>집계 파이프라인 언어는 표현 측면에서 SQL의 부분 집합과 유사하지만 SQL의 영어 문장 스타일 구문보다는 JSON 기반 구문을 사용한다.&lt;/p>
&lt;blockquote>
&lt;p>여기서 배울 점은 NoSQL 시스템이 뜻하지 않게 SQL을 재발견하고 있다는 점이다.&lt;/p>
&lt;/blockquote></description></item><item><title>2.1 데이터 모델과 질의 언어 - 관계형 모델과 문서 모델</title><link>https://codemario318.github.io/post/designing-data-intensive-application/2/1/</link><pubDate>Sat, 18 Jan 2025 15:24:49 +0900</pubDate><guid>https://codemario318.github.io/post/designing-data-intensive-application/2/1/</guid><description>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/1/cover.png" alt="Featured image of post 2.1 데이터 모델과 질의 언어 - 관계형 모델과 문서 모델" />&lt;h2 id="관계형-모델과-문서-모델">관계형 모델과 문서 모델&lt;/h2>
&lt;p>&lt;strong>데이터 모델&lt;/strong>은 소프트웨어가 어떠헥 작성됐는지 뿐만 아니라 해결하려는 &lt;strong>문제를 어떻게 생각해야 하는지&lt;/strong>에 대해 지대한 영향을 미친다.&lt;/p>
&lt;p>대부분 애플리케이션은 하나의 데이터 모델을 다른 데이터 모델 위에 계층을 둬서 만든다.&lt;/p>
&lt;p>각 계층의 핵심적인 문제는 다음 하위 계층 관점에서 데이터 모델을 &lt;strong>표현&lt;/strong>하는 방법이다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션 개발자는 현실(사람, 조직, 상품, 행동, 자금 흐름, 센서)을 보고 객체나 데이터 구조, 그리고 이러한 데이터 구조를 다루는 API를 모델링한다.
&lt;ul>
&lt;li>이러한 구조는 보통 애플리케이션에 특화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 구조를 저장할 때는 JSON이나 XML 문서, 관계형 데이터베이스 테이블이나 그래프 모델 같은 범용 데이터 모델로 표현한다.&lt;/li>
&lt;li>데이터베이스 소프트웨어를 개발하는 엔지니어는 JSON/XML/관계형/그래프 데이터를 메모리나 디스크 또는 네트워크 상의 바이트 단위로 표현하는 방법을 결정한다.
&lt;ul>
&lt;li>이 표현은 다양한 방법으로 데이터를 질의, 탐색, 조작 처리할 수 있게 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>더 낮은 수준에서 하드웨어 엔지니어는 전류, 빛의 파동, 자기장 등의 관점에서 바이트를 표현하는 방법을 알아냈다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>복잡한 애플리케이션에서는 여러 API를 기반으로 만든 API처럼 중간 단계를 더 둘 수 있지만 기본 개념은 여전히 동일하다.&lt;/p>
&lt;/blockquote>
&lt;p>각 계층은 명확한 데이터 모델을 제공해 하위 계층의 복잡성을 숨겨(추상화), 다른 그룹의 사람들이 효율적으로 함께 일할 수 있게끔 한다.&lt;/p>
&lt;hr>
&lt;p>다양한 유형의 데이터 모델이 존재하며, 각 데이터 모델은 사용 방법에 대한 가정을 나타낸다.&lt;/p>
&lt;ul>
&lt;li>어떤 종류의 데이터모델의 사용법은 쉬우나 어떤 동작은 지원하지 않는다.&lt;/li>
&lt;li>데이터 모델의 종류에 따라 어떤 연산은 빠르지만 다른 연산은 매우 느리게 작동한다.&lt;/li>
&lt;li>어떤 데이터 변환은 자연스럽지만 달느 어떤 데이터 변환은 부자연스럽다.&lt;/li>
&lt;/ul>
&lt;p>하나의 데이터 모델만을 완전히 익히는 데도 많은 노력이 필요하며(관계형 데이터 모델링 관련된 학습 분량만해도 방대하다), 데이터 모델을 하나만 사용하면서도 내부 동작에 대한 걱정이 없더라도 소프트웨어 작성은 그 자체로 충분히 어렵다.&lt;/p>
&lt;p>그러나 데이터 모델은 그 위에서 &lt;strong>소프트웨어가 할 수 있는 일과 할 수 없는 일에 지대한 영향&lt;/strong>을 주므로 애플리케이션에 적합한 데이터 모델을 선택하는 작업은 상당히 중요하다.&lt;/p>
&lt;hr>
&lt;p>오늘날 가장 잘 알려진 모델은 1970년 에드가 코드(Edgar Codd)가 제안한 관계형 모델을 기반으로 한 SQL이다.&lt;/p>
&lt;ul>
&lt;li>데이터는 &lt;strong>관계&lt;/strong>로 구성되고 각 관계는 순서 없는 &lt;strong>튜플&lt;/strong> 모음이다.&lt;/li>
&lt;/ul>
&lt;p>관계형 데이터베이스의 근원은 1960년대와 1970년대에 메인프레임 컴퓨터에서 수행된 &lt;strong>비즈니스 데이터 처리&lt;/strong>에 있다.&lt;/p>
&lt;ul>
&lt;li>트랜잭션 처리, 일괄 처리 등&lt;/li>
&lt;/ul>
&lt;p>당시 다른 데이터베이스를 사용하는 개발자는 데이터베이스 내부 데이터 표현에 대해 고민해야 했지만, 관계형 모델로 인해 정리된 인터페이스 뒤로 구현 세부 사항을 숨길 수 있게 되었다.&lt;/p>
&lt;p>이후 컴퓨터가 훨씬 더 강력해지고 네트워크화됨에 따라 다양한 목적으로 활용되기 시작하였고, 관계형 데이터베이스는 비즈니스 데이터 처리 뿐만이 아닌 폭넓은 다양한 사용 사례에도 보편화 되는 것으로 나타났다.&lt;/p>
&lt;p>오늘날 대부분의 서비스는 여전히 관계형 데이터베이스를 통해 제공된다.&lt;/p>
&lt;h3 id="nosql의-탄생">NoSQL의 탄생&lt;/h3>
&lt;p>2010년대에 들어서며 NoSQL이 빠르게 확산되었는데 다양한 이유가 있다.&lt;/p>
&lt;ul>
&lt;li>대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성의 필요&lt;/li>
&lt;li>상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산&lt;/li>
&lt;li>관계형 모델에서 지원하지 않는 특수 질의 동작&lt;/li>
&lt;li>관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람&lt;/li>
&lt;/ul>
&lt;p>애플리케이션은 저마다 요구사항이 다르기 때문에, 사용 사례에 맞는 최적의 기술 선택은 동시에 요구되는 사용 사례에 맞는 최적의 선택과는 다를 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>이 때문에 관계형 데이터베이스가 폭넓은 다양함을 가진 비관계형 데이터스토어와 함께 사용될 것이다.(😲)&lt;/p>
&lt;/blockquote>
&lt;p>이런 개념을 종종 &lt;strong>다중 저장소 지속성&lt;/strong>(polyglot persistence)이라고 부른다.&lt;/p>
&lt;h3 id="객체-관계형-불일치">객체 관계형 불일치&lt;/h3>
&lt;p>오늘날의 대부분의 애플리케이션은 객체지향 프로그래밍 언어로 개발되는데, 이는 SQL 데이터 모델과 객체 모델 사이에 불일치가 발생한다.&lt;/p>
&lt;ul>
&lt;li>데이터를 관계형 테이블에 저장하려면 애플리케이션 코드와 데이터베이스 모델 객체 사이에 거추장스러운 전환 계층이 필요함&lt;/li>
&lt;li>이런 모델 사이의 분리를 임피던스 불일치(impedance mismatch)라고 부른다.&lt;/li>
&lt;/ul>
&lt;p>액티브레코드(Active Record)나 하이버네이트(Hibernate)와 같은 ORM 프레임워크는 전환 계층에 필요한 상용구 코드(boilerplate code)의 양을 줄이지만 두 모델 간의 차이를 완벽히 숨길 수 없다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image.png"
width="728"
height="654"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image_huf7279fce334eb341135beb90b76ab788_145375_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/1/image_huf7279fce334eb341135beb90b76ab788_145375_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="관계형 스키마를 사용해 링크트인 프로필을 표현"
class="gallery-image"
data-flex-grow="111"
data-flex-basis="267px"
>&lt;/p>
&lt;p>프로필 전체는 고유 식별자인 &lt;code>user_id&lt;/code>로 식별가능하고, &lt;code>first_name&lt;/code>, &lt;code>last_name&lt;/code> 같은 필드는 사용자마다 하나만 있으므로 &lt;code>users&lt;/code> 테이블 컬럼으로 모델링 가능하다.&lt;/p>
&lt;p>하지만 경력에 넣을 직업이 하나 이상이며 학력 기간과 연락처 정보도 다양하기 때문에, 사용자와 이들 사이의 관계는 일대다 관계(one-to-many)이며 이는 다양한 방법으로 표현할 수 있다.&lt;/p>
&lt;ul>
&lt;li>전통적인 SQL 모델의 일반적인 정구화 표현은 직위, 학력, 연락처 정보를 개별 테이블에 넣고 외래 키로 &lt;code>users&lt;/code> 테이블을 참조&lt;/li>
&lt;li>구조화된 데이터타입으로 저장(XML, JSON 등)
&lt;ul>
&lt;li>SQL 표준의 마지막 버번에서 구조화된 데이터타입에 대한 지원이 추가됨에 따라, 한 로우에 다중 값을 저장하고 질의와 색인이 가능해짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>직업, 학력, 연략처 정보를 JSON이나 XML 문서로 부호화해 데이터베이스의 텍스트 컬럼에 저장 후, 애플리케이션이 구조와 내용을 해석
&lt;ul>
&lt;li>일반적으로 부호화된 컬럼의 값을 질의하는 데 데이터베이스를 사용할 수 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이력서와 같은 데이터 구조는 모든 내용을 갖추고 있는 &lt;strong>문서&lt;/strong>라서 JSON 표현에 매우 적합하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">251&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;first_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Bill&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;last_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Gates&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;summary&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Co-chair of the Bill &amp;amp; Melinda Gates... Active blogger.&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;region_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;us:91&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;industry_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">131&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;photo_url&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;/p/7/000/253/05b/308dd6e.jpg&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;positions&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;job_title&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Co-chair&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;organization&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Bill &amp;amp; Melinda Gates Foundation&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;job_title&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Co-founder, Chairman&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;organization&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Microsoft&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;education&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;school_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Harvard University&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;start&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1973&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;end&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1975&lt;/span>&lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;school_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Lakeside School, Seattle&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;start&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;end&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;contact_info&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;blog&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;http://thegatesnotes.com&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;twitter&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;http://twitter.com/BillGates&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>일부 개발자는 JSON 모델이 애플리케이션 코드와 저장 계층 간 임피던스 불일치를 줄인다고 생각한다.&lt;/p>
&lt;ul>
&lt;li>물론 데이터 부화화 형식으로서 JSON의 문제도 있음(4장)&lt;/li>
&lt;/ul>
&lt;p>JSON 표현은 다중 테이블 스키마보다 더 나은 &lt;strong>지역성&lt;/strong>(locality)을 갖는다.&lt;/p>
&lt;ul>
&lt;li>관계형 예제에서 프로필을 가져오려면 다중 질의를 수행하거나 &lt;code>users&lt;/code> 테이블과 그 하위 테이블 간에 난잡한 다중 조인이 필요함&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-1.png"
width="726"
height="330"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-1_huf01bd4b866b0b0735bdca555b8616a7f_45548_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-1_huf01bd4b866b0b0735bdca555b8616a7f_45548_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="트리 구조를 형성하는 일대다 관계"
class="gallery-image"
data-flex-grow="220"
data-flex-basis="528px"
>&lt;/p>
&lt;p>사용자 프로필에서 사용자에서 직위, 학력 기록, 연락처 정보로 대응되는 일대다 관계는 의미상 데이터 트리 구조와 같다.&lt;/p>
&lt;ul>
&lt;li>이러한 트리 구조는 JSON 표현에서 명시적으로 드러나게된다.&lt;/li>
&lt;/ul>
&lt;h3 id="다대일과-다대다-관계">다대일과 다대다 관계&lt;/h3>
&lt;p>이력서 예시에서 &lt;code>region_id&lt;/code>와 &lt;code>industry_id&lt;/code>는 평문이 아닌 외래 키인데, 지리적 지역과 업계 표준 목록으로 드롭다운 리스트나 자동 완성 기능을 만들어 사용자가 선택하게 하는 데는 다음과 같은 장점이 있다.&lt;/p>
&lt;ul>
&lt;li>프로필 간 일관된 스타일 철자&lt;/li>
&lt;li>모호함 회피(이름이 같은 여러 도시 등)&lt;/li>
&lt;li>갱신의 편의성
&lt;ul>
&lt;li>이름이 한 곳에만 저장되므로 이름을 변경해야 하는 경우 전반적인 갱신이 쉬움&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>현지화 지원
&lt;ul>
&lt;li>글로벌 서비스의 경우 표준 목록을 현지화하는데 용이함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>더 나은 검색
&lt;ul>
&lt;li>검색할 특정 항목이 특정 지역 목록에 포함된다는 것을 부호화하여 더 정확한 검색 결과를 얻을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>ID나 텍스트 문자열의 저장 여부는 중복의 문제로 텍스트로 저장하게되면 같은 의미의 데이터가 중복된다.&lt;/p>
&lt;blockquote>
&lt;p>비정규화는 데이터 중복을 일부로 발생시키는 방법인데 이후 다룸&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>중복된 데이터를 정규화하려면 &lt;strong>다대일&lt;/strong> 관계가 필요한데 이는 문서 모델에 적합하지 않다.&lt;/p>
&lt;p>관계형 데이터베이스에서는 조인이 쉬어 ID로 다른 테이블의 로우를 참조하는 방식이 일반적이지만, 문서 데이터베이스에서는 일대다 트리 구조를 위해 조인이 필요하지 않지만 조인에 댛나 지원이 보통 약하다.&lt;/p>
&lt;p>데이터베이스가 조인을 지원하지 않으면 데이터베이스에 대한 다중 질의를 만들어 애플리케이션 코드에서 조인을 흉내 내야 한다.&lt;/p>
&lt;p>더욱이 애플리케이션의 초기 버전이 조인 없는 문서 모델에 적합하더라도 애플리케이션에 기능을 추가하면서 데이터는 점차 상호 연결되는 경향이 있다.&lt;/p>
&lt;ul>
&lt;li>예시에서는 직장, 학교, 추천서 등&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-2.png"
width="726"
height="500"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-2_hu1901cea60f5abd3dcdc7332c37186851_87478_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-2_hu1901cea60f5abd3dcdc7332c37186851_87478_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="다대다 관계로 이력서 확장"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="348px"
>&lt;/p>
&lt;h3 id="문서-데이터베이스는-역사를-반복하고-있나">문서 데이터베이스는 역사를 반복하고 있나?&lt;/h3>
&lt;p>문서 데이터베이스와 NoSQL은 데이터베이스에서 다대다 관계를 표현하는 제일 좋은 방법에 대한 논쟁을 다시 열었다.&lt;/p>
&lt;p>1970년대 많이 사용된 데이터베이스로 IBM의 정보 관리 시스템(Information Management System, IMS)은 &lt;strong>계층 모델&lt;/strong>이라 부르는 간단한 데이터 모델을 사용했는데, JSON 모델과 매우 유사하다.&lt;/p>
&lt;p>이때 관계형 모델에 대한 한계를 극복하기 위해 대표적으로 &lt;strong>관계형 모델&lt;/strong>(SQL로 세상을 지배중)과 &lt;strong>네트워크 모델&lt;/strong>이 제안되었는데, 해결하려는 문제가 지금 풀려는 문제와 매우 유사하다.&lt;/p>
&lt;h4 id="네트워크-모델">네트워크 모델&lt;/h4>
&lt;p>네트워크 모델은 코다실(Conference for Data Systems Languages, CODASYL)이 제안한 모델로 &lt;strong>코다실 모델&lt;/strong>이라고도 부른다.&lt;/p>
&lt;p>코다실 모델은 계층 모델을 일반화한다.&lt;/p>
&lt;ul>
&lt;li>계층 모델의 트리 구조에서 모든 레코드는 정확하게 하나의 부모가 있지만, 네트워크 모델에서는 레코드는 다중 부모가 있을 수 있다.&lt;/li>
&lt;li>네트워크 모델에서 레코드 간 연결은 왜래 키 보다는 프로그래밍 언어의 포인터와 더 비슷하다.&lt;/li>
&lt;/ul>
&lt;p>레코드에 접근하는 유일한 방법은 최상위 레코드(root record)에서 시작하는 경로를 따라가는 것이다.(&amp;ldquo;접근 경로&amp;quot;라고 함)&lt;/p>
&lt;ul>
&lt;li>다대다 관계는 다양한 다른 경로가 같은 레코드로 이어질 수 있으므로, 네트워크 모델을 사용하는 프로그래머는 경로의 맨 앞에서 이런 다양한 접근 경로를 계속 추적해야 한다.&lt;/li>
&lt;/ul>
&lt;p>코다실에서 질의는 레코드 목록을 반복해 접근 경로를 따라 데이터베이스의 끝에서 끝까지 커서를 움직여 수행되며, 레코드가 다중 부모를 가진다면 애플리케이션 코드는 다양한 관계를 모두 추적해야한다.&lt;/p>
&lt;ul>
&lt;li>수동 접근 경로 선택은 매우 제한된 하드웨어 성능을 가장 효율적으로 사용할 수 있었지만 데이터베이스 질의와 갱신을 위한 코드가 복잡하고 유연하지 못했다.&lt;/li>
&lt;/ul>
&lt;p>계층 모델과 네트워크 모델 모두, 원하는 데이터에 대한 결오가 없다면 어려운 상황에 놓인다.&lt;/p>
&lt;ul>
&lt;li>접근 경로를 변경할 수 있지만 아주 많은 수작업 데이터베이스 질의 코드를 살펴야한다.&lt;/li>
&lt;li>새로운 접근 경로를 다루기 위해 재작성 해야한다.&lt;/li>
&lt;/ul>
&lt;p>애플리케이션의 데이터 모델을 바꾸는 작업은 매우 어려운 일이었다.&lt;/p>
&lt;h4 id="관계형-모델">관계형 모델&lt;/h4>
&lt;p>관계형 모델이 하는 일은 알려진 모든 데이터를 배치하는 것이다.&lt;/p>
&lt;ul>
&lt;li>관계(테이블)는 단순히 튜플(로우)의 컬렉션이 전부이다.&lt;/li>
&lt;li>복잡한 중첩 구조와 데이터를 보고 싶을 때 따라가야 할 복잡한 접근 경로가 없다.&lt;/li>
&lt;/ul>
&lt;p>임의 조건과 일치하는 테이블의 일부 또는 모든 로우를 선택해서 읽을 수 있고 일부 칼럼을 키로 지정해 칼럼과 일치하는 특정 로우를 읽을 수 있다.&lt;/p>
&lt;p>다른 테이블과의 외래 키 관계에 대해 신경 쓰지 않고 임의 테이블에 새 로우를 삽입할 수 있다.&lt;/p>
&lt;p>관계형 데이터베이스에서 질의 최적화기(query optimizer)는 네트워크 모델의 접근 경로와 같은 실행 계획을 선택한다.&lt;/p>
&lt;p>따라서 애플리케이션 개발자가 접근 경로를 따로 생각할 필요는 없으며, 새로운 방식으로 데이터에 질의하고 싶다면 새로운 색인을 선언하면 잘의는 자동으로 가장 적합한 색인을 사용하게 된다.&lt;/p>
&lt;ul>
&lt;li>관계형 모델은 애플리케이션에 새로운 기능을 추가하는 작업이 훨씬 쉽다.&lt;/li>
&lt;/ul>
&lt;h4 id="문서-데이터베이스와의-비교">문서 데이터베이스와의 비교&lt;/h4>
&lt;p>문서 데이터베이스는 별도 테이블이 아닌 상위 레코드 내에 중첩된 레코드를 저장한다.&lt;/p>
&lt;p>하지만 다대일과 다대다 관계를 표현할 때 관계형 데이터베이스와 문서 데이터베이스는 근본적으로 다르지 않다.&lt;/p>
&lt;ul>
&lt;li>둘 다 관련 항목은 고유한 식별자로 참조&lt;/li>
&lt;li>관계형 모델에서는 &lt;strong>외래 키&lt;/strong>, 문서 모델에서는 &lt;strong>문서 참조&lt;/strong>(document reference)&lt;/li>
&lt;/ul>
&lt;p>이 식별자는 조인이나 후속 질의를 사용해 읽기 시점을 확인한다.&lt;/p>
&lt;h3 id="관계형-데이터베이스와-오늘날의-문서-데이터베이스">관계형 데이터베이스와 오늘날의 문서 데이터베이스&lt;/h3>
&lt;p>관계형 데이터베이스와 문서 데이터베이스를 비교할 때 많은 부분을 고려해야하지만 데이터 모델의 차이점에만 집중한다.&lt;/p>
&lt;p>문서 데이터 모델을 선호하는 주요 이유는 &lt;strong>스키마 유연성&lt;/strong>, &lt;strong>지역성에 기인한 더 나은 성능&lt;/strong> 때문이고 일부 애플리케이션의 경우 애플리케이션에서 사용하는 데이터 구조와 더 까깝기 때문이다.&lt;/p>
&lt;p>관계형 모델은 조인, 다대일, 다대다 관계를 더 잘 지원함으로써 문서 데이터 모델에 대항한다.&lt;/p>
&lt;h4 id="어떤-데이터-모델이-애플리케이션-코드를-더-간단하게-할까">어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?&lt;/h4>
&lt;p>애플리케이션에서 데이터가 문서와 비슷한 구조라면 문서 모델을 사용하는 것이 좋다.&lt;/p>
&lt;ul>
&lt;li>문서와 비슷한 구조를 여러 테이블로 나누어 찢는(shredding) 관계형 기법은 다루기 힘든 스키마와 불필요하게 복잡한 애플리케이션 코드를 발생시킨다.&lt;/li>
&lt;/ul>
&lt;p>문서 모델은 문서 내 중첩 항목을 바로 참조할 수는 없다는 제한으로 인해 &amp;ldquo;사용자 251의 직위 목록의 두 번째 항목&amp;quot;과 같이 표현해야하지만, 문서가 너무 깊게 중첩되지 않으면 일반적으로 문제되진 않는다.&lt;/p>
&lt;p>문서 데이터베이스의 미흡한 조인 지원은 애플리케이션에 따라 문제일 수 일 수 있지만 아닐수도 있다.&lt;/p>
&lt;ul>
&lt;li>ex) 어떤 시점에 발생한 이벤트를 기록하는 문서 데이터베이스를 사용하는 분석 애플리케이션&lt;/li>
&lt;/ul>
&lt;p>하지만 애플리케이션에서 다대다 관계를 사용한다면 문서 모델은 매력이 떨어진다.&lt;/p>
&lt;ul>
&lt;li>비정규화로 조인의 필요성 줄이기가 가능하지만 애플리케이션 코드에서 비정규화된 데이터의 일관성을 유지하기 위한 추가 작업 필요&lt;/li>
&lt;li>조인은 애플리케이션 코드에서 데이터베이스에 다중 요청을 만들어 흉내낼 수 있지만 복잡도가 높고, 조인보다 느림
이러한 경우 문서 모델을 사용하는 것이 훨씬 더 복잡한 애플리케이션 코드와 나쁜 성능으로 이어질 수 있다.&lt;/li>
&lt;/ul>
&lt;p>일반적으로 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 만드는지는 데이터 항목 간에 존재하는 관계 유형에 따라 다르다.&lt;/p>
&lt;ul>
&lt;li>상호 연결이 많은 데이터의 경우
&lt;ul>
&lt;li>문서 모델: 곤란&lt;/li>
&lt;li>관계형 모델: 무난&lt;/li>
&lt;li>그래프 모델: 매우 자연스러움&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="문서-모델에서의-스키마-유연성">문서 모델에서의 스키마 유연성&lt;/h4>
&lt;p>대부분의 문서 데이터베이스는 스키마를 강요하지 않는데, 이는 임의의 키와 값을 문서에 추가할 수 있고 읽을 때 클라이언트는 문서에 포함된 필드의 존재 여부를 보장하지 않는다는 의미이다.&lt;/p>
&lt;p>문서 데이터베이스는 종종 &lt;strong>스키마리스&lt;/strong>(schema-less)라고 부르는데, 오해의 소지가 있다. 보통은 읽는 코드는 어떤 구조를 가정하므로, 암묵적인 스키마가 있지만 강요하지 않는다는 뜻이 더 정확하다.&lt;/p>
&lt;ul>
&lt;li>쓰기 스키마(schema-on-write)
&lt;ul>
&lt;li>관계형 데이터베이스의 전통적인 접근 방식&lt;/li>
&lt;li>스키마는 명시적이고 데이터베이스는 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>읽기 스키마(schema-on-read)
&lt;ul>
&lt;li>데이터 구조는 암묵적이고 데이터를 읽을 때만 해석&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>데이터베이스에서 스키마 강제는 논쟁의 여지가 있는 주제이며 일반적으로 옳고 그른 정답은 없다.&lt;/p>
&lt;p>접근 방식 간 차이는 애플리케이션이 데이터 타입을 변경하고자 할 때 특히 뚜렷이 나타나는데, 문서 데이터베이스에서는 새로운 필드를 가진 새로운 문서를 작성하기 시작하고 애플리케이션에서는 예전 문서를 읽은 경우를 처리하는 코드만 있으면 된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">if (user &amp;amp;&amp;amp; user.name &amp;amp;&amp;amp; !user.first_name) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // Documents written before Dec 8, 2013 don&amp;#39;t have first_name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> user.first_name = user.name.split(&amp;#34; &amp;#34;)[0];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>데이터베이스 스키마에서는 보통 마이그레이션(migration)을 수행한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ADD&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COLUMN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">text&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">UPDATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">split_part&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- PostgreSQL
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">UPDATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">substring_index&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- MySQL
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>스키마 변경은 느리고 중단시간을 요구하기 때문에 평판이 나쁘지만, 대부분의 관계형 데이터베이스 시스템에서 엄청 느리지는 않다.&lt;/p>
&lt;ul>
&lt;li>MySQL은 예외적으로 &lt;code>ALTER TABLE&lt;/code>시 전체 테이블을 복사하기 때문에 큰 테이블을 변경할 때 수 분에서 수 시간까지 중단 시간이 발생할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>큰 테이블에 &lt;code>UPDATE&lt;/code>문을 실행하면 모든 로우가 재작성될 수 있기 때문에 어떤 데이터베이스는 오래 걸릴수 있다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션은 입력될 항목이 기본값인 널로 설정되게 남겨두고 문서 데이터베이스처럼 읽는 시점에 채울 수도 있다.&lt;/li>
&lt;/ul>
&lt;p>읽기 스키마 접근 방식은 컬렉션 안의 항목이 어떤 이유로 모두 동일한 구조가 아닐 때(데이터가 여러 다른 유형으로 구성돼 있을 때) 유용하다.&lt;/p>
&lt;ul>
&lt;li>다른 여러 유형의 오브젝트가 있고 각 유형의 오브젝트별로 자체 테이블에 넣는 방법은 실용적이지 않다.&lt;/li>
&lt;li>사용자가 제어할 수 없고 언제나 변경 가능한 외부 시스템에 의해 데이터 구조가 결정된다.&lt;/li>
&lt;/ul>
&lt;p>하지만 모든 레코드가 동일한 구조라서 예상 가능하다면 스키마가 문서화와 구조를 강제하기 위한 유용한 메커니즘이다.&lt;/p>
&lt;h4 id="질의를-위한-지역성">질의를 위한 지역성&lt;/h4>
&lt;p>문서는 보통 JSON, XML로 부호화된 단일 연속 문자열이나(MongoDB의 BSON) JSON 또는 XML의 이진 변형으로 저장된다.&lt;/p>
&lt;p>애플리케이션이 자주 전체 문서에 접근해야 할 때 &lt;strong>저장소 지역성&lt;/strong>(storage locality)을 활용하면 성능 이점이 있다.&lt;/p>
&lt;ul>
&lt;li>처음 봤던 이력서 예시처럼 데이터가 다중 테이블로 나눠졌으면 전체를 검색하기 위해 다중 색인 검색이 필요하므로 더 많은 디스크 탐색이 필요하다.&lt;/li>
&lt;/ul>
&lt;p>지역성의 이점은 한 번에 해당 문서의 많은 부분을 필요로 하는 경우에만 적용된다.&lt;/p>
&lt;ul>
&lt;li>문서의 작은 부분에만 접근해도 전체 문서를 적재해야 하기에 큰 문서에서는 낭비일 수 있다.&lt;/li>
&lt;li>문서를 갱신할 때도 보통 전체 문서를 재작성 해야한다.&lt;/li>
&lt;li>부호화된 문서의 크기를 바꾸지 않는 수정은 쉽게 수행할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이런 이유로 일반적으로 문서를 아주 작게 유지하면서 문서의 크기가 증가하는 쓰기를 피하라고 권장한다.&lt;/p>
&lt;ul>
&lt;li>이 성능 제한 때문에 문서 데이터베이스가 유용한 상황이 많이 줄어든다.&lt;/li>
&lt;/ul>
&lt;p>지역성을 위해 관련 데이터를 함께 그룹화하는 개념이 문서 모델에만 국한되지는 않는다는 점이 중요하다.&lt;/p>
&lt;ul>
&lt;li>구글의 스패너(Spanner) 데이터베이스는 부모 테이블 내에 테이블의 로우를 교차 배치되게끔 선언하는 스키마를 허용하여 관계형 데이터 모델에서 지역성 특성을 동일하게 제공&lt;/li>
&lt;li>오라클은 &lt;strong>다중 테이블 색인 클러스터 테이블&lt;/strong>(multi-table index cluster table)을 사용해 관계형 데이터베이스에서 지역성을 제공&lt;/li>
&lt;li>빅테이블(Bigtable) 데이터 모델의 &lt;strong>컬럼 패밀리&lt;/strong>(column family)개념(카산드라, HBase)이 지역성 관리와 유사항 목적이 있음&lt;/li>
&lt;/ul>
&lt;h4 id="문서-데이터베이스와-관계형-데이터베이스의-통합">문서 데이터베이스와 관계형 데이터베이스의 통합&lt;/h4>
&lt;p>대부분 관계형 데이터베이스 시스템은 2000년대 중반 이후로 XML을 지원한다.&lt;/p>
&lt;ul>
&lt;li>XML 문서의 저역적 수정 및 문서 내부 색인과 질의 기능 포함&lt;/li>
&lt;/ul>
&lt;p>그래서 문서 데이터베이스를 사용할 때와 매우 비슷한 데이터 모델을 애플리케이션이 사용할 수 있다.&lt;/p>
&lt;p>PostgreSQL 9.3, MySQL 5.7, DB2 10.5 부터는 JSON 문서에 대해 비슷한 수준의 지원 기능을 제공한다.&lt;/p>
&lt;ul>
&lt;li>웹 API용 JSON의 인기를 고려할 때, 그 밖의 관계형 데이터베이스도 선례를 쫒아 JSON 지원 기능을 추가할 가능성이 높아보임&lt;/li>
&lt;/ul>
&lt;p>문서 데이터베이스 쪽에서 본다면 리싱키DB는 질의 언어에서 관계형 조인을 지원하고 MongoDB 드라이버는 자동으로 데이터베이스 참조를 확인한다.&lt;/p>
&lt;ul>
&lt;li>실제로는 클라이언트 측 조인을 수행&lt;/li>
&lt;li>네트워크 왕복이 추가로 필요하고 최적화가 덜 되기 때문에 데이터베이스에서 수행되는 조인보다 느릴 수 있음&lt;/li>
&lt;/ul>
&lt;p>관계형 데이터베이스와 문서 데이터베이스는 시간이 지남에 따라 점점 더 비슷해지고 있다.&lt;/p>
&lt;p>만약 데이터베이스가 데이터를 문서처럼 다룰 수 있고 관계형 질의를 수행할 수 있다면 애플리케이션은 필요에 따라 가장 적합한 기능을 조합해 사용하면 된다.&lt;/p>
&lt;blockquote>
&lt;p>관계형과 문서형의 혼합 모델은 미래 데이터베이스들이 가야 할 올바른 길이다.🫨&lt;/p>
&lt;/blockquote></description></item><item><title>1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 어플리케이션</title><link>https://codemario318.github.io/post/designing-data-intensive-application/1/</link><pubDate>Thu, 02 Jan 2025 13:54:49 +0900</pubDate><guid>https://codemario318.github.io/post/designing-data-intensive-application/1/</guid><description>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/cover.png" alt="Featured image of post 1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 어플리케이션" />&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img.png"
width="2100"
height="2756"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_hu7c7d9bbab499c5082d7f275bac15d9e4_1376618_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_hu7c7d9bbab499c5082d7f275bac15d9e4_1376618_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 중심 어플리케이션 설계"
class="gallery-image"
data-flex-grow="76"
data-flex-basis="182px"
>&lt;/p>
&lt;p>오늘날 많은 애플리케이션은 &lt;strong>계산 중심&lt;/strong>(compute-intensive)과는 다르게 &lt;strong>데이터 중심&lt;/strong>(data-intensive)적이다.&lt;/p>
&lt;p>이러한 애플리케이션의 경우 CPU 성능보다 &lt;strong>데이터의 양&lt;/strong>, &lt;strong>데이터의 복잡도&lt;/strong>, &lt;strong>데이터의 변화 속도&lt;/strong>가 애플리케이션을 제한하는 요소이다.&lt;/p>
&lt;p>일반적으로 데이터 중심 애플리케이션은 공통으로 필요로 하는 기능을 제공하는 표준 구성 요소(standard building block)로 만든다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장(&lt;strong>데이터베이스&lt;/strong>)&lt;/li>
&lt;li>읽기 속도 향상을 위해 값비싼 수행 결과를 기억(&lt;strong>캐시&lt;/strong>)&lt;/li>
&lt;li>사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공(&lt;strong>검색 색인, search index&lt;/strong>)&lt;/li>
&lt;li>비동기 처리를 위해 다른 프로세스로 메시지 보내기(&lt;strong>스트림 처리, stream processing&lt;/strong>)&lt;/li>
&lt;li>주기적으로 대량의 누적된 데이터를 분석(&lt;strong>일괄 처리, batch processing&lt;/strong>)&lt;/li>
&lt;/ul>
&lt;p>애플리케이션마다 요구사항이 다르기 때문에 데이터베이스 시스템 도한 저마다 다양한 특성을 가지고 있다.&lt;/p>
&lt;ul>
&lt;li>캐싱을 위한 다양한 접근 방식, 검색 색인을 구축하는 여러 가지 방법 등&lt;/li>
&lt;/ul>
&lt;p>애플리케이션을 만들 때 어떤 도구와 어떤 접근 방식이 수행 중인 작업에 가장 적합한지 생각해야 한다.&lt;/p>
&lt;ul>
&lt;li>단 하나의 도구만으로 할 수 없는 것을 해야하는 경우 도구들을 결합하기 어려울 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이 책은 데이터 시스템의 원칙(principle)과 실용성(practicality), 이를 활용한 데이터 중심 애플리케이션을 개발하는 방법을 모두 담고있다.&lt;/p>
&lt;blockquote>
&lt;p>소개된 다양한 도구가 공통적으로 지닌 것은 무엇이고 서로 구별되는 것은 무엇인지, 어떠헥 그러한 특성을 구현해냈는지 알아본다.&lt;/p>
&lt;/blockquote>
&lt;p>그 전에 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 데이터 시스템을 구축하기 위한 가장 기초적인 노력을 살펴봐야한다.&lt;/p>
&lt;h2 id="데이터-시스템에-대한-생각">데이터 시스템에 대한 생각&lt;/h2>
&lt;p>일반적으로 데이터베이스, 큐, 캐시 등을 매우 다른 범주에 속하는 도구로 생각한다.&lt;/p>
&lt;p>데이터베이스와 메시지 큐는 표면적으로 비슷하더라도(얼마 동안 데이터를 저장함) 매우 다른 접근 패턴을 갖고 있어 서로 다른 성능 특성이 있기 때문에 구현 방식이 다르다.&lt;/p>
&lt;blockquote>
&lt;p>모든 것을 왜 &lt;strong>데이터 시스템&lt;/strong>이라는 포괄적 용어로 묶어야 하는가?&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>분류 간 경계가 흐려짐&lt;/strong>&lt;/p>
&lt;p>데이터 저장과 처리를 위한 여러 새로운 도구는 최근에 만들어졌고, 새로운 도구들은 다양한 사용 사례(use case)에 최적화되어 전통적인 분류에 딱 들어맞지 않는다.&lt;/p>
&lt;p>메시지 큐를 예시로 살펴보면&lt;/p>
&lt;ul>
&lt;li>레디스: 지속성을 보장하지 않음&lt;/li>
&lt;li>카프카: 데이터베이스처럼 지속성을 보장&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>광범위한 요구사항&lt;/strong>&lt;/p>
&lt;p>점점 더 많은 애플리케이션이 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없는 과도하고 광범위한 요구사항을 갖고있다.&lt;/p>
&lt;p>대신 작업(work)은 단일 도구에서 효율적으로 수행할 수 있는 태스크(task)로 나누고 다양한 도구들은 애플리케이션 코드를 이용해 서로 연결한다.&lt;/p>
&lt;ul>
&lt;li>메인 데이터베이스와 분리된 애플리케이션 관리 캐시 계층(멤캐시디, Memcached)이나 전문(full-text) 검색 서버(엘라스틱서치, 솔라)의 경우 메인 데이터베이스와 동기화된 캐시나 색인을 유지하는 것은 보통 애플리케이션 코드의 책임이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img_1.png"
width="2880"
height="2049"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_1_huf3ea3a46984851ffc8f25b1984abfd55_116627_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_1_huf3ea3a46984851ffc8f25b1984abfd55_116627_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="다양한 구성 요소를 결합한 데이터 시스템 아키텍처의 예"
class="gallery-image"
data-flex-grow="140"
data-flex-basis="337px"
>&lt;/p>
&lt;p>서비스 제공을 위해 각 도구를 결합할 때 서비스 인터페이스나 애플리케이션 프로그래밍 인터페이스(API)는 보통 클라이언트가 모르게 구현 세부사항을 숨긴다.&lt;/p>
&lt;ul>
&lt;li>기본적으로 좀 더 작은 범용 구성 요소들로 새롬고 특수한 목적의 데이터 시스템을 만든다.&lt;/li>
&lt;li>복합 데이터 시스템(composite data system)은 외부 클라이언트가 일관된 결과를 볼 수 있게끔 쓰기에서 캐시를 올바르게 무효화하거나 엡데이트 하는 등의 특정 보장 기능을 제공할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>여러 데이터 시스템을 설계, 통합하고 관리해야하는 요즘 개발자는 애플리케이션 개발자일 뿐 아니라 &lt;strong>데이터 시스템 설계자&lt;/strong>이기도 하다.&lt;/p>
&lt;hr>
&lt;p>데이터 시스템이나 서비스를 설계할 때 까다로운 문제가 많이 생긴다.&lt;/p>
&lt;ul>
&lt;li>내부적으로 문제가 있어도 데이터를 정확하고 완전하게 유지해야함&lt;/li>
&lt;li>시스템의 일부 성능이 저하되더라도 클라이언트에 일관되게 좋은 성능을 제공해야함&lt;/li>
&lt;li>부하 증가를 다루기 위해 규모를 확장할 수 있어야함&lt;/li>
&lt;li>서비스를 위해 좋은 API를 설계해야함&lt;/li>
&lt;/ul>
&lt;p>뿐만 아니라 관련자의 기술 숙련도, 기존 시스템의 의존성, 전달 시간 척도, 다양한 종류의 위험에 대한 조직의 내성, 규제 제약 등은 시스템 설계에 영향을 줄 수 있는 많은 요소이다.&lt;/p>
&lt;p>이런 요소는 상황에 크게 좌우되는 요소이므로 이 책에서는 &lt;strong>대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사에 중점&lt;/strong>을 둔다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>신뢰성&lt;/strong>(Reliability)
&lt;ul>
&lt;li>하드웨어나 소프트웨어 결함, 인적 오류 같은 &lt;strong>역경&lt;/strong>에 직면하더라도 시스템은 지속적으로 올바르게 동작(원하는 성능 수준에서 정확한 기능을 수행)해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>확장성&lt;/strong>(Scalability)
&lt;ul>
&lt;li>시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>유지보수성&lt;/strong>(Maintainability)
&lt;ul>
&lt;li>여러 다양한 사람들이 시스템 상에서 작업할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있어야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="신뢰성">신뢰성&lt;/h2>
&lt;p>소프트웨어의 경우 신뢰성에 대한 일반적인 기대치는 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션은 사용자가 기대한 기능을 수행한다.&lt;/li>
&lt;li>시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다.&lt;/li>
&lt;li>시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.&lt;/li>
&lt;li>시스템은 허가되지 않은 접근과 오남용을 방지한다.&lt;/li>
&lt;/ul>
&lt;p>이러한 내용들이 올바르게 동작함을 의미하는 경우, 대략 &amp;ldquo;&lt;strong>무언가 잘못 되더라도 지속적으로 올바르게 동작함&lt;/strong>&amp;ldquo;을 신뢰성의 의미로 이해할 수 있다.&lt;/p>
&lt;h3 id="결함">결함&lt;/h3>
&lt;p>잘못될 수 있는 일을 &lt;strong>결함&lt;/strong>(fault)이라 부른다.&lt;/p>
&lt;p>그리고 결함을 예측하고 대처할 수 있는 시스템을 &lt;strong>내결함성&lt;/strong>(fault-tolerant) 또는 &lt;strong>탄력성&lt;/strong>(resilient)을 지녔다고 말한다.&lt;/p>
&lt;p>모든 종류의 결함을 견딜 수 있는 시스템은 실제로 실현 가능하지 않으므로 &lt;strong>특정 유형&lt;/strong>의 결함 내성에 대해서만 이야기하는 것이 타당하다.&lt;/p>
&lt;p>결함과 장애(failure)는 다르다.&lt;/p>
&lt;ul>
&lt;li>결함
&lt;ul>
&lt;li>사양에서 벗어난 시스템의 한 구성 요소&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>장애
&lt;ul>
&lt;li>사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>결함 확률을 0으로 줄이는 것은 불가능하므로 결함으로 인해 장애가 발생하지 않게끔 내결함성 구조를 설계하는 것이 좋다.&lt;/p>
&lt;ul>
&lt;li>이 책에서는 신뢰할 수 없는 여러 부품들로 신뢰할 수 있는 시스템을 구축하는 다양한 기법을 배운다.&lt;/li>
&lt;/ul>
&lt;p>실제 많은 중대한 버그는 미흡한 오류 처리에서 기인한다.&lt;/p>
&lt;ul>
&lt;li>내결함성 시스템에서 고의적으로 결함을 유도함으로써 내결함성 시스템을 지속적으로 훈련하고 테스트해서 결함이 자연적으로 발생했을 때 올바르게 처리할 수 있다는 자신감을 높인다.&lt;/li>
&lt;li>ex) 넷플릭스의 &lt;strong>카오스 몽키&lt;/strong>(Chaos Monkey)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>일반적으로 결함 예방을 넘어 내결함성을 갖는 것을 선호하지만, 해결책이 없는 경우는 예방책이 필수적이다.&lt;/p>
&lt;ul>
&lt;li>보안 문제: 공격자가 시스템을 손상시키고 민감한 데이터에 대한 접근 권한을 얻는다면 되돌릴 수 없다.&lt;/li>
&lt;/ul>
&lt;h3 id="하드웨어-결함">하드웨어 결함&lt;/h3>
&lt;p>시스템 장애의 대표적인 예시로, 규모가 큰 데이터센터에서 일하는 사람은 많은 장비를 다룰 경우 이 같은 일은 늘상 일어난다고 말한다.&lt;/p>
&lt;ul>
&lt;li>10,000개의 디스크로 구성된 저장 클러스터는 평균적으로 하루에 한 개의 디스크가 죽는다고 예상해야한다.&lt;/li>
&lt;/ul>
&lt;p>시스템 장애율을 줄이기 위한 대표적인 방법은 각 하드웨어 구성 요소에 중복(redundancy)을 추가하는 방법이다.&lt;/p>
&lt;ul>
&lt;li>구성 요소가 죽으면 고장 난 구성 요소가 교체되는 동안 중복된 구성 요소를 대신 사용한다.&lt;/li>
&lt;/ul>
&lt;p>이런 접근 방식은 하드웨어 문제로 장애가 발생하는 것은 완전히 막으룻는 없지만 이해하기 쉽고 보통 수년 간 장비가 중단되지 않고 계속 동작할 수 있게 한다.&lt;/p>
&lt;p>최근까지 단일 장비의 전체 장애는 매우 드물기 때문에 대부분의 애플리케이션은 하드웨어 구성 요소의 중복으로 충분하여, 다중 장비 중복은 고가용성(high availability)이 절대적으로 필수적은 소수의 애플리케이션에서만 필요했다.&lt;/p>
&lt;ul>
&lt;li>새 장비에 백업을 매우 빠르게 복원할 수 있는 경우 중단시간(downtime)은 대부분의 애플리케이션에 치명적이지 않다.&lt;/li>
&lt;/ul>
&lt;p>하지만 데이터 양과 애플리케이션의 계산 요구가 늘어나면서 더 많은 애플리케이션이 많은 수의 장비를 사용하게 됐고 이와 비례해 하드웨어 결함율도 증가했다.&lt;/p>
&lt;p>따라서 소프트웨어 내결함성 기술을 사용하거나 하드웨어 중복성을 추가해 전체 장비의 손실을 견딜 수 있는 시스템으로 점점 옮겨가고 있으며, 이러한 시스템에는 운영상의 장점도 있다.&lt;/p>
&lt;ul>
&lt;li>장비를 재부팅 해야하는 경우 등&lt;/li>
&lt;/ul>
&lt;h3 id="소프트웨어-오류">소프트웨어 오류&lt;/h3>
&lt;p>보통 하드웨어 결함을 무작위적으고 서로 독립적이라고 생각한다.&lt;/p>
&lt;ul>
&lt;li>다수의 하드웨어 구성 요소에 동시 장애가 발생하는 경우는 드물다.&lt;/li>
&lt;/ul>
&lt;p>또 다른 부류의 결함으로 시스템 내 체계적 오류(systematic error)는 예상하기 더 어렵고 노드 간 상관관계 때문에 상관관계가 없는 하드웨어 결함보다 오히려 시스템 오류를 더욱 많이 유발하는 경향이 있다.&lt;/p>
&lt;ul>
&lt;li>잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그
&lt;ul>
&lt;li>ex) 리눅스 커널의 버그로 인해 많은 애플리케이션이 일제히 멈춰버린 원인니 된 2012년 6월 30일 윤초&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스&lt;/li>
&lt;li>시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스&lt;/li>
&lt;li>한 구성 요소의 작은 결함이 다른 구성 요소의 결함을 야기하고 차례차례 더 많은 결함이 발생하는 연쇄 장애(cascading failure)&lt;/li>
&lt;/ul>
&lt;p>이 같은 소프트웨어 결함을 유발하는 버그는 &lt;strong>특정 상황에 의해 발생하기 전까지 오랫동안 나타나지 않는다&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>소프트웨어에는 확여에 대한 일종의 가정이 있다는 시실을 알 수 있다.(일부 제외)&lt;/li>
&lt;/ul>
&lt;p>스프트웨어의 체계적 오류 문제는 신속한 해결책이 없다.&lt;/p>
&lt;ul>
&lt;li>시스템의 가정과 상호작용에 대해 주의 깊게 생각하기&lt;/li>
&lt;li>빈틈없는 테스트&lt;/li>
&lt;li>프로세스 격리(process isolation)&lt;/li>
&lt;li>죽은 프로세스의 재시작 허용&lt;/li>
&lt;li>프로덕션 환경에서 스스템 동작의 측정&lt;/li>
&lt;li>모니터링&lt;/li>
&lt;li>분석하기&lt;/li>
&lt;/ul>
&lt;p>위와 같은 여러 작은 일들이 문제 해결에 도움을 줄 수 있다.&lt;/p>
&lt;p>시스템이 무너가를 보장하길 기대한다면 수행 중에 이를 지속적으로 확인해 차이가 생기는 경우 경고를 발생시킬 수 있다.&lt;/p>
&lt;h3 id="인적-오류">인적 오류&lt;/h3>
&lt;p>사람은 소프트웨어 시스템을 설계하고 구축하며, 운영자로서 시스템을 계속 운영한다.&lt;/p>
&lt;ul>
&lt;li>대규모 인터넷 서비스에 대한 연구에 따르면 운영자의 설정 오류가 중단의 주요 원인이며, 하드웨어 결함은 중단 원인의 10~20%에 그친다.&lt;/li>
&lt;/ul>
&lt;p>다양한 접근 방식을 결합하여 신뢰성 있는 시스템을 만들어야 한다.&lt;/p>
&lt;ul>
&lt;li>오류의 가능성을 최소하 하는 방향으로 시스템을 설계
&lt;ul>
&lt;li>잘 설계된 추상화, API, 관리 인터페이스 사용으로 옳은 일은 쉽게 하고, 잘못된 일은 막는다.&lt;/li>
&lt;li>인터페이스가 지나치게 제한적이면 제한된 인터페이스를 사람들은 피해 작업하는 경향이 있어, 올바르게 작동하게끔 균형을 맞추기 어렵다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사람이 가장 많이 실수하는 장소(부분)에서 사람의 실수로 장애가 발생할 수 있는 부분을 분리
&lt;ul>
&lt;li>비 프로덕션 샌드박스(sandbox) 환경 제공&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트
&lt;ul>
&lt;li>코너 케이스를 다루는 데 유용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>장애 발생의 영향을 최소화하기 위해 인적 오류를 빠르고 쉽게 복구할 수 있는 환경
&lt;ul>
&lt;li>설정 변경 내역을 빠르게 롤백&lt;/li>
&lt;li>새로운 코드를 서서히 롤하웃하게 구성(예상치 못한 버그가 일부 사용자에게만 영향이 미치도록)&lt;/li>
&lt;li>이전 계산이 잘못된 경우를 대비해 데이터 재계산 도구 제공&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책 마련
&lt;ul>
&lt;li>원격 측정(telemetry)&lt;/li>
&lt;li>모니터링은 조기에 경고 신호를 보내줄 수 있고 특정 가정이나 제한을 벗어나는지 확인할 수 있게 함&lt;/li>
&lt;li>문제가 발생했을 때 지표는 문제를 분석하는 데 매우 중요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>조작 교육과 실습을 진행&lt;/li>
&lt;/ul>
&lt;h3 id="신뢰성은-얼마나-중요할까">신뢰성은 얼마나 중요할까?&lt;/h3>
&lt;p>신뢰성은 원자력 발전소나 항공 교통 관제 소프트웨어만을 위한 것이 아니며, 일상적인 애플리케이션도 안정적으로 작동해야한다.&lt;/p>
&lt;p>비즈니스 애플리케이션에서 버그는 생산성 저하의 원인이고 전자 상거래 사이트의 중단은 매출에 손실이 발생하고 명성에 타격을 준다는 면에서 많은 비용이 든다.&lt;/p>
&lt;p>중요하지 않은 애플리케이션도 사용자에 대한 책임이 있다.&lt;/p>
&lt;ul>
&lt;li>사소한 데이터라도 누군가에게는 매우 소중할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>비용을 줄이려 신뢰성을 희생해야 하는 경우, 비용을 줄여하는 시점을 매우 잘 알고 있어야 한다.&lt;/p>
&lt;h2 id="확장성">확장성&lt;/h2>
&lt;p>시스템이 현재 안정적으로 동작한다고 해서 미래에도 아정적으로 동작한다는 보장은 없다.&lt;/p>
&lt;p>성능 저하를 유발하는 흔한 이뉴 중 하나는 부하 증가로, 확장성은 증가한 부하에 대처하는 시스템 능력을 설명한다.&lt;/p>
&lt;p>확장성을 논한다는 것은 &amp;ldquo;&lt;strong>시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?&lt;/strong>&amp;ldquo;와 &amp;ldquo;&lt;strong>추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?&lt;/strong>&amp;rdquo; 같은 질문을 고여한다는 의미이다.&lt;/p>
&lt;h3 id="부하-기술하기">부하 기술하기&lt;/h3>
&lt;p>무엇보다 시스템의 현재 부하를 간결하게 기술해야 부하 성장 질문을 논의할 수 있다.&lt;/p>
&lt;p>부하는 &lt;strong>부하 매개변수&lt;/strong>(load parameter)라 부르는 몇 개의 숫자로 내타낼 수 있으며, 가장 적합한 부하 매개변수 선택은 시스템 설계에 따라 달라진다.&lt;/p>
&lt;ul>
&lt;li>웹 서버의 초당 요청 수&lt;/li>
&lt;li>데이터베이스의 읽기 대 쓰기 비율&lt;/li>
&lt;li>대화방의 동시 활성 사용자(active user)&lt;/li>
&lt;li>캐시 적중률 등&lt;/li>
&lt;/ul>
&lt;p>평균적인 경우가 중요할 수도 있고 소수의 극단적인 경우가 병목 현상의 우너인일 수도 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>트위터 예시&lt;/strong>&lt;/p>
&lt;p>트위터의 주요 두 가지 동작은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>트윗 작성
&lt;ul>
&lt;li>사용자는 팔로워에게 새로운 메시지를 게시할 수 있다.&lt;/li>
&lt;li>평균 초당 4.6k 요청, 피크일 때 12k 요청 이상&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>홈 타임라인
&lt;ul>
&lt;li>사용자는 팔로우한 사람이 작성한 트윗을 볼 수 있다.&lt;/li>
&lt;li>초당 300k 요청&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>단순히 초당 12,000쓰기 처리는 상당히 쉽지만, 트위터의 확장성 문제는 주로 트윗 양이 아닌 팬 아웃(fan-out) 때문이다.&lt;/p>
&lt;p>개별 사용자는 많은 사용자를 팔로우하고 많은 사람이 개별 사용자를 팔로우한다.&lt;/p>
&lt;ol>
&lt;li>트윗 작성은 간단히 새로운 트윗 전역 컬렉션에 삽입.
&lt;ul>
&lt;li>사용자가 자신의 홈 타임라인을 요청하면 팔로우하는 모든 사람을 찾고, 이 사람들의 모든 트윗을 찾아 시간순으로 정렬해서 합친다.&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tweets&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tweets&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tweets&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sender_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">follows&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">follows&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">followee_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">follows&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">follower_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">current_user&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 수신 사용자용 트윗 유편함처럼 개별 사용자의 홈 타임라인 캐시를 유지.
&lt;ul>
&lt;li>사용자가 트윗을 작성하면 해당 사용자를 팔오우하는 사람을 모두 찾고 팔로워 각자의 홈 타임라인 캐시에 새로운 트윗을 삽입&lt;/li>
&lt;li>홈 타임라인의 읽기 요청은 요청 결과를 미리 계산했으므로 비용이 저렴&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img_2.png"
width="2880"
height="1037"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_2_huef454c28ed509f14d0506aa4413f3fba_72867_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_2_huef454c28ed509f14d0506aa4413f3fba_72867_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="트위터 홈 타임라인 구현을 위한 간략한 관계형 스키마"
class="gallery-image"
data-flex-grow="277"
data-flex-basis="666px"
>&lt;br>
&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img_3.png"
width="2880"
height="1037"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_3_huf1eee131e293bb95b1294c4be771ef1f_79137_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_3_huf1eee131e293bb95b1294c4be771ef1f_79137_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="매개변수와 함께 팔로워에게 트윗을 전송하기 위한 트위터의 데이터 파이프라인"
class="gallery-image"
data-flex-grow="277"
data-flex-basis="666px"
>&lt;/p>
&lt;p>트위터의 첫 번째 버전은 1을 사용했는데, 시스템이 홈 타임라인 질의 부하를 버텨내기 위해 고군분투 해야했고, 그 결과 2로 전환했다.&lt;/p>
&lt;ul>
&lt;li>평균적으로 트윗 게시 요청량이 홈 타임라인 읽기 요청량에 비해 수백 배 적기 때문에 2가 훨씬 잘 동작함
이 경우는 쓰기 시점에 더 많은 일을 하고, 일기 시점에 적은 일을 하는 것이 바람직하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>2의 불리한 점은 트윗 작성이 많은 부가 작업을 필요로 한다는 점이다.&lt;/p>
&lt;ul>
&lt;li>평균 트윗이 약 75명의 팔로워에게 전달되므로 초당 4.6k 트윗은 홈 타임라인 캐시에 초당 345k건의 쓰기 요청 발생&lt;/li>
&lt;li>일부 사용자는 팔로워가 3천만명이 넘으므로 단일 트윗이 홈 타임라인에 3천만 건 이상의 쓰기 요청 발생 가능&lt;/li>
&lt;/ul>
&lt;p>트위터 사례에서 사용자당 팔로워의 분포는 팬 아웃 부하를 결정하기 때문에 확장성을 논의할 때 핵심 부하 매개변수가 된다.&lt;/p>
&lt;p>결과적으로 트위터는 접근 방식 2를 기반으로 하이브리드 형식으로 바꾸고 있다.&lt;/p>
&lt;ul>
&lt;li>대부분 사용자의 트윗은 계속해서 사람들이 작성할 때 홈 타임라인에 펼쳐지지만 유명인은 팬 아웃에서 제외된다.&lt;/li>
&lt;li>유명인의 트윗은 별도로 가져와 1처럼 읽는 시점에 사용자의 홈 타임라인에 합친다.&lt;/li>
&lt;/ul>
&lt;h3 id="성능-기술하기">성능 기술하기&lt;/h3>
&lt;p>일단 시스템 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있다.&lt;/p>
&lt;ul>
&lt;li>부하 매개변수를 증가시키고 시스템 자원은 병경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?&lt;/li>
&lt;li>부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까?&lt;/li>
&lt;/ul>
&lt;p>두 질문 모두 성능 수치가 필요하므로 시스템 성능에 대해 간단히 살펴본다.&lt;/p>
&lt;ul>
&lt;li>일괄 처리 시스템(ex. hadoop)
&lt;ul>
&lt;li>&lt;strong>처리량&lt;/strong>(throughput, 초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>온라인 시스템
&lt;ul>
&lt;li>서비스 &lt;strong>응답 시간&lt;/strong>(response time)&lt;/li>
&lt;li>클라이언트가 요청을 보내고 응답을 받는 사이의 시간&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>지연 시간(latency)과 응답 시간(response time)&lt;/strong>&lt;br>
응답 시간은 클라이언트 관점에서 본 시간으로, 요청을 처리하는 실제 시간 외에도 네트워크 지연과 큐 지연도 포함한다.&lt;br>
지연 시간은 요청이 처리되길 기다리는 시간으로, 서비스를 기다리며 휴지(latent) 상태인 시간을 말한다.&lt;/p>
&lt;/blockquote>
&lt;p>응답 시간은 매번 요청에 따라 달라지기 때문에, 단일 숫자가 아닌 측정 가능한 값의 분포로 생각해야한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img_4.png"
width="2880"
height="805"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_4_hu34112d46532c22af0f415ce8b7d25f2a_86463_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_4_hu34112d46532c22af0f415ce8b7d25f2a_86463_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="평균과 백분위 예시"
class="gallery-image"
data-flex-grow="357"
data-flex-basis="858px"
>&lt;/p>
&lt;p>대부분의 요청은 꽤 빠르지만 가끔 오래 걸리는 &lt;strong>특이 값(outlier)&lt;/strong> 이 있는데 다음과 같이 이유로 발생할 수 있다.&lt;/p>
&lt;ul>
&lt;li>백그라운드 프로세스의 컨텍스트 스위치&lt;/li>
&lt;li>네트워크 패킷 손실과 TCP 재전송&lt;/li>
&lt;li>가비지 컬렉션 휴지&lt;/li>
&lt;li>디스크에서 읽기를 강제하는 페이지 폴트&lt;/li>
&lt;li>서버 랙의 기계적인 진동 등&lt;/li>
&lt;/ul>
&lt;p>보고된 서비스 평균 응답 시간을 살피는 일이 일반적이지만, 전형적인 응답 시간을 알고 싶다면 평균은 좋은 지표는 아니다.&lt;/p>
&lt;ul>
&lt;li>얼마나 많은 사용자가 실제로 지연을 경험했는지 알 수 없음&lt;/li>
&lt;/ul>
&lt;p>일반적으로 평균보다는 &lt;strong>백분위&lt;/strong>(percentile)을 사용하는 편이 더 좋다.&lt;/p>
&lt;ul>
&lt;li>중앙값(median, p50)
&lt;ul>
&lt;li>사용자가 보통 얼마나 오랫동안 기다려야 하는지 알고 싶다면 좋은 지표&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>상위 백분위
&lt;ul>
&lt;li>p95, p99, p999 같은 상위 백분위를 통해특이 값이 얼마나 좋지 않은지 확인에 좋은 지표&lt;/li>
&lt;li>&lt;strong>꼬리 지연 시간(tail latency)&lt;/strong> 으로 알려진 상위 백분위 응답 시간은 서비스의 사용자 경험에 직접 영향을 주기 때문에 중요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>p9999 같이 최상위 백분위는 통제할 수 없는 임의 이벤트에 쉽게 영향을 받으므로 응답 시간을 줄이기가 매우 어려어 이점이 줄어든다.&lt;/p>
&lt;p>백분위는 서비스 수준 목표(service level objective, SLO)와 서비스 수준 협약서(service level agreement, SLA)에 자주 사용하고 기대 성능과 서비스 가용성르 정의하는 계약서에도 자주 등장한다.&lt;/p>
&lt;ul>
&lt;li>응답 시간 중앙값이 200밀리초 미만이고 99분위가 1초 미만인 경우 정상 서비스 상태로 간주하며 서비스 제공 시간은 99.9% 이상이어야 한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>선두 차단(head-of-line blocking)&lt;/strong>&lt;/p>
&lt;p>큐 대기 지연은 높은 백분위에서 응답 시간의 상당 부분을 차지한다.&lt;/p>
&lt;ul>
&lt;li>서버는 병렬로 소수의 작업만 처리할 수 있기 때문에 소수의 느린 요청 처리만으로 후속 요청 처리가 지체된다.&lt;/li>
&lt;li>서버에서 후속 요청이 빠르게 처리되더라도 이전 요청이 완료되길 기다리는 시간 때문에 클라이언트는 전체적으로 응답 시간이 느리다고 생각하게된다.&lt;/li>
&lt;/ul>
&lt;p>이런 문제로 인해 클라이언트 쪽 응답 시간 측정이 중요하다.&lt;/p>
&lt;hr>
&lt;p>시스템의 확장성을 테스트하려고 인위적으로 부하를 생성하는 경우 부하 생성 클라이언트는 응답 시간과 독립적으로 요청을 지속적으로 보내야한다.&lt;/p>
&lt;ul>
&lt;li>다음 요청을 보내기 전에 이전 요청이 완료되길 기다리면 테스트에서 인위적으로 대기 시간을 실제보다 더 짧게 만들어 평가를 왜곡한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img_5.png"
width="2880"
height="1304"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_5_hu4bbd8047ec59659dcb92a302da18488b_76022_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_5_hu4bbd8047ec59659dcb92a302da18488b_76022_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="요청을 처리하기 위해 여러 번 백엔드 호출이 필요한 상황에서 단 하나의 느린 백엔드 요청이 전체 최종 사용자 요청을 느리게 만든다."
class="gallery-image"
data-flex-grow="220"
data-flex-basis="530px"
>&lt;/p>
&lt;h3 id="부하-대응-접근-방식">부하 대응 접근 방식&lt;/h3>
&lt;p>부하 수준 1단계에 적합한 아키텍처로는 10배의 부하를 대응할 수 없기 때문에 급성장하는 서비스를 맡고 있다면 부하 규모의 자릿수가 바뀔 때마다 혹은 그보다 자주 아키텍처를 재검토해야 할지 모른다.&lt;/p>
&lt;p>확장성과 관련해 &lt;strong>용량 확장(scaling up, 수직 확장)&lt;/strong> 과 &lt;strong>규모 확장(scaling out, 수평 확장)&lt;/strong> 구분할 수 있다.&lt;/p>
&lt;p>다수의 장비에 부하를 분산하는 아키텍처를 &lt;strong>비공유(shared-noting)&lt;/strong> 아키텍처라 부르며, 단일 장비에서 수행될 수 있는 시스템은 보통 간단하지만 고사양 장비는 매우 비싸기 때문에 상당히 집약된 작업 부하는 대개 규모 확장을 피하지 못한다.&lt;/p>
&lt;p>현실적으로 좋은 아키텍처는 실용적인 접근 방식의 조합이 필요하다.&lt;/p>
&lt;ul>
&lt;li>적절한 사양의 장비 몇 대가 다량의 낮은 사양 가상 장비보다 여전히 훨씬 간단하고 저렴하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>일부 시스템은 &lt;strong>탄력적(elastic)&lt;/strong> 이다.&lt;/p>
&lt;ul>
&lt;li>부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가할 수 있다. 그렇지 않은 시스템은 수동으로 확장해야한다.&lt;/li>
&lt;/ul>
&lt;p>탄력적인 시스템은 부하를 예측할 수 없을 만큼 높은 경우 유용하지만, 수동으로 확장하는 시스템이 더 간단하고 운영상 예상치 못한 일이 더 적다.&lt;/p>
&lt;hr>
&lt;p>다수의 장비에 상태 비저앙(stateless) 서비스를 배포하는 일은 상당히 간단하지만, 단일 노드에 상태 유지(stateful) 데이터 시스템을 분산 설치하는 일은 아주 많은 복잡도가 추가적으로 발생한다.&lt;/p>
&lt;ul>
&lt;li>이런 이유로 확장 비용이나 데이터베이스를 분산으로 만들어야 하는 고가용성 요구가 있을 때 까지 단일 노드에 데이터베이스를 유지하는 것이 최근까지의 통념이다.&lt;/li>
&lt;/ul>
&lt;p>분산 시스템을 위한 도구와 추상화가 좋아지면서 이 통념이 적어도 일부 애플리케이션에서는 바뀌었다.&lt;/p>
&lt;ul>
&lt;li>대용량 데이터와 트래픽을 다루지 않는 사용 사례에도 분산 데이터 시스템이 향후 기본 아키텍처로 자리 잡을 가능성이 있다.&lt;/li>
&lt;/ul>
&lt;p>대개 대규모로 동작하는 시스템의 아키텍처는 해당 시스템을 사용하는 애플리케이션에 특화돼 있다.&lt;/p>
&lt;ul>
&lt;li>범용적으로 모든 상황에 맞는 확장 아키텍처는 없다.&lt;/li>
&lt;/ul>
&lt;p>아키텍처를 결정하는 요소는 읽기의 양, 쓰기의 양, 저장할 데이터의 양, 데이터의 복잡도, 응답 시간 요구사항, 접근 패턴 등이 있다.&lt;/p>
&lt;p>특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 무엇인지에 대한 가정을 바탕으로 구축한다.&lt;/p>
&lt;ul>
&lt;li>이 가정은 곧 부하 매개변수가 되며, 이 가정이 잘못되면 확장에 대한 엔지니어링 노력은 헛수고가 되고 최악의 경우 역효과를 낳을 수 있다.&lt;/li>
&lt;/ul>
&lt;p>스타트업 초기 단계나 검증되지 않은 제품의 경우 미래를 가정한 부하에 대비해 확장하기보다는 빠르게 반복해서 제품 기능을 개선하는 작업이 좀 더 중요하다.&lt;/p>
&lt;ul>
&lt;li>확장성을 갖춘 아키텍처가 특정 애플리케이션에 특화됐을 지라도 일너 아키텍처는 보통 익숙한 패턴으로 나열된 범용적인 구성 요소로 구축한다.&lt;/li>
&lt;/ul>
&lt;h2 id="유지보수성">유지보수성&lt;/h2>
&lt;p>소프트웨어 비용의 대부분은 지속해서 이어지는 유지보수에 들어간다.&lt;/p>
&lt;ul>
&lt;li>버그 수정, 시스템 운영 유지, 장애 조사, 시로운 플랫폼 적용, 새 사용 사례를 위한 변경, 기술 채무 상환, 새로운 기능 추가 등&lt;/li>
&lt;/ul>
&lt;p>모든 레거시 시스템은 각자 나름에 풀편함이 있어 이를 다루기 위해 일반적으로 추천할 만한 방법을 제시하는 일은 매우 어렵다.&lt;/p>
&lt;p>하지만 희망적인 점은 유지보수 중 고통을 최소화하고 레거시 소프트웨어를 직접 만들지 않게끔 소프투웨어를 설계할 수 있다는 점이다.&lt;/p>
&lt;p>그러기 위해 주의를 기울여야 할 소프트웨어 시스템 설계 원칙은 다음 세 가지이다.&lt;/p>
&lt;ul>
&lt;li>운용성(operability)
&lt;ul>
&lt;li>운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단순성(simplicity)
&lt;ul>
&lt;li>시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라&lt;/li>
&lt;li>사용자 인터페이스의 단순성과는 다르다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>발전성(evolvability)
&lt;ul>
&lt;li>엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라.&lt;/li>
&lt;li>요구사항 변경 같은 예기치 않은 사용 사례를 적용하기 쉽다.&lt;/li>
&lt;li>유연성, 수정 가능성, 적응성으로 알려져 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>신뢰성, 확장성을 달성하기 위한 쉬운 해결책은 없으므로, 운용성, 단순성, 발전성을 염두에 두고 시스템을 생각하려 노력해야한다.&lt;/p>
&lt;h3 id="운용성-운영의-편리함-만들기">운용성: 운영의 편리함 만들기&lt;/h3>
&lt;p>좋은 운영은 종종 나쁜 소프트웨어의 제약을 피하는 대안이 될 수 있다.&lt;/p>
&lt;p>하지만 좋은 소프트웨어라도 나쁘게 운영할 경우 작동을 신뢰할 수 없다는 말이 있다.&lt;/p>
&lt;ul>
&lt;li>운영 중 일부 측면은 자동화할 수 있고 또 자동화 해야한다.&lt;/li>
&lt;li>자동화를 처음 설정하고 제대로 동작하는지 확인하는 일은 여전히 사람의 몫이다.&lt;/li>
&lt;/ul>
&lt;p>시스템이 지속해서 원할하게 작동하려면 운영팀이 필수이며, 좋은 운영팀은 일반적으로 다음과 같은 작업 등을 책임진다.&lt;/p>
&lt;ul>
&lt;li>시스템 상태를 모니터링 하고 상태가 좋지 않다면 빠르게 서비스를 복원&lt;/li>
&lt;li>시스템 장애, 성능 저하 등의 문제의 원인을 추적&lt;/li>
&lt;li>보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지&lt;/li>
&lt;li>다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사하응ㄹ 손상을 입히기 전에 차단&lt;/li>
&lt;li>미래에 발생 가능한 문제를 예측해 문제가 발생하기 전에 해결(ex. 용량 계획 등)&lt;/li>
&lt;li>배포, 설정 관리 등을 위한 모범 사례와 도구를 마련&lt;/li>
&lt;li>애플리케이션을 특정 플랫폼에서 다른 플랫폼으로 이동하는 등 복잡한 유지보스 태스크를 수행&lt;/li>
&lt;li>설정 변경으로 생기는 시스템 보안 유지보수&lt;/li>
&lt;li>예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의&lt;/li>
&lt;li>개인 인사 이동에도 시스템에 대한 조직의 지식을 보존&lt;/li>
&lt;/ul>
&lt;p>좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활도에 노력을 집중한다는 의미이다.&lt;/p>
&lt;ul>
&lt;li>좋은 모니터링으로 런타임 동작과 시스템의 내부에 대한 가시성 제공&lt;/li>
&lt;li>표준 도구를 이용해 자동화와 통합을 위한 우수한 자원을 제공&lt;/li>
&lt;li>개별 장비 의존성을 회피. 유지보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고 계속해서 운영 가능해야함&lt;/li>
&lt;li>좋은 문서와 이해하기 쉬운 운영 모델(ex. X를 하면 Y가 발생한다.) 제공&lt;/li>
&lt;li>만족할 만한 기본 동작을 제공하고, 필요할 때 기본값을 다시 정의할 수 있는 자유를 관리자에게 부여&lt;/li>
&lt;li>적절하게 자기 회복이 가능할 뿐 아니라 필요에 따라 관리자가 시스템 상태를 수동으로 제어할 수 있게 함&lt;/li>
&lt;li>에측 가능하게 동작하고 예기치 않은 상황을 최소화함&lt;/li>
&lt;/ul>
&lt;h3 id="단순성-복잡도-관리">단순성: 복잡도 관리&lt;/h3>
&lt;p>프로젝트가 커짐에 따라 시스템은 매우 복잡하고 이해하기 어려워진다.&lt;/p>
&lt;p>복잡도는 같은 시스템에서 작업해야 하는 모든 사람의 진행을 느리게 하고 나아가 유지 보수 비용이 증가한다.&lt;/p>
&lt;ul>
&lt;li>커다란 진흙 덩어리(big ball of mud)로 묘사한다.&lt;/li>
&lt;/ul>
&lt;p>복잡도는 다양한 증상으로 나타난다.&lt;/p>
&lt;ul>
&lt;li>상태 공간의 급증&lt;/li>
&lt;li>모듈 간 강한 커플링(tight coupling)&lt;/li>
&lt;li>복잡한 의존성&lt;/li>
&lt;li>일관성 없는 명명과 용어&lt;/li>
&lt;li>성능 문제 해결을 목표로 한 해킹&lt;/li>
&lt;li>임시방편으로 문제를 해결한 특수 사례 등&lt;/li>
&lt;/ul>
&lt;p>복잡도가 높아 시스템 유지보수가 어려울 때 아래와 같은 문제들이 발생할 수 있다.&lt;/p>
&lt;ul>
&lt;li>예산과 일정이 초과&lt;/li>
&lt;li>변경이 있을 때 버그가 생길 위험이 더 큼&lt;/li>
&lt;li>개발자가 시스템을 이해하고 추론하기 어려워지면서 시스템에 숨겨진 가정과 의도치않은 결과 및 예기치 않은 상호작용을 간과하기 쉬움&lt;/li>
&lt;/ul>
&lt;p>반대로 복잡도를 줄이면 소프트웨어 유지보수성이 크게 향상되므로, 단순성이 구축하려는 시스템의 핵심 목표여야 한다.&lt;/p>
&lt;p>시스템을 단순하게 만드는 일은 단순히 기능을 줄인다는 의미는 아니며, &lt;strong>우발적 복잡도(accidental complexity)&lt;/strong> 를 줄인다는 뜻에 더 가깝다.&lt;/p>
&lt;ul>
&lt;li>우발적 복잡도: 소프트웨어가 풀어야 할 (사용자에게 보이는) 문제에 내재하고 있지 않고 구현에서만 발생하는 것&lt;/li>
&lt;/ul>
&lt;p>우발적 복잡도를 제거하기 위한 최상의 도구는 추상화이다.&lt;/p>
&lt;ul>
&lt;li>깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.&lt;/li>
&lt;/ul>
&lt;p>좋은 추상화는 다른 다양한 애플리케이션에서도 사용 가능하다.&lt;/p>
&lt;p>이러한 재사용은 비슷한 기능을 여러 번 재구현 하는 것보다 더 효율적일 뿐만 아니라 추상화된 구성 요소의 품질 향상이 이를 사용하는 모든 애플리케이션에 도움을 주므로 고품질 소프트웨어로 이어진다.&lt;/p>
&lt;p>하지만 좋은 추상화를 찾기는 매우 어렵다.&lt;/p>
&lt;p>분산 시스템 분야에서는 여러 좋은 알고리즘이 있지만 관리 가능한 수준에서 시스템 복잡도를 유지하는 데 도움이 되는 추상화로 이런 알고리즘을 묶는 방법은 명확하지 않다.&lt;/p>
&lt;h3 id="발전성-변화를-쉽게-만들기">발전성: 변화를 쉽게 만들기&lt;/h3>
&lt;p>시스템의 요구사항이 끊임없이 변할 가능성이 크다.&lt;/p>
&lt;ul>
&lt;li>새로운 사실을 배움&lt;/li>
&lt;li>미처 예기치 않은 사용 사례 발견&lt;/li>
&lt;li>비즈니스 우선순위 변경&lt;/li>
&lt;li>사용자의 새로운 니즈&lt;/li>
&lt;li>새로운 플랫폼 등장&lt;/li>
&lt;li>법적 또는 규제 요구사항 변경&lt;/li>
&lt;li>시스템의 성장으로 인한 아키텍처 변화&lt;/li>
&lt;/ul>
&lt;p>조직 프로세스 측면에서 &lt;strong>애자일&lt;/strong> 작업 패턴은 변화에 적응하기 위한 프레임워크를 제공한다. 또한 애자일 커뮤니티는 TDD, 리팩토링 같이 자주 변화하는 환경에서 소프트웨어를 개발할 때 도움이 되는 기술 도구와 패턴을 개발하고 있다.&lt;/p>
&lt;p>애자일 기법에 대한 설명은 대부분 매우 작고, 로컬 규모(동일 애플리케이션 내 소스코드 파일이 몇 개반 있음)에 초점을 맞추고 있는데, 이 책에서는 다양한 애플리케이션이나 다른 특성을 가진 서비스로 구성된 대규모 데이터 시스템 수준에서 민첩성을 높이는 방법을 찾는다.&lt;/p>
&lt;p>데이터 시스템 변경을 쉽게 하고 변화된 요구사항에 시스템을 맞추는 방법은 시스템의 간단함과 추상화와 밀접한 관련이 있다.&lt;/p>
&lt;ul>
&lt;li>간단하고 이해하기 쉬운 시스템은 대개 복잡한 시스템보다 수정하기 쉽다.&lt;/li>
&lt;li>데이터 시스템 수준에서 민첩성을 언급할 때는 &lt;strong>발전성&lt;/strong> 사용한다.&lt;/li>
&lt;/ul>
&lt;h2 id="정리">정리&lt;/h2>
&lt;p>이번 장에서는 데이터 중심 애플리케이션을 생각하는 기본적인 방법 몇 가지를 살펴봤다.&lt;/p>
&lt;p>애플리케이션이 유용하려면 다양한 요구사항을 충족시켜야 한다.&lt;/p>
&lt;ul>
&lt;li>기능적 요구사항
&lt;ul>
&lt;li>여러 방법으로 데이터를 저장하고 조회하고 검색하고 처리하게끔 허용하는 작업과 같이 해야하는 일&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비기능적 요구사항
&lt;ul>
&lt;li>보안, 신뢰성, 법규 준수, 확장성, 호환성, 유지보수성과 같은 일반 속성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이번 장에서는 신뢰성, 확장성, 유지보수성을 자세히 살폈다.&lt;/p>
&lt;ul>
&lt;li>신뢰성
&lt;ul>
&lt;li>결함이 발생해도 시스템이 올바르게 동작하게 만든다는 의미&lt;/li>
&lt;li>결함은 하드웨어와 소프트웨어 버그와 사람에게 있을 수 있음&lt;/li>
&lt;li>내결함성 기술은 최종 사용자에게 특정 유형의 결함을 숨길 수 있게 해준다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장성
&lt;ul>
&lt;li>부하가 증가해도 좋은 성능을 유지하기 위한 전략&lt;/li>
&lt;li>확장성을 설명하기 위해 양적으로 부하와 성능을 설명하는 방법이 필요함&lt;/li>
&lt;li>확장 가능한 시스템에서는 부하가 높은 상태에서 신뢰성을 유지하기 위해 처리 용량을 추가할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유지보수성
&lt;ul>
&lt;li>본질은 시스템에서 작업하는 엔지니어와 운영 팀의 삶을 개선하는 데 있음&lt;/li>
&lt;li>좋은 추상화는 복잡도를 줄이고 쉽게 시스템을 변경할 수 있게하며 새로운 사용 사례에 적용하는 데 도움이됨&lt;/li>
&lt;li>좋은 운용성이란 시스템의 건강 상태를 잘 관찰할 수 있고 시스템을 효율적으로 관리하는 방법을 보유한다는 의미&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>애플리케이션을 신뢰할 수 있고 확장 가능하며 유지보수하기 쉽게 만들어주는 간단한 해결책은 없다.&lt;/p>
&lt;p>하지만 여러 애플리케이션에서 계속 재현되는 특정 패턴과 기술이 있으며, 데이터 시스템 몇 가지를 예제로 살펴보고 이런 목표를 향해 데이터 시스템이 어떻게 작동하는지 분석한다.&lt;/p></description></item></channel></rss>