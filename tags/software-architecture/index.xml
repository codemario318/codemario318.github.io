<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software Architecture on Mario Blog</title><link>https://codemario318.github.io/tags/software-architecture/</link><description>Recent content in Software Architecture on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Thu, 18 Apr 2024 16:19:13 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/software-architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>30. 데이터베이스는 세부사항이다</title><link>https://codemario318.github.io/post/clean-architecture/30/</link><pubDate>Thu, 18 Apr 2024 16:19:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/30/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/30/cover.png" alt="Featured image of post 30. 데이터베이스는 세부사항이다" />&lt;p>아키텍처 관점에서 볼 때 데이터베이스는 엔티티가 아니다.&lt;/p>
&lt;p>데이터 모델과는 달리 아키텍처 관점에서는 데이터베이스는 세부사항이라서 아키텍처의 구성요소 수준으로 끌어올릴 수 없다.&lt;/p>
&lt;p>데이터베이스는 소프트웨어일 뿐이며, 데이터에 접근할 방법을 제공하는 유틸리티이다.&lt;/p>
&lt;p>유틸리티는 저수준 세부사항(메커니즘)일 뿐 아키텍처와는 관계 없으므로, 데이터베이스를 이용한다는 사실이 아키텍처에 영향을 주지 않아야한다.&lt;/p>
&lt;h2 id="관계형-데이터베이스">관계형 데이터베이스&lt;/h2>
&lt;p>관계형 테이블은 특정한 형식의 데이터에 접근하는 경우에 편리함을 제공하지만, 데이터를 테이블에 행 단위로 배치한다는 자체는 아키텍처적으로 볼 때 전혀 중요하지 않다.&lt;/p>
&lt;p>따라서 (관계형 데이터베이스에 저장된)데이터가 테이블 구조를 가진다는 사실은 오직 아키텍처의 외부 원에 위치한 최하위 수준의 유틸리티 함수만 알아야한다.&lt;/p>
&lt;p>소프트웨어에서 테이블과 행을 허용한다면, 유스케이스, 업무 규칙, UI조차도 관계형 데이터 구조에 결합되어버린다.&lt;/p>
&lt;h2 id="데이터베이스-시스템은-왜-이렇게-널리-사용되는가">데이터베이스 시스템은 왜 이렇게 널리 사용되는가?&lt;/h2>
&lt;p>데이터 저장 공간의 한계로 디스크를 사용할 수 밖에 없었기 때문이다.&lt;/p>
&lt;p>디스크의 단점은 느리다는 점 인데, 이로인해 발생하는 성능 저하 완화를 위한 색인, 캐시, 쿼리 계획 최적화가 필요해졌다.&lt;/p>
&lt;p>색인, 캐시, 쿼리 계획을 위해 작업중인 대상이 어떤 데이터인지 알 수 있어야 했으므로 데이터를 표현하는 일종의 표준적인 방식도 필요했고, 시간이 흘러 파일 시스템과 관계형 데이터베이스 관리 시스템(RDBMS) 2가지 유형으로 분리되었다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>파일 시스템&lt;/strong>&lt;/p>
&lt;p>문서(document) 기반 시스템으로, 분서 전체를 자연스럽고 편리하게 저장하는 방법을 제공한다.&lt;/p>
&lt;p>문서를 이름을 기준으로 저장하거나 조회할 때는 잘 동작하지만, 내용을 기준으로 검색할 때는 크게 도움되지 않는다.&lt;/p>
&lt;p>&lt;strong>데이터베이스 시스템&lt;/strong>&lt;/p>
&lt;p>내용 기반 시스템으로 내용을 기바능로 레코드를 자연스럽고 편리하게 찾는 방법을 제공한다.&lt;/p>
&lt;p>레코드가 서로 공유하는 일부 내용에 기반해서 다수의 레코드를 연관 짓는 데 매우 탁월하지만, 정형화되지 않은 문서를 저장하고 검색하는 데는 대체로 부적합하다.&lt;/p>
&lt;hr>
&lt;p>각 시스템은 데이터를 디스크에 체계화하고 특화된 방식으로 데이터를 저장하고 검색할 수 있도록 하며, 성능을 높히기 위해 데이터를 색인하고 RAM에 배치하는 고유한 전략을 활용한다.&lt;/p>
&lt;h2 id="디스크가-없다면-어떻게-될까">디스크가 없다면 어떻게 될까?&lt;/h2>
&lt;p>디스크는 RAM으로 대체되고있다.&lt;/p>
&lt;p>모든 데이터가 RAM에 저장된다면 데이터들을 연결 리스트, 트리, 해시 테이블, 스택, 큐 와 같은 데이터 구조로 체계화 될 것이며, 데이터에 접근할 때는 포인터나 참조를 활용할 것이다.&lt;/p>
&lt;p>데이터가 데이터베이스나 파일 시스템에 있더라도, RAM으로 읽은 후에는 다루기 편리한 형태로 그 구조로 변경하는데, 이는 프로그래머가 하는 일로 그대로 하면 된다.&lt;/p>
&lt;h2 id="세부사항">세부사항&lt;/h2>
&lt;p>데이터가 파일 시스템이나 데이터베이스 시스템을 통해 저장된다고 하더라도 결과적으로 실제 데이터를 처리할 때는 사용하기 편한 방식(자료구조)으로 처리하여 RAM에 올려 사용하게 된다.&lt;/p>
&lt;p>이처럼 데이터베이스는 디스크와 RAM 사이에서 데이터를 옮길 때 사용할 뿐인 메커니즘이고, 데이터를 장기적으로 저장하는 공간일 뿐이다.&lt;/p>
&lt;p>따라서 아케텍처 관점에서 본다면 데이터베이스는 세부사항이므로, 데이터가 어떤 형태로 어디에 저장되어있는지 인식해서는 안된다.&lt;/p>
&lt;h2 id="하지만-성능은">하지만 성능은?&lt;/h2>
&lt;p>데이터 저장소 측명에서 성능은 완전히 캡슐화하여 업무 규칙과는 분리할 수 있는 관심사이다.&lt;/p>
&lt;p>데이터 저장소에서 데이터를 빠르게 넣고 뺄 수 있어야 하는 것은 맞지만, 이는 저수준 관심사로 저수준의 데이터 매커니즘 단에서 다뤄야한다.&lt;/p>
&lt;ul>
&lt;li>인덱스 등&lt;/li>
&lt;/ul>
&lt;p>따라서 데이터 저장소의 성능은 시스템의 전반적인 아케텍처와는 관계가 없다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>체계화된 데이터 구조와 데이터 모델은 아키텍처적으로 중요한 반면, 데이터를 디스크에서 이리 저리 옮길 뿐인 기술과 시스템은 아키텍처적으로 중요하지 않다.&lt;/p>
&lt;p>데이터를 테이블 구조로 만들고 SQL로만 접근하도록 하는 관계형 데이터베이스 시스템은 후자와 관련이 깊으므로 아키텍처적으로 종요하지 않다.&lt;/p>
&lt;p>데이터는 중요하나, 데이터베이스는 세부사항이다.&lt;/p></description></item><item><title>31. 웹은 세부사항이다</title><link>https://codemario318.github.io/post/clean-architecture/32/</link><pubDate>Thu, 18 Apr 2024 16:19:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/32/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/32/cover.png" alt="Featured image of post 31. 웹은 세부사항이다" />&lt;h2 id="끝없이-반복하는-추">끝없이 반복하는 추&lt;/h2>
&lt;p>1960년대 이래로 모든 연산 능력을 중앙 서버에 두는 방식과 모든 연산 능력을 단말에 두는 방식 사이의 일련의 반복되는 진동을 겪어왔으며 웹은 진동 끝 한 점에 있을 뿐이다.&lt;/p>
&lt;p>IT 역사 전체로 시야를 넓히면 웹은 아무것도 바꾸지 않았으며, 이러한 진동은 앞으로도 지속될것이다.&lt;/p>
&lt;p>따라서 아키텍트로서 이 진동은 핵심 업무 규칙의 중심에서 밀어내야하는 단기적인 문제일 뿐이다.&lt;/p>
&lt;p>이러한 진동은 GUI의 변경을 동반하며, 이러한 변경으로부터 애플리케이션을 보호하기 위해 GUI로부터 업무 규칙을 분리해야한다.&lt;/p>
&lt;h2 id="요약">요약&lt;/h2>
&lt;p>GUI는 세부사항이다. 웹은 입 출력 장치의 다른 모습이므로 GUI이며, 이러한 이유로 웹은 세부사항이다.&lt;/p>
&lt;p>따라서 아키텍트는 웹을 핵심 업무 로직에서 분리된 경계 바깥에 두어야한다.&lt;/p>
&lt;p>애플리케이션과 GUI의 상호작용은 빈번하고 방식도 사용중인 GUI 종류에 따라 차이가 크기 때문에 추상화하려는 시도는 성공할 가능성이 낮아 보인다.&lt;/p>
&lt;p>하지만 UI와 애플리케이션 사이에는 추상화가 가능한 또 다른 경계가 존재한다.&lt;/p>
&lt;ul>
&lt;li>업무 로직은 다수의 유스케이스로 구성되며, 각 유스케이스는 사용자를 대신해서 일부 함수를 수행하는 것을 볼 수 있다.&lt;/li>
&lt;li>각 유스케이스는 입력 데이터 수행할 처리 과정, 출력 데이터를 기반으로 기술할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>환전한 입력 데이터와 그에 따른 출력 데이터는 데이터 구조로 만들어서 유스케이스를 실행하는 처리 과정의 입력 값과 출력 값으로 사용할 수 있기 때문에, 각 유스케이스가 장치 독립적인 방식으로 UI라는 입출력 장치를 동작시킨다고 간주할 수 있다.&lt;/p>
&lt;p>이러한 입력 데이터와 그에 따른 출력 데이터로 만들어지는 데이터 구조는 UI와 애플리케이션 사이의 경계를 넘나드는 수단이므로 추상화가 가능한 경계이다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>이러한 종류의 추상화는 만들기 쉽지 않고, 제대로 만들려면 수차례의 반복 과정을 거쳐야 할 것이다.&lt;/p>
&lt;p>하지만 이러한 추상화는 가능하며, 변경이 될 요소는 매우 많기 때문에 추상화는 꼭 필요하다.&lt;/p></description></item><item><title>28. 테스트 경계</title><link>https://codemario318.github.io/post/clean-architecture/28/</link><pubDate>Mon, 15 Apr 2024 18:17:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/28/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/28/cover.png" alt="Featured image of post 28. 테스트 경계" />&lt;p>테스트는 시스템의 일부이며, 아키텍처에도 관여한다.&lt;/p>
&lt;h2 id="시스템-컴포넌트인-테스트">시스템 컴포넌트인 테스트&lt;/h2>
&lt;p>아키텍처 관점에서는 어떠한 종류에 테스트이든 동일하다.&lt;/p>
&lt;p>테스트는 태생적으로 의존성 규칙을 따른다.&lt;/p>
&lt;ul>
&lt;li>테스트는 세부적이며 구체적이다.&lt;/li>
&lt;li>따라서 의존성은 항상 테스트 대상이 되는 코드를 향한다.(아키텍처의 가장 바깥쪽 원으로 볼 수 있다.)&lt;/li>
&lt;li>시스템 내부의 어떤 것도 테스트에는 의존하지 않는다.&lt;/li>
&lt;li>독립적으로 배포 가능하다.&lt;/li>
&lt;li>시스템 컴포넌트 중에서 가장 고립되어 있다.&lt;/li>
&lt;li>시스템 운영에 꼭 필요치는 않다.&lt;/li>
&lt;li>테스트의 역할은 운영이 아니라 개발을 지원하는 것이므로, 어떤 사용자도 테스트에 의존하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>그렇다고 하더라도 테스트가 시스템 컴포넌트가 아니라는 뜻은 아니며, 다른 모든 시스템 컴포넌트가 반드시 지켜야하는 모델을 표현해준다.&lt;/p>
&lt;h2 id="테스트를-고려한-설계">테스트를 고려한 설계&lt;/h2>
&lt;p>테스트의 극단적인 고립성이 대체로 배포하지 않는다는 사실과 어우러져, 테스트가 시스템의 설계 범위 밖에 있다고 착각한다.&lt;/p>
&lt;p>테스트가 시스템 설계와 잘 통합되지 않으면, 테스트는 깨지기 쉬워지고, 시스템은 뻣뻣해져서 변경하기가 어려워진다.&lt;/p>
&lt;p>&lt;strong>깨지기 쉬운 테스트 문제(Fragile Tests Problem)&lt;/strong>&lt;/p>
&lt;p>시스템에 강하게 결합된 테스트라면 시스템이 변경될 때 함께 변경되어야하므로, 시스템 컴포넌트에 생긴 아주 사소한 변경도, 이와 결합된 수많은 테스트를 망가뜨릴 수 있다.&lt;/p>
&lt;p>시스템의 공통 컴포넌트가 변경되면 수백, 심지어 수천 개의 테스트가 망가진다.&lt;/p>
&lt;hr>
&lt;p>깨지기 쉬운 테스트는 시스템을 뻣뻣하게 만든다는 부작용을 낳을 때가 많다.&lt;/p>
&lt;ul>
&lt;li>시스템에 가한 간단한 변경이 대량의 테스트 실패로 이어진다는 사실을 알게되면, 개발자는 변경을 하지 않으려고 할 것이다.&lt;/li>
&lt;/ul>
&lt;p>따라서 이러한 문제를 해결하기 위해 테스트를 고려한 설계가 필요하다.&lt;/p>
&lt;p>핵심은 &lt;strong>변동성이 있는 것에 의존하지 않는 것&lt;/strong>이다.&lt;/p>
&lt;p>변동성이 큰 GUI같은 것으로 시스템을 조작하는 테스트 스위트는 깨지기 쉽기 때문에 시스템과 테스트를 설계할 때 GUI를 사용하지 않고 업무 규칙을 테스트 할 수 있게 해야한다.&lt;/p>
&lt;h2 id="테스트-api">테스트 API&lt;/h2>
&lt;p>변동성이 적은 방식으로 업무 규칙을 테스트하기 위해 모든 업무 규칙을 검증하는 데 사용할 수 있도록 특화된 API를 만든다.&lt;/p>
&lt;ul>
&lt;li>보안 제약 사항을 무시할 수 있어야 한다.&lt;/li>
&lt;li>데이터베이스와 같은 값비싼 자원은 건너뛰고, 시스템을 테스트 가능한 특정 상태로 강제하는 강력한 힘을 지녀야한다.&lt;/li>
&lt;li>사용자 인터페이스가 사용하는 &lt;strong>인터렉터&lt;/strong>와 &lt;strong>인터페이스 어댑터&lt;/strong>들의 상위 집합이 될 것이다.&lt;/li>
&lt;/ul>
&lt;p>테스트 API는 테스트를 애플리케이션으로부터 분리할 목적으로 사용한다.&lt;/p>
&lt;h3 id="구조적-결합">구조적 결합&lt;/h3>
&lt;p>구조적 결합은 테스트 결합 중에서 가장 강하며, 가장 은밀하게 퍼져나가는 유형이다.&lt;/p>
&lt;p>모든 상용 클래스에 테스트 클래스가 각각 존재하고, 모든 상용 메서드에 테스트 메서드 집합이 각각 존재하는 테스트 스위트가 있다고 가정할 때 이러한 테스트 스위트는 애플리케이션 구조에 강하게 결합되어있다.&lt;/p>
&lt;ul>
&lt;li>상용 클래스나 메서드 중 하나라도 변경되면 딸려있는 다수의 테스트가 변경되어야한다.&lt;/li>
&lt;li>테스트는 깨지기 위워지고, 이로 인해 상용 코드를 뻣뻣하게 만든다.&lt;/li>
&lt;/ul>
&lt;p>테스트 API의 역할은 애플리케이션의 구조를 테스트로부터 숨기는 데 있다.&lt;/p>
&lt;ul>
&lt;li>상용 코드를 리펙터링하거나 진화시키더라도 테스트에는 전혀 영향을 주지 않는다.&lt;/li>
&lt;li>테스트를 리펙터링 하거나 진화시킬 때도 사용 코드에는 영향을 주지 않는다.&lt;/li>
&lt;/ul>
&lt;p>시간이 지날수록 테스트는 계속해서 더 구체적이고 특화된 형태로 변하고, 상용 코드는 더 추상적이고 범용적인 형태로 변하기 때문에 따로따로 진화할 수 있다는 점은 필수적이다.&lt;/p>
&lt;p>하지만 구조적 결합이 강하면 위와 같은 진화 과정을 방해한다.&lt;/p>
&lt;h3 id="보안">보안&lt;/h3>
&lt;p>테스트 API를 운영 시스템에 배포하면 위험에 처할 수 있다.&lt;/p>
&lt;p>테스트 API 자체와 테스트 API 중 위험한 부분의 구현부를 독립적으로 배포할 수 있는 컴포넌트로 분리해야한다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>테스트는 시스템의 일부이다.&lt;/p>
&lt;p>따라서 테스트에서 기대하는 안정성과 회귀의 이점을 얻을 수 있으려면 테스트는 잘 설계 돼야만한다.&lt;/p>
&lt;p>테스트를 시스템의 일부로 설계하지 않으면 테스트는 깨지기 쉽고 유지보수하기 어려워지는 경향이 있으며, 이러한 테스트는 유지보수하기 힘들기 때문에 버려지는 최후를 맡는다.&lt;/p></description></item><item><title>27. 크고 작은 모든 서비스들</title><link>https://codemario318.github.io/post/clean-architecture/27/</link><pubDate>Mon, 15 Apr 2024 17:13:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/27/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/27/cover.png" alt="Featured image of post 27. 크고 작은 모든 서비스들" />&lt;p>서비스 지향 아키텍처와 마이크로서비스 아키텍처는 최근에 큰 인기를 끌고 있는데 이유는 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>서비스를 사용하면 상호 결합이 철저하게 분리되는 것처럼 보인다.&lt;/li>
&lt;li>서비스를 사용하면 개발과 배포 독립성을 지원하는 것처럼 보인다.&lt;/li>
&lt;/ul>
&lt;h2 id="서비스-아키텍처">서비스 아키텍처?&lt;/h2>
&lt;p>서비스를 사용한다는 것이 본질적으로 아키텍처에 해당하는지에 대해 생각해보면 명백히 사실이 아니다.&lt;/p>
&lt;p>시스템의 아키텍처는 의존선 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의된다.&lt;/p>
&lt;p>이러한 관점에서 애플리케이션의 행위를 분리할 뿐인 서비스라면 값비싼 함수 호출에 불과하며, 아키텍처 관점에서 꼭 중요하다고 볼 수는 없다.&lt;/p>
&lt;p>기능을 프로세스나 플랫폼에 독립적이 되게끔 서비스들을 생성하면 의존성 규칙 준수 여부와 상관 없이 큰 도움이 될 때가 많으나, 서비스 그 자체로는 아키텍처를 정의하지 않는다.&lt;/p>
&lt;p>위에 언급한대로 시스템에서 아키텍처를 정의하는 요소는 의존성 규칙을 따르며 아키텍처 경계를 넘나드는 행위 자체이며, 결국 서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않는다고 볼 수 있다.&lt;/p>
&lt;h2 id="서비스의-이점">서비스의 이점?&lt;/h2>
&lt;p>많은 사람들이 생각하는 서비스의 이점에 대해 아키텍처 관점의 근본적인 문제를 살펴보면 이러한 부분들이 완벽한 해결책은 아님을 알 수 있다.&lt;/p>
&lt;h3 id="결합-분리의-오류">결합 분리의 오류&lt;/h3>
&lt;p>시스템을 서비스들로 분리함으로써 얻게 되리라 예상되는 큰 이점중 하나는 &lt;strong>서비스 사이의 결합이 확실히 분리된다는 점&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>각 서비스는 서로 다른 프로세스에서 실행되므로 서비스는 다른 서비스의 변수에 직접 접근이 불가능하다.&lt;/li>
&lt;li>모든 서비스의 인터페이스는 반드시 잘 정의되어 있어야 한다.&lt;/li>
&lt;/ul>
&lt;p>서비스들이 변수를 통해 직접 접근할 수는 없지만 프로세서 내의 또는 네트워크 상의 공유 자원과 이로 인한 공유하는 데이터에 의해 서비스들이 강력하게 결합된다.&lt;/p>
&lt;ul>
&lt;li>서비스 사이를 오가는 데이터 레코드에 새로운 필드를 추가하면, 이 필드를 사용하는 모든 서비스는 반드시 변경되어야한다.&lt;/li>
&lt;li>필드에 담긴 데이터를 해석하는 방식을 사전에 완벽하게 조율해야 한다.&lt;/li>
&lt;/ul>
&lt;p>이로 인해 서비스들은 레코드에 강하게 결합되고, 서비스들 사이는 서로 간접적으로 결합되어버린다.&lt;/p>
&lt;h3 id="개발-및-배포-독립성의-오류">개발 및 배포 독립성의 오류&lt;/h3>
&lt;p>전담팀이 서비스를 소유하고 운영하게 되므로 각자 개발 및 배포할 수 있게되어 &lt;strong>확장 가능한&lt;/strong>, 확장이 용이한 구조라고 생각하지만, 서비스는 확장 가능한 시스템을 구축하는 유일한 선택지가 아니다.&lt;/p>
&lt;ul>
&lt;li>모노리틱 시스템이나 컴포넌트 기반 시스템으로도 확장 가능한 시스템을 구축할 수 있다는 사실이 역사적으로 증명되어왔다.&lt;/li>
&lt;/ul>
&lt;p>결합 분리 오류에서 언급한 내용을 토대로 살펴보면 서비스라고 해서 항상 독립적으로 개발, 배포, 운영할 수 있는 것은 아니며, 결합된 정도에 맞게 조정해야한다.&lt;/p>
&lt;h2 id="야옹이-문제">야옹이 문제&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/27/img.png"
width="1393"
height="574"
srcset="https://codemario318.github.io/post/clean-architecture/27/img_huc93515613977e36e214e87cb871aaccb_354737_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/27/img_huc93515613977e36e214e87cb871aaccb_354737_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="242"
data-flex-basis="582px"
>&lt;/p>
&lt;p>이전에 예시로 들었던 택시 통합 시스템을 수많은 작은 마이크로 서비스를 기반으로 구축했다.&lt;/p>
&lt;p>이러한 아키텍처에서 야옹이 배달 서비스를 런칭하겠다고 가정한다.&lt;/p>
&lt;p>&lt;strong>요구사항&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>사용자는 집이나 사무실로 야옹이를 배달해달라고 주문할 수 있다.
&lt;ul>
&lt;li>야옹이를 태울 다수의 승차 지점을 설정해야한다.&lt;/li>
&lt;li>승차 지점 중 한 곳에서 야옹이를 태운 후, 올바른 주로소 야옹이를 배달해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>제약사항&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>운전자가 고양이 알러지가 있는 경우 해당 운전자는 이 서비스에서 제외되어야한다.&lt;/li>
&lt;li>일반 택시 승객이 알러지가 있을 수 있으므로, 배차를 신청한 고객이 알러지가 있다면, 야옹이를 배달했던 차량은 배차에서 제외한다.&lt;/li>
&lt;/ul>
&lt;p>서비스 다이어그램을 살펴봤을 때 마이크로서비스들은 모두 결합되어 있어 독립적으로 개발하고 배포하거나 유지할 수 없다.&lt;/p>
&lt;p>따라서 야옹이 배달 기능을 추가하려면 구성된 모든 마이크로서비스를 변경해야 한다.&lt;/p>
&lt;p>이는 횡단 관심사(Cross-Cutting Concern)가 지닌 문제로 기능적 분해는 새로운 기능이 기능적 행위를 횡단하는 상황에서 매우 취약하다.&lt;/p>
&lt;h2 id="객체가-구출하다">객체가 구출하다&lt;/h2>
&lt;p>SOLID 설계원칙에서, 다향적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 한다.&lt;/p>
&lt;p>이를 통해 컴포넌트 아키텍처에서는 아래와 같은 전략을 활용할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/27/img_1.png"
width="1418"
height="1356"
srcset="https://codemario318.github.io/post/clean-architecture/27/img_1_hu5da0ee89e3d37864338935723ad5c1a6_654243_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/27/img_1_hu5da0ee89e3d37864338935723ad5c1a6_654243_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="104"
data-flex-basis="250px"
>&lt;/p>
&lt;p>원래 서비스 로직 중 대다수가 이 객체 모델의 기반 클래스들 내부로 녹아들었다.&lt;/p>
&lt;ul>
&lt;li>배차에 특화된 로직 부분은 &lt;code>Rides&lt;/code> 컴포넌트로 추출되었다.&lt;/li>
&lt;li>야옹이에 대한 신규 기능은 &lt;code>Kittens&lt;/code> 컴포넌트에 들어있다.&lt;/li>
&lt;li>이 두 컴포넌트는 기존 컴포넌트들에 있는 추상 기반 클래스를 템플릿 메서드나 전략 패턴 등을 이용해서 오버라이드한다.&lt;/li>
&lt;li>신규 컴포넌트 &lt;code>Rides&lt;/code>, &lt;code>Kittens&lt;/code>가 의존성 규칙을 준수한다.&lt;/li>
&lt;li>이 기능을 구현하는 클래스들은 UI의 제어 하에 팩토리가 생성한다.&lt;/li>
&lt;/ul>
&lt;p>이 전략을 따르더라도 야옹이 기능을 구현하려면 &lt;code>TaxiUI&lt;/code>는 변경해야 하지만, 그 외의 것들은 변경할 필요가 없다.&lt;/p>
&lt;p>따라서 야옹이 기능은 결합이 분리되며, 독립적으로 개발하여 배포할 수 있다.&lt;/p>
&lt;h2 id="컴포넌트-기반-서비스">컴포넌트 기반 서비스&lt;/h2>
&lt;p>서비스가 반드시 소규모 단일체(monolith)일 이유는 없다.&lt;/p>
&lt;p>서비스는 SOLID 원칙대로 설계할 수 있으며 컴포넌트 구조를 갖출 수도 있다.&lt;/p>
&lt;p>java의 경우 서비스를 하나 이상의 &lt;code>jar&lt;/code> 파일에 포함되는 &lt;strong>추상 클래스들의 집합&lt;/strong>이라고 생각할 수 있다.&lt;/p>
&lt;p>새로운 기능 추가 혹은 기능 확장은 기존 &lt;code>jar&lt;/code> 파일에 정의돈 추상 클래스들을 확장하여 새로운 &lt;code>jar&lt;/code> 파일로 만든다면, 새로운 기능 배포는 서비스를 재배포하는 문제가 아니라, 서비스를 로드하는 경로에 단순히 새로운 &lt;code>jar&lt;/code> 파일을 추가하는 문제가 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/27/img_2.png"
width="1404"
height="1024"
srcset="https://codemario318.github.io/post/clean-architecture/27/img_2_huc3c601dcdc257ffe66a5f4dc26dbb7e2_569311_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/27/img_2_huc3c601dcdc257ffe66a5f4dc26dbb7e2_569311_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="329px"
>&lt;/p>
&lt;p>각 서비스의 내부는 자신만의 컴포넌트 설계로 되어 있어서 파생 클래스를 만드는 방식으로 신규 기능을 추가할 수 있다.&lt;/p>
&lt;h2 id="횡단-관심사">횡단 관심사&lt;/h2>
&lt;p>아키텍처 경계는 서비스 사이에 있지 않고 오히려 서비스를 관통하며, 서비스를 컴포넌트 단위로 분할한다.&lt;/p>
&lt;p>모든 주요 시스템이 직면하는 횡단 관심사를 처리하려면, 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/27/img_3.png"
width="1426"
height="639"
srcset="https://codemario318.github.io/post/clean-architecture/27/img_3_hu56c1406b520655ab8ea4c66d27f42c03_210561_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/27/img_3_hu56c1406b520655ab8ea4c66d27f42c03_210561_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="223"
data-flex-basis="535px"
>&lt;/p>
&lt;p>서비스들은 시스템의 아키텍처 경계를 정의하지 않으며, 아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트이다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>서비스는 시스템의 확정성과 개발 가능성 측면에서 유용하지만, 그 자체로는 아키텍처적으로 그리 중요한 요소는 아니다.&lt;/p>
&lt;p>시스템의 아키텍처는 구성 요소가 통신하고 실행되는 물리적인 매커니즘에 의해 아키텍처가 정의되는 것이 아닌, 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의된다.&lt;/p>
&lt;ul>
&lt;li>서비스는 단 하나의 아케텍처 경계로 둘러싸인 단일 컴포넌트로 만들 수 있다.&lt;/li>
&lt;li>여러 아키텍처 경계로 분리된 다수의 컴포넌트로 구성할 수도 있다.&lt;/li>
&lt;li>클라이언트와 서비스가 강하게 결합되어 아키텍처적으로 아무런 의미가 없을 때도 있다.&lt;/li>
&lt;/ul></description></item><item><title>26. 메인 컴포넌트</title><link>https://codemario318.github.io/post/clean-architecture/26/</link><pubDate>Mon, 15 Apr 2024 16:48:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/26/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/26/cover.png" alt="Featured image of post 26. 메인 컴포넌트" />&lt;p>모든 시스템에는 최소한 하나의 컴포넌트가 존재하여 나머지 컴포넌트를 생성, 조정, 관리하는데 이러한 컴포넌트를 메인 컴포넌트라 한다.&lt;/p>
&lt;h2 id="궁극적인-세부사항">궁극적인 세부사항&lt;/h2>
&lt;p>메인 컴포넌트는 &lt;strong>궁극적인 세부사항&lt;/strong>으로, 가장 낮은 수준의 정책이다.&lt;/p>
&lt;ul>
&lt;li>시스템의 초기 진입점이다.&lt;/li>
&lt;li>운영체제를 제외하면 어떤 것도 메인에 의존하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>메인은 모든 팩토리(Factory)와 전략(Strategy), 시스템 전반을 담당하는 나머지 기발 설비를 생성한 후, 시스템에서 더 높은 수준을 담당하는 부분으로 제어권을 넘긴다.&lt;/p>
&lt;hr>
&lt;p>의존성 주입 프레임워크를 이용해 의존성을 주입하는 일은 메인 컴포넌트에서 이뤄져야 한다.&lt;/p>
&lt;p>메인에 의존성이 주입되고 나면, 의존성 주입 프레임워크를 사용하지 않고도 일반적인 방식으로 의존성을 분배할 수 있어야한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">IOException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">game&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">HtwFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeGame&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;htw.game.HuntTheWumpusFacade&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Main&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">createMap&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">BufferdReader&lt;/span> &lt;span class="n">br&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">BufferedReader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">InputStreamReader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">in&lt;/span>&lt;span class="o">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeRestCommand&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">excute&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getPlayerCavern&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Health: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">hitPoints&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; arrows: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getQuiver&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">HuntTheWumpus&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">Command&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeRestCommand&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;&amp;gt;&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">String&lt;/span> &lt;span class="n">command&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">br&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">readLine&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;e&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">EAST&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;w&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">WEST&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;n&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">NORTH&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;s&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">SOUTH&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;r&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;sw&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">WEST&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;se&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">EAST&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;sn&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">EAST&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;ss&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">SOUTH&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;q&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">excute&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>HtwFactory&lt;/code>를 사용하여 게임을 생성할 때, &lt;code>htw.game.HuntTheWumpusFacade&lt;/code>라는 클래스 이름을 문자열로 전달하는데, 이는 이 클래스가 변경이 매우 많은 지저분한 클래스이므로, 문자열을 통해 참조하도록 하여 직접 참조하지 않게 하여 변경이 생겨도 메인을 재컴파일/재배포하지 않게 만들기 위함이다.&lt;/p>
&lt;p>입력 스티름 생성 부분, 게임의 메인 루프 처리, 간단한 입력 명령어 해석 등은 모두 &lt;code>main()&lt;/code>에서 처리하지만, 명령어를 실제로 처리하는 일은 다른 고수준 컴포넌트로 위임한다.&lt;/p>
&lt;hr>
&lt;p>메인은 클린 아키텍처에서 가장 바깥 원에 위치하는, 지저분한 저수준 모듈이다.&lt;/p>
&lt;p>메인은 고수준의 시스템을 위한 모든 것을 로드한 후, 제어권을 고수준의 시스템에게 넘긴다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>메인을 초기 조건과 성정을 구성하고, 외부 자원을 모두 수집한 후 제어권을 애플리케이션의 고수준 정책으로 넘기는 플러그인이다.&lt;/p>
&lt;p>메인은 플러그인이므로 메인 컴포넌트를 애플리케이션의 설정별로 하나씩 두로록 하여 둘 이상의 메인 컴포넌트를 만들 수도 있다.&lt;/p>
&lt;ul>
&lt;li>개발용 메인 플러그인&lt;/li>
&lt;li>테스트용 메인 플러그인&lt;/li>
&lt;li>국가별 플러그인&lt;/li>
&lt;li>관할 영역 별 플러그인&lt;/li>
&lt;li>고객별 플러그인 등&lt;/li>
&lt;/ul>
&lt;p>메인을 플러그인 컴포넌트로 여기고 아키텍처 경계 바깥에 위치한다고 보면 설정 관련 문제를 훨씬 쉽게 해결할 수 있다.&lt;/p></description></item><item><title>25. 계층과 경계</title><link>https://codemario318.github.io/post/clean-architecture/25/</link><pubDate>Thu, 04 Apr 2024 09:16:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/25/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/25/cover.png" alt="Featured image of post 25. 계층과 경계" />&lt;p>단순한 시스템에서는 UI, 업무 규칙, 데이터베이스 컴포넌트만으로도 충분하지만, 대다수의 시스템에서 컴포넌트의 개수는 이보다 훨씬 많다.&lt;/p>
&lt;p>이에 따라 컴포넌트간 경계도 훨씬 많이질 수 밖에 없다.&lt;/p>
&lt;p>아키텍처 경계는 어디에나 존재하며, 아키텍트는 아키텍처 경계가 언제 필요한지를 신중하게 파악해내야한다.&lt;/p>
&lt;p>이러한 경계를 제대로 구현하는 비용은 크며, 경계가 무시되었다면 나중에 다시 추가하는 비용도 매우 크다.&lt;/p>
&lt;p>오버 엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많으므로 XP의 원칙인 &lt;strong>YAGNI&lt;/strong>가 말하는 것 처럼 추상화가 필요하리라고 미리 예측해서는 안 된다.&lt;/p>
&lt;p>하지만, 경계가 존재하지 않는 상황에서 경계가 필요하다는 것을 깨닳고 추가하려면 비용이 매우 많이 들고 큰 위험을 감수해야한다.&lt;/p>
&lt;hr>
&lt;p>이처럼 소프트웨어 아키텍트는 여러 상황들을 적절히 고려하여 소프트웨어가 어떻게 발전할지 예측해야한다.&lt;/p>
&lt;p>이를 통해 완벽하게 구현할 경계와 부분적으로 구현할 경계, 무시할 경계가 무엇인지 결정해야만 한다.&lt;/p>
&lt;p>그렇지만 프로젝트 초반에는 경계를 쉽게 결정할 수 없기 때문에 한번에 정해지는 것은 아니므로, 시스템이 발전함에 따라 주의를 기울여야한다.&lt;/p>
&lt;ul>
&lt;li>경계가 필요할 수 있는 부분에 주목한다.&lt;/li>
&lt;li>경계가 존재하지 않아 생기는 마찰의 첫 조짐을 신중하게 관찰한다.
&lt;ul>
&lt;li>경계를 구현하는 비용가 무시할 때 감수할 비용을 가늠해본다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>결정된 사항을 자주 검토한다.&lt;/li>
&lt;/ul>
&lt;p>경계의 구현 비용이 그것을 무시하여 생기는 비용보다 적어지는 시점에 경계를 구현해야하며, 적절한 시점에 경계를 구현하기 위해 빈틈없이 지켜봐야한다.&lt;/p></description></item><item><title>24. 부분적 경계</title><link>https://codemario318.github.io/post/clean-architecture/24/</link><pubDate>Thu, 04 Apr 2024 08:49:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/24/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/24/cover.png" alt="Featured image of post 24. 부분적 경계" />&lt;p>아키텍처 경계를 완벽하게 만드는 데는 엄청난 노력을 기율여야 하고, 유지하는 데도 엄청난 노력이 든다.&lt;/p>
&lt;ul>
&lt;li>쌍방향의 다형적 &lt;code>Boundary&lt;/code> 인터페이스&lt;/li>
&lt;li>&lt;code>Input&lt;/code>, &lt;code>Output&lt;/code>을 위한 데이터 구조&lt;/li>
&lt;li>두 영역을 독립적으로 컴파일하고 배포할 수 있는 컴포넌트로 격리하는 데 필요한 모든 의존성 관리&lt;/li>
&lt;/ul>
&lt;p>많은 경우에 이러한 경계를 만드는 비용이 크다고 판단하면서도, 필요한 작업만 해야한다는 XP 원칙인 &lt;strong>YAGNI&lt;/strong>(You Aren&amp;rsquo;t going to Need It)을 위배하며 나중에 필요할 것이라 예상대는 것들에 대한 대비하길 원한다.&lt;/p>
&lt;p>이렇게 필요할 것으로 예상되는 것을 꼭 대비해야 한다면 완벽한 경계가 아닌 &lt;strong>부분적 경계&lt;/strong>(Patial boundary)를 활용해 볼 수 있다.&lt;/p>
&lt;h2 id="마지막-단계를-건너-뛰기">마지막 단계를 건너 뛰기&lt;/h2>
&lt;p>독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 방법이다.&lt;/p>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>다수의 컴포넌트를 관리하는 작업을 하지 않아도 된다.&lt;/li>
&lt;li>추적을 위한 버전 번호도 필요없다.&lt;/li>
&lt;li>배포 관리 부담이 없다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>부분적 경계를 만들기 위해 완벽한 경계를 만들 때 만큼의 코드량과 사전 설계가 필요하다.&lt;/li>
&lt;li>시간이 흐르며 별도로 분리한 컴포넌트가 재사용될 가능성이 전혀 없을 것임이 명백해지는 경우가 있다.&lt;/li>
&lt;li>시간이 흐르며 컴포넌트 사이의 구분이 점점 약화된다.&lt;/li>
&lt;/ul>
&lt;h2 id="일차원-경계">일차원 경계&lt;/h2>
&lt;p>완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 &lt;code>Boundary&lt;/code> 인터페이스를 사용하는데, 이러한 형태는 초기 설정할 때나 지속적으로 유지할 때도 비용이 많이 든다.&lt;/p>
&lt;p>이러한 경우 추후 완벽한 형태의 경계로 확장할 수 있는 공간을 확보하고자 할 때, 전통적인 전략 패턴을 사용하여 간단한 구조를 활용해 볼 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/24/img.png"
width="720"
height="292"
srcset="https://codemario318.github.io/post/clean-architecture/24/img_huf66003e0682ccdb8f85feab7e684d52d_81657_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/24/img_huf66003e0682ccdb8f85feab7e684d52d_81657_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="246"
data-flex-basis="591px"
>&lt;/p>
&lt;p>&lt;code>Client&lt;/code>를 &lt;code>ServiceImpl&lt;/code>로 부터 격리시키는 데 필요한 의존성 역전이 적용되었기 때문에 미래에 필요한 아키텍처 경계를 대비할 수 있다.&lt;/p>
&lt;p>하지만 이러한 형태의 분리는 쌍방향 인터페이스가 없고 개발자와 아키텍트의 능력에 따라, 점선과 같은 비밀 통로가 생기는 일을 막을 방법이 없다.&lt;/p>
&lt;h2 id="퍼사드">퍼사드&lt;/h2>
&lt;p>더 단순한 경계는 퍼사드 패턴으로, 이 경우에는 의존성 역전까지 희생한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/24/img_1.png"
width="720"
height="299"
srcset="https://codemario318.github.io/post/clean-architecture/24/img_1_huda7c855c7c3463c0aff875896060fffa_46486_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/24/img_1_huda7c855c7c3463c0aff875896060fffa_46486_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="240"
data-flex-basis="577px"
>&lt;/p>
&lt;p>경계는 &lt;code>Facade&lt;/code> 클래스로만 간단히 전의되며, 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 서비스 클래스로 호출을 전달한다.&lt;/p>
&lt;p>클라이언트는 서비스 클래스에 직접 접근할 수 없지만, &lt;code>Client&lt;/code>가 이 모든 서비스 클래스에 대해 추이 종속성을 가지게 된다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>추이 종속성&lt;/strong>&lt;br>
A 모듈이 B 모듈에 의존하고, B 모듈이 C 모듈에 의존한다고 가정할 때, A 모듈은 직접적으로는 C 모듈에 의존하지 않지만, B 모듈을 통해 C 모듈에 간접적으로 의존하는 형태&lt;/p>
&lt;/blockquote>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>아키텍처 경계를 부분적으로 구현하는 방법은 많다.&lt;/p>
&lt;p>이러한 접근법은 각각 나름의 비용과 장점을 지니며, 완벽한 형태의 경계를 담기 위한 공간으로써 적절하게 사용할 수 있는 상황이 서로 다르다.&lt;/p>
&lt;p>부분적인 경계는 추후에 완벽한 형태의 경계가 실제로 구체화되지 않으면 가치가 떨어질 수 있다.&lt;/p></description></item><item><title>23. 프레젠터와 험블 객체</title><link>https://codemario318.github.io/post/clean-architecture/23/</link><pubDate>Wed, 03 Apr 2024 22:31:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/23/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/23/cover.png" alt="Featured image of post 23. 프레젠터와 험블 객체" />&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/23/img.png"
width="772"
height="567"
srcset="https://codemario318.github.io/post/clean-architecture/23/img_hudd764f775c86d6d6fb1802d465c14dac_405598_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/23/img_hudd764f775c86d6d6fb1802d465c14dac_405598_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="326px"
>&lt;/p>
&lt;p>프레젠터는 험블 객체(Humble Object) 패턴을 따른 형태로, 아키텍처 경계를 식별하고 보호하는 데 도움이 된다.&lt;/p>
&lt;h2 id="험블-객체-패턴">험블 객체 패턴&lt;/h2>
&lt;p>험블 객체 패턴은 디자인 패턴으로, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.&lt;/p>
&lt;ul>
&lt;li>행위들을 두 개의 모듈 또는 클래스로 나눈다.&lt;/li>
&lt;li>가장 기본적인 본질은 남기고, 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다.&lt;/li>
&lt;li>나머지 모듈에는 험블 객체에 속하지 않은, 테스트하기 쉬운 행위를 모두 옮긴다.&lt;/li>
&lt;/ul>
&lt;h2 id="프레젠터와-뷰">프레젠터와 뷰&lt;/h2>
&lt;p>GUI는 화면에서 각 요소가 필요한 위치에 적절히 표시되었는지 테스트 해야하므로 작성하기 어려운 반면, GUI에서 수행하는 행위의 대다수는 쉽게 테스트할 수 있다.&lt;/p>
&lt;p>험블 객체 패턴을 사용하면 두 부류의 행위를 분리하여 프레젠터와 뷰라는 서로 다른 클래스로 만들 수 있다.&lt;/p>
&lt;p>&lt;strong>뷰&lt;/strong>&lt;br>
뷰는 데이터를 GUI로 이동시키지만, 데이터를 직접 처리하지는 않는다.&lt;/p>
&lt;ul>
&lt;li>험블 객체이고 테스트하기 어렵다.&lt;/li>
&lt;li>포함된 코드를 가능한 간단하게 유지한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>프레젠터&lt;/strong>&lt;br>
애플리케이션으로 부터 데이터를 받아 화면에 표현할 수 있는 포멧으로 만든다.&lt;/p>
&lt;ul>
&lt;li>뷰가 데이터를 받아 화면에 전달하는 간단한 일만 처리하도록 만들어준다.&lt;/li>
&lt;li>테스트하기 쉬워진다.&lt;/li>
&lt;/ul>
&lt;p>뷰는 뷰 모델의 데이터를 화면으로 로드할 뿐이며, 이 외에 뷰가 맡은 역할은 전혀 없기 때문에 뷰는 보잘것없다(Humble)&lt;/p>
&lt;h2 id="테스트와-아키텍처">테스트와 아키텍처&lt;/h2>
&lt;p>테스트 용이성은 좋은 아키텍처가 지녀야 할 속성으로 오랫동안 알려저 왔다.&lt;/p>
&lt;p>험블 객체 패턴은 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하여 아키텍처 경계를 정의하므로 테스트가 용이하다.&lt;/p>
&lt;p>즉, 아키텍처에 험블 객체 패턴을 적절히 활용하면 프레젠터와 뷰와 같이 테스트가 용이한 구조를 만들 수 있다.&lt;/p>
&lt;h2 id="데이터베이스-게이트웨이">데이터베이스 게이트웨이&lt;/h2>
&lt;p>유스케이스 인터랙터와 데이터베이스 사이에는 데이터베이스 게이트웨이(데이터베이스의 쿼리를 처리하는 모든 메서드가 포함)가 위치한다.&lt;/p>
&lt;p>유스케이스 레이어는 SQL을 허용하지 않아야 하므로 필요한 메서드를 제공하는 게이트웨이 인터페이스를 호출하게 되는데, 이 때 데이터베이스 레이어에 존재하는 &lt;strong>인터페이스의 구현체&lt;/strong>가 험블 객체이다.&lt;/p>
&lt;p>이와 달리 인터랙터는 애플리케이션에 특화된 업무 규칙을 캡슐화화기 때문에 험블 객체가 아니기 때문에 게이트웨이는 가짜 데이터(Mock, stub, test-double, fake)를 통해서도 테스트를 할 수 있으므로 테스트하기 쉬워진다.&lt;/p>
&lt;h2 id="데이터-매퍼">데이터 매퍼&lt;/h2>
&lt;p>하이버네이트와 같은 ORM은 어느 계층에 속하는가?&lt;/p>
&lt;p>ORM 시스템은 데이터베이스 레이어에 위치하며 게이트웨이 인터페이스와 데이터베이스 사이의 일종에 또 다른 험블 객체 경계를 형성한다.&lt;/p>
&lt;ul>
&lt;li>사용자 관점에서 객체는 공개된 메서드만 볼 수 있으므로, 단순히 오퍼레이션의 집합이다.&lt;/li>
&lt;li>&lt;strong>데이터 구조&lt;/strong>는 함축된 행위를 가지지 않는 공개된 변수의 집합이다.&lt;/li>
&lt;/ul>
&lt;p>객체는 데이터 구조가 아니기 때문에, 사실 객체 관계 매퍼(Object Relational Mapper, ORM)는 관계형 데이터베이스 테이블로부터 가져온 데이터를 데이터 구조에 맞게 담아주는 역할을 수행하므로 사실 데이터 매퍼라고 볼 수 있다.&lt;/p>
&lt;h2 id="서비스-리스너">서비스 리스너&lt;/h2>
&lt;p>서비스에서도 험블 객체 패턴을 발견할 수 있다.&lt;/p>
&lt;p>애플리케이션은 데이터를 간단한 데이터 구조 형태로 로드한 후, 이 데이터 구조를 경계를 거슬러 특정 모듈로 전달하고, 데이터 구조를 전달받은 모듈이 적절한 포맷으로 만들어 외부 서비스로 전송하게 된다.&lt;/p>
&lt;p>외부로부터 데이터를 수신하는 서비스는 서비스 리스너가 서비스 인터페이스로부터 데이터를 수신하고, 데이터를 애플리케이션에서 사용할 수 있게 간단한 데이터 구조로 포맷을 변경하여 서비스 경계를 가로질러 내부로 전달된다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>아키텍처 경계마다 험블 객체 패턴을 발견할 수 있다.&lt;/p>
&lt;p>경계를 넘나드는 통신은 거의 모두 간단한 데이터 구조를 수반할 때가 많고, 대개 그 경계는 테스트하기 어려운 무언가와 테스트하기 쉬운 무언가로 분리된다.&lt;/p>
&lt;p>이러한 아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다.&lt;/p></description></item><item><title>22. 클린 아키텍처</title><link>https://codemario318.github.io/post/clean-architecture/22/</link><pubDate>Wed, 03 Apr 2024 16:22:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/22/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/22/cover.png" alt="Featured image of post 22. 클린 아키텍처" />&lt;ul>
&lt;li>육각형 아키텍처(Hexagonal Architecture)&lt;/li>
&lt;li>DCI(Data, Context and Interaction)&lt;/li>
&lt;li>BCE(Boundary-Control-Entity)&lt;/li>
&lt;/ul>
&lt;p>위와 같은 아키텍처들의 목적은 &lt;strong>관심사의 분리&lt;/strong>(Separation of concerns)이다.&lt;/p>
&lt;p>소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성할 수 있었다.&lt;/p>
&lt;p>각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함하며, 시스템이 다음과 같은 특징을 가지도록 만든다.&lt;/p>
&lt;ul>
&lt;li>프레임워크 독립성&lt;/li>
&lt;li>테스트 용이성&lt;/li>
&lt;li>UI 독립성&lt;/li>
&lt;li>데이터베이스 독립성&lt;/li>
&lt;li>모든 외부 에이전시에 대한 독립성&lt;/li>
&lt;/ul>
&lt;h2 id="의존성-규칙">의존성 규칙&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/22/img.png"
width="772"
height="567"
srcset="https://codemario318.github.io/post/clean-architecture/22/img_hudd764f775c86d6d6fb1802d465c14dac_405598_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/22/img_hudd764f775c86d6d6fb1802d465c14dac_405598_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="326px"
>&lt;/p>
&lt;p>그림의 각 동원은 소프트웨어의 서로 다른 영역을 표현하는데, 안으로 들어갈수록 고수준의 소프트웨어가 된다.(바깥쪽은 메커니즘, 안쪽은 정책)&lt;/p>
&lt;p>이러한 아키텍처가 동작하도록 하는 가장 중요한 규칙은 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다는 &lt;strong>의존성 규칙&lt;/strong>(Dependency Rule)이다.&lt;/p>
&lt;ul>
&lt;li>내부의 원에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못한다.
&lt;ul>
&lt;li>함수, 클래스, 변수, 엔티티 등&lt;/li>
&lt;li>외부의 원에 선언된 데이터 형식도 내부의 원에서 절대 사용해서는 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>외부 원에 위치한 어떤 것도 내부 원에 영향을 주지 않아야한다.&lt;/p>
&lt;h3 id="엔티티">엔티티&lt;/h3>
&lt;p>엔티티는 전사적인 핵심 업무 규칙을 캡슐화한 것이다.(단순한 단일 애플리케이션이라면 애플리케이션의 업무 객체)&lt;/p>
&lt;ul>
&lt;li>메서드를 가지는 객체&lt;/li>
&lt;li>일련의 데이터 구조와 함수의 집합&lt;/li>
&lt;/ul>
&lt;p>기업의 다양한 애플리케이션에서 엔티티를 재사용할 수만 있다면, 그 형태는 그다지 중요하지 않다.&lt;/p>
&lt;p>운영 관점에서 특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안 된다.&lt;/p>
&lt;h3 id="유스케이스">유스케이스&lt;/h3>
&lt;p>유스케이스 계층의 소프트웨어는 애플리케이션에 특화된 업무 규칙을 포함하며, 시스템의 모든 유스케이스를 캡슐화하고 구현한다.&lt;/p>
&lt;ul>
&lt;li>엔티티로 들어오고 나가는 데이터 흐름을 조정한다.&lt;/li>
&lt;li>엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다.&lt;/li>
&lt;/ul>
&lt;p>유스케이스 레이어를 잘 격리하여 발생한 변경이 엔티티에 영향을 줘서는 안될 뿐만 아니라, 외부 요소에서 발생한 변경이 이 계층에 영향을 줘서도 안된다.&lt;/p>
&lt;p>유스케이스 레이어는 아래와 같은 상황에서만 영향을 받아야한다.&lt;/p>
&lt;ul>
&lt;li>운영 관점에서 애플리케이션이 변경되어 유스케이스 자체가 영향을 받은 경우&lt;/li>
&lt;li>유스케이스의 세부 사항이 변경된 경우&lt;/li>
&lt;/ul>
&lt;h3 id="인터페이스-어댑터">인터페이스 어댑터&lt;/h3>
&lt;p>인터페이스 어댑터 레이어는 일련의 어댑터들(Controllers, Gateways, Presenters)로 구성된다.&lt;/p>
&lt;p>어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환한다.&lt;/p>
&lt;ul>
&lt;li>ex) GUI의 MVC 아키텍처&lt;/li>
&lt;/ul>
&lt;p>모델은 데이터 구조 정도에 지나지 않으며, 컨트롤러에서 유스케이스로 전달되고, 다시 유스케이스에서 프레젠터와 뷰로 되돌아간다.&lt;/p>
&lt;p>인터페이스 어댑터 레이어는 데이터를 엔티티와 유스케이스에게 가장 편리한 형식에서 영속성용으로 사용 중인 임의의 프레임워크(ex. DB)가 이용하기에 가장 편리한 형식으로 변환한다.&lt;/p>
&lt;p>또한 데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또 다른 어댑터가 필요하다.&lt;/p>
&lt;h3 id="프레임워크와-드라이버">프레임워크와 드라이버&lt;/h3>
&lt;p>가장 바깥 레이어인 프레임워크와 드라이버 레이어는 모든 세부사항이 위치하는 곳으로, 일반적으로 데이터베이스나 웹 프레임워크 같은 프레임워크나 도구들로 구성된다.&lt;/p>
&lt;p>이 계층에서는 안쪽 원과 통신하기 위한 접합 코드 외에는 특별히 더 작성해야 할 코드가 그다지 많지 않다.&lt;/p>
&lt;p>웹, 데이터베이스와 같은 세부사항을 모두 외부에 위치시켜서 피해를 최소화한다.&lt;/p>
&lt;h3 id="원은-네-개여야만-하는가">원은 네 개여야만 하는가?&lt;/h3>
&lt;p>그림의 원들은 하나의 예시일 뿐이며 더 많은 원이 필요할 수 있다.&lt;/p>
&lt;p>하지만 어떤 경우에도 &lt;strong>의존성 규칙&lt;/strong>은 적용된다.&lt;/p>
&lt;ul>
&lt;li>소스코드 의존성은 항상 안족을 향한다.&lt;/li>
&lt;li>안쪽으로 이동할수록 추상화와 정책의 수준은 높아진다.&lt;/li>
&lt;li>가장 바깥쪽 원은 저수준의 구체적인 세부사항으로 구성된다.&lt;/li>
&lt;li>안쪽으로 이동할수록 소프트웨어는 점점 추상화되고 더 높은 수준의 정책들을 캡슐화한다.&lt;/li>
&lt;/ul>
&lt;h3 id="경계-횡단하기">경계 횡단하기&lt;/h3>
&lt;p>위 예시에서 컨트롤러와 프레젠터가 다음 계층에 속한 유스케이스와 통신하는 모습을 확인할 수 있다.&lt;/p>
&lt;ol>
&lt;li>컨트롤에서 시작&lt;/li>
&lt;li>유스케이스를 지남&lt;/li>
&lt;li>프레젠터에서 실행&lt;/li>
&lt;/ol>
&lt;p>유스케이스가 내부 원의 인터페이스를 호출하도록 하고, 외부 원의 프레젠터가 그 인터페이스를 구현하도록 만들어 의존성 흐름을 역전시켰다.&lt;/p>
&lt;p>이처럼 제어흐름과 의존성의 방향이 명백히 반대여야 하는 경우, 의존성 역전 원칙을 사용하여 해결한다.&lt;/p>
&lt;ul>
&lt;li>인터페이스와 상속 관계 등&lt;/li>
&lt;/ul>
&lt;p>아키텍처 경계를 횡단할 때 언제라도 동일한 기법을 사용할 수 있다.&lt;/p>
&lt;h3 id="경계를-횡단하는-데이터는-어떤-모습인가">경계를 횡단하는 데이터는 어떤 모습인가?&lt;/h3>
&lt;p>경계를 가로지르는 데이터는 흔히 간단한 데이터 구조로 이루어져 있다.&lt;/p>
&lt;ul>
&lt;li>기본적인 구조체, 간단한 데이터 전송 객체(DTO) 등&lt;/li>
&lt;li>함수 호출 시 간단한 인자&lt;/li>
&lt;li>해시맵, 객체&lt;/li>
&lt;/ul>
&lt;p>중요한 점은 엔티티 객체나 데이터베이스의 행을 전달하는 것이 아닌 격리되어 있는 간단한 데이터 구조가 경계를 가로질러 전달되어야 한다.&lt;/p>
&lt;p>위와 같은 경우 결과적으로 어떠한 형태로든 전달되는 데이터 구조를 통해 내부의 원에서 외부 원의 무언가를 알게 되므로 의존성 규칙을 위배하게된다.&lt;/p>
&lt;p>따라서 경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야한다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>위와같은 간단한 규칙들을 준수하는 것은 어렵지 않으며, 향후에 겪을 수많은 고통거리를 덜어준다.&lt;/p>
&lt;p>소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며, 그에 다른 이점을 누릴 수 있다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스나 프레임워크와 같은 시스템의 외부 요소를 교체하더라도 훨씬 수월해진다.&lt;/li>
&lt;/ul></description></item><item><title>21. 소리치는 아키텍처</title><link>https://codemario318.github.io/post/clean-architecture/21/</link><pubDate>Tue, 02 Apr 2024 16:19:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/21/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/21/cover.png" alt="Featured image of post 21. 소리치는 아키텍처" />&lt;p>건물의 청사진을 살펴본다고 가정했을 때, 커다란 정문, 체크인과 체크아웃을 담당할 사서를 위한 공간, 독서 공간, 작은 회의실, 책장을 배치한 진열실이 나타난다면, 이 아키텍처는 &amp;ldquo;도서관&amp;quot;을 위한 아키텍처임을 예상해볼 수 있다.&lt;/p>
&lt;p>이처럼 잘 만들어진 소프트웨어 아키텍처라면 상위 수준의 디렉터리 구조, 최상위 패키지에 담긴 소스 파일등을 살펴보면 어떠한 역할을 수행하는 소프트웨어인지 한눈에 파악할 수 있다.&lt;/p>
&lt;h2 id="아키텍처의-테마">아키텍처의 테마&lt;/h2>
&lt;blockquote>
&lt;p>소프트웨어 아키텍처는 시스템의 유스케이스를 지원하는 구조이다.&lt;br>
- 이바 야콥슨 Ivar Jacobson,&lt;br>
Object-Oriented Software Engineering: Use Case Driven Approach&lt;/p>
&lt;/blockquote>
&lt;p>소프트웨어 애플리케이션의 아키텍처도 애플리케이션의 유스케이스에 대해 소리처야한다.&lt;/p>
&lt;ul>
&lt;li>아키텍처는 프레임워크에 대한 것이 아니며 절대로 그래서도 안된다.&lt;/li>
&lt;li>아키텍처를 프레임워크로부터 제공받아서는 절대 안된다.&lt;/li>
&lt;/ul>
&lt;p>프레임워크는 사용하는 도구일 뿐, 아키텍처가 준수해야 할 대상이 아니다.&lt;/p>
&lt;p>아키텍처를 프레임워크 중심으로 만들어버리면 유스케이스가 중심이 되는 아키텍처는 절대 나올 수 없다.&lt;/p>
&lt;h2 id="아키텍처의-목적">아키텍처의 목적&lt;/h2>
&lt;p>좋은 아키텍처는 유스케이스를 그 중심에 두기 때문에, 프레임워크나 도구, 환경에 전혀 구애받지 않고 유스케이스를 지원하는 구조를 아무런 문제 없이 기술할 수 있다.&lt;/p>
&lt;ul>
&lt;li>건물의 청사진의 관심사는 목적에 맞는 공간임을 확실히 하는 것이지, 어떤 기법, 재질로 지어지는지 확인하는 것이 아니다.&lt;/li>
&lt;/ul>
&lt;p>좋은 소프트웨어 아키텍처는 유스케이스에 중점을 두며, 지엽적인 관심사에 대한 결합을 분리시켜 개발 환경 문제나 도구에 대해서는 결정을 미루고, 쉽게 번복할 수 있도록 한다.&lt;/p>
&lt;h2 id="하지만-웹은">하지만 웹은?&lt;/h2>
&lt;p>웹은 전달 메커니즘(입출력 장치)이며, 애플리케이션 아키텍처에서도 그와 같이 취급해야한다.&lt;/p>
&lt;ul>
&lt;li>웹을 통해 전달된다는 사실 자체가 세부 사항이므로, 시스템 구조를 지배해서는 안된다.&lt;/li>
&lt;/ul>
&lt;p>시스템 아키텍처는 과도한 문제를 일으키거나 근본적인 아키텍처를 뜯어고치지 않더라도 시스템을 콘솔 앱, 웹 앱, 리치 클라이언트, 웹서비스 앱등 다양한 방식으로 전달할 수 있어야 한다.&lt;/p>
&lt;h2 id="프레임워크는-도구일-뿐-삶의-방식은-아니다">프레임워크는 도구일 뿐, 삶의 방식은 아니다&lt;/h2>
&lt;p>프레임워크는 매우 강력하고 상당히 유용할 수 있지만, 프레임워크가 아키텍처의 기준이 되서는 안된다.&lt;/p>
&lt;p>좋은 아키텍트라면 아키텍처를 유스케이스에 중점을 둔 채 그대로 보존할 수 있을지를 생각해야 하며, 프레임워크가 아키텍처의 중심을 차지하는 일을 막을 수 있는 전략을 개발해야한다.&lt;/p>
&lt;h2 id="테스트하기-쉬운-아키텍처">테스트하기 쉬운 아키텍처&lt;/h2>
&lt;p>아키텍처가 유스케이스를 최우선으로 하고, 이로인해 프레임워크와는 적당한 거리를 둔다면, 프레임워크를 전혀 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다.&lt;/p>
&lt;ul>
&lt;li>테스트를 돌리는 데 웹 서버가 반드시 필요한 상황이 되어서는 안된다.&lt;/li>
&lt;li>데이터베이스가 반드시 연결되어 있어야만 테스트를 돌릴 수 있어서도 안된다.&lt;/li>
&lt;/ul>
&lt;p>엔티티 객체는 반드시 오래된 방식의 간단한 객체(Plain Old Object)여야 하며, 여타 복잡한 것들에 의존해서는 안된다.&lt;/p>
&lt;p>유스케이스 객체가 엔티티 객체를 조작하도록 해야하며, 최종적으로 프레임워크로 인한 어려움을 겪지 않고도 이 모두를 있는 그래도 테스트할 수 있어야 한다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>아키텍처는 유스케이스를 통해 시스템을 이야기해야 하며, 시스템에 적용한 프레임워크에 대해 이야기해서는 안된다.&lt;/p>
&lt;p>시스템이 어떻게 전달될지 알지 못한 상태에서도 시스템의 모든 유스케이스를 이해할 수 있어야한다.&lt;/p></description></item></channel></rss>