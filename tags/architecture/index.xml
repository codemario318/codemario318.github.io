<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Architecture on Mario Blog</title><link>https://codemario318.github.io/tags/architecture/</link><description>Recent content in Architecture on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Sun, 16 Feb 2025 15:56:49 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>2.3 데이터 모델과 질의 언어 - 그래프형 데이터 모델</title><link>https://codemario318.github.io/post/designing-data-intensive-application/2/3/</link><pubDate>Sun, 16 Feb 2025 15:56:49 +0900</pubDate><guid>https://codemario318.github.io/post/designing-data-intensive-application/2/3/</guid><description>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/3/cover.png" alt="Featured image of post 2.3 데이터 모델과 질의 언어 - 그래프형 데이터 모델" />&lt;h2 id="그래프형-데이터-모델">그래프형 데이터 모델&lt;/h2>
&lt;p>애플리케이션이 주로 일대다 관계(트리 구조 데이터)이거나 레코드 간 관계가 없다면 문서 모델이 적합하다.&lt;/p>
&lt;p>하지만 데이터에서 다대다 관계가 매우 일반적이라면 어떻게 해야 할까? 관게형 모델은 &lt;strong>단순한 다대다 관계&lt;/strong>를 다룰 수 있지만, 데이터 간 연결이 더 복잡해지면 그래프로 데이터를 모델링하기 시작하는 편이 더
자연스럽다.&lt;/p>
&lt;p>그래프는 두 유형의 객체로 이뤄지며 이를 통해 많은 유형의 데이터를 그래프로 모델링할 수 있다.&lt;/p>
&lt;ul>
&lt;li>정점(vertex)(노드, 엔티티)&lt;/li>
&lt;li>간선(edge)(관계, 호(arc))&lt;/li>
&lt;/ul>
&lt;p>일반적인 예는 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>소셜 그래프
&lt;ul>
&lt;li>정점은 사람, 간선은 사람들이 알고 있음을 나타냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 그래프
&lt;ul>
&lt;li>정점은 웹 페이지, 간선은 다른 페이지에 대한 링크&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>도로나 철도 네트워크
&lt;ul>
&lt;li>정점은 교차로, 간선은 도로나 철로&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>하지만 그래프는 정점이 모든 같은 유형인 형식, 동종 데이터에 국한되지 않는다. 그래프를 동종 데이터와 마찬가지 방식으로 사용하면 단일 데이터 저장소에 완전히 다른 유형의 객체를 일관성 있게 저장할 수 있는 강력한
방법을 제공한다.&lt;/p>
&lt;ul>
&lt;li>페이스북
&lt;ul>
&lt;li>정점: 사람, 장소, 이벤트, 체크인, 사용자가 작성한 코멘드 등&lt;/li>
&lt;li>간선:
&lt;ul>
&lt;li>어떤 사람이 서로 친구인지&lt;/li>
&lt;li>어떤 위치에서 체크인이 발생했는지&lt;/li>
&lt;li>누가 어떤 포스트에 코멘트를 했는지&lt;/li>
&lt;li>누가 이벤트에 참여했는지 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="속성-그래프">속성 그래프&lt;/h3>
&lt;p>그래프에서 데이터를 구조화하고 질의하는 몇 가지 다른(하지만 관련된) 방법이 있다.&lt;/p>
&lt;p>속성 그래프 모델에서 각 정점은 다음과 같은 요소로 구성된다.&lt;/p>
&lt;ul>
&lt;li>고유한 식별자&lt;/li>
&lt;li>유출(outgoing) 간선 집합&lt;/li>
&lt;li>유입(incoming) 간선 집합&lt;/li>
&lt;li>속성 컬렉션(키-값 쌍)&lt;/li>
&lt;/ul>
&lt;p>각 간선은 다음과 같은 요소로 구성된다.&lt;/p>
&lt;ul>
&lt;li>고유한 식별자&lt;/li>
&lt;li>간선이 시작하는 정점(꼬리 정점)&lt;/li>
&lt;li>간선이 끝나는 정점(머리 정점)&lt;/li>
&lt;li>두 정점 간 관계 유형을 설명하는 레이블&lt;/li>
&lt;li>속성 컬렉션(키-값 쌍)&lt;/li>
&lt;/ul>
&lt;p>아래와 같이 두 개의 관계형 테이블(하나는 정점, 하나는 간선)로 구성된 그래프 저장소를 생각해보면, 머리와 꼬리 정점은 각 간선마다 저장된다. 따라서 정점을 위한 유입 간선과 유출 간선의 집합이 필요하다면
&lt;code>edges&lt;/code> 테이블에 &lt;code>head_vertex&lt;/code>나 &lt;code>tail_vertex&lt;/code>로 각각 질의할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">json&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">edge_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">REFERENCES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">REFERENCES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">text&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">json&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges_tails&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges_heads&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이 모델의 몇 가지 중요한 면은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>정점은 다른 정점과 간선으로 연결된다.
&lt;ul>
&lt;li>특정 유형과 관련 여부를 제한하는 스키마는 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>정점이 주어지면 정점의 유입과 유출 간선을 효율적으로 찾을 수 있고 그래프를 순회할 수 있다.
&lt;ul>
&lt;li>일련의 정점을 따라 앞뒤 방향으로 순회한다.&lt;/li>
&lt;li>이를 위해 &lt;code>tali_vertex&lt;/code>와 &lt;code>head_vertex&lt;/code> 컬럼에 대해 색인을 생성했다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다른 유형의 관계에 서로 다른 레이블을 사용하면 단일 그래프에 다른 유형의 정보를 저장하면서도 데이터 모델을 깔끔하게 유지할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이러한 기능을 통해 그래프는 데이터 모델링을 위한 많은 유연성을 제공한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img.png"
width="925"
height="564"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_hue7842d50d38e3b2e6ac6ca2ece9154d3_90342_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_hue7842d50d38e3b2e6ac6ca2ece9154d3_90342_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="그래프 구조 데이터"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="393px"
>&lt;/p>
&lt;p>위 그림에서 전통적인 관계형 스키마에서 표현하기 어려운 사례 몇 가지를 살펴볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>국가마다 다른 지역 구조
&lt;ul>
&lt;li>프랑스에서는 주(departement)와 도(region)&lt;/li>
&lt;li>미국에서는 군(country)과 주(state)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위 예시에서 루시와 알랭 또는 그 밖의 사람에 대한 다른 여러 사실을 포함시키기 위해 그래프를 확장해야한다면, 새로운 관심사를 정점으로 만들고 연결하기만 하면 된다.&lt;/p>
&lt;p>그래프는 발전성이 좋아서 애플리케이션에 기능을 추가하는 경우 애플리케이션의 데이터 구조 변경을 수용하게끔 그래프를 쉽게 확장할 수 있다.&lt;/p>
&lt;h3 id="사이퍼-질의-언어">사이퍼 질의 언어&lt;/h3>
&lt;p>사이퍼(Cypher)는 속성 그래프를 위한 선언형 질의 언어로, Neo4j 그래프 데이터베이스용으로 만들어졌다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img.png"
width="925"
height="564"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_hue7842d50d38e3b2e6ac6ca2ece9154d3_90342_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_hue7842d50d38e3b2e6ac6ca2ece9154d3_90342_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="그래프 구조 데이터"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="393px"
>&lt;/p>
&lt;p>사이퍼로 왼쪽 부분을 그래프 데이터베이스로 삽입하려면 아래와 같은 질의가 필요하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">CREATE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (NAmerica:Location {name:&amp;#39;North America&amp;#39;, type:&amp;#39;continent&amp;#39;}),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (USA:Location
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Idaho:Location
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Lucy:Person
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Idaho) -[:WITHIN]-&amp;gt; (USA) -[:WITHIN]-&amp;gt; (NAmerica),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Lucy) -[:BORN_IN]-&amp;gt; (Idaho)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>각 정점에는 USA나 Idaho 같은 상징적인 이름이 지정돼있고, 질의의 다른 부분에서 이 이름을 사용해 정점간 간선을 화살표 표기를 사용해 만들 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>미국에서 유럽으로 이민 온 모든 사람들의 이름 찾기&lt;/strong>&lt;/p>
&lt;p>더 정확하게 말하면 미국 내 위치의 &lt;code>BORN_IN&lt;/code> 간선을 가진 정점과 유럽 내 위치의 &lt;code>LIVING_IN&lt;/code> 간선을 갖는 모든 정점을 찾아서 이 정점들의 &lt;code>name&lt;/code> 속성을 반호나하는 문제이다.&lt;/p>
&lt;p>&lt;code>MATCH&lt;/code> 문에서는 같은 화살표 표기를 이용해 그래프에서 패턴을 찾는다.&lt;/p>
&lt;p>&lt;code>(person) -[:BORN_IN]-&amp;gt; ()&lt;/code>는 &lt;code>BORN_IN&lt;/code> 레이블을 가진 간선과 관련된 두 정점을 찾는다. 이 간선의 꼬리 정점은 &lt;code>person&lt;/code> 변수에 묶여 있고 머리 정점은 명기하지 않는 채로
남아있게된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">MATCH
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (person) -[:BORN_IN]-&amp;gt; () -[:WITHIN*0..]-&amp;gt; (us:Location {name:&amp;#39;United States&amp;#39;}),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (person) -[:LIVES_IN]-&amp;gt; () -[:WITHIN*0..]-&amp;gt; (eu:Location {name:&amp;#39;Europe&amp;#39;})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RETURN person.name
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>&lt;code>person&lt;/code>은 어떤 정점을 향하는 &lt;code>BORN_IN&lt;/code> 유출 간선을 가지며, 이 정점에서 &lt;code>name&lt;/code> 속성이 &amp;ldquo;United States&amp;quot;인 &lt;code>Location&lt;/code> 유형의 정점에 도달할 때까지 일련의 &lt;code>WITHIN&lt;/code>
유출 간선을 따라간다.&lt;/li>
&lt;li>같은 &lt;code>person&lt;/code>의 정점은 &lt;code>LIVES_IN&lt;/code> 유출 간선도 가지는데, 이 간선과 &lt;code>WITHIN&lt;/code> 유출 간선을 따라가면 결국 &lt;code>name&lt;/code> 속성이 &amp;ldquo;Europe&amp;quot;인 &lt;code>Location&lt;/code> 유형의 정점에
도달하게된다.&lt;/li>
&lt;li>각 &lt;code>person&lt;/code> 정점마다 &lt;code>name&lt;/code> 속성을 반환한다.&lt;/li>
&lt;/ol>
&lt;p>질의를 실행하는 데는 여러 가지 방법이 있다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스에서 모든 사람을 홅어보는 작업을 시작으로 사람들의 출생지와 거주지를 확인해 기준에 맞는 사람들만 반환&lt;/li>
&lt;li>두 개의 &lt;code>Location&lt;/code> 정점에서 시작해 반대 방향으로 수행
&lt;ul>
&lt;li>&lt;code>name&lt;/code> 속성에 색인이 있다면 미국과 유럽을 나타내는 두 개의 정점을 효율적으로 찾을 수 있음&lt;/li>
&lt;li>&lt;code>WITHIN&lt;/code> 유입 간선을 따라겨 미국과 유럽의 모든 위치 찾기를 진행&lt;/li>
&lt;li>위치를 나타내는 정점 중 하나에서 &lt;code>BORN_IN&lt;/code>이나 &lt;code>LIVE_IN&lt;/code> 유입 간선을 통해 발견된 사람을 구함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>보통 선언형 질의 언어는 질의를 작성할 때 이처럼 수행에 대해 자세히 지정할 필요가 없다. 질의 최적화기가 가장 효율적이라고 예측한 전략을 자동으로 선택하므로 작성자는 나머지 애플리케이션만 작성하면 된다.&lt;/p>
&lt;h3 id="sql의-그래프-질의">SQL의 그래프 질의&lt;/h3>
&lt;p>위에서 언급한 것 처럼 관계형 데이터베이스에서 그래프 데이터를 표현할 수 있음을 제안하였다.&lt;/p>
&lt;p>그래프를 관계형 구조로 넣어도 SQL을 통해 질의할 수 있지만, &lt;strong>어렵다&lt;/strong>. 관계형 데이터베이스에서는 대개 질의에 필요한 조인을 미리 알고 있는데, 그래프 질의에서는 찾고자 하는 정점을 찾기 전에 가변적인 여러
간선을 순회해야하기 때문이다.&lt;/p>
&lt;ul>
&lt;li>미리 조인 수를 고정할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>예제에서 간선 순회는 사이퍼 질의의 &lt;code>() -[:WITHIN*0..]-&amp;gt; ()&lt;/code> 문에서 발생한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>person&lt;/code>의 &lt;code>LIVES_IN&lt;/code> 간선은 위치 유형(거리, 도시, 지구, 군, 주 등)을 가리킨다.&lt;/li>
&lt;li>각각 &amp;ldquo;도시 -&amp;gt; 군 -&amp;gt; 주 -&amp;gt; 주 -&amp;gt; 국가&amp;rdquo; 순으로 &lt;code>WITHIN&lt;/code> 간선으로 이어진다.
&lt;code>LIVES_IN&lt;/code> 간선은 찾고자 하는 위치 정점을 직접 가르킬 수 있으나 위치 계층 구조에서 제거된 일부 수준일 수도 있다.&lt;/li>
&lt;/ul>
&lt;p>사이퍼에서 &lt;code>:WITHIN*0..&lt;/code>은 0회 이상 &lt;code>WITHIN&lt;/code> 간선을 따라가라는 의미로 이를 간결하게 표현한다.&lt;/p>
&lt;p>SQL:1999 이후 가변 순회 경로에 대한 질의 개념은 &lt;strong>재귀 공통 테이블 식&lt;/strong>(recursive common table expression, &lt;code>WITH RECURSIVE&lt;/code>)을 사용해서 표현할 수 있지만
사이퍼와 비교했을 때 문법이 어렵다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">WITH&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">RECURSIVE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">-- in_usa is the set of vertex IDs of all locations within the United States
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_usa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&amp;gt;&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;name&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;United States&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">UNION&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- 2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_usa&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;within&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">-- in_europe is the set of vertex IDs of all locations within Europe
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_europe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- 3
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&amp;gt;&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;name&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Europe&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">UNION&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_europe&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_europe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;within&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">-- born_in_usa is the set of vertex IDs of all people born in the US
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">born_in_usa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- 4
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_usa&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;born_in&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">-- lives_in_europe is the set of vertex IDs of all people living in Europe
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lives_in_europe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- 5
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_europe&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_europe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;lives_in&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&amp;gt;&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;name&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-- join to find those people who were both born in the US *and* live in Europe
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">born_in_usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">born_in_usa&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- 6
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lives_in_europe&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lives_in_europe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;code>name&lt;/code> 속성이 &amp;ldquo;United States&amp;quot;인 정점을 찾아 &lt;code>in_usa&lt;/code> 정점 집합의 첫 번째 엘리먼트로 만든다.&lt;/li>
&lt;li>&lt;code>in_usa&lt;/code> 집합의 모든 정점들의 모든 &lt;code>within&lt;/code> 유입 간선을 따라가 같은 집합에 추가한다.
&lt;ul>
&lt;li>모든 &lt;code>within&lt;/code> 간선을 방문할 때까지 수행한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>name&lt;/code> 속성이 &amp;ldquo;Europe&amp;quot;인 정점을 시작으로 동일하게 수행해 &lt;code>in_europe&lt;/code> 집합을 만든다.&lt;/li>
&lt;li>미국에서 태어난 사람을 찾기 위해 &lt;code>in_usa&lt;/code> 집합의 각 정점에 대해 &lt;code>born_in&lt;/code> 유입 간선을 따라간다.&lt;/li>
&lt;li>비슷하게 유럽에서 사는 사람을 찾기 위해 &lt;code>in_europe&lt;/code> 집합의 각 정점에 대해 &lt;code>lives_in&lt;/code> 유입 간선을 따라간다.&lt;/li>
&lt;li>마지막으로 조인을 이용해 미국에서 태어난 사람 집합과 유럽에서 사는 사람 집합의 교집합을 구한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>동일한 질의를, cypher는 4줄로 작성하고, SQL은 29줄로 작성해야 한다. 이는 다양한 데이터 모델이 서로 다른 사용 사례를 만족하기 위해 설계되었다는 사실을 반증한다.&lt;/p>
&lt;p>따라서 애플리케이션에 적합한 데이터 모델 선택 작업은 중요하다.&lt;/p>
&lt;h3 id="트리플-저장소와-스파클">트리플 저장소와 스파클&lt;/h3>
&lt;p>트리플 저장소 모델은 속성 그래프 모델과 거의 동등하다.&lt;/p>
&lt;p>이 모델은 같은 생각을 다른 용어를 사용해 설명한다. 그럼에도 애플리케이션 구축에 유용한 도구일지도 모를 트리플 저장소를 위한 ㄷ양한 도구와 언어가 있기 때문에 논의할 만한 가치가 있다.&lt;/p>
&lt;p>트리플 저장소에서는 모든 정보를 &lt;strong>주어&lt;/strong>(subject), &lt;strong>서술어&lt;/strong>(predicate), 목적어(object) 처럼 매우 간단한 &lt;strong>세 부분 구문&lt;/strong>(three-part statements) 형식으로
저장한다.&lt;/p>
&lt;p>트리플의 주어는 그래프의 정점과 종등하며, 목적어는 두 가지중 하나이다.&lt;/p>
&lt;ul>
&lt;li>문자열이나 숫자 같은 원시 데이터타입의 값
&lt;ul>
&lt;li>트리플의 서술어와 목적어는 주어 정점에서 속성의 키, 값과 동등하다.&lt;/li>
&lt;li>(루시, 나이, 33)은 &lt;code>{&amp;quot;age&amp;quot;:33}&lt;/code> 속성을 가진 정점 lucy와 같다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>그래프의 다른 정점
&lt;ul>
&lt;li>서술어는 그래프의 간선이고 주어는 꼬리 정점이며 목적어는 머리 정점이다.&lt;/li>
&lt;li>(루시, 결혼하다, 알랭)에서 주어와 목적어인 루시와 알랭은 정점이고, 서술어 결혼하다는 두 정점을 잇는 간선의 레이블이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img.png"
width="925"
height="564"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_hue7842d50d38e3b2e6ac6ca2ece9154d3_90342_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_hue7842d50d38e3b2e6ac6ca2ece9154d3_90342_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="그래프 구조 데이터"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="393px"
>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-turtle" data-lang="turtle">&lt;span class="line">&lt;span class="cl">&lt;span class="k">@prefix&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nv">&amp;lt;urn:example:&amp;gt;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">lucy&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Person&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">lucy&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Lucy&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">lucy&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">bornIn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">idaho&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">idaho&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Location&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">idaho&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Idaho&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">idaho&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;state&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">idaho&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">within&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">usa&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Location&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;United States&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;country&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">within&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">namerica&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">namerica&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Location&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">namerica&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;North America&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">namerica&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;continent&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위 예제는 그림의 일부를 보여주며 &lt;strong>터틀&lt;/strong>(Turtle) 형식의 트리플로 작성되었다.(터틀은 &lt;strong>Notation3&lt;/strong>(N3)의 부분 집합이다.)&lt;/p>
&lt;p>그래프의 정점을 &lt;code>_:someName&lt;/code>으로 작성했는데 이 파일 외부의 것을 의미하지 않는다, &lt;code>_:someName&lt;/code>은 트리플이 같은 정점을 참조하는지 달리 알지 못하기 때문에 존재한다.&lt;/p>
&lt;p>서술어가 간선을 나타내면 목적어는 &lt;code>_:usa :within _:usa&lt;/code> 처럼 정점이 되고, 서술어가 속성이라면 목적어는 &lt;code>_:usa :name &amp;quot;United States&amp;quot;&lt;/code> 처럼 문자열 리터럴이된다.&lt;/p>
&lt;p>동일한 주어를 반복하는 작업은 단순 반복 작업으로, 세미콜론을 사용해 동일한 주어에 대해 여러 경우를 잘 표한할 수 있게되어 터틀 형식을 읽기 쉽게 만든다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-turtle" data-lang="turtle">&lt;span class="line">&lt;span class="cl">&lt;span class="k">@prefix&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nv">&amp;lt;urn:example:&amp;gt;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">lucy&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Person&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Lucy&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">bornIn&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">idaho&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">idaho&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Location&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Idaho&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;state&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">within&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">usa&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Location&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;United States&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;country&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">within&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">namerica&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">_&lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">namerica&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">Location&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;North America&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">:&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;continent&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="시맨틱-웹">시맨틱 웹&lt;/h3>
&lt;p>트리플 저장소에 관한 내용을 읽다보면 &lt;strong>시맨틱 웹&lt;/strong>관련 기사들을 많이 접할 수 있지만, 트리플 저장소 데이터 모델은 시맨틱 웹과는 완전히 독립적이다.&lt;/p>
&lt;p>하지만 많은 사람들이 이 둘이 매우 밀접한 관계가 있다고 생각하기때문에 간략화게 논의할 필요가 있다.&lt;/p>
&lt;p>시맨틱 웹은 즉 웹 사이트는 이미 사람이 읽을 수 있는 텍스트와 그림으로 정보를 게시하고 있으니 &lt;strong>컴퓨터가 읽게끔 기계가 판독 가능한 데이터로도 정보를 게시하는 건 어떨까&lt;/strong>?라는 개념이다.&lt;/p>
&lt;p>&lt;strong>자원 기술 프레임워크(Resource Description Framework, RDF)&lt;/strong> 는 서로 다른 웹 사이트가 일관된 형식으로 데이터를 게시하기 위한 방법을 제안한다.&lt;/p>
&lt;p>RDF는 서로 다른 웹 사이트의 데이터가 일종의 전 인터넷 &amp;ldquo;만물 데이터베이스(database of everything)&amp;ldquo;인 &lt;strong>데이터 웹(web of data)&lt;/strong> 에 자동으로 결함할 수 있게 한다.&lt;/p>
&lt;p>시맨틱 웹은 2000년대 초반에 과대평가됐고 지금까지 현실에서 실현된 흔적이 없어 많은 사람이 부정적인 견해를 보였다.&lt;/p>
&lt;ul>
&lt;li>어지러운 약어의 과잉과 지나치게 복잡한 표준 제안, 자만심으로 어려움을 겪었다.&lt;/li>
&lt;/ul>
&lt;p>하지만 이런 단점들이 있음에도 시맨틱 웹 프로젝트에서 유래한 좋은 작업이 많이 있으며, 시맨틱 웹에서 RDF 데이터를 게시하는 일어 관심이 없다고 하더라도 트리플은 &lt;strong>애플리케이션의 훌륭한 내부 데이터 모델&lt;/strong>이 될
수 있다.&lt;/p>
&lt;h3 id="rdf-데이터-모델">RDF 데이터 모델&lt;/h3>
&lt;p>터틀 언어는 RDF 데이터를 사람이 읽을 수 있는 형식으로 표현한다. XML 형식으로 쓰기도 하지만, XML 형식은 같은 내용을 훨씬 장황하게 만든다.&lt;/p>
&lt;p>한눈에 쉽게 보기 위해서는 터틀/N3를 선호하며 아파치 제나 같은 도구는 필요한 경우 서로 다른 RDF 형식으로 자동 변환할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;rdf:RDF&lt;/span> &lt;span class="na">xmlns=&lt;/span>&lt;span class="s">&amp;#34;urn:example:&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">xmlns:rdf=&lt;/span>&lt;span class="s">&amp;#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Location&lt;/span> &lt;span class="na">rdf:nodeID=&lt;/span>&lt;span class="s">&amp;#34;idaho&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;name&amp;gt;&lt;/span>Idaho&lt;span class="nt">&amp;lt;/name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;type&amp;gt;&lt;/span>state&lt;span class="nt">&amp;lt;/type&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;within&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Location&lt;/span> &lt;span class="na">rdf:nodeID=&lt;/span>&lt;span class="s">&amp;#34;usa&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;name&amp;gt;&lt;/span>United States&lt;span class="nt">&amp;lt;/name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;type&amp;gt;&lt;/span>country&lt;span class="nt">&amp;lt;/type&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;within&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Location&lt;/span> &lt;span class="na">rdf:nodeID=&lt;/span>&lt;span class="s">&amp;#34;namerica&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;name&amp;gt;&lt;/span>North America&lt;span class="nt">&amp;lt;/name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;type&amp;gt;&lt;/span>continent&lt;span class="nt">&amp;lt;/type&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Location&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/within&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Location&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/within&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Location&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Person&lt;/span> &lt;span class="na">rdf:nodeID=&lt;/span>&lt;span class="s">&amp;#34;lucy&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;name&amp;gt;&lt;/span>Lucy&lt;span class="nt">&amp;lt;/name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;bornIn&lt;/span> &lt;span class="na">rdf:nodeID=&lt;/span>&lt;span class="s">&amp;#34;idaho&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Person&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/rdf:RDF&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>RDF는 인터넷 전체의 데이터 교환을 위해 설계했기 때문에 약간 이상한 점이 있다.&lt;/p>
&lt;p>첫 번째로 트리플의 주어, 서술어, 목적어는 주로 URI다.&lt;/p>
&lt;p>서술어는 &lt;code>WITHIN&lt;/code>이나 &lt;code>LIVES_IN&lt;/code>이 아니라 &lt;code>&amp;lt;http://my-company.com/namespace#within&amp;gt;&lt;/code>, &lt;code>&amp;lt;http://my-company.com/namespace#lives_in&amp;gt;&lt;/code>
같은 URL일 수 있는데, 이러한 설계의 배경은 데이터를 다른 사람의 데이터와 결합하기 위함이다.&lt;/p>
&lt;p>만약 &lt;code>within&lt;/code>이나 &lt;code>lives_in&lt;/code> 단어에 다른 의미를 붙이면 서술어는 &lt;code>&amp;lt;http://other.org/foo#within&amp;gt;&lt;/code>, &lt;code>&amp;lt;http://other.org/foo#lives_in&amp;gt;&lt;/code>이므로 충돌이
발생하지 않게된다.&lt;/p>
&lt;p>두 번째로 URL은 반드시 실제 접속 가능한 주소일 필요는 없다는 점으로, RDF의 관점에서는 하나의 네임 스페이스를 의미할 뿐이다.&lt;/p>
&lt;h3 id="스파클-질의-언어">스파클 질의 언어&lt;/h3>
&lt;p>스파클(SPARQL)은 RDF 데이터 모델을 사용한 트리플 저장소 질의 언어이다.(SPARQL Protocol and RDF Query Language)&lt;/p>
&lt;p>스파클을 사이퍼보다 먼저 만들었고 사이퍼의 패턴 매칭을 스파클에서 차용했기 때문에 매우 유사해보인다.&lt;/p>
&lt;p>앞에서 살펴본 무국에서 유럽으로 이주한 사람을 찾는 질의는 사이퍼보다 스파클에서 더욱 간결해진다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">PREFIX : &amp;lt;urn:example:&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT ?personName
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WHERE {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ?person :name ?personName.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ?person :bornIn / :within* / :name &amp;#34;United States&amp;#34;.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ?person :livesIn / :within* / :name &amp;#34;Europe&amp;#34;.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>구조는 매우 유사하며 다음 두 표현식은 동등하다.&lt;/p>
&lt;ul>
&lt;li>스파클에서 변수는 물음표로 시작&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(person) -[:BORN_IN]-&amp;gt; () -[:WITHIN*0..]-&amp;gt; (location) # Cypher
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">?person :bornIn / :within* ?location. # SPARQL
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>RDF는 속성과 간선을 구별하지 않고 서술어만 사용하기 때문에 속성 매칭을 위해 동일한 구문을 사용할 수 있다.&lt;/p>
&lt;p>다음 표현식에 따르면 &lt;code>usa&lt;/code> 변수는 문자열 값이 &lt;code>&amp;quot;United States&amp;quot;&lt;/code>인 &lt;code>name&lt;/code> 속성을 가진 모든 정점이어야 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(usa {name:&amp;#39;United States&amp;#39;}) # Cypher
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">?usa :name &amp;#34;United States&amp;#34;. # SPARQL
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>스파클은 훌륭한 질의 언어로 시멘틱 웹이 아니더라도 애플리케이션이 내부적으로 사용하는 강력한 도구가 될 수 있다.&lt;/p>
&lt;h3 id="초석-데이터로그">초석: 데이터로그&lt;/h3>
&lt;p>&lt;strong>데이터로그(Datalog)&lt;/strong> 는 스파클이나 사이퍼보다 훨씬 오래된 언어로 1980년대 학계에서 광범위하게 연구되었다.&lt;/p>
&lt;p>소프트웨어 엔지니어 사이에서는 잘 알려져 있지 않지만 그럼에도 중요한 이유는 이후 질의 언어의 기반이 되는 초석을 제공하기 때문이다.&lt;/p>
&lt;p>데이터로그의 데이터 모델은 트리플 저장소 모델과 유사하지만 조금 더 일반화되었다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>(주어, 서술어, 목적어)&lt;/code>로 트리플을 작성하는 대신 &lt;code>서술어(주어, 목적어)&lt;/code>로 작성한다.&lt;/li>
&lt;/ul>
&lt;p>지금까지 예시로 주어졌던 데이터를 데이터로그로 표현아면 아래와 같다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">name(namerica, &amp;#39;North America&amp;#39;).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">type(namerica, continent).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">name(usa, &amp;#39;United States&amp;#39;).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">type(usa, country).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">within(usa, namerica).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">name(idaho, &amp;#39;Idaho&amp;#39;).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">type(idaho, state).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">within(idaho, usa).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">name(lucy, &amp;#39;Lucy&amp;#39;).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">born_in(lucy, idaho).
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>데이터를 위와 같이 정의했다면, 데이터로그를 이용해서 이전과 동일한 질의를 작성할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">within_recursive(Location, Name) :- name(Location, Name). /* Rule 1 */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">within_recursive(Location, Name) :- within(Location, Via), /* Rule 2 */ within_recursive(Via, Name).
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">migrated(Name, BornIn, LivingIn) :- name(Person, Name), /* Rule 3 */ born_in(Person, BornLoc),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> within_recursive(BornLoc, BornIn),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lives_in(Person, LivingLoc),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> within_recursive(LivingLoc, LivingIn).
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>사이퍼와 스파클은 &lt;code>SELECT&lt;/code>로 바로 질의하는 반면 데이터로그는 단계를 나눠 한 번에 조금씩 질의로 나아간다.&lt;/p>
&lt;p>먼저 새로운 서술어를 데이터베이스에 전달하는 &lt;strong>규칙(rule)&lt;/strong> 을 정의한다.&lt;/p>
&lt;ul>
&lt;li>이 예제에서는 &lt;code>within_recursive&lt;/code>와 &lt;code>migrated&lt;/code> 두 개를 새로 정의&lt;/li>
&lt;/ul>
&lt;p>서술어는 데이터베이스에 저장된 트리플이 아니며, 데이터나 다른 규칙으로 부터 파생되며, 규칙(rule)은 함수가 다른 함수를 호출하거나 재귀적으로 자신을 호출하는 것 처럼 다른 규칙을 참조할 수 있다.&lt;/p>
&lt;ul>
&lt;li>이처럼 복잡한 질의를 작은 부분으로 나눠 차례차례 구성할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>규칙에서 대문자로 시작하는 단어는 변수이고 서술어는 사이퍼와 스파클의 서술어와 대응된다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>name(Location, Name)&lt;/code>은 변수 &lt;code>Location = namerica&lt;/code>, &lt;code>Name = 'North America'&lt;/code>를 가진 트리플 &lt;code>name(namerica, 'North America')&lt;/code>에 대응&lt;/li>
&lt;/ul>
&lt;p>시스템이 &lt;code>:-&lt;/code> 연산자의 오른편에 있는 모든 서술어의 대응을 찾으면 규칙이 적용된다. 규칙이 적용될 때 &lt;code>:-&lt;/code>의 왼편이 데이터베이스에 추가된다.(변수는 대응된 값으로 대체)&lt;/p>
&lt;p>다음은 이 규칙을 적용할 수 있는 방법 중 하나다.&lt;/p>
&lt;ol>
&lt;li>데이터베이스에 &lt;code>name(namerica, 'North America')&lt;/code>가 존재하면 규칙 1을 적용하고, 규칙 1은 &lt;code>within_recursive(namerica, 'North America')&lt;/code>를 생성한다.&lt;/li>
&lt;li>데이터베이스에 &lt;code>within(usa, namerica)&lt;/code>가 존재하고 이전 단계에서 &lt;code>within_recursive(namerica, 'North America')&lt;/code>를 생성했으면 규칙 2를 적용한다. 규칙 2는 &lt;code>within_recursive(usa, 'North America')&lt;/code>를 생성한다.&lt;/li>
&lt;li>데이터베이스에 &lt;code>within(idaho, usa)&lt;/code>가 존재하고 이전 단계에서 &lt;code>within_recursive(usa, 'North America')&lt;/code>를 생성했으면 규칙 2를 적용한다. 규칙 2는 &lt;code>within_recursive(idaho, 'North America')&lt;/code>를 생성한다.&lt;/li>
&lt;/ol>
&lt;p>&lt;code>within_recursive&lt;/code> 서술어는 규칙 1과 2를 반복 적용해 데이터베이스에 포함된 북아메리카(또는 다른 장소 이름)의 모든 위치를 찾을 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_1.png"
width="923"
height="312"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_1_hucbf885bc5c024331c2bd06108b34aaca_93746_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/3/img_1_hucbf885bc5c024331c2bd06108b34aaca_93746_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터로그 규칙을 사용해 아이다호가 북아메리카에 있는지 확인"
class="gallery-image"
data-flex-grow="295"
data-flex-basis="710px"
>&lt;/p>
&lt;p>이제 규칙 3으로 특정 &lt;code>LivingIn&lt;/code> 장소에 살면서 특정 &lt;code>BornIn&lt;/code> 장소에서 태어난 사람을 찾을 수 있다.&lt;/p>
&lt;p>질의는 &lt;code>BornIn = 'United State'&lt;/code>와 &lt;code>LivingIn = 'Europe'&lt;/code>이고 변수 &lt;code>Who&lt;/code>에 사람을 남기게 한 다음 데이터로그 시스템에 어떤 값이 변수 &lt;code>Who&lt;/code>에 나타날 수 있는지 물어본 후 최종적으로 이전 사이퍼나 스파클 질의와 같은 답을 얻는다.&lt;/p>
&lt;p>데이터로그 접근 방식은 이번 장에서 이전에 설명한 질의 언어와는 다른 사고가 필요하지만 다른 질의 규칙을 결합하거나 재사용할 수 있기 때문에 매우 강력한 접근 방식이다.&lt;/p>
&lt;p>간단한 일회성 질의에 사용하기는 편리하지 않지만 데이터가 복잡하면 더 효과적으로 대체할 수 있다.&lt;/p>
&lt;h2 id="정리">정리&lt;/h2>
&lt;p>데이터 모델은 광범위한 주제다. 이번 장에서는 다양한 종류의 모델을 간략하게 살펴봤다.&lt;/p>
&lt;p>역사적으로 데이터를 하나의 큰 트리(계층 모델)로 표현하려고 노력했지만 &lt;strong>다대다 관계를 표현하기에는 트리 구조가 적절하지 않았다.&lt;/strong> 이 문제를 해결하기 위해 &lt;strong>관계형 모델&lt;/strong>이 고안되었으며, 최근 개발자들은 관계형 모델에도 적합하지 않은 애플리케이션이 있다는 사실을 발견했다.&lt;/p>
&lt;p>새롬게 등장한 비관계형 데이터 저장소인 &lt;strong>NoSQL&lt;/strong>은 다음과 같은 두 가지 주요 갈래가 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>문서 데이터베이스&lt;/strong>
&lt;ul>
&lt;li>데이터가 문서 자체에 포함돼 있으면서 하나의 문서와 다른 문서 간 관계가 거의 없는 사용 사례를 대상으로 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>그래프 데이터베이스&lt;/strong>
&lt;ul>
&lt;li>문서 데이터베이스와는 정 반대로 모든 것이 잠재적으로 관련이 있다는 사용 사례를 대상으로 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>세 가지 모델(문서, 관계형, 그래프) 모두 현재 널리 사용하고 있으며 각 모델은 &lt;strong>각자의 영역에서 훌륭하다&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>한 모델을 다른 모델로 흉내 낼 수 있지만 그 결과는 대부분 엉망이며, 이것이 단일 만능 솔루션이 아닌 각기 목적에 맞는 다양한 시스템을 보유해야 하는 이유이다.&lt;/p>
&lt;/blockquote>
&lt;p>문서 및 그래프 데이터베이스가 가진 공통점 중 하나는 일반적으로 저장할 데이터를 위한 스키마를 강제하지 않아 변화하는 요구사항에 맞춰 애플리케이션을 쉽게 변경할 수 있지만, 애플리케이션은 데이터가 특정 구조를 갖는다고 가정할 가능성이 높다.&lt;/p>
&lt;ul>
&lt;li>이는 스키마가 명시적인지(쓰기에 강요) 암시적인지(읽기에 다뤄짐)의 문제일 뿐이다.&lt;/li>
&lt;/ul>
&lt;p>각 데이터 모델은 고유한 질의 언어나 프레임 워크를 제공한다.&lt;/p>
&lt;ul>
&lt;li>SQL, 맵리듀스, MongoDB의 집계 파이프라인, 사이퍼, 스파클, 데이터로그 등&lt;/li>
&lt;li>CSS, XSL/XPath: 데이터베이스 질의 언어는 아니지만 흥미로운 유사점이 있다.&lt;/li>
&lt;/ul>
&lt;p>아직 언급되지 않은 데이터 모델은 몇 가지는 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>게놈(Genome) 데이터베이스&lt;/li>
&lt;li>대형 강입자 충돌기를 위한 하드웨어 비용이 통제되는 사용자 정의 솔루션&lt;/li>
&lt;li>전문 검색(full-text)&lt;/li>
&lt;/ul></description></item><item><title>2.2 데이터 모델과 질의 언어 - 데이터를 위한 질의 언어</title><link>https://codemario318.github.io/post/designing-data-intensive-application/2/2/</link><pubDate>Mon, 03 Feb 2025 21:06:49 +0900</pubDate><guid>https://codemario318.github.io/post/designing-data-intensive-application/2/2/</guid><description>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/2/cover.png" alt="Featured image of post 2.2 데이터 모델과 질의 언어 - 데이터를 위한 질의 언어" />&lt;h2 id="데이터를-위한-질의-언어">데이터를 위한 질의 언어&lt;/h2>
&lt;p>관계형 모델이 등장했을 때 데이터를 질의하는 새로운 방법도 함께 나타났다. SQL은 &lt;strong>선언형&lt;/strong> 질의 언어인 반면 IMS와 코다실은 &lt;strong>명령형&lt;/strong> 코드를 사용해 데이터베이스에 질의한다.&lt;/p>
&lt;p>일반적으로 많이 사용하는 프로그래밍 언어는 명령형 언어다. 예를 들어 동물의 종 목록이 있을 때 목록에서 상어만 반환하는 코드는 아래와 같다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">getSharks&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">sharks&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">animals&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">animals&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">family&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;Sharks&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sharks&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">animals&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">sharks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>SQL로 표현하면 아래와 같다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">animals&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">family&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Sharks&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>명령형 언어는 특정 순서로 특정 연산을 수행하게끔 컴퓨터에게 지시한다.&lt;/p>
&lt;ul>
&lt;li>코드르 한줄씩 단계별로 실행&lt;/li>
&lt;li>조건을 평가&lt;/li>
&lt;li>변수를 갱신&lt;/li>
&lt;li>루프를 실행할지 여부를 결정&lt;/li>
&lt;/ul>
&lt;p>SQL이나 관계 대수 같은 선언형 질의 언어에서는 &lt;strong>목표를 달성하기 위한 방법&lt;/strong>이 아니라 알고자 하는 데이터의 패턴, 즉 &lt;strong>결과&lt;/strong>가 충족해야 하는 조건과 데이터를 어떻게 변환(ex. 정렬, 그룹화, 집계)할 지 지정하기만 하면 된다.&lt;/p>
&lt;p>어떤 색인과 어떤 조인 함수를 사용할지, 질의의 다양한 부분을 어떤 순서로 실행할지를 결정하는 일은 데이터베이스 시스템의 질의 최적화기가 할 일이다.&lt;/p>
&lt;p>선언형 질의 언어는 일반적으로 명령형 API보다 더 간결하고 쉽게 작업할 수 있기 때문에 매력적이다. 하지만 더 중요한 점은 &lt;strong>데이터베이스 엔진의 상세 구현이 숨겨져 있어 질의를 변경하지 않고도 데이터베이스 시스템의 성능을 향상시킬 수 있다는 점&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>선언형 질의는 특정 순서를 보장하지 않으므로 순서가 바뀌어도 상관없으나, 질의가 명령형으로 작성되었다면 데이터베이스는 코드가 순서에 의존하는지 여부를 확신할 수 없다.&lt;/li>
&lt;li>SQL이 기능적으로 더 제한적이라는 사실은 데이터베이스에게 자동으로 최적화할 수 있는 여지를 더 많이 준다는 의미이다.&lt;/li>
&lt;/ul>
&lt;p>선언형 언어는 종종 병렬 실행에 적합하다. 명령형 코드는 명령어를 특정 순서로 수행하게끔 지정하기 때문에 다중 코어나 다중 장비에서 병렬 처리가 매우 어렵다. 선언형 언어는 결과를 결정하기 위한 알고리즘을 지정하는 게 아니라 결과의 패턴만 지정하므로 병렬 실행으로 더 빨라질 가능성이 크다.&lt;/p>
&lt;h3 id="웹에서의-선언형-질의">웹에서의 선언형 질의&lt;/h3>
&lt;p>선언형 질의 언어의 장점은 데이터베이스에만 국한되지 않는다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-html" data-lang="html">&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span> &lt;span class="na">class&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;selected&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Sharks&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Great White Shark&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Tiger Shark&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Hammerhead Shark&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Whales&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Blue Whale&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Humpback Whale&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Fin Whale&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위와 같은 HTML 문서에서 선택된 리스트의 요소인 &lt;code>&amp;lt;p&amp;gt;Sharks&amp;lt;p&amp;gt;&lt;/code>의 배경을 파란색으로 변경하고 싶다면 아래와 같이 CSS를 작성할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-css" data-lang="css">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">li&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nc">selected&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nt">p&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">background-color&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">blue&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>CSS는 대표적인 선언형 언어로 만약 명령형 접근 방식을 활용해야한다면, 아래와 같은 JS 코드가 필요하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">liElements&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getElementsByTagName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;li&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">liElements&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">liElements&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">className&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;selected&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">children&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">liElements&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">childNodes&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">children&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">children&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">j&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nodeType&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">Node&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ELEMENT_NODE&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">tagName&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;P&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">setAttribute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;style&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;background-color: blue&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위 자바스크립트 코드는 CSS보다 이해하기 어려울 뿐더러 심각한 문제를 가지고 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>selected&lt;/code> 클래스가 삭제된 경우 코드가 재실행되더라도 파란색은 삭제되지 않음
&lt;ul>
&lt;li>CSS의 경우는 규칙이 적용되지 않을 때 바로 다시 그려짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>새로운 API의 장점을 취하고 싶다면 코드를 재작성해야함
&lt;ul>
&lt;li>브라우저 밴더는 호환성을 깨트리지 않고 CSS의 성능을 향상시킬 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>웹 브라우저에서 선언형 CSS 스타일을 사용하는 편이 자바스크립트에서 명령형으로 스타일을 다루기보다 훨씬 편리하다.&lt;/p>
&lt;p>마찬가지로 데이터베이스에서는 SQL 같은 선언형 질의 언어가 명령형 질의 API 보다 훨씬 좋다고 나타났다.&lt;/p>
&lt;h3 id="맵리듀스-질의">맵리듀스 질의&lt;/h3>
&lt;p>&lt;strong>맵리듀스&lt;/strong>(MapReduce)는 많은 컴퓨터에서 대랴으이 데이터를 처리하기 위한 프로그래밍 모델로, 구글에 의해 널리 알려졌다. 이 메커니즘은 많은 문서를 대상으로 읽기 전용(read-only) 질의를 수행할 때 사용한다.&lt;/p>
&lt;p>맵리듀스는 선언형 질의 언어도 완전한 명령형 질의 API도 아닌 그 중간 정도에 있다. 질의 로직은 처리 프레임워크가 반복적으로 호출하는 &lt;strong>조각 코드로 표현&lt;/strong>한다.&lt;/p>
&lt;ul>
&lt;li>함수형 프로그래밍 언어에 있는 map(collect)과 reduce(fold, inject) 함수를 기반으로 함&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>한 달에 얼마나 자주 상어를 발견하는지 보고서를 작성하는 상황&lt;/strong>을 가정하고 예시를 살펴본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>Postgresql&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">date_trunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;month&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">observation_timestamp&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">observation_month&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_animals&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_animals&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">observations&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">family&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Sharks&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">GROUP&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">observation_month&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>상어과에 속하는 종만 보이도록 관측치를 필터링한 다음, 관측ㄱ치가 발생한 달력의 우러로 그룹화하고 마지막으로 해당 달의 모든 관측치에 보여진 동물 수를 합함&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>MongoDB&lt;/strong>&lt;/p>
&lt;p>맵리듀스 기능을 활용하여 다음과 같이 표현할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">db&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">observations&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mapReduce&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">function&lt;/span> &lt;span class="nx">map&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">year&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">observationTimestamp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getFullYear&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">month&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">observationTimestamp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getMonth&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">year&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s2">&amp;#34;-&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">month&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">numAnimals&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 3
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">function&lt;/span> &lt;span class="nx">reduce&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">values&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 4
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">Array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">values&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 5
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">query&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">family&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;Sharks&amp;#34;&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="c1">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">out&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;monthlySharkReport&amp;#34;&lt;/span> &lt;span class="c1">// 6
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>상어 종만 거르기 위한 필터를 선언적으로 지정&lt;/li>
&lt;li>질의와 일치하는 모든 문서에 대해 한 번씩 호출&lt;/li>
&lt;li>키와 값을 방출&lt;/li>
&lt;li>방출한 키-값 쌍은 키로 그룹화됨
&lt;ul>
&lt;li>같은 키를 갖는 모든 키-값 쌍은 &lt;code>reduce&lt;/code> 함수를 한 번 호출함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>특정 월의 모든 관측치에서 동물 수를 합침&lt;/li>
&lt;li>최종 출력을 &lt;code>monthlySharkReport&lt;/code> 컬렉션에 기록&lt;/li>
&lt;/ol>
&lt;p>MongoDB의 &lt;code>map&lt;/code>과 &lt;code>reduce&lt;/code> 함수는 수행할 때 두 함수는 순수 함수여야 한다는 제약이 있다.&lt;/p>
&lt;ul>
&lt;li>입력으로 전달된 데이터만 사용하고, 추가적인 데이터베이스 질의를 수행할 수 없어야함&lt;/li>
&lt;li>부수 효과(side effect)가 없어야함&lt;/li>
&lt;/ul>
&lt;p>이러한 제약 사항 때문에 데이터베이스가 임의 순서로 어디서나 이 함수를 실행할 수 있고 장애가 발생해도 함수를 재실행 할 수 있다. 이런 제약 사항이 있어도 여전히 강력하며, 문자열을 파싱하고 라이브러리 함수를 호출하고 계산을 실행하는 등의 작업을 &lt;code>map&lt;/code>과 &lt;code>reduce&lt;/code> 함수에서 실행할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>집계 파이프라인 언어&lt;/strong>&lt;/p>
&lt;p>맵리듀스의 사용성 문제는 연계된 자바스크립트 함수 두 개를 신중하게 작성해야 한다는 점인데 이는 종종 하나의 질의를 작성하는 것보다 어렵다. 반면 선언형 질의 언어는 질의 최적화기가 질의 성능을 높일 수 있는 기회를 제공한다.&lt;/p>
&lt;p>이러한 이유로 MongoDB는 &lt;strong>집게 파이프라인&lt;/strong>(aggregation pipeline)이라 부르는 선언형 질의 언어 지원을 추가했다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">db&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">observations&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">aggregate&lt;/span>&lt;span class="p">([&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span> &lt;span class="nx">$match&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">family&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;Sharks&amp;#34;&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span> &lt;span class="nx">$group&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">_id&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">year&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">$year&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;$observationTimestamp&amp;#34;&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">month&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">$month&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;$observationTimestamp&amp;#34;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">totalAnimals&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">$sum&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;$numAnimals&amp;#34;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>집계 파이프라인 언어는 표현 측면에서 SQL의 부분 집합과 유사하지만 SQL의 영어 문장 스타일 구문보다는 JSON 기반 구문을 사용한다.&lt;/p>
&lt;blockquote>
&lt;p>여기서 배울 점은 NoSQL 시스템이 뜻하지 않게 SQL을 재발견하고 있다는 점이다.&lt;/p>
&lt;/blockquote></description></item><item><title>2.1 데이터 모델과 질의 언어 - 관계형 모델과 문서 모델</title><link>https://codemario318.github.io/post/designing-data-intensive-application/2/1/</link><pubDate>Sat, 18 Jan 2025 15:24:49 +0900</pubDate><guid>https://codemario318.github.io/post/designing-data-intensive-application/2/1/</guid><description>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/1/cover.png" alt="Featured image of post 2.1 데이터 모델과 질의 언어 - 관계형 모델과 문서 모델" />&lt;h2 id="관계형-모델과-문서-모델">관계형 모델과 문서 모델&lt;/h2>
&lt;p>&lt;strong>데이터 모델&lt;/strong>은 소프트웨어가 어떠헥 작성됐는지 뿐만 아니라 해결하려는 &lt;strong>문제를 어떻게 생각해야 하는지&lt;/strong>에 대해 지대한 영향을 미친다.&lt;/p>
&lt;p>대부분 애플리케이션은 하나의 데이터 모델을 다른 데이터 모델 위에 계층을 둬서 만든다.&lt;/p>
&lt;p>각 계층의 핵심적인 문제는 다음 하위 계층 관점에서 데이터 모델을 &lt;strong>표현&lt;/strong>하는 방법이다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션 개발자는 현실(사람, 조직, 상품, 행동, 자금 흐름, 센서)을 보고 객체나 데이터 구조, 그리고 이러한 데이터 구조를 다루는 API를 모델링한다.
&lt;ul>
&lt;li>이러한 구조는 보통 애플리케이션에 특화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 구조를 저장할 때는 JSON이나 XML 문서, 관계형 데이터베이스 테이블이나 그래프 모델 같은 범용 데이터 모델로 표현한다.&lt;/li>
&lt;li>데이터베이스 소프트웨어를 개발하는 엔지니어는 JSON/XML/관계형/그래프 데이터를 메모리나 디스크 또는 네트워크 상의 바이트 단위로 표현하는 방법을 결정한다.
&lt;ul>
&lt;li>이 표현은 다양한 방법으로 데이터를 질의, 탐색, 조작 처리할 수 있게 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>더 낮은 수준에서 하드웨어 엔지니어는 전류, 빛의 파동, 자기장 등의 관점에서 바이트를 표현하는 방법을 알아냈다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>복잡한 애플리케이션에서는 여러 API를 기반으로 만든 API처럼 중간 단계를 더 둘 수 있지만 기본 개념은 여전히 동일하다.&lt;/p>
&lt;/blockquote>
&lt;p>각 계층은 명확한 데이터 모델을 제공해 하위 계층의 복잡성을 숨겨(추상화), 다른 그룹의 사람들이 효율적으로 함께 일할 수 있게끔 한다.&lt;/p>
&lt;hr>
&lt;p>다양한 유형의 데이터 모델이 존재하며, 각 데이터 모델은 사용 방법에 대한 가정을 나타낸다.&lt;/p>
&lt;ul>
&lt;li>어떤 종류의 데이터모델의 사용법은 쉬우나 어떤 동작은 지원하지 않는다.&lt;/li>
&lt;li>데이터 모델의 종류에 따라 어떤 연산은 빠르지만 다른 연산은 매우 느리게 작동한다.&lt;/li>
&lt;li>어떤 데이터 변환은 자연스럽지만 달느 어떤 데이터 변환은 부자연스럽다.&lt;/li>
&lt;/ul>
&lt;p>하나의 데이터 모델만을 완전히 익히는 데도 많은 노력이 필요하며(관계형 데이터 모델링 관련된 학습 분량만해도 방대하다), 데이터 모델을 하나만 사용하면서도 내부 동작에 대한 걱정이 없더라도 소프트웨어 작성은 그 자체로 충분히 어렵다.&lt;/p>
&lt;p>그러나 데이터 모델은 그 위에서 &lt;strong>소프트웨어가 할 수 있는 일과 할 수 없는 일에 지대한 영향&lt;/strong>을 주므로 애플리케이션에 적합한 데이터 모델을 선택하는 작업은 상당히 중요하다.&lt;/p>
&lt;hr>
&lt;p>오늘날 가장 잘 알려진 모델은 1970년 에드가 코드(Edgar Codd)가 제안한 관계형 모델을 기반으로 한 SQL이다.&lt;/p>
&lt;ul>
&lt;li>데이터는 &lt;strong>관계&lt;/strong>로 구성되고 각 관계는 순서 없는 &lt;strong>튜플&lt;/strong> 모음이다.&lt;/li>
&lt;/ul>
&lt;p>관계형 데이터베이스의 근원은 1960년대와 1970년대에 메인프레임 컴퓨터에서 수행된 &lt;strong>비즈니스 데이터 처리&lt;/strong>에 있다.&lt;/p>
&lt;ul>
&lt;li>트랜잭션 처리, 일괄 처리 등&lt;/li>
&lt;/ul>
&lt;p>당시 다른 데이터베이스를 사용하는 개발자는 데이터베이스 내부 데이터 표현에 대해 고민해야 했지만, 관계형 모델로 인해 정리된 인터페이스 뒤로 구현 세부 사항을 숨길 수 있게 되었다.&lt;/p>
&lt;p>이후 컴퓨터가 훨씬 더 강력해지고 네트워크화됨에 따라 다양한 목적으로 활용되기 시작하였고, 관계형 데이터베이스는 비즈니스 데이터 처리 뿐만이 아닌 폭넓은 다양한 사용 사례에도 보편화 되는 것으로 나타났다.&lt;/p>
&lt;p>오늘날 대부분의 서비스는 여전히 관계형 데이터베이스를 통해 제공된다.&lt;/p>
&lt;h3 id="nosql의-탄생">NoSQL의 탄생&lt;/h3>
&lt;p>2010년대에 들어서며 NoSQL이 빠르게 확산되었는데 다양한 이유가 있다.&lt;/p>
&lt;ul>
&lt;li>대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성의 필요&lt;/li>
&lt;li>상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산&lt;/li>
&lt;li>관계형 모델에서 지원하지 않는 특수 질의 동작&lt;/li>
&lt;li>관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람&lt;/li>
&lt;/ul>
&lt;p>애플리케이션은 저마다 요구사항이 다르기 때문에, 사용 사례에 맞는 최적의 기술 선택은 동시에 요구되는 사용 사례에 맞는 최적의 선택과는 다를 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>이 때문에 관계형 데이터베이스가 폭넓은 다양함을 가진 비관계형 데이터스토어와 함께 사용될 것이다.(😲)&lt;/p>
&lt;/blockquote>
&lt;p>이런 개념을 종종 &lt;strong>다중 저장소 지속성&lt;/strong>(polyglot persistence)이라고 부른다.&lt;/p>
&lt;h3 id="객체-관계형-불일치">객체 관계형 불일치&lt;/h3>
&lt;p>오늘날의 대부분의 애플리케이션은 객체지향 프로그래밍 언어로 개발되는데, 이는 SQL 데이터 모델과 객체 모델 사이에 불일치가 발생한다.&lt;/p>
&lt;ul>
&lt;li>데이터를 관계형 테이블에 저장하려면 애플리케이션 코드와 데이터베이스 모델 객체 사이에 거추장스러운 전환 계층이 필요함&lt;/li>
&lt;li>이런 모델 사이의 분리를 임피던스 불일치(impedance mismatch)라고 부른다.&lt;/li>
&lt;/ul>
&lt;p>액티브레코드(Active Record)나 하이버네이트(Hibernate)와 같은 ORM 프레임워크는 전환 계층에 필요한 상용구 코드(boilerplate code)의 양을 줄이지만 두 모델 간의 차이를 완벽히 숨길 수 없다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image.png"
width="728"
height="654"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image_huf7279fce334eb341135beb90b76ab788_145375_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/1/image_huf7279fce334eb341135beb90b76ab788_145375_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="관계형 스키마를 사용해 링크트인 프로필을 표현"
class="gallery-image"
data-flex-grow="111"
data-flex-basis="267px"
>&lt;/p>
&lt;p>프로필 전체는 고유 식별자인 &lt;code>user_id&lt;/code>로 식별가능하고, &lt;code>first_name&lt;/code>, &lt;code>last_name&lt;/code> 같은 필드는 사용자마다 하나만 있으므로 &lt;code>users&lt;/code> 테이블 컬럼으로 모델링 가능하다.&lt;/p>
&lt;p>하지만 경력에 넣을 직업이 하나 이상이며 학력 기간과 연락처 정보도 다양하기 때문에, 사용자와 이들 사이의 관계는 일대다 관계(one-to-many)이며 이는 다양한 방법으로 표현할 수 있다.&lt;/p>
&lt;ul>
&lt;li>전통적인 SQL 모델의 일반적인 정구화 표현은 직위, 학력, 연락처 정보를 개별 테이블에 넣고 외래 키로 &lt;code>users&lt;/code> 테이블을 참조&lt;/li>
&lt;li>구조화된 데이터타입으로 저장(XML, JSON 등)
&lt;ul>
&lt;li>SQL 표준의 마지막 버번에서 구조화된 데이터타입에 대한 지원이 추가됨에 따라, 한 로우에 다중 값을 저장하고 질의와 색인이 가능해짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>직업, 학력, 연략처 정보를 JSON이나 XML 문서로 부호화해 데이터베이스의 텍스트 컬럼에 저장 후, 애플리케이션이 구조와 내용을 해석
&lt;ul>
&lt;li>일반적으로 부호화된 컬럼의 값을 질의하는 데 데이터베이스를 사용할 수 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이력서와 같은 데이터 구조는 모든 내용을 갖추고 있는 &lt;strong>문서&lt;/strong>라서 JSON 표현에 매우 적합하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">251&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;first_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Bill&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;last_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Gates&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;summary&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Co-chair of the Bill &amp;amp; Melinda Gates... Active blogger.&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;region_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;us:91&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;industry_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">131&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;photo_url&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;/p/7/000/253/05b/308dd6e.jpg&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;positions&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;job_title&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Co-chair&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;organization&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Bill &amp;amp; Melinda Gates Foundation&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;job_title&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Co-founder, Chairman&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;organization&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Microsoft&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;education&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;school_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Harvard University&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;start&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1973&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;end&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1975&lt;/span>&lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;school_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Lakeside School, Seattle&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;start&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;end&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;contact_info&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;blog&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;http://thegatesnotes.com&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;twitter&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;http://twitter.com/BillGates&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>일부 개발자는 JSON 모델이 애플리케이션 코드와 저장 계층 간 임피던스 불일치를 줄인다고 생각한다.&lt;/p>
&lt;ul>
&lt;li>물론 데이터 부화화 형식으로서 JSON의 문제도 있음(4장)&lt;/li>
&lt;/ul>
&lt;p>JSON 표현은 다중 테이블 스키마보다 더 나은 &lt;strong>지역성&lt;/strong>(locality)을 갖는다.&lt;/p>
&lt;ul>
&lt;li>관계형 예제에서 프로필을 가져오려면 다중 질의를 수행하거나 &lt;code>users&lt;/code> 테이블과 그 하위 테이블 간에 난잡한 다중 조인이 필요함&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-1.png"
width="726"
height="330"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-1_huf01bd4b866b0b0735bdca555b8616a7f_45548_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-1_huf01bd4b866b0b0735bdca555b8616a7f_45548_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="트리 구조를 형성하는 일대다 관계"
class="gallery-image"
data-flex-grow="220"
data-flex-basis="528px"
>&lt;/p>
&lt;p>사용자 프로필에서 사용자에서 직위, 학력 기록, 연락처 정보로 대응되는 일대다 관계는 의미상 데이터 트리 구조와 같다.&lt;/p>
&lt;ul>
&lt;li>이러한 트리 구조는 JSON 표현에서 명시적으로 드러나게된다.&lt;/li>
&lt;/ul>
&lt;h3 id="다대일과-다대다-관계">다대일과 다대다 관계&lt;/h3>
&lt;p>이력서 예시에서 &lt;code>region_id&lt;/code>와 &lt;code>industry_id&lt;/code>는 평문이 아닌 외래 키인데, 지리적 지역과 업계 표준 목록으로 드롭다운 리스트나 자동 완성 기능을 만들어 사용자가 선택하게 하는 데는 다음과 같은 장점이 있다.&lt;/p>
&lt;ul>
&lt;li>프로필 간 일관된 스타일 철자&lt;/li>
&lt;li>모호함 회피(이름이 같은 여러 도시 등)&lt;/li>
&lt;li>갱신의 편의성
&lt;ul>
&lt;li>이름이 한 곳에만 저장되므로 이름을 변경해야 하는 경우 전반적인 갱신이 쉬움&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>현지화 지원
&lt;ul>
&lt;li>글로벌 서비스의 경우 표준 목록을 현지화하는데 용이함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>더 나은 검색
&lt;ul>
&lt;li>검색할 특정 항목이 특정 지역 목록에 포함된다는 것을 부호화하여 더 정확한 검색 결과를 얻을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>ID나 텍스트 문자열의 저장 여부는 중복의 문제로 텍스트로 저장하게되면 같은 의미의 데이터가 중복된다.&lt;/p>
&lt;blockquote>
&lt;p>비정규화는 데이터 중복을 일부로 발생시키는 방법인데 이후 다룸&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>중복된 데이터를 정규화하려면 &lt;strong>다대일&lt;/strong> 관계가 필요한데 이는 문서 모델에 적합하지 않다.&lt;/p>
&lt;p>관계형 데이터베이스에서는 조인이 쉬어 ID로 다른 테이블의 로우를 참조하는 방식이 일반적이지만, 문서 데이터베이스에서는 일대다 트리 구조를 위해 조인이 필요하지 않지만 조인에 댛나 지원이 보통 약하다.&lt;/p>
&lt;p>데이터베이스가 조인을 지원하지 않으면 데이터베이스에 대한 다중 질의를 만들어 애플리케이션 코드에서 조인을 흉내 내야 한다.&lt;/p>
&lt;p>더욱이 애플리케이션의 초기 버전이 조인 없는 문서 모델에 적합하더라도 애플리케이션에 기능을 추가하면서 데이터는 점차 상호 연결되는 경향이 있다.&lt;/p>
&lt;ul>
&lt;li>예시에서는 직장, 학교, 추천서 등&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-2.png"
width="726"
height="500"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-2_hu1901cea60f5abd3dcdc7332c37186851_87478_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/2/1/image-2_hu1901cea60f5abd3dcdc7332c37186851_87478_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="다대다 관계로 이력서 확장"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="348px"
>&lt;/p>
&lt;h3 id="문서-데이터베이스는-역사를-반복하고-있나">문서 데이터베이스는 역사를 반복하고 있나?&lt;/h3>
&lt;p>문서 데이터베이스와 NoSQL은 데이터베이스에서 다대다 관계를 표현하는 제일 좋은 방법에 대한 논쟁을 다시 열었다.&lt;/p>
&lt;p>1970년대 많이 사용된 데이터베이스로 IBM의 정보 관리 시스템(Information Management System, IMS)은 &lt;strong>계층 모델&lt;/strong>이라 부르는 간단한 데이터 모델을 사용했는데, JSON 모델과 매우 유사하다.&lt;/p>
&lt;p>이때 관계형 모델에 대한 한계를 극복하기 위해 대표적으로 &lt;strong>관계형 모델&lt;/strong>(SQL로 세상을 지배중)과 &lt;strong>네트워크 모델&lt;/strong>이 제안되었는데, 해결하려는 문제가 지금 풀려는 문제와 매우 유사하다.&lt;/p>
&lt;h4 id="네트워크-모델">네트워크 모델&lt;/h4>
&lt;p>네트워크 모델은 코다실(Conference for Data Systems Languages, CODASYL)이 제안한 모델로 &lt;strong>코다실 모델&lt;/strong>이라고도 부른다.&lt;/p>
&lt;p>코다실 모델은 계층 모델을 일반화한다.&lt;/p>
&lt;ul>
&lt;li>계층 모델의 트리 구조에서 모든 레코드는 정확하게 하나의 부모가 있지만, 네트워크 모델에서는 레코드는 다중 부모가 있을 수 있다.&lt;/li>
&lt;li>네트워크 모델에서 레코드 간 연결은 왜래 키 보다는 프로그래밍 언어의 포인터와 더 비슷하다.&lt;/li>
&lt;/ul>
&lt;p>레코드에 접근하는 유일한 방법은 최상위 레코드(root record)에서 시작하는 경로를 따라가는 것이다.(&amp;ldquo;접근 경로&amp;quot;라고 함)&lt;/p>
&lt;ul>
&lt;li>다대다 관계는 다양한 다른 경로가 같은 레코드로 이어질 수 있으므로, 네트워크 모델을 사용하는 프로그래머는 경로의 맨 앞에서 이런 다양한 접근 경로를 계속 추적해야 한다.&lt;/li>
&lt;/ul>
&lt;p>코다실에서 질의는 레코드 목록을 반복해 접근 경로를 따라 데이터베이스의 끝에서 끝까지 커서를 움직여 수행되며, 레코드가 다중 부모를 가진다면 애플리케이션 코드는 다양한 관계를 모두 추적해야한다.&lt;/p>
&lt;ul>
&lt;li>수동 접근 경로 선택은 매우 제한된 하드웨어 성능을 가장 효율적으로 사용할 수 있었지만 데이터베이스 질의와 갱신을 위한 코드가 복잡하고 유연하지 못했다.&lt;/li>
&lt;/ul>
&lt;p>계층 모델과 네트워크 모델 모두, 원하는 데이터에 대한 결오가 없다면 어려운 상황에 놓인다.&lt;/p>
&lt;ul>
&lt;li>접근 경로를 변경할 수 있지만 아주 많은 수작업 데이터베이스 질의 코드를 살펴야한다.&lt;/li>
&lt;li>새로운 접근 경로를 다루기 위해 재작성 해야한다.&lt;/li>
&lt;/ul>
&lt;p>애플리케이션의 데이터 모델을 바꾸는 작업은 매우 어려운 일이었다.&lt;/p>
&lt;h4 id="관계형-모델">관계형 모델&lt;/h4>
&lt;p>관계형 모델이 하는 일은 알려진 모든 데이터를 배치하는 것이다.&lt;/p>
&lt;ul>
&lt;li>관계(테이블)는 단순히 튜플(로우)의 컬렉션이 전부이다.&lt;/li>
&lt;li>복잡한 중첩 구조와 데이터를 보고 싶을 때 따라가야 할 복잡한 접근 경로가 없다.&lt;/li>
&lt;/ul>
&lt;p>임의 조건과 일치하는 테이블의 일부 또는 모든 로우를 선택해서 읽을 수 있고 일부 칼럼을 키로 지정해 칼럼과 일치하는 특정 로우를 읽을 수 있다.&lt;/p>
&lt;p>다른 테이블과의 외래 키 관계에 대해 신경 쓰지 않고 임의 테이블에 새 로우를 삽입할 수 있다.&lt;/p>
&lt;p>관계형 데이터베이스에서 질의 최적화기(query optimizer)는 네트워크 모델의 접근 경로와 같은 실행 계획을 선택한다.&lt;/p>
&lt;p>따라서 애플리케이션 개발자가 접근 경로를 따로 생각할 필요는 없으며, 새로운 방식으로 데이터에 질의하고 싶다면 새로운 색인을 선언하면 잘의는 자동으로 가장 적합한 색인을 사용하게 된다.&lt;/p>
&lt;ul>
&lt;li>관계형 모델은 애플리케이션에 새로운 기능을 추가하는 작업이 훨씬 쉽다.&lt;/li>
&lt;/ul>
&lt;h4 id="문서-데이터베이스와의-비교">문서 데이터베이스와의 비교&lt;/h4>
&lt;p>문서 데이터베이스는 별도 테이블이 아닌 상위 레코드 내에 중첩된 레코드를 저장한다.&lt;/p>
&lt;p>하지만 다대일과 다대다 관계를 표현할 때 관계형 데이터베이스와 문서 데이터베이스는 근본적으로 다르지 않다.&lt;/p>
&lt;ul>
&lt;li>둘 다 관련 항목은 고유한 식별자로 참조&lt;/li>
&lt;li>관계형 모델에서는 &lt;strong>외래 키&lt;/strong>, 문서 모델에서는 &lt;strong>문서 참조&lt;/strong>(document reference)&lt;/li>
&lt;/ul>
&lt;p>이 식별자는 조인이나 후속 질의를 사용해 읽기 시점을 확인한다.&lt;/p>
&lt;h3 id="관계형-데이터베이스와-오늘날의-문서-데이터베이스">관계형 데이터베이스와 오늘날의 문서 데이터베이스&lt;/h3>
&lt;p>관계형 데이터베이스와 문서 데이터베이스를 비교할 때 많은 부분을 고려해야하지만 데이터 모델의 차이점에만 집중한다.&lt;/p>
&lt;p>문서 데이터 모델을 선호하는 주요 이유는 &lt;strong>스키마 유연성&lt;/strong>, &lt;strong>지역성에 기인한 더 나은 성능&lt;/strong> 때문이고 일부 애플리케이션의 경우 애플리케이션에서 사용하는 데이터 구조와 더 까깝기 때문이다.&lt;/p>
&lt;p>관계형 모델은 조인, 다대일, 다대다 관계를 더 잘 지원함으로써 문서 데이터 모델에 대항한다.&lt;/p>
&lt;h4 id="어떤-데이터-모델이-애플리케이션-코드를-더-간단하게-할까">어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?&lt;/h4>
&lt;p>애플리케이션에서 데이터가 문서와 비슷한 구조라면 문서 모델을 사용하는 것이 좋다.&lt;/p>
&lt;ul>
&lt;li>문서와 비슷한 구조를 여러 테이블로 나누어 찢는(shredding) 관계형 기법은 다루기 힘든 스키마와 불필요하게 복잡한 애플리케이션 코드를 발생시킨다.&lt;/li>
&lt;/ul>
&lt;p>문서 모델은 문서 내 중첩 항목을 바로 참조할 수는 없다는 제한으로 인해 &amp;ldquo;사용자 251의 직위 목록의 두 번째 항목&amp;quot;과 같이 표현해야하지만, 문서가 너무 깊게 중첩되지 않으면 일반적으로 문제되진 않는다.&lt;/p>
&lt;p>문서 데이터베이스의 미흡한 조인 지원은 애플리케이션에 따라 문제일 수 일 수 있지만 아닐수도 있다.&lt;/p>
&lt;ul>
&lt;li>ex) 어떤 시점에 발생한 이벤트를 기록하는 문서 데이터베이스를 사용하는 분석 애플리케이션&lt;/li>
&lt;/ul>
&lt;p>하지만 애플리케이션에서 다대다 관계를 사용한다면 문서 모델은 매력이 떨어진다.&lt;/p>
&lt;ul>
&lt;li>비정규화로 조인의 필요성 줄이기가 가능하지만 애플리케이션 코드에서 비정규화된 데이터의 일관성을 유지하기 위한 추가 작업 필요&lt;/li>
&lt;li>조인은 애플리케이션 코드에서 데이터베이스에 다중 요청을 만들어 흉내낼 수 있지만 복잡도가 높고, 조인보다 느림
이러한 경우 문서 모델을 사용하는 것이 훨씬 더 복잡한 애플리케이션 코드와 나쁜 성능으로 이어질 수 있다.&lt;/li>
&lt;/ul>
&lt;p>일반적으로 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 만드는지는 데이터 항목 간에 존재하는 관계 유형에 따라 다르다.&lt;/p>
&lt;ul>
&lt;li>상호 연결이 많은 데이터의 경우
&lt;ul>
&lt;li>문서 모델: 곤란&lt;/li>
&lt;li>관계형 모델: 무난&lt;/li>
&lt;li>그래프 모델: 매우 자연스러움&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="문서-모델에서의-스키마-유연성">문서 모델에서의 스키마 유연성&lt;/h4>
&lt;p>대부분의 문서 데이터베이스는 스키마를 강요하지 않는데, 이는 임의의 키와 값을 문서에 추가할 수 있고 읽을 때 클라이언트는 문서에 포함된 필드의 존재 여부를 보장하지 않는다는 의미이다.&lt;/p>
&lt;p>문서 데이터베이스는 종종 &lt;strong>스키마리스&lt;/strong>(schema-less)라고 부르는데, 오해의 소지가 있다. 보통은 읽는 코드는 어떤 구조를 가정하므로, 암묵적인 스키마가 있지만 강요하지 않는다는 뜻이 더 정확하다.&lt;/p>
&lt;ul>
&lt;li>쓰기 스키마(schema-on-write)
&lt;ul>
&lt;li>관계형 데이터베이스의 전통적인 접근 방식&lt;/li>
&lt;li>스키마는 명시적이고 데이터베이스는 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>읽기 스키마(schema-on-read)
&lt;ul>
&lt;li>데이터 구조는 암묵적이고 데이터를 읽을 때만 해석&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>데이터베이스에서 스키마 강제는 논쟁의 여지가 있는 주제이며 일반적으로 옳고 그른 정답은 없다.&lt;/p>
&lt;p>접근 방식 간 차이는 애플리케이션이 데이터 타입을 변경하고자 할 때 특히 뚜렷이 나타나는데, 문서 데이터베이스에서는 새로운 필드를 가진 새로운 문서를 작성하기 시작하고 애플리케이션에서는 예전 문서를 읽은 경우를 처리하는 코드만 있으면 된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">if (user &amp;amp;&amp;amp; user.name &amp;amp;&amp;amp; !user.first_name) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // Documents written before Dec 8, 2013 don&amp;#39;t have first_name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> user.first_name = user.name.split(&amp;#34; &amp;#34;)[0];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>데이터베이스 스키마에서는 보통 마이그레이션(migration)을 수행한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ADD&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COLUMN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">text&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">UPDATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">split_part&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- PostgreSQL
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">UPDATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">substring_index&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- MySQL
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>스키마 변경은 느리고 중단시간을 요구하기 때문에 평판이 나쁘지만, 대부분의 관계형 데이터베이스 시스템에서 엄청 느리지는 않다.&lt;/p>
&lt;ul>
&lt;li>MySQL은 예외적으로 &lt;code>ALTER TABLE&lt;/code>시 전체 테이블을 복사하기 때문에 큰 테이블을 변경할 때 수 분에서 수 시간까지 중단 시간이 발생할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>큰 테이블에 &lt;code>UPDATE&lt;/code>문을 실행하면 모든 로우가 재작성될 수 있기 때문에 어떤 데이터베이스는 오래 걸릴수 있다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션은 입력될 항목이 기본값인 널로 설정되게 남겨두고 문서 데이터베이스처럼 읽는 시점에 채울 수도 있다.&lt;/li>
&lt;/ul>
&lt;p>읽기 스키마 접근 방식은 컬렉션 안의 항목이 어떤 이유로 모두 동일한 구조가 아닐 때(데이터가 여러 다른 유형으로 구성돼 있을 때) 유용하다.&lt;/p>
&lt;ul>
&lt;li>다른 여러 유형의 오브젝트가 있고 각 유형의 오브젝트별로 자체 테이블에 넣는 방법은 실용적이지 않다.&lt;/li>
&lt;li>사용자가 제어할 수 없고 언제나 변경 가능한 외부 시스템에 의해 데이터 구조가 결정된다.&lt;/li>
&lt;/ul>
&lt;p>하지만 모든 레코드가 동일한 구조라서 예상 가능하다면 스키마가 문서화와 구조를 강제하기 위한 유용한 메커니즘이다.&lt;/p>
&lt;h4 id="질의를-위한-지역성">질의를 위한 지역성&lt;/h4>
&lt;p>문서는 보통 JSON, XML로 부호화된 단일 연속 문자열이나(MongoDB의 BSON) JSON 또는 XML의 이진 변형으로 저장된다.&lt;/p>
&lt;p>애플리케이션이 자주 전체 문서에 접근해야 할 때 &lt;strong>저장소 지역성&lt;/strong>(storage locality)을 활용하면 성능 이점이 있다.&lt;/p>
&lt;ul>
&lt;li>처음 봤던 이력서 예시처럼 데이터가 다중 테이블로 나눠졌으면 전체를 검색하기 위해 다중 색인 검색이 필요하므로 더 많은 디스크 탐색이 필요하다.&lt;/li>
&lt;/ul>
&lt;p>지역성의 이점은 한 번에 해당 문서의 많은 부분을 필요로 하는 경우에만 적용된다.&lt;/p>
&lt;ul>
&lt;li>문서의 작은 부분에만 접근해도 전체 문서를 적재해야 하기에 큰 문서에서는 낭비일 수 있다.&lt;/li>
&lt;li>문서를 갱신할 때도 보통 전체 문서를 재작성 해야한다.&lt;/li>
&lt;li>부호화된 문서의 크기를 바꾸지 않는 수정은 쉽게 수행할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이런 이유로 일반적으로 문서를 아주 작게 유지하면서 문서의 크기가 증가하는 쓰기를 피하라고 권장한다.&lt;/p>
&lt;ul>
&lt;li>이 성능 제한 때문에 문서 데이터베이스가 유용한 상황이 많이 줄어든다.&lt;/li>
&lt;/ul>
&lt;p>지역성을 위해 관련 데이터를 함께 그룹화하는 개념이 문서 모델에만 국한되지는 않는다는 점이 중요하다.&lt;/p>
&lt;ul>
&lt;li>구글의 스패너(Spanner) 데이터베이스는 부모 테이블 내에 테이블의 로우를 교차 배치되게끔 선언하는 스키마를 허용하여 관계형 데이터 모델에서 지역성 특성을 동일하게 제공&lt;/li>
&lt;li>오라클은 &lt;strong>다중 테이블 색인 클러스터 테이블&lt;/strong>(multi-table index cluster table)을 사용해 관계형 데이터베이스에서 지역성을 제공&lt;/li>
&lt;li>빅테이블(Bigtable) 데이터 모델의 &lt;strong>컬럼 패밀리&lt;/strong>(column family)개념(카산드라, HBase)이 지역성 관리와 유사항 목적이 있음&lt;/li>
&lt;/ul>
&lt;h4 id="문서-데이터베이스와-관계형-데이터베이스의-통합">문서 데이터베이스와 관계형 데이터베이스의 통합&lt;/h4>
&lt;p>대부분 관계형 데이터베이스 시스템은 2000년대 중반 이후로 XML을 지원한다.&lt;/p>
&lt;ul>
&lt;li>XML 문서의 저역적 수정 및 문서 내부 색인과 질의 기능 포함&lt;/li>
&lt;/ul>
&lt;p>그래서 문서 데이터베이스를 사용할 때와 매우 비슷한 데이터 모델을 애플리케이션이 사용할 수 있다.&lt;/p>
&lt;p>PostgreSQL 9.3, MySQL 5.7, DB2 10.5 부터는 JSON 문서에 대해 비슷한 수준의 지원 기능을 제공한다.&lt;/p>
&lt;ul>
&lt;li>웹 API용 JSON의 인기를 고려할 때, 그 밖의 관계형 데이터베이스도 선례를 쫒아 JSON 지원 기능을 추가할 가능성이 높아보임&lt;/li>
&lt;/ul>
&lt;p>문서 데이터베이스 쪽에서 본다면 리싱키DB는 질의 언어에서 관계형 조인을 지원하고 MongoDB 드라이버는 자동으로 데이터베이스 참조를 확인한다.&lt;/p>
&lt;ul>
&lt;li>실제로는 클라이언트 측 조인을 수행&lt;/li>
&lt;li>네트워크 왕복이 추가로 필요하고 최적화가 덜 되기 때문에 데이터베이스에서 수행되는 조인보다 느릴 수 있음&lt;/li>
&lt;/ul>
&lt;p>관계형 데이터베이스와 문서 데이터베이스는 시간이 지남에 따라 점점 더 비슷해지고 있다.&lt;/p>
&lt;p>만약 데이터베이스가 데이터를 문서처럼 다룰 수 있고 관계형 질의를 수행할 수 있다면 애플리케이션은 필요에 따라 가장 적합한 기능을 조합해 사용하면 된다.&lt;/p>
&lt;blockquote>
&lt;p>관계형과 문서형의 혼합 모델은 미래 데이터베이스들이 가야 할 올바른 길이다.🫨&lt;/p>
&lt;/blockquote></description></item><item><title>웹소켓 시스템의 성능 개선하기</title><link>https://codemario318.github.io/post/websocket-scale-out/</link><pubDate>Sat, 04 Jan 2025 14:57:49 +0900</pubDate><guid>https://codemario318.github.io/post/websocket-scale-out/</guid><description>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/cover.png" alt="Featured image of post 웹소켓 시스템의 성능 개선하기" />&lt;p>최근 실시간 다중 사용자 퀴즈 게임을 구현하면서 단순하게 서버 1대와 인메모리(이하 세션)를 이용한 방식으로 웹소켓을 이용해 게임 진행과 채팅 기능을 구현했었는데요.&lt;/p>
&lt;p>당시 부하 테스트 결과로 초당 5,000건 이상의 메시지 처리가 가능했기 때문에, 목표로 했던 300명 이상의 참여자 동시 진행이 가능했습니다.&lt;/p>
&lt;p>하지만 게임에 참여하는 사용자가 많아지면 현재 상황에서는 분명 한계가 있겠죠? 그래서 웹소켓 서버의 처리량을 늘리는 방법들에 대해서 알아보려 합니다.&lt;/p>
&lt;h2 id="수평-확장과-수직-확장">수평 확장과 수직 확장&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img.png"
width="1024"
height="659"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_hu1795940aac2814a197193d8fc3eed447_80445_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_hu1795940aac2814a197193d8fc3eed447_80445_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="img.png"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="372px"
>&lt;/p>
&lt;p>시스템의 성능을 향상시킬 때 기본적으로 &lt;strong>수평 확장&lt;/strong>과 &lt;strong>수직 확장&lt;/strong> 두 가지 접근 방식을 고려할 수 있습니다.&lt;/p>
&lt;h3 id="수직-확장-scale-up">수직 확장 (Scale Up)&lt;/h3>
&lt;p>단일 서버의 성능을 향상시키는 방법입니다. CPU, 메모리, 디스크 등 하드웨어 리소스를 증설하여 성능을 개선합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>장점:&lt;/strong>
&lt;ul>
&lt;li>구현이 간단하며 추가적인 아키텍처 변경이 필요 없음&lt;/li>
&lt;li>단일 서버이므로 데이터 일관성 유지가 쉬움&lt;/li>
&lt;li>네트워크 복잡도가 낮음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>단점:&lt;/strong>
&lt;ul>
&lt;li>하드웨어 비용이 기하급수적으로 증가&lt;/li>
&lt;li>물리적인 한계가 존재&lt;/li>
&lt;li>장애 발생 시 전체 시스템에 영향&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="수평-확장-scale-out">수평 확장 (Scale Out)&lt;/h3>
&lt;p>동일한 서버를 여러 대 추가하여 부하를 분산시키는 방법입니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>장점:&lt;/strong>
&lt;ul>
&lt;li>선형적인 비용 증가로 효율적&lt;/li>
&lt;li>무한한 확장이 이론적으로 가능&lt;/li>
&lt;li>고가용성과 장애 허용성 확보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>단점:&lt;/strong>
&lt;ul>
&lt;li>아키텍처가 복잡해짐&lt;/li>
&lt;li>데이터 일관성 유지가 어려움&lt;/li>
&lt;li>네트워크 오버헤드 발생&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>수직 확장은 단순히 서버 스펙을 올리는 것으로 한계가 명확하기 때문에(&lt;del>비싸기 때문에&lt;/del>), 수평 확장 위주로 성능을 개선하는 것이 바람직해보입니다.&lt;/p>
&lt;p>이제 수평 확장을 위한 구체적인 방법들을 살펴보겠습니다.&lt;/p>
&lt;h2 id="웹소켓의-특성">웹소켓의 특성&lt;/h2>
&lt;p>먼저 여러 시도를 하기 전 웹소켓의 연결 특성에 대해 이해할 필요가 있습니다.&lt;/p>
&lt;p>웹소켓은 클라이언트와 서버 간에 지속 &lt;strong>연결 상태를 유지&lt;/strong>하므로, 수평 확장 시 각 서버에 &lt;strong>클라이언트 연결이 분산&lt;/strong>됩니다.&lt;/p>
&lt;p>이를 해결하기 위해 &lt;strong>서버 간 상태를 동기화&lt;/strong>하거나 상황에 맞게 클라이언트가 &lt;strong>특정 서버에 고정&lt;/strong>되도록 설정해야 합니다.&lt;/p>
&lt;h2 id="로드-밸런싱">로드 밸런싱&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_1.png"
width="1650"
height="1275"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_1_hue58ad55d5fe691e3e59586d3994effac_81538_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_1_hue58ad55d5fe691e3e59586d3994effac_81538_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="로드 밸런싱"
class="gallery-image"
data-flex-grow="129"
data-flex-basis="310px"
>&lt;/p>
&lt;p>수평 확장을 통해 서비스의 요청을 분산하기 위해 여러 대의 서버를 배포하면 실제로 배포된 여러 서버로 요청을 분산해야겠죠&lt;/p>
&lt;p>로드 밸런싱은 들어오는 네트워크 트래픽을 여러 서버에 효율적으로 분산하는 기술입니다.&lt;/p>
&lt;h3 id="sticky-sessions-vs-non-sticky-sessions">Sticky Sessions vs Non-Sticky Sessions&lt;/h3>
&lt;p>네트워크 트래픽을 분산하기 위한 여러 알고리즘이 존재하는데, 클라이언트 요청이 같은 서버로 가는지 아닌지에 따라 나눌 수 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_2.png"
width="850"
height="400"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_2_hu00407f29da576d8704b9ee37e577ead4_25051_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_2_hu00407f29da576d8704b9ee37e577ead4_25051_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Sticky Sessions vs Non-Sticky Sessions"
class="gallery-image"
data-flex-grow="212"
data-flex-basis="510px"
>&lt;/p>
&lt;p>Non-Sticky Sessions은 클라이언트의 요청이 매번 다른 서버로 자유롭게 라우팅될 수 있는 방식으로 stateless 아키텍처를 구현할 때 선호되는 방식입니다.&lt;/p>
&lt;p>주요 차이점을 비교하면:&lt;/p>
&lt;ol>
&lt;li>상태 관리
&lt;ul>
&lt;li>Sticky Sessions: 서버가 클라이언트의 상태를 메모리에 보관&lt;/li>
&lt;li>Non-Sticky Sessions: 모든 상태를 Redis 같은 외부 저장소에 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>장애 대응
&lt;ul>
&lt;li>Sticky Sessions: 서버 장애 시 해당 서버의 모든 세션 손실&lt;/li>
&lt;li>Non-Sticky Sessions: 서버 장애와 무관하게 세션 유지 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장성
&lt;ul>
&lt;li>Sticky Sessions: 특정 서버에 부하가 집중될 수 있음&lt;/li>
&lt;li>Non-Sticky Sessions: 더 균등한 부하 분산 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>웹소켓의 경우 연결 자체가 stateful하기 때문에 일반적으로 Sticky Sessions을 사용하지만, &lt;strong>대규모 시스템&lt;/strong>에서는 Non-Sticky Sessions 방식을 채택하고 모든 상태를 외부 저장소에 보관하는 방식을 사용하기도 합니다.&lt;/p>
&lt;h2 id="서버-간-상태-동기화">서버 간 상태 동기화&lt;/h2>
&lt;p>저희 서비스에서는 사용자가 퀴즈존을 기반으로 서버의 세션을 통해 관리되기 때문에, 퀴즈존에 참여하고 있는 모든 사용자가 동일한 서버에 연결되어야 합니다.&lt;/p>
&lt;p>이는 상황에 따라 사용자가 많이 참여하고 있는 퀴즈존이 특정 서버에 집중되는 경우 수평 확장의 장점을 가져갈 수 없게 되는 문제를 발생시킬 수 있습니다.&lt;/p>
&lt;p>이렇게 특정 서버에 세션에 의존하지 않게 만들기 위해 &lt;strong>서버 간의 상태를 동기화&lt;/strong> 해야할 필요가 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_3.png"
width="385"
height="131"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_3_hufe3d7b7f11325482bb16b822eb0a78ec_8599_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_3_hufe3d7b7f11325482bb16b822eb0a78ec_8599_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Redis"
class="gallery-image"
data-flex-grow="293"
data-flex-basis="705px"
>&lt;/p>
&lt;p>단순히 서버 간의 상태를 동기화 한다면, 모든 사용자에 대한 정보를 모든 서버가 메모리로 가져야하고 이를 수시로 업데이트 해야하는 문제가 있습니다.&lt;/p>
&lt;p>이는 배포된 각각의 서버의 메모리가 충분해야는 것이 기본 전제이므로 메모리로 인한 서버 비용 절감은 의미가 없어질 뿐 아니라 상태 동기화를 위한 여러 오버헤드가 발생하므로 효과적인 방식으로 보긴 어렵습니다.&lt;/p>
&lt;p>그래서 더 단순한 방법으로 배포된 여러 서버가 같은 세션을 바라보게 만드는 방법을 활용하는 경우가 많고, 세션은 빠른 읽기/쓰기가 요구되므로 주로 &lt;code>Redis&lt;/code>를 활용합니다.&lt;/p>
&lt;h2 id="pubsub-패턴-적용">Pub/Sub 패턴 적용&lt;/h2>
&lt;p>위처럼 서버 간의 상태를 동기화했다고 하더라도, 웹소켓의 특성상 특정 서버에 연결된 클라이언트에게만 직접 메시지를 전송할 수 있습니다. 다른 서버에 연결된 클라이언트에게는 직접적인 메시지 전송이 불가능한 것이죠.&lt;/p>
&lt;p>이 문제를 해결하기 위해 메시지 브로커를 활용한 Pub/Sub 패턴을 적용할 수 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_4.png"
width="2050"
height="1168"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_4_hu3cc9ed0eaf825475f37e7ff59c7a86c6_734061_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_4_hu3cc9ed0eaf825475f37e7ff59c7a86c6_734061_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Pub/Sub 패턴"
class="gallery-image"
data-flex-grow="175"
data-flex-basis="421px"
>&lt;/p>
&lt;ul>
&lt;li>각 서버는 메시지 브로커(예: Redis, RabbitMQ, Kafka)의 채널을 구독(Subscribe)&lt;/li>
&lt;li>메시지 전송이 필요할 때는 해당 채널에 메시지를 발행(Publish)&lt;/li>
&lt;li>모든 서버가 메시지를 수신하고, 자신에게 연결된 클라이언트에게 필요한 메시지를 전달&lt;/li>
&lt;/ul>
&lt;p>이러한 방식을 통해 서버 간 직접적인 통신 없이도 모든 클라이언트에게 메시지를 전달할 수 있습니다.&lt;/p>
&lt;h2 id="auto-scaling">Auto Scaling&lt;/h2>
&lt;p>리소스를 효율적으로 관리하기 위해, 트래픽에 따라 서버를 동적으로 확장하고 축소하는 것이 이상적입니다.&lt;/p>
&lt;ul>
&lt;li>저희 서비스도 근본적으로는 게임이라서 저녁 시간대에 트래픽이 집중되지 않을까 예상해봅니다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_5.png"
width="560"
height="332"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_5_hu8d0a7bc59b0e5202eca4aab1e4c19efd_27969_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_5_hu8d0a7bc59b0e5202eca4aab1e4c19efd_27969_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Auto Scaling"
class="gallery-image"
data-flex-grow="168"
data-flex-basis="404px"
>&lt;/p>
&lt;p>하지만 웹소켓 서버의 동적 확장 시에는 몇 가지 고려해야 할 문제들이 있습니다.&lt;/p>
&lt;h3 id="서버-추가">서버 추가&lt;/h3>
&lt;p>새로운 서버가 추가되었을 때, 기존 클라이언트들은 이미 다른 서버들과 연결이 되어있는 상태입니다. 이로 인해 새로운 서버는 새로 접속하는 클라이언트의 연결만 받게 되어 서버 간 부하 분산이 균형있게 이루어지지 않을 수 있습니다.&lt;/p>
&lt;p>이를 해결하기 위해서는 다음과 같은 방법들을 고려할 수 있습니다:&lt;/p>
&lt;ul>
&lt;li>연결 재분배 (Connection Rebalancing)
&lt;ul>
&lt;li>주기적으로 서버 간 연결 수를 확인하고 불균형이 발생하면 일부 클라이언트에게 재연결 요청&lt;/li>
&lt;li>클라이언트는 재연결 시 로드밸런서를 통해 새로운 서버에 고르게 분배됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가중치 기반 라우팅
&lt;ul>
&lt;li>새로운 서버에 더 높은 가중치를 부여하여 신규 연결을 더 많이 할당&lt;/li>
&lt;li>점진적으로 서버 간 연결 수가 균형을 이루도록 조정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="서버-제거">서버 제거&lt;/h3>
&lt;p>서버를 제거할 때는 해당 서버에 연결된 클라이언트들의 연결을 적절히 처리해야 합니다. 갑작스러운 연결 종료는 사용자 경험을 해칠 수 있으며, 서비스의 안정성에도 영향을 미칩니다.&lt;/p>
&lt;p>이를 위한 해결 방안으로는:&lt;/p>
&lt;ul>
&lt;li>Draining Mode 구현
&lt;ul>
&lt;li>서버 제거 전에 해당 서버를 &amp;lsquo;draining&amp;rsquo; 상태로 전환&lt;/li>
&lt;li>더 이상 새로운 연결을 받지 않도록 로드밸런서 설정 변경&lt;/li>
&lt;li>기존 연결은 유지하면서 자연스럽게 감소하도록 유도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Graceful Shutdown with Notification
&lt;ul>
&lt;li>종료 예정인 서버의 클라이언트들에게 재연결 필요성을 알리는 메시지 전송&lt;/li>
&lt;li>클라이언트는 메시지 수신 후 다른 서버로 재연결 시도&lt;/li>
&lt;li>일정 시간 후 남아있는 연결을 정상적으로 종료&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="zookeeper">ZooKeeper&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_6.png"
width="921"
height="498"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_6_hu9638b0602de60e14c3a3201684f97ad9_138457_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_6_hu9638b0602de60e14c3a3201684f97ad9_138457_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Apache ZooKeeper"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="443px"
>&lt;/p>
&lt;p>이러한 처리들의 원활한 관리를 위해 서버들의 상태를 효과적으로 관리하고 모니터링하는 것이 중요합니다. Apache ZooKeeper와 같은 도구를 활용하면 이러한 분산 환경에서의 서버 관리를 효율적으로 수행할 수 있습니다.&lt;/p>
&lt;ul>
&lt;li>서버 상태 관리
&lt;ul>
&lt;li>각 서버는 ZooKeeper에 임시 노드(ephemeral node)를 생성하여 자신의 상태를 등록&lt;/li>
&lt;li>서버 장애 시 노드가 자동으로 삭제되어 빠른 장애 감지 가능&lt;/li>
&lt;li>현재 활성화된 서버 목록을 실시간으로 파악 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>부하 분산 정보 공유
&lt;ul>
&lt;li>각 서버의 현재 연결 수, 리소스 사용량 등을 ZooKeeper에 저장&lt;/li>
&lt;li>로드밸런서는 이 정보를 바탕으로 최적의 서버 선택 가능&lt;/li>
&lt;li>동적 가중치 조정에 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>설정 정보 관리
&lt;ul>
&lt;li>서버 구성 정보, 환경 설정 등을 중앙화된 저장소에서 관리&lt;/li>
&lt;li>설정 변경 시 모든 서버에 실시간으로 반영 가능&lt;/li>
&lt;li>일관된 설정 유지 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>Auto Scaling과의 연계&lt;/strong>&lt;/p>
&lt;p>ZooKeeper를 Auto Scaling과 연계하면 더욱 효과적인 서버 관리가 가능합니다:&lt;/p>
&lt;ul>
&lt;li>스케일 인/아웃 이벤트 발생 시 서버 목록 자동 업데이트&lt;/li>
&lt;li>새로운 서버 추가 시 기존 서버들과의 설정 동기화&lt;/li>
&lt;li>서버 제거 시 안전한 종료 절차 조율&lt;/li>
&lt;li>서버 간 부하 분산 상태 모니터링 및 재조정&lt;/li>
&lt;/ul>
&lt;p>이러한 ZooKeeper의 활용은 특히 Auto Scaling 환경에서 서버들의 동적인 변화를 안정적으로 관리하는 데 큰 도움이 될 수 있고, 서버의 추가와 제거가 자주 발생하는 환경에서도 서비스의 안정성과 가용성을 높은 수준으로 유지할 수 있다는 장점도 있습니다.&lt;/p>
&lt;h2 id="정리">정리&lt;/h2>
&lt;p>웹소켓 기반의 실시간 게임 서비스를 확장하면서 발생할 수 있는 문제들과 해결 방안들을 살펴보았습니다.&lt;/p>
&lt;ul>
&lt;li>서버 확장성 문제
&lt;ul>
&lt;li>수평적 확장을 통한 처리량 증가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>상태 관리 문제
&lt;ul>
&lt;li>Redis를 활용한 세션 저장소 외부화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 전달 문제
&lt;ul>
&lt;li>Pub/Sub 패턴 도입&lt;/li>
&lt;li>메시지 브로커를 통한 효율적인 메시지 전파&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>동적 확장 문제
&lt;ul>
&lt;li>서버의 동적 추가, 제거로 인한 문제&lt;/li>
&lt;li>ZooKeeper 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>연결이 유지되는 특성 때문에 발생하는 문제들이 많았네요&lt;/p>
&lt;p>어떤 방식들을 적용해야할지 고민을 더 해봐야겠습니다.&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다😊&lt;/p></description></item><item><title>1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 어플리케이션</title><link>https://codemario318.github.io/post/designing-data-intensive-application/1/</link><pubDate>Thu, 02 Jan 2025 13:54:49 +0900</pubDate><guid>https://codemario318.github.io/post/designing-data-intensive-application/1/</guid><description>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/cover.png" alt="Featured image of post 1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 어플리케이션" />&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img.png"
width="2100"
height="2756"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_hu7c7d9bbab499c5082d7f275bac15d9e4_1376618_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_hu7c7d9bbab499c5082d7f275bac15d9e4_1376618_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 중심 어플리케이션 설계"
class="gallery-image"
data-flex-grow="76"
data-flex-basis="182px"
>&lt;/p>
&lt;p>오늘날 많은 애플리케이션은 &lt;strong>계산 중심&lt;/strong>(compute-intensive)과는 다르게 &lt;strong>데이터 중심&lt;/strong>(data-intensive)적이다.&lt;/p>
&lt;p>이러한 애플리케이션의 경우 CPU 성능보다 &lt;strong>데이터의 양&lt;/strong>, &lt;strong>데이터의 복잡도&lt;/strong>, &lt;strong>데이터의 변화 속도&lt;/strong>가 애플리케이션을 제한하는 요소이다.&lt;/p>
&lt;p>일반적으로 데이터 중심 애플리케이션은 공통으로 필요로 하는 기능을 제공하는 표준 구성 요소(standard building block)로 만든다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장(&lt;strong>데이터베이스&lt;/strong>)&lt;/li>
&lt;li>읽기 속도 향상을 위해 값비싼 수행 결과를 기억(&lt;strong>캐시&lt;/strong>)&lt;/li>
&lt;li>사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공(&lt;strong>검색 색인, search index&lt;/strong>)&lt;/li>
&lt;li>비동기 처리를 위해 다른 프로세스로 메시지 보내기(&lt;strong>스트림 처리, stream processing&lt;/strong>)&lt;/li>
&lt;li>주기적으로 대량의 누적된 데이터를 분석(&lt;strong>일괄 처리, batch processing&lt;/strong>)&lt;/li>
&lt;/ul>
&lt;p>애플리케이션마다 요구사항이 다르기 때문에 데이터베이스 시스템 도한 저마다 다양한 특성을 가지고 있다.&lt;/p>
&lt;ul>
&lt;li>캐싱을 위한 다양한 접근 방식, 검색 색인을 구축하는 여러 가지 방법 등&lt;/li>
&lt;/ul>
&lt;p>애플리케이션을 만들 때 어떤 도구와 어떤 접근 방식이 수행 중인 작업에 가장 적합한지 생각해야 한다.&lt;/p>
&lt;ul>
&lt;li>단 하나의 도구만으로 할 수 없는 것을 해야하는 경우 도구들을 결합하기 어려울 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이 책은 데이터 시스템의 원칙(principle)과 실용성(practicality), 이를 활용한 데이터 중심 애플리케이션을 개발하는 방법을 모두 담고있다.&lt;/p>
&lt;blockquote>
&lt;p>소개된 다양한 도구가 공통적으로 지닌 것은 무엇이고 서로 구별되는 것은 무엇인지, 어떠헥 그러한 특성을 구현해냈는지 알아본다.&lt;/p>
&lt;/blockquote>
&lt;p>그 전에 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 데이터 시스템을 구축하기 위한 가장 기초적인 노력을 살펴봐야한다.&lt;/p>
&lt;h2 id="데이터-시스템에-대한-생각">데이터 시스템에 대한 생각&lt;/h2>
&lt;p>일반적으로 데이터베이스, 큐, 캐시 등을 매우 다른 범주에 속하는 도구로 생각한다.&lt;/p>
&lt;p>데이터베이스와 메시지 큐는 표면적으로 비슷하더라도(얼마 동안 데이터를 저장함) 매우 다른 접근 패턴을 갖고 있어 서로 다른 성능 특성이 있기 때문에 구현 방식이 다르다.&lt;/p>
&lt;blockquote>
&lt;p>모든 것을 왜 &lt;strong>데이터 시스템&lt;/strong>이라는 포괄적 용어로 묶어야 하는가?&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>분류 간 경계가 흐려짐&lt;/strong>&lt;/p>
&lt;p>데이터 저장과 처리를 위한 여러 새로운 도구는 최근에 만들어졌고, 새로운 도구들은 다양한 사용 사례(use case)에 최적화되어 전통적인 분류에 딱 들어맞지 않는다.&lt;/p>
&lt;p>메시지 큐를 예시로 살펴보면&lt;/p>
&lt;ul>
&lt;li>레디스: 지속성을 보장하지 않음&lt;/li>
&lt;li>카프카: 데이터베이스처럼 지속성을 보장&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>광범위한 요구사항&lt;/strong>&lt;/p>
&lt;p>점점 더 많은 애플리케이션이 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없는 과도하고 광범위한 요구사항을 갖고있다.&lt;/p>
&lt;p>대신 작업(work)은 단일 도구에서 효율적으로 수행할 수 있는 태스크(task)로 나누고 다양한 도구들은 애플리케이션 코드를 이용해 서로 연결한다.&lt;/p>
&lt;ul>
&lt;li>메인 데이터베이스와 분리된 애플리케이션 관리 캐시 계층(멤캐시디, Memcached)이나 전문(full-text) 검색 서버(엘라스틱서치, 솔라)의 경우 메인 데이터베이스와 동기화된 캐시나 색인을 유지하는 것은 보통 애플리케이션 코드의 책임이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img_1.png"
width="2880"
height="2049"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_1_huf3ea3a46984851ffc8f25b1984abfd55_116627_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_1_huf3ea3a46984851ffc8f25b1984abfd55_116627_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="다양한 구성 요소를 결합한 데이터 시스템 아키텍처의 예"
class="gallery-image"
data-flex-grow="140"
data-flex-basis="337px"
>&lt;/p>
&lt;p>서비스 제공을 위해 각 도구를 결합할 때 서비스 인터페이스나 애플리케이션 프로그래밍 인터페이스(API)는 보통 클라이언트가 모르게 구현 세부사항을 숨긴다.&lt;/p>
&lt;ul>
&lt;li>기본적으로 좀 더 작은 범용 구성 요소들로 새롬고 특수한 목적의 데이터 시스템을 만든다.&lt;/li>
&lt;li>복합 데이터 시스템(composite data system)은 외부 클라이언트가 일관된 결과를 볼 수 있게끔 쓰기에서 캐시를 올바르게 무효화하거나 엡데이트 하는 등의 특정 보장 기능을 제공할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>여러 데이터 시스템을 설계, 통합하고 관리해야하는 요즘 개발자는 애플리케이션 개발자일 뿐 아니라 &lt;strong>데이터 시스템 설계자&lt;/strong>이기도 하다.&lt;/p>
&lt;hr>
&lt;p>데이터 시스템이나 서비스를 설계할 때 까다로운 문제가 많이 생긴다.&lt;/p>
&lt;ul>
&lt;li>내부적으로 문제가 있어도 데이터를 정확하고 완전하게 유지해야함&lt;/li>
&lt;li>시스템의 일부 성능이 저하되더라도 클라이언트에 일관되게 좋은 성능을 제공해야함&lt;/li>
&lt;li>부하 증가를 다루기 위해 규모를 확장할 수 있어야함&lt;/li>
&lt;li>서비스를 위해 좋은 API를 설계해야함&lt;/li>
&lt;/ul>
&lt;p>뿐만 아니라 관련자의 기술 숙련도, 기존 시스템의 의존성, 전달 시간 척도, 다양한 종류의 위험에 대한 조직의 내성, 규제 제약 등은 시스템 설계에 영향을 줄 수 있는 많은 요소이다.&lt;/p>
&lt;p>이런 요소는 상황에 크게 좌우되는 요소이므로 이 책에서는 &lt;strong>대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사에 중점&lt;/strong>을 둔다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>신뢰성&lt;/strong>(Reliability)
&lt;ul>
&lt;li>하드웨어나 소프트웨어 결함, 인적 오류 같은 &lt;strong>역경&lt;/strong>에 직면하더라도 시스템은 지속적으로 올바르게 동작(원하는 성능 수준에서 정확한 기능을 수행)해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>확장성&lt;/strong>(Scalability)
&lt;ul>
&lt;li>시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>유지보수성&lt;/strong>(Maintainability)
&lt;ul>
&lt;li>여러 다양한 사람들이 시스템 상에서 작업할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있어야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="신뢰성">신뢰성&lt;/h2>
&lt;p>소프트웨어의 경우 신뢰성에 대한 일반적인 기대치는 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션은 사용자가 기대한 기능을 수행한다.&lt;/li>
&lt;li>시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다.&lt;/li>
&lt;li>시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.&lt;/li>
&lt;li>시스템은 허가되지 않은 접근과 오남용을 방지한다.&lt;/li>
&lt;/ul>
&lt;p>이러한 내용들이 올바르게 동작함을 의미하는 경우, 대략 &amp;ldquo;&lt;strong>무언가 잘못 되더라도 지속적으로 올바르게 동작함&lt;/strong>&amp;ldquo;을 신뢰성의 의미로 이해할 수 있다.&lt;/p>
&lt;h3 id="결함">결함&lt;/h3>
&lt;p>잘못될 수 있는 일을 &lt;strong>결함&lt;/strong>(fault)이라 부른다.&lt;/p>
&lt;p>그리고 결함을 예측하고 대처할 수 있는 시스템을 &lt;strong>내결함성&lt;/strong>(fault-tolerant) 또는 &lt;strong>탄력성&lt;/strong>(resilient)을 지녔다고 말한다.&lt;/p>
&lt;p>모든 종류의 결함을 견딜 수 있는 시스템은 실제로 실현 가능하지 않으므로 &lt;strong>특정 유형&lt;/strong>의 결함 내성에 대해서만 이야기하는 것이 타당하다.&lt;/p>
&lt;p>결함과 장애(failure)는 다르다.&lt;/p>
&lt;ul>
&lt;li>결함
&lt;ul>
&lt;li>사양에서 벗어난 시스템의 한 구성 요소&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>장애
&lt;ul>
&lt;li>사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>결함 확률을 0으로 줄이는 것은 불가능하므로 결함으로 인해 장애가 발생하지 않게끔 내결함성 구조를 설계하는 것이 좋다.&lt;/p>
&lt;ul>
&lt;li>이 책에서는 신뢰할 수 없는 여러 부품들로 신뢰할 수 있는 시스템을 구축하는 다양한 기법을 배운다.&lt;/li>
&lt;/ul>
&lt;p>실제 많은 중대한 버그는 미흡한 오류 처리에서 기인한다.&lt;/p>
&lt;ul>
&lt;li>내결함성 시스템에서 고의적으로 결함을 유도함으로써 내결함성 시스템을 지속적으로 훈련하고 테스트해서 결함이 자연적으로 발생했을 때 올바르게 처리할 수 있다는 자신감을 높인다.&lt;/li>
&lt;li>ex) 넷플릭스의 &lt;strong>카오스 몽키&lt;/strong>(Chaos Monkey)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>일반적으로 결함 예방을 넘어 내결함성을 갖는 것을 선호하지만, 해결책이 없는 경우는 예방책이 필수적이다.&lt;/p>
&lt;ul>
&lt;li>보안 문제: 공격자가 시스템을 손상시키고 민감한 데이터에 대한 접근 권한을 얻는다면 되돌릴 수 없다.&lt;/li>
&lt;/ul>
&lt;h3 id="하드웨어-결함">하드웨어 결함&lt;/h3>
&lt;p>시스템 장애의 대표적인 예시로, 규모가 큰 데이터센터에서 일하는 사람은 많은 장비를 다룰 경우 이 같은 일은 늘상 일어난다고 말한다.&lt;/p>
&lt;ul>
&lt;li>10,000개의 디스크로 구성된 저장 클러스터는 평균적으로 하루에 한 개의 디스크가 죽는다고 예상해야한다.&lt;/li>
&lt;/ul>
&lt;p>시스템 장애율을 줄이기 위한 대표적인 방법은 각 하드웨어 구성 요소에 중복(redundancy)을 추가하는 방법이다.&lt;/p>
&lt;ul>
&lt;li>구성 요소가 죽으면 고장 난 구성 요소가 교체되는 동안 중복된 구성 요소를 대신 사용한다.&lt;/li>
&lt;/ul>
&lt;p>이런 접근 방식은 하드웨어 문제로 장애가 발생하는 것은 완전히 막으룻는 없지만 이해하기 쉽고 보통 수년 간 장비가 중단되지 않고 계속 동작할 수 있게 한다.&lt;/p>
&lt;p>최근까지 단일 장비의 전체 장애는 매우 드물기 때문에 대부분의 애플리케이션은 하드웨어 구성 요소의 중복으로 충분하여, 다중 장비 중복은 고가용성(high availability)이 절대적으로 필수적은 소수의 애플리케이션에서만 필요했다.&lt;/p>
&lt;ul>
&lt;li>새 장비에 백업을 매우 빠르게 복원할 수 있는 경우 중단시간(downtime)은 대부분의 애플리케이션에 치명적이지 않다.&lt;/li>
&lt;/ul>
&lt;p>하지만 데이터 양과 애플리케이션의 계산 요구가 늘어나면서 더 많은 애플리케이션이 많은 수의 장비를 사용하게 됐고 이와 비례해 하드웨어 결함율도 증가했다.&lt;/p>
&lt;p>따라서 소프트웨어 내결함성 기술을 사용하거나 하드웨어 중복성을 추가해 전체 장비의 손실을 견딜 수 있는 시스템으로 점점 옮겨가고 있으며, 이러한 시스템에는 운영상의 장점도 있다.&lt;/p>
&lt;ul>
&lt;li>장비를 재부팅 해야하는 경우 등&lt;/li>
&lt;/ul>
&lt;h3 id="소프트웨어-오류">소프트웨어 오류&lt;/h3>
&lt;p>보통 하드웨어 결함을 무작위적으고 서로 독립적이라고 생각한다.&lt;/p>
&lt;ul>
&lt;li>다수의 하드웨어 구성 요소에 동시 장애가 발생하는 경우는 드물다.&lt;/li>
&lt;/ul>
&lt;p>또 다른 부류의 결함으로 시스템 내 체계적 오류(systematic error)는 예상하기 더 어렵고 노드 간 상관관계 때문에 상관관계가 없는 하드웨어 결함보다 오히려 시스템 오류를 더욱 많이 유발하는 경향이 있다.&lt;/p>
&lt;ul>
&lt;li>잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그
&lt;ul>
&lt;li>ex) 리눅스 커널의 버그로 인해 많은 애플리케이션이 일제히 멈춰버린 원인니 된 2012년 6월 30일 윤초&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스&lt;/li>
&lt;li>시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스&lt;/li>
&lt;li>한 구성 요소의 작은 결함이 다른 구성 요소의 결함을 야기하고 차례차례 더 많은 결함이 발생하는 연쇄 장애(cascading failure)&lt;/li>
&lt;/ul>
&lt;p>이 같은 소프트웨어 결함을 유발하는 버그는 &lt;strong>특정 상황에 의해 발생하기 전까지 오랫동안 나타나지 않는다&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>소프트웨어에는 확여에 대한 일종의 가정이 있다는 시실을 알 수 있다.(일부 제외)&lt;/li>
&lt;/ul>
&lt;p>스프트웨어의 체계적 오류 문제는 신속한 해결책이 없다.&lt;/p>
&lt;ul>
&lt;li>시스템의 가정과 상호작용에 대해 주의 깊게 생각하기&lt;/li>
&lt;li>빈틈없는 테스트&lt;/li>
&lt;li>프로세스 격리(process isolation)&lt;/li>
&lt;li>죽은 프로세스의 재시작 허용&lt;/li>
&lt;li>프로덕션 환경에서 스스템 동작의 측정&lt;/li>
&lt;li>모니터링&lt;/li>
&lt;li>분석하기&lt;/li>
&lt;/ul>
&lt;p>위와 같은 여러 작은 일들이 문제 해결에 도움을 줄 수 있다.&lt;/p>
&lt;p>시스템이 무너가를 보장하길 기대한다면 수행 중에 이를 지속적으로 확인해 차이가 생기는 경우 경고를 발생시킬 수 있다.&lt;/p>
&lt;h3 id="인적-오류">인적 오류&lt;/h3>
&lt;p>사람은 소프트웨어 시스템을 설계하고 구축하며, 운영자로서 시스템을 계속 운영한다.&lt;/p>
&lt;ul>
&lt;li>대규모 인터넷 서비스에 대한 연구에 따르면 운영자의 설정 오류가 중단의 주요 원인이며, 하드웨어 결함은 중단 원인의 10~20%에 그친다.&lt;/li>
&lt;/ul>
&lt;p>다양한 접근 방식을 결합하여 신뢰성 있는 시스템을 만들어야 한다.&lt;/p>
&lt;ul>
&lt;li>오류의 가능성을 최소하 하는 방향으로 시스템을 설계
&lt;ul>
&lt;li>잘 설계된 추상화, API, 관리 인터페이스 사용으로 옳은 일은 쉽게 하고, 잘못된 일은 막는다.&lt;/li>
&lt;li>인터페이스가 지나치게 제한적이면 제한된 인터페이스를 사람들은 피해 작업하는 경향이 있어, 올바르게 작동하게끔 균형을 맞추기 어렵다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사람이 가장 많이 실수하는 장소(부분)에서 사람의 실수로 장애가 발생할 수 있는 부분을 분리
&lt;ul>
&lt;li>비 프로덕션 샌드박스(sandbox) 환경 제공&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트
&lt;ul>
&lt;li>코너 케이스를 다루는 데 유용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>장애 발생의 영향을 최소화하기 위해 인적 오류를 빠르고 쉽게 복구할 수 있는 환경
&lt;ul>
&lt;li>설정 변경 내역을 빠르게 롤백&lt;/li>
&lt;li>새로운 코드를 서서히 롤하웃하게 구성(예상치 못한 버그가 일부 사용자에게만 영향이 미치도록)&lt;/li>
&lt;li>이전 계산이 잘못된 경우를 대비해 데이터 재계산 도구 제공&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책 마련
&lt;ul>
&lt;li>원격 측정(telemetry)&lt;/li>
&lt;li>모니터링은 조기에 경고 신호를 보내줄 수 있고 특정 가정이나 제한을 벗어나는지 확인할 수 있게 함&lt;/li>
&lt;li>문제가 발생했을 때 지표는 문제를 분석하는 데 매우 중요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>조작 교육과 실습을 진행&lt;/li>
&lt;/ul>
&lt;h3 id="신뢰성은-얼마나-중요할까">신뢰성은 얼마나 중요할까?&lt;/h3>
&lt;p>신뢰성은 원자력 발전소나 항공 교통 관제 소프트웨어만을 위한 것이 아니며, 일상적인 애플리케이션도 안정적으로 작동해야한다.&lt;/p>
&lt;p>비즈니스 애플리케이션에서 버그는 생산성 저하의 원인이고 전자 상거래 사이트의 중단은 매출에 손실이 발생하고 명성에 타격을 준다는 면에서 많은 비용이 든다.&lt;/p>
&lt;p>중요하지 않은 애플리케이션도 사용자에 대한 책임이 있다.&lt;/p>
&lt;ul>
&lt;li>사소한 데이터라도 누군가에게는 매우 소중할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>비용을 줄이려 신뢰성을 희생해야 하는 경우, 비용을 줄여하는 시점을 매우 잘 알고 있어야 한다.&lt;/p>
&lt;h2 id="확장성">확장성&lt;/h2>
&lt;p>시스템이 현재 안정적으로 동작한다고 해서 미래에도 아정적으로 동작한다는 보장은 없다.&lt;/p>
&lt;p>성능 저하를 유발하는 흔한 이뉴 중 하나는 부하 증가로, 확장성은 증가한 부하에 대처하는 시스템 능력을 설명한다.&lt;/p>
&lt;p>확장성을 논한다는 것은 &amp;ldquo;&lt;strong>시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?&lt;/strong>&amp;ldquo;와 &amp;ldquo;&lt;strong>추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?&lt;/strong>&amp;rdquo; 같은 질문을 고여한다는 의미이다.&lt;/p>
&lt;h3 id="부하-기술하기">부하 기술하기&lt;/h3>
&lt;p>무엇보다 시스템의 현재 부하를 간결하게 기술해야 부하 성장 질문을 논의할 수 있다.&lt;/p>
&lt;p>부하는 &lt;strong>부하 매개변수&lt;/strong>(load parameter)라 부르는 몇 개의 숫자로 내타낼 수 있으며, 가장 적합한 부하 매개변수 선택은 시스템 설계에 따라 달라진다.&lt;/p>
&lt;ul>
&lt;li>웹 서버의 초당 요청 수&lt;/li>
&lt;li>데이터베이스의 읽기 대 쓰기 비율&lt;/li>
&lt;li>대화방의 동시 활성 사용자(active user)&lt;/li>
&lt;li>캐시 적중률 등&lt;/li>
&lt;/ul>
&lt;p>평균적인 경우가 중요할 수도 있고 소수의 극단적인 경우가 병목 현상의 우너인일 수도 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>트위터 예시&lt;/strong>&lt;/p>
&lt;p>트위터의 주요 두 가지 동작은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>트윗 작성
&lt;ul>
&lt;li>사용자는 팔로워에게 새로운 메시지를 게시할 수 있다.&lt;/li>
&lt;li>평균 초당 4.6k 요청, 피크일 때 12k 요청 이상&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>홈 타임라인
&lt;ul>
&lt;li>사용자는 팔로우한 사람이 작성한 트윗을 볼 수 있다.&lt;/li>
&lt;li>초당 300k 요청&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>단순히 초당 12,000쓰기 처리는 상당히 쉽지만, 트위터의 확장성 문제는 주로 트윗 양이 아닌 팬 아웃(fan-out) 때문이다.&lt;/p>
&lt;p>개별 사용자는 많은 사용자를 팔로우하고 많은 사람이 개별 사용자를 팔로우한다.&lt;/p>
&lt;ol>
&lt;li>트윗 작성은 간단히 새로운 트윗 전역 컬렉션에 삽입.
&lt;ul>
&lt;li>사용자가 자신의 홈 타임라인을 요청하면 팔로우하는 모든 사람을 찾고, 이 사람들의 모든 트윗을 찾아 시간순으로 정렬해서 합친다.&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tweets&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tweets&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tweets&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sender_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">follows&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">follows&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">followee_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">follows&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">follower_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">current_user&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 수신 사용자용 트윗 유편함처럼 개별 사용자의 홈 타임라인 캐시를 유지.
&lt;ul>
&lt;li>사용자가 트윗을 작성하면 해당 사용자를 팔오우하는 사람을 모두 찾고 팔로워 각자의 홈 타임라인 캐시에 새로운 트윗을 삽입&lt;/li>
&lt;li>홈 타임라인의 읽기 요청은 요청 결과를 미리 계산했으므로 비용이 저렴&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img_2.png"
width="2880"
height="1037"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_2_huef454c28ed509f14d0506aa4413f3fba_72867_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_2_huef454c28ed509f14d0506aa4413f3fba_72867_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="트위터 홈 타임라인 구현을 위한 간략한 관계형 스키마"
class="gallery-image"
data-flex-grow="277"
data-flex-basis="666px"
>&lt;br>
&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img_3.png"
width="2880"
height="1037"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_3_huf1eee131e293bb95b1294c4be771ef1f_79137_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_3_huf1eee131e293bb95b1294c4be771ef1f_79137_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="매개변수와 함께 팔로워에게 트윗을 전송하기 위한 트위터의 데이터 파이프라인"
class="gallery-image"
data-flex-grow="277"
data-flex-basis="666px"
>&lt;/p>
&lt;p>트위터의 첫 번째 버전은 1을 사용했는데, 시스템이 홈 타임라인 질의 부하를 버텨내기 위해 고군분투 해야했고, 그 결과 2로 전환했다.&lt;/p>
&lt;ul>
&lt;li>평균적으로 트윗 게시 요청량이 홈 타임라인 읽기 요청량에 비해 수백 배 적기 때문에 2가 훨씬 잘 동작함
이 경우는 쓰기 시점에 더 많은 일을 하고, 일기 시점에 적은 일을 하는 것이 바람직하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>2의 불리한 점은 트윗 작성이 많은 부가 작업을 필요로 한다는 점이다.&lt;/p>
&lt;ul>
&lt;li>평균 트윗이 약 75명의 팔로워에게 전달되므로 초당 4.6k 트윗은 홈 타임라인 캐시에 초당 345k건의 쓰기 요청 발생&lt;/li>
&lt;li>일부 사용자는 팔로워가 3천만명이 넘으므로 단일 트윗이 홈 타임라인에 3천만 건 이상의 쓰기 요청 발생 가능&lt;/li>
&lt;/ul>
&lt;p>트위터 사례에서 사용자당 팔로워의 분포는 팬 아웃 부하를 결정하기 때문에 확장성을 논의할 때 핵심 부하 매개변수가 된다.&lt;/p>
&lt;p>결과적으로 트위터는 접근 방식 2를 기반으로 하이브리드 형식으로 바꾸고 있다.&lt;/p>
&lt;ul>
&lt;li>대부분 사용자의 트윗은 계속해서 사람들이 작성할 때 홈 타임라인에 펼쳐지지만 유명인은 팬 아웃에서 제외된다.&lt;/li>
&lt;li>유명인의 트윗은 별도로 가져와 1처럼 읽는 시점에 사용자의 홈 타임라인에 합친다.&lt;/li>
&lt;/ul>
&lt;h3 id="성능-기술하기">성능 기술하기&lt;/h3>
&lt;p>일단 시스템 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있다.&lt;/p>
&lt;ul>
&lt;li>부하 매개변수를 증가시키고 시스템 자원은 병경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?&lt;/li>
&lt;li>부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까?&lt;/li>
&lt;/ul>
&lt;p>두 질문 모두 성능 수치가 필요하므로 시스템 성능에 대해 간단히 살펴본다.&lt;/p>
&lt;ul>
&lt;li>일괄 처리 시스템(ex. hadoop)
&lt;ul>
&lt;li>&lt;strong>처리량&lt;/strong>(throughput, 초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>온라인 시스템
&lt;ul>
&lt;li>서비스 &lt;strong>응답 시간&lt;/strong>(response time)&lt;/li>
&lt;li>클라이언트가 요청을 보내고 응답을 받는 사이의 시간&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>지연 시간(latency)과 응답 시간(response time)&lt;/strong>&lt;br>
응답 시간은 클라이언트 관점에서 본 시간으로, 요청을 처리하는 실제 시간 외에도 네트워크 지연과 큐 지연도 포함한다.&lt;br>
지연 시간은 요청이 처리되길 기다리는 시간으로, 서비스를 기다리며 휴지(latent) 상태인 시간을 말한다.&lt;/p>
&lt;/blockquote>
&lt;p>응답 시간은 매번 요청에 따라 달라지기 때문에, 단일 숫자가 아닌 측정 가능한 값의 분포로 생각해야한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img_4.png"
width="2880"
height="805"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_4_hu34112d46532c22af0f415ce8b7d25f2a_86463_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_4_hu34112d46532c22af0f415ce8b7d25f2a_86463_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="평균과 백분위 예시"
class="gallery-image"
data-flex-grow="357"
data-flex-basis="858px"
>&lt;/p>
&lt;p>대부분의 요청은 꽤 빠르지만 가끔 오래 걸리는 &lt;strong>특이 값(outlier)&lt;/strong> 이 있는데 다음과 같이 이유로 발생할 수 있다.&lt;/p>
&lt;ul>
&lt;li>백그라운드 프로세스의 컨텍스트 스위치&lt;/li>
&lt;li>네트워크 패킷 손실과 TCP 재전송&lt;/li>
&lt;li>가비지 컬렉션 휴지&lt;/li>
&lt;li>디스크에서 읽기를 강제하는 페이지 폴트&lt;/li>
&lt;li>서버 랙의 기계적인 진동 등&lt;/li>
&lt;/ul>
&lt;p>보고된 서비스 평균 응답 시간을 살피는 일이 일반적이지만, 전형적인 응답 시간을 알고 싶다면 평균은 좋은 지표는 아니다.&lt;/p>
&lt;ul>
&lt;li>얼마나 많은 사용자가 실제로 지연을 경험했는지 알 수 없음&lt;/li>
&lt;/ul>
&lt;p>일반적으로 평균보다는 &lt;strong>백분위&lt;/strong>(percentile)을 사용하는 편이 더 좋다.&lt;/p>
&lt;ul>
&lt;li>중앙값(median, p50)
&lt;ul>
&lt;li>사용자가 보통 얼마나 오랫동안 기다려야 하는지 알고 싶다면 좋은 지표&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>상위 백분위
&lt;ul>
&lt;li>p95, p99, p999 같은 상위 백분위를 통해특이 값이 얼마나 좋지 않은지 확인에 좋은 지표&lt;/li>
&lt;li>&lt;strong>꼬리 지연 시간(tail latency)&lt;/strong> 으로 알려진 상위 백분위 응답 시간은 서비스의 사용자 경험에 직접 영향을 주기 때문에 중요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>p9999 같이 최상위 백분위는 통제할 수 없는 임의 이벤트에 쉽게 영향을 받으므로 응답 시간을 줄이기가 매우 어려어 이점이 줄어든다.&lt;/p>
&lt;p>백분위는 서비스 수준 목표(service level objective, SLO)와 서비스 수준 협약서(service level agreement, SLA)에 자주 사용하고 기대 성능과 서비스 가용성르 정의하는 계약서에도 자주 등장한다.&lt;/p>
&lt;ul>
&lt;li>응답 시간 중앙값이 200밀리초 미만이고 99분위가 1초 미만인 경우 정상 서비스 상태로 간주하며 서비스 제공 시간은 99.9% 이상이어야 한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>선두 차단(head-of-line blocking)&lt;/strong>&lt;/p>
&lt;p>큐 대기 지연은 높은 백분위에서 응답 시간의 상당 부분을 차지한다.&lt;/p>
&lt;ul>
&lt;li>서버는 병렬로 소수의 작업만 처리할 수 있기 때문에 소수의 느린 요청 처리만으로 후속 요청 처리가 지체된다.&lt;/li>
&lt;li>서버에서 후속 요청이 빠르게 처리되더라도 이전 요청이 완료되길 기다리는 시간 때문에 클라이언트는 전체적으로 응답 시간이 느리다고 생각하게된다.&lt;/li>
&lt;/ul>
&lt;p>이런 문제로 인해 클라이언트 쪽 응답 시간 측정이 중요하다.&lt;/p>
&lt;hr>
&lt;p>시스템의 확장성을 테스트하려고 인위적으로 부하를 생성하는 경우 부하 생성 클라이언트는 응답 시간과 독립적으로 요청을 지속적으로 보내야한다.&lt;/p>
&lt;ul>
&lt;li>다음 요청을 보내기 전에 이전 요청이 완료되길 기다리면 테스트에서 인위적으로 대기 시간을 실제보다 더 짧게 만들어 평가를 왜곡한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/1/img_5.png"
width="2880"
height="1304"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/1/img_5_hu4bbd8047ec59659dcb92a302da18488b_76022_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/1/img_5_hu4bbd8047ec59659dcb92a302da18488b_76022_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="요청을 처리하기 위해 여러 번 백엔드 호출이 필요한 상황에서 단 하나의 느린 백엔드 요청이 전체 최종 사용자 요청을 느리게 만든다."
class="gallery-image"
data-flex-grow="220"
data-flex-basis="530px"
>&lt;/p>
&lt;h3 id="부하-대응-접근-방식">부하 대응 접근 방식&lt;/h3>
&lt;p>부하 수준 1단계에 적합한 아키텍처로는 10배의 부하를 대응할 수 없기 때문에 급성장하는 서비스를 맡고 있다면 부하 규모의 자릿수가 바뀔 때마다 혹은 그보다 자주 아키텍처를 재검토해야 할지 모른다.&lt;/p>
&lt;p>확장성과 관련해 &lt;strong>용량 확장(scaling up, 수직 확장)&lt;/strong> 과 &lt;strong>규모 확장(scaling out, 수평 확장)&lt;/strong> 구분할 수 있다.&lt;/p>
&lt;p>다수의 장비에 부하를 분산하는 아키텍처를 &lt;strong>비공유(shared-noting)&lt;/strong> 아키텍처라 부르며, 단일 장비에서 수행될 수 있는 시스템은 보통 간단하지만 고사양 장비는 매우 비싸기 때문에 상당히 집약된 작업 부하는 대개 규모 확장을 피하지 못한다.&lt;/p>
&lt;p>현실적으로 좋은 아키텍처는 실용적인 접근 방식의 조합이 필요하다.&lt;/p>
&lt;ul>
&lt;li>적절한 사양의 장비 몇 대가 다량의 낮은 사양 가상 장비보다 여전히 훨씬 간단하고 저렴하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>일부 시스템은 &lt;strong>탄력적(elastic)&lt;/strong> 이다.&lt;/p>
&lt;ul>
&lt;li>부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가할 수 있다. 그렇지 않은 시스템은 수동으로 확장해야한다.&lt;/li>
&lt;/ul>
&lt;p>탄력적인 시스템은 부하를 예측할 수 없을 만큼 높은 경우 유용하지만, 수동으로 확장하는 시스템이 더 간단하고 운영상 예상치 못한 일이 더 적다.&lt;/p>
&lt;hr>
&lt;p>다수의 장비에 상태 비저앙(stateless) 서비스를 배포하는 일은 상당히 간단하지만, 단일 노드에 상태 유지(stateful) 데이터 시스템을 분산 설치하는 일은 아주 많은 복잡도가 추가적으로 발생한다.&lt;/p>
&lt;ul>
&lt;li>이런 이유로 확장 비용이나 데이터베이스를 분산으로 만들어야 하는 고가용성 요구가 있을 때 까지 단일 노드에 데이터베이스를 유지하는 것이 최근까지의 통념이다.&lt;/li>
&lt;/ul>
&lt;p>분산 시스템을 위한 도구와 추상화가 좋아지면서 이 통념이 적어도 일부 애플리케이션에서는 바뀌었다.&lt;/p>
&lt;ul>
&lt;li>대용량 데이터와 트래픽을 다루지 않는 사용 사례에도 분산 데이터 시스템이 향후 기본 아키텍처로 자리 잡을 가능성이 있다.&lt;/li>
&lt;/ul>
&lt;p>대개 대규모로 동작하는 시스템의 아키텍처는 해당 시스템을 사용하는 애플리케이션에 특화돼 있다.&lt;/p>
&lt;ul>
&lt;li>범용적으로 모든 상황에 맞는 확장 아키텍처는 없다.&lt;/li>
&lt;/ul>
&lt;p>아키텍처를 결정하는 요소는 읽기의 양, 쓰기의 양, 저장할 데이터의 양, 데이터의 복잡도, 응답 시간 요구사항, 접근 패턴 등이 있다.&lt;/p>
&lt;p>특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 무엇인지에 대한 가정을 바탕으로 구축한다.&lt;/p>
&lt;ul>
&lt;li>이 가정은 곧 부하 매개변수가 되며, 이 가정이 잘못되면 확장에 대한 엔지니어링 노력은 헛수고가 되고 최악의 경우 역효과를 낳을 수 있다.&lt;/li>
&lt;/ul>
&lt;p>스타트업 초기 단계나 검증되지 않은 제품의 경우 미래를 가정한 부하에 대비해 확장하기보다는 빠르게 반복해서 제품 기능을 개선하는 작업이 좀 더 중요하다.&lt;/p>
&lt;ul>
&lt;li>확장성을 갖춘 아키텍처가 특정 애플리케이션에 특화됐을 지라도 일너 아키텍처는 보통 익숙한 패턴으로 나열된 범용적인 구성 요소로 구축한다.&lt;/li>
&lt;/ul>
&lt;h2 id="유지보수성">유지보수성&lt;/h2>
&lt;p>소프트웨어 비용의 대부분은 지속해서 이어지는 유지보수에 들어간다.&lt;/p>
&lt;ul>
&lt;li>버그 수정, 시스템 운영 유지, 장애 조사, 시로운 플랫폼 적용, 새 사용 사례를 위한 변경, 기술 채무 상환, 새로운 기능 추가 등&lt;/li>
&lt;/ul>
&lt;p>모든 레거시 시스템은 각자 나름에 풀편함이 있어 이를 다루기 위해 일반적으로 추천할 만한 방법을 제시하는 일은 매우 어렵다.&lt;/p>
&lt;p>하지만 희망적인 점은 유지보수 중 고통을 최소화하고 레거시 소프트웨어를 직접 만들지 않게끔 소프투웨어를 설계할 수 있다는 점이다.&lt;/p>
&lt;p>그러기 위해 주의를 기울여야 할 소프트웨어 시스템 설계 원칙은 다음 세 가지이다.&lt;/p>
&lt;ul>
&lt;li>운용성(operability)
&lt;ul>
&lt;li>운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단순성(simplicity)
&lt;ul>
&lt;li>시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라&lt;/li>
&lt;li>사용자 인터페이스의 단순성과는 다르다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>발전성(evolvability)
&lt;ul>
&lt;li>엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라.&lt;/li>
&lt;li>요구사항 변경 같은 예기치 않은 사용 사례를 적용하기 쉽다.&lt;/li>
&lt;li>유연성, 수정 가능성, 적응성으로 알려져 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>신뢰성, 확장성을 달성하기 위한 쉬운 해결책은 없으므로, 운용성, 단순성, 발전성을 염두에 두고 시스템을 생각하려 노력해야한다.&lt;/p>
&lt;h3 id="운용성-운영의-편리함-만들기">운용성: 운영의 편리함 만들기&lt;/h3>
&lt;p>좋은 운영은 종종 나쁜 소프트웨어의 제약을 피하는 대안이 될 수 있다.&lt;/p>
&lt;p>하지만 좋은 소프트웨어라도 나쁘게 운영할 경우 작동을 신뢰할 수 없다는 말이 있다.&lt;/p>
&lt;ul>
&lt;li>운영 중 일부 측면은 자동화할 수 있고 또 자동화 해야한다.&lt;/li>
&lt;li>자동화를 처음 설정하고 제대로 동작하는지 확인하는 일은 여전히 사람의 몫이다.&lt;/li>
&lt;/ul>
&lt;p>시스템이 지속해서 원할하게 작동하려면 운영팀이 필수이며, 좋은 운영팀은 일반적으로 다음과 같은 작업 등을 책임진다.&lt;/p>
&lt;ul>
&lt;li>시스템 상태를 모니터링 하고 상태가 좋지 않다면 빠르게 서비스를 복원&lt;/li>
&lt;li>시스템 장애, 성능 저하 등의 문제의 원인을 추적&lt;/li>
&lt;li>보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지&lt;/li>
&lt;li>다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사하응ㄹ 손상을 입히기 전에 차단&lt;/li>
&lt;li>미래에 발생 가능한 문제를 예측해 문제가 발생하기 전에 해결(ex. 용량 계획 등)&lt;/li>
&lt;li>배포, 설정 관리 등을 위한 모범 사례와 도구를 마련&lt;/li>
&lt;li>애플리케이션을 특정 플랫폼에서 다른 플랫폼으로 이동하는 등 복잡한 유지보스 태스크를 수행&lt;/li>
&lt;li>설정 변경으로 생기는 시스템 보안 유지보수&lt;/li>
&lt;li>예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의&lt;/li>
&lt;li>개인 인사 이동에도 시스템에 대한 조직의 지식을 보존&lt;/li>
&lt;/ul>
&lt;p>좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활도에 노력을 집중한다는 의미이다.&lt;/p>
&lt;ul>
&lt;li>좋은 모니터링으로 런타임 동작과 시스템의 내부에 대한 가시성 제공&lt;/li>
&lt;li>표준 도구를 이용해 자동화와 통합을 위한 우수한 자원을 제공&lt;/li>
&lt;li>개별 장비 의존성을 회피. 유지보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고 계속해서 운영 가능해야함&lt;/li>
&lt;li>좋은 문서와 이해하기 쉬운 운영 모델(ex. X를 하면 Y가 발생한다.) 제공&lt;/li>
&lt;li>만족할 만한 기본 동작을 제공하고, 필요할 때 기본값을 다시 정의할 수 있는 자유를 관리자에게 부여&lt;/li>
&lt;li>적절하게 자기 회복이 가능할 뿐 아니라 필요에 따라 관리자가 시스템 상태를 수동으로 제어할 수 있게 함&lt;/li>
&lt;li>에측 가능하게 동작하고 예기치 않은 상황을 최소화함&lt;/li>
&lt;/ul>
&lt;h3 id="단순성-복잡도-관리">단순성: 복잡도 관리&lt;/h3>
&lt;p>프로젝트가 커짐에 따라 시스템은 매우 복잡하고 이해하기 어려워진다.&lt;/p>
&lt;p>복잡도는 같은 시스템에서 작업해야 하는 모든 사람의 진행을 느리게 하고 나아가 유지 보수 비용이 증가한다.&lt;/p>
&lt;ul>
&lt;li>커다란 진흙 덩어리(big ball of mud)로 묘사한다.&lt;/li>
&lt;/ul>
&lt;p>복잡도는 다양한 증상으로 나타난다.&lt;/p>
&lt;ul>
&lt;li>상태 공간의 급증&lt;/li>
&lt;li>모듈 간 강한 커플링(tight coupling)&lt;/li>
&lt;li>복잡한 의존성&lt;/li>
&lt;li>일관성 없는 명명과 용어&lt;/li>
&lt;li>성능 문제 해결을 목표로 한 해킹&lt;/li>
&lt;li>임시방편으로 문제를 해결한 특수 사례 등&lt;/li>
&lt;/ul>
&lt;p>복잡도가 높아 시스템 유지보수가 어려울 때 아래와 같은 문제들이 발생할 수 있다.&lt;/p>
&lt;ul>
&lt;li>예산과 일정이 초과&lt;/li>
&lt;li>변경이 있을 때 버그가 생길 위험이 더 큼&lt;/li>
&lt;li>개발자가 시스템을 이해하고 추론하기 어려워지면서 시스템에 숨겨진 가정과 의도치않은 결과 및 예기치 않은 상호작용을 간과하기 쉬움&lt;/li>
&lt;/ul>
&lt;p>반대로 복잡도를 줄이면 소프트웨어 유지보수성이 크게 향상되므로, 단순성이 구축하려는 시스템의 핵심 목표여야 한다.&lt;/p>
&lt;p>시스템을 단순하게 만드는 일은 단순히 기능을 줄인다는 의미는 아니며, &lt;strong>우발적 복잡도(accidental complexity)&lt;/strong> 를 줄인다는 뜻에 더 가깝다.&lt;/p>
&lt;ul>
&lt;li>우발적 복잡도: 소프트웨어가 풀어야 할 (사용자에게 보이는) 문제에 내재하고 있지 않고 구현에서만 발생하는 것&lt;/li>
&lt;/ul>
&lt;p>우발적 복잡도를 제거하기 위한 최상의 도구는 추상화이다.&lt;/p>
&lt;ul>
&lt;li>깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.&lt;/li>
&lt;/ul>
&lt;p>좋은 추상화는 다른 다양한 애플리케이션에서도 사용 가능하다.&lt;/p>
&lt;p>이러한 재사용은 비슷한 기능을 여러 번 재구현 하는 것보다 더 효율적일 뿐만 아니라 추상화된 구성 요소의 품질 향상이 이를 사용하는 모든 애플리케이션에 도움을 주므로 고품질 소프트웨어로 이어진다.&lt;/p>
&lt;p>하지만 좋은 추상화를 찾기는 매우 어렵다.&lt;/p>
&lt;p>분산 시스템 분야에서는 여러 좋은 알고리즘이 있지만 관리 가능한 수준에서 시스템 복잡도를 유지하는 데 도움이 되는 추상화로 이런 알고리즘을 묶는 방법은 명확하지 않다.&lt;/p>
&lt;h3 id="발전성-변화를-쉽게-만들기">발전성: 변화를 쉽게 만들기&lt;/h3>
&lt;p>시스템의 요구사항이 끊임없이 변할 가능성이 크다.&lt;/p>
&lt;ul>
&lt;li>새로운 사실을 배움&lt;/li>
&lt;li>미처 예기치 않은 사용 사례 발견&lt;/li>
&lt;li>비즈니스 우선순위 변경&lt;/li>
&lt;li>사용자의 새로운 니즈&lt;/li>
&lt;li>새로운 플랫폼 등장&lt;/li>
&lt;li>법적 또는 규제 요구사항 변경&lt;/li>
&lt;li>시스템의 성장으로 인한 아키텍처 변화&lt;/li>
&lt;/ul>
&lt;p>조직 프로세스 측면에서 &lt;strong>애자일&lt;/strong> 작업 패턴은 변화에 적응하기 위한 프레임워크를 제공한다. 또한 애자일 커뮤니티는 TDD, 리팩토링 같이 자주 변화하는 환경에서 소프트웨어를 개발할 때 도움이 되는 기술 도구와 패턴을 개발하고 있다.&lt;/p>
&lt;p>애자일 기법에 대한 설명은 대부분 매우 작고, 로컬 규모(동일 애플리케이션 내 소스코드 파일이 몇 개반 있음)에 초점을 맞추고 있는데, 이 책에서는 다양한 애플리케이션이나 다른 특성을 가진 서비스로 구성된 대규모 데이터 시스템 수준에서 민첩성을 높이는 방법을 찾는다.&lt;/p>
&lt;p>데이터 시스템 변경을 쉽게 하고 변화된 요구사항에 시스템을 맞추는 방법은 시스템의 간단함과 추상화와 밀접한 관련이 있다.&lt;/p>
&lt;ul>
&lt;li>간단하고 이해하기 쉬운 시스템은 대개 복잡한 시스템보다 수정하기 쉽다.&lt;/li>
&lt;li>데이터 시스템 수준에서 민첩성을 언급할 때는 &lt;strong>발전성&lt;/strong> 사용한다.&lt;/li>
&lt;/ul>
&lt;h2 id="정리">정리&lt;/h2>
&lt;p>이번 장에서는 데이터 중심 애플리케이션을 생각하는 기본적인 방법 몇 가지를 살펴봤다.&lt;/p>
&lt;p>애플리케이션이 유용하려면 다양한 요구사항을 충족시켜야 한다.&lt;/p>
&lt;ul>
&lt;li>기능적 요구사항
&lt;ul>
&lt;li>여러 방법으로 데이터를 저장하고 조회하고 검색하고 처리하게끔 허용하는 작업과 같이 해야하는 일&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비기능적 요구사항
&lt;ul>
&lt;li>보안, 신뢰성, 법규 준수, 확장성, 호환성, 유지보수성과 같은 일반 속성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이번 장에서는 신뢰성, 확장성, 유지보수성을 자세히 살폈다.&lt;/p>
&lt;ul>
&lt;li>신뢰성
&lt;ul>
&lt;li>결함이 발생해도 시스템이 올바르게 동작하게 만든다는 의미&lt;/li>
&lt;li>결함은 하드웨어와 소프트웨어 버그와 사람에게 있을 수 있음&lt;/li>
&lt;li>내결함성 기술은 최종 사용자에게 특정 유형의 결함을 숨길 수 있게 해준다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장성
&lt;ul>
&lt;li>부하가 증가해도 좋은 성능을 유지하기 위한 전략&lt;/li>
&lt;li>확장성을 설명하기 위해 양적으로 부하와 성능을 설명하는 방법이 필요함&lt;/li>
&lt;li>확장 가능한 시스템에서는 부하가 높은 상태에서 신뢰성을 유지하기 위해 처리 용량을 추가할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유지보수성
&lt;ul>
&lt;li>본질은 시스템에서 작업하는 엔지니어와 운영 팀의 삶을 개선하는 데 있음&lt;/li>
&lt;li>좋은 추상화는 복잡도를 줄이고 쉽게 시스템을 변경할 수 있게하며 새로운 사용 사례에 적용하는 데 도움이됨&lt;/li>
&lt;li>좋은 운용성이란 시스템의 건강 상태를 잘 관찰할 수 있고 시스템을 효율적으로 관리하는 방법을 보유한다는 의미&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>애플리케이션을 신뢰할 수 있고 확장 가능하며 유지보수하기 쉽게 만들어주는 간단한 해결책은 없다.&lt;/p>
&lt;p>하지만 여러 애플리케이션에서 계속 재현되는 특정 패턴과 기술이 있으며, 데이터 시스템 몇 가지를 예제로 살펴보고 이런 목표를 향해 데이터 시스템이 어떻게 작동하는지 분석한다.&lt;/p></description></item><item><title>아키텍처 관점에서 ORM을 사용하는 이유</title><link>https://codemario318.github.io/post/common/architect-orm/</link><pubDate>Sat, 02 Nov 2024 10:11:49 +0900</pubDate><guid>https://codemario318.github.io/post/common/architect-orm/</guid><description>&lt;img src="https://codemario318.github.io/post/common/architect-orm/cover.png" alt="Featured image of post 아키텍처 관점에서 ORM을 사용하는 이유" />&lt;p>안녕하세요😁 오늘은 제가 생각하는 &lt;strong>ORM&lt;/strong>(Object Relational Mapping)을 사용하는 이유에 대한 개인적인 생각을 써보려고 합니다.&lt;/p>
&lt;p>저는 현재 부스트캠프 웹 풀스택 9기 멤버십 과정에 참여중인데, 피어 세션이라던가 스터디 그룹에서 다른 분들과 ORM에 대한 이야기를 할 일이 많았어요&lt;/p>
&lt;p>이야기 나눴던 분들이 말하는 ORM은 아래와 같은 내용이 대부분이었습니다.&lt;/p>
&lt;ul>
&lt;li>ORM은 쿼리 빌더처럼 직접 SQL을 사용하지 않고도 쿼리를 작성해주는 도구이다.&lt;/li>
&lt;li>RDB 테이블을 객체 지향적으로 사용할 수 있게 만들어주는 도구이다.&lt;/li>
&lt;li>일관된 구조를 활용하기 때문에 유지보수가 편리해진다.&lt;/li>
&lt;/ul>
&lt;p>위 처럼 제가 이야기나눴던 분들은 대부분 편의성에 초점을 맞추시는 것 같았어요&lt;/p>
&lt;hr>
&lt;p>조금 깔끔하게 정리해보면 &lt;strong>ORM은 RDB 테이블에 저장된 데이터 조회하여 주요 관심사 단위인 엔티티 객체로 만들기 위해 사용&lt;/strong>됩니다.&lt;/p>
&lt;p>다른 분들이 말씀해주셨던 내용 모두 맞는 말 입니다. 그런데 위에서 언급했던 장점들이 ORM을 사용하는 &lt;strong>본질적인 이유&lt;/strong>일까요?&lt;/p>
&lt;p>이는 사실 ORM을 사용했을 때 &lt;strong>부가적으로 따라오는 장점&lt;/strong>이며 저는 조금 더 근본적인 이유가 바로 &lt;strong>아키텍처&lt;/strong>에 있다고 생각합니다.&lt;/p>
&lt;h2 id="rdbms와-아키텍처">RDBMS와 아키텍처&lt;/h2>
&lt;p>먼저 관계형 데이터베이스가 소프트웨어 아키텍처에 어떤 영향을 주는지 살펴보면 좋을 것 같아요&lt;/p>
&lt;p>아직까지도 관계형 데이터베이스는 웹서비스에서 가장 많이 활용되는 기술입니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/common/architect-orm/img_2.png"
width="866"
height="650"
srcset="https://codemario318.github.io/post/common/architect-orm/img_2_huc333306ede2f54d49d5eff7dc126e0c7_92178_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/common/architect-orm/img_2_huc333306ede2f54d49d5eff7dc126e0c7_92178_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="319px"
>&lt;img src="https://codemario318.github.io/post/common/architect-orm/img_3.png"
width="213"
height="237"
srcset="https://codemario318.github.io/post/common/architect-orm/img_3_hu875005b2d960dbb09b53d1a8c10ff308_9502_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/common/architect-orm/img_3_hu875005b2d960dbb09b53d1a8c10ff308_9502_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="PostgreSQL"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="215px"
>&lt;/p>
&lt;p>관계형 데이터베이스는 데이터를 표(table) 형식으로 구성하여 저장하고, 연관된 데이터는 각 테이블의 관계를 통해 관리할 수 있죠&lt;/p>
&lt;hr>
&lt;p>책 &lt;strong>클린 아키텍처&lt;/strong>에서는 소프트웨어 아키텍처는 세부사항에 의존하면 유연하지 못한 아키텍처가 된다는 것을 항상 강조하고 있습니다.&lt;/p>
&lt;p>&lt;strong>데이터베이스는 세부사항이다&lt;/strong> 단락을 보면 아래와 같은 내용들이 언급됩니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>아키텍처 관점에서 볼 때 &lt;strong>데이터베이스는 엔티티&lt;/strong>가 아니다.&lt;/em>&lt;br>
&lt;em>데이터 모델과는 달리 아키텍처 관점에서는 데이터베이스는 세부사항이라 &lt;strong>아키텍처의 구성 요소 수준으로 끌어올릴 수 없다&lt;/strong>.&lt;/em>&lt;br>
&lt;em>데이터베이스는 &lt;strong>소프트웨어&lt;/strong>일 뿐이며, &lt;strong>데이터에 접근할 방법을 제공하는 유틸리티&lt;/strong>다.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>그리고 아키텍처 관점의 &lt;strong>컴포넌트&lt;/strong>에 대해 중요하게 언급하는데요, &lt;strong>아키텍처 관점의 컴포넌트&lt;/strong>를 설명한다면 아래와 같습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>컴포넌트는 &lt;strong>시스템의 구성 요소로 배포할 수 있는 가장 작은 단위&lt;/strong>다.&lt;/em>&lt;br>
&lt;em>&amp;lt;중략&amp;hellip;&amp;gt;&lt;/em>&lt;br>
&lt;em>컴포넌트가 마지막에 어떤 형태로 배포되든, &lt;strong>잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야한다&lt;/strong>.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>이러한 이유 때문에 &lt;strong>Spring&lt;/strong> 같은 경우는 데이터 저장소에 대한 일관된 처리 추상화한 &lt;code>Spring Data&lt;/code>를 제공합니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이제 위에서 언급한 클린 아키텍처에서 언급했던 컴포넌트 그리고 세부사항을 중심으로 관계형 데이터베이스의 활용을 다시 생각해볼게요&lt;/p>
&lt;p>관계형 데이터베이스에서 외래키로 표현되는 &lt;strong>의존 관계&lt;/strong>는 각 데이터베이스 수준에서 &lt;strong>엔티티간 결합&lt;/strong>이 발생한다는 것을 의미합니다.&lt;/p>
&lt;p>이 때문에 아키텍처 관점에서 &lt;strong>데이터베이스를 사용한다는 것 자체&lt;/strong>와 &lt;strong>엔티티를 기준으로 분리될 수 있는 컴포넌트의 결합&lt;/strong>이 문제가 될 수 있습니다.&lt;/p>
&lt;h2 id="고전적인-처리-방식">고전적인 처리 방식&lt;/h2>
&lt;p>일단 ORM을 활용하지 않는 RDB를 사용하던 방식을 확인해보면 도움이 될 것 같아요&lt;/p>
&lt;p>이전에는 물리적인 제한으로 인해 발생하는 지연(네트워크 오버헤드 등)과 고전적인 SSR 같은 이유로 &lt;strong>페이지&lt;/strong>나 &lt;strong>API 엔드포인트&lt;/strong> 별로 하나의 큰 쿼리(한방 쿼리 라고도 한다고 하네요)를 사용하는 것이 정석이었습니다.&lt;/p>
&lt;p>게시글, 댓글을 예시로 확인해볼까요?&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
User {
int user_id PK
string user_name
}
Post {
int post_id PK
int user_id FK
string post_title
string post_content
}
Reply {
int reply_id PK
int user_id FK
int post_id FK
string reply_content
}
User ||--o{ Post : ""
User ||--o{ Reply : ""
Post ||--o{ Reply : ""
&lt;/pre>
&lt;p>위 테이블 구조에서 고전적인 SSR을 이용하여 게시글 상세 정보를 보여주는 페이지를 렌더링해야 한다고 가정해보겠습니다.&lt;/p>
&lt;ul>
&lt;li>게시글 정보&lt;/li>
&lt;li>게시글 작성자 정보&lt;/li>
&lt;li>댓글 정보&lt;/li>
&lt;li>댓글 작성자 정보&lt;/li>
&lt;li>게시글에 달린 댓글 수&lt;/li>
&lt;li>댓글 페이지네이션&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_title&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_content&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">post_author&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COUNT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply_count&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_content&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply_author&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">post&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">LEFT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">LEFT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="k">limit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">OFFSET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="k">offset&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>아마 위와 같은 쿼리로 모든 데이터를 조회한 후 서비스 로직에서의 처리를 통해 HTML을 그려줬을거에요&lt;/p>
&lt;p>만약 쿼리를 나누고 싶다던가, &lt;code>Ajax&lt;/code>로 댓글 정보만 별도로 불러온다면 &lt;code>reply&lt;/code> 테이블에 대한 조회를 분리할 수 있을겁니다. 아래처럼요!&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_title&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_content&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">author&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">post&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COUNT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply_count&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_content&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply_author&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">reply&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ru&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">post_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reply_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="k">limit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">OFFSET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="k">offset&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위 예시는 간단한 편 이지만, 실제 운영되는 서비스는 복잡하고 연관된 데이터가 훨씬 많기 때문에 많은 수의 테이블을 &lt;code>JOIN&lt;/code> 해야할 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>이처럼 이전에는 서버와 데이터베이스간 통신 오버헤드, 서버의 응답 처리 방식, 분산 처리의 여러움(하드웨어 비용, 기술 부재) 등으로 인해 쿼리를 작게 나눠 조회하는 것 보다 한번에 조회하는 방식이 성능을 위해 더 좋은 방식으로 여겨졌습니다.&lt;/p>
&lt;p>한번에 조회해야 할 단위가 클라이언트에게 응답해야 할 데이터 전체이므로, 쿼리 자체도 제공해야할 뷰나 API 응답 결과에 종속적이 된다는 문제도 있었어요&lt;/p>
&lt;p>위와 같은 고전적인 방식을 활용할 때, 테이블에 저장되는 데이터가 너무 커져서 데이터베이스를 분리하고 싶다던가, NoSQL로 마이그레이션 하고 싶다던가, &lt;code>MSA&lt;/code>로 변경하여 각각을 독립적으로 운영해야한다면 어떤 문제가 있을까요?&lt;/p>
&lt;p>매우 귀찮고 복잡한 일 이므로, 서비스의 규모가 크다면 작업을 시작하기도 어려울겁니다🥲&lt;/p>
&lt;h2 id="처리-방식의-변화">처리 방식의 변화&lt;/h2>
&lt;p>시간이 흐르면서 하드웨어, 소프트웨어의 발전과 비용 감소 등 여러 이유로 &lt;strong>수평 확장&lt;/strong>이 쉬워지게 되었어요&lt;/p>
&lt;p>필요에 따라 서버를 많이 배포하는 것이 어려운 일이 아니게되었고, 데이터베이스도 많은 수의 &lt;code>Read Replica&lt;/code>를 확보해서 &lt;strong>조회 요청&lt;/strong>에 대한 트래픽에 비교적 쉽게 대응할 수 있게 되었습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/common/architect-orm/img_4.png"
width="640"
height="603"
srcset="https://codemario318.github.io/post/common/architect-orm/img_4_hu22a297eba345d3df949b53c8e2b3a027_170554_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/common/architect-orm/img_4_hu22a297eba345d3df949b53c8e2b3a027_170554_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Scale Out"
class="gallery-image"
data-flex-grow="106"
data-flex-basis="254px"
>&lt;/p>
&lt;p>이러한 이유로 위에서 살짝 보여드린 것 처럼 &lt;strong>커다란 쿼리를 작게 나누는 것&lt;/strong>이 성능 향상에 더 유리하다고 여겨지게 되었어요 &lt;del>쿼리 튜닝도 훨씬 쉬워집니다&lt;/del>&lt;/p>
&lt;p>이전과 달리 다뤄야하는 데이터의 범위와 크기도 작아졌기 때문에 &lt;strong>객체지향적으로 데이터를 관리&lt;/strong>하는 것이 비교적 용이해졌고, 비즈니스 요구사항들을 처리하기 위해 &lt;strong>엔티티 중심으로 설계&lt;/strong>하는 것이 적극적으로 고려되었습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/common/architect-orm/img.png"
width="1000"
height="1432"
srcset="https://codemario318.github.io/post/common/architect-orm/img_hufca2fe698ad69cd2a61645fa2aa0686a_2740195_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/common/architect-orm/img_hufca2fe698ad69cd2a61645fa2aa0686a_2740195_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="엔티티"
class="gallery-image"
data-flex-grow="69"
data-flex-basis="167px"
>&lt;/p>
&lt;p>소프트웨어 아키텍처에서 &lt;strong>엔티티&lt;/strong>(Entity)는 도메인 모델의 핵심 구성 요소로, 시스템이 다루는 중요한 개체 혹은 개념이에요&lt;/p>
&lt;p>조금 더 설명하면 시스템의 도메인에서 고유한 속성과 행동을 가진 데이터 단위로서, 시스템의 주체가되고 주요 비즈니스 로직의 기본 단위입니다.&lt;/p>
&lt;p>앞에서 언급했던 &lt;strong>아키텍처 관점의 컴포넌트&lt;/strong>의 단위가 될 수도 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/common/architect-orm/img_1.png"
width="940"
height="909"
srcset="https://codemario318.github.io/post/common/architect-orm/img_1_hu9b47f7a709a7aa24fdf2e6ddd0a86654_52592_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/common/architect-orm/img_1_hu9b47f7a709a7aa24fdf2e6ddd0a86654_52592_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="레이어드 아키텍처"
class="gallery-image"
data-flex-grow="103"
data-flex-basis="248px"
>&lt;/p>
&lt;p>위 그림은 레이어드 아키텍처의 데이터 흐름을 표현한 것 인데, &lt;code>Business Layer&lt;/code>에서 특정 &lt;strong>비즈니스 로직을 처리하기 위한 주요 속성을 묶은 단위&lt;/strong>(객체 등)를 &lt;strong>엔티티&lt;/strong>라고 표현할 수 있어요&lt;/p>
&lt;h2 id="orm과-아키텍처의-관계">ORM과 아키텍처의 관계&lt;/h2>
&lt;p>여기까지 쓰고나니 조금 돌아온 기분이 드는군요🤣 그래서 ORM과 아키텍처가 무슨 관계냐?!&lt;/p>
&lt;p>위에서 언급했던 내용을 다시 살펴보면 &lt;strong>ORM은 RDB의 데이터를 조회하여 엔티티 객체로 만들어주는 역할&lt;/strong>을 수행하게 되어요&lt;/p>
&lt;p>이 때문에 ORM을 사용하기 위해 &lt;strong>엔티티를 분리&lt;/strong>해야하고, 이는 &lt;strong>관심사에 대한 수직 분해&lt;/strong>가 되었다는 의미이기도 합니다.&lt;/p>
&lt;p>또한 관계형 데이터베이스를 사용한다는 사실은 변하지 않았지만 설정 값으로 특정 데이터베이스를 선택할 수 있는 기능을 제공하므로 어느정도 &lt;strong>수평 분해를 위한 추상화가 되었다&lt;/strong>고 볼 수 있어요&lt;/p>
&lt;p>여기해 더해 레이어드 아키텍처의 예시에서 &lt;code>Persistence Layer&lt;/code> 역할을 하는 계층을 분리했다면, &lt;strong>인터페이스&lt;/strong> 등을 통해 &lt;strong>의존성 역전&lt;/strong>을 활용하여 완전히 다른 유형의 데이터베이스(또는 API 응답)에 대해 거의 완전하게 관심사 분리가 가능해집니다.&lt;/p>
&lt;h2 id="연관-관계-분리">연관 관계 분리&lt;/h2>
&lt;p>연관 관계가 있는 테이블들도 마찬가지로 ORM을 사용하여 관계를 관리해주기 위해 별도 엔티티로 분리해줘야합니다.&lt;/p>
&lt;p>그렇기 때문에 자연스럽게 비즈니스 로직에서의 결합이 낮아지게 되어요&lt;/p>
&lt;p>따라서 완전히 다른 데이터 주체로 변경된다고 하더라도 연관 관계에 있는 엔티티에 변경 내역이 비교적 적어질 것을 기대할 수 있습니다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>그래서 제가 하고싶었던 말을 정리해보면 아래와 같습니다.&lt;/p>
&lt;ul>
&lt;li>ORM을 사용하기 위해서는 비즈니스의 주요 관심사인 엔티티에 대한 분리가 전제되어야한다.&lt;/li>
&lt;li>데이터를 조회 계층 분리를 통해 추상화를 쉽게 적용할 수 있고, 이를 통해 조회 주체에 대한 의존성이 없어진다.&lt;/li>
&lt;li>그러한 이유로 독립적으로 배포 가능한 단위인 아키텍처 관점의 컴포넌트로 분리된다.&lt;/li>
&lt;li>ORM 방식도 여러 문제가 있지만 아키텍처 관점에서 장점이 있기 때문에 계속해서 활용되고 있는 것 같다.&lt;/li>
&lt;/ul>
&lt;p>사실 ORM을 사용해서라기보다는 &lt;strong>&amp;ldquo;좋은 아키텍처를 만들기 위해 개별 배포 가능한 컴포넌트로 관심사를 분리가 필요한데, ORM이 이러한 방향을 추구하고 있고, 어느정도 강제하고 있기 때문에 자연스럽게 좋은 아키텍처를 만든다.&amp;rdquo;&lt;/strong> 가 이 글의 결론이겠네요&lt;/p>
&lt;p>추가로 &lt;strong>&amp;ldquo;ORM 라이브러리는 이러한 아키텍처를 지원하기 위해 사용되는 도구일 뿐이다.&amp;rdquo;&lt;/strong>, &lt;strong>&amp;ldquo;ORM을 사용하지 않더라도(직접 구현하더라도) 관심사를 잘 분리할 수 있는 구조를 만들어야 한다.&amp;rdquo;&lt;/strong> 라는 걸 말씀 드리고 싶었습니다.&lt;/p>
&lt;p>다 쓰고 보니 정말 많이 돌아왔네요&amp;hellip; 쓴게 아까워서 지우진 않겠습니다🤣&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다.&lt;/p></description></item><item><title>34. 빠져있는 장: By Simon Brown</title><link>https://codemario318.github.io/post/clean-architecture/34/</link><pubDate>Fri, 19 Apr 2024 15:59:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/34/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/cover.png" alt="Featured image of post 34. 빠져있는 장: By Simon Brown" />&lt;p>지금까지 읽은 모든 조언을 통해 올바르게 정의된 경계, 명확한 책임, 통제된 의존성을 가진 클래스와 컴포넌트로 구성된 좋은 소프트웨어를 설계할 수 있다.&lt;/p>
&lt;p>하지만 실제 적용에서는 &lt;strong>디테일&lt;/strong>(구현 세부사항)을 심사숙고하지 않는다면 마지막 고비에 걸려 넘어지기 십상이다.&lt;/p>
&lt;h2 id="계층-기반-패키지">계층 기반 패키지&lt;/h2>
&lt;p>가장 단순한 설계 방식으로 &lt;strong>전통적인 수평 계층형 아키텍처&lt;/strong>가 있다.&lt;/p>
&lt;p>&lt;strong>계층 기반 패키지&lt;/strong>라고도 불리는 이 방법은 기술적인 관점에서 해당 코드가 하는 일에 기반해 그 코드를 분할한다.&lt;/p>
&lt;p>이러한 전형적인 계층형 아키텍처에는 웹, 업무 규칙, 영속성 코드를 위해 계층이 각각 하나씩 존재한다.&lt;/p>
&lt;p>코드는 계층이라는 얇은 수평 조각으로 나뉘며, 각 계층은 유사한 종류의 것들을 묶는 도구로 사용된다.&lt;/p>
&lt;ul>
&lt;li>엄격한 계층형 아키텍처의 경우 계층은 반드시 바로 아래 계층에만 의존해야한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img.png"
width="635"
height="674"
srcset="https://codemario318.github.io/post/clean-architecture/34/img_hu09d1a64cd1e72f2d69d142c6a608bf93_75674_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img_hu09d1a64cd1e72f2d69d142c6a608bf93_75674_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="94"
data-flex-basis="226px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;code>OrdersController&lt;/code>
&lt;ul>
&lt;li>웹 컨트롤러이며, 웹 기반 요청을 처리한다.&lt;/li>
&lt;li>ex) Spring MVC 컨트롤러 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>OrdersService&lt;/code>
&lt;ul>
&lt;li>주문 관련 업무 규칙을 정의하는 인터페이스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>OrdersServiceImpl&lt;/code>
&lt;ul>
&lt;li>&lt;code>OrdersService&lt;/code>의 구현체&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>OrdersRepository&lt;/code>
&lt;ul>
&lt;li>영구 저장된 주문 정보에 접근하는 방법을 정의하는 인터페이스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>JdbcOrdersRepository&lt;/code>
&lt;ul>
&lt;li>&lt;code>OrdersRespository&lt;/code>의 구현체&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>마틴 파울러는 &lt;strong>프레젠테이션 도메인 데이터&lt;/strong> 계층화에서 처음 시작하기에는 계층형 아키텍처가 적합하다고 언급한다.&lt;/p>
&lt;ul>
&lt;li>엄청난 복잡함을 겪지 않고도 무언가를 작동시켜 주는 아주 빠른 방법이다.&lt;/li>
&lt;li>소프트웨어가 커지고 복잡해지기 시작하면 세 개의 계층으로만은 부족하다 느끼고 더 잘게 모듈화 해야할 필요성을 느낄 수 있다.&lt;/li>
&lt;li>업무 도메인에 대해 아무것도 말해주지 않는다.&lt;/li>
&lt;/ul>
&lt;h2 id="기능-기반-패키지">기능 기반 패키지&lt;/h2>
&lt;p>&lt;strong>기능 기반 패키지&lt;/strong> 구조는 서로 연관된 기능, 도메인 개념, (도메인 주도 설계 용어를 자주 사용한다면) Aggregate Root에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img2.png"
width="627"
height="670"
srcset="https://codemario318.github.io/post/clean-architecture/34/img2_hub33c374a47ec3a9ae590abdd19e1dc17_60523_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img2_hub33c374a47ec3a9ae590abdd19e1dc17_60523_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="93"
data-flex-basis="224px"
>&lt;/p>
&lt;p>인터페이스와 클래스는 이전과 같지만, 모두가 단 하나의 패키지에 속하게 된다.&lt;/p>
&lt;ul>
&lt;li>이는 &lt;strong>계층 기반 패키지&lt;/strong>를 아주 간단히 리팩터링한 형태지만 코드의 상위 수준 구조가 업무 도메인에 대해 무언가를 알려주게된다.&lt;/li>
&lt;li>유스케이스가 변경될 경우 변경해야 할 코드를 모두 찾는 작업이 더 쉬워질 수 있다.&lt;/li>
&lt;/ul>
&lt;p>소프트웨어 개발팀이 수평적 계층화의 문제를 깨닫고, 수직적 계층화로 전환하는 경우가 많지만, 두 접근법 모두 차선책이다.&lt;/p>
&lt;h2 id="포트와-어댑터">포트와 어댑터&lt;/h2>
&lt;p>포트와 어댑터(Ports and Adapters) 혹은 육각형 아키텍처(Hexagonal Architecture), 경계, 컨트롤러, 엔티티(BCE) 등의 방식으로 접근하는 이유는 업무/도메인에 초점을 둔 코드가 프레임워크나 데이터베이스 같은 기술적인 세부 구현과 독립적이며 분리된 아키텍처를 만들기 위해서다.&lt;/p>
&lt;p>그런 코드 베이스는 **내부(도메인)**와 **외부(인프라)**로 구성됨을 흔히 볼 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img3.png"
width="633"
height="485"
srcset="https://codemario318.github.io/post/clean-architecture/34/img3_hub97e2c2908d969078290a6c0afd4246d_67211_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img3_hub97e2c2908d969078290a6c0afd4246d_67211_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="130"
data-flex-basis="313px"
>&lt;/p>
&lt;ul>
&lt;li>내부 영역
&lt;ul>
&lt;li>도메인 개념을 모두 포함한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>외부 영역
&lt;ul>
&lt;li>외부 세계(UI, DB, 서드파티 통합)와의 상호작용을 포함한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>외부가 내부에 의존하며, 절대 그 반대로는 안된다.&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img4.png"
width="632"
height="669"
srcset="https://codemario318.github.io/post/clean-architecture/34/img4_hu067ed2819602a97a65ad3f6557f29a26_73442_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img4_hu067ed2819602a97a65ad3f6557f29a26_73442_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="94"
data-flex-basis="226px"
>&lt;/p>
&lt;p>위 구조에서 &lt;code>com.mycompany.myapp.domain&lt;/code> 패키지가 내부이며, 나머지 패키지는 모두 외부이다.&lt;/p>
&lt;p>&lt;code>OrdersRepository&lt;/code>가 &lt;code>Orders&lt;/code>라는 간단한 이름으로 바뀌었는데, 이는 도메인 주도 설계라는 세계관에서 비롯된 명명법으로, &lt;strong>내부&lt;/strong>에 존재하는 모든 것의 이름은 반드시 &lt;strong>유비쿼터스 도메인 언어&lt;/strong>관점에서 기술하라고 조언한다.&lt;/p>
&lt;ul>
&lt;li>도메인에 대하 논의할 때 &lt;strong>주문&lt;/strong>에 대해 말하는 것이지 &lt;strong>주문 리포지토리&lt;/strong>에 대해 말하는 것이 아니기 때문&lt;/li>
&lt;/ul>
&lt;h2 id="컴포넌트-기반-패키지">컴포넌트 기반 패키지&lt;/h2>
&lt;p>SOLID, REP, CCP, CRP 같은 이 책에 대다수의 조언은 당연히 중요하지만, 코드를 조직화하는 방법에 대해서는 &lt;strong>컴포넌트 기반 패키지&lt;/strong>같은 접근 방법을 적용해 볼 수 있다.&lt;/p>
&lt;p>&lt;strong>계층형 아키텍처의 단점&lt;/strong>&lt;/p>
&lt;p>계층형 아키텍처의 목적은 기능이 같은 코드끼리 서로 분리하는 것이다.&lt;/p>
&lt;p>구현 관점에서 보면 각 계층은 일반적으로 자바 패키지에 해당하며 서로 다른 패키지에 속한다. 따라서 코드의 접근성 관점에서 살펴보면 아래와 같은 문제가 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>OrdersController&lt;/code>가 &lt;code>OrdersService&lt;/code> 인터페이스에 의존하려면 &lt;code>OrdersService&lt;/code> 인터페이스는 반드시 &lt;code>public&lt;/code>으로 선언되어야 한다.&lt;/li>
&lt;li>&lt;code>OrdersRepository&lt;/code> 인터페이스도 &lt;code>public&lt;/code>이어야만 &lt;code>repository&lt;/code> 패키지 외부에 있는 &lt;code>OrdersServiceImpl&lt;/code> 클래스에 접근할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>엄격한 계층형 아키텍처에서 의존성 화살표는 항상 아래를 향해야 하므로, 깔끔한 비순환 의존성 그래프를 만들 수 있을 것이라 생각할 수 있지만, 실제로는 코드 베이스의 요소들이 서로를 의존할 때는 몇 가지 규칙을 반드시 지켜야한다.&lt;/p>
&lt;p>여기서 큰 문제는, 속임수를 써서 의존성을 의도치 않은 방식으로 추가하더라도 보기에는 여전히 좋은 비순환 의존성 그래프가 생성된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img_1.png"
width="629"
height="671"
srcset="https://codemario318.github.io/post/clean-architecture/34/img_1_hue2c4f507d4fc8ef9fe870f9d5a52a08a_68784_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img_1_hue2c4f507d4fc8ef9fe870f9d5a52a08a_68784_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="93"
data-flex-basis="224px"
>&lt;/p>
&lt;p>위 상황처럼 &lt;code>OrdersController&lt;/code>가 &lt;code>OrdersService&lt;/code>를 우회하여 직접 &lt;code>OrdersRepository&lt;/code>에 의존성을 가지게 하더라도 비순환 의존성 그래프가 만들어진다.&lt;/p>
&lt;p>이러한 조직화는 인접한 계층들을 건너 뛰는 일이 허용되기 때문에 &lt;strong>완화된 계층형 아키텍처&lt;/strong>라고 부르며, 이러한 방식은 CQRS(Command Query Responsibility Segregation) 패턴 같은 경우를 제외한다면 바람직하지 못하다.&lt;/p>
&lt;p>따라서 계층형 아키텍처는 이러한 우회를 강제할 수 있는 방법이 없기 때문에 아키텍처가 지켜지기 힘들어진다.&lt;/p>
&lt;p>&lt;strong>컴포넌트 기반 패키지&lt;/strong>&lt;/p>
&lt;p>반면 컴포넌트 기반 패키지는 컴파일러를 사용해서 아키텍처를 강제할 수 있다.&lt;/p>
&lt;p>컴포넌트 기반 패키지는 큰 단위(coarse-grained)의 단일 컴포넌트와 관련된 모든 책임을 하나의 자바 패키지로 묶는데 주안점을 둔다.&lt;/p>
&lt;p>이 접근법은 마이크로서비스 아키텍처가 가진 시각과 동일하게 서비스 중심적인 시각으로 소프트웨어 시스템을 바라볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>포트와 어댑터에서 웹을 그저 또 다른 전달 메커니즘으로 취급하는 것과 마찬가지로, 사용자 인터페이스를 큰 단위의 컴포넌트로부터 분리해서 유지한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img_2.png"
width="628"
height="668"
srcset="https://codemario318.github.io/post/clean-architecture/34/img_2_huade6c3c558bab5a248a2fc0978ef31a2_60168_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img_2_huade6c3c558bab5a248a2fc0978ef31a2_60168_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="94"
data-flex-basis="225px"
>&lt;/p>
&lt;p>컴포넌트 기반 패키지는 본질적으로 업무 로직과 영속성 관련 코드를 하나로 묶는데 이러한 단위를 컴포넌트라 부른다.&lt;/p>
&lt;blockquote>
&lt;p>지금까지 언급되었던 배포할 수 있는 가장 작은 단위라는 의미가 아닌 &lt;strong>깔끔한 인터페이스로 감싸진 연관된 기능들의 묶음&lt;/strong>을 의미한다.&lt;br>
스프트웨어 시스템의 전적 구조를 컨테이너, 컴포넌트, 클래스(코드) 측면에서 계층적으로 생각하는 방법(C4 소프트웨어 아키텍처 모델)&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>관련된 무언가를 코딩해야 할 때 &lt;code>**Component&lt;/code>만 둘러보면 된다.&lt;/li>
&lt;li>컴포넌트 내부에서 관심사 분리는 여전히 유효하다.&lt;/li>
&lt;li>따라서 업무 로직은 데이터 영속성과 분리된다.
&lt;ul>
&lt;li>컴포넌트 구현과 관련된 세부사항으로, 사용자는 알 필요가 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>모노리틱 애플리케이션에서 컴포넌트를 잘 정의하면 마이크로서비스 아키텍처로 가기 위한 발판으로 삼을 수 있다.&lt;/p>
&lt;h2 id="구현-세부사항엔-항상-문제가-있다">구현 세부사항엔 항상 문제가 있다.&lt;/h2>
&lt;p>언급한 네 가지 접근법이 코드를 조직하하는 것으로 보이지만 세부사항을 잘못 구현하면 이러한 견해도 아주 빠르게 흐트러지기 시작한다.&lt;/p>
&lt;ul>
&lt;li>모든 타입에서 &lt;strong>public&lt;/strong> 지시자를 사용한다는 것 제공하는 캡슐화 이점을 활용하지 않겠다는 뜻이며, 이로인해 지향아는 아키텍처 스타일을 위반하게 될 것이다.&lt;/li>
&lt;/ul>
&lt;h3 id="조직화-vs-캡슐화">조직화 VS 캡슐화&lt;/h3>
&lt;p>자바 애플리케이션에서 모든 타입을 &lt;code>public&lt;/code>으로 지정한다면 패키지는 단순히 조직화를 위한 매커니즘(폴더와 같은 역할만)으로 전락하여 캠슐화를 위한 메커니즘이 될 수 없다.&lt;/p>
&lt;ul>
&lt;li>코드 베이스를 어디서도 사용할 수 있다면 패키지를 사용하는 데 따른 이점이 거의 없다.&lt;/li>
&lt;li>패키지를 무시해 버리면 캡슐화나 은닉에 아무런 도움이 없으므로 최종적으로 어떤 아키텍처 스타일로 만들려고 하는지는 아무런 의미가 없어진다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img_3.png"
width="630"
height="446"
srcset="https://codemario318.github.io/post/clean-architecture/34/img_3_hubd3840a39404a726edb0ac1a8a8a458d_77645_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img_3_hubd3840a39404a726edb0ac1a8a8a458d_77645_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="339px"
>&lt;/p>
&lt;p>모든 타입을 &lt;code>public&lt;/code>으로 선언한다면 실제로 갖게 되는 것은 수평적 계층형 아키텍처를 표현하는 방법에 불과해진다.&lt;/p>
&lt;hr>
&lt;p>접근 지시자를 적절하게 사용하면, 타입을 패키지로 배치하는 방식에 다라서 각 타입에 접근할 수 있는 정도가 실제로 크게 달라질 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/34/img_4.png"
width="631"
height="487"
srcset="https://codemario318.github.io/post/clean-architecture/34/img_4_hub59749830694f830b27427b6082c0095_105897_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/34/img_4_hub59749830694f830b27427b6082c0095_105897_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="129"
data-flex-basis="310px"
>&lt;/p>
&lt;ol>
&lt;li>계층 기반 패키지 접근법
&lt;ul>
&lt;li>&lt;code>OrdersService&lt;/code>, &lt;code>OrdersRepository&lt;/code> 인터페이스는 외부 패키지의 클래스로부터 자신이 속한 패키지 내부로 들어오는 의존성으로 &lt;code>public&lt;/code> 으로 선언되어야하지만, 구체 클래스는 누구도 알 필요가 없는 구현 세부사항이므로 &lt;code>protected&lt;/code>로 선언할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>기능 기반 패키지 접근법
&lt;ul>
&lt;li>&lt;code>OrdersController&lt;/code>가 패키지로 들어올 수 있는 유일한 통로를 제공하므로 나머지 패키지는 &lt;code>protected&lt;/code>로 지정할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>포트와 어댑터 접근법
&lt;ul>
&lt;li>&lt;code>OrdersService&lt;/code>와 &lt;code>Orders&lt;/code> 인터페이스는 외부로부터 들어오는 의존성을 가지므로 &lt;code>public&lt;/code>으로 지정해야한다.&lt;/li>
&lt;li>구현 클래스 패키지는 &lt;code>protected&lt;/code>로 지정하며, 런타임에 의존성을 주입할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>컴포넌트 기반 패키지
&lt;ul>
&lt;li>컨트롤러에서 &lt;code>OrdersComponent&lt;/code> 인터페이스로 향하는 의존성을 가지며, 그 외의 모든 것은 패키지 &lt;code>protected&lt;/code>로 지정할 수 있다.&lt;/li>
&lt;li>패키지 외부의 코드에서는 &lt;code>OrdersRepository&lt;/code> 인터페이스나 구현체를 직접 사용할 수 있는 방법이 전혀 없으므로 컴파일러를 통해 아키텍처를 강제할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>아키텍처 원칙을 강제할 때 컴파일러의 도움을 받아 그렇게 할 수 밖에 없도록 만들어야 한다.&lt;/p>
&lt;p>모든 코드가 하나의 소스 코드 트리로 존재하는 모노리틱 애플리케이션이라면 큰 도움이 될 것이다.&lt;/p>
&lt;h2 id="다른-결합-분리-모드">다른 결합 분리 모드&lt;/h2>
&lt;p>프로그래밍 언어가 제공하는 방법 외에도 소스 코드 의존성을 분리하는 방법은 존재할 수 있다.&lt;/p>
&lt;ul>
&lt;li>모듈 시스템(ex. 자바 OSGI)&lt;/li>
&lt;li>소스코드 수준에서 의존성을 분리하는 방법
&lt;ul>
&lt;li>&lt;strong>서로 다른 소스 코드 트리로 분리하는 방법&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="결론-빠져있는-조언">결론: 빠져있는 조언&lt;/h2>
&lt;p>최적의 설계를 꾀했더라도, 구현 전략에 얽힌 복잡함을 고려하지 않으면 설계가 순식간에 망가질 수도 있다.&lt;/p>
&lt;ul>
&lt;li>설계를 어떻게 해야만 원하는 코드 구조로 매핑할 수 있을지&lt;/li>
&lt;li>코드를 어떻게 조직화 할지&lt;/li>
&lt;li>런타임과 컴파일타입에 어떤 결합 분리 모드를 적용할지&lt;/li>
&lt;/ul>
&lt;p>위와 같은 내용을 고민해야하며, 선택사항을 열어두되 실용주의적으로 행해야한다.&lt;/p>
&lt;ul>
&lt;li>팀의 규모, 기술 수준, 해결책의 복잡성을 일정과 예산이라는 제약과 동시에 고려해야한다.&lt;/li>
&lt;li>선택된 아키텍처 스타일을 강제하는 데 컴파일러의 도움을 받을 수 있을지 고민해야한다.&lt;/li>
&lt;li>데이터 모델과 같은 다른 영역에 결합되지 않도록 주의해야한다.&lt;/li>
&lt;/ul>
&lt;p>구현 세부사항에는 항상 문제가 있는 법이다.&lt;/p></description></item><item><title>33. 사례연구: 비디오 판매</title><link>https://codemario318.github.io/post/clean-architecture/33/</link><pubDate>Fri, 19 Apr 2024 15:27:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/33/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/33/cover.png" alt="Featured image of post 33. 사례연구: 비디오 판매" />&lt;p>짧고 단순한 사례를 통해 뛰어난 아키텍트가 일을 처리하는 과정과 결정을 내리는 모습을 살펴보자.&lt;/p>
&lt;h2 id="제품-비디오-판매-웹-서비스">제품: 비디오 판매 웹 서비스&lt;/h2>
&lt;ul>
&lt;li>판매하길 원하는 비디오들이 있고, 개인과 기업에게 웹을 통해 판매한다.&lt;/li>
&lt;li>개인은 단품 가격을 지불해 스트리밍으로 본다.&lt;/li>
&lt;li>개인은 더 높은 가격을 지불하여 비디오를 다운로드해서 영구 소장할 수 있다.&lt;/li>
&lt;li>기업용 라이선스는 스트리밍 전용이다.&lt;/li>
&lt;li>기업용 라이선스로 대량 구매시 할인을 받을 수 있다.&lt;/li>
&lt;li>개인은 시청자인 동시에 구매자&lt;/li>
&lt;li>기업은 다른 사람들이 시청할 비디오를 구매하는 사람이 따로 있다.&lt;/li>
&lt;li>비디오 제작자는 비디오 파일과 설명서, 부속 파일(시험, 문제, 해법, 소스 코드 등)을 제공한다.&lt;/li>
&lt;li>관리자는 신규 비디오 시리즈물을 추가한다.&lt;/li>
&lt;li>관리자는 기존 시리즈물에 비디오를 추가 도는 삭제한다.&lt;/li>
&lt;li>관리자는 다양한 라이선스에 맞춰 가격을 책정한다.&lt;/li>
&lt;/ul>
&lt;h2 id="유스케이스-분석">유스케이스 분석&lt;/h2>
&lt;p>주요 액터는 구매자, 시청자, 제작자, 관리자 네 가지이다.&lt;/p>
&lt;p>단일 책임 원칙에 따라 네 액터가 시스템이 변경되어야 할 네 가지 주요 근원이 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/33/img.png"
width="709"
height="700"
srcset="https://codemario318.github.io/post/clean-architecture/33/img_huc3fc667673246b20a35a0a0b5773b4d6_306180_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/33/img_huc3fc667673246b20a35a0a0b5773b4d6_306180_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="101"
data-flex-basis="243px"
>&lt;/p>
&lt;p>신규 기능 추가나, 기존 기능 변경의 이유는 액터 중 하나에게 해당 기능을 제공하기 위함이므로, 시스템을 분할하여 특정 액터를 위한 변경이 나머지 액터에게는 전혀 영향을 미치지 않게 만들어야한다.&lt;/p>
&lt;p>중앙 점선으로 된 유스케이스는 추상 유스케이스이다.&lt;/p>
&lt;p>추상 유스케이스는 범용적인 정책을 담고 있으며, 다른 유스케이스에서 이를 더 구체화한다.&lt;/p>
&lt;p>시청자 입장에서 카탈로그 조회하기와 구매자 입장에서 카탈로그 조회하기 유스케이스는 모두 카탈로그 조회하기라는 추상 유스케이스를 상속받는다.&lt;/p>
&lt;ul>
&lt;li>이 추상 유스케이스를 다이어그램에서 없애더라도 전체 제품의 기능을 조금도 손상시키지 않지만, 이들 두 유스케이스는 너무 비슷하기 때문에, 유사성을 식별하여 분석 초기에 통합하는 방법을 찾는 방법이 더 현명하다고 판단하였다.&lt;/li>
&lt;/ul>
&lt;h2 id="컴포넌트-아키텍처">컴포넌트 아키텍처&lt;/h2>
&lt;p>액터와 유스케이스를 식별했으므로, 예비 단계의 컴포넌트 아키텍처를 만들어 볼 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/33/img_1.png"
width="642"
height="478"
srcset="https://codemario318.github.io/post/clean-architecture/33/img_1_hue0ddbb544a7f722e559ab09d7f8f1c4f_121162_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/33/img_1_hue0ddbb544a7f722e559ab09d7f8f1c4f_121162_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="134"
data-flex-basis="322px"
>&lt;/p>
&lt;p>이중으로 된 선은 아키텍처 경계를 나타낸다.&lt;/p>
&lt;ul>
&lt;li>뷰 프레젠터, 인터랙터, 컨트롤러로 분리된 전형적이 분할 방법을 활용했다.&lt;/li>
&lt;li>대응하는 액터에 다라 카테고리를 분리했다.&lt;/li>
&lt;/ul>
&lt;p>특수한 컴포넌트인 &lt;code>Catalog View&lt;/code>와 &lt;code>Catalog Presenter&lt;/code>는 &lt;strong>카탈로그 조회하기&lt;/strong>라는 추상 유스케이스를 처리하는 방식으로 뷰와 프레젠터는 해당 컴포넌트 내부에 추상 클래스로 코드화될 것이며, 상속받는 컴포넌트에서는 이를 추상클래스로부터 상속받은 뷰와 프레젠터 클래스들을 포함한다.&lt;/p>
&lt;p>시스템을 이러한 컴포넌트들로 모두 분할한다면, 모든 컴포넌트를 분할해서 여러개의 &lt;code>.jar&lt;/code> 등 파일로 전달할 수도 있고 모두 한 파일로도 합칠 수 있다.&lt;/p>
&lt;p>이는 선택지를 열어두는 것이며, 선택지를 열어두면, 시스템이 변경되는 양상에 맞춰 시스템 배포 방식을 조정할 수 있다.&lt;/p>
&lt;h2 id="의존성-관리">의존성 관리&lt;/h2>
&lt;p>위 그림에서 제어흐름은 오른족에서 왼쪽으로 이동한다.&lt;/p>
&lt;ol>
&lt;li>입력이 컨트롤러에서 발생&lt;/li>
&lt;li>인터렉터에 의해 처리되어 결과가 만들어짐&lt;/li>
&lt;li>프레젠터가 결과의 포멧을 변경&lt;/li>
&lt;li>뷰가 화면에 표시&lt;/li>
&lt;/ol>
&lt;p>대부분의 화살표가 왼쪽에서 오른쪽으로 향하는데, 이는 아키텍처가 의존성 규칙을 준수하기 때문이다.&lt;/p>
&lt;p>모든 의존성은 경계선을 한 방향으로만 즉, 항상 더 높은 수준의 정책을 포함하는 컴포넌트로 향해야한다.&lt;/p>
&lt;p>사용 관계(열린 화살표)는 제어흐름과 같은 방향을 가리키며, 상속 관계(닫힌 화살표)는 제어흐름과는 반대 방향을 가르키는데, 이는 개방 폐쇄 원칙을 적용했음을 보여준다.&lt;/p>
&lt;p>이를 통해 의존성이 올바른 방향으로 흐르며, 저수준의 세부사항에서 발생한 변경이 상위로 파급되어 상위 수준의 정책에 영향을 미치지는 않음을 보장할 수 있다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>그림으로 확인할 수 있는 단일 책임 원칙에 기반한 액터의 분리와 의존성 규칙 모두 서로 다른 이유로, 서로 다른 속도로 변경되는 컴포넌트를 분리하는 데 그 목적이 있다.&lt;/p>
&lt;ul>
&lt;li>서로 다른 이유라는 것은 액터와 관련이 있다.&lt;/li>
&lt;li>서로 다른 속도라는 것은 정책 수준과 관련이 있다.&lt;/li>
&lt;/ul>
&lt;p>이러한 방식으로 코드를 한번 구조화하고 나면 시스템을 실제로 배포하는 방식은 다양하게 선택할 수 있게된다.&lt;/p></description></item><item><title>32. 프레임워크는 세부사항이다</title><link>https://codemario318.github.io/post/clean-architecture/32/</link><pubDate>Thu, 18 Apr 2024 19:42:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/32/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/32/cover.png" alt="Featured image of post 32. 프레임워크는 세부사항이다" />&lt;p>아무리 해도 프레임워크는 아키텍처가 될 수 없다.&lt;/p>
&lt;h2 id="프레임워크-제작자">프레임워크 제작자&lt;/h2>
&lt;p>프레임워크 제작자는 자신이 해결해야 할 고유한 문제를 위해 프레임워크를 제작한 것 이므로, 내가 풀려는 문제와 완벽하게 일치할수는 없다.&lt;/p>
&lt;h2 id="혼인-관계의-비대칭성">혼인 관계의 비대칭성&lt;/h2>
&lt;p>프레임워크 제작자와 사용자의 관계는 놀라울 정도로 비대칭 적이며 프레임워크 제작자는 당신에게 프레임워크와 혼인하기를 요구하는 것 처럼 보인다.&lt;/p>
&lt;p>프레임워크 제작자는 당신의 애플리케이션이 가능하면 프레임워크에 공고하게 결합될 것을 강하게 역설한다.&lt;/p>
&lt;p>이러한 결합은 제작자에게는 위험 요소가 되지 않으며, 프레임워크에대해 절대적인 제어권을 쥐고 있는 입장에서 오히려 프레임워크와 결합되기를 바란다.&lt;/p>
&lt;p>한술 더 떠 제작자는 사용자도 프레임워크에 결합되어 관계를 깨지 못하는 것을 기대하고 있다.&lt;/p>
&lt;p>제작자는 프레임워크에대해 장시간에 걸친 헌신을 요청하지만, 그에 상응하는 헌신을 받을수 는 없을 것이다.&lt;/p>
&lt;p>모든 위험과 부담은 당신이 감수할 뿐, 제작자가 감수하는 건 아무것도 없다.&lt;/p>
&lt;h2 id="위험요인">위험요인&lt;/h2>
&lt;p>&lt;strong>프레임워크의 아키텍처는 깔끔하지 않은 경우가 많다.&lt;/strong> &lt;br>
프레임워크는 의존성 규칙을 위반하는 경향이 있다.&lt;/p>
&lt;ul>
&lt;li>업무 객체를 만들 때 프레임워크 코드를 상속할 것을 요구한다.&lt;/li>
&lt;li>고유한 엔티티에 코드가 상속되면 애플리케이션의 가장 안쪽 원과 프레임워크의 결합이 발생한다.&lt;/li>
&lt;/ul>
&lt;p>프레임워크가 한번 원 안으로 들어가버리면 다시는 원 밖으로 나오지 않을 것이다.&lt;/p>
&lt;p>&lt;strong>결국 싸우게된다.&lt;/strong>&lt;/p>
&lt;p>프레임워크가 애플리케이션의 초기 기능을 만드는데 도움이 될 것이지만, 제품이 성숙해지면서 프레임워크가 제공하는 기능과 틀을 벗어나게 될 것이다.&lt;/p>
&lt;p>&lt;strong>앞으로의 변화&lt;/strong>&lt;/p>
&lt;p>프레임워크는 애플리케이션에게 도움되지 않는 방향으로 진화할 수도 있다.&lt;/p>
&lt;p>&lt;strong>더 나은 프레임워크&lt;/strong>&lt;/p>
&lt;p>새롭고 더 나은 프레임워크가 등장해서 갈아타고 싶을 수도 있다.&lt;/p>
&lt;h2 id="해결책">해결책&lt;/h2>
&lt;blockquote>
&lt;p>프레임워크와 결혼하지 말라!&lt;/p>
&lt;/blockquote>
&lt;p>프레임워크를 사용할 수는 있지만 결합해서는 안된다.&lt;/p>
&lt;p>프레임워크는 아키텍처의 바깥쪽 원에 속하는 세부사항으로 취급해야한다.&lt;/p>
&lt;p>업무 객체를 만들 때 프레임워크가 자신의 기반 클래스로부터 파생하기를 요구한다면, 프락시를 만들고, 업무 규칙에 플러그인할 수 있는 컴포넌트에 이 프락시를 위치시켜 프레임워크가 핵심 코드 안으로 들어오지 못하게 해야한다.&lt;/p>
&lt;p>대신 핵심 코드에 플러그인할 수 있는 컴포넌트에 프레임워크를 통합하고, 의존성 규칙을 준수한다.&lt;/p>
&lt;h2 id="이제-선언합니다">이제 선언합니다.&lt;/h2>
&lt;p>애플리케이션이 프레임워크와 결혼하고자 한다면 애플리케이션의 남은 생애 동안 그 프레임워크와 항상 함께 해야 한다는 사실을 반드시 명심해야한다.&lt;/p>
&lt;p>결코 가볍게 시작할 수 있는 관계가 아니다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>프레임워크와의 첫 만남부터 바로 결혼하려 들지 말라.&lt;/p>
&lt;p>가급적이면 프레임워크를 가능한 한 오랫동안 아키텍처 경계 너머에 두자.&lt;/p></description></item><item><title>31. 웹은 세부사항이다</title><link>https://codemario318.github.io/post/clean-architecture/31/</link><pubDate>Thu, 18 Apr 2024 19:07:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/31/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/31/cover.png" alt="Featured image of post 31. 웹은 세부사항이다" />&lt;h2 id="끝없이-반복하는-추">끝없이 반복하는 추&lt;/h2>
&lt;p>1960년대 이래로 모든 연산 능력을 중앙 서버에 두는 방식과 모든 연산 능력을 단말에 두는 방식 사이의 일련의 반복되는 진동을 겪어왔으며 웹은 진동 끝 한 점에 있을 뿐이다.&lt;/p>
&lt;p>IT 역사 전체로 시야를 넓히면 웹은 아무것도 바꾸지 않았으며, 이러한 진동은 앞으로도 지속될것이다.&lt;/p>
&lt;p>따라서 아키텍트로서 이 진동은 핵심 업무 규칙의 중심에서 밀어내야하는 단기적인 문제일 뿐이다.&lt;/p>
&lt;p>이러한 진동은 GUI의 변경을 동반하며, 이러한 변경으로부터 애플리케이션을 보호하기 위해 GUI로부터 업무 규칙을 분리해야한다.&lt;/p>
&lt;h2 id="요약">요약&lt;/h2>
&lt;p>GUI는 세부사항이다. 웹은 입 출력 장치의 다른 모습이므로 GUI이며, 이러한 이유로 웹은 세부사항이다.&lt;/p>
&lt;p>따라서 아키텍트는 웹을 핵심 업무 로직에서 분리된 경계 바깥에 두어야한다.&lt;/p>
&lt;p>애플리케이션과 GUI의 상호작용은 빈번하고 방식도 사용중인 GUI 종류에 따라 차이가 크기 때문에 추상화하려는 시도는 성공할 가능성이 낮아 보인다.&lt;/p>
&lt;p>하지만 UI와 애플리케이션 사이에는 추상화가 가능한 또 다른 경계가 존재한다.&lt;/p>
&lt;ul>
&lt;li>업무 로직은 다수의 유스케이스로 구성되며, 각 유스케이스는 사용자를 대신해서 일부 함수를 수행하는 것을 볼 수 있다.&lt;/li>
&lt;li>각 유스케이스는 입력 데이터 수행할 처리 과정, 출력 데이터를 기반으로 기술할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>완전한 입력 데이터&lt;/strong>와 그에 따른 &lt;strong>출력 데이터&lt;/strong>는 데이터 구조로 만들어서 유스케이스를 실행하는 처리 과정의 입력 값과 출력 값으로 사용할 수 있기 때문에, &lt;strong>각 유스케이스가 장치 독립적인 방식으로 UI라는 입출력 장치를 동작시킨다&lt;/strong>고 간주할 수 있다.&lt;/p>
&lt;p>이러한 입력 데이터와 그에 따른 출력 데이터로 만들어지는 데이터 구조는 UI와 애플리케이션 사이의 경계를 넘나드는 수단이므로 추상화가 가능한 경계이다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>이러한 종류의 추상화는 만들기 쉽지 않고, 제대로 만들려면 수차례의 반복 과정을 거쳐야 할 것이다.&lt;/p>
&lt;p>하지만 이러한 추상화는 가능하며, 변경이 될 요소는 매우 많기 때문에 추상화는 꼭 필요하다.&lt;/p></description></item><item><title>30. 데이터베이스는 세부사항이다</title><link>https://codemario318.github.io/post/clean-architecture/30/</link><pubDate>Thu, 18 Apr 2024 16:19:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/30/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/30/cover.png" alt="Featured image of post 30. 데이터베이스는 세부사항이다" />&lt;p>아키텍처 관점에서 볼 때 데이터베이스는 엔티티가 아니다.&lt;/p>
&lt;p>데이터 모델과는 달리 아키텍처 관점에서는 데이터베이스는 세부사항이라서 아키텍처의 구성요소 수준으로 끌어올릴 수 없다.&lt;/p>
&lt;p>데이터베이스는 소프트웨어일 뿐이며, 데이터에 접근할 방법을 제공하는 유틸리티이다.&lt;/p>
&lt;p>유틸리티는 저수준 세부사항(메커니즘)일 뿐 아키텍처와는 관계 없으므로, 데이터베이스를 이용한다는 사실이 아키텍처에 영향을 주지 않아야한다.&lt;/p>
&lt;h2 id="관계형-데이터베이스">관계형 데이터베이스&lt;/h2>
&lt;p>관계형 테이블은 특정한 형식의 데이터에 접근하는 경우에 편리함을 제공하지만, 데이터를 테이블에 행 단위로 배치한다는 자체는 아키텍처적으로 볼 때 전혀 중요하지 않다.&lt;/p>
&lt;p>따라서 (관계형 데이터베이스에 저장된)데이터가 테이블 구조를 가진다는 사실은 오직 아키텍처의 외부 원에 위치한 최하위 수준의 유틸리티 함수만 알아야한다.&lt;/p>
&lt;p>소프트웨어에서 테이블과 행을 허용한다면, 유스케이스, 업무 규칙, UI조차도 관계형 데이터 구조에 결합되어버린다.&lt;/p>
&lt;h2 id="데이터베이스-시스템은-왜-이렇게-널리-사용되는가">데이터베이스 시스템은 왜 이렇게 널리 사용되는가?&lt;/h2>
&lt;p>데이터 저장 공간의 한계로 디스크를 사용할 수 밖에 없었기 때문이다.&lt;/p>
&lt;p>디스크의 단점은 느리다는 점 인데, 이로인해 발생하는 성능 저하 완화를 위한 색인, 캐시, 쿼리 계획 최적화가 필요해졌다.&lt;/p>
&lt;p>색인, 캐시, 쿼리 계획을 위해 작업중인 대상이 어떤 데이터인지 알 수 있어야 했으므로 데이터를 표현하는 일종의 표준적인 방식도 필요했고, 시간이 흘러 파일 시스템과 관계형 데이터베이스 관리 시스템(RDBMS) 2가지 유형으로 분리되었다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>파일 시스템&lt;/strong>&lt;/p>
&lt;p>문서(document) 기반 시스템으로, 문서 전체를 자연스럽고 편리하게 저장하는 방법을 제공한다.&lt;/p>
&lt;p>문서를 이름을 기준으로 저장하거나 조회할 때는 잘 동작하지만, 내용을 기준으로 검색할 때는 크게 도움되지 않는다.&lt;/p>
&lt;p>&lt;strong>데이터베이스 시스템&lt;/strong>&lt;/p>
&lt;p>내용 기반 시스템으로 내용을 기반으로 레코드를 자연스럽고 편리하게 찾는 방법을 제공한다.&lt;/p>
&lt;p>레코드가 서로 공유하는 일부 내용에 기반해서 다수의 레코드를 연관 짓는 데 매우 탁월하지만, 정형화되지 않은 문서를 저장하고 검색하는 데는 대체로 부적합하다.&lt;/p>
&lt;hr>
&lt;p>각 시스템은 데이터를 디스크에 체계화하고 특화된 방식으로 데이터를 저장하고 검색할 수 있도록 하며, 성능을 높히기 위해 데이터를 색인하고 RAM에 배치하는 고유한 전략을 활용한다.&lt;/p>
&lt;h2 id="디스크가-없다면-어떻게-될까">디스크가 없다면 어떻게 될까?&lt;/h2>
&lt;p>디스크는 RAM으로 대체되고있다.&lt;/p>
&lt;p>모든 데이터가 RAM에 저장된다면 데이터들을 연결 리스트, 트리, 해시 테이블, 스택, 큐 와 같은 데이터 구조로 체계화 될 것이며, 데이터에 접근할 때는 포인터나 참조를 활용할 것이다.&lt;/p>
&lt;p>데이터가 데이터베이스나 파일 시스템에 있더라도, RAM으로 읽은 후에는 다루기 편리한 형태로 그 구조로 변경하는데, 이는 프로그래머가 하는 일로 그대로 하면 된다.&lt;/p>
&lt;h2 id="세부사항">세부사항&lt;/h2>
&lt;p>데이터가 파일 시스템이나 데이터베이스 시스템을 통해 저장된다고 하더라도 결과적으로 실제 데이터를 처리할 때는 사용하기 편한 방식(자료구조)으로 처리하여 RAM에 올려 사용하게 된다.&lt;/p>
&lt;p>이처럼 데이터베이스는 디스크와 RAM 사이에서 데이터를 옮길 때 사용할 뿐인 메커니즘이고, 데이터를 장기적으로 저장하는 공간일 뿐이다.&lt;/p>
&lt;p>따라서 아케텍처 관점에서 본다면 데이터베이스는 세부사항이므로, 데이터가 어떤 형태로 어디에 저장되어있는지 인식해서는 안된다.&lt;/p>
&lt;h2 id="하지만-성능은">하지만 성능은?&lt;/h2>
&lt;p>데이터 저장소 측면에서 성능은 완전히 캡슐화하여 업무 규칙과는 분리할 수 있는 관심사이다.&lt;/p>
&lt;p>데이터 저장소에서 데이터를 빠르게 넣고 뺄 수 있어야 하는 것은 맞지만, 이는 저수준 관심사로 저수준의 데이터 매커니즘 단에서 다뤄야한다.&lt;/p>
&lt;ul>
&lt;li>인덱스 등&lt;/li>
&lt;/ul>
&lt;p>따라서 데이터 저장소의 성능은 시스템의 전반적인 아케텍처와는 관계가 없다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>체계화된 데이터 구조와 데이터 모델은 아키텍처적으로 중요한 반면, 데이터를 디스크에서 이리 저리 옮길 뿐인 기술과 시스템은 아키텍처적으로 중요하지 않다.&lt;/p>
&lt;p>데이터를 테이블 구조로 만들고 SQL로만 접근하도록 하는 관계형 데이터베이스 시스템은 후자와 관련이 깊으므로 아키텍처적으로 종요하지 않다.&lt;/p>
&lt;p>데이터는 중요하나, 데이터베이스는 세부사항이다.&lt;/p></description></item><item><title>28. 테스트 경계</title><link>https://codemario318.github.io/post/clean-architecture/28/</link><pubDate>Mon, 15 Apr 2024 18:17:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/28/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/28/cover.png" alt="Featured image of post 28. 테스트 경계" />&lt;p>테스트는 시스템의 일부이며, 아키텍처에도 관여한다.&lt;/p>
&lt;h2 id="시스템-컴포넌트인-테스트">시스템 컴포넌트인 테스트&lt;/h2>
&lt;p>아키텍처 관점에서는 어떠한 종류에 테스트이든 동일하다.&lt;/p>
&lt;p>테스트는 태생적으로 의존성 규칙을 따른다.&lt;/p>
&lt;ul>
&lt;li>테스트는 세부적이며 구체적이다.&lt;/li>
&lt;li>따라서 의존성은 항상 테스트 대상이 되는 코드를 향한다.(아키텍처의 가장 바깥쪽 원으로 볼 수 있다.)&lt;/li>
&lt;li>시스템 내부의 어떤 것도 테스트에는 의존하지 않는다.&lt;/li>
&lt;li>독립적으로 배포 가능하다.&lt;/li>
&lt;li>시스템 컴포넌트 중에서 가장 고립되어 있다.&lt;/li>
&lt;li>시스템 운영에 꼭 필요치는 않다.&lt;/li>
&lt;li>테스트의 역할은 운영이 아니라 개발을 지원하는 것이므로, 어떤 사용자도 테스트에 의존하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>그렇다고 하더라도 테스트가 시스템 컴포넌트가 아니라는 뜻은 아니며, 다른 모든 시스템 컴포넌트가 반드시 지켜야하는 모델을 표현해준다.&lt;/p>
&lt;h2 id="테스트를-고려한-설계">테스트를 고려한 설계&lt;/h2>
&lt;p>테스트의 극단적인 고립성이 대체로 배포하지 않는다는 사실과 어우러져, 테스트가 시스템의 설계 범위 밖에 있다고 착각한다.&lt;/p>
&lt;p>테스트가 시스템 설계와 잘 통합되지 않으면, 테스트는 깨지기 쉬워지고, 시스템은 뻣뻣해져서 변경하기가 어려워진다.&lt;/p>
&lt;p>&lt;strong>깨지기 쉬운 테스트 문제(Fragile Tests Problem)&lt;/strong>&lt;/p>
&lt;p>시스템에 강하게 결합된 테스트라면 시스템이 변경될 때 함께 변경되어야하므로, 시스템 컴포넌트에 생긴 아주 사소한 변경도, 이와 결합된 수많은 테스트를 망가뜨릴 수 있다.&lt;/p>
&lt;p>시스템의 공통 컴포넌트가 변경되면 수백, 심지어 수천 개의 테스트가 망가진다.&lt;/p>
&lt;hr>
&lt;p>깨지기 쉬운 테스트는 시스템을 뻣뻣하게 만든다는 부작용을 낳을 때가 많다.&lt;/p>
&lt;ul>
&lt;li>시스템에 가한 간단한 변경이 대량의 테스트 실패로 이어진다는 사실을 알게되면, 개발자는 변경을 하지 않으려고 할 것이다.&lt;/li>
&lt;/ul>
&lt;p>따라서 이러한 문제를 해결하기 위해 테스트를 고려한 설계가 필요하다.&lt;/p>
&lt;p>핵심은 &lt;strong>변동성이 있는 것에 의존하지 않는 것&lt;/strong>이다.&lt;/p>
&lt;p>변동성이 큰 GUI같은 것으로 시스템을 조작하는 테스트 스위트는 깨지기 쉽기 때문에 시스템과 테스트를 설계할 때 GUI를 사용하지 않고 업무 규칙을 테스트 할 수 있게 해야한다.&lt;/p>
&lt;h2 id="테스트-api">테스트 API&lt;/h2>
&lt;p>변동성이 적은 방식으로 업무 규칙을 테스트하기 위해 모든 업무 규칙을 검증하는 데 사용할 수 있도록 특화된 API를 만든다.&lt;/p>
&lt;ul>
&lt;li>보안 제약 사항을 무시할 수 있어야 한다.&lt;/li>
&lt;li>데이터베이스와 같은 값비싼 자원은 건너뛰고, 시스템을 테스트 가능한 특정 상태로 강제하는 강력한 힘을 지녀야한다.&lt;/li>
&lt;li>사용자 인터페이스가 사용하는 &lt;strong>인터렉터&lt;/strong>와 &lt;strong>인터페이스 어댑터&lt;/strong>들의 상위 집합이 될 것이다.&lt;/li>
&lt;/ul>
&lt;p>테스트 API는 테스트를 애플리케이션으로부터 분리할 목적으로 사용한다.&lt;/p>
&lt;h3 id="구조적-결합">구조적 결합&lt;/h3>
&lt;p>구조적 결합은 테스트 결합 중에서 가장 강하며, 가장 은밀하게 퍼져나가는 유형이다.&lt;/p>
&lt;p>모든 상용 클래스에 테스트 클래스가 각각 존재하고, 모든 상용 메서드에 테스트 메서드 집합이 각각 존재하는 테스트 스위트가 있다고 가정할 때 이러한 테스트 스위트는 애플리케이션 구조에 강하게 결합되어있다.&lt;/p>
&lt;ul>
&lt;li>상용 클래스나 메서드 중 하나라도 변경되면 딸려있는 다수의 테스트가 변경되어야한다.&lt;/li>
&lt;li>테스트는 깨지기 위워지고, 이로 인해 상용 코드를 뻣뻣하게 만든다.&lt;/li>
&lt;/ul>
&lt;p>테스트 API의 역할은 애플리케이션의 구조를 테스트로부터 숨기는 데 있다.&lt;/p>
&lt;ul>
&lt;li>상용 코드를 리펙터링하거나 진화시키더라도 테스트에는 전혀 영향을 주지 않는다.&lt;/li>
&lt;li>테스트를 리펙터링 하거나 진화시킬 때도 사용 코드에는 영향을 주지 않는다.&lt;/li>
&lt;/ul>
&lt;p>시간이 지날수록 테스트는 계속해서 더 구체적이고 특화된 형태로 변하고, 상용 코드는 더 추상적이고 범용적인 형태로 변하기 때문에 따로따로 진화할 수 있다는 점은 필수적이다.&lt;/p>
&lt;p>하지만 구조적 결합이 강하면 위와 같은 진화 과정을 방해한다.&lt;/p>
&lt;h3 id="보안">보안&lt;/h3>
&lt;p>테스트 API를 운영 시스템에 배포하면 위험에 처할 수 있다.&lt;/p>
&lt;p>테스트 API 자체와 테스트 API 중 위험한 부분의 구현부를 독립적으로 배포할 수 있는 컴포넌트로 분리해야한다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>테스트는 시스템의 일부이다.&lt;/p>
&lt;p>따라서 테스트에서 기대하는 안정성과 회귀의 이점을 얻을 수 있으려면 테스트는 잘 설계 돼야만한다.&lt;/p>
&lt;p>테스트를 시스템의 일부로 설계하지 않으면 테스트는 깨지기 쉽고 유지보수하기 어려워지는 경향이 있으며, 이러한 테스트는 유지보수하기 힘들기 때문에 버려지는 최후를 맡는다.&lt;/p></description></item><item><title>27. 크고 작은 모든 서비스들</title><link>https://codemario318.github.io/post/clean-architecture/27/</link><pubDate>Mon, 15 Apr 2024 17:13:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/27/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/27/cover.png" alt="Featured image of post 27. 크고 작은 모든 서비스들" />&lt;p>서비스 지향 아키텍처와 마이크로서비스 아키텍처는 최근에 큰 인기를 끌고 있는데 이유는 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>서비스를 사용하면 상호 결합이 철저하게 분리되는 것처럼 보인다.&lt;/li>
&lt;li>서비스를 사용하면 개발과 배포 독립성을 지원하는 것처럼 보인다.&lt;/li>
&lt;/ul>
&lt;h2 id="서비스-아키텍처">서비스 아키텍처?&lt;/h2>
&lt;p>서비스를 사용한다는 것이 본질적으로 아키텍처에 해당하는지에 대해 생각해보면 명백히 사실이 아니다.&lt;/p>
&lt;p>시스템의 아키텍처는 의존선 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의된다.&lt;/p>
&lt;p>이러한 관점에서 애플리케이션의 행위를 분리할 뿐인 서비스라면 값비싼 함수 호출에 불과하며, 아키텍처 관점에서 꼭 중요하다고 볼 수는 없다.&lt;/p>
&lt;p>기능을 프로세스나 플랫폼에 독립적이 되게끔 서비스들을 생성하면 의존성 규칙 준수 여부와 상관 없이 큰 도움이 될 때가 많으나, 서비스 그 자체로는 아키텍처를 정의하지 않는다.&lt;/p>
&lt;p>위에 언급한대로 시스템에서 아키텍처를 정의하는 요소는 의존성 규칙을 따르며 아키텍처 경계를 넘나드는 행위 자체이며, 결국 서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않는다고 볼 수 있다.&lt;/p>
&lt;h2 id="서비스의-이점">서비스의 이점?&lt;/h2>
&lt;p>많은 사람들이 생각하는 서비스의 이점에 대해 아키텍처 관점의 근본적인 문제를 살펴보면 이러한 부분들이 완벽한 해결책은 아님을 알 수 있다.&lt;/p>
&lt;h3 id="결합-분리의-오류">결합 분리의 오류&lt;/h3>
&lt;p>시스템을 서비스들로 분리함으로써 얻게 되리라 예상되는 큰 이점중 하나는 &lt;strong>서비스 사이의 결합이 확실히 분리된다는 점&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>각 서비스는 서로 다른 프로세스에서 실행되므로 서비스는 다른 서비스의 변수에 직접 접근이 불가능하다.&lt;/li>
&lt;li>모든 서비스의 인터페이스는 반드시 잘 정의되어 있어야 한다.&lt;/li>
&lt;/ul>
&lt;p>서비스들이 변수를 통해 직접 접근할 수는 없지만 프로세서 내의 또는 네트워크 상의 공유 자원과 이로 인한 공유하는 데이터에 의해 서비스들이 강력하게 결합된다.&lt;/p>
&lt;ul>
&lt;li>서비스 사이를 오가는 데이터 레코드에 새로운 필드를 추가하면, 이 필드를 사용하는 모든 서비스는 반드시 변경되어야한다.&lt;/li>
&lt;li>필드에 담긴 데이터를 해석하는 방식을 사전에 완벽하게 조율해야 한다.&lt;/li>
&lt;/ul>
&lt;p>이로 인해 서비스들은 레코드에 강하게 결합되고, 서비스들 사이는 서로 간접적으로 결합되어버린다.&lt;/p>
&lt;h3 id="개발-및-배포-독립성의-오류">개발 및 배포 독립성의 오류&lt;/h3>
&lt;p>전담팀이 서비스를 소유하고 운영하게 되므로 각자 개발 및 배포할 수 있게되어 &lt;strong>확장 가능한&lt;/strong>, 확장이 용이한 구조라고 생각하지만, 서비스는 확장 가능한 시스템을 구축하는 유일한 선택지가 아니다.&lt;/p>
&lt;ul>
&lt;li>모노리틱 시스템이나 컴포넌트 기반 시스템으로도 확장 가능한 시스템을 구축할 수 있다는 사실이 역사적으로 증명되어왔다.&lt;/li>
&lt;/ul>
&lt;p>결합 분리 오류에서 언급한 내용을 토대로 살펴보면 서비스라고 해서 항상 독립적으로 개발, 배포, 운영할 수 있는 것은 아니며, 결합된 정도에 맞게 조정해야한다.&lt;/p>
&lt;h2 id="야옹이-문제">야옹이 문제&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/27/img.png"
width="1393"
height="574"
srcset="https://codemario318.github.io/post/clean-architecture/27/img_huc93515613977e36e214e87cb871aaccb_354737_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/27/img_huc93515613977e36e214e87cb871aaccb_354737_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="242"
data-flex-basis="582px"
>&lt;/p>
&lt;p>이전에 예시로 들었던 택시 통합 시스템을 수많은 작은 마이크로 서비스를 기반으로 구축했다.&lt;/p>
&lt;p>이러한 아키텍처에서 야옹이 배달 서비스를 런칭하겠다고 가정한다.&lt;/p>
&lt;p>&lt;strong>요구사항&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>사용자는 집이나 사무실로 야옹이를 배달해달라고 주문할 수 있다.
&lt;ul>
&lt;li>야옹이를 태울 다수의 승차 지점을 설정해야한다.&lt;/li>
&lt;li>승차 지점 중 한 곳에서 야옹이를 태운 후, 올바른 주로소 야옹이를 배달해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>제약사항&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>운전자가 고양이 알러지가 있는 경우 해당 운전자는 이 서비스에서 제외되어야한다.&lt;/li>
&lt;li>일반 택시 승객이 알러지가 있을 수 있으므로, 배차를 신청한 고객이 알러지가 있다면, 야옹이를 배달했던 차량은 배차에서 제외한다.&lt;/li>
&lt;/ul>
&lt;p>서비스 다이어그램을 살펴봤을 때 마이크로서비스들은 모두 결합되어 있어 독립적으로 개발하고 배포하거나 유지할 수 없다.&lt;/p>
&lt;p>따라서 야옹이 배달 기능을 추가하려면 구성된 모든 마이크로서비스를 변경해야 한다.&lt;/p>
&lt;p>이는 횡단 관심사(Cross-Cutting Concern)가 지닌 문제로 기능적 분해는 새로운 기능이 기능적 행위를 횡단하는 상황에서 매우 취약하다.&lt;/p>
&lt;h2 id="객체가-구출하다">객체가 구출하다&lt;/h2>
&lt;p>SOLID 설계원칙에서, 다향적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 한다.&lt;/p>
&lt;p>이를 통해 컴포넌트 아키텍처에서는 아래와 같은 전략을 활용할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/27/img_1.png"
width="1418"
height="1356"
srcset="https://codemario318.github.io/post/clean-architecture/27/img_1_hu5da0ee89e3d37864338935723ad5c1a6_654243_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/27/img_1_hu5da0ee89e3d37864338935723ad5c1a6_654243_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="104"
data-flex-basis="250px"
>&lt;/p>
&lt;p>원래 서비스 로직 중 대다수가 이 객체 모델의 기반 클래스들 내부로 녹아들었다.&lt;/p>
&lt;ul>
&lt;li>배차에 특화된 로직 부분은 &lt;code>Rides&lt;/code> 컴포넌트로 추출되었다.&lt;/li>
&lt;li>야옹이에 대한 신규 기능은 &lt;code>Kittens&lt;/code> 컴포넌트에 들어있다.&lt;/li>
&lt;li>이 두 컴포넌트는 기존 컴포넌트들에 있는 추상 기반 클래스를 템플릿 메서드나 전략 패턴 등을 이용해서 오버라이드한다.&lt;/li>
&lt;li>신규 컴포넌트 &lt;code>Rides&lt;/code>, &lt;code>Kittens&lt;/code>가 의존성 규칙을 준수한다.&lt;/li>
&lt;li>이 기능을 구현하는 클래스들은 UI의 제어 하에 팩토리가 생성한다.&lt;/li>
&lt;/ul>
&lt;p>이 전략을 따르더라도 야옹이 기능을 구현하려면 &lt;code>TaxiUI&lt;/code>는 변경해야 하지만, 그 외의 것들은 변경할 필요가 없다.&lt;/p>
&lt;p>따라서 야옹이 기능은 결합이 분리되며, 독립적으로 개발하여 배포할 수 있다.&lt;/p>
&lt;h2 id="컴포넌트-기반-서비스">컴포넌트 기반 서비스&lt;/h2>
&lt;p>서비스가 반드시 소규모 단일체(monolith)일 이유는 없다.&lt;/p>
&lt;p>서비스는 SOLID 원칙대로 설계할 수 있으며 컴포넌트 구조를 갖출 수도 있다.&lt;/p>
&lt;p>java의 경우 서비스를 하나 이상의 &lt;code>jar&lt;/code> 파일에 포함되는 &lt;strong>추상 클래스들의 집합&lt;/strong>이라고 생각할 수 있다.&lt;/p>
&lt;p>새로운 기능 추가 혹은 기능 확장은 기존 &lt;code>jar&lt;/code> 파일에 정의돈 추상 클래스들을 확장하여 새로운 &lt;code>jar&lt;/code> 파일로 만든다면, 새로운 기능 배포는 서비스를 재배포하는 문제가 아니라, 서비스를 로드하는 경로에 단순히 새로운 &lt;code>jar&lt;/code> 파일을 추가하는 문제가 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/27/img_2.png"
width="1404"
height="1024"
srcset="https://codemario318.github.io/post/clean-architecture/27/img_2_huc3c601dcdc257ffe66a5f4dc26dbb7e2_569311_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/27/img_2_huc3c601dcdc257ffe66a5f4dc26dbb7e2_569311_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="329px"
>&lt;/p>
&lt;p>각 서비스의 내부는 자신만의 컴포넌트 설계로 되어 있어서 파생 클래스를 만드는 방식으로 신규 기능을 추가할 수 있다.&lt;/p>
&lt;h2 id="횡단-관심사">횡단 관심사&lt;/h2>
&lt;p>아키텍처 경계는 서비스 사이에 있지 않고 오히려 서비스를 관통하며, 서비스를 컴포넌트 단위로 분할한다.&lt;/p>
&lt;p>모든 주요 시스템이 직면하는 횡단 관심사를 처리하려면, 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/27/img_3.png"
width="1426"
height="639"
srcset="https://codemario318.github.io/post/clean-architecture/27/img_3_hu56c1406b520655ab8ea4c66d27f42c03_210561_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/27/img_3_hu56c1406b520655ab8ea4c66d27f42c03_210561_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="223"
data-flex-basis="535px"
>&lt;/p>
&lt;p>서비스들은 시스템의 아키텍처 경계를 정의하지 않으며, 아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트이다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>서비스는 시스템의 확정성과 개발 가능성 측면에서 유용하지만, 그 자체로는 아키텍처적으로 그리 중요한 요소는 아니다.&lt;/p>
&lt;p>시스템의 아키텍처는 구성 요소가 통신하고 실행되는 물리적인 매커니즘에 의해 아키텍처가 정의되는 것이 아닌, 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의된다.&lt;/p>
&lt;ul>
&lt;li>서비스는 단 하나의 아케텍처 경계로 둘러싸인 단일 컴포넌트로 만들 수 있다.&lt;/li>
&lt;li>여러 아키텍처 경계로 분리된 다수의 컴포넌트로 구성할 수도 있다.&lt;/li>
&lt;li>클라이언트와 서비스가 강하게 결합되어 아키텍처적으로 아무런 의미가 없을 때도 있다.&lt;/li>
&lt;/ul></description></item><item><title>26. 메인 컴포넌트</title><link>https://codemario318.github.io/post/clean-architecture/26/</link><pubDate>Mon, 15 Apr 2024 16:48:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/26/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/26/cover.png" alt="Featured image of post 26. 메인 컴포넌트" />&lt;p>모든 시스템에는 최소한 하나의 컴포넌트가 존재하여 나머지 컴포넌트를 생성, 조정, 관리하는데 이러한 컴포넌트를 메인 컴포넌트라 한다.&lt;/p>
&lt;h2 id="궁극적인-세부사항">궁극적인 세부사항&lt;/h2>
&lt;p>메인 컴포넌트는 &lt;strong>궁극적인 세부사항&lt;/strong>으로, 가장 낮은 수준의 정책이다.&lt;/p>
&lt;ul>
&lt;li>시스템의 초기 진입점이다.&lt;/li>
&lt;li>운영체제를 제외하면 어떤 것도 메인에 의존하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>메인은 모든 팩토리(Factory)와 전략(Strategy), 시스템 전반을 담당하는 나머지 기발 설비를 생성한 후, 시스템에서 더 높은 수준을 담당하는 부분으로 제어권을 넘긴다.&lt;/p>
&lt;hr>
&lt;p>의존성 주입 프레임워크를 이용해 의존성을 주입하는 일은 메인 컴포넌트에서 이뤄져야 한다.&lt;/p>
&lt;p>메인에 의존성이 주입되고 나면, 의존성 주입 프레임워크를 사용하지 않고도 일반적인 방식으로 의존성을 분배할 수 있어야한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">IOException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">game&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">HtwFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeGame&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;htw.game.HuntTheWumpusFacade&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Main&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">createMap&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">BufferdReader&lt;/span> &lt;span class="n">br&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">BufferedReader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">InputStreamReader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">in&lt;/span>&lt;span class="o">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeRestCommand&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">excute&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getPlayerCavern&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Health: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">hitPoints&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; arrows: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getQuiver&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">HuntTheWumpus&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">Command&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeRestCommand&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;&amp;gt;&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">String&lt;/span> &lt;span class="n">command&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">br&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">readLine&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;e&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">EAST&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;w&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">WEST&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;n&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">NORTH&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;s&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">SOUTH&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;r&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;sw&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">WEST&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;se&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">EAST&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;sn&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">EAST&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;ss&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">game&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">makeMoveCommand&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">SOUTH&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equalsIgnoreCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;q&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">excute&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>HtwFactory&lt;/code>를 사용하여 게임을 생성할 때, &lt;code>htw.game.HuntTheWumpusFacade&lt;/code>라는 클래스 이름을 문자열로 전달하는데, 이는 이 클래스가 변경이 매우 많은 지저분한 클래스이므로, 문자열을 통해 참조하도록 하여 직접 참조하지 않게 하여 변경이 생겨도 메인을 재컴파일/재배포하지 않게 만들기 위함이다.&lt;/p>
&lt;p>입력 스티름 생성 부분, 게임의 메인 루프 처리, 간단한 입력 명령어 해석 등은 모두 &lt;code>main()&lt;/code>에서 처리하지만, 명령어를 실제로 처리하는 일은 다른 고수준 컴포넌트로 위임한다.&lt;/p>
&lt;hr>
&lt;p>메인은 클린 아키텍처에서 가장 바깥 원에 위치하는, 지저분한 저수준 모듈이다.&lt;/p>
&lt;p>메인은 고수준의 시스템을 위한 모든 것을 로드한 후, 제어권을 고수준의 시스템에게 넘긴다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>메인을 초기 조건과 성정을 구성하고, 외부 자원을 모두 수집한 후 제어권을 애플리케이션의 고수준 정책으로 넘기는 플러그인이다.&lt;/p>
&lt;p>메인은 플러그인이므로 메인 컴포넌트를 애플리케이션의 설정별로 하나씩 두로록 하여 둘 이상의 메인 컴포넌트를 만들 수도 있다.&lt;/p>
&lt;ul>
&lt;li>개발용 메인 플러그인&lt;/li>
&lt;li>테스트용 메인 플러그인&lt;/li>
&lt;li>국가별 플러그인&lt;/li>
&lt;li>관할 영역 별 플러그인&lt;/li>
&lt;li>고객별 플러그인 등&lt;/li>
&lt;/ul>
&lt;p>메인을 플러그인 컴포넌트로 여기고 아키텍처 경계 바깥에 위치한다고 보면 설정 관련 문제를 훨씬 쉽게 해결할 수 있다.&lt;/p></description></item><item><title>25. 계층과 경계</title><link>https://codemario318.github.io/post/clean-architecture/25/</link><pubDate>Thu, 04 Apr 2024 09:16:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/25/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/25/cover.png" alt="Featured image of post 25. 계층과 경계" />&lt;p>단순한 시스템에서는 UI, 업무 규칙, 데이터베이스 컴포넌트만으로도 충분하지만, 대다수의 시스템에서 컴포넌트의 개수는 이보다 훨씬 많다.&lt;/p>
&lt;p>이에 따라 컴포넌트간 경계도 훨씬 많이질 수 밖에 없다.&lt;/p>
&lt;p>아키텍처 경계는 어디에나 존재하며, 아키텍트는 아키텍처 경계가 언제 필요한지를 신중하게 파악해내야한다.&lt;/p>
&lt;p>이러한 경계를 제대로 구현하는 비용은 크며, 경계가 무시되었다면 나중에 다시 추가하는 비용도 매우 크다.&lt;/p>
&lt;p>오버 엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많으므로 XP의 원칙인 &lt;strong>YAGNI&lt;/strong>가 말하는 것 처럼 추상화가 필요하리라고 미리 예측해서는 안 된다.&lt;/p>
&lt;p>하지만, 경계가 존재하지 않는 상황에서 경계가 필요하다는 것을 깨닳고 추가하려면 비용이 매우 많이 들고 큰 위험을 감수해야한다.&lt;/p>
&lt;hr>
&lt;p>이처럼 소프트웨어 아키텍트는 여러 상황들을 적절히 고려하여 소프트웨어가 어떻게 발전할지 예측해야한다.&lt;/p>
&lt;p>이를 통해 완벽하게 구현할 경계와 부분적으로 구현할 경계, 무시할 경계가 무엇인지 결정해야만 한다.&lt;/p>
&lt;p>그렇지만 프로젝트 초반에는 경계를 쉽게 결정할 수 없기 때문에 한번에 정해지는 것은 아니므로, 시스템이 발전함에 따라 주의를 기울여야한다.&lt;/p>
&lt;ul>
&lt;li>경계가 필요할 수 있는 부분에 주목한다.&lt;/li>
&lt;li>경계가 존재하지 않아 생기는 마찰의 첫 조짐을 신중하게 관찰한다.
&lt;ul>
&lt;li>경계를 구현하는 비용가 무시할 때 감수할 비용을 가늠해본다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>결정된 사항을 자주 검토한다.&lt;/li>
&lt;/ul>
&lt;p>경계의 구현 비용이 그것을 무시하여 생기는 비용보다 적어지는 시점에 경계를 구현해야하며, 적절한 시점에 경계를 구현하기 위해 빈틈없이 지켜봐야한다.&lt;/p></description></item><item><title>24. 부분적 경계</title><link>https://codemario318.github.io/post/clean-architecture/24/</link><pubDate>Thu, 04 Apr 2024 08:49:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/24/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/24/cover.png" alt="Featured image of post 24. 부분적 경계" />&lt;p>아키텍처 경계를 완벽하게 만드는 데는 엄청난 노력을 기율여야 하고, 유지하는 데도 엄청난 노력이 든다.&lt;/p>
&lt;ul>
&lt;li>쌍방향의 다형적 &lt;code>Boundary&lt;/code> 인터페이스&lt;/li>
&lt;li>&lt;code>Input&lt;/code>, &lt;code>Output&lt;/code>을 위한 데이터 구조&lt;/li>
&lt;li>두 영역을 독립적으로 컴파일하고 배포할 수 있는 컴포넌트로 격리하는 데 필요한 모든 의존성 관리&lt;/li>
&lt;/ul>
&lt;p>많은 경우에 이러한 경계를 만드는 비용이 크다고 판단하면서도, 필요한 작업만 해야한다는 XP 원칙인 &lt;strong>YAGNI&lt;/strong>(You Aren&amp;rsquo;t going to Need It)을 위배하며 나중에 필요할 것이라 예상대는 것들에 대한 대비하길 원한다.&lt;/p>
&lt;p>이렇게 필요할 것으로 예상되는 것을 꼭 대비해야 한다면 완벽한 경계가 아닌 &lt;strong>부분적 경계&lt;/strong>(Patial boundary)를 활용해 볼 수 있다.&lt;/p>
&lt;h2 id="마지막-단계를-건너-뛰기">마지막 단계를 건너 뛰기&lt;/h2>
&lt;p>독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 방법이다.&lt;/p>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>다수의 컴포넌트를 관리하는 작업을 하지 않아도 된다.&lt;/li>
&lt;li>추적을 위한 버전 번호도 필요없다.&lt;/li>
&lt;li>배포 관리 부담이 없다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>부분적 경계를 만들기 위해 완벽한 경계를 만들 때 만큼의 코드량과 사전 설계가 필요하다.&lt;/li>
&lt;li>시간이 흐르며 별도로 분리한 컴포넌트가 재사용될 가능성이 전혀 없을 것임이 명백해지는 경우가 있다.&lt;/li>
&lt;li>시간이 흐르며 컴포넌트 사이의 구분이 점점 약화된다.&lt;/li>
&lt;/ul>
&lt;h2 id="일차원-경계">일차원 경계&lt;/h2>
&lt;p>완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 &lt;code>Boundary&lt;/code> 인터페이스를 사용하는데, 이러한 형태는 초기 설정할 때나 지속적으로 유지할 때도 비용이 많이 든다.&lt;/p>
&lt;p>이러한 경우 추후 완벽한 형태의 경계로 확장할 수 있는 공간을 확보하고자 할 때, 전통적인 전략 패턴을 사용하여 간단한 구조를 활용해 볼 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/24/img.png"
width="720"
height="292"
srcset="https://codemario318.github.io/post/clean-architecture/24/img_huf66003e0682ccdb8f85feab7e684d52d_81657_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/24/img_huf66003e0682ccdb8f85feab7e684d52d_81657_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="246"
data-flex-basis="591px"
>&lt;/p>
&lt;p>&lt;code>Client&lt;/code>를 &lt;code>ServiceImpl&lt;/code>로 부터 격리시키는 데 필요한 의존성 역전이 적용되었기 때문에 미래에 필요한 아키텍처 경계를 대비할 수 있다.&lt;/p>
&lt;p>하지만 이러한 형태의 분리는 쌍방향 인터페이스가 없고 개발자와 아키텍트의 능력에 따라, 점선과 같은 비밀 통로가 생기는 일을 막을 방법이 없다.&lt;/p>
&lt;h2 id="퍼사드">퍼사드&lt;/h2>
&lt;p>더 단순한 경계는 퍼사드 패턴으로, 이 경우에는 의존성 역전까지 희생한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/24/img_1.png"
width="720"
height="299"
srcset="https://codemario318.github.io/post/clean-architecture/24/img_1_huda7c855c7c3463c0aff875896060fffa_46486_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/24/img_1_huda7c855c7c3463c0aff875896060fffa_46486_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="240"
data-flex-basis="577px"
>&lt;/p>
&lt;p>경계는 &lt;code>Facade&lt;/code> 클래스로만 간단히 전의되며, 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 서비스 클래스로 호출을 전달한다.&lt;/p>
&lt;p>클라이언트는 서비스 클래스에 직접 접근할 수 없지만, &lt;code>Client&lt;/code>가 이 모든 서비스 클래스에 대해 추이 종속성을 가지게 된다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>추이 종속성&lt;/strong>&lt;br>
A 모듈이 B 모듈에 의존하고, B 모듈이 C 모듈에 의존한다고 가정할 때, A 모듈은 직접적으로는 C 모듈에 의존하지 않지만, B 모듈을 통해 C 모듈에 간접적으로 의존하는 형태&lt;/p>
&lt;/blockquote>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>아키텍처 경계를 부분적으로 구현하는 방법은 많다.&lt;/p>
&lt;p>이러한 접근법은 각각 나름의 비용과 장점을 지니며, 완벽한 형태의 경계를 담기 위한 공간으로써 적절하게 사용할 수 있는 상황이 서로 다르다.&lt;/p>
&lt;p>부분적인 경계는 추후에 완벽한 형태의 경계가 실제로 구체화되지 않으면 가치가 떨어질 수 있다.&lt;/p></description></item><item><title>23. 프레젠터와 험블 객체</title><link>https://codemario318.github.io/post/clean-architecture/23/</link><pubDate>Wed, 03 Apr 2024 22:31:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/23/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/23/cover.png" alt="Featured image of post 23. 프레젠터와 험블 객체" />&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/23/img.png"
width="772"
height="567"
srcset="https://codemario318.github.io/post/clean-architecture/23/img_hudd764f775c86d6d6fb1802d465c14dac_405598_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/23/img_hudd764f775c86d6d6fb1802d465c14dac_405598_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="326px"
>&lt;/p>
&lt;p>프레젠터는 험블 객체(Humble Object) 패턴을 따른 형태로, 아키텍처 경계를 식별하고 보호하는 데 도움이 된다.&lt;/p>
&lt;h2 id="험블-객체-패턴">험블 객체 패턴&lt;/h2>
&lt;p>험블 객체 패턴은 디자인 패턴으로, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.&lt;/p>
&lt;ul>
&lt;li>행위들을 두 개의 모듈 또는 클래스로 나눈다.&lt;/li>
&lt;li>가장 기본적인 본질은 남기고, 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다.&lt;/li>
&lt;li>나머지 모듈에는 험블 객체에 속하지 않은, 테스트하기 쉬운 행위를 모두 옮긴다.&lt;/li>
&lt;/ul>
&lt;h2 id="프레젠터와-뷰">프레젠터와 뷰&lt;/h2>
&lt;p>GUI는 화면에서 각 요소가 필요한 위치에 적절히 표시되었는지 테스트 해야하므로 작성하기 어려운 반면, GUI에서 수행하는 행위의 대다수는 쉽게 테스트할 수 있다.&lt;/p>
&lt;p>험블 객체 패턴을 사용하면 두 부류의 행위를 분리하여 프레젠터와 뷰라는 서로 다른 클래스로 만들 수 있다.&lt;/p>
&lt;p>&lt;strong>뷰&lt;/strong>&lt;br>
뷰는 데이터를 GUI로 이동시키지만, 데이터를 직접 처리하지는 않는다.&lt;/p>
&lt;ul>
&lt;li>험블 객체이고 테스트하기 어렵다.&lt;/li>
&lt;li>포함된 코드를 가능한 간단하게 유지한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>프레젠터&lt;/strong>&lt;br>
애플리케이션으로 부터 데이터를 받아 화면에 표현할 수 있는 포멧으로 만든다.&lt;/p>
&lt;ul>
&lt;li>뷰가 데이터를 받아 화면에 전달하는 간단한 일만 처리하도록 만들어준다.&lt;/li>
&lt;li>테스트하기 쉬워진다.&lt;/li>
&lt;/ul>
&lt;p>뷰는 뷰 모델의 데이터를 화면으로 로드할 뿐이며, 이 외에 뷰가 맡은 역할은 전혀 없기 때문에 뷰는 보잘것없다(Humble)&lt;/p>
&lt;h2 id="테스트와-아키텍처">테스트와 아키텍처&lt;/h2>
&lt;p>테스트 용이성은 좋은 아키텍처가 지녀야 할 속성으로 오랫동안 알려저 왔다.&lt;/p>
&lt;p>험블 객체 패턴은 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하여 아키텍처 경계를 정의하므로 테스트가 용이하다.&lt;/p>
&lt;p>즉, 아키텍처에 험블 객체 패턴을 적절히 활용하면 프레젠터와 뷰와 같이 테스트가 용이한 구조를 만들 수 있다.&lt;/p>
&lt;h2 id="데이터베이스-게이트웨이">데이터베이스 게이트웨이&lt;/h2>
&lt;p>유스케이스 인터랙터와 데이터베이스 사이에는 데이터베이스 게이트웨이(데이터베이스의 쿼리를 처리하는 모든 메서드가 포함)가 위치한다.&lt;/p>
&lt;p>유스케이스 레이어는 SQL을 허용하지 않아야 하므로 필요한 메서드를 제공하는 게이트웨이 인터페이스를 호출하게 되는데, 이 때 데이터베이스 레이어에 존재하는 &lt;strong>인터페이스의 구현체&lt;/strong>가 험블 객체이다.&lt;/p>
&lt;p>이와 달리 인터랙터는 애플리케이션에 특화된 업무 규칙을 캡슐화화기 때문에 험블 객체가 아니기 때문에 게이트웨이는 가짜 데이터(Mock, stub, test-double, fake)를 통해서도 테스트를 할 수 있으므로 테스트하기 쉬워진다.&lt;/p>
&lt;h2 id="데이터-매퍼">데이터 매퍼&lt;/h2>
&lt;p>하이버네이트와 같은 ORM은 어느 계층에 속하는가?&lt;/p>
&lt;p>ORM 시스템은 데이터베이스 레이어에 위치하며 게이트웨이 인터페이스와 데이터베이스 사이의 일종에 또 다른 험블 객체 경계를 형성한다.&lt;/p>
&lt;ul>
&lt;li>사용자 관점에서 객체는 공개된 메서드만 볼 수 있으므로, 단순히 오퍼레이션의 집합이다.&lt;/li>
&lt;li>&lt;strong>데이터 구조&lt;/strong>는 함축된 행위를 가지지 않는 공개된 변수의 집합이다.&lt;/li>
&lt;/ul>
&lt;p>객체는 데이터 구조가 아니기 때문에, 사실 객체 관계 매퍼(Object Relational Mapper, ORM)는 관계형 데이터베이스 테이블로부터 가져온 데이터를 데이터 구조에 맞게 담아주는 역할을 수행하므로 사실 데이터 매퍼라고 볼 수 있다.&lt;/p>
&lt;h2 id="서비스-리스너">서비스 리스너&lt;/h2>
&lt;p>서비스에서도 험블 객체 패턴을 발견할 수 있다.&lt;/p>
&lt;p>애플리케이션은 데이터를 간단한 데이터 구조 형태로 로드한 후, 이 데이터 구조를 경계를 거슬러 특정 모듈로 전달하고, 데이터 구조를 전달받은 모듈이 적절한 포맷으로 만들어 외부 서비스로 전송하게 된다.&lt;/p>
&lt;p>외부로부터 데이터를 수신하는 서비스는 서비스 리스너가 서비스 인터페이스로부터 데이터를 수신하고, 데이터를 애플리케이션에서 사용할 수 있게 간단한 데이터 구조로 포맷을 변경하여 서비스 경계를 가로질러 내부로 전달된다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>아키텍처 경계마다 험블 객체 패턴을 발견할 수 있다.&lt;/p>
&lt;p>경계를 넘나드는 통신은 거의 모두 간단한 데이터 구조를 수반할 때가 많고, 대개 그 경계는 테스트하기 어려운 무언가와 테스트하기 쉬운 무언가로 분리된다.&lt;/p>
&lt;p>이러한 아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다.&lt;/p></description></item><item><title>22. 클린 아키텍처</title><link>https://codemario318.github.io/post/clean-architecture/22/</link><pubDate>Wed, 03 Apr 2024 16:22:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/22/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/22/cover.png" alt="Featured image of post 22. 클린 아키텍처" />&lt;ul>
&lt;li>육각형 아키텍처(Hexagonal Architecture)&lt;/li>
&lt;li>DCI(Data, Context and Interaction)&lt;/li>
&lt;li>BCE(Boundary-Control-Entity)&lt;/li>
&lt;/ul>
&lt;p>위와 같은 아키텍처들의 목적은 &lt;strong>관심사의 분리&lt;/strong>(Separation of concerns)이다.&lt;/p>
&lt;p>소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성할 수 있었다.&lt;/p>
&lt;p>각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함하며, 시스템이 다음과 같은 특징을 가지도록 만든다.&lt;/p>
&lt;ul>
&lt;li>프레임워크 독립성&lt;/li>
&lt;li>테스트 용이성&lt;/li>
&lt;li>UI 독립성&lt;/li>
&lt;li>데이터베이스 독립성&lt;/li>
&lt;li>모든 외부 에이전시에 대한 독립성&lt;/li>
&lt;/ul>
&lt;h2 id="의존성-규칙">의존성 규칙&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/22/img.png"
width="772"
height="567"
srcset="https://codemario318.github.io/post/clean-architecture/22/img_hudd764f775c86d6d6fb1802d465c14dac_405598_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/22/img_hudd764f775c86d6d6fb1802d465c14dac_405598_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="326px"
>&lt;/p>
&lt;p>그림의 각 동원은 소프트웨어의 서로 다른 영역을 표현하는데, 안으로 들어갈수록 고수준의 소프트웨어가 된다.(바깥쪽은 메커니즘, 안쪽은 정책)&lt;/p>
&lt;p>이러한 아키텍처가 동작하도록 하는 가장 중요한 규칙은 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다는 &lt;strong>의존성 규칙&lt;/strong>(Dependency Rule)이다.&lt;/p>
&lt;ul>
&lt;li>내부의 원에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못한다.
&lt;ul>
&lt;li>함수, 클래스, 변수, 엔티티 등&lt;/li>
&lt;li>외부의 원에 선언된 데이터 형식도 내부의 원에서 절대 사용해서는 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>외부 원에 위치한 어떤 것도 내부 원에 영향을 주지 않아야한다.&lt;/p>
&lt;h3 id="엔티티">엔티티&lt;/h3>
&lt;p>엔티티는 전사적인 핵심 업무 규칙을 캡슐화한 것이다.(단순한 단일 애플리케이션이라면 애플리케이션의 업무 객체)&lt;/p>
&lt;ul>
&lt;li>메서드를 가지는 객체&lt;/li>
&lt;li>일련의 데이터 구조와 함수의 집합&lt;/li>
&lt;/ul>
&lt;p>기업의 다양한 애플리케이션에서 엔티티를 재사용할 수만 있다면, 그 형태는 그다지 중요하지 않다.&lt;/p>
&lt;p>운영 관점에서 특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안 된다.&lt;/p>
&lt;h3 id="유스케이스">유스케이스&lt;/h3>
&lt;p>유스케이스 계층의 소프트웨어는 애플리케이션에 특화된 업무 규칙을 포함하며, 시스템의 모든 유스케이스를 캡슐화하고 구현한다.&lt;/p>
&lt;ul>
&lt;li>엔티티로 들어오고 나가는 데이터 흐름을 조정한다.&lt;/li>
&lt;li>엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다.&lt;/li>
&lt;/ul>
&lt;p>유스케이스 레이어를 잘 격리하여 발생한 변경이 엔티티에 영향을 줘서는 안될 뿐만 아니라, 외부 요소에서 발생한 변경이 이 계층에 영향을 줘서도 안된다.&lt;/p>
&lt;p>유스케이스 레이어는 아래와 같은 상황에서만 영향을 받아야한다.&lt;/p>
&lt;ul>
&lt;li>운영 관점에서 애플리케이션이 변경되어 유스케이스 자체가 영향을 받은 경우&lt;/li>
&lt;li>유스케이스의 세부 사항이 변경된 경우&lt;/li>
&lt;/ul>
&lt;h3 id="인터페이스-어댑터">인터페이스 어댑터&lt;/h3>
&lt;p>인터페이스 어댑터 레이어는 일련의 어댑터들(Controllers, Gateways, Presenters)로 구성된다.&lt;/p>
&lt;p>어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환한다.&lt;/p>
&lt;ul>
&lt;li>ex) GUI의 MVC 아키텍처&lt;/li>
&lt;/ul>
&lt;p>모델은 데이터 구조 정도에 지나지 않으며, 컨트롤러에서 유스케이스로 전달되고, 다시 유스케이스에서 프레젠터와 뷰로 되돌아간다.&lt;/p>
&lt;p>인터페이스 어댑터 레이어는 데이터를 엔티티와 유스케이스에게 가장 편리한 형식에서 영속성용으로 사용 중인 임의의 프레임워크(ex. DB)가 이용하기에 가장 편리한 형식으로 변환한다.&lt;/p>
&lt;p>또한 데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또 다른 어댑터가 필요하다.&lt;/p>
&lt;h3 id="프레임워크와-드라이버">프레임워크와 드라이버&lt;/h3>
&lt;p>가장 바깥 레이어인 프레임워크와 드라이버 레이어는 모든 세부사항이 위치하는 곳으로, 일반적으로 데이터베이스나 웹 프레임워크 같은 프레임워크나 도구들로 구성된다.&lt;/p>
&lt;p>이 계층에서는 안쪽 원과 통신하기 위한 접합 코드 외에는 특별히 더 작성해야 할 코드가 그다지 많지 않다.&lt;/p>
&lt;p>웹, 데이터베이스와 같은 세부사항을 모두 외부에 위치시켜서 피해를 최소화한다.&lt;/p>
&lt;h3 id="원은-네-개여야만-하는가">원은 네 개여야만 하는가?&lt;/h3>
&lt;p>그림의 원들은 하나의 예시일 뿐이며 더 많은 원이 필요할 수 있다.&lt;/p>
&lt;p>하지만 어떤 경우에도 &lt;strong>의존성 규칙&lt;/strong>은 적용된다.&lt;/p>
&lt;ul>
&lt;li>소스코드 의존성은 항상 안족을 향한다.&lt;/li>
&lt;li>안쪽으로 이동할수록 추상화와 정책의 수준은 높아진다.&lt;/li>
&lt;li>가장 바깥쪽 원은 저수준의 구체적인 세부사항으로 구성된다.&lt;/li>
&lt;li>안쪽으로 이동할수록 소프트웨어는 점점 추상화되고 더 높은 수준의 정책들을 캡슐화한다.&lt;/li>
&lt;/ul>
&lt;h3 id="경계-횡단하기">경계 횡단하기&lt;/h3>
&lt;p>위 예시에서 컨트롤러와 프레젠터가 다음 계층에 속한 유스케이스와 통신하는 모습을 확인할 수 있다.&lt;/p>
&lt;ol>
&lt;li>컨트롤에서 시작&lt;/li>
&lt;li>유스케이스를 지남&lt;/li>
&lt;li>프레젠터에서 실행&lt;/li>
&lt;/ol>
&lt;p>유스케이스가 내부 원의 인터페이스를 호출하도록 하고, 외부 원의 프레젠터가 그 인터페이스를 구현하도록 만들어 의존성 흐름을 역전시켰다.&lt;/p>
&lt;p>이처럼 제어흐름과 의존성의 방향이 명백히 반대여야 하는 경우, 의존성 역전 원칙을 사용하여 해결한다.&lt;/p>
&lt;ul>
&lt;li>인터페이스와 상속 관계 등&lt;/li>
&lt;/ul>
&lt;p>아키텍처 경계를 횡단할 때 언제라도 동일한 기법을 사용할 수 있다.&lt;/p>
&lt;h3 id="경계를-횡단하는-데이터는-어떤-모습인가">경계를 횡단하는 데이터는 어떤 모습인가?&lt;/h3>
&lt;p>경계를 가로지르는 데이터는 흔히 간단한 데이터 구조로 이루어져 있다.&lt;/p>
&lt;ul>
&lt;li>기본적인 구조체, 간단한 데이터 전송 객체(DTO) 등&lt;/li>
&lt;li>함수 호출 시 간단한 인자&lt;/li>
&lt;li>해시맵, 객체&lt;/li>
&lt;/ul>
&lt;p>중요한 점은 엔티티 객체나 데이터베이스의 행을 전달하는 것이 아닌 격리되어 있는 간단한 데이터 구조가 경계를 가로질러 전달되어야 한다.&lt;/p>
&lt;p>위와 같은 경우 결과적으로 어떠한 형태로든 전달되는 데이터 구조를 통해 내부의 원에서 외부 원의 무언가를 알게 되므로 의존성 규칙을 위배하게된다.&lt;/p>
&lt;p>따라서 경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야한다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>위와같은 간단한 규칙들을 준수하는 것은 어렵지 않으며, 향후에 겪을 수많은 고통거리를 덜어준다.&lt;/p>
&lt;p>소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며, 그에 다른 이점을 누릴 수 있다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스나 프레임워크와 같은 시스템의 외부 요소를 교체하더라도 훨씬 수월해진다.&lt;/li>
&lt;/ul></description></item><item><title>21. 소리치는 아키텍처</title><link>https://codemario318.github.io/post/clean-architecture/21/</link><pubDate>Tue, 02 Apr 2024 16:19:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/21/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/21/cover.png" alt="Featured image of post 21. 소리치는 아키텍처" />&lt;p>건물의 청사진을 살펴본다고 가정했을 때, 커다란 정문, 체크인과 체크아웃을 담당할 사서를 위한 공간, 독서 공간, 작은 회의실, 책장을 배치한 진열실이 나타난다면, 이 아키텍처는 &amp;ldquo;도서관&amp;quot;을 위한 아키텍처임을 예상해볼 수 있다.&lt;/p>
&lt;p>이처럼 잘 만들어진 소프트웨어 아키텍처라면 상위 수준의 디렉터리 구조, 최상위 패키지에 담긴 소스 파일등을 살펴보면 어떠한 역할을 수행하는 소프트웨어인지 한눈에 파악할 수 있다.&lt;/p>
&lt;h2 id="아키텍처의-테마">아키텍처의 테마&lt;/h2>
&lt;blockquote>
&lt;p>소프트웨어 아키텍처는 시스템의 유스케이스를 지원하는 구조이다.&lt;br>
- 이바 야콥슨 Ivar Jacobson,&lt;br>
Object-Oriented Software Engineering: Use Case Driven Approach&lt;/p>
&lt;/blockquote>
&lt;p>소프트웨어 애플리케이션의 아키텍처도 애플리케이션의 유스케이스에 대해 소리처야한다.&lt;/p>
&lt;ul>
&lt;li>아키텍처는 프레임워크에 대한 것이 아니며 절대로 그래서도 안된다.&lt;/li>
&lt;li>아키텍처를 프레임워크로부터 제공받아서는 절대 안된다.&lt;/li>
&lt;/ul>
&lt;p>프레임워크는 사용하는 도구일 뿐, 아키텍처가 준수해야 할 대상이 아니다.&lt;/p>
&lt;p>아키텍처를 프레임워크 중심으로 만들어버리면 유스케이스가 중심이 되는 아키텍처는 절대 나올 수 없다.&lt;/p>
&lt;h2 id="아키텍처의-목적">아키텍처의 목적&lt;/h2>
&lt;p>좋은 아키텍처는 유스케이스를 그 중심에 두기 때문에, 프레임워크나 도구, 환경에 전혀 구애받지 않고 유스케이스를 지원하는 구조를 아무런 문제 없이 기술할 수 있다.&lt;/p>
&lt;ul>
&lt;li>건물의 청사진의 관심사는 목적에 맞는 공간임을 확실히 하는 것이지, 어떤 기법, 재질로 지어지는지 확인하는 것이 아니다.&lt;/li>
&lt;/ul>
&lt;p>좋은 소프트웨어 아키텍처는 유스케이스에 중점을 두며, 지엽적인 관심사에 대한 결합을 분리시켜 개발 환경 문제나 도구에 대해서는 결정을 미루고, 쉽게 번복할 수 있도록 한다.&lt;/p>
&lt;h2 id="하지만-웹은">하지만 웹은?&lt;/h2>
&lt;p>웹은 전달 메커니즘(입출력 장치)이며, 애플리케이션 아키텍처에서도 그와 같이 취급해야한다.&lt;/p>
&lt;ul>
&lt;li>웹을 통해 전달된다는 사실 자체가 세부 사항이므로, 시스템 구조를 지배해서는 안된다.&lt;/li>
&lt;/ul>
&lt;p>시스템 아키텍처는 과도한 문제를 일으키거나 근본적인 아키텍처를 뜯어고치지 않더라도 시스템을 콘솔 앱, 웹 앱, 리치 클라이언트, 웹서비스 앱등 다양한 방식으로 전달할 수 있어야 한다.&lt;/p>
&lt;h2 id="프레임워크는-도구일-뿐-삶의-방식은-아니다">프레임워크는 도구일 뿐, 삶의 방식은 아니다&lt;/h2>
&lt;p>프레임워크는 매우 강력하고 상당히 유용할 수 있지만, 프레임워크가 아키텍처의 기준이 되서는 안된다.&lt;/p>
&lt;p>좋은 아키텍트라면 아키텍처를 유스케이스에 중점을 둔 채 그대로 보존할 수 있을지를 생각해야 하며, 프레임워크가 아키텍처의 중심을 차지하는 일을 막을 수 있는 전략을 개발해야한다.&lt;/p>
&lt;h2 id="테스트하기-쉬운-아키텍처">테스트하기 쉬운 아키텍처&lt;/h2>
&lt;p>아키텍처가 유스케이스를 최우선으로 하고, 이로인해 프레임워크와는 적당한 거리를 둔다면, 프레임워크를 전혀 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다.&lt;/p>
&lt;ul>
&lt;li>테스트를 돌리는 데 웹 서버가 반드시 필요한 상황이 되어서는 안된다.&lt;/li>
&lt;li>데이터베이스가 반드시 연결되어 있어야만 테스트를 돌릴 수 있어서도 안된다.&lt;/li>
&lt;/ul>
&lt;p>엔티티 객체는 반드시 오래된 방식의 간단한 객체(Plain Old Object)여야 하며, 여타 복잡한 것들에 의존해서는 안된다.&lt;/p>
&lt;p>유스케이스 객체가 엔티티 객체를 조작하도록 해야하며, 최종적으로 프레임워크로 인한 어려움을 겪지 않고도 이 모두를 있는 그래도 테스트할 수 있어야 한다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>아키텍처는 유스케이스를 통해 시스템을 이야기해야 하며, 시스템에 적용한 프레임워크에 대해 이야기해서는 안된다.&lt;/p>
&lt;p>시스템이 어떻게 전달될지 알지 못한 상태에서도 시스템의 모든 유스케이스를 이해할 수 있어야한다.&lt;/p></description></item><item><title>20. 업무 규칙</title><link>https://codemario318.github.io/post/clean-architecture/20/</link><pubDate>Fri, 22 Mar 2024 00:23:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/20/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/20/cover.png" alt="Featured image of post 20. 업무 규칙" />&lt;p>애플리케이션을 업무 규칙과 플러그인으로 구분하려면 업무 규칙이 실제로 무엇인지를 잘 이해해야만 한다.&lt;/p>
&lt;p>&lt;strong>핵심 업무 규칙&lt;/strong>(Critical Business Rule)&lt;/p>
&lt;ul>
&lt;li>업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차이다.&lt;/li>
&lt;li>컴퓨터상으로 구현했는지와 상관없이, 사업적으로 수익을 얻거나 비용을 줄일 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;p>핵심 업무 규칙은 사업 자체에 핵심적이며, 규칙을 자동화하는 시스템이 없더라도 업무 규칙은 그대로 존재한다.&lt;/p>
&lt;p>&lt;strong>핵심 업무 데이터&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>핵심 업무 규칙이 요구하는 데이터&lt;/li>
&lt;li>시스템으로 자동화되지 않은 경우에도 존재하는 데이터이다.&lt;/li>
&lt;/ul>
&lt;p>핵심 규칙과 핵심 데이터는 본질적으로 결함되어 있기 때문에 객체로 만들 좋은 후보가 되며 이러한 유형의 객체를 &lt;strong>엔티티&lt;/strong>(Entity)라고 부른다.&lt;/p>
&lt;h2 id="엔티티">엔티티&lt;/h2>
&lt;p>엔티티는 컴퓨터 시스템 내부의 객체로서, 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화한다.&lt;/p>
&lt;ul>
&lt;li>핵심 업무 데이터를 직접 포함할 수 있다.&lt;/li>
&lt;li>핵심 업무 데이터에 매우 쉽게 접근할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>엔티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/20/img.png"
width="600"
height="279"
srcset="https://codemario318.github.io/post/clean-architecture/20/img_hubc44a445cee9fc3574f155c156bd7117_18299_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/20/img_hubc44a445cee9fc3574f155c156bd7117_18299_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="215"
data-flex-basis="516px"
>&lt;/p>
&lt;p>엔티티를 생성할 때는&lt;/p>
&lt;ul>
&lt;li>업무에서 핵심적인 개념을 구현하는 소프트웨어를 한데 모은다.&lt;/li>
&lt;li>구축 중인 자동화 시스템의 나머지 모든 고려사항과 분리시킨다.&lt;/li>
&lt;/ul>
&lt;p>이 클래스는 업무의 대표자로서 독립적으로 존재한다.&lt;/p>
&lt;p>엔티티는 순전히 업무만을 위한 것이므로 데이터베이스, 사용자 인터페이스, 서드파티 프레임워크에 대한 고려사항들로 인해 오염되어서는 절대 안된다.&lt;/p>
&lt;ul>
&lt;li>어떤 시스템에서도 업무를 수행할 수 있어야 한다.&lt;/li>
&lt;li>시스템의 표현 형식이나 데이터 저장 방식, 시스템에서 컴퓨터가 배치되는 방식과도 무관하다.&lt;/li>
&lt;/ul>
&lt;p>엔티티의 유일한 요구 조건은 &lt;strong>핵심 업무 데이터와 핵심 업무 규칙을 하나로 묶어 별도의 소프트웨어 모듈로 만들어야 한다는 것이다.&lt;/strong>&lt;/p>
&lt;h2 id="유스케이스">유스케이스&lt;/h2>
&lt;p>유스케이스는 &lt;strong>자동화된 시스템이 동작하는 방법을 정의하고 제약함으로써 수익을 얻거나 비용을 줄이는 업무 규칙&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>자동화된 시스템이 사용되는 방법을 설명한다.&lt;/li>
&lt;li>사용자가 제공해야 하는 입력을 기술한다.&lt;/li>
&lt;li>사용자에게 제공해야하는 출력을 기술한다.&lt;/li>
&lt;li>해당 출력을 생성하기 위한 처리 단계를 기술한다.&lt;/li>
&lt;/ul>
&lt;p>엔티티 내의 핵심 업무 규칙과는 반대로, &lt;strong>애플리케이션에 특화된 업무 규칙&lt;/strong>을 설명한다.&lt;/p>
&lt;p>인터페이스로 들어오는 데이터와 인터페이스에서 도될려주는 데이터를 형식 없이 명시한다는 점만 빼면, 유스케이스는 사용자 인터페이스를 기술하지 않는다.&lt;/p>
&lt;p>유스케이스는 시스템이 사용자에게 어떻게 보이는지를 설명하지 않는다.&lt;/p>
&lt;p>애플리케이션에 특화된 규칙을 설명하며, 이를 통해 &lt;strong>사용자와 엔티티 사이의 상호작용을 규정&lt;/strong>한다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션에 특화된 업무 규칙을 구현하는 하나 이상의 함수를 제공한다.&lt;/li>
&lt;li>입력 데이터를 포함한다.&lt;/li>
&lt;li>출력 데이터를 포함한다.&lt;/li>
&lt;li>유스케이스가 상호작용하는 엔티티에 대한 참조 데이터를 포함한다.&lt;/li>
&lt;/ul>
&lt;p>유스케이스는 단일 애플리케이션에 특화되어 있으며, 따라서 해당 시스템의 입력과 출력에 보다 가깝게 위치하므로, 엔티티와 같은 고수준 개념은 유스케이스와 같은 저수준 개념에 대해 아무것도 알지 못한다.&lt;/p>
&lt;p>즉, 유스케이스는 엔티티에 의존하며, 엔티티는 유스케이스에 의존하지 않는다.&lt;/p>
&lt;h2 id="요청-및-응답-모델">요청 및 응답 모델&lt;/h2>
&lt;p>유스케이스는 입력 데이터를 받아서 출력 데이터를 생성한다.&lt;/p>
&lt;p>하지만 제대로 구성된 유스 케이스 객체라면 데이터를 사용자나 또 다른 컴포넌트와 주고 받는 방식에 대해서는 전혀 눈치챌 수 없어야 한다.&lt;/p>
&lt;p>유스케이스는 단순한 요청 데이터 구조를 입력으로 받아들이고 단순한 응답 데이터 구조를 출력으로 반환하는 역할만 수행하며, 이러한 데이터 구조는 어떤것에도 의존하지 않아야 한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>HttpRequest&lt;/code>, &lt;code>HttpResponse&lt;/code> 등&lt;/li>
&lt;/ul>
&lt;p>요청 및 응답 모델이 독립적이지 않다면 그 모델에 의존하는 유스케이스도 결국 해당 모델이 수반하는 의존성에 간접적으로 결합이 되므로 의존성을 제거해야 한다.&lt;/p>
&lt;hr>
&lt;p>엔티티와 요청/응답 모델은 많은 데이터를 공유하므로 엔티티의 참조를 요청/응답 데이터 구조에 포함하려는 유혹을 받을 수 있다.&lt;/p>
&lt;p>하지만 두 객체의 목적은 완전히 다르므로, 시간이 지남에 따라 다른 이유로 변경될 것이다.&lt;/p>
&lt;p>따라서 어떤 식으로든 함께 묶는 행위는 공통 폐쇄 원칙과 단일 책임 원칙을 위배하게 되며, 결국 코드에는 수많은 떠돌이 데이터가 만들어지고, 이로인해 수많은 조건문이 추가되어 버린다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>업무 규칙은 소프트웨어 시스템이 존재하는 이유, 핵심적인 기능이다.&lt;/p>
&lt;p>업무 규칙은 수익을 내고 비용을 줄이는 코드를 수반하는 매우 중요한 요소이다.&lt;/p>
&lt;p>따라서 사용자 인터페이스나 데이터베이스와 같은 저수준의 관심사로 인해 오염되어서는 안 되며, 원래 그대로의 모습으로 남아 있어야 한다.&lt;/p>
&lt;p>이상적으로는 업무 규칙을 표현하는 코드는 반드시 시스템의 심장부에 위치해야 하며, 덜 중요한 코드는 이 심장부에 플러그인되어야 한다.&lt;/p>
&lt;p>&lt;strong>업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드여야 한다.&lt;/strong>&lt;/p></description></item><item><title>19. 정책과 수준</title><link>https://codemario318.github.io/post/clean-architecture/19/</link><pubDate>Thu, 21 Mar 2024 23:41:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/19/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/19/cover.png" alt="Featured image of post 19. 정책과 수준" />&lt;p>소프트웨어 시스템이란 정책을 기술한 것이다.&lt;/p>
&lt;p>컴퓨터 프로그램은 각 입력을 출력으로 변환하는 정책을 상세하게 기술한 설명서이다.&lt;/p>
&lt;p>대다수의 주요 시스템에서 하나의 정책은 이 정책을 서술하는 여러 개의 조그만 정책들로 쪼갤 수 있다.&lt;/p>
&lt;p>소프트웨어 아키텍처를 개발하는 기술에는 정책을 신중하게 분리하고, 정책이 변경되는 양상에 따라 정책을 재편성하는 일도 포함된다.&lt;/p>
&lt;ul>
&lt;li>동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며, 동일한 컴포넌트에 속해야 한다.&lt;/li>
&lt;li>서로 다른 이유, 다른 시점에 변경되는 정책은 다른 수준에 위치하며, 반드시 컴포넌트로 분리해야 한다.&lt;/li>
&lt;/ul>
&lt;p>아키텍처 개발은 재편성된 컴포넌트들을 비순환 방향 그래프(directed acyclic graph)로 구성하는 기술을 포함한다.&lt;/p>
&lt;ul>
&lt;li>정점(node): 동일한 수준의 정책을 포함하는 컴포넌트&lt;/li>
&lt;li>간선(edge): 컴포넌트 사이의 의존성&lt;/li>
&lt;/ul>
&lt;p>좋은 아키텍처라면 각 컴포넌트를 연결할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계해야 한다.&lt;/p>
&lt;h2 id="수준">수준&lt;/h2>
&lt;p>수준(level)은 &lt;strong>입력과 출력까지의 거리&lt;/strong>로 정의할 수 있다.&lt;/p>
&lt;p>시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아지며, 입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치한다.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/19/img.png"
width="1400"
height="738"
srcset="https://codemario318.github.io/post/clean-architecture/19/img_hu0cccb83cda5e1cfc944d8b5720341535_354495_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/19/img_hu0cccb83cda5e1cfc944d8b5720341535_354495_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="189"
data-flex-basis="455px"
>&lt;/p>
&lt;p>간단한 암호화 프로그램의 설계 예시 처럼 프로그램을 제대로 설계했다면 소스 코드 의존성은 곧은 점선처럼 표시되어야 한다.&lt;/p>
&lt;p>&lt;code>Translate&lt;/code> 컴포넌트는 입력과 출력에서 가장 멀리 떨어져 있으므로 최고 수준의 컴포넌트이다.&lt;/p>
&lt;p>굽은 실선은 데이터의 흐름을 나타내는데, 보는 것과 같이 데이터 흐름과 소스 코드 의존성이 항상 같은 방향을 가리키지는 않는다.&lt;/p>
&lt;ul>
&lt;li>소스 코드 의존성은 그 수준에 따라 결합되어야 하며, 데이터 흐름을 기준으로 결합되어서는 안된다는 것이다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">function encrypt() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while(true)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> writeChar(translate(readChar()));
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위와 같은 예시는 고수준인 &lt;code>encrypt&lt;/code> 함수가 저수준인 &lt;code>readChar&lt;/code>, &lt;code>writeChar&lt;/code> 함수에 의존하기 때문에 잘못된 아키텍처이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/19/img_1.png"
width="672"
height="560"
srcset="https://codemario318.github.io/post/clean-architecture/19/img_1_hu3792ba83091153c640e2b5a2eab1f46a_335401_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/19/img_1_hu3792ba83091153c640e2b5a2eab1f46a_335401_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="288px"
>&lt;/p>
&lt;p>&lt;code>Encrypt&lt;/code> 클래스, &lt;code>CharWriter&lt;/code>와 &lt;code>CharReader&lt;/code> 인터페이스를 둘러싸고 있는 점선으로 된 경계로 묶인 영역이 이 시스템에서 최고 수준의 구성요소이며, 횡단하는 의존성은 모두 경계 안쪽으로 향한다.&lt;/p>
&lt;p>입력과 출력에 변화가 생기더라도 암호화 정책은 거의 영향을 받지 않기 때문에, 고수준의 암호화 정책을 저수준의 입력/출력 정책으로 부터 분리시켜 암호화 정책을 더 넓은 맥락에서 사용할 수 있다.&lt;/p>
&lt;hr>
&lt;p>정책을 컴포넌트로 묶는 기준은 정책이 변경되는 방식에 달려있다.&lt;/p>
&lt;p>단일 책임 원칙(SRP)과 공통 폐쇄 원칙(CCP)에 따르면 동일한 이유로 동일한 시점에 변경되는 정책은 함께 묶인다.&lt;/p>
&lt;ul>
&lt;li>고수준 정책: 입력/출력에서부터 멀리 떨어진 정책
&lt;ul>
&lt;li>저수준 정책에 비해 덜 빈번하게 변경된다.&lt;/li>
&lt;li>보다 중요한 이유로 변경된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>저수준 정책: 입력과 출력에 가까운 정책
&lt;ul>
&lt;li>더 빈빈하게 변경된다.&lt;/li>
&lt;li>긴급성을 요하며, 덜 중요한 이유로 변경된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이처럼 소스 코드 의존성 방향이 고수준 정책을 향할 수 있도록 정책을 분리했다면 변경의 영향도를 줄일 수 있다.&lt;/p>
&lt;ul>
&lt;li>시스템의 최저 수준에서 중요하지 않지만 긴급한 변경이 발생하더라도, 중요한 수준에 미치는 영향이 거의 없게 된다.&lt;/li>
&lt;/ul>
&lt;p>이는 저수준 컴포넌트가 고수준 컴포넌트에 플러그인되어야 한다는 관점으로도 바라볼 수 있다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>정책을 분리하는 것은 단일 책임 원칙, 개방 폐쇄 원칙, 공통 폐쇄 원칙, 의존성 역전 원칙, 안정된 의존성 원칙, 안정된 추상화 원칙을 모두 포함한다.&lt;/p></description></item><item><title>18. 경계 해부학</title><link>https://codemario318.github.io/post/clean-architecture/18/</link><pubDate>Thu, 21 Mar 2024 15:36:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/18/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/18/cover.png" alt="Featured image of post 18. 경계 해부학" />&lt;p>시스템 아키텍처는 일련의 소프트웨어 퀌포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의된다.&lt;/p>
&lt;p>이러한 경계는 다양한 형태로 나타난다.&lt;/p>
&lt;h2 id="경계-횡단하기">경계 횡단하기&lt;/h2>
&lt;p>&amp;lsquo;런타임에 경계를 횡단한다&amp;rsquo;는 의미는 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일에 불과하다.&lt;/p>
&lt;p>적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다.&lt;/p>
&lt;ul>
&lt;li>소스 코드 모듈 하나의 변경으로 읜존하는 다른 소스 코드 모듈을 변경하거나, 다시 컴파일해서 새로 배포해야 할 지도 모르기 때문&lt;/li>
&lt;/ul>
&lt;p>경계는 소스 코드 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단으로써 존재한다.&lt;/p>
&lt;h2 id="두려운-단일체">두려운 단일체&lt;/h2>
&lt;p>아키텍처 경계 중 가장 단순하며 흔한 형태는 물리적으로 엄격하게 구분되지 않는 형태다.&lt;/p>
&lt;p>이는 앞서 언급했던 소스 수준 분리 모드로, 함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며 나름의 규칙에 따라 분리되어있는 상태이다.&lt;/p>
&lt;p>배포 관점에서 이는 단일체(monolith)라고 불리는 단일 실행 파일이므로, 외부에서 볼 때(물리적으로) 경계가 밖으로 드러나지는 않는다.&lt;/p>
&lt;p>가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/18/img.png"
width="878"
height="328"
srcset="https://codemario318.github.io/post/clean-architecture/18/img_hu33eeba12431c5bf1806d35e4e7b8ce12_88436_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/18/img_hu33eeba12431c5bf1806d35e4e7b8ce12_88436_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="267"
data-flex-basis="642px"
>&lt;/p>
&lt;p>이 경우 런타임 의존성과 컴파일타임 의존성은 모두 저수준 컴포넌트에서 고수준 컴포넌트로 향한다.&lt;/p>
&lt;hr>
&lt;p>고수준 클라이언트가 저수준 서비스를 호출해야 한다면 동적 다형성을 사용하여 제어흐름과는 반대 방향으로 의존성을 역전시킬 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/18/img_1.png"
width="886"
height="326"
srcset="https://codemario318.github.io/post/clean-architecture/18/img_1_hu4203ca497a373869a2b5425ba45e2e20_90287_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/18/img_1_hu4203ca497a373869a2b5425ba45e2e20_90287_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="271"
data-flex-basis="652px"
>&lt;/p>
&lt;p>경계를 횡단할 때 의존성은 모두 고수준 컴포넌트를 향하고 있으며, 데이터 구조의 정의가 호출하는 쪽에 위치한다.&lt;/p>
&lt;hr>
&lt;p>정적 링크된 모노리틱 구조의 실행 파일이라도 규칙적인 방식으로 구조를 분리하면 프로젝트를 개발, 테스트, 배포하는 작업에 큰 도움이 된다.&lt;/p>
&lt;p>단일체에서 컴포넌트간 통신은 전형적인 함수 호출에 지나지 않으므로 매우 빠르고 값싸며, 이러한 이유로 소스 수준에서 결합이 분리되면 경계를 가로지르는 통신은 상당히 빈번할 수 있다.&lt;/p>
&lt;h2 id="배포형-컴포넌트">배포형 컴포넌트&lt;/h2>
&lt;p>아키텍처의 경계가 물리적으로 드러날 수도 있는데 그중 가장 단순한 형태는 동적 링크 라이브러리다.&lt;/p>
&lt;p>이는 배포 수준 결합 분리 모드에 해당하며 컴포넌트를 동적 링크 라이브러리 형태로 배포하면 따로 컴파일하지 않고 곧바로 사용할 수 있는 대신 바이너리와 같이 배포 가능한 형태로 전달된다.&lt;/p>
&lt;p>배포 관점에서 이러한 형태는 단순히 배포 가능한 단위를 좀 더 편리한 형태로 묶으므로, 단일체와 동일하다.&lt;/p>
&lt;ul>
&lt;li>모든 함수가 동일한 프로세서와 주소 공간에 위치하며, 컴포넌트 간 의존성을 관리하는 전략도 동일하다.&lt;/li>
&lt;/ul>
&lt;p>단일체와 마찬가지로 경계를 가로지르는 통신은 함수 호출에 지나지 않으므로 값싸기 때문에, 경계를 가로지르는 통신은 대체로 매우 빈번하다.&lt;/p>
&lt;h2 id="스레드">스레드&lt;/h2>
&lt;p>스레드는 아키텍처 경계도 아니며 배포 단위도 아니다.&lt;/p>
&lt;p>단일체와 배포형 컴포넌트 모두 스레드를 활용할 수 있다.&lt;/p>
&lt;p>스레드는 실행 계획과 순서를 체계화 하는 방법에 가까우며, 모든 스레드가 단 하나의 컴포넌트에 포함될 수도 있고, 분산될 수도 있다.&lt;/p>
&lt;h2 id="로컬-프로세스">로컬 프로세스&lt;/h2>
&lt;p>로컬 프로세스는 이전 언급한 경계보다 훨씬 강한 물리적 형태를 띈다.&lt;/p>
&lt;p>주로 명령행이나 그와 유사한 시스템 호출을 통해 생성되고, 동일한 프로세서 또는 하나의 멀티코어 시스템에 속한 여러 프로세서들에서 실행되지만, 독립된 주소 공간에서 실행된다.&lt;/p>
&lt;p>종종 공유 메모리 파티션을 사용하기도 하지만, 일반적으로는 메모리 보호를 통해 프로세스들이 메모리를 공유하지 못하게 한다.&lt;/p>
&lt;p>대개의 경우 소켓, 메일박스, 메시지 큐와 같이 운영체제에서 제공하는 통신 기능을 이용하여 서로 통신한다.&lt;/p>
&lt;hr>
&lt;p>각 로컬 프로세스는 정적으로 링크된 단일체 이거나 동적으로 링크된 여러개의 컴포넌트로 구성될 수 있다.&lt;/p>
&lt;ul>
&lt;li>정적으로 링크된 단일체
&lt;ul>
&lt;li>여러 모노리틱 프로세스가 같은 컴포넌트들을 가지고 있을 수 있다.&lt;/li>
&lt;li>컴파일하고 정적 링크하는 과정에서 각 컴포넌트의 바이너리가 단일체에 물리적으로 복사되기때문&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>동적으로 링크된 배포형 컴포넌트
&lt;ul>
&lt;li>동적으로 링크된 배포형 컴포넌트들을 서로 공유할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>로컬 프로세스는 컴포넌트 간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트로 구성되므로 일종의 최상위 컴포넌트로 볼 수 있다.&lt;/p>
&lt;p>로컬 프로세스 간 분리 전략은 단일체나 바이너리 컴포넌트의 경우와 동일하다.&lt;/p>
&lt;p>소스 코드 의존성은 고수준 컴포넌트를 향해야하므로 로컬 프로세스에서는 고수준 프로세스의 소스 코드가 저수준 프로세스의 이름, 물리 주소, 레지스트리 조회 키를 절대로 포함해서는 안된다.&lt;/p>
&lt;p>로컬 프로세스 경계를 지나는 통신에는 운영체제 호출, 데이터 마샬링, 언마샬링, 프로세스 간 문맥 교환 등이 있으며, 이들은 제법 비싼 작업이므로 통신이 너무 빈번하게 이뤄지지 않도록 신중하게 제한해야한다.&lt;/p>
&lt;h2 id="서비스">서비스&lt;/h2>
&lt;p>물리적인 형태를 띠는 가장 강력한 경계는 서비스다.&lt;/p>
&lt;p>서비스는 프로세스로, 일반적으로 명령행 또는 그와 동등한 시스템 호출을 통해 구동된다.&lt;/p>
&lt;p>서비스들은 모든 통신이 네트워크를 통해 이뤄진다고 가정하므로 자신의 물리적 위치에 구애받지 않는다.&lt;/p>
&lt;p>서비스 경계를 지나는 통신은 함수 호출에 매우 느리므로 가능하다면 빈번하게 통신하는 일을 피해야 하며, 지연(latency)에 따른 문제를 고수준에서 처리할 수 있어야 한다.&lt;/p>
&lt;p>이를 제외하고는 로컬 프로세스에 적용한 규칙이 서비스에 적용된다.&lt;/p>
&lt;p>저수준 서비스는 반드시 고수준 서비스에 &lt;strong>플러그인&lt;/strong>되어야하며, 고수준 서비스의 소스 코드에는 저수준 서비스를 특정 짓는 어떤 물리적인 정보(URI 등)도 절대로 포함해서는 안된다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.&lt;/p>
&lt;p>실제로 서비스는 상호작용하는 일련의 로컬 프로세스 퍼사드에 불과할 때가 많다.&lt;/p>
&lt;p>또한 개별 서비스 또는 로컬 프로세스는 거의 언제나 소스 코드 컴포넌트로 구성된 단일체이거나, 동적으로 링크된 배포형 컴포넌트의 집합이다.&lt;/p>
&lt;p>즉, 한 시스템 안에서도 통신이 빈번한 로컬 경계와 지연을 중요하게 고려해야 하는 경계가 혼합되어 있음을 의미한다.&lt;/p></description></item><item><title>17. 경계: 선 긋기</title><link>https://codemario318.github.io/post/clean-architecture/17/</link><pubDate>Wed, 20 Mar 2024 21:36:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/17/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/17/cover.png" alt="Featured image of post 17. 경계: 선 긋기" />&lt;p>소프트웨어 아키텍처는 선을 긋는 기술이며, 이러한 선을 &lt;strong>경계&lt;/strong>(Boundary)라고 부른다.&lt;/p>
&lt;p>경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 소소가 반대편에 있는 요소를 알지 못하도록 막는다.&lt;/p>
&lt;p>이 중 초기에 그려지는 선은 &lt;strong>가능한 한 오랫동안 결정을 연기&lt;/strong>시키기고, 결정이 핵심적인 업무 로직을 &lt;strong>오염시키지 못하게 만들려는 목적&lt;/strong>으로 쓰인다.&lt;/p>
&lt;p>아키텍트의 목표는 시스템을 만들고 유지하는 데 드는 자원을 최소화 하는 것인데, 효율을 떨어뜨리는 요인은 &lt;strong>결합&lt;/strong>(Coupling)이며, &lt;strong>너무 일찍 내려진 결정에 따른 결합은 더 큰 영향&lt;/strong>을 미친다.&lt;/p>
&lt;p>너무 일찍 내려진 결정은 시스템의 업무 요구사항, 즉 유스케이스와 아무런 관련이 없는 결정을 의미한다.&lt;/p>
&lt;ul>
&lt;li>프레임워크&lt;/li>
&lt;li>데이터베이스&lt;/li>
&lt;li>웹 서버&lt;/li>
&lt;li>유틸리티 라이브러리&lt;/li>
&lt;li>의존성 주입에 대한 결정 등&lt;/li>
&lt;/ul>
&lt;p>좋은 시스템 아키텍처란 유스케이스와 아무런 관련이 없는 결정에 의존하지 않아 이러한 결정이 부수적이며, 연기할 수 있는 아키텍처다.&lt;/p>
&lt;p>경계선을 긋는 행위는 결정을 늦추고 연기하는 데 도움이되며, 궁극적으로는 시간을 엄청나게 절약해주었으며, 골치를 썩지 않게 해준다.&lt;/p>
&lt;h2 id="어떻게-선을-그을까-언제-그을까">어떻게 선을 그을까? 언제 그을까?&lt;/h2>
&lt;p>관련이 있는 것과 없는 것 사이에 선을 긋는다.&lt;/p>
&lt;ul>
&lt;li>GUI는 업뮤 규칙과는 관련 없기 때문에, 둘 사이에는 반드시 선이 있어야한다.&lt;/li>
&lt;li>데이터베이스는 GUI와는 고나련이 없으므로, 둘 사이에는 반드시 선이 있어야한다.&lt;/li>
&lt;li>데이터베이스는 업무 규칙과 관련이 없으므로, 둘 사이에도 선이 있어야한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>데이터베이스는 업무 규칙과 서로 떼어놓을 수 없는 관계라고 배운 사람이 많으며, 심지어 업무 규칙이 구체화된 것이 데이터베이스라고 확신하는 사람도 더러 있지만 이는 잘못된 생각이다.&lt;/p>
&lt;p>업무 규칙은 데이터를 가져오고 저장할 때 사용할 수 있는 함수 집합이 있다는 사실이 전부여야한다.&lt;/p>
&lt;p>이러한 함수 집합을 통해 데이터베이스를 인터페이스 뒤로 숨길 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/17/img.png"
width="407"
height="281"
srcset="https://codemario318.github.io/post/clean-architecture/17/img_hu673cbb09eeb85c8e13222d62fdbc3a4e_65890_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/17/img_hu673cbb09eeb85c8e13222d62fdbc3a4e_65890_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클래스 경계선"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;p>&lt;code>DatabaseAccess&lt;/code>에서 출발하는 화살표는 클래스로부터 바깥쪽으로 향하는데 이는 &lt;code>DatabaseAccess&lt;/code>가 존재하는 클래스는 없다는 의미이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/17/img_1.png"
width="401"
height="283"
srcset="https://codemario318.github.io/post/clean-architecture/17/img_1_hub12dd706ba5018e7ec9bc226af343837_66166_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/17/img_1_hub12dd706ba5018e7ec9bc226af343837_66166_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="컴포넌트 경계선"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="340px"
>&lt;/p>
&lt;p>&lt;code>DatabaseInterface&lt;/code> 클래스는 &lt;code>BusinessRules&lt;/code> 컴포넌트에 속하며, &lt;code>DatabaseAccess&lt;/code> 클래스는 &lt;code>Database&lt;/code> 컴포넌트에 속하므로, &lt;code>Database&lt;/code>는 &lt;code>BusinessRules&lt;/code>에 대해 알고있지만, &lt;code>BusinessRules&lt;/code>은 &lt;code>Database&lt;/code>에 관해 알지 못한다.&lt;/p>
&lt;p>따라서 &lt;code>BusinessRules&lt;/code>에게 있어 &lt;code>Database&lt;/code>는 문제가 되지 않지만, &lt;code>Database&lt;/code>는 &lt;code>BusinessRules&lt;/code> 없이는 존재할 수 없다.&lt;/p>
&lt;hr>
&lt;p>&lt;code>Database&lt;/code> 컴포넌트는 &lt;code>BusinessRules&lt;/code>가 만들어 낸 호출을 데이터베이스의 쿼리 언어로 변환하는 코드를 담고 있으며, 이 변환 코드가 &lt;code>BusinessRules&lt;/code>를 알고 있는 것이다.&lt;/p>
&lt;p>두 컴포넌트 사이에 경계선, 화살표의 방향이 &lt;code>BusinessRules&lt;/code>를 향하도록 만들었기 때문에 어떤 종류의 데이터베이스도 사용할 수 있게된다.&lt;/p>
&lt;p>따라서 데이터베이스에 대한 결정을 연기할 수 있으며, 데이터베이스를 결정하기에 앞서 업무 규칙을 먼저 작성하고 테스트하는 데 집중할 수 있다.&lt;/p>
&lt;h2 id="입력과-출력은">입력과 출력은?&lt;/h2>
&lt;p>입력과 출력은 중요하지않다.&lt;/p>
&lt;p>시스템의 행위를 입출력이 지닌 행위적 측면에서 생각하는 경향이 있는데, 이러한 입출력 뒤에는 모델(데이터 구조와 함수로 구성된 정교한 집합)이 존재한다는 사실을 잊는다.&lt;/p>
&lt;p>이러한 모델은 GUI가 없이도 동작할 수 있으므로 중요하지 않고, 실제로 중요한 것은 &lt;strong>업무 규칙&lt;/strong>이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/17/img_2.png"
width="401"
height="275"
srcset="https://codemario318.github.io/post/clean-architecture/17/img_2_huca1b9f1dde324acc9010f81287c21632_63448_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/17/img_2_huca1b9f1dde324acc9010f81287c21632_63448_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="349px"
>&lt;/p>
&lt;p>&lt;code>GUI&lt;/code> 컴포넌트는 &lt;code>BusinessRules&lt;/code> 컴포넌트에게 의존하기 때문에 경계선으로 분할할 수 있다.&lt;/p>
&lt;p>따라서 &lt;code>GUI&lt;/code>는 다른 종류의 인터페이스로 얼마든지 교체할 수 있으며 &lt;code>BusinessRules&lt;/code>에 끼치는 영향은 없다.&lt;/p>
&lt;h2 id="플러그인-아키텍처">플러그인 아키텍처&lt;/h2>
&lt;p>데이터베이스와 GUI에 대해 내린 두 가지 결정을 하나로 합쳐서 보면 컴포넌트 추가와 관련한 일정의 패턴이 만들어진다.&lt;/p>
&lt;p>소프트웨어 개발 기술의 역사는 프러그인을 손쉽게 생성하여, 확장 가능하며 유지보수가 쉬운 시스템 아키텍처를 확립할 수 있게 만드는 방법에 대한 이야기이다.&lt;/p>
&lt;ul>
&lt;li>선택적이거나 또는 수많은 다양한 형태로 구현될 수 있는 나머지 컴포넌트로부터 핵심적인 업무 규칙은 분리되어 있고, 또한 독립적이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/17/img_3.png"
width="411"
height="276"
srcset="https://codemario318.github.io/post/clean-architecture/17/img_3_hu6d5ed14c5677eea0e6c3298e2ee307eb_74568_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/17/img_3_hu6d5ed14c5677eea0e6c3298e2ee307eb_74568_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="148"
data-flex-basis="357px"
>&lt;/p>
&lt;p>위와 같은 설계에서 사용자 인터페이스는 플러그인 형태로 고려되었기에, 수많은 종류의 사용자 인터페이스를 플러그인 형태로 연결할 수 있게 된다.&lt;/p>
&lt;p>데이터베이스도 동일하게 적용할 수 있다.&lt;/p>
&lt;p>GUI, 데이터베이스 등의 교체 작업이 쉬운 작업은 아니고, 업무 규칙 활용을 위해 추가적인 작업도 필요할 수 있지만, 플러그인 구조를 가정한 채 시작함으로써, 이러한 변경 작업을 현실성 있도록 만든다.&lt;/p>
&lt;h2 id="플러그인에-대한-논의">플러그인에 대한 논의&lt;/h2>
&lt;p>시스템을 플러그인 아키텍처로 배치함으로써 변경이 전파될 수 없는 방화벽을 생성할 수 있다.&lt;/p>
&lt;p>경계는 &lt;strong>변경의 축&lt;/strong>(Axis of change)이 있는 지점에 그어진다. 그리고 경계의 한쪽에 위치한 컴포넌트는 경계 반대편의 컴포넌트와는 다른 속도로, 다른 이유로 변경된다.&lt;/p>
&lt;p>따라서 다른 시점에 다른 속도로 변경되는 둘 사이에는 반드시 경계가 필요하다.&lt;/p>
&lt;p>이 역시도 단일 책임 원칙에 해당하며, 단일 책임 원칙은 어디에 경계를 그어야 할지 알려준다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>소프트웨어 아키텍처에서 경계선을 그리려면&lt;/p>
&lt;ol>
&lt;li>
&lt;p>먼저 시스템을 컴포넌트 단위로 분할해야한다.&lt;/p>
&lt;ul>
&lt;li>일부 컴포넌트는 핵심 업무 규칙에 해당한다.&lt;/li>
&lt;li>나머지 컴포넌트는 플러그인으로 핵심 업무와는 직접적인 관련이 없지만 필수 기능을 포함한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>컴포넌트 사이의 화살표가 핵심 업무를 향하도록 컴포넌트의 소스를 배치한다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>이는 의존성 역전 원칙과 안정된 추상화 원칙을 응용한 것이며, 의존성의 화살표는 저수준 세부사항에서 고수준의 추상화를 향하도록 배치된다.&lt;/p></description></item><item><title>16. 독립성</title><link>https://codemario318.github.io/post/clean-architecture/16/</link><pubDate>Wed, 13 Mar 2024 14:51:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/16/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/16/cover.png" alt="Featured image of post 16. 독립성" />&lt;p>좋은 아키텍처는 다음을 지원해야한다.&lt;/p>
&lt;ul>
&lt;li>시스템의 유스케이스&lt;/li>
&lt;li>시스템의 운영&lt;/li>
&lt;li>시스템의 개발&lt;/li>
&lt;li>시스템의 배포&lt;/li>
&lt;/ul>
&lt;h2 id="유스케이스">유스케이스&lt;/h2>
&lt;p>시스템의 아키텍처는 시스템의 의도를 지원해야 한다는 뜻이다.&lt;/p>
&lt;p>실제로 아키텍트의 최우선 관심사는 유스케이스이며, 아키텍처에서도 유스케이스가 최우선이다. 따라서 아키텍처는 반드시 유스케이스를 지원해야한다.&lt;/p>
&lt;p>아키텍처는 시스템의 행위 차제에는 큰 영향을 주지 않으며, 행위와 관련하여 아키텍처가 열어둘 수 있는 선택사항의 거의 없다.&lt;/p>
&lt;p>하지만, 아키텍처의 시스템의 행위에 대한 직접적인 영향력과 별개로 좋은 아키텍처는 시스템의 행위를 지원할 수 있다.&lt;/p>
&lt;ul>
&lt;li>행위를 명확히 하고 외부로 드러낸다.&lt;/li>
&lt;li>이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만든다.&lt;/li>
&lt;/ul>
&lt;p>좋은 아키텍처를 가진다면 시스템의 유스케이스는 시스템 구조 자체에서 한눈에 드러난다.&lt;/p>
&lt;ul>
&lt;li>이러한 시스템의 &lt;strong>행위&lt;/strong>는 &lt;strong>일급 요소 first-class element&lt;/strong>이며 시스템의 최상위 수준에서 알아볼 수 있으므로, 개발자가 일일이 찾아 헤매이지 않아도 된다.&lt;/li>
&lt;li>이들 요소는 클래스이거나 함수 또는 모듈러서 아키텍처 내에서 핵심적인 자리를 차지할 뿐만 아니라, 자신의 기능을 분명하게 설명하는 이름을 가져야한다.&lt;/li>
&lt;/ul>
&lt;h2 id="운영">운영&lt;/h2>
&lt;p>시스템의 운영 지원 관점에서 볼 때 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡는다.&lt;/p>
&lt;p>&lt;strong>예시&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>시스템이 초당 100,000명의 고객을 처리해야 한다면, 아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞은 처리량과 응답시간을 보장해야 한다.&lt;/li>
&lt;li>시스템에서 수 밀리초 안에 3차원의 빅데이터 테이블에 질의해야 한다면, 반드시 이러한 운영 작업을 허용할 수 있는 형태로 아키텍처를 구조화해야한다.&lt;/li>
&lt;/ul>
&lt;p>예시와 같이 &lt;strong>형태를 지원&lt;/strong>한다는 말은 다양한 의미를 지닌다.&lt;/p>
&lt;ul>
&lt;li>시스템의 처리 요소를 일련의 작은 서비스들로 배열하여, 서로 다른 많은 서버에서 병렬로 실행할 수 있는 시스템&lt;/li>
&lt;li>경량의 수많은 스레드가 단일 프로세서에서 같은 주소 공간을 공유하는 시스템&lt;/li>
&lt;li>독립된 주소 공간에서 실행되는 소수의 프로세스만으로도 충분한 시스템&lt;/li>
&lt;li>단일 프로세스에서 실행되는 단순한 모노리틱 프로그램&lt;/li>
&lt;/ul>
&lt;p>위와 같은 운영 관점의 아키텍처 결정은 뛰어난 이키텍트라면 열어두어야 하는 선택 사항 중의 하나다.&lt;/p>
&lt;p>아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.&lt;/p>
&lt;h2 id="개발">개발&lt;/h2>
&lt;p>아키텍처는 개발환경을 지원하는데 있어 핵심적인 역할을 수행한다.&lt;/p>
&lt;blockquote>
&lt;p>시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.&lt;br>
- 콘웨이 법칙 -&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>많은 팀으로 구성되며 관심사가 다양한 조직에서 어떤 시스템을 개발해야 한다면, 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 팀들이 서로 방해하지 않도록 해야 한다.&lt;/li>
&lt;li>잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할 할 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="배포">배포&lt;/h2>
&lt;p>아키텍처는 배포 용이성(&lt;strong>즉각적인 배포 immediate deployment&lt;/strong>)을 결정하는 데 중요한 역할을 한다.&lt;/p>
&lt;p>좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.&lt;/p>
&lt;ul>
&lt;li>수십 개의 작은 설정 스크립트나 속성 파일을 약간씩 수정하는 방식을 사용하지 않는다.&lt;/li>
&lt;li>꼭 필요한 디렉터리나 파일을 수작업으로 생성하게 내버려 두지 않는다.&lt;/li>
&lt;/ul>
&lt;p>이러한 아케텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다.&lt;/p>
&lt;p>마스터 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야 한다.&lt;/p>
&lt;h2 id="선택사항-열어놓기">선택사항 열어놓기&lt;/h2>
&lt;p>좋은 아키텍처는 컴포넌트 구조와 관련된 이 관심사들 사이에서 균형을 맞추고, 각 관심사 모두를 만족시켜야 하지만, 현실에서는 이러한 균형을 잡기가 매우 어렵다.&lt;/p>
&lt;ul>
&lt;li>모든 유스케이스를 알 수는 없다.&lt;/li>
&lt;li>운영하는 데 따르는 제약사항, 팀 구조, 배포 요구사항을 알지 못한다.&lt;/li>
&lt;li>이러한 사항들을 알고 있더라도, 시스템이 생명주기의 단계를 하나씩 거쳐감에 따라 이 사항들도 반드시 변한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>도달하려는 목표는 뚜렷하지 않을 뿐만 아니라 시시각각 변한다.&lt;/strong>&lt;/p>
&lt;p>이러한 변화속에서도 몇몇 아키텍처 원칙을 구현하는 비용이 비교적 비싸지 않으며, 이를 통해 관심사들 사이에서 균형을 잡는데 도움이 된다는 사실은 변하지 않는다.&lt;/p>
&lt;ul>
&lt;li>균형을 맞추려는 목표점을 명확히 그릴 수 없는 경우에도 관심사들 사이에서 균형을 잡는 데 도움이 된다.&lt;/li>
&lt;li>시스템을 제대로 격리된 컴포넌트 단위로 분할할 때 도움이 된다.&lt;/li>
&lt;li>이를 통해 선택사항을 가능 한 많이, 가능한 오랫동안 열어 둘 수 있게 해준다.&lt;/li>
&lt;/ul>
&lt;p>좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.&lt;/p>
&lt;h2 id="계층-결합-분리">계층 결합 분리&lt;/h2>
&lt;p>UI, 애플리케이션 자체와 밀접한 업무 규칙과, 도메인에 밀접한 업무 규칙, 기술적인 세부사항 등은 각자 다른 속도로, 다른 이유로 변경되므로 서로 분리하고, 독립적으로 변경할 수 있도록 만들어야만 한다.&lt;/p>
&lt;p>업무 규칙은 그 자체가 애플리케이션과 밀접한 관련이 있거나, 혹은 더 범용적일 수 있는데, 아키텍트는 이들을 시스템의 나머지 부분으로부터 분리하여 독립적으로 변경할 수 있도록 해야한다.&lt;/p>
&lt;ul>
&lt;li>입력 필드 유효성 검사는 애플리케이션 자체와 밀접하게 관련된 업무 규칙이다.&lt;/li>
&lt;li>계좌의 이자 계산이나 재고품 비교는 업무 도메인에 더 밀접하게 연관된 업무 규칙이다.&lt;/li>
&lt;/ul>
&lt;p>이러한 계층의 예로는 UI, 애플리케이션에 특화된 업무 규칙, 애플리케이션과는 독립접인 업무 규칙, 데이터베이스와 같은 기술적인 세부사항등이 있다.&lt;/p>
&lt;h2 id="유스케이스-결합-분리">유스케이스 결합 분리&lt;/h2>
&lt;p>유스케이스 자체도 서로 다른 이유로 변경될 수 있다.&lt;/p>
&lt;ul>
&lt;li>예) 주문 입력 시스템의 주문 추가 유스케이스와 주문 삭제 유스케이스&lt;/li>
&lt;/ul>
&lt;p>유스케이스는 시스템의 수평적인 계층을 가르지르도록 자른 수직으로 좁다란 조각이기도 하다.&lt;/p>
&lt;ul>
&lt;li>각 유스케이스는 UI의 일부, 애플리케이션 특화 업무 규칙의 일부, 애플리케이션 독립적 업무 규칙의 일부 데이터베이스 기능의 일부 를 사용한다.&lt;/li>
&lt;/ul>
&lt;p>따라서 시스템을 수평적 계층으로 분할하면서 동시에 해당 계층을 가로지르는 얇은 수직적인 유스케이스로 시스템을 분할할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/16/img.png"
width="725"
height="247"
srcset="https://codemario318.github.io/post/clean-architecture/16/img_hu9d481b337dae54d8696707eddc9309ec_159985_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/16/img_hu9d481b337dae54d8696707eddc9309ec_159985_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="293"
data-flex-basis="704px"
>&lt;/p>
&lt;p>이와 같이 수직, 수평 결합을 동시에 분리하여 시스템의 맨 아래 계층까지 수직으로 내려가며 유스케이스들이 각 계층에서 서로 겹치지 않게 한다.&lt;/p>
&lt;p>서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있다.&lt;/p>
&lt;p>또한 유스케이스를 뒷받침하는 서로 다른 관점(aspect)을 사용하게 되면, 새로운 유스케이스를 추가하더라도 기존 유스케이스에 영향을 주는 일은 거의 없을 것이다.&lt;/p>
&lt;h2 id="개발-독립성">개발 독립성&lt;/h2>
&lt;p>컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다.&lt;/p>
&lt;p>기능 팀, 컴포넌트 팀, 계층 팀, 혹은 다른 형태의 팀이라도, 계층과 유스케이스의 결합이 분리되는 한 시스템의 아키텍처는 그 팀 구조를 뒷받침해 줄 것이다.&lt;/p>
&lt;h2 id="배포-톡립성">배포 톡립성&lt;/h2>
&lt;p>유스케이스와 계층의 결합이 분리되면 배포 측면에서도 고도의 유연성이 생긴다.&lt;/p>
&lt;p>결합을 제대로 분리했다면 운영 중인 시스템에서도 계층과 유스케이스를 교체할 수 있다.&lt;/p>
&lt;h2 id="가짜-중복">가짜 중복&lt;/h2>
&lt;p>아키텍트는 중복에 대한 공포로부터 발생하는 함정에 빠지곤 한다.&lt;/p>
&lt;p>소프트웨어에서 중복은 일반적으로 나쁜 것이나, 중복에도 여러 종류가 있다.&lt;/p>
&lt;ul>
&lt;li>진짜 중복
&lt;ul>
&lt;li>인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가짜 중복: 거짓된 또는 우발적인 중복
&lt;ul>
&lt;li>중복으로 보이는 두 코드 영역이 각자의 경로로 발전한다면(서로 다른 속도와 다른 이유로 변경된다면) 이 코드는 중복이 아니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>의도적으로 만든 중복(비슷하지만 다른 방향으로 발전할 것이 예상되는)우발적 중복을 통합한다면 나중에 코드를 다시 분리하느라 큰 수고를 감수해야 한다.&lt;/p>
&lt;p>유스케이스를 수직으로 분리할 때 이러한 문제와 마주치는 경우가 많으므로, 중복이 진짜 중복인지 확인하고 통합해야한다.&lt;/p>
&lt;p>계층을 수평으로 분리하는 경우, 특정 데이터베이스 레코드의 데이터 구조가 특정 화면의 데이터 구조와 상당히 비슷한 경우를 자주 볼 수 있는데, 이때 데이터베이스 레코드와 동일한 형태의 뷰 모델을 만들어서 각 항목을 복사하는 방식을 선택해야한다.&lt;/p>
&lt;h2 id="결합-분리-모드">결합 분리 모드&lt;/h2>
&lt;p>위와 같이 결합을 분리하면 운영 관점에서 여러가지 장점을 살펴볼 수 있다.&lt;/p>
&lt;p>유스케이스에서 서로 다른 관점이 분리되었다면,&lt;/p>
&lt;ul>
&lt;li>높은 처리량을 보장해야 하는 유스케이스와 낮은 처리량으로도 충분한 유스케이스는 이미 분리되어 있을 가능성이 높다.&lt;/li>
&lt;li>UI와 데이터베이스가 업무 규칙과 분리되어 있다면, UI와 데이터베이스는 업무 규칙과는 다른 서버에서 실행될 수 있다.&lt;/li>
&lt;li>높은 대역폭을 요구하는 유스케이스는 여러 서버로 복제하여 실행할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>유스케이스를 위해 수행하는 그 작업들(분리된 것들)은 운영에도 도움이 될 수 있다.&lt;/p>
&lt;p>운영 측면에서 이점을 살리기 이해선 결합을 분리할 때 적절한 모드를 선택해야 한다.&lt;/p>
&lt;ul>
&lt;li>분리된 컴포넌트를 서로 다른 서버에서 실행해야 하는 상황: MSA 등&lt;/li>
&lt;/ul>
&lt;p>때때로는 컴포넌트를 서비스 수준까지도 분리해야 한다.&lt;/p>
&lt;p>좋은 아키텍처는 선택권을 열어둔다는 말에서 결합 분리 모드는 이러한 선택지 중 하나다.&lt;/p>
&lt;p>계층과 유스케이스의 결합을 분리하는 방법은 다양하다.&lt;/p>
&lt;ul>
&lt;li>소스 수준 분리 모드
&lt;ul>
&lt;li>소스 코드 모듈 사이의 의존성을 제어할 수 있다.&lt;/li>
&lt;li>하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만들 수 있다.&lt;/li>
&lt;li>모노리틱 구조&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>배포 수준 분리 모드
&lt;ul>
&lt;li>&lt;code>.jar&lt;/code>, &lt;code>DLL&lt;/code>, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있다.&lt;/li>
&lt;li>소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있다.&lt;/li>
&lt;li>많은 컴포넌트가 같은 주소 공간에 상주하며, 단순한 함수 호출을 통해 통신할 수 있다.&lt;/li>
&lt;li>어떤 컴포넌트는 동일한 프로세스의 다른 프로세스에 상주하고, 프로세스 간 통신, 소켓, 공유 메모리를 통해 통신할 수 있다.&lt;/li>
&lt;li>결합이 분리된 컴포넌트가 독립적으로 배포할 수 있는 단위로 분할되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서비스 수준 분리 모드
&lt;ul>
&lt;li>의존하는 수준을 데이터 구조 단위까지 낮추고, 네트워크 패킷을 통해서만 통신하도록 만들 수 있다.&lt;/li>
&lt;li>모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적이게 된다.&lt;/li>
&lt;li>마이크로서비스, 서비스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>프로젝트 초기 단계는 어떤 모드가 최선인지 알기 어려우며, 프로젝트가 성숙해갈수록 최적인 모드가 달라질 수 있다.&lt;/p>
&lt;p>좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도,이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장하고, 또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 한다.(반대도 마찬가지)&lt;/p>
&lt;p>좋은 아키텍처는 결합 분리 모드를 선택사항으로 남겨두어서 배포 규모에 다라 가장 적합한 모드를 선택해 사용할 수 있게 만들어 준다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영할 수 있도록 만들어야한다.&lt;/p></description></item><item><title>15. 아키텍처란?</title><link>https://codemario318.github.io/post/clean-architecture/15/</link><pubDate>Tue, 12 Mar 2024 15:37:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/15/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/15/cover.png" alt="Featured image of post 15. 아키텍처란?" />&lt;p>&lt;strong>소프트웨어 아키텍트란?&lt;/strong>&lt;br>
소프트웨어 아키텍트는 프로그래머이며, 앞으로도 계속 프로그래머로 남아야하므로, 고수준 문제에만 집중하여 코드와 동떨어져서는 안 된다.&lt;/p>
&lt;p>소프트웨어 아키텍트는 개발에 참여하며 나머지 팀원들이 생산성을 극대화할 수 있는 설계를 하도록 방향을 이끌어준다.&lt;/p>
&lt;p>따라서 프로그래밍을 작업에 계속 참여하며 문제를 직접 경험하고 이를 통해 다른 프로그래머를 지원하는 작업을 수행해야한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>소프트웨어 시스템의 아키텍처란?&lt;/strong>&lt;/p>
&lt;p>시스템을 구축했던 사람들이 만들어낸 시스템의 형태로 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라 정해진다.&lt;/p>
&lt;p>이러한 시스템 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다.&lt;/p>
&lt;blockquote>
&lt;p>개발, 배포, 운영, 유지보수를 용이하게 만들기 위해서는 가능한 한 많은 선택지를, 가능한 한 오래 남겨두는 전략을 따라야한다.&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>시스템 아키텍처는 시스템의 동작 여부와는 거의 관련이 없다.&lt;/p>
&lt;ul>
&lt;li>형편없는 아키텍처를 갖춤 시스템도 수없이 많지만, 그런데로 잘 동작한다.&lt;/li>
&lt;li>이러한 경우 대체로 운영에서는 문제가 없지만 배포, 유지보수, 계속되는 개발 과정에서 어려움을 겪는다.&lt;/li>
&lt;/ul>
&lt;p>시스템 아키텍처가 시스템이 제대로 동작하는 것과는 직접적으로 관련이 없지만, 시스템이 제대로 동작하도록 &lt;strong>지원&lt;/strong>한다(간접적).&lt;/p>
&lt;ul>
&lt;li>시스템을 쉽게 이해할 수 있게 한다.&lt;/li>
&lt;li>쉽게 개발할 수 있게 한다.&lt;/li>
&lt;li>쉽게 유지보수할 수 있게 한다.&lt;/li>
&lt;li>쉽게 배포하게 해준다.&lt;/li>
&lt;/ul>
&lt;p>아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다. 궁극적으로 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.&lt;/p>
&lt;h2 id="개발">개발&lt;/h2>
&lt;p>시스템 아키텍처는 개발팀(들)이 시스템을 쉽게 개발할 수 있도록 뒷받침해야만 한다.&lt;/p>
&lt;p>&lt;strong>팀 구조&lt;/strong>&lt;/p>
&lt;p>팀 구조가 다르다면 아키텍처 관련 결정에서도 차이가 난다.&lt;/p>
&lt;ul>
&lt;li>작은 규모
&lt;ul>
&lt;li>팀 규모가 작아 상위 구조로 인한 장애물이 없기를 바라기 때문에 아키텍처 없이 시작하는 경우가 많다.&lt;/li>
&lt;li>잘 정의된 컴포넌트나 인터페이스가 없더라도 서로 효율적으로 협력하여 모노리틱 시스템을 개발할 수 있다.&lt;/li>
&lt;li>개발 초기에는 아키텍처 관련 제약들이 오히려 방해가 된다고 여길 가능성이 높다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>큰 규모
&lt;ul>
&lt;li>다른 요소를 고려하지 않는다면 아키텍처는 팀별 단일 컴포넌트(큰 관심사 별 컴포넌트)로 각각 발전될 가능성이 높다.&lt;/li>
&lt;li>팀별 단일 컴포넌트 아키텍처는 시스템을 배포, 운영, 유지보수하는 데 최적은 아닐 확률이 높다.&lt;/li>
&lt;li>시스템을 신뢰할 수 있고 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리하지 않으면 개발이 진척되지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="배포">배포&lt;/h2>
&lt;p>배포 비용이 높을수록 시스템의 유용성은 떨어진다.&lt;/p>
&lt;p>따라서 소프트웨어 아키텍처는 시스템을 단 한번에 쉽게 배포할 수 있도록 만드는 데 그 목표를 두어야 한다.&lt;/p>
&lt;ul>
&lt;li>초기 개발 단계에서는 배포 전략을 거의 고려하지 않기 때문에 개발하기는 쉬워도 배포하기는 어려운 아키텍처가 만들어진다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>마이크로서비스 아키텍처 micro-service architecture&lt;/strong>&lt;/p>
&lt;p>컴포넌트 경계가 매우 뚜렷해지고, 인터페이스가 대체로 안정화되므로 시스템을 매우 쉽게 개발할 수 있다.&lt;/p>
&lt;p>하지만 늘어난 수많은 마이크로서비스로인해 서로 연결하기 위해 설정하고 작동 순서를 결정하는 과정에서 오작동이 발생할 원천이 스며들어 배포하기 어려워진다.&lt;/p>
&lt;hr>
&lt;p>아키텍트가 배포 문제를 초기에 고려했다면, 더 적은 서비스를 사용하고, 서비스 컴포넌트와 프로세스 수준의 컴포넌트를 하이브리드 형태로 융합하며, 좀 더 통합된 도구를 사용해 상호 연결을 관리했을 것이다.&lt;/p>
&lt;h2 id="운영">운영&lt;/h2>
&lt;p>아키텍처가 시스템 운영에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향보다는 &lt;strong>덜 극적&lt;/strong>이다.&lt;/p>
&lt;p>운영에서 겪는 대다수의 어려움은 단순히 하드웨어를 더 투입해서 해결할 수 있다.&lt;/p>
&lt;ul>
&lt;li>소프트웨어 아키텍처가 비효율적이라면 스토리자와 서버를 추가하는 것만으로 제대로 동작하도록 만들 수 있을 때가 많다.&lt;/li>
&lt;li>하드웨어는 값싸고 인력은 비싸다.&lt;/li>
&lt;/ul>
&lt;p>운영 관점에서 소프트웨어 아키텍처는 비용 공식 관점에서 보다는 개발, 배포 유지보수 쪽으로 더 기운다는 의미를 가진다.&lt;/p>
&lt;p>&lt;strong>운영 방식&lt;/strong>&lt;/p>
&lt;p>시스템 아키텍처가 개발자에게 시스템의 운영 방식을 잘 드러내 준다.&lt;/p>
&lt;p>좋은 소프트웨어 아키텍처는 시스템을 운영하는 데 필요한 요구도 알려준다.&lt;/p>
&lt;ul>
&lt;li>유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시킨다.&lt;/li>
&lt;li>위 요소가 개발자에게 주요 목표로 인식되도록 해야한다.&lt;/li>
&lt;/ul>
&lt;p>이를 통해 시스템을 이해하기 쉬워지며, 따라서 개발과 유지보수에 큰 도움이 된다.&lt;/p>
&lt;h2 id="유지보수">유지보수&lt;/h2>
&lt;p>유지보수는 모든 측면에서 소프트웨어 시스템에서 가장 많은 비용이 발생한다.&lt;/p>
&lt;p>유지보수의 가장 큰 비용은 &lt;strong>탐사 spelunking&lt;/strong>와 &lt;strong>이로 인한 위험부담&lt;/strong>에 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>탐사란?&lt;/strong>&lt;/p>
&lt;p>기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 소프트웨어를 파헤쳐서 어디를 고치는 게 최선인지, 어떤 전략을 쓰는 게 최적일지를 결정할 때 드는 비용&lt;/p>
&lt;/blockquote>
&lt;p>변경사항을 반영할 때 의도치 않은 결함이 발생할 가능성은 항상 존재하며, 이로인한 위험부담 비용이 추가된다.&lt;/p>
&lt;p>주의를 기울여 신중하게 아키텍처를 만들면 이 비용을 크게 줄일 수 있다.&lt;/p>
&lt;ul>
&lt;li>시스템을 컴포넌트로 분리&lt;/li>
&lt;li>안정된 인터페이스를 두어 서로 격리&lt;/li>
&lt;/ul>
&lt;p>이를 통해 미래에 추가될 기능에 대한 길을 밝혀 둘 수 있을 뿐만 아니라 의도치 않은 장재가 발생할 위험을 크게 줄일 수 있다.&lt;/p>
&lt;h2 id="선택사항-열어두기">선택사항 열어두기&lt;/h2>
&lt;p>책 초반에 언급했듯, 소프트웨어는 행위적 가치와 구조적 가치를 지니며, 아키텍처 관점에서 구조적 가치를 추구해야한다.&lt;/p>
&lt;p>소프트웨어를 만든 이유는 기계의 행위를 빠르고 쉽게 변경하는 방법이 필요했기 때문인데, 이러한 유연성은 &lt;strong>시스템의 형태&lt;/strong>, &lt;strong>컴포넌트의 배치 방식&lt;/strong>, &lt;strong>컴포넌트가 상호 연결되는 방식&lt;/strong>에 상당히 크게 의존한다.&lt;/p>
&lt;p>소프트웨어의 유연성을 유지하는 방법은 선택사항(세부사항)을 &lt;strong>가능한 한 많이&lt;/strong>, &lt;strong>가능한 한 오랫동안&lt;/strong> 열어두는 것이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>정책과 세부사항&lt;/strong>&lt;/p>
&lt;p>모든 소프트웨어 시스템은 정책과 세부사항으로 분해할 수 있다.&lt;/p>
&lt;ul>
&lt;li>정책
&lt;ul>
&lt;li>모든 업무 규칙과 업무 절차를 구체화한다.&lt;/li>
&lt;li>시스템의 진정한 가치가 살아있는 곳&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>세부사항
&lt;ul>
&lt;li>사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소&lt;/li>
&lt;li>정책이 가진 행위에는 조금도 영향을 미치지 않는다.&lt;/li>
&lt;li>입출력 장치, DB, 웹 시스템, 서버, 프레임워크, 프로토콜 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 데 있다.&lt;/p>
&lt;p>이를 통해 세부사항을 결정하는 일은 미루거나 연기할 수 있게 된다.&lt;/p>
&lt;p>&lt;strong>예시&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>개발 초기에는 데이터베이스 시스템을 선택할 필요가 없다.
&lt;ul>
&lt;li>고수준의 정책을 데이터베이스가 관계형인지, 분산형인지, 계층형인지 등에 관계 없도록 만들어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개발 초기에는 웹 서버를 선택할 필요가 없다.
&lt;ul>
&lt;li>고수준의 정책은 자신이 웹을 통해 전달된다는 사실을 알아서는 안 된다.&lt;/li>
&lt;li>웹 개발 기술들에 대해 고수준의 정책이 전혀 알지 못하게 만들면, 프로젝트 후반까지는 어떤 종류의 웹 시스템을 사용할지를 결정하지 않아도 된다.&lt;/li>
&lt;li>시스템을 웹을 통해 전송할 것인지조차도 결정할 필요가 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개발 초기에는 REST를 적용할 필요가 없다.
&lt;ul>
&lt;li>고수준의 정책은 외부 세계로의 인터페이스에 대해 독립적이어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>의존성 주입 프레임워크를 적용할 필요가 없다.
&lt;ul>
&lt;li>고수준의 정책은 의존성을 해석하는 방식에 대해 신경써서는 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>세부사항에 몰두하지 않은 채 고수준의 정책을 만들 수 있다면, 이러한 세부사항에 대한 결정을 오랫동안 미루거나 연기할 수 있다.&lt;/p>
&lt;ul>
&lt;li>이러한 결정을 더 오래 참을 수 있다면, 더 많은 정보를 얻을 수 있고, 이를 기초로 제대로 된 결정을 내릴 수 있다.&lt;/li>
&lt;li>선택사항을 더 오랫동안 열어 둘 수 있다면 더 많은 실험을 해볼 수 있고 더 많은 것을 시도할 수 있다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>좋은 아케텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다.&lt;/p>
&lt;p>이를 통해 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다.&lt;/p>
&lt;p>좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.&lt;/p></description></item><item><title>14. 컴포넌트 결합</title><link>https://codemario318.github.io/post/clean-architecture/14/</link><pubDate>Thu, 07 Mar 2024 15:31:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/14/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/cover.png" alt="Featured image of post 14. 컴포넌트 결합" />&lt;p>지금부터 다룰 세 가지 원칙은 &lt;strong>컴포넌트 사이의 관계&lt;/strong>를 설명한다.&lt;/p>
&lt;p>컴포넌트 사이의 관계는 응집도와 마찬가지로 개발 가능성과 논리적 설계 사이의 균형을 다룬다.&lt;/p>
&lt;p>컴포넌트 구조와 관련된 아키텍처를 침범하는 힘은 기술적이며, 정치적이고, 가변적이다.&lt;/p>
&lt;h2 id="adp-의존성-비순환-원칙">ADP: 의존성 비순환 원칙&lt;/h2>
&lt;blockquote>
&lt;p>컴포넌트 의존성 그래프에 순환(Cycle)이 있어서는 안된다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>숙취 증후군 The morning after syndrome&lt;/strong>&lt;br>
무언가를 작동하게 만들놓았는데, 무언가를 의존하고 있던 무언가를 다른 사람이 수정하여 동작하지 않는 현상을 저자는 숙취 증후군이라 부른다.&lt;/p>
&lt;hr>
&lt;p>숙취 증후군은 많은 개발자가 동일한 소스 파일을 수정하는 환경에서 발생한다.&lt;/p>
&lt;p>소수의 개발자로 구성된 작은 프로젝트에서는 큰 문제가 되지 않지만, 프로젝트와 개발팀 규모가 커지면 큰 문제로 다가온다.&lt;/p>
&lt;p>지난 수십 년 동안 이 문제의 해결책으로 두 가지 방법이 발전되어 왔다.&lt;/p>
&lt;ul>
&lt;li>주 단위 빌드(Weekly build)&lt;/li>
&lt;li>의존성 비순환 원칙(Acyclic Dependencies Principle)&lt;/li>
&lt;/ul>
&lt;h3 id="주-단위-빌드">주 단위 빌드&lt;/h3>
&lt;p>중간 규모의 프로젝트에서는 흔하게 사용되는 방법으로 일주일의 첫 4일 동안은 각자 작업한 후 금요일이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다.&lt;/p>
&lt;p>이 접근법은 5일 중 4일 동안 개발자가 걱정없이 개발할 수 있다는 장점이 있지만, 금요일에 통합과 관련된 막대한 업보를 치러야한다는 단점을 가진다.&lt;/p>
&lt;ol>
&lt;li>프로젝트가 커질수록 통합은 하루만에 끝마치는게 불가능해진다.
&lt;ul>
&lt;li>통합 일정이 길어진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개발보다 통합에 드는 시간이 늘어나면서 팀의 효율성도 서서히 나빠진다.
&lt;ul>
&lt;li>빌드 주기가 길어진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>이러한 과정이 반복되며 효율성을 유지하기 위해 빌드 일정을 계속 늘려야 하고, 빌드 주기가 늦어질수록 프로젝트가 감수할 위험은 더 커지게된다.&lt;/p>
&lt;ul>
&lt;li>통합과 테스트를 수행하기가 점점 어려워진다.&lt;/li>
&lt;li>빠른 피드백이 주는 장점을 잃는다.&lt;/li>
&lt;/ul>
&lt;h3 id="순환-의존성-제거하기">순환 의존성 제거하기&lt;/h3>
&lt;p>이 문제의 해결책은 &lt;strong>개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것&lt;/strong>이다.&lt;/p>
&lt;p>이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.&lt;/p>
&lt;ol>
&lt;li>개발자가 해당 컴호넌트가 동작하도록 만든 후, 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할 수 있도록 만든다.&lt;/li>
&lt;li>컴포넌트에 릴리스 번호를 부여하고, 다른팀에서 사용할 수 있는 디렉터리로 이동시킨다.&lt;/li>
&lt;li>개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정한다.&lt;/li>
&lt;li>나머지 개발자는 릴리스된 버전을 사용한다.&lt;/li>
&lt;li>컴포넌트가 새로 릴리스되어 사용할 수 있게 되면, 다른팀에서는 새 릴리스를 적용할 지 결정한다.&lt;/li>
&lt;/ol>
&lt;p>특정 컴포넌트가 변경 되더라도 다른 팀에 영향을 즉각 영향을 주지는 않으므로 어떤 팀도 다른 팀에 의해 좌우되지 않는다.&lt;/p>
&lt;ul>
&lt;li>각 팀은 특정 컴포넌트가 새로 릴리스되면 자신의 컴포넌트를 해당 컴포넌트에 맞게 수정할 시기를 스스로 결정할 수 있다.&lt;/li>
&lt;li>통합은 작고 점진적으로 이뤄진다.&lt;/li>
&lt;/ul>
&lt;p>이 같은 작업 절차는 단순하며 합리적이여서 널리 사용되는 방식이나, 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img.png"
width="1410"
height="706"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_hu25b06e863fc54028a17a8c977c361598_212469_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_hu25b06e863fc54028a17a8c977c361598_212469_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="199"
data-flex-basis="479px"
>&lt;/p>
&lt;p>컴포넌트 다이어그램에서는 컴포넌트를 조립하여 애플리케이션을 만드는 다소 전형적인 구조로, 중요한 점은 컴포넌트 간의 의존성 구조이다.&lt;/p>
&lt;ul>
&lt;li>의존성 관계는 일방향이다.&lt;/li>
&lt;li>어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없다.&lt;/li>
&lt;li>어떠한 컴포넌트의 새로운 릴리스를 만들게 되면 영향을 받는 컴포넌트는 의존성 화살표를 거꾸로 따라가면 알 수 있다.
&lt;ul>
&lt;li>&lt;code>Presenters&lt;/code> &amp;gt; &lt;code>View&lt;/code>, &lt;code>Main&lt;/code>&lt;/li>
&lt;li>&lt;code>Main&lt;/code>은 새로 릴리스되더라도 영향을 받는 컴포넌트가 전혀 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;code>Presenters&lt;/code> 컴포넌트를 만드는 개발자가 이 컴포넌트를 테스트하려고 한다면, 현재 사용중인 버전의 &lt;code>Interactors&lt;/code>와 &lt;code>Entities&lt;/code>를 이용해서 &lt;code>Presenters&lt;/code> 자체 버전을 빌드하면 그만이다.&lt;/p>
&lt;ul>
&lt;li>테스트를 구성할 때 대체로 적은 노력이 든다.&lt;/li>
&lt;li>고려해야 할 변수도 상대적으로 적다.&lt;/li>
&lt;/ul>
&lt;p>시스템 전체를 릴리스해야 할 때가 오면 릴리스 절차는 상향식으로 진행된다.&lt;/p>
&lt;ol>
&lt;li>&lt;code>Entities&lt;/code> 컴포넌트를 컴파일하고, 테스트하고, 릴리스한다.&lt;/li>
&lt;li>&lt;code>Database&lt;/code>와 &lt;code>Interactors&lt;/code>에서도 동일한 과정을 거친다.&lt;/li>
&lt;li>&lt;code>Presenters&lt;/code>, &lt;code>Views&lt;/code>, &lt;code>Controllers&lt;/code>, &lt;code>Authorizer&lt;/code> 순으로 진행한다.&lt;/li>
&lt;li>마지막으로 &lt;code>Main&lt;/code>을 처리한다.&lt;/li>
&lt;/ol>
&lt;p>구성요소 간 의존성을 파악하고 있으면 시스템을 빌드하는 방법을 알 수 있다.&lt;/p>
&lt;h3 id="순환이-컴포넌트-의존성-그래프에-미치는-영향">순환이 컴포넌트 의존성 그래프에 미치는 영향&lt;/h3>
&lt;p>요구사항 발생으로 &lt;code>Entities&lt;/code>의 &lt;code>User&lt;/code> 클래스가 &lt;code>Authorizer&lt;/code>의 &lt;code>Permissions&lt;/code> 클래스를 사용한다고 가정하면, 아래와 같이 순환 의존성이 발생한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_2.png"
width="600"
height="293"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_2_hu1d9357bad079e1bd21e0590f44df1af1_28113_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_2_hu1d9357bad079e1bd21e0590f44df1af1_28113_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="204"
data-flex-basis="491px"
>&lt;/p>
&lt;p>&lt;code>Database&lt;/code> 컴포넌트를 릴리스하려면 &lt;code>Entities&lt;/code>와의 호환되어야 하므로 &lt;code>Authorizer&lt;/code>과 확인도 필요하며, &lt;code>Authorizer&lt;/code>는 &lt;code>Interactors&lt;/code>와도 의존하므로 세 개의 컴포넌트가 사실상 하나의 거대한 컴포넌트가되어 릴리스 하기 어려워진다.&lt;/p>
&lt;p>해당 컴포넌트의 개발자들은 항상 정확하게 동일한 릴리스를 사용해야하므로 모두 서로에게 얽매이게 된다.&lt;/p>
&lt;p>&lt;code>Entites&lt;/code> 컴포넌트를 테스트할 때도 &lt;code>Authorizer&lt;/code>와 &lt;code>Interactors&lt;/code> 까지도 반드시 빌드하고 통합해야한다.&lt;/p>
&lt;p>이처럼 순환이 생기면 컴포넌트를 분리하기가 상당히 어려워진다.&lt;/p>
&lt;ul>
&lt;li>단위테스트를 하고 릴리스를 하는 일도 굉장히 어려워진다. 에러가 쉽게 발생한다.&lt;/li>
&lt;li>모듈의 개수가 많아짐에 따라 빌드 관련 이슈는 기하급수적으로 증가한다.&lt;/li>
&lt;li>컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어진다.
&lt;ul>
&lt;li>순환이 생기면 올바른 순서라는 것 자체가 없을 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="순환-끊기">순환 끊기&lt;/h3>
&lt;p>컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG로 원상복구하는 일은 언제라도 가능하다.&lt;/p>
&lt;p>&lt;strong>의존성 역전 원칙 적용&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_4.png"
width="600"
height="297"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_4_hu2d0ddebed758504a656ef831a9615a2e_23447_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_4_hu2d0ddebed758504a656ef831a9615a2e_23447_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="202"
data-flex-basis="484px"
>&lt;/p>
&lt;ol>
&lt;li>&lt;code>User&lt;/code>가 필요로하는 메서드를 제공하는 인터페이스를 생성한다.&lt;/li>
&lt;li>이 인터페이스를 &lt;code>Entities&lt;/code>에 위치시키고, &lt;code>Authorizer&lt;/code>에서 이 인터페이스를 상속받는다.&lt;/li>
&lt;/ol>
&lt;p>이를 통해 &lt;code>Entities&lt;/code>와 &lt;code>Authorizer&lt;/code> 사이의 의존성을 역전시킬 수 있고, 이를 통해 순환을 끊을 수 있다.&lt;/p>
&lt;p>&lt;strong>새로운 컴포넌트&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_1.png"
width="1024"
height="496"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_1_hud3e3acb0c4f3794f6f3cfe621553502d_150119_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_1_hud3e3acb0c4f3794f6f3cfe621553502d_150119_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="495px"
>&lt;/p>
&lt;ol>
&lt;li>&lt;code>Entities&lt;/code>와 &lt;code>Authorizer&lt;/code>가 모두 의존하는 새로운 컴포넌트를 만든다.&lt;/li>
&lt;li>두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.&lt;/li>
&lt;/ol>
&lt;h3 id="흐트러짐jitters">흐트러짐(Jitters)&lt;/h3>
&lt;p>새로운 컴포넌트를 생성하는 두 번째 해결책에서 시사하는 바는 &lt;strong>요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다&lt;/strong>는 사실이다.&lt;/p>
&lt;p>애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장하므로, 의존성 구조에 순환이 발생하는지를 항상 관찰하여 순환이 발생하면 어떤 식으로든 끊어야 한다.&lt;/p>
&lt;p>이로인해 새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질수도 있다.&lt;/p>
&lt;h2 id="하향식top-down-설계">하향식(Top-down) 설계&lt;/h2>
&lt;p>지금까지 논의로 &lt;strong>컴포넌트 구조는 하향식으로 설계될 수 없다&lt;/strong>는 결론에 다다른다.&lt;/p>
&lt;p>컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.&lt;/p>
&lt;hr>
&lt;p>컴포넌트와 같이 큰 단위로 분해된 구조는 고수준의 기능적인 구조로 다시 분해할 수 있다고 기대하기 때문에 동의하지 않을 수 있지만, 컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없다.&lt;/p>
&lt;p>컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도이므로 빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도 도한 필요 없기 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.&lt;/p>
&lt;p>하지만 프로젝트가 진행되고 발전함에 따라 의존성관리, 영향범위 최소화, 안정적인 컴포넌트, 재사용성 등의 대한 요구로 점점 아키텍처를 새로 만들고 가다듬게 되어 컴포넌트 의존성 그래프는 조금씩 흐트러지고 성장한다.&lt;/p>
&lt;hr>
&lt;p>이처럼 아직 아무런 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하려고 시도한다면 큰 실패를 맛볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>공통 폐쇄에 대해 파악할 수 없다.&lt;/li>
&lt;li>재사용 가능한 요소도 알 수 없다.&lt;/li>
&lt;li>컴포넌트 생성 시 대부분 순환 의존성이 발생하게된다.&lt;/li>
&lt;/ul>
&lt;p>따라서 컴포넌트 의존성 구조는 시스템의 논리적인 설계에 발맞춰 성장하며 또 진화해야한다.&lt;/p>
&lt;h2 id="sdp-안정된-의존성-원칙">SDP: 안정된 의존성 원칙&lt;/h2>
&lt;blockquote>
&lt;p>안정성의 방향으로(더 안정된 쪽에) 의존하라.&lt;/p>
&lt;/blockquote>
&lt;p>설계를 유지하다 보면 변경은 불가피하므로 결코 정적일 수 없다.&lt;/p>
&lt;p>공통 폐쇄 원칙을 준수함으로써 컴포넌트가 다른 유형의 변경에는 영향받지 않으면서도 &lt;strong>특정 유형의 변경&lt;/strong>에만 민감하게 만들 수 있으며, 이에 맞추어 특정 컴포넌트는 변동성을 지니도록 설계한다.&lt;/p>
&lt;p>변동성이 높은(변동이 예상되는) 컴포넌트에 한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워지므로 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대 안된다.&lt;/p>
&lt;ul>
&lt;li>모듈을 만들 때는 변경하기 쉽도록 설계했지만, 그 모듈에 의존성을 매달아 버리면 해당 모듈도 변경하기 어려워진다.&lt;/li>
&lt;li>만든 모듈에서는 한 줄의 코드도 변경되지 않았더라도 변경하는 일이 상당히 도전적인 일이 되어버린다.&lt;/li>
&lt;/ul>
&lt;p>안정된 의존성 원칙을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.&lt;/p>
&lt;h3 id="안정성">안정성&lt;/h3>
&lt;p>동전을 세로로 세우면 안정성이 떨어지지만 건드리지 않으면 넘어지지 않는 것 처럼, 안정성은 변화가 발생하는 빈도와는 직접적인 관련이 없다.&lt;/p>
&lt;p>웹스터 사전에서는 안정성을 &amp;lsquo;쉽게 움직이지 않는&amp;rsquo;이라고 정의하는데 이는 변경을 만들기 위해 필요한 작업량과 관련된다.&lt;/p>
&lt;ul>
&lt;li>변경을 위해 필요한 작업량이 많으면 안정적이다.&lt;/li>
&lt;/ul>
&lt;p>소프트웨어 컴포넌트를 변경하기 어렵게 만드는 데는 크기, 복잡도, 간결함 등 많은 요인이 있지만, 변경하기 어렵게 만드는 확실한 방법 중 하나는 &lt;strong>수 많은 컴포넌트가 해당 컴포넌트에 의존&lt;/strong>하게 만드는 것이다.&lt;/p>
&lt;ul>
&lt;li>컴포넌트 안쪽으로 들어오는 의존성이 많아지면, 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하기 위해 많은 노력이 들기 때문에 상당히 안정적이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>안정된 컴포넌트&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_5.png"
width="600"
height="236"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_5_huda8f1298a64169a65f641afa6cef89c1_12377_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_5_huda8f1298a64169a65f641afa6cef89c1_12377_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="254"
data-flex-basis="610px"
>&lt;/p>
&lt;ul>
&lt;li>X는 세 컴포넌트를 &lt;strong>책임 responsible&lt;/strong>진다
&lt;ul>
&lt;li>X에 3개 컴포넌트가 의존하기 때문에 X를 변경하지 말아야할 이유는 3가지이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>X는 &lt;strong>독립적&lt;/strong>이다.
&lt;ul>
&lt;li>어디에도 의존하지 않으므로 변경되도록 만들 수 있는 외적인 영향이 전혀 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>불안정한 컴포넌트&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_6.png"
width="600"
height="240"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_6_hu7f1ed0727c7caffa02617c63a39a84b1_16824_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_6_hu7f1ed0727c7caffa02617c63a39a84b1_16824_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="250"
data-flex-basis="600px"
>&lt;/p>
&lt;ul>
&lt;li>책임성이 없다.
&lt;ul>
&lt;li>어떤 컴포넌트도 Y에 의존하지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>의존적이다.
&lt;ul>
&lt;li>3개 컴포넌트에 의존하므로 변경이 발생할 수 있는 외부 요인이 3가지이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="안정성-지표">안정성 지표&lt;/h3>
&lt;p>컴포넌트로 들어오고 나가는 의존성의 개수를 세어 컴포넌트가 위치상(Positional) 어느 정도의 안정성을 가지는지 계산할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Fan-in&lt;/strong>: 안으로 들어오는 의존성
&lt;ul>
&lt;li>컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래수 개수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Fan-out&lt;/strong>: 바깥으로 나가는 의존성
&lt;ul>
&lt;li>컴포넌트 외부의 크래스에 의존하는 컴포넌트 내부의 클래수 개수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>I(불안정성)&lt;/strong>: &lt;code>I = Fan-out / (Fan-in + Fan-out)&lt;/code>
&lt;ul>
&lt;li>0 ~ 1&lt;/li>
&lt;li>0이면 최고로 안정된 컴포넌트&lt;/li>
&lt;li>1이면 최고로 불안정한 컴포넌트&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Fan-in&lt;/code>과 &lt;code>Fan-out&lt;/code> 지표는 특정 컴포넌트 내부의 클래스에 의존하는, 컴포넌트 외부에 위치한 클래스의 개수를 세어서 계산할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_7.png"
width="600"
height="270"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_7_hub157614c3a6b055305efa756855a49e0_18409_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_7_hub157614c3a6b055305efa756855a49e0_18409_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="222"
data-flex-basis="533px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;code>I&lt;/code> 값이 1이면 어떤 컴포넌트도 해당 컴포넌트에 의존하지 않지만, 해당 컴포넌트는 다른 컴포넌트에 의존한다는 뜻이다.
&lt;ul>
&lt;li>최고로 불안정한 상태, 책임이 없으며 의존적이다.&lt;/li>
&lt;li>자신에게 의존하는 컴포넌트가 없으므로 변경하지 말아야 할 이유가 없다.&lt;/li>
&lt;li>다른 컴포넌트에 의존하기 때문에 언젠가는 해당 컴포넌트를 변경해야 할 이유가 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>I&lt;/code> 값이 0이면 해당 컴포넌트에 의존하는 다른 컴포넌트가 있지만, 해당 컴포넌트 자체는 다른 컴포넌트에 의존하지 않는다는 뜻이다.
&lt;ul>
&lt;li>최고로 안정된 상태, 다른 컴포넌트를 책임지면서 독립적이다.&lt;/li>
&lt;li>자신에게 의존하는 컴포넌트가 있으므로 변경하기가 어렵다.&lt;/li>
&lt;li>해당 컴포넌트를 변경하도록 강제하는 의존성은 같지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>SDP에서 컴포넌트 &lt;code>I&lt;/code> 지표는 그 컴포넌느가 의존하는 다른 컴포넌트들의 &lt;code>I&lt;/code>보다 커야한다고 말한다.&lt;/p>
&lt;p>즉, 의존성 방향으로 갈수록 &lt;code>I&lt;/code> 지표 값이 감소해야한다.&lt;/p>
&lt;h3 id="모든-컴포넌트가-안정적이어야-하는-것은-아니다">모든 컴포넌트가 안정적이어야 하는 것은 아니다.&lt;/h3>
&lt;p>모든 컴포넌트가 최고로 안정적인 시스템이라면 &lt;strong>변경이 불가능&lt;/strong>하다.&lt;/p>
&lt;p>이는 바람직한 상황은 아니며, 컴포넌트 구조를 설계할 때 기대하는 것은 &lt;strong>불안정한 컴포넌트와 안정된 컴포넌트가 공존하는 상태&lt;/strong>다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_8.png"
width="600"
height="279"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_8_hudc89e9bfdfd398c241eb318aebd58dcb_13750_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_8_hudc89e9bfdfd398c241eb318aebd58dcb_13750_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="215"
data-flex-basis="516px"
>&lt;/p>
&lt;p>위 다이어그램은 세 컴포넌트로 구성된 이상적인 구조이다.&lt;/p>
&lt;p>&lt;strong>추상 컴포넌트&lt;/strong>&lt;/p>
&lt;p>인터페이스만을 포함하는 추상 컴포넌트는 상당히 안정적이므로, 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_9.png"
width="1234"
height="265"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_9_hu6570728dfc635355d54dc2e2f70ef94b_129829_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_9_hu6570728dfc635355d54dc2e2f70ef94b_129829_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="465"
data-flex-basis="1117px"
>&lt;/p>
&lt;p>안정적인 &lt;code>Stable&lt;/code>의 내부 클래스 &lt;code>U&lt;/code>가 불안정한 &lt;code>Flexible&lt;/code>의 내부 클래스 &lt;code>C&lt;/code>를 사용해야한다면, DIP를 도입해 문제를 해결할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_10.png"
width="1232"
height="493"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_10_hu9ebc981cdc230977d03f9eebf0861deb_153552_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_10_hu9ebc981cdc230977d03f9eebf0861deb_153552_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="249"
data-flex-basis="599px"
>&lt;/p>
&lt;p>&lt;code>US&lt;/code>라는 인터페이스를 생성한 수 &lt;code>UServer&lt;/code> 컴포넌트에 넣고, 해당 인터페이스를 구현하도록 하면 &lt;code>Stable&lt;/code>의 &lt;code>Flexible&lt;/code>에 대한 의존성을 끊을 수 있고, &lt;code>UServer&lt;/code> 자체는 어디에도 의존하지 않으므로 안정된 상태이므로, 모든 의존성이 감소하는 방향으로 개선할 수 있다.&lt;/p>
&lt;h2 id="sap-안정된-추상화-원칙">SAP: 안정된 추상화 원칙&lt;/h2>
&lt;blockquote>
&lt;p>컴포넌트는 안정된 정도만큼만 추상화되어야 한다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="고수준-정책을-어디에-위치시켜야-하는가">고수준 정책을 어디에 위치시켜야 하는가?&lt;/h3>
&lt;p>고수준 아키텍처가 정책 결정과 관련된 소프트웨어는 자주 변경되서는 절대로 안되는 소프트웨어이다.&lt;/p>
&lt;p>따라서 시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트(&lt;code>I = 0&lt;/code>)에 위치해야 한다.&lt;/p>
&lt;p>불안정한 컴포넌트(&lt;code>I = 1&lt;/code>)는 반드시 변동성이 큰 소프트웨어, 즉 쉽고 바르게 변경할 수 있는 소프트웨어만을 포함해야 한다.&lt;/p>
&lt;p>하지만 고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스코드는 수정하기 어려워져 시스템 전체 아키텍쳐가 유연성을 잃게 된다.&lt;/p>
&lt;p>개방 폐쇄 원칙의 추상화를 통해 컴포넌트가 최고로 안정된 상태이면서도 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있다.&lt;/p>
&lt;h3 id="안정된-추상화-원칙">안정된 추상화 원칙&lt;/h3>
&lt;p>안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의한다.&lt;/p>
&lt;ul>
&lt;li>안정된 컴포넌트는 추상 컴포넌트여야한다.&lt;/li>
&lt;li>이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다.&lt;/li>
&lt;li>불안정한 컴포넌트는 반드시 구체 컴포넌트여야한다.
&lt;ul>
&lt;li>컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하므로&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>따라서 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다.&lt;/p>
&lt;p>안정된 컴포넌트가 확장 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 된다.&lt;/p>
&lt;p>SDP에서는 의존성이 반드시 안정성의 방향으로 향해야 한다고 말하며, SAP에서는 안정성이 결국 추상화를 의미한다고 말하기 때문에 SAP와 SDP를 결합하면 &lt;strong>컴포넌트에 대한 DIP&lt;/strong>와 같다.&lt;/p>
&lt;ul>
&lt;li>따라서 의존성은 추상화의 방향으로 향하게 된다.&lt;/li>
&lt;/ul>
&lt;h3 id="추상화-정도-측정하기">추상화 정도 측정하기&lt;/h3>
&lt;p>SDP + SPA 조합이 컴포넌트에 대한 DIP라고 언급했었지만, DIP는 클래스에 대한 원칙이므로 추상적이거나 그렇지 않거나 둘중 하나이다.&lt;/p>
&lt;p>하지만 SDP + SAP 조합은 컴포넌트에 대한 원칙이므로 컴포넌트의 어떤 부분은 추상적이면서 다른 부분은 안정적일 수 있다.&lt;/p>
&lt;p>&lt;code>A&lt;/code> 지표는 컴포넌트의 클래스 총 수 대비 인터페이스와 추상 클래스의 개수를 단순히 계산하여 컴포넌트의 추상화 정도를 측정한 값이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>Nc&lt;/code>: 컴포넌트의 클래스 개수&lt;/li>
&lt;li>&lt;code>Na&lt;/code>: 컴포넌트의 추상 클래스와 인터페이스 개수&lt;/li>
&lt;li>&lt;code>A&lt;/code>: 추상화 정도
&lt;ul>
&lt;li>&lt;code>A = Na / Nc&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>A&lt;/code>지표는 0과 1 사이의 값을 가지며, 0이면 추상 클래스가 하나도 없다는 뜻, 1이면 추상클래스만 포함한다는 뜻이다.&lt;/p>
&lt;h3 id="주계열-main-sequence">주계열: Main Sequence&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_11.png"
width="600"
height="297"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_11_hua926ad8375330f6f0926e565cc510cc5_5673_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_11_hua926ad8375330f6f0926e565cc510cc5_5673_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="202"
data-flex-basis="484px"
>&lt;/p>
&lt;ul>
&lt;li>최고로 안정적이며 추상화된 컴포넌트는 (0, 1)&lt;/li>
&lt;li>최고로 불안정하며 구체화된 컴포넌트는 (1, 0)&lt;/li>
&lt;/ul>
&lt;p>컴포넌트는 추상화와 안정화 정도가 다양하므로 두 지점에만 분포할 수는 없다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/14/img_12.png"
width="579"
height="297"
srcset="https://codemario318.github.io/post/clean-architecture/14/img_12_huf3699ca9d7d2715e368d8f9e5572debf_24335_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/14/img_12_huf3699ca9d7d2715e368d8f9e5572debf_24335_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="194"
data-flex-basis="467px"
>&lt;/p>
&lt;p>따라서 A/I 그래프 상에서 컴포넌트가 위치할 수 있는 합리적인 지점을 정의하는 궤적이 있을 것이라 가정해 볼 수 있으며, 이 궤적은 컴포넌트가 절대로 위치해서는 안 되는 영역(배제할 구역)을 찾는 방식으로 추론할 수 있다.&lt;/p>
&lt;h3 id="고통의-구역-zone-of-pain">고통의 구역: Zone of Pain&lt;/h3>
&lt;p>(0, 0) 주변 구역에 위치한 컴포넌트는 매우 안정적이며 구체적이므로 굉장히 뻣뻣한 상태로 바람직한 상태는 아니다.&lt;/p>
&lt;ul>
&lt;li>추상적이지 않으므로 확장할 수 없다.&lt;/li>
&lt;li>안정적이므로 변경하기 어렵다.&lt;/li>
&lt;/ul>
&lt;p>제대로 설계된 컴포넌트라면 (0, 0) 근처에는 위치하지 않을 것이라 보는게 일반적이다.&lt;/p>
&lt;p>일부 소프트웨어 엔티티는 고통의 구역에 위치한다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스 스키마
&lt;ul>
&lt;li>변동성이 매우 높다.&lt;/li>
&lt;li>극단적으로 구체적이다.&lt;/li>
&lt;li>많은 컴포넌트가 의존한다.&lt;/li>
&lt;li>OO 애플리케이션과 데이터베이스 사이에 위치한 인터페이스는 관리하기 굉장히 어렵다.&lt;/li>
&lt;li>스키마가 변경되면 대체로 고통을 수반한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유틸리티 라이브러리(&lt;code>String&lt;/code> 컴포넌트)
&lt;ul>
&lt;li>I가 1일지라도, 실제로는 변동성이 거의 없다.&lt;/li>
&lt;li>속한 클래스가 모두 구체 클래스이다.&lt;/li>
&lt;li>광범위하게 사용되어 수정하면 혼란을 초래할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>변동될 가능성이 거의 없는 컴포넌트는 (0, 0)에 위치했더라도 해롭지 않다.&lt;/p>
&lt;p>고통의 구역에서 문제가 되는 경우는 변동성이 있는 소프트웨어 컴포넌트이다.&lt;/p>
&lt;h3 id="쓸모없는-구역-zone-of-uselessness">쓸모없는 구역: Zone of Uselessness&lt;/h3>
&lt;p>(1, 1)에 위치한 컴포넌트는 최고로 추상적이지만 누구도 그 컴포넌트에 의존하지 않기 때문에 쓸모없는 컴포넌트이며 이로인해 쓸모없는 구역이라 부른다.&lt;/p>
&lt;p>이 영역에 존재하는 소프트웨어 엔티티는 폐기물과도 같다.&lt;/p>
&lt;ul>
&lt;li>대부분 누구도 구현하지 않은 채 남겨진 추상 클래스&lt;/li>
&lt;/ul>
&lt;p>쓸모없는 구역 내부 깊숙이 자리잡은 컴포넌트는 이러한 엔티티의 상당 부분을 포함할 가능성이 높다.&lt;/p>
&lt;h3 id="배제-구역-벗어나기">배제 구역 벗어나기&lt;/h3>
&lt;p>변동성이 큰 컴포넌트 대부분은 두 배제 구역으로부터 가능한 멀리 떨어뜨려야 한다.&lt;/p>
&lt;p>주계열에 위치한 컴포넌트는 자신의 안정성에 비해 너무 추상적이지도 않고, 추상화 정도에 비해 너무 불안정하지도 않다.&lt;/p>
&lt;ul>
&lt;li>쓸모없지 않으면서 고통을 안겨 주지도 않는다.&lt;/li>
&lt;li>추상화된 수준에 어울릴 정도로만 다른 컴포넌트가 의존한다.&lt;/li>
&lt;li>구체화된 수준에 어울릴 정로로만 다른 컴포넌트에 의존한다.&lt;/li>
&lt;/ul>
&lt;p>컴포넌트가 위치할 수 있는 가장 바람직한 지점은 &lt;strong>주계열의 두 종점&lt;/strong>이다.&lt;/p>
&lt;p>하지만 대규모 시스템에서 일부 컴포넌트는 완벽히 추상적이거나 완전하게 안정적일 수 없으므로, 이러한 컴포넌트는 주 계열 바로 위에 또는 가깝게 위치하게 설계하는 것이 이상적이다.&lt;/p>
&lt;h3 id="주계열과의-거리">주계열과의 거리&lt;/h3>
&lt;p>추상화 정도를 측정하는 A/I 그래프에서 (1, 0), (0, 1)를 연결하는 직선인 주계열을 기준으로 해당 컴포넌트가 얼마나 떨어져있는지 거리를 측정하여 지표으로 사용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>D: 거리, D = |A + I - 1|
&lt;ul>
&lt;li>유효범위: [0, 1]&lt;/li>
&lt;li>0이면 주계열 바로 위에 위치, 1이면 주계열로부터 가정 멀리 위치&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 지표를 통해 컴포넌트가 주계열에 대체로 일치하도록 설계되었는지(추상화, 구체화 수준에 어울리는 의존성을 갖는지) 분석하고, 거리가 먼 컴포넌트들을 개선할 수 있다.&lt;/p>
&lt;p>&lt;strong>통계적 활용&lt;/strong>&lt;/p>
&lt;p>값으로 계산할 수 있으므로 통계적으로 분석 가능해진다.&lt;/p>
&lt;p>설계에 포함된 컴포넌트들의 D를 계산하고 이들의 평균과 분산을 측정하였을때, 주계열에 일치하도록 설계되었다면 평균과 분산은 0에 가까워진다.&lt;/p>
&lt;ul>
&lt;li>분산을 통해 다른 컴포넌트에 비해 극히 예외적인 컴포넌트르 식별할 수 있으므로 관리 한계를 결정하는데 유용할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>시간에 따른 변화 확인&lt;/strong>&lt;/p>
&lt;p>각 컴포넌트의 D 값을 시간의 흐름에 따라 확인해보면, 해당 컴포넌트가 시간이 지남에 따라 의존성이 어떻게 변화하는지 확인할 수 있다.&lt;/p>
&lt;p>이를 통해 주계열에서 멀리 벗어난 컴포넌트들을 분석하여 인사이트를 얻는 것도 가능하다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>의존성 관리 지표는 설계의 의존성과 추상화 정도가 휼륭한 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다.&lt;/p>
&lt;p>하지만 지표는 임의로 결정된 표준을 기초로 한 측정값이므로 진리가 아니며, 의존성의 좋고 나쁨을 지표로만 판단해서는 안된다.&lt;/p>
&lt;p>그러나 이러한 지표를 통해 이상을 확인할 여지가 충분하고, 이를 상세하게 분석하여 아키텍처 개선에 유용하게 사용될 수 있다.&lt;/p></description></item><item><title>13. 컴포넌트 응집도</title><link>https://codemario318.github.io/post/clean-architecture/13/</link><pubDate>Thu, 07 Mar 2024 15:09:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/13/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/13/cover.png" alt="Featured image of post 13. 컴포넌트 응집도" />&lt;p>이 장에서는 컴포넌트 응집도와 관련된 세 가지 원칙을 논의한다.&lt;/p>
&lt;h2 id="rep-재사용릴리스-등가-원칙">REP: 재사용/릴리스 등가 원칙&lt;/h2>
&lt;blockquote>
&lt;p>재사용 단위는 릴리스 단위와 같다.&lt;/p>
&lt;/blockquote>
&lt;p>재사용 가능한 컴포넌트나 컴포넌트 라이브러리가 매우 많이 만들어짐에 따라 모듈 관리 도구가 점점 중요해졌다.&lt;/p>
&lt;p>소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나, 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수도 없고, 하지도 않을 것이다.&lt;/p>
&lt;ul>
&lt;li>릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없다.&lt;/li>
&lt;li>릴리스 번호를 통해 새로운 버전이 언제 출시되고 무엇이 변했는지를 소프트웨어 개발자들이 알아야 한다.
&lt;ul>
&lt;li>따라서 릴리스 절차에는 적절한 공지와 함께 릴리스 문서 작성도 포함되어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 &lt;strong>단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함&lt;/strong>을 뜻한다.&lt;/p>
&lt;p>다른 시각으로 바라보면 &lt;strong>하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 한다.&lt;/li>
&lt;li>동일한 릴리스로 추적 관리되어야 한다.&lt;/li>
&lt;li>동일한 릴리스 문서에 포함되어야 한다.&lt;/li>
&lt;/ul>
&lt;p>REP의 이러한 내용은 개발자들 간의 관습이라는 점이 약점이다. 하지만 그렇기 때문에 컴포넌트가 REP를 위배하면 컴포넌트 사용자가 알게 되고, 아키텍트로서 능력을 높게 평가하지 않을 것이다.&lt;/p>
&lt;p>이 원칙의 약점은 다른 두 원칙이 지닌 강점을 통해 충분히 보완할 수 있다.&lt;/p>
&lt;h2 id="ccp-공통-폐쇄-원칙">CCP: 공통 폐쇄 원칙&lt;/h2>
&lt;blockquote>
&lt;p>동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라.&lt;br>
서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.&lt;/p>
&lt;/blockquote>
&lt;h3 id="srp와-유사성">SRP와 유사성&lt;/h3>
&lt;p>이 원칙은 단일 책임 원칙(SRP)을 컴포넌트 관점에서 다시 쓴 원칙이다.&lt;/p>
&lt;blockquote>
&lt;p>동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.&lt;/p>
&lt;/blockquote>
&lt;p>SRP에서 클래스의 변경 이유는 하나여야 한다고 말하듯이, 공통 폐쇄 원칙에서도 마찬가지로 &lt;strong>단일 컴포넌트는 변경의 이유가 여러개여서는 안된다&lt;/strong>고 말한다.&lt;/p>
&lt;p>대다수의 애플리케이션에서 유지보수성(Maintainability)은 재사용성보다 훨씬 중요하다.&lt;/p>
&lt;p>애플리케이션의 코드가 반드시 변경되어야 한다면, 여러 컴포넌트 도처에서 분산되어 발생하기 보다는, 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.&lt;/p>
&lt;p>변경을 단일 컴포넌트로 제한할 수 있다면, 해당 컴포넌트만 재배포하면 되므로 의존하지 않는 다른 컴포넌트는 다시 검증하거나 배포할 필요가 없어진다.&lt;/p>
&lt;p>CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권한다.&lt;/p>
&lt;ul>
&lt;li>물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 한다.&lt;/li>
&lt;/ul>
&lt;p>이를 통해 소프트웨어를 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화 할 수 있다.&lt;/p>
&lt;h3 id="ocp와의-유사성">OCP와의 유사성&lt;/h3>
&lt;p>이 원칙은 개방 폐쇄 원칙과도 밀접하게 관련되어 있다.&lt;/p>
&lt;p>OCP에서는 클래스가 변경에는 닫혀있고 확장에는 열려있어야 한다고 말하는데, 100% 완전한 폐쇄란 불가능하므로 전략적으로 폐쇄해야 하며, 이에 따라 발생할 가능성이 있거나 과거에 발생했던 대다수의 공통적인 변경에 대해서 클래스가 닫혀 있도록 설계한다.&lt;/p>
&lt;p>CCP에서는 동일한 유형의 변경에 대해 닫혀있는 클래스들을 하나의 컴포넌트로 묶음으로써 OCP에서 얻은 교훈을 확대 적용한다.&lt;/p>
&lt;p>따라서 변경이 필요한 요구사항이 발생했을 때, 그 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아진다.&lt;/p>
&lt;h2 id="crp-공통-재사용-원칙">CRP: 공통 재사용 원칙&lt;/h2>
&lt;blockquote>
&lt;p>컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.&lt;/p>
&lt;/blockquote>
&lt;p>공통 재사용 원칙도 클래스와 모듈을 어느 컴포넌트에 위치시킬 지 결정할 때 도움되는 원칙이다.&lt;/p>
&lt;p>CRP에서는 &lt;strong>같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말한다.&lt;/strong>&lt;/p>
&lt;p>재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용하는 경우가 많은데, CRP에서는 이런 클래스들이 동일한 컴포넌트에 포함되어야 한다고 말한다.&lt;/p>
&lt;ul>
&lt;li>예를 들어 컨테이너 클래스와 해당 클래스의 이터레이터 클래스는 서로 강하게 결합되어 있기 때문에 함께 재사용되므로 이들 클래스는 반드시 동일한 컴포넌트에 위치해야 한다.&lt;/li>
&lt;/ul>
&lt;p>이처럼 CRP는 각 컴포넌트에 어떤 클래스들을 포함시켜야 하는지를 설명해준다.&lt;/p>
&lt;h3 id="isp와의-관계">ISP와의 관계&lt;/h3>
&lt;p>CRP는 인터페이스 분리 원칙의 포괄적인 버전이다.&lt;/p>
&lt;blockquote>
&lt;p>필요하지 않은 것에 의존하지 말라.&lt;/p>
&lt;/blockquote>
&lt;p>ISP는 사용하지 않은 메서드가 있는 클래스에 의존하지 말라고 조언하고, CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다.&lt;/p>
&lt;p>이를 통해 CRP는 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다.&lt;/p>
&lt;p>&lt;strong>어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에는 의존성이 생겨난다.&lt;/strong>&lt;/p>
&lt;p>사용하는 컴포넌트가 사용되는 컴포넌트의 극히 일부만을 사용한다고 하더라도 의존성은 조금도 약해지지 않는다.&lt;/p>
&lt;ul>
&lt;li>사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트도 변경해야 할 가능성이 높다.&lt;/li>
&lt;li>사용하는 컴포넌트를 변경하지 않더라도, 재컴파일, 재검증, 재배포를 해야 하는 가능성은 여전히 남아있다.&lt;/li>
&lt;/ul>
&lt;p>따라서 &lt;strong>의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야한다.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없다.&lt;/li>
&lt;li>그 중 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확실히 인지해야한다.&lt;/li>
&lt;/ul>
&lt;p>CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안 되는지에 대해 훨씬 더 많은 것을 이야기한다.&lt;/p>
&lt;ul>
&lt;li>강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안된다고 말한다.&lt;/li>
&lt;/ul>
&lt;h2 id="컴포넌트-응집도에-대한-균형-다이어그램">컴포넌트 응집도에 대한 균형 다이어그램&lt;/h2>
&lt;p>응집도 관점으로 세 원칙이 상충된다.&lt;/p>
&lt;ul>
&lt;li>포함 원칙: &lt;strong>REP&lt;/strong>, &lt;strong>CCP&lt;/strong>
&lt;ul>
&lt;li>컴포넌트의 크기를 더욱 크게 만든다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>배제 원칙: &lt;strong>CRP&lt;/strong>
&lt;ul>
&lt;li>컴포넌트를 더욱 작게 만든다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>뛰어난 아키텍트라면 이 원칙들이 균형을 이루는 방법을 찾아야한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/13/img.png"
width="821"
height="556"
srcset="https://codemario318.github.io/post/clean-architecture/13/img_hue86487ac117dcaed641584f80e0bb2e1_143879_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/13/img_hue86487ac117dcaed641584f80e0bb2e1_143879_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="147"
data-flex-basis="354px"
>&lt;/p>
&lt;ul>
&lt;li>REP와 CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미친다.&lt;/li>
&lt;li>CCP와 REP에만 과도하게 집중하면 불필요한 릴리스가 너무 빈번해진다.&lt;/li>
&lt;/ul>
&lt;p>이 균형 삼각형에서 개발팀이 현재 관심을 기울이는 부분을 충족시키는 위치를 찾아야 하며, 시간이 흐르면서 개발팀이 주의를 기울이는 부분 역시 변한다는 사실도 이해하고 있어야 한다.&lt;/p>
&lt;ul>
&lt;li>ex) 프로젝트 초기에는 개발 가능성이 더욱 중요하므로 CCP가 REP보다 훨씬 더 중요하다.&lt;/li>
&lt;/ul>
&lt;p>일반적으로 프로젝트는 삼각형의 오른쪽에서 시작하여 재사용성을 희생한다.&lt;/p>
&lt;p>프로젝트가 성숙하고, 파생된 또 다른 프로젝트가 시작되면, 점차 왼쪽으로 이동해간다.&lt;/p>
&lt;p>즉, 프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변하며, 프로젝트가 실제로 수행하는 일 자체보다는 프로젝트가 발전되고 사용되는 방법과 더 관련이 깊다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>과거에는 응집도를 &amp;lsquo;모듈은 단 하나의 기능만 수행해야한다.&amp;lsquo;는 속성 정도로 훌씬 단순했다.&lt;/p>
&lt;p>하지만 컴포넌트 응집도에 관한 세 가지 원칙은 응집도가 가질 수 있는 훨씬 복잡한 다양성을 설명해 준다.&lt;/p>
&lt;p>어느 클래스들을 묶어서 컴포넌트로 만들지 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 고려하여 애플리케이션의 요구에 맞게 균형을 잡는 일은 중요하다.&lt;/p>
&lt;p>이 균형점은 거의 항상 유동적이므로 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화해야한다.&lt;/p></description></item><item><title>12. 컴포넌트</title><link>https://codemario318.github.io/post/clean-architecture/12/</link><pubDate>Thu, 07 Mar 2024 14:21:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/12/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/12/cover.png" alt="Featured image of post 12. 컴포넌트" />&lt;blockquote>
&lt;p>SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명한다.&lt;/p>
&lt;p>큰 빌딩과 마찬가지로 대규모 소프트웨어 시스템은 작은 컴포넌트들로 만들어지므로, 컴포넌트가 무엇인지, 구성하는 요소는 무엇인지 알아보고, 컴포넌트를 결합하여 시스탬을 구성하는 방법에 대해 논의한다.&lt;/p>
&lt;/blockquote>
&lt;p>컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.&lt;/p>
&lt;ul>
&lt;li>java: .jar, ruby: gem, .net: DLL&lt;/li>
&lt;li>컴파일 언어에서는 바이너리 파일의 결합체&lt;/li>
&lt;li>인터프리터 언어의 경우 소스 파일의 결합체&lt;/li>
&lt;/ul>
&lt;p>여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있다.&lt;/p>
&lt;ul>
&lt;li>단일 아카이브: &lt;code>.war&lt;/code>&lt;/li>
&lt;li>플러그인: &lt;code>.jar&lt;/code>, &lt;code>dll&lt;/code>&lt;/li>
&lt;li>실행 파일: &lt;code>.exe&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>컴포넌트가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야한다.&lt;/p>
&lt;h2 id="컴포넌트의-간략한-역사">컴포넌트의 간략한 역사&lt;/h2>
&lt;p>소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어하여, 프로그램 위치가 결정되면, 재배치가 불가능했다.&lt;/p>
&lt;ul>
&lt;li>라이브러리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일했다.&lt;/li>
&lt;li>라이브러리는 바이너리가 아니라 소스 코드 형태로 유지되었다.&lt;/li>
&lt;li>자원이 한정적이었기 때문에 소스코드 전체를 여러번에 걸쳐서 읽어야하지만, 코드 전체를 메모리에 상주시킬 수가 없어 여러차례 읽어야했다.&lt;/li>
&lt;li>컴파일 시간을 단축시키기위해 함수 라이브러리의 소스코드를 애플리케이션 코드로부터 분리했다.
&lt;ul>
&lt;li>개별적으로 컴파일하고, 컴파일된 바이너리를 메모리의 특정 위치에 로드했다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>하지만 애플리케이션은 점점 커졌고, 할당된 공간을 넘어서게 되어 두 개의 주소 세그먼트로 분리하고 함수 라이브라리 공간을 사이에 두고 오가며 동작하게 배치해야했다.&lt;/li>
&lt;li>사용하는 메모리가 늘어날스록 이러한 단편화는 계속될 수밖에 없었기 때문에 지속가능하지 않았다.&lt;/li>
&lt;/ul>
&lt;h3 id="재배치성">재배치성&lt;/h3>
&lt;p>이러한 문제의 해결책은 재배치가 가능한 바이너리(Relocatable binary)였다.&lt;/p>
&lt;ul>
&lt;li>지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정&lt;/li>
&lt;/ul>
&lt;p>함수 라이브러리를 로드할 위치와 애필리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었다.&lt;/p>
&lt;p>이를 통해 오직 필요한 함수만을 로드할 수 있게 되었다.&lt;/p>
&lt;p>컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정되었다.&lt;/p>
&lt;ul>
&lt;li>프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 외부 참조(External reference)&lt;/li>
&lt;li>라이브러리 함수를 정의하는 프로그램이라면 외부 정의(External definition)&lt;/li>
&lt;/ul>
&lt;p>이렇게 함으로써 외부 정의를 로드할 위치가 정해지만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 되었고, 이렇게 링킹 로더(Linking Loader)가 탄생했다.&lt;/p>
&lt;h3 id="링커">링커&lt;/h3>
&lt;p>링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다.&lt;/p>
&lt;p>하지만 프로그램도 훨씬 커지게 되며 링킹 로더의 성능으로 감당할 수 없는 수준이 되었다.&lt;/p>
&lt;p>이에 따라 로드와 링크가 두 단계로 분리되었다.&lt;/p>
&lt;ul>
&lt;li>링커라는 별도의 애플리케이션으로 링크가 완료된 재배치 코드를 만들어주어 로딩 과정이 아주 빨라졌다.&lt;/li>
&lt;li>한번 만들어둔 실행 파일은 언제라도 빠르게 로드할 수 있게 되었다.&lt;/li>
&lt;/ul>
&lt;p>이후 C와 같은 고수준 언어를 사용하기 시작하며 소스 모듈은 &lt;code>.c&lt;/code>파일에서 &lt;code>.o&lt;/code> 파일로 컴파일된 후, 링커로 전달되어 바르게 로드될 수 있는 형태의 실행 파일로 만들어졌다.&lt;/p>
&lt;p>하지만 프로그램의 규모가 커지며 전체 모듈을 컴파일 하는데 꽤 시간이 걸렸고, 이후에 링크에서는 더 많은 시간이 소요되었다.&lt;/p>
&lt;blockquote>
&lt;p>로드 시간은 여전히 빨랐지만, &lt;strong>컴파일-링크 시간&lt;/strong>이 병목 구간이었다.&lt;/p>
&lt;/blockquote>
&lt;p>하지만 자원의 성능이 비약적으로 향상되며 프로그램을 성장시키는 속도보다 링크 시간이 줄어드는 속고가 더 빨라지기 시작했고, 소규모 작업이라면 링킹 로더마저도 다시금 사용할 만하게 되었다.&lt;/p>
&lt;p>이렇게 액티브 X와 공유 라이브러리 시대가 열렸고 &lt;code>.jar&lt;/code> 파일도 등장하기 시작했다.&lt;/p>
&lt;p>다수의 &lt;code>.jar&lt;/code> 파일 또는 다수의 공유 라이브러리를 순식간에 서로 링크한 후, 링크가 끝난 프로그램을 실행할 수 있게 되었고, 이렇게 **컴포넌트 플러그인 아키텍쳐(Component Plugin Architecture)**가 탄생했다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다.&lt;/p>
&lt;p>과거에는 초인적인 노력을 들여아만 컴포넌트 플러그인 아키텍처를 적용할 수 있었지만, 이제는 기본으로 쉽게 사용할 수 있는 지점까지 다다랐다.&lt;/p></description></item><item><title>11. DIP: 의존성 역전 원칙</title><link>https://codemario318.github.io/post/clean-architecture/11/</link><pubDate>Sun, 03 Mar 2024 10:17:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/11/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/11/cover.png" alt="Featured image of post 11. DIP: 의존성 역전 원칙" />&lt;p>의존성 역전 원칙에서 말하는 &amp;lsquo;유연성이 극대화된 시스템&amp;rsquo;이란 &lt;strong>소스 코드 의존성이 추상(Abstraction)에 의존하며 구체(Concretion)에는 의존하지 않는 시스템&lt;/strong>이다.&lt;/p>
&lt;p>자바와 같은 정적 타입 언어에서 이 말은 &lt;code>use&lt;/code>, &lt;code>import&lt;/code>, &lt;code>include&lt;/code> 구분은 오직 &lt;strong>인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다&lt;/strong>는 뜻이다.&lt;/p>
&lt;p>마찬가지로 동적 타입 언어에서도 소스 코드 의존 관계에서 구체 모듈은 참조해서는 안된다.&lt;/p>
&lt;p>하지만 구체 모듈이 무엇인지 정의하기 다소 어렵고, 호출할 함수가 구현된 모듈이라면 참조하지 않기가 특히 어렵다.&lt;/p>
&lt;p>소프트웨어 시스템이라면 구체적인 많은 장치에 반드시 의존하기 때문에 규칙으로 보기에 비현실적이다.&lt;/p>
&lt;ul>
&lt;li>ex) 자바 &lt;code>String&lt;/code>은 구체 클래스
&lt;ul>
&lt;li>애써 추상 클래스로 만들려는 시도는 현실성이 없다.&lt;/li>
&lt;li>&lt;code>java.lang.String&lt;/code> 구체 클래스에 대한 소스 코드 의존성은 벗어날 수 없고, 벗어나서도 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>String&lt;/code> 클래스는 변경되는 일이 거의 없고, 있더라도 엄격하게 통제되므로 매우 안정적이다.&lt;/p>
&lt;ul>
&lt;li>개발자와 아키텍트는 &lt;code>String&lt;/code> 클래스에서 변경이 자주 발생할 것이라고 염려할 필요가 없다.&lt;/li>
&lt;/ul>
&lt;p>이러한 이유로 DIP를 논할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다.&lt;/p>
&lt;ul>
&lt;li>환경에 대한 의존성을 용납하는 이유는 변경되지 않기 때문이다.&lt;/li>
&lt;/ul>
&lt;p>즉, &lt;strong>변동성이 큰(Volatile) 구체적인 요소&lt;/strong>가 의존하지 않도록 만들어야 하는 목표이며, 구체적인 요소는 지속적인 개발을 통해 계속 변경될 수 밖에 없는 모듈들이다.&lt;/p>
&lt;h2 id="안정된-추상화">안정된 추상화&lt;/h2>
&lt;p>안정된 소프트웨어 아키텍처란 변동성이 큰 구현제에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처이다.&lt;/p>
&lt;p>인터페이스는 구현체보다 변동성이 낮다.&lt;/p>
&lt;p>따라서 인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 통해 인터페이스의 변동성을 낮춰야한다.&lt;/p>
&lt;ul>
&lt;li>변동성이 큰 구체 클래스를 참조하지 말라.
&lt;ul>
&lt;li>추상 인터페이스를 참조하라&lt;/li>
&lt;li>객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리(Abstract Factory)를 사용하도록 강제한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>변동성이 큰 구체 클래스로부터 파생하지 말라.
&lt;ul>
&lt;li>상속은 소스 코드에 존재하는 모든 관계 중에서 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다.&lt;/li>
&lt;li>상속을 아주 신중하게 사용해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>구체 함수를 오버라이드 하지 말라.
&lt;ul>
&lt;li>구체 함수는 대체로 소스 코드 의존성을 필요로한다.&lt;/li>
&lt;li>구체 함수를 오버라이드 하면 이러한 의존성을 제거할 수 없게되며, 그 의존성을 상속하게 된다.&lt;/li>
&lt;li>추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.&lt;/li>
&lt;/ul>
&lt;h2 id="팩토리">팩토리&lt;/h2>
&lt;p>사실상 모든 언어에서 객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생하므로, &lt;strong>변동성이 큰 구체적인 객체는 특별히 주의해서 생성&lt;/strong>해야한다.&lt;/p>
&lt;p>대다수의 객체 지향 언어에서 바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/11/img.png"
width="1410"
height="712"
srcset="https://codemario318.github.io/post/clean-architecture/11/img_hufd5bb71d9d4dcad5d050da13121b4711_297143_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/11/img_hufd5bb71d9d4dcad5d050da13121b4711_297143_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="475px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>소스 코드 의존성&lt;/strong>
&lt;ul>
&lt;li>곡선은 구체적인 것들로부터 추상적인 것들은 분리하고 있다.&lt;/li>
&lt;li>소스 코드 의존성은 해당 곡선과 교차할 때 모두 추상적인 쪽으로 향한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>컴포넌트&lt;/strong>
&lt;ul>
&lt;li>시스템이 곡선을 기준으로 추상 컴포넌트와 구체 컴포넌트로 분리된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>제어흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지르고 있는데, 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다.&lt;/p>
&lt;p>이러한 이유로 이 원칙을 의존성 역전이라고 부른다.&lt;/p>
&lt;h2 id="구체-컴포넌트">구체 컴포넌트&lt;/h2>
&lt;p>위 예제의 경우 &lt;code>ServiceFactoryImpl&lt;/code> 구체 클래스가 &lt;code>ConcreteImpl&lt;/code> 구체 클래스에 의존하고 있으므로 DIP를 위배한다고 볼 수 있다.&lt;/p>
&lt;p>DIP 위배를 모두 없앨수는 없지만, DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과는 분리할 수 있다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>DIP는 고수준의 아키텍처 원칙에서 지속적으로 언급되는 규칙이다.&lt;/p>
&lt;p>DIP는 아키텍처 다이어그램에서 가장 눈에 드라나는 원칙이 될 것이다.&lt;/p>
&lt;p>곡선은 아키텍처의 경계가 되고, 의존성은 곡선을 경계로 더 추상적인 엔티티가 있는 쪽으로만 향한다.&lt;/p></description></item><item><title>10. ISP: 인터페이스 분리 원칙</title><link>https://codemario318.github.io/post/clean-architecture/10/</link><pubDate>Sun, 03 Mar 2024 09:49:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/10/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/10/cover.png" alt="Featured image of post 10. ISP: 인터페이스 분리 원칙" />&lt;pre class="mermaid" style="text-align: center;">classDiagram
direction BT
class User1 {
}
class User2 {
}
class User3 {
}
class OPS {
op1()
op2()
op3()
}
OPS &lt;-- User1
OPS &lt;-- User2
OPS &lt;-- User3
&lt;/pre>
&lt;ul>
&lt;li>다수의 사용자가 &lt;code>OPS&lt;/code> 클래스의 오퍼레이션을 사용함
&lt;ul>
&lt;li>&lt;code>UserN&lt;/code>은 &lt;code>opN&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>OPS&lt;/code>는 정적 타입 언어로 작성된 클래스&lt;/li>
&lt;/ul>
&lt;p>위와 같은 경우 &lt;code>User1&lt;/code>이 &lt;code>op2&lt;/code>, &lt;code>op3&lt;/code>를 전혀 사용하지 않음에도 이 두 메서드에 의존하게되고, 사용하지 않는 소스 코드가 변경되면 다시 컴파일한 후 새로 배포해야한다.&lt;/p>
&lt;p>인터페이스 분리 원칙은 &lt;strong>오퍼레이션을 인터페이스 단위로 분리하여 이러한 의존성을 제거&lt;/strong>한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">classDiagram
class User1 {
}
class User2 {
}
class User3 {
}
class U1Ops {
&lt;&lt; interface >>
op1()
}
class U2Ops {
&lt;&lt; interface >>
op2()
}
class U3Ops {
&lt;&lt; interface >>
op3()
}
class OPS {
op1()
op2()
op3()
}
OPS --|> U1Ops
OPS --|> U2Ops
OPS --|> U3Ops
U1Ops &lt;-- User1
U2Ops &lt;-- User2
U3Ops &lt;-- User3
&lt;/pre>
&lt;p>&lt;code>User1&lt;/code>의 소스 코드는 &lt;code>U1Ops&lt;/code>와 &lt;code>op1&lt;/code>에는 의존하지만 &lt;code>OPS&lt;/code>에는 의존하지 않게 되어 &lt;code>OPS&lt;/code> 에서 발생한 변경이 &lt;code>User1&lt;/code>과 전혀 관계없는 변경이라면, &lt;code>User1&lt;/code>을 다시 컴파일하고 새로 배포하는 상황은 초래되지 않는다.&lt;/p>
&lt;h2 id="isp와-언어">ISP와 언어&lt;/h2>
&lt;p>정적 타입 언어는 사용자가 &lt;code>import&lt;/code>, &lt;code>use&lt;/code>, &lt;code>include&lt;/code>와 같은 타입 선언문을 사용하도록 강제한다.&lt;/p>
&lt;p>이러한 &lt;strong>&amp;lsquo;포함된(included)&amp;rsquo;&lt;/strong> 선언문으로 인해 소스 코드 의존성이 발생하고, 이로 인해 재컴파일 도는 재배포가 강제되는 상황이 무조건 초래된다.&lt;/p>
&lt;ul>
&lt;li>동적 타입 언어네서는 소스 코드에 이러한 선언문이 존재하지 않고 런타임에 추론이 발생한다.
&lt;ul>
&lt;li>소스 코드 의존성이 아예 없으며, 재컴파일과 재배포가 필요없다.&lt;/li>
&lt;li>이러한 이유로 동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때보다 유연하며 결합도가 낮은 시스템을 만들 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>ISP를 아키텍처가 아니라, 언어와 관련된 문제라고 결론내릴 여지가 있다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="isp와-아키텍처">ISP와 아키텍처&lt;/h2>
&lt;p>ISP를 사용하는 근본적인 동기를 살펴보면, 잠재되어 있는 더 깊은 우려사항을 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>일반적으로 필요 이상으로 많을 걸 포함하는 모듈에 의존하는 것은 해로운 일이다.
&lt;ul>
&lt;li>소스 코드 의존성의 경우 &lt;strong>불필요한 재컴파일과 재배포를 강제&lt;/strong>하기 때문이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위와 같은 문제는 물론 아키텍처 수준에서도 마찬가지의 상황이 발생한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
a[System S]
b[Framework F]
c[Database D]
a --> b --> c
&lt;/pre>
&lt;ul>
&lt;li>&lt;code>S&lt;/code> 시스템을 구축하며 &lt;code>F&lt;/code>라는 프레임워크를 도입하려고한다.&lt;/li>
&lt;li>&lt;code>F&lt;/code> 프레임워크는 &lt;code>D&lt;/code>라는 특정 데이터베이스를 반드시 사용하도록 만들었다.&lt;/li>
&lt;li>&lt;code>S&lt;/code>는 &lt;code>F&lt;/code>에 의존하고, &lt;code>F&lt;/code>는 &lt;code>D&lt;/code>에 의존하게 된다.&lt;/li>
&lt;/ul>
&lt;p>위와 같은 상황에서 &lt;code>F&lt;/code>에서는 불필요한 기능, 즉 &lt;code>S&lt;/code>와는 전혀 관계없는 기능이 &lt;code>D&lt;/code>에 포함되어있다고 가정하면,&lt;/p>
&lt;ul>
&lt;li>불필요한 기능으로 인해 &lt;code>D&lt;/code> 내부가 변경되면, &lt;code>F&lt;/code>를 재배포 해야할 수도 있다.&lt;/li>
&lt;li>&lt;code>D&lt;/code> 내부의 기능 중 &lt;code>F&lt;/code>와 &lt;code>S&lt;/code>에서 불필요한 기능에 문제가 발생해도 &lt;code>F&lt;/code>와 &lt;code>S&lt;/code>에 영향을 준다.&lt;/li>
&lt;/ul>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다.&lt;/p></description></item><item><title>9. LSP: 리스코프 치환 원칙</title><link>https://codemario318.github.io/post/clean-architecture/9/</link><pubDate>Sat, 02 Mar 2024 16:20:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/9/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/9/cover.png" alt="Featured image of post 9. LSP: 리스코프 치환 원칙" />&lt;blockquote>
&lt;p>&lt;strong>하위 타입(Subtype)&lt;/strong>&lt;br>
&lt;code>S&lt;/code>타입의 객체 &lt;code>o1&lt;/code> 각각에 대응하는 &lt;code>T&lt;/code>타입 객체 &lt;code>o2&lt;/code>가 있고, &lt;code>T&lt;/code>타입을 이용해서 정의한 모든 프로그램 &lt;code>P&lt;/code>에서 &lt;code>o2&lt;/code>의 자리에 &lt;code>o1&lt;/code>을 치환하더라도 &lt;code>P&lt;/code>의 행위가 변하지 않는다면, &lt;code>S&lt;/code>는 &lt;code>T&lt;/code>의 하위 타입이다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="상속을-사용하도록-가이드하기">상속을 사용하도록 가이드하기&lt;/h2>
&lt;pre class="mermaid" style="text-align: center;">classDiagram
class Billing {
}
class License {
&lt;&lt; interface >>
calcFee()
}
class PersonalLicense {
}
class BusinessLicense {
users
}
Billing --> License
License &lt;|-- PersonalLicense
License &lt;|-- BusinessLicense
&lt;/pre>
&lt;p>&lt;code>Billing&lt;/code> 애플리케이션의 행위가 &lt;code>License&lt;/code>타입 중 무엇을 사용하는지에 전혀 의존하지 않이 때문에, 이들 하위 타입은 모두 &lt;code>License&lt;/code> 타입을 치환할 수 있으므로 위 설계는 리스코프 치환 원칙을 준수한다.&lt;/p>
&lt;h2 id="정사각형직사각형-문제">정사각형/직사각형 문제&lt;/h2>
&lt;p>리스코프 치환 원칙을 위반하는 전형적인 문제로 유명한 정사각형/직사각형 문제가 있다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">classDiagram
direction LR
class User {
}
class Rectangle {
H, W
setH()
setW()
}
class Square {
setSide()
}
User --> Rectangle
Rectangle &lt;|-- Square
&lt;/pre>
&lt;p>위 예제에서 &lt;code>Rectangle&lt;/code>의 높이와 너비는 서로 독립적으로 변경될 수 있는 반면, &lt;code>Square&lt;/code>의 높이와 너비는 반드시 함께 변경되므로 &lt;code>Square&lt;/code>는 &lt;code>Rectangle&lt;/code>의 하위 타입으로는 부적합하다.&lt;/p>
&lt;p>이러한 경우 &lt;code>User&lt;/code>는 대화하고 있는 상대가 &lt;code>Rectangle&lt;/code> 이라고 생각하므로 혼동이 생길 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Rectangle&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">setW&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">setH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">area&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위와 같은 경우 &lt;code>...&lt;/code>에 &lt;code>Square&lt;/code>를 생성한다면(치환한다면), &lt;code>assert&lt;/code>문은 실패하게된다.&lt;/p>
&lt;hr>
&lt;p>이러한 형태의 리스코프 치환 원칙 위반을 막기 위한 유일한 방법은 검사하는 메커니즘을 &lt;code>User&lt;/code>에 추가하는 것 인데, &lt;code>User&lt;/code>의 행위가 사용하는 타입에 의존하게 되므로, 결국 타입을 서로 치환할 수 없게 된다.&lt;/p>
&lt;h2 id="lsp와-아키텍처">LSP와 아키텍처&lt;/h2>
&lt;p>LSP는 상속을 사용하도록 가이드하는 방법 정도로 간주 되었으나, 시간이 지나면서 LSP는 &lt;strong>인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모해왔다.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>인터페이스&lt;/strong>&lt;/p>
&lt;p>위에서 말하는 인터페이스는 여러 의미로 해석 가능하다.&lt;/p>
&lt;ul>
&lt;li>인터페이스 하나와 이를 구현하는 여러 개의 클래스&lt;/li>
&lt;li>동일한 메서드 시그니처를 공유하는 여러 개의 클래스&lt;/li>
&lt;li>동일한 REST 인터페이스에 응답하는 서비스 집단&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>잘 정의된 인터페이스와 그 인터페이스의 구현체끼리의 상호 치환 가능성에 기대는 사용자들이 존재하기 때문에 대부분의 상황에서 LSP를 적용할 수 있다.&lt;/p>
&lt;h2 id="lsp-위배-사례-택시-파견-서비스">LSP 위배 사례: 택시 파견 서비스&lt;/h2>
&lt;p>&lt;strong>요구사항&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>고객이 어느 택시업체인지는 신경쓰지 않고 자신의 상황에 가장 적합한 택시를 찾는다.&lt;/li>
&lt;li>택시를 결정하면, 시스템은 REST 서비스를 통해 선택된 택시를 고객 위치로 파견한다.
&lt;ul>
&lt;li>URI가 운전기사 데이터베이스에 저장되어 있다.&lt;/li>
&lt;li>URI 정보를 이용하여 해당 기사를 고객 위치로 파견한다.&lt;/li>
&lt;li>ex) Bob의 URI: &lt;code>purplecab.com/driver/Bob&lt;/code>&lt;/li>
&lt;li>요청 예시&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">purplecab.com/driver/Bob
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> /picupAddress/24 Maple St.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> /pickupTime/153
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> /destination/ORD
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 서비스를 만들 때 다양한 택시업체에서 동일한 REST 인터페이스를 반드시 준수하도록 만들어야한다.&lt;/p>
&lt;p>만약 택시업체 ACME에서 &lt;code>destination&lt;/code> 필드를 &lt;code>dest&lt;/code>로 축약해서 사용했다고 가정하면, 해당 예외 사항을 처리하는 로직을 추가해야만 한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">driver&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getDispatchUri&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">startWith&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;acme.com&amp;#34;&lt;/span>&lt;span class="p">))...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&amp;ldquo;acme&amp;quot;라는 단어를 코드 자체에 추가하면, 끔찍할 뿐만 아니라 이해할 수도 없는 온갖 종류의 에러가 발생할 여지를 만들게 된다.&lt;/li>
&lt;li>새로운 택시업체 추가시 또 다른 if문이 필요할 수 있다.&lt;/li>
&lt;li>위와 같은 버그를 방지하기 위해 &lt;strong>설정용 데이터베이스&lt;/strong>를 이용하는 파견 명령 생성 모듈을 만들어야 할 수도 있다.
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>URI&lt;/th>
&lt;th>Dispatch Format&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Acme.com&lt;/td>
&lt;td>/pickupAddress/%s/pickupTime/%s/dest/%s&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>*.*&lt;/td>
&lt;td>/pickupAddress/%s/pickupTime/%s/destination/%s&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>REST 서비스들의 인터페이스가 서로 치환 가능하지 않다는 사실을 처리하는 중요하고 복잡한 매커니즘을 추가해야 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다.&lt;/p>
&lt;p>치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.&lt;/p></description></item><item><title>8. 개방 폐쇄 원칙</title><link>https://codemario318.github.io/post/clean-architecture/8/</link><pubDate>Fri, 01 Mar 2024 09:06:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/8/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/8/cover.png" alt="Featured image of post 8. 개방 폐쇄 원칙" />&lt;blockquote>
&lt;p>소프트웨어 개체(Artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.&lt;/p>
&lt;/blockquote>
&lt;p>개방 폐쇄 원칙은 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안된다는 원칙이다.&lt;/p>
&lt;p>요구사항을 살짝 확장하는 데 소프트웨어를 많이 수정해야 한다면, 그 소프트웨어 시스템을 설계한 아키텍트는 엄청난 실패에 맞닥뜨린 것이다.&lt;/p>
&lt;p>OCP는 클래스와 모듈을 설계할 때 도움이 되는 원칙으로 알려져 있지만, &lt;strong>아키텍처 컴포넌트 수준에서 고려할 때 훨씬 중요한 의미를 가진다.&lt;/strong>&lt;/p>
&lt;h2 id="사고-실험-재무제표-시스템">사고 실험: 재무제표 시스템&lt;/h2>
&lt;p>&lt;strong>요구사항&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>웹 페이지에 표시되는 데이터는 스크롤할 수 있음&lt;/li>
&lt;li>음수는 빨간색으로 출력&lt;/li>
&lt;li>추가 요구 사항: 동일한 정보를 보고서 형태로 변환해서 흑백 프린터로 출력 가능
&lt;ul>
&lt;li>페이지 번호가 제대로 메겨져 있어야 함&lt;/li>
&lt;li>페이지마다 적절한 머리글과 바닥글 있어야 함&lt;/li>
&lt;li>표의 각 열에는 레이블이 있어야 함&lt;/li>
&lt;li>음수는 괄호로 감싸야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>소프트웨어 아키텍처가 훌륭하다면 추가 요구사항에 따라 변경되는 코드의 양이 가능한 최소화 될 것이다.(이상적인 변경량은 0)&lt;/p>
&lt;p>이러한 경우 &lt;strong>서로 다른 목적으로 변경되는 요소를 적절하게 분리&lt;/strong>하고(단일 책임 원칙), 이들 &lt;strong>요소 사이의 의존성을 체계화&lt;/strong>함으로(의존성 역전 원칙) 변경량을 최소화 할 수 있다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
a[재무 데이터]
b((재무 분석기))
c[보고서용 재무 데이터]
d((보고서를 웹에 표시))
e((보고서를 프린터로 출력))
a --> b
b --> c
c --> d
c --> e
&lt;/pre>
&lt;ul>
&lt;li>보고서 생성이 두 개의 책임으로 분리 &amp;gt; 웹, 프린터
&lt;ul>
&lt;li>책임을 분리했다면, 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 의존성도 확실히 조직화 해야한다.&lt;/li>
&lt;li>행위가 확장될 때 변경이 발생하지 않음을 보장해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 목적을 달성하려면 &lt;strong>처리과정을 클래스 단위로 분할&lt;/strong>, &lt;strong>컴포넌트 단위로 구분&lt;/strong>해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/8/img_1.png"
width="1596"
height="1320"
srcset="https://codemario318.github.io/post/clean-architecture/8/img_1_hu67afed36bbb285aef637bc2b5de4e81c_785295_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/8/img_1_hu67afed36bbb285aef637bc2b5de4e81c_785295_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="290px"
>&lt;/p>
&lt;ul>
&lt;li>모든 의존성이 소스 코드 의존성을 나타낸다.
&lt;ul>
&lt;li>&lt;code>FinancialDataMapper&lt;/code>는 구현 관계를 통해 &lt;code>FinancialDataGateway&lt;/code>를 알고 있지만, &lt;code>FinancialDataGateway&lt;/code>는 &lt;code>FinancialDataMapper&lt;/code>에 대해 알지 못한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이중선은 화살표와 오직 한 방향으로만 교차한다.
&lt;ul>
&lt;li>모든 컴포넌트 관계는 단 방향으로 이루어진다.&lt;/li>
&lt;li>화살표는 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/8/img.png"
width="1734"
height="918"
srcset="https://codemario318.github.io/post/clean-architecture/8/img_hua4d495848552290f72309b8d34290664_326621_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/8/img_hua4d495848552290f72309b8d34290664_326621_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;blockquote>
&lt;p>A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야한다.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;code>Presenter&lt;/code>에서 발생한 변경으로부터 &lt;code>Controller&lt;/code>를 보호&lt;/li>
&lt;li>&lt;code>View&lt;/code>에서 발생한 변경으로부터 &lt;code>Presenter&lt;/code>를 보호&lt;/li>
&lt;li>&lt;code>Interactor&lt;/code>는 다른 모든 것에서 발생한 변경으로부터 보호&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Interactor&lt;/code>는 변경 폐쇄 원칙을 가장 잘 준수하는 곳에 위치하고 있는데, 이는 &lt;code>Interactor&lt;/code>가 애플리케이션에서 가장 높은 수준의 정책, 가장 중요한 문제를 담당하고 있기 때문이다.&lt;/p>
&lt;p>보호의 계층구조는 &lt;strong>수준 level&lt;/strong>이라는 개념을 바탕으로 구성되어야하며, 높은 수준일수록(세부 구현과 멀 수록) 변경에 대해 강력한 보호가 필요하다.&lt;/p>
&lt;p>아키텍처 수준에서 개방 폐쇄 원칙은 아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다.&lt;/p>
&lt;p>컴포넌트 계층구조를 이와 같이 조족화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.&lt;/p>
&lt;h2 id="방향성-제어">방향성 제어&lt;/h2>
&lt;p>&lt;code>FinancialDataGateway&lt;/code> 인터페이스는 &lt;code>Interactor&lt;/code> 컴포넌트에서 &lt;code>Database&lt;/code> 컴포넌트의 의존성을 역전시키기 위해 &lt;code>FinancialReportGenerator&lt;/code>와 &lt;code>FinancialDataMapper&lt;/code> 사이에 위치한다.&lt;/p>
&lt;p>&lt;code>FinancialDataGateway&lt;/code> 인터페이스가 없었다면 의존성이 &lt;code>Interactor&lt;/code> 컴포넌트에서 &lt;code>Database&lt;/code> 컴포넌트로 바로 향하게된다.&lt;/p>
&lt;h2 id="정보-은닉">정보 은닉&lt;/h2>
&lt;p>&lt;code>FinancialReportRequester&lt;/code> 인터페이스는 &lt;code>FinancialReportController&lt;/code>가 &lt;code>Interactor&lt;/code> 내부에 대해 너무 많이 알지 못하도록 막기 위해서 존재한다.&lt;/p>
&lt;ul>
&lt;li>인터페이스가 없었다면 &lt;code>Controller&lt;/code>는 &lt;code>FinancialEntities&lt;/code>에 대해 추이 종속성(Transitive dependency)을 가지게 된다.&lt;/li>
&lt;li>추이 종속성을 가지게 되면, 소프트웨어 엔티티는 **&amp;lsquo;자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다.&amp;rsquo;**는 소프트웨어 원칙을 위반하게 된다.&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Controller&lt;/code>에서 발생한 변경으로부터 &lt;code>Interactor&lt;/code>를 보호하는 일의 우선순위가 가장 높지만, 반대로 &lt;code>Interactor&lt;/code>에서 발생한 변경으로 부터 &lt;code>Controller&lt;/code>도 보호되길 바라기 때문에 &lt;code>Interactor&lt;/code> 내부를 은닉한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>추이 종속성(Transitive dependency)&lt;/strong>&lt;/p>
&lt;p>클래스 A가 클래스 B에 의존하고, 클래스 B가 클래스 C에 의존한다면, 클래스 A는 클래스 C에 의존하게 된다.&lt;/p>
&lt;ul>
&lt;li>클래스 이외의 소프트웨어의 모든 엔티티에도 동일하게 적용된다.&lt;/li>
&lt;li>클래스 의존성이 순환적이라면, 모든 클래스가 서로 의존하게 되는 문제가 있다.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>개방 폐쇄 원칙은 아키텍처를 떠받치는 원동력 중 하나다. OCP의 목표는 &lt;strong>시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있다.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>시스템을 컴포넌트 단위로 분리한다.&lt;/li>
&lt;li>저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 한다.&lt;/li>
&lt;/ul></description></item><item><title>7. 단일 책임 원칙</title><link>https://codemario318.github.io/post/clean-architecture/7/</link><pubDate>Thu, 29 Feb 2024 16:27:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/7/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/7/cover.png" alt="Featured image of post 7. 단일 책임 원칙" />&lt;h2 id="solid">SOLID&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>SOLID 원칙&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>함수와 데이터 구조를 클래스로 배치하는 방법&lt;/li>
&lt;li>클래스를 서로 결합하는 방법&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>좋은 소프트웨어 시스템은 깔끔한 코드(Clean Code)를 전제한다.&lt;/p>
&lt;p>하지만 깔끔한 코드를 사용한다고 하더라도 아키텍처가 좋지 못하다면 좋은 소프트웨어 시스템을 만들 수 없기 때문에 깔끔한 코드로 좋은 아키텍처를 정의하는 원칙이 필요하다.&lt;/p>
&lt;p>SOLID 원칙의 목적은 &lt;strong>중간 수준의 소프트웨어 구조&lt;/strong>가 아래와 같도록 만드는 것이다.&lt;/p>
&lt;ul>
&lt;li>변경에 유연&lt;/li>
&lt;li>이해하기 쉬움&lt;/li>
&lt;li>많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>중간 수준&lt;/strong>의미는?&lt;br>
프로그래머가 이들 원칙을 &lt;strong>모듈 수준&lt;/strong>에서 작업할 때 적용할 수 있다.&lt;br>
코드 수준보다는 조금 더 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는 데 도움을 준다.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>SRP: Single Responsibility Principle, 단일 책임 원칙&lt;/strong>
&lt;ul>
&lt;li>콘웨이(Conway) 법칙
&lt;ul>
&lt;li>조직이 설계한 시스템은 해당 조직의 커뮤니케이션 구조를 반영한다.&lt;/li>
&lt;li>조직의 내부 구조와 상호 작용 방식은 그 조직이 개발하는 소프트웨어의 구조와 유사해진다.&lt;/li>
&lt;li>조직 내에 분산된 팀이 서로 간의 교류가 원할하지 않을 경우 개발하는 소프트웨어도 모듈화 인터페이스 설계에 문제가 발생한다.&lt;/li>
&lt;li>따름 정리:
&lt;ul>
&lt;li>특정한 제한을 둔 조직 구조가 특정한 형태의 소프트웨어 아키텍처를 유도한다.&lt;/li>
&lt;li>특정한 형테의 조직 구조가 특정한 형태의 소프트웨어 아키텍처를 촉진하거나 제한할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>따라서 각 소프트웨어의 모듈은 변경의 이유가 하나여야만 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>OCP: Open-Closed Principle, 개방 폐쇠 원칙&lt;/strong>
&lt;ul>
&lt;li>기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 시스템을 쉽게 변경할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>LSP: Liskov Substitution Principle, 리스코프 치환 원칙&lt;/strong>
&lt;ul>
&lt;li>상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 구성요소는 반드시 서로 치환 가능해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>ISP: Interface Segregation Principle, 인터페이스 분리 원칙&lt;/strong>
&lt;ul>
&lt;li>사용하지 않은 것에 의존하지 않아야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>DIP: Dependency Inversion Principle, 의존성 역전 원칙&lt;/strong>
&lt;ul>
&lt;li>고수준 정책을 구현하는 코드는 저수준 세보사항을 구현하는 코드에 절대로 의존해서는 안된다.&lt;/li>
&lt;li>세부사항이 정책에 의존해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="srp-단일-책임-원칙">SRP: 단일 책임 원칙&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경된다.&lt;/p>
&lt;p>따라서 SRP가 말하는 변경의 이유는 **사용자와 이해관계자 집단(액터, Actor)**을 의미하며, 이러한 관점에서 단일 책임 원칙은 다음과 같이 말할 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>하나의 모듈은 한의 액터에 대해서만 책임져야 한다&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>모듈이란?&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>소스 파일&lt;/li>
&lt;li>단순히 함수와 데이터 구조로 음집된 집합&lt;/li>
&lt;/ul>
&lt;p>단일 액터를 책임지는 코드르 함께 묶어주는 힘이 바로 &lt;strong>응집성 Cohesion&lt;/strong>이다.&lt;/p>
&lt;h3 id="징후-1-우발적-중복">징후 1: 우발적 중복&lt;/h3>
&lt;pre class="mermaid" style="text-align: center;">classDiagram
class Employee {
calculatePay()
reportHours()
save()
}
&lt;/pre>
&lt;ul>
&lt;li>&lt;code>calculatePay()&lt;/code>
&lt;ul>
&lt;li>회계팀에서 기능을 정의&lt;/li>
&lt;li>CFO 보고를 위해 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>reportHours()&lt;/code>
&lt;ul>
&lt;li>인사팀에서 기능을 정의하고 사용&lt;/li>
&lt;li>COO 보고를 위해 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>save()&lt;/code>
&lt;ul>
&lt;li>DBA가 기능을 정의&lt;/li>
&lt;li>CTO 보고를 위해 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Employee&lt;/code> 클래스는 서로 매우 다른 액터를 책임지기 때문에 SRP를 위반하게 된다.&lt;/p>
&lt;p>&lt;code>Employee&lt;/code>는 단일 클래스 내의 각각 다른 액터를 책임지는 메서드들로 인해 액터간의 결합이 발생하였고, 이러한 결합으로 인해 의존하는 무언가에 영향을 줄 수 있다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart TD
a[calculatePay]
b[reportHours]
c[regularHours]
a --> c
b --> c
&lt;/pre>
&lt;p>위 처럼 &lt;code>calculatePay&lt;/code>와 &lt;code>reportHours&lt;/code> 메소드의 시간 계산 코드 중복을 피하기 위해 &lt;code>regularHours&lt;/code> 메소드를 추가했다고 가정하고, &lt;code>calculatePay&lt;/code>의 정책 변경으로 인해 &lt;code>reqularHours&lt;/code> 메소드를 일부 변경했다.&lt;/p>
&lt;p>이러한 경우 해당 메소드와 연관된 액터가 CFO, COO 둘이지만, CFO의 요구사항으로 변경되었기 때문에 변경을 원하지 않는 COO의 기능에도 영향을 미치게 되는데, 관심사가 달라 의존 관계를 확인하기 어려워 확인이 누락이 될 수 있다.&lt;/p>
&lt;p>(이로인해 &lt;code>reportHours&lt;/code> 메소드에서는 이러한 변경으로 인해 잘못된 결과를 얻을 수 있다.)&lt;/p>
&lt;p>결과적으로 이러한 문제는 &lt;strong>서로 다른 액터가 의존하는 코드를 너무 가까이 배치&lt;/strong>했기 때문에 발생한 문제이며, SRP는 이러한 문제를 &lt;strong>서로 다른 액터가 의존하는 코드를 서로 분리&lt;/strong>하여 예방하라고 말하고 있다.&lt;/p>
&lt;h3 id="징후-2-병합">징후 2: 병합&lt;/h3>
&lt;p>메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성이 확실히 더 높아진다.&lt;/p>
&lt;p>많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우에 발생한다.&lt;/p>
&lt;ul>
&lt;li>다른 목적으로 인해 같은 코드를 변경할 가능성이 높아지고 이로인해 변경사항이 충돌할 여지가 많다.&lt;/li>
&lt;/ul>
&lt;p>이러한 문제는 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것으로 이러한 문제를 벗어날 수 있다.&lt;/p>
&lt;h3 id="해결책">해결책&lt;/h3>
&lt;p>이 문제의 해결책은 다양하지만, 모두 메서드를 각기 다른 클래스로 이동시키는 것은 공통적으로 포함한다.&lt;/p>
&lt;p>가장 확실한 해결책은 데이터와 메서드를 분리하는 방식으로, 아무런 메서드가 없는 데이터 구조인 &lt;code>EmployeeData&lt;/code> 클래스를 만들어 세 개의 클래스가 공유하도록 만든다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">classDiagram
direction LR
class EmployeeData {
datas...
}
class PayCalculator {
calculatePay()
}
class HourReporter {
reportHours()
}
class EmployeeSaver {
saveEmployee()
}
PayCalculator --> EmployeeData
HourReporter --> EmployeeData
EmployeeSaver --> EmployeeData
&lt;/pre>
&lt;p>세 클래스는 서로의 존재를 모르기 때문에 &lt;strong>우연한 중복&lt;/strong>을 피할 수 있다.&lt;/p>
&lt;p>위 방식은 개발자가 세 가지 클래스를 인스턴스화하고 추적해야 한다는 단점이 있는데, 퍼사드 패턴을 활용하여 개선이 가능하다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">classDiagram
direction LR
class EmployeeFacade {
calculatePay()
reportHours()
save()
}
class EmployeeData {
datas...
}
class PayCalculator {
calculatePay()
}
class HourReporter {
reportHours()
}
class EmployeeSaver {
saveEmployee()
}
EmployeeFacade --> PayCalculator
EmployeeFacade --> HourReporter
EmployeeFacade --> EmployeeSaver
PayCalculator --> EmployeeData
HourReporter --> EmployeeData
EmployeeSaver --> EmployeeData
&lt;/pre>
&lt;p>중요한 업무 규칙을 데이터와 가깝게 배치하는 방식을 원한다면 아래와 같이 구성할 수도 있다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">classDiagram
direction LR
class Employee {
employeeData
calculatePay()
reportHours()
save()
}
class HourReporter {
reportHours()
}
class EmployeeSaver {
saveEmployee()
}
Employee --> HourReporter
Employee --> EmployeeSaver
&lt;/pre>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>단일 책임 원칙은 &lt;strong>메서드와 클래스 수준의 원칙&lt;/strong>이다.&lt;/p>
&lt;p>하지만 이보다 상위 두 수준에서도 다른 형태로 다시 등장한다.&lt;/p>
&lt;ul>
&lt;li>컴포넌트 수준: 공통 폐쇄 원칙(Common Closure Principle)&lt;/li>
&lt;li>아키텍처 수준: 아키텍쳐 경계(Architectural Boundaray)의 생성을 책임지는 변경의 축(Axis of Change)&lt;/li>
&lt;/ul></description></item><item><title>6. 함수형 프로그래밍</title><link>https://codemario318.github.io/post/clean-architecture/6/</link><pubDate>Sun, 25 Feb 2024 20:36:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/6/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/6/cover.png" alt="Featured image of post 6. 함수형 프로그래밍" />&lt;p>함수형 프로그래밍이라는 개념은 프로그래밍 그 자체보다 앞서 등장했다.&lt;/p>
&lt;p>이 패러다임에서 핵심이 되는 기반은 람다(Lambda) 계산법으로 안론조 처치가 1930년대에 발명했다.&lt;/p>
&lt;h2 id="불변성과-아키텍처">불변성과 아키텍처&lt;/h2>
&lt;p>일반적인 언어들과 달리 함수형 언어에서는 변수가 한번 초기화되면 절대로 변경되지 않는다.&lt;/p>
&lt;p>가변 변수로 인해 경합 조건, 교착상태 조건, 동시 업데이트 문제가 발생하는데, 만약 어떠한 변수도 갱신되지 않는다면 경합 조건이나 동시 업데이트 문제가 발생하지 않는다.&lt;/p>
&lt;p>락(lock)이 가변적이지 않다면 교착상태도 일어나지 않는다.&lt;/p>
&lt;p>동시성 애플리케이션에서 마주치는 모든 문제, 즉 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.&lt;/p>
&lt;p>불변성은 저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다면 보장 가능하지만 그럴 수 없으므로 어느정도 타협이 필요하다.&lt;/p>
&lt;h2 id="가변셩의-분리">가변셩의 분리&lt;/h2>
&lt;p>불변성과 관련하여 가장 주요한 타협 중 하나는 애플리케이션 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.&lt;/p>
&lt;p>불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.&lt;/p>
&lt;p>불변 컴포넌트는 변수의 상태를 변경할 수 있는, 죽 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/6/img.png"
width="574"
height="396"
srcset="https://codemario318.github.io/post/clean-architecture/6/img_hu99e785152b719343990f143a06772634_81872_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/6/img_hu99e785152b719343990f143a06772634_81872_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="상태 변경과 트랜잭션 메모리"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;p>상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 트랜잭션 메모리와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호한다.&lt;/p>
&lt;p>트랜잭션 메모리는 트랜잭션을 사용하거나 도는 재시도 기법을 통해 변수를 보호한다.&lt;/p>
&lt;p>애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야한다.&lt;/p>
&lt;p>그리고 이렇게 분리하려면 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침해야한다.&lt;/p>
&lt;p>현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.&lt;/p>
&lt;h2 id="이벤트-소싱">이벤트 소싱&lt;/h2>
&lt;p>이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다.&lt;/p>
&lt;p>상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.&lt;/p>
&lt;p>이 전략은 많은 저장 공간을 필요로 하지만 현재는 저장 공간을 충분히 확보할 수 있다.&lt;/p>
&lt;ul>
&lt;li>데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없으므로, 결과적으로 애플리케이션은 CRUD가 아닌 그저 CR만 수행한다.&lt;/li>
&lt;li>데이터 저장소에서 변경과 삭제가 전혀 발생하지 않으므로 동시 없데이트 문제 또한 일어나지 않는다.&lt;/li>
&lt;/ul>
&lt;p>저장 공간과 처리 능력이 충분하면 완전한 불변성을 갖도록 만들 수 있고, 따라서 완전한 함수형으로 만들 수 있다.&lt;/p>
&lt;ul>
&lt;li>버전 관리 시스템이 정확히 이방식으로 동작한다.&lt;/li>
&lt;/ul>
&lt;h2 id="결론">결론&lt;/h2>
&lt;ul>
&lt;li>구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.&lt;/li>
&lt;li>객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.&lt;/li>
&lt;li>함수형 프로그래밍은 변수 할당에 부과되는 규율이다.&lt;/li>
&lt;/ul>
&lt;p>세 패러다임 모두 무언가를 하지 못하게 제한하고 있으며, 코드를 작성하는 방식의 형태를 한정시킨다.&lt;/p>
&lt;p>지난 반세기 동안 우리가 배운 것은 &lt;strong>해서는 안되는 것&lt;/strong>에 대해서이다.&lt;/p>
&lt;p>도구는 달라졌고 소프트웨어도 변했지만, 소프트웨어는 순차, 분기, 반복 참조로 구성된다는 것은 변하지 않았다.&lt;/p></description></item><item><title>5. 객체 지향 프로그래밍</title><link>https://codemario318.github.io/post/clean-architecture/5/</link><pubDate>Sun, 25 Feb 2024 17:46:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/5/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/5/cover.png" alt="Featured image of post 5. 객체 지향 프로그래밍" />&lt;p>좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는 데서 출발한다.&lt;/p>
&lt;h2 id="object-oriented란-무엇인가">Object Oriented란 무엇인가?&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>데이터와 함수의 조합&lt;/strong>
&lt;ul>
&lt;li>대체로 이런 방식으로 많이 설명되지만 만족스러운 대답은 아니다.&lt;/li>
&lt;li>&lt;code>o.f()&lt;/code>가 &lt;code>f(o)&lt;/code>와 다르다는 의미를 내포한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>실제 세계를 모델링하는 새로운 방법&lt;/strong>
&lt;ul>
&lt;li>얼버무리는 수준에 지나지 않는다. 의도가 불분명하며, 정의가 너무 모호하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>캡슐화, 상속, 다형성
&lt;ul>
&lt;li>세가지 개념을 적절하게 조합한 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="캡슐화encapsulation">캡슐화(Encapsulation)?&lt;/h2>
&lt;p>OO를 정의하는 요소 중 하나로 캡슐화를 언급하는 이유는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 OO 언어가 제공하기 때문이다.&lt;/p>
&lt;p>이를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>private&lt;/code>, &lt;code>public&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>하지만 이러한 개념은 OO에만 국한된 것은 아니다.&lt;/p>
&lt;p>&lt;strong>point.h&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">makePoint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">double&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">double&lt;/span> &lt;span class="nf">distance&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>point.c&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;point.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;math.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">makepoint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">double&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">double&lt;/span> &lt;span class="nf">distance&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">dx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p1&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">p2&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">dy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p1&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">p2&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nf">sqrt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dx&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">dx&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">dy&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">dy&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위 예시에서 &lt;code>point.h&lt;/code>를 사용하는 측에서 &lt;code>struct Point&lt;/code>의 멤버에 접근할 방법이 전혀 없다.&lt;/p>
&lt;ul>
&lt;li>사용자는 &lt;code>makePoint()&lt;/code> 함수와 &lt;code>distance()&lt;/code> 함수를 호출할 수는 있지만, &lt;code>Point&lt;/code> 구조체의 데이터 구조와 함수가 어떻게 구현되었는지에 대해서는 조금도 알지 못한다.&lt;/li>
&lt;/ul>
&lt;p>이것이 완벽한 캡슐화이며, OO가 아닌 언어에서도 충분히 가능하다.&lt;/p>
&lt;p>오히려 OO를 지원하는 언어들이 캡슐화를 훼손하고 있는 경우가 많아 언어에 &lt;code>public&lt;/code>, &lt;code>private&lt;/code>, &lt;code>protected&lt;/code> 키워드를 도입하여 불완전한 캡슐화를 보완한다.&lt;/p>
&lt;ul>
&lt;li>C++는 컴파일러가 클래스의 인스턴스 크기를 알아야하는 기술적인 이유로 클래스의 멤버변수를 해당 클래스의 헤더파일에 선언해야하고, 이로인해 사용측에서 멤버변수의 존재를 알게된다.&lt;/li>
&lt;li>자바, C#은 헤더와 구현체를 분리하는 방식을 버렸다. 이로인해 클래스 선언과 정의를 구분하는게 불가능하다.&lt;/li>
&lt;/ul>
&lt;p>이 때문에 OO가 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들며, 대부분의 OO를 제공하는 언어들이 실제로는 C언어에서 누렸던 완벽한 캡슐화를 약화시켰다.&lt;/p>
&lt;ul>
&lt;li>많은 언어가 캡슐화를 거의 강제하지 않는다.&lt;/li>
&lt;li>OO 프로그래밍은 프로그래머가 캡슐화를 우회하지 않을 것 이라는 믿음을 기반으로 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="상속">상속?&lt;/h2>
&lt;p>OO 언어가 더 나은 캡슐화를 제공하지는 못했지만, 상속만큼은 확실히 제공했다.&lt;/p>
&lt;p>하지만 상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어 재정의하는 일에 불과하다.&lt;/p>
&lt;p>&lt;strong>namedPoint.h&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">makeNamedPoint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">double&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">setName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">getName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>namedPoint.c&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;NamedPoint.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">makeNmaedPoint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">double&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">p&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">setName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">np&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">getName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">NmaedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>main.c&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;point.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;namedPoint.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">ac&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">**&lt;/span> &lt;span class="n">av&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">origin&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">makeNamedPoint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">0.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;origin&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">NamedPoint&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">upperRight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">makeNamedPoint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">1.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">1.0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;upperRight&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;distance=%f&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">distance&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">origin&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// namedPoint를 point로 쓰고있음
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">Point&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">upperRight&lt;/span> &lt;span class="c1">// namedPoint를 point로 쓰고있음
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>main&lt;/code> 프로그램을 살펴보면 &lt;code>NamedPoint&lt;/code> 데이터 구조가 &lt;code>Point&lt;/code> 데이터 구조로부터 파생된 구조인 것 처럼 동작한다는 사실을 볼 수 있다.&lt;/p>
&lt;p>이처럼 눈속임처럼 보이는 방식은 OO가 출현하기 이전부터 프로그래머가 흔히 사용했던 기법이다. 실제로 C++은 이 방법을 이용해 단일 상속을 구현하였다.&lt;/p>
&lt;p>OO 언어가 고안되기 훨씬 이전에도 상속과 비슷한 기법이 사용되었지만, 상속만큼 편리한 방식은 절대 아니다.&lt;/p>
&lt;p>따라서 OO 언어가 완전히 새로운 개념을 만들지는 못했지만, 상당히 편리한 방식으로 제공했다고 볼 수 있다.&lt;/p>
&lt;h2 id="다형성">다형성?&lt;/h2>
&lt;p>OO 언어가 있기 이전에도 다형성을 표현할 수 있었다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">copy&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">getchar&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">EOF&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">putchar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>getchar()&lt;/code>는 &lt;code>STDIN&lt;/code>에서 문자를 읽고, &lt;code>putchar()&lt;/code>는 &lt;code>STDOUT&lt;/code>으로 문자를 쓴다.&lt;/p>
&lt;p>&lt;code>STDIN&lt;/code>과 &lt;code>STDOUT&lt;/code>은 다양한 장치가 될 수 있기 때문에 이러한 함수는 다형적(Polymorphic)이다.&lt;/p>
&lt;p>유닉스 운영체제의 경우 모든 입출력 장치 드라이버가 다섯 가지 표준 함수를 제공할 것을 요구한다&lt;/p>
&lt;ul>
&lt;li>&lt;code>open&lt;/code>, &lt;code>close&lt;/code>, &lt;code>read&lt;/code>, &lt;code>write&lt;/code>, &lt;code>seek&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>FILE&lt;/code> 데이터 구조는 이들 다섯 함수를 가리키는 포인터들을 포함한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">FILE&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">open&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">close&lt;/span>&lt;span class="p">)();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="p">)();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">write&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">seek&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>입출력 드라이버에서는 이들 함수를 아래와 같이 전의하며, &lt;code>FILE&lt;/code> 데이터 구조를 함수에 대한 주소와 함께 로드한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;file.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="cm">/* ... */&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">close&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="cm">/* ... */&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">read&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* ... */&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="cm">/* ... */&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">seek&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="cm">/* ... */&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">FILE&lt;/span> &lt;span class="n">console&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">open&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">close&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">write&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">seek&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>STDIN&lt;/code>을 &lt;code>FILE*&lt;/code>로 선언하면 콘솔 데이터 구조를 가리키므로, &lt;code>getchar()&lt;/code>는 아래와 같은 방식으로 구현할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">extern&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">FILE&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">STDIN&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">getchar&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">STDIN&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="nf">read&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>다시말해 &lt;code>getchar()&lt;/code>는 &lt;code>STDIN&lt;/code>으로 참초되는 &lt;code>FILE&lt;/code> 데이터 구조의 &lt;code>read&lt;/code> 포인터가 가르키는 함수를 단순히 호출할 뿐이다.&lt;/p>
&lt;p>이처럼 단순한 기법이 모든 OO가 지는 다형성이 근간이 되며, 즉 함수를 가리키는 포인터를 응용한 것이 다형성이고 OO가 새롭게 만든 개념이 아니다.&lt;/p>
&lt;p>하지만, OO 언어는 좀 더 안전하고 편리하게 사용할 수 있게 해준다.&lt;/p>
&lt;ul>
&lt;li>함수 포인터를 사용하기 위한 관례들을 없애 실수할 위험이 없다.&lt;/li>
&lt;/ul>
&lt;p>OO는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론 지을 수 있다. (??)&lt;/p>
&lt;h3 id="다형성이-가진-힘">다형성이 가진 힘&lt;/h3>
&lt;p>복사 프로그램 예제에서 새로운 입출력 장치가 생겨도 프로그램의 아무런 변경이 필요하지 않다.&lt;/p>
&lt;ul>
&lt;li>복사 프로그램의 소스 코드는 입출력 드라이버의 소스 코드에 의존하지 않기 때문이다.&lt;/li>
&lt;li>입출력 드라이버가 &lt;code>FILE&lt;/code>에 정의된 다섯가지 표준 함수를 구현한다면, 복사 프로그램에서는 어떠한 입출력 드라이버도 사용할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>플러그인 아키텍처(Plugin architecture)&lt;/strong>&lt;/p>
&lt;p>플러그인 아키텍처는 이처럼 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다.&lt;/p>
&lt;p>그런데도 대다수의 프로그래머는 함수 포인터의 위험함 때문에 이러한 개념을 확장하여 적용하지 않았는데, OO의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.&lt;/p>
&lt;h3 id="의존성-역전">의존성 역전&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/5/img_1.png"
width="437"
height="218"
srcset="https://codemario318.github.io/post/clean-architecture/5/img_1_hu9d7ba88c223125c910483171079777bc_7404_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/5/img_1_hu9d7ba88c223125c910483171079777bc_7404_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="소스 코드 의존성 vs. 제어흐름"
class="gallery-image"
data-flex-grow="200"
data-flex-basis="481px"
>&lt;/p>
&lt;p>다형성을 안전하고 편리하게 적용할 수 있기 전에는 &lt;code>main&lt;/code> 함수가 고수준 함수를 호출하고, 고수준 함수는 다시 중간 수준 함수를, 중간 수준 함수는 저수준 함수를 호출한다.&lt;/p>
&lt;p>이로인해 소스 코드 의존성의 방향은 반드시 제어흐름을 따르게 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/5/img.png"
width="694"
height="280"
srcset="https://codemario318.github.io/post/clean-architecture/5/img_hu57338117272e8a2dea8d6af8f8d33249_6758_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/5/img_hu57338117272e8a2dea8d6af8f8d33249_6758_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="의존성 역전"
class="gallery-image"
data-flex-grow="247"
data-flex-basis="594px"
>&lt;/p>
&lt;p>하지만 다형성을 활용하면 의존성의 방향이 바뀐다.&lt;/p>
&lt;p>&lt;code>HL1&lt;/code> 모듈은 &lt;code>ML1&lt;/code> 모듈의 &lt;code>F()&lt;/code> 함수를 호출한다. 하지만 &lt;code>ML1&lt;/code>과 &lt;code>I&lt;/code> 인터페이스 사이의 소스 코드 의존성(상속 관계)이 제어흐름과는 반대이다.&lt;/p>
&lt;p>이는 의존성 역전(Dependency inversion)이라고 부르며, 소프트웨어 아키텍처 관점에서 이러한 현상은 &lt;strong>소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻&lt;/strong>이기도 하다.&lt;/p>
&lt;p>이러한 접근법을 사용한다면, OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대한 방향을 결정할 수 있는 절대적인 권한을 가지게 된다.&lt;/p>
&lt;ul>
&lt;li>소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다.&lt;/li>
&lt;li>호출하는 모듈이든 호출 받는 모듈이든 관계없이 소스 코드 의존성을 원하는 방향으로 설정할 수 있다.&lt;/li>
&lt;/ul>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
a[UI]
b[Business Rules]
c[Database]
a-->b
b-.->a
c-->b
b-.->c
&lt;/pre>
&lt;p>위 와 같은 경우 업무 규칙이 데이터베이스와 UI에 의존하는 대신에, 시스템의 소스코드 의존성을 반대로 배치하여 데이터베이스와 UI가 업무 규칙에 의존하게 만들 수 있다.&lt;/p>
&lt;ul>
&lt;li>UI와 데이터베이스가 업무 규칙의 플러그인이 된다는 뜻이다.&lt;/li>
&lt;li>업무 규칙의 소스 코드에서는 UI나 데이터베이스를 호출하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>결과적으로 업무 규칙, UI, 데이터베이스는 세 가지로 분리된 컴포넌트 또는 배포 가능한 단위로 컴파일할 수 있고, 의존하지 않기 때문에 각 컴포넌트들을 독립적으로 배포할 수 있다.&lt;/p>
&lt;ul>
&lt;li>특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포한다.&lt;/li>
&lt;li>이를 배포 독립성(Independent deployability)이라고 한다.&lt;/li>
&lt;li>시스템의 모듈을 독립적으로 배포할 수 있게 되면, 다른 팀에서 각 모듈을 독립적으로 개발할 수 있고, 이것을 개발 독립성 이라 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>소프트웨어 아키텍트 관점에서 OO란 다형성을 이용하여 전체 시스템의 모든 소스코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.&lt;/p>
&lt;p>OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 전책을 포함하는 모듈은 저수순의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.&lt;/p>
&lt;p>저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.&lt;/p></description></item><item><title>4. 구조적 프로그래밍</title><link>https://codemario318.github.io/post/clean-architecture/4/</link><pubDate>Tue, 20 Feb 2024 20:33:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/4/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/4/cover.png" alt="Featured image of post 4. 구조적 프로그래밍" />&lt;p>구조적 프로그래밍(Structured Programming)은 프로그래밍의 한 접근 방법으로, 프로그램을 작성할 때 제어 흐름을 구조화하여 코드를 보다 이해하기 쉽고 유지 보수하기 쉽게 만들려는 것을 중점으로한다.&lt;/p>
&lt;p>구조적 프로그래밍은 프로그래밍 분야에서 중요한 발전 중 하나로, 초기 프로그래밍 방법론이 가진 한계(복잡성, 프로그래밍 실수, 소프트웨어 신뢰성 등)를 극복하고자 탄생하였다.&lt;/p>
&lt;h2 id="goto문의-해로움">&lt;code>goto&lt;/code>문의 해로움&lt;/h2>
&lt;p>구조적 프로그래밍을 발견한 데이크스트라는 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘하지 못한다고 생각하였는제 아래와 같은 이유가 원인이라고 생각했다.&lt;/p>
&lt;ul>
&lt;li>모든 프로그램은 단순할지라도 너무 많은 세부사항을 담고 있었다.&lt;/li>
&lt;li>아주 작은 세부사항이라도 간과하면 예상 외의 방식으로 실패하곤 했다.&lt;/li>
&lt;/ul>
&lt;p>데이크스트라는 &lt;strong>증명&lt;/strong>이라는 수학적인 원리를 적용하여 이러한 문제를 해결하려고자 했고, 수학자가 유클리드 계층구조를 사용하여 증명하는 방식을 프로그래머도 사용할 수 있다고 믿었다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>유클리드 계층구조&lt;/strong>&lt;br>
공리(axiom)는 증명 없이 참으로 받아들이는 명제를 뜻한다.&lt;/p>
&lt;p>정리(theorem)는 증명이라는 과정을 통해 참이라는 것이 밝혀진 명제다.&lt;/p>
&lt;p>이러한 정리를 증명하는 데 필요한 정리를 보조정리(lemma)로 부르며, 정리를 통해 자연스럽게 도출되는 정리를 따름정리(corollary)라고 부른다.&lt;/p>
&lt;/blockquote>
&lt;p>이를 위한 연구를 진행하면서 합리적인 증명을 위한 분할 정복 접근법을 적용하려 했는데 &lt;code>goto&lt;/code> 문장을 이용한 제어 흐름 전환이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 된다는 것을 발견하였다.&lt;/p>
&lt;p>반면 &lt;code>goto&lt;/code> 문장을 사용하더라도 모듈을 분해할 때 문제가 되지 않는 경우는 &lt;code>if/then/else&lt;/code>와 &lt;code>do/while&lt;/code> 같은 분기와 반복이라는 단순한 제어 구조에 해당한다는 사실을 발견했다.&lt;/p>
&lt;p>다익스트라는 제어 구조가 순차 실행(Sequential execution)과 결합해야 한다고 깨닳았다.&lt;/p>
&lt;h2 id="structured-program-theoremhttpsenwikipediaorgwikistructured_program_theorem">&lt;a class="link" href="https://en.wikipedia.org/wiki/Structured_program_theorem" target="_blank" rel="noopener"
>Structured program theorem&lt;/a>&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/4/img.png"
width="700"
height="117"
srcset="https://codemario318.github.io/post/clean-architecture/4/img_hu2203a586a82df95cc8044769f2a6a61e_7549_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/4/img_hu2203a586a82df95cc8044769f2a6a61e_7549_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="598"
data-flex-basis="1435px"
>&lt;/p>
&lt;p>&lt;strong>Böhm–Jacopini 정리&lt;/strong>라고도 불리는 구조적 프로그래밍 정리는 프로그램을 작성하는 데 사용되는 모든 제어 구조를 표한할 수 있는 최소한의 구조가 있음을 보여준다.&lt;/p>
&lt;ul>
&lt;li>순차(Sequence)
&lt;ul>
&lt;li>프로그램의 각 문장들은 순차적으로 실행&lt;/li>
&lt;li>어떤 작업을 차례대로 수행하는 것을 의미함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>분기(Selection)
&lt;ul>
&lt;li>조건문을 사용하여 프로그램의 흐름을 분기&lt;/li>
&lt;li>조건에 따라 다른 명령문 또는 블록을 실행&lt;/li>
&lt;li>일반적으로 &lt;code>if-else&lt;/code>문이나 &lt;code>switch-case&lt;/code>문을 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>반복(Iteration)
&lt;ul>
&lt;li>루프를 사용하여 특정 조건이 충족될 때까지 특정한 명령문 또는 블록을 반복하여 실행&lt;/li>
&lt;li>대표적으로는 &lt;code>for&lt;/code>루프나 &lt;code>while&lt;/code>루프&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 제어 구조들이 모든 프로그램을 작성하는 데 필요한 최소한의 구조라는 것을 보여주며, 즉 어떤 프로그램이라도 세 가지 구조로 구현할 수 있다는 것을 의미한다.&lt;/p>
&lt;h2 id="기능적-분해">기능적 분해&lt;/h2>
&lt;p>구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 분해할 수 있게 되었다.&lt;/p>
&lt;ul>
&lt;li>이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻하며, 거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있다.&lt;/li>
&lt;li>분해한 기능들은 구조적 프로그래밍의 &lt;strong>제한된 제어구조&lt;/strong>를 이용하여 표현할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이를 토대로 구조적 분석이나 구조적 설계와 같은 기법이 인기를 끌었으며, 개선되어 널리 알려졌다.&lt;/p>
&lt;ul>
&lt;li>대규모 시스템을 모듈과 컴포넌트로 나눌 수 있다.&lt;/li>
&lt;li>모듈과 컴포넌트는 입증할 수 있는 작은 기능들로 세분화할 수 있다.&lt;/li>
&lt;/ul>
&lt;h2 id="과학적-방법scientific-method">과학적 방법(Scientific Method)&lt;/h2>
&lt;blockquote>
&lt;p>테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄수는 없다.&lt;/p>
&lt;/blockquote>
&lt;p>소프트웨어 개발이 수학적인 구조를 다루는 듯 보이더라도, 소프트웨어 개발은 수학적인 시도가 아니다.&lt;/p>
&lt;p>오히려 올바르지 않음을 증명하는 데 실패함으로 올바름을 보여주는 과학과 같다.&lt;/p>
&lt;p>이러한 부정확함에 대한 증명은 입증 가능한 프로그램에만 적용할 수 있으며, 구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다.&lt;/p>
&lt;p>그러고 나서 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도하며, 거짓임을 증명하는 테스트가 실패한다면, 충분히 참이라고 여기게 된다.&lt;/p>
&lt;h2 id="현대적-가치">현대적 가치&lt;/h2>
&lt;p>구조적 프로그래밍에 대한 논의는 많은 새로운 언어를 낳았으며, 기존의 언어에 구조적인 면이 추가되는 등 언어의 발전에 도움이 되었다. 그리고 이후에 나온 프로그래밍 패러다임들에도 영향을 끼쳤다.&lt;/p>
&lt;p>구조적 프로그래밍은 프로그래머의 습관을 바꾸었다.&lt;/p>
&lt;p>프로그램의 정확성을 증명하는 문제를 떠나서 데이크스트라가 그의 논문에서 말한 대로 시간에 따라 변하는 동적인 과정을 시각화하는 것은 인간에게 매우 어려운 일이다.&lt;/p>
&lt;p>꼭 &lt;code>GOTO&lt;/code>문만의 문제가 아니라 구조화된 흐름 제어문을 사용한다고 할지라도 너무 복잡하게 중첩되어 있거나 스코프의 길이가 너무 긴 코드를 작성한다거나 너무 긴 길이의 하위프로그램을 작성하는 일을 가급적 피하게 경향이 생겼다.&lt;/p>
&lt;p>그리고 이런 습관은 다른 사람이 작성한 프로그래밍 코드를 쉽게 이해하는 데 도움을 준다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;ul>
&lt;li>구조적 프로그래밍이 가치있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력 때문이다.&lt;/li>
&lt;li>가작 작은 기능에서 부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 반증 가능성에 의해 주도된다.&lt;/li>
&lt;li>스프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기위해 노력해야 한다.&lt;/li>
&lt;li>구조적 프로그래밍과 유사한 제한적인 규칙들을 통해 쉽게 반증 가능한 구조를 만들 수 있다.&lt;/li>
&lt;/ul></description></item><item><title>3. 패러다임 개요</title><link>https://codemario318.github.io/post/clean-architecture/3/</link><pubDate>Sun, 18 Feb 2024 19:54:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/3/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/3/cover.png" alt="Featured image of post 3. 패러다임 개요" />&lt;h2 id="구조적-프로그래밍">구조적 프로그래밍&lt;/h2>
&lt;blockquote>
&lt;p>구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.&lt;/p>
&lt;/blockquote>
&lt;p>최초로 적용된 패러다임(최초로 만들어진 패러다임은 아님)으로 1968년 에츠허르 비버 데이크스트라가 발견했다.&lt;/p>
&lt;ul>
&lt;li>무분별한 점프(&lt;code>goto&lt;/code> 문장)는 프로그램 구조에 해롭다는 사실을 제시함&lt;/li>
&lt;li>이러한 점프들을 &lt;code>if/then/else&lt;/code>, &lt;code>do/while/until&lt;/code>과 같이 더 익숙한 구조로 대체함&lt;/li>
&lt;/ul>
&lt;h2 id="객체-지향-프로그래밍">객체 지향 프로그래밍&lt;/h2>
&lt;blockquote>
&lt;p>객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.&lt;/p>
&lt;/blockquote>
&lt;p>두 번째로 도입된 패러다음으로 구조적 프로그래밍보다 2년 앞선 1966년 올레 요한 달과 크리스텐 니가드에 의해 등장했다.&lt;/p>
&lt;p>알골(ALGOL) 언어의 함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지될 수 있음을 발견했다.&lt;/p>
&lt;ul>
&lt;li>이러한 함수가 클래스의 생성자가 되었고, 지역 변수는 인스턴스 변수, 중첩 함수는 메서드가 되었다.&lt;/li>
&lt;li>함수 포인터를 특정 규칙에 따라 사용하는 과정을 통해 필연적으로 다형성이 등장하게 되었다.&lt;/li>
&lt;/ul>
&lt;h2 id="함수형-프로그래밍">함수형 프로그래밍&lt;/h2>
&lt;blockquote>
&lt;p>함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.&lt;/p>
&lt;/blockquote>
&lt;p>최근에 들어서야 겨우 도입되기 시작했지만 가장 먼저 만들어졌다.&lt;/p>
&lt;p>알론조 처치는 앨런 튜링도 똑같이 흥미를 느꼈던 수학적 문제를 해결하는 과정에서 람다(Lambda) 계산법을 발명했는데, 함수형 프로그래밍은 이러한 연구 결과에 직접적인 영향을 받아 만들어졌다.&lt;/p>
&lt;p>1958년에 존 매카시가 만든 LISP 언어에 근간이 되는 개념이 바로 이 람다 계산법이다.&lt;/p>
&lt;ul>
&lt;li>람다 계산법의 기초가 되는 개념은 불변성으로, 심볼의 값이 변경되지 않는다는 개념이다.&lt;/li>
&lt;li>이는 함수형 언어에는 할당문이 전혀 없다는 뜻이기도 하다.&lt;/li>
&lt;li>대다수의 함수형 언어가 변수값을 변경할 수 있는 방법을 제공하기는 하지만, 굉장히 까다로운 조건 아래서만 가능하다.&lt;/li>
&lt;/ul>
&lt;h2 id="생각할-거리">생각할 거리&lt;/h2>
&lt;p>각 패러다임은 프로그래머에게서 권한을 박탈한다. 어느 패러다임도 새로운 권한을 부여하지 않는다.&lt;/p>
&lt;ul>
&lt;li>각 패러다임은 추가적인 규칙을 통해 특정 행동들을 하지 못하게 제약한다.&lt;/li>
&lt;li>패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안되는지를 말해준다.&lt;/li>
&lt;/ul>
&lt;p>각 패러다임이 우리에게서 무언가를 빼앗는다는 사실을 인지하는 것이다.&lt;/p>
&lt;ul>
&lt;li>구조적 프로그래밍: &lt;code>goto&lt;/code>문&lt;/li>
&lt;li>객체 지향 프로그래밍: 함수 포인터&lt;/li>
&lt;li>함수형 프로그래밍: 할당문&lt;/li>
&lt;/ul>
&lt;p>이 외에 개발자에게 가져갈 수 있는 것이 남아있지 않으므로, 프로그래밍 패러다임은 앞으로도 세 가지 밖에 없을 것이다.&lt;/p>
&lt;ul>
&lt;li>패러다임이 10년 동안 모두 만들어진 이후 수십 년이 지났지만 새롭게 등장한 패러다임은 전혀 없다.&lt;/li>
&lt;/ul>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>패러다임의 역사로부터 얻을 수 있는 이러한 교훈은 아키텍처와 큰 관계가 있다.&lt;/p>
&lt;ul>
&lt;li>아키텍처 경계를 넘나들기 위한 메커니즘으로 다형성을 이용한다.&lt;/li>
&lt;li>함수형 프로그래밍을 이용하여 데이터의 위치와 접근 방법에 대해 규칙을 부과한다.&lt;/li>
&lt;li>모듈 기반 알고리즘으로 구조적 프로그래밍을 사용한다.&lt;/li>
&lt;/ul>
&lt;p>세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목하자.&lt;/p></description></item><item><title>2. 두 가지 가치에 대한 이야기</title><link>https://codemario318.github.io/post/clean-architecture/2/</link><pubDate>Sun, 18 Feb 2024 19:03:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/2/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/2/cover.png" alt="Featured image of post 2. 두 가지 가치에 대한 이야기" />&lt;p>모든 소프트웨어 시스템은 이해관계자에게 행위(Behavior)와 구조(Structure)라는 두가지 가치를 제공한다.&lt;/p>
&lt;p>따라서 소프트웨어 개발자는 두 가치를 모두 반드시 높게 유지해야 하는 책임을 진다.&lt;/p>
&lt;p>하지만 한 가지 가치에만 집중하고 나머지 가치는 배제하곤 하며, 대체로 덜 중요한 가치에 집중하여 결국에는 소프트웨어 시스템이 쓸모 없게 만들어버린다.&lt;/p>
&lt;h2 id="행위기능">행위(기능)&lt;/h2>
&lt;p>프로그래머를 고용하는 이유는 이해관계자를 위해 기계가 수익을 창출하거나 비용을 절약하도록 만들기 위해서이다.&lt;/p>
&lt;ul>
&lt;li>이해관계자가 기능 명세서나 요구사항 문서를 구체화할 수 있도록 돕는다.&lt;/li>
&lt;li>이해관계자의 기계가 이러한 요구사항을 만족하도록 코드를 작성한다.
&lt;ul>
&lt;li>요구사항을 위반하면 문제를 고친다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>행위는 개발자가 구현해야하는 기능을 의미하며, 기능을 구현하고 만들어진 기능을 운영하는 것만을 개발자의 역할이라고 생각한다.&lt;/p>
&lt;h2 id="아키텍처">아키텍처&lt;/h2>
&lt;p>소프트웨어라는 단어는 부드러운(soft)과 제품(ware)의 합성어이다.&lt;/p>
&lt;p>소프트웨어는 부드러움을 지니도록 만들어졌으며, 소프트웨어를 만든 이유는 기계의 행위를 쉽게 변경할 수 있도록 하기 위해서이다.&lt;/p>
&lt;p>따라서 소프트웨어가 가진 본연의 목적을 추구하려면 소프트웨어는 반드시 부드러움, 즉 변경이 쉬워야하며 이해관계자가 기능에 대한 생각을 바꾸면 이러한 변경사항을 간단하고 쉽게 적용할 수 있어야 한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>변경사항을 적용하는 데 드는 어려움은 변경되는 범위에 비례해야하며, 변경사항의 형태와는 관련이 없어야 한다.&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>소프트웨어 개발 비용의 증가를 결정짓는 주된 요인은 바로 변경사항의 범위와 형태의 차이에 있다.&lt;/p>
&lt;p>이해관계자는 범위가 비슷한 일련의 변경사항을 제시할 뿐이지만, 개발자 입장에서는 복잡도가 지속적으로 증가하는 퍼즐 판 위에서 이해관계자가 계속해서 퍼즐 조각을 맞추라는 지시를 하는 것처럼 느낀다.&lt;/p>
&lt;p>이는 시스템의 형태와 요구사항의 형태가 서로 맞지 않기 때문인데, 원인은 소프트웨어 아키텍처다.&lt;/p>
&lt;p>아키텍처가 특정 형태를 다른 형태보다 선호하면 할수록, 새로운 기능을 이 구조에 맞추는 게 더 힘들어진다.&lt;/p>
&lt;p>&lt;strong>따라서 아키텍처는 항상 형태에 독립적이어야하고, 그럴수록 더 실용적이다.&lt;/strong>&lt;/p>
&lt;h2 id="더-높은-가치">더 높은 가치&lt;/h2>
&lt;p>기능과 아키텍처 둘 중 어느 것의 가치가 더 높은지 업무 관리자에게 묻는다면, 대다수가 소프트웨어 시스템이 동작하는 것이 더 중요하다고 대답하지만, 개발자는 아키텍처에 더 가치를 둬야한다.&lt;/p>
&lt;p>&lt;strong>양 극단 사례 검토&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>완벽하게 동작하지만 수정이 불가능한 프로그램은 요구사항이 변경될 때 동작하지 않게 되어 쓸모가 없다.&lt;/li>
&lt;li>동작은 하지 않니만 변경이 쉬운 프로그램은 개발자가 돌아가도록 만들 수 있고, 변경사항이 발생하더라도 여전히 동작하여 유용한채로 남는다.&lt;/li>
&lt;/ul>
&lt;p>변경에 드는 비용이 변경으로 창출되는 수익을 초과하는 경우 수정이 현실적으로 불가능하며, 이로 인해 기능 또는 설정 측면에서 만은 시스템이 현실적으로 수정할 수 없는 상황에 빠진다.&lt;/p>
&lt;p>현재의 기능 동작을 위해 미래의 유연성을 희생한다면, 변경에 드는 비용이 높아지게되어 현실적으로 수정할 수 없는 상황에 빠지게되고, 결과적으로 책임은 개발자에게 돌아간다.&lt;/p>
&lt;h2 id="아이젠하워-매트릭스">아이젠하워 매트릭스&lt;/h2>
&lt;p>긴급한 문제가 아주 중요한 문제일 경우는 드물고, 중요한 문제가 몹시 긴급한 경우는 거의 없다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/2/img.png"
width="1440"
height="1476"
srcset="https://codemario318.github.io/post/clean-architecture/2/img_hub52f30903063439618abfbc9fbd0cd5f_559836_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/2/img_hub52f30903063439618abfbc9fbd0cd5f_559836_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="아이젠하워 매트릭스"
class="gallery-image"
data-flex-grow="97"
data-flex-basis="234px"
>&lt;/p>
&lt;ol>
&lt;li>긴급 O, 중요 O&lt;/li>
&lt;li>긴급 X, 중요 O&lt;/li>
&lt;li>긴급 O, 중요 X&lt;/li>
&lt;li>긴급 X, 중요 X&lt;/li>
&lt;/ol>
&lt;p>아이젠하워 매트릭스에서는 위와 같은 우선순위로 문제를 해결할 것을 제안하고 있다.&lt;/p>
&lt;hr>
&lt;p>첫 번째 가치인 행위는 대부분 긴급하지만 매번 높은 중요도를 가지는 것은 아니며, 두 번째 가치인 아키텍처는 중요하지만 즉각적인 긴급성을 필요로 하는 경우는 절대 없다.&lt;/p>
&lt;p>아키텍처는 1, 2를 차지하는 반변, 행위는 1, 3에 위치한다.&lt;/p>
&lt;p>많은 업무 관리자와 개발자가 3번에 위치한 항목을 1번으로 격상시키는 실수를 많이 한다.&lt;/p>
&lt;ul>
&lt;li>긴급하지만 중요하지 않은 기능과 진짜로 긴급하면서 주용한 기능을 구분하지 못한다.&lt;/li>
&lt;/ul>
&lt;p>이러한 실패로 중요도가 높은 아키텍처를 무시한 채 중요도가 떨어지는 기능을 선택하게 된다.&lt;/p>
&lt;h2 id="아키텍처를-위해-투쟁하라">아키텍처를 위해 투쟁하라&lt;/h2>
&lt;p>더 중요한 가치인 아키텍처가 더 낮은 우선순위를 가지게 되는 이유는 대부분의 업무 관리자가 아키텍처의 중요성을 평가하지 못하기 때문이다.&lt;/p>
&lt;p>따라서 개발자, 개발팀은 다른 이해관계자들을 설득해야 할 의무가 있다.&lt;/p>
&lt;ul>
&lt;li>기능의 긴급성이 아닌 아키텍처의 중요성을 설득하는 일은 소프트웨어 개발팀이 책임을 져야한다.&lt;/li>
&lt;li>소프트웨어 개발자도 이해관계자이며, 소프트웨어를 안전하게 보호해야 할 책임이 있다.&lt;/li>
&lt;/ul>
&lt;p>소프트웨어 아키텍트는 시스템이 제공하는 특성이나 기능보다는 시스템의 구조에 더 중점을 둔다. 아키텍트는 이러한 특성과 기능을 개발하기 쉽고, 간편하게 수정할 수 있으며, 확장하기 쉬운 아키텍처를 만들어야 한다.&lt;/p>
&lt;p>개발자가 아키텍처에 더 높은 우선순위를 둘 수 있도록 이해관계자들과 투쟁하는 것은 장기적인 관점에서 더 나은 소프트웨어를 만들 수 있는 가능성을 높힌다.&lt;/p>
&lt;hr>
&lt;p>아키텍처가 후순위가 되면 시스템을 개발하는 비용이 점점 더 많이 들게되고, 결국 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 힘들어진다.&lt;/p>
&lt;p>이러한 상황이 발생하도록 용납했다면, 이는 결국 소프트웨어 개발팀이 스스로 옳다고 믿는 가치를 위해 충분히 투쟁하지 않았다는 뜻이다.&lt;/p></description></item><item><title>1. 설계와 아키텍처란?</title><link>https://codemario318.github.io/post/clean-architecture/1/</link><pubDate>Sun, 18 Feb 2024 18:09:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/1/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/1/cover.png" alt="Featured image of post 1. 설계와 아키텍처란?" />&lt;h2 id="설계와-아키텍처의-차이">설계와 아키텍처의 차이&lt;/h2>
&lt;p>설계(Design)와 아키텍처(Architecture)의 정의가 모호하여 오랫동안 많은 혼란이 있었지만 실제로는 둘의 차이는 없다.&lt;/p>
&lt;ul>
&lt;li>아키텍처는 저수준 세부사항과는 분리된 고수준의 무언가를 가릴킬 때 흔히 사용된다.&lt;/li>
&lt;li>설계는 저수준의 구조 또는 결정사항 등을 의미할 때가 많다.&lt;/li>
&lt;/ul>
&lt;p>하지만 아키텍트가 실제로 하는 일을 살펴보면 이러한 구분은 무의미하다.&lt;/p>
&lt;h3 id="새로운-집">새로운 집&lt;/h3>
&lt;p>새로운 집을 설계하는 아키텍트가 있다면 이 집의 아키텍처는 형태, 외관, 입면도, 공간이나 방의 배치등이 포함된다.&lt;/p>
&lt;p>하지만 아키텍트가 만든 도면을 살펴보면 콘센트, 전등 스위치, 전등이 모두 어디에 위치하는 지 등 세부사항도 모두 확인할 수 있으며, 벽, 지붕 기초 공사등이 어떻게 진행될지도 상세히 확인할 수 있다.&lt;/p>
&lt;p>이처럼 모든 고수준의 결정사항을 지탱하는 &lt;strong>모든 세부사항&lt;/strong>과 &lt;strong>고수준의 결정사항&lt;/strong>은 집의 전체 설계의 구성요소가 된다.&lt;/p>
&lt;p>소프트웨어 설계도 마찬가지로, 저수준의 세부사항과 고수준의 구조는 모두 소프트웨어 전체 설계의 구성요소다.&lt;/p>
&lt;p>저수준 세부사항과 고수준 세부사항은 &lt;strong>단절 없이 이어진 직물&lt;/strong>과 같으며, 이를 통해 대상 시스템의 구조를 정의한다.&lt;/p>
&lt;blockquote>
&lt;p>이 둘은 개별로 존재할 수 없으며, 경계 또한 뚜렸하지 않고 &lt;strong>고수준에서 저수준으로 향하는 의사결정의 연속성만이 있을 뿐이다.&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;h2 id="목표는">목표는?&lt;/h2>
&lt;p>이러한 의사결정, 좋은 소프트웨어 설계 즉 소프트웨어 아키텍처의 목표는 &lt;strong>필요한 시스템을 만드록 유지보수하는데 투입되는 인력을 최소화하는 데 있다.&lt;/strong>&lt;/p>
&lt;p>설계 품질의 척도는 고객의 &lt;strong>요구를 만족시키는 데 드는 비용&lt;/strong> 척도와 다름 없다.&lt;/p>
&lt;ul>
&lt;li>비용이 낮을 뿐만 아니라 시스템의 수명이 다할 때까지 &lt;strong>낮게 유지할 수 있다면 좋은 설계&lt;/strong>라고 말할 수 있다.&lt;/li>
&lt;li>새로운 기능을 출시할 때 마다 &lt;strong>비용이 증가&lt;/strong>한다면 나쁜 설계다.&lt;/li>
&lt;/ul>
&lt;h2 id="좋은-설계가-필요한-이유">좋은 설계가 필요한 이유&lt;/h2>
&lt;p>소프트웨어 아키텍처가 나쁘다면 소프트웨어가 진화함에 따라 점점 비용이 증가한다. (생산성이 떨어진다.)&lt;/p>
&lt;ul>
&lt;li>이러한 비용의 상승은 사업 모델의 수익을 고갈시킨다.&lt;/li>
&lt;li>회사의 성장을 멈추게 하거나 심지어는 완전히 망하게 만든다.&lt;/li>
&lt;/ul>
&lt;p>시스템을 급하게 만들거나, 결과물의 총량을 순전히 프로그래머 수만으로 결정하거나, 코드와 설계와 구조를 깔끔하게 만들려는 생각을 전혀 하지 않는다면, 시간이 지남에 따라 비용이 급격히 상승하게되고, 이를 통해 생산성이 바닥을 치게 된다.&lt;/p>
&lt;p>이러한 현상이 발생하게 되면 개발자가 기능 개발보다는 엉망이 된 상황에 대처하는 데 소모되기 시작하며, 개발자들이 쏟은 노력의 가치를 보잘것없게 만든다.&lt;/p>
&lt;h3 id="무엇이-잘못-되었나">무엇이 잘못 되었나?&lt;/h3>
&lt;p>&lt;strong>생산성을 유지할 수 있다는 착각&lt;/strong>&lt;/p>
&lt;p>일부 개발자들은 생산성을 유지할 수 있다고 자신의 능력을 과신한다.(언제든지 돌아가 생산성을 회복시킬 수 있다고 생각한다.)&lt;/p>
&lt;p>현대의 개발자들은 빠른 시장 출시가 경쟁자보다 앞서 가는 것이라 생각하며 &amp;ldquo;코드는 나중에 정리하면 돼. 당장은 시장에 출시하는 게 먼저야!&amp;ldquo;라고 스스로를 속인다.&lt;/p>
&lt;p>하지만 시장의 압박은 절대 수그러들지 않기 때문에 태세를 전환하지 않고 정리하는 일은 매우 드물게 되며, 이로 인해 휼륭하고 깔끔하게 잘 설계된 코드와 점점 더 거리가 멀어지게 된다.&lt;/p>
&lt;p>이러한 상황에서 계속해서 새로운 기능들이 추가가 되어 결국 엉망진창이 되고, 생산성이 0으로 수렴하기 시작한다.&lt;/p>
&lt;p>&lt;strong>지저분한 코드를 작성하면 단기간에 빠르게 갈 수 있다는 착각&lt;/strong>&lt;/p>
&lt;p>지저분한 코드를 작성하면 단 기간에는 빠르게 갈 수 있고, &lt;strong>장기적으로 볼 때만 생산성이 낮아진다는 견해&lt;/strong>는 엉망으로 코드를 짜기위한 자기합리화이며, 진실은 &lt;strong>엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리다.&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/1/img.png"
width="491"
height="355"
srcset="https://codemario318.github.io/post/clean-architecture/1/img_hu97e80447e00e45f30d31a1b6d7350367_79701_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/1/img_hu97e80447e00e45f30d31a1b6d7350367_79701_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이터레이션별 걸린 시간과 TDD 적용 여부"
class="gallery-image"
data-flex-grow="138"
data-flex-basis="331px"
>&lt;/p>
&lt;p>제이슨 고먼은 코드를 깔끔하게 유지하는 잘 알려진 방법 중 하나인 TDD를 사용 여부로 생산성을 측정했다.&lt;/p>
&lt;p>TDD를 적용했을때가 훨씬 더 빨랐으며, 심지어 TDD를 적용한 가장 느렸던 날이 적용하지 않은 가장 빨리 작업한 날보다 더 빨랐다.&lt;/p>
&lt;blockquote>
&lt;p>빨리 가는 유일한 방법은 제대로 가는 것이다.&lt;/p>
&lt;/blockquote>
&lt;p>생산성이 감소되고 비용이 증가하는 현상을 되돌릴 수 있는 유일한 방법은 없다.&lt;/p>
&lt;p>이러한 문제를 해결하기 위해 처음부터 다시 시작하더라도 한번 문제를 발생시킨 개발자(팀)는 똑같은 문제를 반복하는 경우가 많으며, 이 때문에 항상 코드와 설계를 깔끔하게 만들려는 노력을 지속해야한다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>어떤 경우라도 개발 조직이 할 수 있는 최고의 선택지는 조직에 스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처의 품질을 심각하게 고민하기 시작하는 것이다.&lt;/p>
&lt;p>소프트웨어 아키텍처를 심각하게 고려할 수 있으려면 좋은 소프트웨어 아키텍처가 무엇인지 이해해야 한다.&lt;/p>
&lt;ul>
&lt;li>비용은 최소화하고 생산성은 최대화 할 수 있는 설계와 아키텍처를 가진 시스템을 만드려면, 시스템 아키텍처가 지닌 속성을 알고 있어야 한다.&lt;/li>
&lt;/ul>
&lt;p>이 책은 훌륭하고 깔끔한 아키텍처와 설계가 무엇인지 설명하고, 이를 통해 소프트웨어 개발자가 장시간에 걸쳐 수익을 창출하는 시스템을 만들 수 있게 하고자 한다.&lt;/p></description></item></channel></rss>