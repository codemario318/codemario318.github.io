<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>System Design Interview on Mario Blog</title><link>https://codemario318.github.io/tags/system-design-interview/</link><description>Recent content in System Design Interview on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Thu, 11 Jul 2024 11:07:50 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/system-design-interview/index.xml" rel="self" type="application/rss+xml"/><item><title>14. 유튜브 설계</title><link>https://codemario318.github.io/post/system-design-interview/14/</link><pubDate>Thu, 11 Jul 2024 11:07:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/14/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/cover.png" alt="Featured image of post 14. 유튜브 설계" />&lt;p>유튜브 시스템을 설계하는 방식은 넷플릭스나 훌루 같은 &lt;strong>비디오 플랫폼&lt;/strong>을 설계하는 문제에도 적용 가능하다.&lt;/p>
&lt;p>유튜브 시스템에서 제공하는 기능들은 단순해보이지만, 엄청난 트래픽으로 인해 매우 복잡한 수많은 기술들이 숨어있다.&lt;/p>
&lt;ul>
&lt;li>MAU: 20억&lt;/li>
&lt;li>매일 재생되는 비디오 수: 50억&lt;/li>
&lt;li>5천만명의 창작자&lt;/li>
&lt;li>광고 수입은 2019년 기중 150억 달러&lt;/li>
&lt;li>전체 모바일 트래픽 중 37%는 유튜브&lt;/li>
&lt;li>80개 언어로 사용 가능&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>유튜브에서는 비디오를 보는 것 말고도 많은 일을 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>댓글&lt;/li>
&lt;li>비디오 공유&lt;/li>
&lt;li>좋아요&lt;/li>
&lt;li>재생 목록 저장&lt;/li>
&lt;li>구독&lt;/li>
&lt;/ul>
&lt;p>모든 내용을 설계 면접 동안 만들 수 없으므로, 요구하는 핵심 기능만을 찾아 범위를 제한해야한다.&lt;/p>
&lt;ul>
&lt;li>Q. 가장 중요한 기능은?
&lt;ul>
&lt;li>A. 비디오를 올리는 기능과 시청하는 기능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 지원 클라이언트는?
&lt;ul>
&lt;li>A. 모바일 앱, 웹 브라우저, 스마트 TV&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 일간 능동 사용자 수?
&lt;ul>
&lt;li>A. 5백만&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 이 제품에 평균적으로 소비하는 시간
&lt;ul>
&lt;li>A. 30분&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 다국어 지원?
&lt;ul>
&lt;li>A. 어떤 언어로도 사용 가능해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 비디오 해상도 지원 범위?
&lt;ul>
&lt;li>A. 현존하는 비디오 종류와 해상도를 대부분 지원해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 암호화?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 비디오 파일 크기에 제한?
&lt;ul>
&lt;li>A. 1GB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 클라우드 서비스 사용 가능 여부?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위 질문을 통해 찾아낸 요구사항과 비디오 스트리밍 서비스에 필요한 항목들을 정리하면 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>빠른 비디오 업로드&lt;/li>
&lt;li>원활한 비디오 재생&lt;/li>
&lt;li>재생 품질 선택 가능(대부분의 종류와 해상도 지원)&lt;/li>
&lt;li>낮은 인프라 비용&lt;/li>
&lt;li>높은 가용성과 규모 확장성, 안정성(DAU 5백만)&lt;/li>
&lt;li>지원 클라이언트(모바일 앱, 브라우저, 스마트 TV)&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;p>시스템이 처리해야하는 트래픽 규모를 추정하여 어떤 기술들을 어디까지 활용해야야하는지 파악한다.&lt;/p>
&lt;p>도메인에 대해 정확히 파악할 수 없을 때는 상식적인 범위 내에서 조건을 가정한다.&lt;/p>
&lt;ul>
&lt;li>DAU 5백만&lt;/li>
&lt;li>한 사용자가 하루 평균 5개 비디오 시청&lt;/li>
&lt;li>10%의 사용자가 하루에 비디오 1개 업로드&lt;/li>
&lt;li>비디오의 평균 크기는 300MB&lt;/li>
&lt;li>비디오 저장을 위해 매일 새로 요구되는 저장 용량
&lt;ul>
&lt;li>&lt;code>500만 * 10% * 300MB = 150TB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CDN 비용
&lt;ul>
&lt;li>클라우드 CDN 사용시 나가는 데이터의 양에 따라 과금된다.&lt;/li>
&lt;li>아마존 클라우드 프론트를 사용할 경우, 미국 기준 1GB당 $0.02&lt;/li>
&lt;li>비디오 스트리밍 기준 &lt;code>5백만 * 5 비디오 * 0.3GB * $0.02 = $150,000&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>추정 결과에 따르면 CDN을 통해 비디오를 서비스할 경우 비용이 엄청나다.&lt;/p>
&lt;p>따라서 CDN으로 인한 비용을 줄이는 방법들까지 고민해야한다.&lt;/p>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>이번 설계안은 &lt;strong>CDN&lt;/strong>과 &lt;strong>BLOB 스토리지&lt;/strong>의 경우 기존 클라우드 서비스를 활용한다.&lt;/p>
&lt;ul>
&lt;li>시스템 설계 면접은 모든 것을 밑바닥부터 만드는 것과는 큰 관계는 없다.
&lt;ul>
&lt;li>주어진 시간 안에 적절한 기술을 골라 설계를 마치는 것이 핵심&lt;/li>
&lt;li>모든 세부 컴포넌트에 대해 설계를 제시하는 것은 지나치다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규모 확장이 쉬운 BLOB 저장소, CDN을 만드는 것은 복잡하며, 비용이 많이 든다.
&lt;ul>
&lt;li>넷플릭스, 페이스북 같은 회사들도 클라우드 서비스를 이용할 정도로&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>개략적으로 보면 이 시스템은 세가지 컴포넌트로 구성된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img.png"
width="593"
height="389"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_hu4cce8c795583504b2953e667e22fdfeb_101903_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_hu4cce8c795583504b2953e667e22fdfeb_101903_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="152"
data-flex-basis="365px"
>&lt;/p>
&lt;ul>
&lt;li>사용자 단말&lt;/li>
&lt;li>CDN
&lt;ul>
&lt;li>비디오가 저장되며 재생 버튼을 누르면 CDN으로부터 스트리밍이 이루어진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>API 서버
&lt;ul>
&lt;li>비디오 스트리밍을 제외한 모든 요청은 API 서버가 처리한다.&lt;/li>
&lt;li>피드 추천, 비디오 업로드 URL 생성, 메타데이터 데이터베이스와 캐시 갱신, 사용자 가입 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>핵심 영역인 &lt;strong>비디오 업로드 절차&lt;/strong>와 &lt;strong>비디오 스트리밍 절차&lt;/strong>를 설계한다.&lt;/p>
&lt;h3 id="비디오-업로드-절차">비디오 업로드 절차&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_1.png"
width="656"
height="831"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_1_hu70082ea2eaddf8f402958853a376db04_212338_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_1_hu70082ea2eaddf8f402958853a376db04_212338_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비디오 업로드 절차 설계안"
class="gallery-image"
data-flex-grow="78"
data-flex-basis="189px"
>&lt;/p>
&lt;ul>
&lt;li>API 서버
&lt;ul>
&lt;li>비디오 스트리밍을 제외한 모든 요청 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 DB
&lt;ul>
&lt;li>비디오의 메타데이터 보관&lt;/li>
&lt;li>샤딩과 다중화를 적용하여 성능 및 가용성 요구사항을 충족시킨다고 가정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 캐시
&lt;ul>
&lt;li>비디오 메타데이터와 사용자 객체를 캐싱&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>원본 저장소
&lt;ul>
&lt;li>원본 비디오를 보관할 대형 이진 파일 저장소&lt;/li>
&lt;li>BLOB(Binary Large Object storage)
&lt;ul>
&lt;li>이진 데이터를 하나의 개체로 보관하는 데이터베이스 관리 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>트랜스코딩 서버
&lt;ul>
&lt;li>비디오의 포맷을 변호나하는 절차를 수행하는 서버&lt;/li>
&lt;li>단말, 대역폭 요구사항에 맞는 최적의 비디오 스트림을 제공하기 위해&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>트랜스코딩 비디오 저장소
&lt;ul>
&lt;li>트랜스코딩이 완료된 비디오를 저장하는 BLOB 저장소&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CDN
&lt;ul>
&lt;li>비디오를 캐싱&lt;/li>
&lt;li>비디오 스트리밍은 CDN을 통해 이루어짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>트랜스코딩 완료 큐
&lt;ul>
&lt;li>비디오 트랜스코딩 완료 이벤트를 보관할 메시지 큐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>트랜스코딩 완료 핸들러
&lt;ul>
&lt;li>트랜스코딩 완료 큐에서 이벤트 데이터를 꺼내어 메타데이터 캐시와 데이터베이스를 갱신할 작업 서버들&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_2.png"
width="747"
height="940"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_2_hu7b8c4341cb5ee562e65ac270a4fefc87_253761_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_2_hu7b8c4341cb5ee562e65ac270a4fefc87_253761_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비디오 업로드 절차"
class="gallery-image"
data-flex-grow="79"
data-flex-basis="190px"
>&lt;/p>
&lt;p>비디오 업로드는 &lt;strong>비디오 업로드&lt;/strong>와 &lt;strong>비디오 메타데이터 갱신&lt;/strong>이 병렬적으로 수행된다.&lt;/p>
&lt;p>&lt;strong>프로세스 a: 비디오 업로드&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>비디오를 원본 저장소에 업로드&lt;/li>
&lt;li>트랜스 코딩 서버가 원본 저장소에서 해당 비디오를 가져와 트랜스코딩을 시작&lt;/li>
&lt;li>완료 후 아래 절차가 병렬적으로 수행
&lt;ul>
&lt;li>트랜스코딩 비디오 저장소로 업로드&lt;/li>
&lt;li>트랜스코딩 완료 이벤트를 트랜스코딩 완료 큐에 넣음
&lt;ol>
&lt;li>트랜스코딩이 끝난 비디오를 CDN에 올림&lt;/li>
&lt;li>완료 핸들러가 이벤트 데이터를 큐에서 꺼냄&lt;/li>
&lt;li>완료 핸들러가 메타데이터 데이터베이스와 캐시를 갱신&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비디오 업로드가 끝나 스트리밍 준비가 되었음을 알림&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>프로세스 b: 메타데이터 갱신&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_3.png"
width="316"
height="578"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_3_hudff31fcb22044dbd74a52c9078466beb_87582_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_3_hudff31fcb22044dbd74a52c9078466beb_87582_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="메타데이터 갱신"
class="gallery-image"
data-flex-grow="54"
data-flex-basis="131px"
>&lt;/p>
&lt;p>원본 저장소에 파일이 업로드 되는 동안, 병렬적으로 비디오 메타데이터 갱신 요청을 API 서버에 보내 처리한다.&lt;/p>
&lt;ul>
&lt;li>파일 이름, 크기, 포맷 등&lt;/li>
&lt;/ul>
&lt;h3 id="비디오-스트리밍-절차">비디오 스트리밍 절차&lt;/h3>
&lt;p>스트리밍은 사용자의 장치가 원격지의 비디오로부터 지속적으로 비디오 스트림을 전송받아 영상을 재생하는 것을 말한다.&lt;/p>
&lt;p>&lt;strong>스트리밍 프로토콜&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>비디오 스트리밍을 위해 데이터를 전송할 때 쓰이는 표준화된 통신 방법&lt;/p>
&lt;ul>
&lt;li>MPEG-DASH(Moving Picture Experts Group-Dynamic Adaptive Streaming over HTTP)&lt;/li>
&lt;li>Apple HLS(HTTP Live Streaming)&lt;/li>
&lt;li>MS Smooth Streaming&lt;/li>
&lt;li>어도비 HDS(HTTP Dynamic Streaming) 등&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>프로토콜마다 지원하는 비디오 인코딩이 다르기 때문에 플레이어도 다르다.&lt;/p>
&lt;p>따라서 비디오 스트리밍 서비스를 설계할 때는 서비스 용례에 맞는 프로토콜을 잘 골라 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_4.png"
width="316"
height="395"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_4_hu87113ebea9cc3d063b24dd7ea8977935_50216_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_4_hu87113ebea9cc3d063b24dd7ea8977935_50216_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="스트리밍 절차"
class="gallery-image"
data-flex-grow="80"
data-flex-basis="192px"
>&lt;/p>
&lt;p>비디오는 CDN에서 바로 스트리밍된다. 사용자의 단말에 가장 가까운 CDN 에지 서버가 비디오 전송을 담당할 것이다.&lt;/p>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>비디오 업로드를 담당하는 부분과 비디오 스트리밍을 담당하는 부분을 최적화 방안을 통해 다듬고, 요류 처리 매커니즘을 반영한다.&lt;/p>
&lt;h3 id="비디오-트랜스코딩">비디오 트랜스코딩&lt;/h3>
&lt;p>비디오를 녹화하면 특정 포맷으로 저장되는데, 다른 단말에서도 잘 재생되려면 호환되는 비트레이트 포맷으로 저장되어야 한다.&lt;/p>
&lt;p>비디오 트랜스코딩은 다음과 같은 이유로 중요하다.&lt;/p>
&lt;ul>
&lt;li>원본 비디오는 저장 공간을 많이 차지한다.&lt;/li>
&lt;li>대부분 클라이언트는 특정 종류의 비디오 포맷만 지원한다.
&lt;ul>
&lt;li>하나의 비디오를 여러 포맷으로 인코딩 해놓아야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>끊김 없는 재생을 보장하기위해 사용자에게 맞는 화질의 비디오를 제공하는 것이 좋다.
&lt;ul>
&lt;li>대역폭 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모바일의 경우 네트워크 상황이 실시간으로 달라질 수 있는데 이에 맞추어 화질이 자동으로 변경되거나 변경할 수 있게 해야한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>인코딩 포멧&lt;/strong>&lt;/p>
&lt;p>대부분의 인코딩 포멧은 다음 두 부분으로 구성되어있다.&lt;/p>
&lt;ul>
&lt;li>컨테이너
&lt;ul>
&lt;li>비디오 파일, 오디오, 메타데이터를 담는 바구니&lt;/li>
&lt;li>컨테이너 포맷은 확장자를 통해 확인할 수 있다(.avi, .mov, .mp4 등)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>코덱
&lt;ul>
&lt;li>비디오 화질을 보존하며 파일 크기를 줄일 목적으로 고안된 압축 및 해제 알고리즘&lt;/li>
&lt;li>H.264, VP9, HEVC 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="유향-비순환-그래프dag-모델">유향 비순환 그래프(DAG) 모델&lt;/h3>
&lt;p>비디오를 트랜스코딩하는 것은 컴퓨터 자원을 많이 소모할 뿐 아니라 시간도 많이 든다.&lt;/p>
&lt;p>또한 콘텐츠 창작자가 각자 가기만의 비디오 프로세싱 요구사항을 가지고있다.&lt;/p>
&lt;ul>
&lt;li>워터마크&lt;/li>
&lt;li>커스텀 섬네일 이미지&lt;/li>
&lt;li>화질 등&lt;/li>
&lt;/ul>
&lt;p>이러한 각기 다른 유형의 비디오 프로세싱 파이프라인을 지원하는 한편 처리 과정의 병렬성을 높히기 위해 적절한 수준의 추상화를 도입하여 클라이언트 프로그래머로 하여금 실행할 작업을 손수 정의할 수 있도록 해야한다.&lt;/p>
&lt;p>페이스북의 스트리밍 비디오 엔진은 DAG 프로그래밍 모델을 도입하여 해당 작업들이 순차적, 병렬적으로 실행될 수 있도록 하고있다.&lt;/p>
&lt;ul>
&lt;li>DAG 모델을 도입하면 유연성과 병렬성을 달성할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_5.png"
width="781"
height="544"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_5_hu7cc05f01956a08985411c34766a925ae_91407_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_5_hu7cc05f01956a08985411c34766a925ae_91407_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비디오 트랜스코딩을 위한 DAG 모델"
class="gallery-image"
data-flex-grow="143"
data-flex-basis="344px"
>&lt;/p>
&lt;p>원본 비디오는 비디오, 오디오, 메타데이터 세 부분으로 나뉘어 처리된다.&lt;/p>
&lt;p>&lt;strong>비디오&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>검사(inspection)
&lt;ul>
&lt;li>좋은 품질의 비디오인지, 손상은 없는지 확인한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비디오 인코딩(video encoding)
&lt;ul>
&lt;li>비디오를 다양한 해상도, 코덱, 비트레이트 조함으로 인코딩한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>섬네일(thumbnail)
&lt;ul>
&lt;li>사용자가 업로드한 이미지나 비디오에서 자동으로 추출된 이미지로 섬네일을 만든다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>워터마크(watermark)
&lt;ul>
&lt;li>비디오데 대한 식별정보를 이미지 위에 오버레이 형태로 띄워 표시한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="비디오-트랜스코딩-아키텍처">비디오 트랜스코딩 아키텍처&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_6.png"
width="819"
height="284"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_6_hu0b01e363c29d39f2e82de0b1928b742d_47551_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_6_hu0b01e363c29d39f2e82de0b1928b742d_47551_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클라우드 서비스를 활용한 비디오 트랜스코딩 아키텍처"
class="gallery-image"
data-flex-grow="288"
data-flex-basis="692px"
>&lt;/p>
&lt;p>클라우드 서비스를 활용한 비디오 트랜스코딩 아키텍처는 다섯 개의 주요 컴포넌트로 구성된다.&lt;/p>
&lt;ul>
&lt;li>전처리기(preprocessor)&lt;/li>
&lt;li>DAG 스케줄러&lt;/li>
&lt;li>자원 관리자(resource manager)&lt;/li>
&lt;li>작업 실행 서버(resource worker)&lt;/li>
&lt;li>임시 저장소(temporary storage)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>전처리기&lt;/strong>&lt;/p>
&lt;p>전처리기는 3가지 작업을 수행한다.&lt;/p>
&lt;ul>
&lt;li>비디오 분할(video spliting)
&lt;ul>
&lt;li>비디오 스트림을 GOP(Group of Pictures)라고 불리는 단위로 쪼갠다.&lt;/li>
&lt;li>오래된 단말이나 브라우저는 GOP 단위의 비디오 분할을 제공하지 않기 때문에 전처리기가 대신 수행한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>GOP&lt;br>
특정 순서로 배열된 프레임(frame) 그룹으로 하나의 GOP는 독립적으로 재생 가능하며, 길이는 보통 몇 초 정도다.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>DAG 생성
&lt;ul>
&lt;li>작성한 설정 파일에 따라 DAG를 만들어낸다.
&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_7.png"
width="451"
height="83"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_7_hude8451aecf6802d6db73c3e028a66766_14090_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_7_hude8451aecf6802d6db73c3e028a66766_14090_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="2개 노드와 1개 연결선으로 구성된 DAG"
class="gallery-image"
data-flex-grow="543"
data-flex-basis="1304px"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_8.png"
width="724"
height="265"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_8_hu4636aecea695599046327b39949966d6_113859_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_8_hu4636aecea695599046327b39949966d6_113859_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="DAG 설정 파일"
class="gallery-image"
data-flex-grow="273"
data-flex-basis="655px"
>&lt;/p>
&lt;ul>
&lt;li>데이터 캐시
&lt;ul>
&lt;li>전처리기는 분할된 비디오의 캐시 역할도 수행한다.&lt;/li>
&lt;li>안정성을 높이기 위해 GOP와 메타데이터를 임시 저장소에 보관한다.&lt;/li>
&lt;li>인코딩 실패시 보관된 데이터를 활용해 인코딩을 재개한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>DAG 스케줄러&lt;/strong>&lt;/p>
&lt;p>DAG 그래프를 몇 개 단계(stage)로 분할한 다음 그 각각을 자원 관리자의 작업 큐에 집어넣는다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_9.png"
width="837"
height="499"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_9_hud8ab1112f1b56f8a3a48350b48cfacc7_104927_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_9_hud8ab1112f1b56f8a3a48350b48cfacc7_104927_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="DAG 스케줄러 동작 사례"
class="gallery-image"
data-flex-grow="167"
data-flex-basis="402px"
>&lt;/p>
&lt;p>하나의 DAG를 2개 작업 단계로 쪼갠 사례이다.&lt;/p>
&lt;ol>
&lt;li>비디오, 오디오, 메타데이터를 분리&lt;/li>
&lt;li>비디오 파일을 인코딩, 섬네일을 추출, 오디오 파일 인코딩&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>자원 관리자&lt;/strong>&lt;/p>
&lt;p>자원 배분을 효과적으로 수행하는 역할을 담당한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_10.png"
width="837"
height="271"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_10_hu4aa1c323e6c007863c84ae483ffa21b4_150318_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_10_hu4aa1c323e6c007863c84ae483ffa21b4_150318_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="자원 관리자 구조"
class="gallery-image"
data-flex-grow="308"
data-flex-basis="741px"
>&lt;/p>
&lt;p>세 개의 큐와 작업 스케줄러(Task scheduler)로 구성된다.&lt;/p>
&lt;ul>
&lt;li>작업 큐(task queue)
&lt;ul>
&lt;li>실행할 작업이 보관되어 있는 우선순위 큐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작업 서버 큐(worker queue)
&lt;ul>
&lt;li>작업 서버의 가용 상태 정보가 보관되어 있는 우선순위 큐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>실행 큐(runner quere)
&lt;ul>
&lt;li>현재 실행 중인 작업 및 작업 서버 정보가 보관되어 있는 뷰&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작업 스케줄러
&lt;ul>
&lt;li>최적의 작업/서버 조합을 골라 해당 작업 서버가 작업을 수행하도록 지시한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>작업 관리자는 다음과 같이 동작한다.&lt;/p>
&lt;ol>
&lt;li>작업 큐에서 가장 높은 우선순위의 작업을 꺼낸다.&lt;/li>
&lt;li>해당 작업을 실행하기 적합한 작업 서버를 고른다.&lt;/li>
&lt;li>해당 작업 서버에게 작업 실행을 지시한다.&lt;/li>
&lt;li>해당 작업이 어떤 서버에게 할당되었는지에 관한 정보를 실행 큐에 넣는다.&lt;/li>
&lt;li>작업이 완료되면 해당 작업을 생행 큐에서 제거한다.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>작업 서버&lt;/strong>&lt;/p>
&lt;p>DAG에 정의된 작업을 수행한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_11.png"
width="366"
height="386"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_11_hubefd9dbcf64d01874bab57f6c01a654d_108389_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_11_hubefd9dbcf64d01874bab57f6c01a654d_108389_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="작업 서버"
class="gallery-image"
data-flex-grow="94"
data-flex-basis="227px"
>&lt;/p>
&lt;p>작업 종류에 따라 작업 서버도 구분하여 관리한다.&lt;/p>
&lt;p>&lt;strong>임시 저장소&lt;/strong>&lt;/p>
&lt;p>임시 저장소 구현에는 여러 저장소 시스템을 활용할 수 있으며, 저장할 데이터의 유형, 크기, 이용 빈도, 데이터 유효기간 등에 따라 선택한다.&lt;/p>
&lt;ul>
&lt;li>메타데이터
&lt;ul>
&lt;li>작업 서버가 빈번히 참조하는 정보, 크기가 작으므로 메모리에 캐시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비디오/오디오
&lt;ul>
&lt;li>BLOB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>임시 저장소에 보관한 데이터는 비디오 프로세싱이 완료되면 삭제한다.&lt;/p>
&lt;p>&lt;strong>인코딩된 비디오&lt;/strong>&lt;/p>
&lt;p>인코딩 파이프라인의 초종 결과물이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>funny_720p.mp4&lt;/code> 와 같은 이름을 짓는다.&lt;/li>
&lt;/ul>
&lt;h3 id="시스템-최적화">시스템 최적화&lt;/h3>
&lt;p>속도, 안정성 비용 측면에서 시스템을 최적화한다.&lt;/p>
&lt;h4 id="속도-최적화">속도 최적화&lt;/h4>
&lt;p>&lt;strong>비디오 병렬 업로드&lt;/strong>&lt;/p>
&lt;p>비디오 전부를 한 번의 업로드로 올리는 것은 비효율적이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_12.png"
width="811"
height="89"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_12_hu98c98eb0efb908039c9faccf2e82e918_18252_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_12_hu98c98eb0efb908039c9faccf2e82e918_18252_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="GOP 분할"
class="gallery-image"
data-flex-grow="911"
data-flex-basis="2186px"
>&lt;/p>
&lt;p>하나의 비디오는 작은 GOP로 분할할 수 있으며, 분할한 GOP를 병렬적으로 업로드하면 일부가 식패해도 빠르게 업로드를 재개할 수 있다.&lt;/p>
&lt;p>따라서 비디오를 GOP 경계에 맞춰 분할하는 작업을 단말이 수행하면 업로드 속도를 높일 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_13.png"
width="809"
height="197"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_13_huc530dc4036dc5a7fd8cff38f1c766090_71440_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_13_huc530dc4036dc5a7fd8cff38f1c766090_71440_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클라이언트 처리 후 병렬 업로드"
class="gallery-image"
data-flex-grow="410"
data-flex-basis="985px"
>&lt;/p>
&lt;p>&lt;strong>업로드 센터를 사용자 근거리에 지정&lt;/strong>&lt;/p>
&lt;p>업로드 센터를 여로 곳에 두고 가까운 센터로 업로드 하도록 한다.&lt;/p>
&lt;ul>
&lt;li>이를 위해 이번 설계안은 CDN을 업로드 센터로 이용한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>모든 절차를 병렬화&lt;/strong>&lt;/p>
&lt;p>느슨하게 결합된 시스템을 만들어서 병렬성을 높이면 낮은 응답지연에 도움이된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_14.png"
width="824"
height="277"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_14_hu11dc666d77b317ede5fc5fe9aa5e5c0a_131083_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_14_hu11dc666d77b317ede5fc5fe9aa5e5c0a_131083_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="기존 설계안"
class="gallery-image"
data-flex-grow="297"
data-flex-basis="713px"
>&lt;/p>
&lt;p>기존 설계안의 비디오를 원본 저장소에서 CDN으로 옮기는 절차를 보면, 어떤 단계의 결과물은 이전 단계의 결과물을 입력으로 사용하여 만들어지는데, 이러한 의존성이 있다면 병렬성을 높이기 어렵다.&lt;/p>
&lt;p>이러한 결합은 메시지 큐를 도입하여 개선할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_15.png"
width="817"
height="491"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_15_hu921f1cca05a7c8b3b0638c3d5cfa32c6_187733_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_15_hu921f1cca05a7c8b3b0638c3d5cfa32c6_187733_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="메시지 큐를 도입한 설계안"
class="gallery-image"
data-flex-grow="166"
data-flex-basis="399px"
>&lt;/p>
&lt;ul>
&lt;li>메시지 큐를 도입하기 전
&lt;ul>
&lt;li>인코딩 모듈은 다운로드 모듈의 작업이 끝나기를 기다려야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 큐를 도입한 후
&lt;ul>
&lt;li>인코딩 모듈은 다운로드 모듈의 작업이 끝나기를 기다리는 것이 아닌, &lt;strong>메시지 큐에 보관된 이벤트&lt;/strong> 각각을 인코딩 모듈이 병렬적으로 처리할 수 있게된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="안전성-최적화">안전성 최적화&lt;/h4>
&lt;p>&lt;strong>미리 사인된 업로드 URL&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>미리 사인된 URL?&lt;br>
아마존 S3에서 쓰이는 용어로, 접근 공유 시그니처 라고도 부른다.&lt;/p>
&lt;/blockquote>
&lt;p>허가받은 사용자만이 올바른 장소에 비디오를 업로드할 수 있도록 하기 위해 미리 사인된(pre-signed) 업로드 URL을 이용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/14/img_16.png"
width="728"
height="397"
srcset="https://codemario318.github.io/post/system-design-interview/14/img_16_hu179b158cca764a11906c4a36151aea61_77187_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/14/img_16_hu179b158cca764a11906c4a36151aea61_77187_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="미리 사인된 업로드 사용"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="440px"
>&lt;/p>
&lt;ol>
&lt;li>클라이언트는 HTTP 서버에 POST 요청을 통해 미리 사인된 URL을 받는다.
&lt;ul>
&lt;li>해당 URL이 가르키는 객체에 대한 접근 권한이 이미 주어져 있는 상태&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>미리 사인된 URL을 돌려준다.&lt;/li>
&lt;li>클라이언트는 해당 URL이 가리키는 위치에 비디오를 업로드한다.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>비디오 보호&lt;/strong>&lt;/p>
&lt;p>많은 콘텐츠 제작자가 비디오 원본을 도난당할까 우려하여 인터넷에 비디오를 업로드하기를 주저한다.&lt;/p>
&lt;p>이러한 저작권 보호를 위해 다음 세가지 선택지 중 하나를 채택할 수 있다.&lt;/p>
&lt;ul>
&lt;li>디지털 저작권 관리(DRM: Digital Rights Management) 시스템 도입
&lt;ul>
&lt;li>애플의 페어플레이, 구글 와이드바인, MS의 플레이레디 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>AES 암호화
&lt;ul>
&lt;li>비디오를 암호화하고 접근 권한을 설정하는 방식&lt;/li>
&lt;li>재생 시에만 복호화하며, 허락된 사용자만 암호화된 비디오를 시청할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>워터마크
&lt;ul>
&lt;li>비디오 위에 소유자 정보를 포함하는 이미지 오베리이를 올린다.&lt;/li>
&lt;li>회사 로고, 이름 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="비용-최적화">비용 최적화&lt;/h4>
&lt;p>비디오 데이터 제공을 위한 CDN은 이번 설계한 시스템의 핵심이다.&lt;/p>
&lt;p>하지만 CDN은 비싸고, 데이터 크기가 클 수록 더욱 비싸다.&lt;/p>
&lt;p>연구 결과에 따르면, 유트브의 비디오 스트리밍은 롱테일 분포를 따른다.&lt;/p>
&lt;ul>
&lt;li>인기 있는 비디오가 대부분 재생의 대부분을 차지한다.&lt;/li>
&lt;/ul>
&lt;p>이러한 점을 이용하여 몇 가지 최적화를 시도할 수 있다.&lt;/p>
&lt;ul>
&lt;li>인기 비디오는 CDN으로 재생하되 다른 비디오는 비디오 서버를 통해 재생한다.&lt;/li>
&lt;li>비인기 비디오는 인코딩 할 필요가 없을 수 있으며, 짧은 비디오라면 필요할 때 인코딩하여 재생할 수 있다.&lt;/li>
&lt;li>특정 비디오는 특정 지역에서만 인기가 높다. 이런 비디오는 다른 지역으로 옮길 필요가 없다.&lt;/li>
&lt;li>CDN을 직접 구축하고 인터넷 서비스 제공자와 제유한다.
&lt;ul>
&lt;li>CDN을 직접 구축하는 것은 초대형 프로젝트이지만 대규모 스트리밍 사업자라면, 비용을 줄이고 사용자 경험을 향상시킬 수 있어 시도할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 최적화는 콘텐츠의 인기도, 이용 패턴, 비디오 크기 등 데이터에 근거한 것으로, 최적화를 시도하기 전 시청 패턴을 분석하는 것이 매우 중요하다.&lt;/p>
&lt;h3 id="오류처리">오류처리&lt;/h3>
&lt;p>대형 시스템에서 오류는 불가피하다.&lt;/p>
&lt;p>장애를 아주 잘 감내하는(highly fault-tolerant) 시스템을 만들려면 오류들을 우아하게 처리하고 빠르게 회복해야한다.&lt;/p>
&lt;ul>
&lt;li>회복 불가능 오류(recoverable error)
&lt;ul>
&lt;li>특정 비디오 세그먼트 트랜스코딩 실패 같은 오류는 회복 가능한 오류이다.&lt;/li>
&lt;li>몇 번 재시도하면 해결되는 경우가 많다.&lt;/li>
&lt;li>계속해서 실패하고, 복구가 어렵다 판단되면 클라이언트에게 적절한 오류 코드를 반환해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>회복 불가능 오류(non-recoverable error)
&lt;ul>
&lt;li>비디오 포맷이 잘못되었다거나 하는 회복 불가능한 오류가 발견되면 해당 비디오에 대한 작업을 중단하고 클라이언트에게 적절한 오류를 반환해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>시스템 컴포넌트 각각에 발생할 수 있는 오류에 대한 전형적 해결 방법 요약하면 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>업로드 오류
&lt;ul>
&lt;li>몇 회 재시도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비디오 분할 오류
&lt;ul>
&lt;li>클라이언트가 분할하지 못하는 경우라면, 전체 비디오를 서버로 전송하고 서버가 해당 비디오 분할을 처리하도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>트랜스코딩 오류
&lt;ul>
&lt;li>재시도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>전처리 오류
&lt;ul>
&lt;li>DAG 그래프 재생성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DAG 스케줄러 오류
&lt;ul>
&lt;li>작업을 다시 스케줄링&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>자원 관리자 큐에 장애 발생
&lt;ul>
&lt;li>사본을 이용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작업 서버 장애
&lt;ul>
&lt;li>다른 서버에서 해당 작업 재시도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>API 서버 장애
&lt;ul>
&lt;li>API를 무상태로 관리하여 신규 요청을 다른 API로 우회&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 캐시 서버 장애
&lt;ul>
&lt;li>데이터 다중화를 통해 다른 노드에서 데이터를 가져올 수 있다.&lt;/li>
&lt;li>장애가 난 캐시 서버는 새로운 것으로 교체&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 데이터베이스 장애
&lt;ul>
&lt;li>주 서버: 부 서버 가운데 하나를 주 서버로 교체&lt;/li>
&lt;li>부 서버: 다른 부 서버를 통해 읽기 연산 처리 및 죽은 서버 교체&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>이외에 중요할 수 있는 내용들은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>API 계층 규모 확정성 확보 방안
&lt;ul>
&lt;li>무상태 서버이므로 수평 규모 확장이 가능하다는 사실을 언급하면 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터베이스 계층의 규모 확장성 확보 방안
&lt;ul>
&lt;li>다중화와 샤딩 방법에 대해 언급&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>라이브 스트리밍
&lt;ul>
&lt;li>라이브 스트리밍은 비디오를 실시간으로 녹화하고 방송하는 절차를 말한다.&lt;/li>
&lt;li>가장 중요한 차이는 다음과 같다.
&lt;ul>
&lt;li>응답지연이 좀 더 낮아야 한다.
&lt;ul>
&lt;li>스트리밍 프로토콜 선정에 유의해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작은 단위의 데이터를 실시간으로 빨리 처리해야하므로 병렬화 필요성은 떨어진다.&lt;/li>
&lt;li>너무 많은 시간이 걸리는 오류 처리 방안은 활용할 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비디오 삭제
&lt;ul>
&lt;li>저작권 위반, 선정성, 불법 행위에 관계된 비디오는 내려야한다.&lt;/li>
&lt;li>업로드 과정에서 식별&lt;/li>
&lt;li>사용자의 신고 절차 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>15. 구글 드라이브 설계</title><link>https://codemario318.github.io/post/system-design-interview/15/</link><pubDate>Tue, 09 Jul 2024 15:46:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/15/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/cover.png" alt="Featured image of post 15. 구글 드라이브 설계" />&lt;p>클라우드 저장소 서비스는 최근 높은 인기를 누리게 된 대표적 클라우드 서비스다.&lt;/p>
&lt;p>그 가운데 구글 드라이브 서비스를 설계해 본다.&lt;/p>
&lt;p>구글 드라이브는 &lt;strong>파일 저장 및 동기화 서비스&lt;/strong>로, 문서, 사진, 비디오, 기타 피일을 &lt;strong>클라우드에 보관&lt;/strong>할 수 있도록 한다.&lt;/p>
&lt;ul>
&lt;li>이 파일은 컴퓨터, 스마트폰, 태블릿 등 어떤 단말에서도 이용 가능해야한다.&lt;/li>
&lt;li>보관된 파일은 친구, 가족, 동료 들과 손쉽게 공유할 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;ul>
&lt;li>Q. 지원해야할 기능?
&lt;ul>
&lt;li>A. 파일 업로드/다운로드, 파일 동기화, 알림&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 모바일 앱, 웹 앱 중 지원 범위
&lt;ul>
&lt;li>A. 웹, 앱 둘다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 파일 암호화 처리?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 파일 크기 제한?
&lt;ul>
&lt;li>A. 10GB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 사용자는?
&lt;ul>
&lt;li>A. DAU 천만명&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이번 장에서는 다음 기능의 설계에 집중한다.&lt;/p>
&lt;ul>
&lt;li>파일 추가
&lt;ul>
&lt;li>가장 쉬운 방법은 파일을 구글 드라이브 안으로 떨구는 것(Drag-and-drop)이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파일 다운로드&lt;/li>
&lt;li>여러 단말에 파일 동기화
&lt;ul>
&lt;li>한 단말에서 파일을 추가하면 다른 단말에도 자동 동기화되어야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파일 갱신 이력 조회&lt;/li>
&lt;li>파일 공유&lt;/li>
&lt;li>파일 편집, 삭제, 새롭게 공유 되었을 때 알림 표시&lt;/li>
&lt;/ul>
&lt;p>기능적 요구사항 외, 비-기능적 요구사항을 이해하는 것도 중요하다.&lt;/p>
&lt;ul>
&lt;li>안정성
&lt;ul>
&lt;li>저장소 시스템의 안정성은 아주 중요하다.&lt;/li>
&lt;li>데이터 손실이 발생하면 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>빠른 동기화
&lt;ul>
&lt;li>동기화 사긴이 너무 많이 걸리면 인내심을 읽고 제품을 더 이상 사용하지 않을 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>네트워크 대역폭
&lt;ul>
&lt;li>네트워크 대역폭을 불필요하게 많이 소모한다면 사용자가 좋아하지 않을 것&lt;/li>
&lt;li>모바일 데이터 플랜이라면 더욱더&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규모 확장성
&lt;ul>
&lt;li>아주 많은 양의 트래픽도 처리 가능해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>높은 가용성
&lt;ul>
&lt;li>일부 서버의 장애, 지연, 네트워크 이슈가 발생해도 계속 사용 가능해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-추정치">개략적 추정치&lt;/h3>
&lt;ul>
&lt;li>가입 사용자는 오천만명, 천만명의 DAU 가정&lt;/li>
&lt;li>모든 사용자에게 10GB 무료 저장공간 할당&lt;/li>
&lt;li>매일 각 사용자가 평균 2개의 파일을 업로드 한다고 가정&lt;/li>
&lt;li>파일 크기 평균 500KB 가정&lt;/li>
&lt;li>읽기, 쓰기 비율은 1:1&lt;/li>
&lt;li>&lt;code>필요한 저장공간 총량 = 5천만 사용자 * 10GB = 500PB&lt;/code>&lt;/li>
&lt;li>&lt;code>업로드 API QPS = 1천만 사용자 * 2회 / 24시간 /3600초 = 240&lt;/code>&lt;/li>
&lt;li>&lt;code>최대 QPS = QPS * 2 = 480&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>모든 것을 담은 한 대 서버에서 출발해 점진적으로 천만 사용자 지원이 가능한 시스템으로 발전시켜 나간다.&lt;/p>
&lt;ul>
&lt;li>파일을 올리고 다운로드 하는 과정을 처리할 웹서버&lt;/li>
&lt;li>사용자 데이터, 로그인 정보, 파일 정보 드으이 메타데이터를 보관할 데이터베이스&lt;/li>
&lt;li>파일을 저장할 저장소 시스템.
&lt;ul>
&lt;li>1TB 사용 예정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>웹 서버, 데이터베이스 설치 후, 파일이 저장될 &lt;code>drive/&lt;/code> 디렉터리를 준비한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img.png"
width="688"
height="311"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_hub24c5a9894590f2559d10c8a4efc626c_63107_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_hub24c5a9894590f2559d10c8a4efc626c_63107_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="파일 저장 예시"
class="gallery-image"
data-flex-grow="221"
data-flex-basis="530px"
>&lt;/p>
&lt;ul>
&lt;li>디렉터리 안에는 네임스페이스라 불리는 하위 디렉터리를 둔다.&lt;/li>
&lt;li>각 네임스페이스 안에는 특정 사용자가 올린 파일이 보관된다.&lt;/li>
&lt;li>파일들은 원래 파일과 같은 이름을 갖는다.&lt;/li>
&lt;li>각 파일과 폴더는 그 상대 경로를 네임스페이스 이름과 결합하면 유일하게 식별할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="api">API&lt;/h3>
&lt;p>이 시스템은 3가지 API가 필요하다.&lt;/p>
&lt;h4 id="파일-업로드-api">파일 업로드 API&lt;/h4>
&lt;p>&lt;strong>단순 업로드&lt;/strong>&lt;/p>
&lt;p>파일 크기가 작을 때 사용한다.&lt;/p>
&lt;p>&lt;strong>이어 올리기(resumable upload)&lt;/strong>&lt;/p>
&lt;p>파일 사이즈가 크고 네트워크 문제로 업로드가 중단될 가능성이 높다고 생각되면 사용한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">https://api.example.com/files/upload?uploadType=resumable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>인자
&lt;ul>
&lt;li>&lt;code>uploadType=resumable&lt;/code>&lt;/li>
&lt;li>&lt;code>data&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이어올리기는 다음 세 단계 절차로 이루어진다.&lt;/p>
&lt;ol>
&lt;li>이어 올리기 URL을 받기 위한 최초 요청 전송&lt;/li>
&lt;li>데이터를 업로드하고 업로드 상태 모니터링&lt;/li>
&lt;li>업로드에 장애가 발생하면 장애 발생시점부터 업로드를 재시작&lt;/li>
&lt;/ol>
&lt;h4 id="파일-다운로드-api">파일 다운로드 API&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">https://api.example.com/files/download
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>인자&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>path&lt;/code>
&lt;ul>
&lt;li>다운로드할 파일의 경로&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;path&amp;#34;: &amp;#34;/recipes/soup/best_soup.txt&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="파일-갱신-히스토리">파일 갱신 히스토리&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">https://api.exmaple.com/files/list_revisions
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>인자&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>path&lt;/code>: 갱신 히스토리를 가져올 파일의 경로&lt;/li>
&lt;li>&lt;code>limit&lt;/code>: 히스토리 길이의 최대치&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;path&amp;#34;: &amp;#34;/recipes/soup/best_soup.txt&amp;#34;,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;limit&amp;#34;: 20
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>나열한 모든 API는 사용자 인증을 필요로 하고, 클라이언트와 백엔드 서버가 주고받는 데이터를 보호하기 위해 &lt;code>HTTPS&lt;/code> 프로토콜을 사용해야한다.&lt;/p>
&lt;h3 id="한-대-서버의-제약-극복">한 대 서버의 제약 극복&lt;/h3>
&lt;p>파일이 많아지면 결국 가득 차게되어 더 이상 파일을 올릴 수 없으므로 긴급히 문제를 해결해야한다.&lt;/p>
&lt;p>쉬운 해결책으로 &lt;strong>샤딩&lt;/strong>을 통해 데이터를 여러 서버에 나누어 저장하는 방법을 고려할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_1.png"
width="549"
height="382"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_1_hue1f43ec1f6b9cd6c37e81cda8b5995c5_45245_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_1_hue1f43ec1f6b9cd6c37e81cda8b5995c5_45245_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="샤딩"
class="gallery-image"
data-flex-grow="143"
data-flex-basis="344px"
>&lt;/p>
&lt;p>서버를 직접 관리했을 때, 장애가 생기면 데이터를 잃게될 수 있으므로 불안하다.&lt;/p>
&lt;p>넷플릭스, 에어비엔비 같은 시장 주도 기업들은 저장소로 &lt;strong>아마존 S3&lt;/strong>를 사용한다.&lt;/p>
&lt;ul>
&lt;li>업계 최고 수준의 규모 확장성, 가용성, 보안, 성능을 제공하는 객체 저장소 서비스&lt;/li>
&lt;li>같은 지역 안에서 다중화, 여러 지역에 걸쳐 다중화가 가능하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_2.png"
width="820"
height="269"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_2_hufcdd6e06324f9d7c9cd88babfdc6839a_145452_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_2_hufcdd6e06324f9d7c9cd88babfdc6839a_145452_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="다중화"
class="gallery-image"
data-flex-grow="304"
data-flex-basis="731px"
>&lt;/p>
&lt;p>따라서 S3를 사용을 결정한다. 하지만 미래에 비슷한 문제(사용자 증가로 인해 발생하는 문제)가 벌어지는 것을 막기 위해, 개선할 부분을 더 찾아보면 아래와 같다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_3.png"
width="498"
height="682"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_3_hu7c8b4e63be5e874ab6c187e11a695377_134558_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_3_hu7c8b4e63be5e874ab6c187e11a695377_134558_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="수정한 설계안"
class="gallery-image"
data-flex-grow="73"
data-flex-basis="175px"
>&lt;/p>
&lt;ul>
&lt;li>로드밸런서
&lt;ul>
&lt;li>트래픽을 고르게 분산할 수 있다.&lt;/li>
&lt;li>특정 웹 서버에 장애가 발생하면 자동으로 해당 서버를 우회한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 서버
&lt;ul>
&lt;li>로드밸런서를 추가하고 나면 더 많은 웹 서버를 손쉽게 추가할 수 있다.&lt;/li>
&lt;li>트래픽이 폭증해도 쉽게 대응 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 데이터베이스
&lt;ul>
&lt;li>데이터베이스를 파일 저장 서버에서 분리하여 SPOF를 회피한다.&lt;/li>
&lt;li>다중화 및 샤딩 정책을 정용하여 가용성과 규모 확장성 요구사항에 대응한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파일 저장소
&lt;ul>
&lt;li>S3를 파일 저장소로 사용하고 가용성과 데이터 무손실을 보장하기 위해 두 개 이상의 지역에 데이터를 다중화한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="동기화-충돌">동기화 충돌&lt;/h3>
&lt;p>구글 드라이브 같은 대형 저장소 시스템의 경우 동기화 충돌이 발생할 수 있다.&lt;/p>
&lt;ul>
&lt;li>두 명 이상의 사용자가 같은 파일이나 폴더를 동시에 업데이트하려고 하는 경우&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_4.png"
width="835"
height="188"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_4_hu342e61e0409206514e14b35844cf2592_55317_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_4_hu342e61e0409206514e14b35844cf2592_55317_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="충돌 해소 전략"
class="gallery-image"
data-flex-grow="444"
data-flex-basis="1065px"
>&lt;/p>
&lt;p>먼저 처리되는 변경은 성공한 것으로 보고, 나중에 처리되는 변경은 충돌이 발생한 것으로 표시하는 전략을 사용할 수 있다.&lt;/p>
&lt;ol>
&lt;li>사용자 1과 2는 같은 파일을 동시에 갱신을 시도한다.&lt;/li>
&lt;li>사용자 1의 요청이 먼저 처리된다.&lt;/li>
&lt;li>사용자 2는 동기화 충돌 오류가 발생한다.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>충돌 오류 해소&lt;/strong>&lt;/p>
&lt;p>오류가 발생한 시점에 이 시스템에는 같은 파일의 두가지 버전이 존재하게 된다.&lt;/p>
&lt;ul>
&lt;li>사용자 2가 가지고 있는 로컬 사본과 서버에 있는 최신 버전&lt;/li>
&lt;/ul>
&lt;p>이 상태에서는 &lt;strong>두 파일을 하나로 합칠지&lt;/strong> 아니면 &lt;strong>둘 중 하나를 다른 파일로 대체할지&lt;/strong>를 결정해야한다.&lt;/p>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_5.png"
width="762"
height="578"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_5_hu0a421274c901a4c9b3c387104fb85a94_147635_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_5_hu0a421274c901a4c9b3c387104fb85a94_147635_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="316px"
>&lt;/p>
&lt;ul>
&lt;li>사용자 단말
&lt;ul>
&lt;li>사용자가 이용하는 웹 브라우저 또는 모바일 앱 등의 클라이언트&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>블록 저장소 서버(block server, block-level storage)
&lt;ul>
&lt;li>파일 블록을 클라우드 저장소에 업로드하는 서버&lt;/li>
&lt;li>클라우드 환경에서 데이터 파일을 저장하는 기술&lt;/li>
&lt;li>파일을 여러개의 블록으로 나눠 저장하며, 각 블록에는 고유한 해시값을 할당&lt;/li>
&lt;li>해시값은 메타데이터 데이터베이스에 저장됨&lt;/li>
&lt;li>각 블록은 독립적인 객체로 취급되어 클라우드 저장소 시스템에 보관(여기서는 s3)&lt;/li>
&lt;li>파일 재구성 시 블록들을 원래 순서대로 합친다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클라우드 저장소
&lt;ul>
&lt;li>파일을 블록 단위로 나눠 클라우드 저장소에 보관한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>아카이빙 저장소(cold storage)
&lt;ul>
&lt;li>오랫동안 사용되지 않은 비활성 데이터를 저장한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>로드밸런서
&lt;ul>
&lt;li>요청을 모든 API 서버에 고르게 분산한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>API 서버
&lt;ul>
&lt;li>파일 업로드 외 거의 모든 것을 담당&lt;/li>
&lt;li>사용자 인증, 사용자 프로파일 관리, 파일 메타데이터 갱신 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 데이터베이스
&lt;ul>
&lt;li>사용자, 파일, 블록, 버전 등의 메타데이터 정보를 관리&lt;/li>
&lt;li>실제 파일은 클라우드에 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 캐시
&lt;ul>
&lt;li>성능을 높이기 위해 자주 쓰이는 메타데이터를 캐시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 서비스
&lt;ul>
&lt;li>특정 이벤트가 발생했음을 클라이언트에게 알리는 발생/구독 프로토콜 기반 시스템&lt;/li>
&lt;li>파일 추가, 편집, 삭제 되었음을 알린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오프라인 사용자 백업 큐(offline backup queue)
&lt;ul>
&lt;li>클라이언트가 접속 중이 아니라서 파일의 최신 상태를 확인할 수 없을 때는 해당 정보를 이 큐에 두어 나중에 클라이언트가 접속했을 때 동기화한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="블록-저장소-서버">블록 저장소 서버&lt;/h3>
&lt;p>정기적으로 갱신되는 큰 파일들은 업데이트가 일어날 때마다 전체 파일을 서버로 보내면 네트워크 대역폭을 많이 사용하게된다.&lt;/p>
&lt;p>이를 최적화하는 방법으로 두 가지 정도를 생각해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>델타 동기화(delta sync)
&lt;ul>
&lt;li>파일이 수정되면 전체 파일 대신 수정이 일어난 블록만 동기화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>압축(compression)
&lt;ul>
&lt;li>블록 단위로 압축해 두면 데이터 크기를 많이 줄일 수 있다.&lt;/li>
&lt;li>압축 알고리즘은 파일 유형에 따라 정한다.&lt;/li>
&lt;li>텍스트: gzip, bzip2 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_6.png"
width="831"
height="451"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_6_hud8fbf54a2a35c27ffe337a1e218c26a0_109645_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_6_hud8fbf54a2a35c27ffe337a1e218c26a0_109645_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="블록 저장소 동작"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/p>
&lt;p>블록 저장소 서버는 &lt;strong>파일 업로드에 관계된 힘든 일을 처리하는 컴포넌트&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>클라이언트가 보낸 파일을 블록 단위로 나눈다.&lt;/li>
&lt;li>각 블록에 압축 알고리즘을 적용한다.&lt;/li>
&lt;li>암호화한다.&lt;/li>
&lt;li>전체 파일을 저장소 시스템으로 보내는 대신 수정된 블록만 전송한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_7.png"
width="699"
height="561"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_7_hu2ea83530cb1f2bac8670a57a1cacd1e2_91495_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_7_hu2ea83530cb1f2bac8670a57a1cacd1e2_91495_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="델타 동기화 전략 동작"
class="gallery-image"
data-flex-grow="124"
data-flex-basis="299px"
>&lt;/p>
&lt;p>갱신된 부분만 동기화해야 하므로 이 두 블록만 클라우드 저장소에 업로드한다.&lt;/p>
&lt;p>블록 저장소 서버에 델타 동기화 전략과 압축 알고리즘을 도입하면, 네트워크 대역폭 사용량을 절감할 수 있다.&lt;/p>
&lt;h3 id="높은-일관성-요구사항">높은 일관성 요구사항&lt;/h3>
&lt;p>구글 드라이브 시스템은 &lt;strong>강한 일관성&lt;/strong>(string consistency) 모델을 기본으로 지원해야한다.&lt;/p>
&lt;ul>
&lt;li>같은 파일이 단말이나 사용자에 따라 다르게 보이는 것을 허용할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>메모리 캐시는 보통 &lt;strong>결과적 일관성&lt;/strong>(eventual consistency) 모델은 지원하기 때문에 강한 일관성을 달성하려면 다음 사항을 보장해야한다.&lt;/p>
&lt;ul>
&lt;li>캐시에 보관된 사본과 데이터베이스에 있는 원본이 일치한다.&lt;/li>
&lt;li>데이터베이스에 보관된 원본에 변경이 발생하면 캐시에 있는 사본을 무효화한다.&lt;/li>
&lt;/ul>
&lt;p>관계형 데이터베이스는 ACID를 보장하므로 강한 일관성을 보장하기 쉽다.&lt;/p>
&lt;p>하지만 NoSQL 데이터베이스는 이를 기본으로 지원하지 않으므로, 동기화 로직 안에 프로그램해 넣어야 한다.&lt;/p>
&lt;p>이번 설계안에는 관계형 데이터베이스를 채택하여 높은 일관성 요구사항에 대응한다.&lt;/p>
&lt;h3 id="메타데이터-데이터베이스">메타데이터 데이터베이스&lt;/h3>
&lt;p>중요한 것만 간추린 스키마를 그려보면 아래와 같다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_8.png"
width="815"
height="552"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_8_hu4f4697bf0a6ca547432e300010d24d9d_152870_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_8_hu4f4697bf0a6ca547432e300010d24d9d_152870_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="스키마 설계안"
class="gallery-image"
data-flex-grow="147"
data-flex-basis="354px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;code>user&lt;/code>
&lt;ul>
&lt;li>이름, 이베일 프로파일 사진 등 사용자에 관계된 기본적인 정보들이 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>device&lt;/code>
&lt;ul>
&lt;li>단말 정보가 보관&lt;/li>
&lt;li>&lt;code>push_id&lt;/code>는 모바일 푸시 알림을 보내고 받기 위한 것&lt;/li>
&lt;li>한 사용자가 여러 대의 단말을 가질 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>namespace&lt;/code>
&lt;ul>
&lt;li>사용자의 루트 디렉터리 정보가 보관된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>file&lt;/code>
&lt;ul>
&lt;li>파일의 최신 정보가 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>file_version&lt;/code>
&lt;ul>
&lt;li>파일의 갱신 이력이 보관&lt;/li>
&lt;li>보관되는 레코드는 전부 읽기 전용&lt;/li>
&lt;li>갱신 이력이 회손되는 것을 막는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>block&lt;/code>
&lt;ul>
&lt;li>파일 블록에 대한 정보를 보관&lt;/li>
&lt;li>특정 버전의 파일은 올바른 순서로 조합하기만 하면 복원할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="업로드-절차">업로드 절차&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_9.png"
width="833"
height="483"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_9_hua0a53d0668d6e7e3b8f1258d11bcb681_72670_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_9_hua0a53d0668d6e7e3b8f1258d11bcb681_72670_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="업로드 절차"
class="gallery-image"
data-flex-grow="172"
data-flex-basis="413px"
>&lt;/p>
&lt;p>사용자가 파일을 올리면 두 개의 요청이 병렬적으로 수행되어야 한다.&lt;/p>
&lt;ul>
&lt;li>파일 메타데이터를 추가
&lt;ol>
&lt;li>새 파일의 메타데이터를 추가하기 위한 요청 전송&lt;/li>
&lt;li>새 파일의 메타 데이터를 데이터베이스에 저장하고 업로드 상태를 대기중(pending)으로 변경&lt;/li>
&lt;li>새 파일이 추가되었음을 알림 서비스에 통지&lt;/li>
&lt;li>관련된 클라이언트(여기서는 클라이언트 2)에게 파일이 업로드되고 있음을 알림&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>파일을 클라우드 저장소로 업로드
&lt;ol>
&lt;li>파일을 블록 저장소 서버에 업로드&lt;/li>
&lt;li>파일을 블록 단위로 쪼갠 다음 압축, 암호화 후 클라우드 저장소에 전송&lt;/li>
&lt;li>업로드 완료시 클라이드 스토리지는 완료 콜백 호출&lt;/li>
&lt;li>메타데이터 DB에 기록된 해당 파일의 상태를 완료(uploaded)로 변경&lt;/li>
&lt;li>알림 서비스에 파일 업로드가 끝났음을 통지&lt;/li>
&lt;li>알림 서비스가 관련 클라이언트(2)에게 파일 업로드가 끝났음을 알림&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>수정도 이와 거의 동일하다.&lt;/p>
&lt;h3 id="다운로드-절차">다운로드 절차&lt;/h3>
&lt;p>파일 다운로드는 파일이 새로 추가되거나 편집되면 자동으로 시작된다.&lt;/p>
&lt;p>다른 클라이언트가 파일을 편집하거나 추가했다는 사실은 두 가지 방법을 통해 이루어진다.&lt;/p>
&lt;ul>
&lt;li>클라이언트 A가 접속 중
&lt;ul>
&lt;li>다른 클라이언트가 파일을 변경하면 알림 서비스가 클라이언트 A에게 변경이 발생했으니 새 버전을 끌어가야 한다고 알림&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클라이언트 A가 접속중이 아님
&lt;ul>
&lt;li>데이터는 캐시에 보관&lt;/li>
&lt;li>해당 클라이언트 상태가 접속 중으로 바뀌면 그때 해당 클라이언트가 새 버전을 가져감&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>파일이 변경되었음을 감지한 클라이언트는&lt;/p>
&lt;ol>
&lt;li>API 서버를 통해 메타데이터를 새로 가져가야한다.&lt;/li>
&lt;li>블록들을 다운받아 파일을 재구성해야 한다.&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/15/img_10.png"
width="833"
height="420"
srcset="https://codemario318.github.io/post/system-design-interview/15/img_10_hu6a208727cbba91ca136cb143ce08ef99_65538_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/15/img_10_hu6a208727cbba91ca136cb143ce08ef99_65538_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="파일 재구성 흐름"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="476px"
>&lt;/p>
&lt;ol>
&lt;li>알림 서비스가 클라이언트 2에게 파일을 변경했음을 알림&lt;/li>
&lt;li>클라이언트 2는 새로운 메타데이터를 요청&lt;/li>
&lt;li>API 서버는 메타데이터 데이터베이스에게 새 메타데이터 요청&lt;/li>
&lt;li>API 서버에게 새 메타데이터 반환&lt;/li>
&lt;li>클라이언트 2에게 새 메타데이터가 반환&lt;/li>
&lt;li>클라이언트 2는 새 메타데이터를 맏는 즉시 블록 다운로드 요청&lt;/li>
&lt;li>블록 저장소 서버는 클라우드 저장소에서 블록 다운로드&lt;/li>
&lt;li>클라우드 저장소는 블록 서버에 요청된 블록 반환&lt;/li>
&lt;li>블록 저장소 서버는 클라이언트에게 요청된 블록 반환.&lt;/li>
&lt;li>클라이언트 2는 전송된 블록으로 파일 재구성&lt;/li>
&lt;/ol>
&lt;h3 id="알림-서비스">알림 서비스&lt;/h3>
&lt;p>알림 서비스는 파일의 일관성 유지를 위해 사용된다.&lt;/p>
&lt;ul>
&lt;li>클라이언트가 로컬에서 파일이 수정되었음을 감지하는 순간 다른 클라이언트에 그 사실을 알려 충돌 가능성을 줄여야한다.&lt;/li>
&lt;/ul>
&lt;p>단순히 보면 알림 서비스는 &lt;strong>이벤트 데이터를 클라이언트들로 보내는 서비스&lt;/strong>이다.&lt;/p>
&lt;p>따라서 두 가지 정도 선택지가 있다.&lt;/p>
&lt;ul>
&lt;li>롱 폴링: 드롭박스가 채택하고있음&lt;/li>
&lt;li>웹소켓
&lt;ul>
&lt;li>클라이언트와 서버 사이에 지속적인 통신 채널을 제공하므로 양방향 통신이 가능함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>둘 다 좋은 방안이지만 이번 설계안에서는 롱 폴링을 사용한다.&lt;/p>
&lt;ul>
&lt;li>구글 드라이브 시스템은 알림 서비스와 양방향 통신이 필요하지 않다.
&lt;ul>
&lt;li>서버만 파일이 변경된 사실을 클라이언트에게 알린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹소켓은 실시간 양방향 통신이 요구되는 채팅과 같은 응용에 적합하다.
&lt;ul>
&lt;li>구글 드라이브의 경우 알림을 보낼 일이 그렇게 자주 발생하지 않는다.&lt;/li>
&lt;li>알림을 보내야 하는 경우에도 단시간에 많은 데이터를 보낼 일은 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>따라서 롱 폴링을 채택하며, 아래와 같은 절차가 반복된다.&lt;/p>
&lt;ol>
&lt;li>각 클라이언트는 알림 서버와 롱 볼링용 연결을 유지한다.&lt;/li>
&lt;li>특정 파일에 대한 변경을 감지하면 해당 연결을 끊는다&lt;/li>
&lt;li>메타데이터 서버와 연결해 파일의 최신 내역을 다운로드한다.&lt;/li>
&lt;li>다운로드 작업이 끝났거나 타임아웃 시간에 도달한 경우 즉시 새요청을 보내 롱 폴링 연결을 복원하고 유지한다.&lt;/li>
&lt;/ol>
&lt;h3 id="저장소-공간-절약">저장소 공간 절약&lt;/h3>
&lt;p>파일 갱신 이력을 보존하고 안정성을 보장하기 위해서 파일의 여러 버전을 데이터센터에 보관할 필요가 있다.&lt;/p>
&lt;p>이 때 모든 버전을 자주 백업하면 저장용량이 너무 빨리 소진될 가능성이 있으므로 아래와 같은 방식을 활용한다.&lt;/p>
&lt;ul>
&lt;li>중복 제거(de-dupe)
&lt;ul>
&lt;li>중복된 파일 블록을 계정 차원에서 제거한다.&lt;/li>
&lt;li>해시 값을 비교해서 판다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지능적 백업 전략 도입
&lt;ul>
&lt;li>한도 설정
&lt;ul>
&lt;li>파일 버전 개수에 상한을 둔다.&lt;/li>
&lt;li>제일 오래된 버전은 버린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>중요한 버전만 보관
&lt;ul>
&lt;li>특정 파일은 단기간에 자주 변경되므로 업데이트될 때마다 새로운 버전으로 관리하는 것이 아닌, 중요한 것만 골라내어 보관한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>아카이빙 저장소(cold storage) 활용
&lt;ul>
&lt;li>자주 쓰이지 않는 데이터는 아카이빙 저장소로 옮긴다.&lt;/li>
&lt;li>아마존 S3 글래지어 같은 아카이빙 저장소 이용료는 매우 저렴하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="장애-처리">장애 처리&lt;/h3>
&lt;p>장애는 대규모 시스템이라면 피할 수 없으므로, 설계 시 그 점을 반드시 고려해야한다.&lt;/p>
&lt;ul>
&lt;li>로드밸런서 장애
&lt;ul>
&lt;li>부(Secondary) 로드밸런서가 활성화되어 트래픽을 이어받아야한다.&lt;/li>
&lt;li>로드밸런서끼리 박동 신호를 주기적으로 보내 상태를 모니터링한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>블록 저장소 서버 장애
&lt;ul>
&lt;li>다른 서버가 미완료 상태 또는 대기 상태인 작업을 이어받아야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클라우드 저장소 장애
&lt;ul>
&lt;li>S3 버킷은 여러 지역에 다중화 할 수 있으므로, 한 지역에서 장애가 발생하였다면 다른 지역에서 파일을 가져온다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>API 서버 장애
&lt;ul>
&lt;li>API 서버는 무상태로, 로드밸런서가 해당 서버에 요청을 보내지 않음으로 장애 서버와 격리한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 캐시 장애
&lt;ul>
&lt;li>다중화하여 다른 노드에서 데이터를 가져온다.&lt;/li>
&lt;li>장애가 발생한 서버는 새 서버로 교체한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 데이터베이스 장애
&lt;ul>
&lt;li>주 데이터베이스 장애
&lt;ul>
&lt;li>부 데이터베이스 서버 가운데 하나를 주 데이터베이스로 바꾼 후, 부 데이터베이스를 추가한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>부 데이터베이스 장애
&lt;ul>
&lt;li>다른 부 데이터베이스 서버가 읽기 연산을 처리하도록 한다.&lt;/li>
&lt;li>부 데이터베이스 서버를 새로 하나 추가한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 서비스 장애
&lt;ul>
&lt;li>접속중인 모든 사용자가 알림 서버와 롱 폴링 연결을 하나씩 유지하므로, 많은 사용자와의 연결을 유지하고 관리해야한다.&lt;/li>
&lt;li>따라서 장애가 발생하면 롱 폴링 연결을 다시 만들어야 하므로 복구하는 것이 상대적으로 느릴 수 있다.&lt;/li>
&lt;li>유지는 쉽지만, 연결을 새로 만드는 것은 오래걸린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오프라인 사용자 백업 큐 장애
&lt;ul>
&lt;li>다중화하여 구독 중인 클라이언트들은 백업 큐로 구독 관게를 재설정해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>높은 수준의 일관성, 낮은 네트워크 지연, 빠른 동기호가 요구된다는 점이 핵심이었다.&lt;/p>
&lt;ul>
&lt;li>구글 드라이브 시스템은 크게 두 가지 부분으로 구성된다.
&lt;ul>
&lt;li>파일의 메타데이터를 관리&lt;/li>
&lt;li>파일 동기화를 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 서비스는 이 두 부분과 변존하는 또 하나의 중요 컴포넌트
&lt;ul>
&lt;li>롱 폴링을 사용하여 클라이언트로 하여금 파일의 상태를 최신으로 유지할 수 있도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>설계안에 어떤 다른 선택지가 있었는지 살펴보면 좋다.&lt;/p>
&lt;ul>
&lt;li>블록 저장소 서버를 거치지 않고 파일을 클라우드 저장소에 직접 업로드한다면?
&lt;ul>
&lt;li>업로드 시간이 빨라질 수 있다.&lt;/li>
&lt;li>분할, 압축, 암호화 로직이 클라이언트에서 처리되어야한다.&lt;/li>
&lt;li>따라서 플랫폼별로 따로 구현해야한다.&lt;/li>
&lt;li>클라이언트가 해킹 당할 가능성이 있으므로 암호화 로직이 클라이언트에 두는 것이 적절치 않을 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>접속상태 관리 로직을 별도 서비스로 옮기는것은?
&lt;ul>
&lt;li>관련 조릭을 알림 서비스에서 분리하면, 다른 서비스에서도 쉽게 활용할 수 있게될 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>13. 검색어 자동완성 시스템</title><link>https://codemario318.github.io/post/system-design-interview/13/</link><pubDate>Tue, 09 Jul 2024 13:22:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/13/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/cover.png" alt="Featured image of post 13. 검색어 자동완성 시스템" />&lt;p>검색어 자동 완성(Autocomplete, Typeahead, Search-as-you-type, Incremental Search)은 입력 중인 글자에 맞는 검색어가 자동으로 완성하여 표시되는 기능이다.&lt;/p>
&lt;p>검색어 자동완성은 많은 제품에 중요하게 사용되는 기능으로 이번 장에서는 가장 많이 이용된 검색어 K개를 자동완성하여 출력하는 시스템을 설계한다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;ul>
&lt;li>Q. 사용자의 입력 단어가 자동완성 될 검색어의 어느 부분인가?(첫, 뒷)
&lt;ul>
&lt;li>A. 첫 부분으로 한정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 몇 개의 자동완성 검색어가 표시?
&lt;ul>
&lt;li>A. 5개&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 자동완성 검색어 5개를 고르는 기준은?
&lt;ul>
&lt;li>A. 질의 빈도에 따라 정해지는 인기 순위&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 맞춤법 검사 기능 제공?
&lt;ul>
&lt;li>A. N&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 질의는 영어?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 대문자나 특수문자도 처리?
&lt;ul>
&lt;li>A. 모든 질의는 영어 소문자만&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 얼마나 많은 사용자를 지원?
&lt;ul>
&lt;li>A. DAU 천만&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="요구사항">요구사항&lt;/h3>
&lt;p>위 질의응답을 통해 정리한 요구사항은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>빠른 응답 속도
&lt;ul>
&lt;li>사용자가 검색어를 입력합에 따라 자동완성 검색어도 충분히 빨리 표시되어야한다.&lt;/li>
&lt;li>페이스북은 응답속도 100ms 이내를 기준으로 한다.&lt;/li>
&lt;li>자동 완성은 실시간으로 빠르게 처리되는 특성으로 느리면 사용이 매우 불편해진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>연관성
&lt;ul>
&lt;li>자동완성 결과는 사용자가 입력한 단어와 연관된 것 이어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>정렬
&lt;ul>
&lt;li>계산 결과는 인기도(Populatiry) 등의 순위 모델(Ranking Model)에 의해 정렬되어 있어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규모 확장성
&lt;ul>
&lt;li>많은 트래픽을 감당할 수 있도록 확장 가능해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>고가용성
&lt;ul>
&lt;li>시스템의 일부에 장애, 지연, 네트워크 문제가 생겨도 계속 사용 가능해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;ul>
&lt;li>DAU는 천만 명으로 가정&lt;/li>
&lt;li>사용자는 평균적으로 매일 10건의 검색을 수행한다고 가정&lt;/li>
&lt;li>질의 마다 평균적으로 20바이트 데이터를 입력한다고 가정
&lt;ul>
&lt;li>ASCII 사용한다고 가정(&lt;code>1문자 = 1바이트&lt;/code>)&lt;/li>
&lt;li>질의문은 평균적으로 4개 단어, 각 단어는 다섯 글자로 구성된다고 가정&lt;/li>
&lt;li>질의당 평균 &lt;code>4 * 5 = 20바이트&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>검색창에 글자를 입력할 때마다 클라이언트는 검색어 자동완성 백엔드에 요청을 보낸다.
&lt;ul>
&lt;li>평균적으로 1회 검색당 20건의 요청이 백엔드로 전달된다.&lt;/li>
&lt;li>&lt;strong>&amp;ldquo;dinner&amp;rdquo;&lt;/strong> 입력 예시
&lt;ol>
&lt;li>&lt;code>search?q=d&lt;/code>&lt;/li>
&lt;li>&lt;code>search?q=di&lt;/code>&lt;/li>
&lt;li>&lt;code>search?q=din&lt;/code>&lt;/li>
&lt;li>&lt;code>search?q=dinn&lt;/code>&lt;/li>
&lt;li>&lt;code>search?q=dinne&lt;/code>&lt;/li>
&lt;li>&lt;code>search?q=dinner&lt;/code>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>대략 &lt;strong>초당 24,000건 질의&lt;/strong>(QPS)
&lt;ul>
&lt;li>&lt;code>10,000,000 사용자 * (10 질의/일) * 20자 / 24시간 / 3,600초&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>최대 QPS = QPS * 2 = 대략 48,000&lt;/code>&lt;/li>
&lt;li>질의 중 20%는 신규 검색어라 가정.
&lt;ul>
&lt;li>&lt;code>10,000,000 사용자 * (10 질의/일 * 20자 * 20%) = 일 0.4GB&lt;/code>&lt;/li>
&lt;li>0.4GB의 신규 데이터가 시스템에 추가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>검색어 자동완성 시스템은 개략적으로 두 부분으로 나뉜다.&lt;/p>
&lt;ul>
&lt;li>데이터 수집 서비스(Data gathering service)
&lt;ul>
&lt;li>사용자가 입력한 질의를 실시간로 수집하는 시스템&lt;/li>
&lt;li>데이터가 많은 시스템에 실시간으로 수집하는건 바람직하지 않기 때문에 진행하며 현실적인 안으로 교체한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>질의 서비스(Query Service)
&lt;ul>
&lt;li>주어진 질의에 다섯 개의 인기 검색어를 정렬해 내놓는 서비스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="데이터-수집-서비스">데이터 수집 서비스&lt;/h3>
&lt;p>데이터 수집 서비스의 동작을 간단한 예제로 살펴본다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img.png"
width="813"
height="248"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_hu094d2fe86b78a26a1e7a8068730185af_51914_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_hu094d2fe86b78a26a1e7a8068730185af_51914_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 수집 서비스 동작 예"
class="gallery-image"
data-flex-grow="327"
data-flex-basis="786px"
>&lt;/p>
&lt;p>질의문과 사용 빈도를 저장하는 빈도 테이블(frequency table)이 있다고 가정하면, 처음 이 테이블은 비어있지만, 사용자가 검색하면 그 상태가 바뀌어 나가게 된다.&lt;/p>
&lt;h3 id="질의-서비스">질의 서비스&lt;/h3>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
Frequency {
query varchar
freuqency bigint
}
&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>query&lt;/th>
&lt;th>freuqency&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>twitter&lt;/td>
&lt;td>35&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>twitch&lt;/td>
&lt;td>29&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>twilight&lt;/td>
&lt;td>25&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>twin peak&lt;/td>
&lt;td>21&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>twitch prime&lt;/td>
&lt;td>18&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>twitter search&lt;/td>
&lt;td>14&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>twillo&lt;/td>
&lt;td>10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>twin peak sf&lt;/td>
&lt;td>8&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>위와 같은 상태에서 사용자가 &lt;code>tw&lt;/code>를 검색창에 입력하면 &amp;ldquo;top 5&amp;rdquo; 검색어가 표시되어야 한다.&lt;/p>
&lt;ul>
&lt;li>twitter&lt;/li>
&lt;li>twitch&lt;/li>
&lt;li>twilight&lt;/li>
&lt;li>twin peak&lt;/li>
&lt;li>twitch prime&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">frequency&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">prefix&lt;/span>&lt;span class="o">%`&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">frequency&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이러한 방법은 데이터 양이 적을 때는 나쁘지 않지만, 데이터가 아주 많아지면 데이터베이스가 병목이 될 수 있다.&lt;/p>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>개략적 설계안은 출발점으로 나쁘진 않지만 최적화가 이루어지지 않아 장기적으로 발전이 필요한 구조였다.&lt;/p>
&lt;p>이번 절에서는 컴포넌트를 몇 개 골라 보다 상세히 설계하고 다음 순서로 최적화 방안을 논의한다.&lt;/p>
&lt;ul>
&lt;li>트라이(Trie) 자료구조&lt;/li>
&lt;li>데이터 수집 서비스&lt;/li>
&lt;li>질의 서비스&lt;/li>
&lt;li>규모 확장이 가능한 저장소&lt;/li>
&lt;li>트라이 연산&lt;/li>
&lt;/ul>
&lt;h3 id="트라이-자료구조">트라이 자료구조&lt;/h3>
&lt;p>개략적 설계안에서는 관계형 데이터베이스를 저장소로 사용했었지만, 관계형 데이터베이스를 이용해 가장 인기 있었던 다섯 개 질의문을 골라내는 방법은 비교적 효율적이지 않다.&lt;/p>
&lt;p>이 문제는 트라이(Trie, 접두어 트리, Prefix tree)를 사용해 성능을 끌어올릴 수 있다.&lt;/p>
&lt;p>트라이는 &lt;strong>문자열들을 간략하게 저장할 수 있는 자료구조&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>트리 형태의 자료 구조다.&lt;/li>
&lt;li>루트 노드는 빈 문자열을 나타낸다.&lt;/li>
&lt;li>각 노드는 글자 하나를 저장하며, 이 설계에서는 26개의 자식 노드를 가질 수 있다.
&lt;ul>
&lt;li>자식 노드는 해당 글자 다음에 등장할 수 있는 모든 글자의 개수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 트리 노드는 하나의 &lt;strong>단어&lt;/strong>, 또는 &lt;strong>접두어 문자열&lt;/strong>을 나타낸다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_1.png"
width="832"
height="497"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_1_hu96baf2f881fae79a8806ed5884aa8fc0_62176_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_1_hu96baf2f881fae79a8806ed5884aa8fc0_62176_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="기본 트라이 구조"
class="gallery-image"
data-flex-grow="167"
data-flex-basis="401px"
>&lt;/p>
&lt;p>기본 트라이 자료구조는 노드에 문자들을 저장한다.&lt;/p>
&lt;p>이를 이용 빈도에 따라 정렬된 결과를 위해 노드에 빈도 정보까지 함께 저장해야한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>query&lt;/th>
&lt;th>frequency&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>tree&lt;/td>
&lt;td>10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>try&lt;/td>
&lt;td>29&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>true&lt;/td>
&lt;td>35&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>toy&lt;/td>
&lt;td>14&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>wish&lt;/td>
&lt;td>25&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>win&lt;/td>
&lt;td>50&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_2.png"
width="704"
height="423"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_2_hue80ee0274c415f5b7e1ad093e0402423_53720_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_2_hue80ee0274c415f5b7e1ad093e0402423_53720_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="빈도수가 포함된 트라이"
class="gallery-image"
data-flex-grow="166"
data-flex-basis="399px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;code>p&lt;/code>: 접두어 길이&lt;/li>
&lt;li>&lt;code>n&lt;/code>: 트라이 안에 있는 노드 개수&lt;/li>
&lt;li>&lt;code>c&lt;/code>: 주어진 노드의 자식 노드 개수&lt;/li>
&lt;/ul>
&lt;p>가장 많이 사용된 질의어 k개는 다음과 같이 찾을 수 있다.&lt;/p>
&lt;ol>
&lt;li>해당 접두어를 표현하는 노드를 찾는다. &lt;code>O(p)&lt;/code>&lt;/li>
&lt;li>해당 노드부터 시작하는 하위 트리를 탐색하여 모든 유효 노드를 찾는다. &lt;code>O(c)&lt;/code>
&lt;ul>
&lt;li>유효한 검색 문자열을 구성하는 노드가 유효 노드&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유효 노드들을 정렬하여 가장 인기 있는 검색어 k개를 찾는다. &lt;code>O(clogc)&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_3.png"
width="723"
height="500"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_3_hu8518561d22de585d1d9daae8066e51dc_100613_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_3_hu8518561d22de585d1d9daae8066e51dc_100613_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="k = 2, &amp;ldquo;be&amp;rdquo; 입력 예시"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;p>이 알고리즘의 시간 복잡도는 위의 각 단계에 소요된 시간의 합이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>O(p) + O(c) + O(clogc)&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>직관적이지만 최악의 경우 k개 결과를 얻으려고 전체 트라이를 다 검색해야 하는 일이 생길 수 있다.&lt;/p>
&lt;p>이러한 문제를 해결할 방법으로 두 가지 정도를 꼽을 수 있다.&lt;/p>
&lt;ul>
&lt;li>접두어의 최대 길이 제한&lt;/li>
&lt;li>각 노드에 인기 검색어 캐시&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>접두어 최대 길이 제한&lt;/strong>&lt;/p>
&lt;p>사용자가 검색창에 긴 검색어를 입력하는 일은 거의 없다는 것을 이용한 방식으로, &lt;code>p&lt;/code>값을 작은 정숫값으로 가정한다.&lt;/p>
&lt;ul>
&lt;li>접두어 노드를 찾는 단계의 시간 복잡도가 &lt;code>O(p)&lt;/code>에서 &lt;code>O(작은 상수값) = O(1)&lt;/code>로 바뀐다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>노드에서 인기 검색어 캐시&lt;/strong>&lt;/p>
&lt;p>각 노드에 k개의 인기 검색어를 저장해 두면 전체 트라이를 검색하는 일을 방지할 수 있다.&lt;/p>
&lt;ul>
&lt;li>5 ~ 10개 정도의 자동완성 제안을 표시하면 충분하므로, k는 충분히 작은 값이다.&lt;/li>
&lt;/ul>
&lt;p>이러한 방법은 검색어를 질의하는 시간 복잡도를 매우 낮출 수 있으나, 각 노드에 질의어를 저장할 공간이 많이 필요하게된다.&lt;/p>
&lt;p>하지만 빠른 응답속도의 우선순위가 매우 높은 경우 저장공간을 희생할 만한 가치는 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_4.png"
width="832"
height="422"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_4_hu52decc19d8be7f33438032912b874586_137079_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_4_hu52decc19d8be7f33438032912b874586_137079_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="캐시가 적용된 트라이"
class="gallery-image"
data-flex-grow="197"
data-flex-basis="473px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>접두어 최대 길이 제한&lt;/strong>과 &lt;strong>인기 검색어 캐시&lt;/strong>를 추가하면 아래와 같이 최적화 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>접두어 노드를 찾는 시간 복잡도가 &lt;code>O(1)&lt;/code>로 바뀐다.&lt;/li>
&lt;li>최고 인기 검색어 5개를 찾는 질의의 시간 복잡도도 &lt;code>O(1)&lt;/code>로 바뀐다.&lt;/li>
&lt;/ul>
&lt;p>각 단계의 시간 복잡도가 &lt;code>O(1)&lt;/code>로 처리되므로, 최고 인기 검색어 k개를 찾는 전체 알고리즘의 복잡도도 &lt;code>O(1)&lt;/code>이다.&lt;/p>
&lt;h3 id="데이터-수집-서비스-1">데이터 수집 서비스&lt;/h3>
&lt;p>사용자가 검색창에 타이핑을 할 때마다 실시간으로 데이터를 수정하는 방식은 아래와 같은 문제점이 있다.&lt;/p>
&lt;ul>
&lt;li>매일 수천만 건의 질의가 입력될 텐데, 그 때마다 트라이를 갱신하면 질의 서비스는 심각하게 느려진다.&lt;/li>
&lt;li>트라이가 만들어지고 나면 인기 검색어는 그다지 자주 바뀌지 않을 것이다.
&lt;ul>
&lt;li>트라이는 자주 갱신할 필요가 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이를 위한 &lt;strong>규모 확장&lt;/strong>이 쉬운 데이터 수집 서비스를 만들려면 &lt;strong>데이터가 어디서 오고 어떻게 이용되는지&lt;/strong>를 살펴야 한다.&lt;/p>
&lt;ul>
&lt;li>트위터 같은 실시간 애플리케이션
&lt;ul>
&lt;li>제안되는 검색어를 항상 신선하게 유지할 필요가 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>구글 검색 같은 애플리케이션
&lt;ul>
&lt;li>그렇게 자주 바꿔줄 이유는 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_5.png"
width="832"
height="284"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_5_hua9039b8861a31be5feff85427b2db289_102806_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_5_hua9039b8861a31be5feff85427b2db289_102806_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 분석 서비스의 수정된 설계안"
class="gallery-image"
data-flex-grow="292"
data-flex-basis="703px"
>&lt;/p>
&lt;p>트라이를 만드는 데 쓰는 데이터는 보통 &lt;strong>분석 서비스&lt;/strong>(Analytics)나 &lt;strong>로깅 서비스&lt;/strong>(Logging service)를 이용하므로, 실시간으로 반영하지 않더라도 기본 구조는 바뀌지 않는다.&lt;/p>
&lt;p>&lt;strong>데이터 분석 서비스 로그&lt;/strong>&lt;/p>
&lt;p>검색창에 입력된 질의에 관한 원본 데이터가 보관된다.&lt;/p>
&lt;p>새로운 데이터가 추가될 뿐 수정은 이루어지지 않으며, 로그 데이터에는 인덱스를 걸지 않는다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>query&lt;/th>
&lt;th>time&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>tree&lt;/td>
&lt;td>2019-10-01 22:01:01&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&lt;/td>
&lt;td>&amp;hellip;&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>로그 취합 서버&lt;/strong>&lt;/p>
&lt;p>로그는 보통 그 양이 엄청나고 데이터 형식도 제각각인 경우가 많다.&lt;/p>
&lt;p>따라서 이 데이터를 잘 취합하여 우리 시스템이 쉽게 소비할 수 있도록 해야한다.&lt;/p>
&lt;p>데이터 취합 방식은 자동완성 서비스의 제공 방식에 따라 달라질 수 있다.&lt;/p>
&lt;ul>
&lt;li>실시간 애플리케이션
&lt;ul>
&lt;li>데이터 취합 주기를 짧게 가져간다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>대부분의 경우
&lt;ul>
&lt;li>일주일에 한 번 정도 로그를 취합해도 충분&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>취합된 데이터&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>query&lt;/th>
&lt;th>time&lt;/th>
&lt;th>frequency&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>tree&lt;/td>
&lt;td>2019-10-01&lt;/td>
&lt;td>12000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&lt;/td>
&lt;td>&amp;hellip;&lt;/td>
&lt;td>&amp;hellip;&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>작업 서버&lt;/strong>&lt;/p>
&lt;p>주기적으로 비동기적 작업을 실행하는 서버 집합으로, 트라이 자료구조를 만들고 트라이 데이터베이스에 저장하는 역할을 담당한다.&lt;/p>
&lt;p>&lt;strong>트라이 캐시&lt;/strong>&lt;/p>
&lt;p>분산 캐시 시스템으로 트라이 데이터를 메모리에 유지하여 읽기 연산 성능을 높이는 역할을 한다.&lt;/p>
&lt;ul>
&lt;li>매주 트라이 데이터베이스의 스냅샷을 떠서 갱신한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>트라이 데이터베이스&lt;/strong>&lt;/p>
&lt;p>지속성 저장소로 트라이 데이터베이스로 사용할 수 있는 선택지로는 다음의 두 가지가 있다.&lt;/p>
&lt;ul>
&lt;li>문서 저장소(Document store)
&lt;ul>
&lt;li>새 트라이를 매주 만들 것이므로, 주기적으로 트라이를 직렬화하여 데이터베이스에 저장할 수 있다.&lt;/li>
&lt;li>몽고디비(MongoDB) 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>키-값 저장소
&lt;ul>
&lt;li>트라이는 해시 테이블 형태로 변환 가능하다.
&lt;ul>
&lt;li>트라이에 보관된 모든 접두어를 해시 테이블 키로 변환&lt;/li>
&lt;li>각 트라이 노드에 보관된 모든 데이터를 해시 테이블 값으로 변환&lt;/li>
&lt;li>트라이 노드는 하나의 &lt;code>&amp;lt;키, 값&amp;gt;&lt;/code> 쌍으로 변환된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_6.png"
width="818"
height="435"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_6_hua95a8a6c746aca929abb2d260afaf51a_125121_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_6_hua95a8a6c746aca929abb2d260afaf51a_125121_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="트라이를 해시 테이블로"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="451px"
>&lt;/p>
&lt;h3 id="질의-서비스-1">질의 서비스&lt;/h3>
&lt;p>개략적 설계안에서의 데이터베이스를 활용한 방식에서 개선된 새 설계안이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_7.png"
width="540"
height="766"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_7_hu1b3b4c00c9a15e24d680cf68ec588414_134975_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_7_hu1b3b4c00c9a15e24d680cf68ec588414_134975_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="새 설계안"
class="gallery-image"
data-flex-grow="70"
data-flex-basis="169px"
>&lt;/p>
&lt;ol>
&lt;li>검색 질의가 로드밸런서로 전송된다.&lt;/li>
&lt;li>로드밸런서는 해당 질의를 API 서버로 보낸다.&lt;/li>
&lt;li>트라이 캐시에서 데이터를 가져와 해당 요청에 대한 자동완성 검색어 제안 응답을 구성한다.&lt;/li>
&lt;li>데이터가 트라이 캐시에 없는 경우 데이터를 데이터베이스에서 가져와 캐시에 채운다.
&lt;ul>
&lt;li>다음에 같은 접두어에 대한 질의가 올 것을 대비하여 캐시를 갱신&lt;/li>
&lt;li>캐시 미스는 캐서 서버의 메모리가 부족하거나 캐시 서버에 장애가 있어도 발생 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>질의 서비스는 번개처럼 빨라야 한다. 이를 위해 다음과 같은 최적화 방안을 생각해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>AJAX
&lt;ul>
&lt;li>비동기로 결과를 받아오므로, 페이지를 새로고침 할 필요가 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>브라우저 캐싱
&lt;ul>
&lt;li>자동완성 검색어 제안 결과는 짧은 시간에 바뀌지 않으므로, 제안된 검색어들을 브라우저 캐시에 넣어두면 후속 결과는 캐시에서 가져갈 수 있다.&lt;/li>
&lt;li>구글은 제안된 검색어를 한 시간 동안 캐시해둔다.&lt;/li>
&lt;li>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_8.png"
width="834"
height="393"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_8_hu8b0378fb2b4e7998d2c93295e38b4b34_180503_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_8_hu8b0378fb2b4e7998d2c93295e38b4b34_180503_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="system design interview 응답 결과"
class="gallery-image"
data-flex-grow="212"
data-flex-basis="509px"
>
&lt;ul>
&lt;li>&lt;code>cache-control&lt;/code>헤더 값의 &lt;code>private&lt;/code>는 요청을 보낸 사용자의 캐시에만 보관된다는 의미(공용은 불가)&lt;/li>
&lt;li>&lt;code>max-age=3600&lt;/code> 한시간동안 유효&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 샘플링
&lt;ul>
&lt;li>모든 질의 결과를 로깅하도록 하면 CPU 자원과 저장공간을 많이 소진하므로, N개의 요청 가운데 1개만 로깅한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="트라이-연산">트라이 연산&lt;/h3>
&lt;p>트라이는 검색어 자동완성 시스템의 핵심이다.&lt;/p>
&lt;p>&lt;strong>트라이 생성&lt;/strong>&lt;/p>
&lt;p>트라이를 갱신하는데는 두 가지 방법이 있다.&lt;/p>
&lt;ul>
&lt;li>매주 한 번 갱신
&lt;ul>
&lt;li>새로운 트라이를 만든 후 기존 트라이를 대체&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 노드를 개별적으로 갱신
&lt;ul>
&lt;li>성능이 좋지 않다.&lt;/li>
&lt;li>트라이가 작을경우 고려할 수 있다.&lt;/li>
&lt;li>트라이 노드는 상위 노드에도 인기 검색어 질의 결과가 보관되므로 갱신시 모든 상위 노드도 갱신해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_9.png"
width="826"
height="390"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_9_hu73f4c20ed932e2b08c4d01884590a6ef_137820_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_9_hu73f4c20ed932e2b08c4d01884590a6ef_137820_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="트라이 노드 갱신"
class="gallery-image"
data-flex-grow="211"
data-flex-basis="508px"
>&lt;/p>
&lt;p>&lt;strong>검색어 삭제&lt;/strong>&lt;/p>
&lt;p>부적절한 질의어를 자동완성 결과에서 제거해야할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_10.png"
width="826"
height="183"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_10_huf2ca44c4db3538feab14802c19a51e64_69611_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_10_huf2ca44c4db3538feab14802c19a51e64_69611_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="필터 레이어 추가"
class="gallery-image"
data-flex-grow="451"
data-flex-basis="1083px"
>&lt;/p>
&lt;p>이를 위한 좋은 방법은 트라이 캐시 앞에 &lt;strong>필터 계층&lt;/strong>(filter layer)를 두고 부적절한 질의어가 반환되지 않도록 하는 것이다.&lt;/p>
&lt;ul>
&lt;li>필터 규칙에 따라 검색 결과를 자유롭게 변경할 수 있다.&lt;/li>
&lt;li>데이터베이스에서 해당 검색어를 물리적으로 삭제하는 것은 다음 업데이트 사이클에 비동기적으로 진행한다.&lt;/li>
&lt;/ul>
&lt;h3 id="저장소-규모-확장">저장소 규모 확장&lt;/h3>
&lt;p>트라이의 크기가 한 서버에 넣기 힘든 경우에 대응할 수 있도록 규모 확장성 문제를 고려해야한다.&lt;/p>
&lt;p>간단하게 첫 글자를 기준으로 &lt;strong>샤딩&lt;/strong>하는 방법을 생각해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>두 대 서버가 필요하다면 &lt;code>a&lt;/code> ~ &lt;code>m&lt;/code>까지 글자로 시작하는 검색어는 1번 서버, 나머지는 2번 서버에 저장 하는 식으로 &amp;hellip;&lt;/li>
&lt;li>사용 가능한 서버는 최대 26대(영어 알파벳 개수)로 제한되므로, 그 이상 늘리려면 &lt;strong>계층적인 샤딩&lt;/strong>이 필요하다.
&lt;ul>
&lt;li>&lt;code>aa&lt;/code> ~ &lt;code>ag&lt;/code>, &lt;code>ah&lt;/code> ~ &lt;code>an&lt;/code> &amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이렇게 단순한 사딩은 단어의 알파벳 빈도수 문제(특정 알파벳으로 시작되는 단어가 몰려있다.)로 인해 데이터를 각 서버에 균등하게 배분하는것이 불가능하다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/13/img_11.png"
width="688"
height="478"
srcset="https://codemario318.github.io/post/system-design-interview/13/img_11_hu659a97cc810b612463efb5f205eeeb0b_119879_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/13/img_11_hu659a97cc810b612463efb5f205eeeb0b_119879_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="빈도수 반영"
class="gallery-image"
data-flex-grow="143"
data-flex-basis="345px"
>&lt;/p>
&lt;p>따라서 과거 질의 데이터의 패턴을 분석하여 알바벳 빈도수를 파악하고, 빈도수를 통해 샤딩하는 방식을 고려해야한다.&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;ul>
&lt;li>다국어 지원이 가능하도록 하려면?
&lt;ul>
&lt;li>트라이에 유니코드 데이터를 저장한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>국가별로 인기 검색어 순위가 다르다면?
&lt;ul>
&lt;li>국가별로 다른 트라이를 사용하도록 한다.&lt;/li>
&lt;li>트라이를 CDN에 저장하여 응답속도를 높이는 방식도 고려할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>실시간으로 변하는 검색어의 추이를 반영하려면?
&lt;ul>
&lt;li>현제 설계는 위와 같은 처리가 적절치 않다.
&lt;ul>
&lt;li>작업 서버가 매주 한 번 씩만 돈다.&lt;/li>
&lt;li>때 맟춰 서버가 실행되어도, 트라이 구성에 많은 시간이 소요된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>샤딩을 통해 작업 대상 데이터의 양을 줄인다.&lt;/li>
&lt;li>순위 모델을 바꾸어 최근 검색어에 보다 높은 가중치를 준다.&lt;/li>
&lt;li>데이터가 스트림 형태로 올 수 있다는 점, 즉 한번에 모든 데이터를 동시에 사용할 수 없을 가능성이 있다는 점을 고려해야한다.
&lt;ul>
&lt;li>데이터가 지속적으로 생성된다는 뜻으로 스트림 프로세싱을 위한 특별한 시스템이 필요하다.
&lt;ul>
&lt;li>아파치 하둡 맵리듀스, 아파치 스파크 스트리밍, 아파치 스톰, 아파치 카프가 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>12. 채팅 시스템 설계</title><link>https://codemario318.github.io/post/system-design-interview/12/</link><pubDate>Fri, 05 Jul 2024 10:02:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/12/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/cover.png" alt="Featured image of post 12. 채팅 시스템 설계" />&lt;p>이번 장에서는 채팅 시스템을 설계해본다.&lt;/p>
&lt;p>채팅 앱은 중점적으로 다뤄야하는 문제에 따라 방향성이 달라질 수 있으므로, 요구사항을 확실히 파악하는것이 매우 중요하기 때문에, 어떤 채팅 앱을 설계하려는지 확실히 해 두는것이 중요하다.&lt;/p>
&lt;ul>
&lt;li>1:1 채팅 중점
&lt;ul>
&lt;li>페이스북 메신저, 위챗, 왓츠앱 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>그룹 채팅 중점
&lt;ul>
&lt;li>슬랙 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>대규모 그룹의 소통과 음성 채팅
&lt;ul>
&lt;li>디스코드 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>질문을 통해 의도를 파악한다.&lt;/p>
&lt;ul>
&lt;li>Q. 1:1 채팅, 그룹 채팅?
&lt;ul>
&lt;li>A. 둘 다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 모바일? 웹?
&lt;ul>
&lt;li>A. 둘 다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 트래픽 규모는?
&lt;ul>
&lt;li>A. DAU 5천만&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 그룹 채팅의 인원 제한?
&lt;ul>
&lt;li>A. 최대 100명&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 중요 기능으로는?
&lt;ul>
&lt;li>A. 1:1 채팅, 그룹 채팅, 사용자 접속 상태 표시, 텍스트 메시지만 허용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 메시지 길이 제한은?
&lt;ul>
&lt;li>A. 100,000자 이하&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 종단 간 암호화(end-to-end encryption) 지원?
&lt;ul>
&lt;li>A. 현재로서는 불필요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 채팅 이력은 얼마나 보관?
&lt;ul>
&lt;li>A. 영원히.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위와 같은 질의응답을 통해 아래와 같은 요구사항을 찾을 수 있다.&lt;/p>
&lt;ul>
&lt;li>응답지연이 낮은 일대일 채팅기능(DAU)&lt;/li>
&lt;li>최대 100명까지 참여할 수 있는 그룹 채팅 기능&lt;/li>
&lt;li>사용자의 접속상태 표시 기능&lt;/li>
&lt;li>다양한 단말 지원, 하나의 계정으로 여러 단말에 동시 접속 지원(웹, 앱 둘다 고려)&lt;/li>
&lt;li>푸시 알림&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>채팅 시스템의 경우 클라이언트는 모바일 앱이거나 웹 애필리케이션이다.&lt;/p>
&lt;p>클라이언트는 서로 직접 통신하지 않는 대신, 각 클라이언트는 위에 나열한 모든 기능을 지우너하는 채팅 서비스와 통신한다.&lt;/p>
&lt;p>따라서 채팅 서비스는 아래 기능을 제공해야 한다.&lt;/p>
&lt;ul>
&lt;li>클라이언트들로부터 메시지 수진&lt;/li>
&lt;li>메시지 수신자(recipient) 결정 및 전달&lt;/li>
&lt;li>수신자가 접속 상태가 아닌 경우 접속할 때까지 해당 메시지 보관&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img.png"
width="831"
height="141"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_hu846a4193e09f6599f67011f5f29692cb_42945_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_hu846a4193e09f6599f67011f5f29692cb_42945_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클라이언트와 채팅 서비스 관계"
class="gallery-image"
data-flex-grow="589"
data-flex-basis="1414px"
>&lt;/p>
&lt;p>채팅을 시작하려는 클라이언트는 네트워크 통신 프로토콜을 사용하여 서비스에 접속하므로, 어떤 통신 프로토콜을 사용할 것인가도 중요한 문제다.&lt;/p>
&lt;p>대부분의 클라이언트/서버 애플리케이션에서 요청을 보내는 것은 클라이언트이며, 채팅 시스템도 마찬가지다.&lt;/p>
&lt;p>위 예시에서는 송신 클라이언트가 수신 클라이언트에게 전달 할 메시지를 보낼 때, 오랜 세월 검증된 &lt;strong>HTTP 프로토콜&lt;/strong>을 사용한다.&lt;/p>
&lt;p>HTTP를 사용한다면, 채팅 서비스에서는 클라이언트가 지속적으로 메시지를 보낸다는 특성을 고려하여, &lt;code>keep-alive&lt;/code> 헤더를 사용해 서버와 클라이언트가 연결을 끊지 않고 유지하는 것이 좋다.&lt;/p>
&lt;p>하지만 메시지 발신에 비해 수신 시나리오는 이것보다 복잡하기 때문에 HTTP가 적절치 않을 수 있다.&lt;/p>
&lt;ul>
&lt;li>서버가 채팅 발신 요청을 받게 되면, 서버가 수신자에게 메시지를 전달해야한다.&lt;/li>
&lt;li>HTTP는 클라이언트가 연결을 만드는 특성으로, 서버에서 클라이언트로 임의 시점에 메시지를 보내는 데 쉽게 쓰일 수 없다.&lt;/li>
&lt;/ul>
&lt;p>이러한 문제를 개선하기위해 서버가 연결을 만드는 것처럼 동작하는 많은 기법이 제안되었다.&lt;/p>
&lt;ul>
&lt;li>폴링, 롱폴링, 웹소켓&lt;/li>
&lt;/ul>
&lt;h3 id="폴링">폴링&lt;/h3>
&lt;p>폴링은 클라이언트가 주기적으로 서버에게 새 메시지가 있는냐고 물어보는 방법이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_1.png"
width="831"
height="879"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_1_huaa79ccbd5858bc013d0c473ceded0490_112044_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_1_huaa79ccbd5858bc013d0c473ceded0490_112044_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="폴링"
class="gallery-image"
data-flex-grow="94"
data-flex-basis="226px"
>&lt;/p>
&lt;p>폴링 비용은 폴링을 자주하면 할수록 올라가므로, 답해줄 메시지가 없는 경우에는 서버 자원이 불필요하게 낭비된다.&lt;/p>
&lt;h3 id="롱-폴링">롱 폴링&lt;/h3>
&lt;p>폴링의 비효율성을 개선하기위해 롱 폴링이 제안되었다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_2.png"
width="831"
height="746"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_2_hu9446a286a0026c1d57706962c9f7b24e_79065_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_2_hu9446a286a0026c1d57706962c9f7b24e_79065_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="롱 폴링"
class="gallery-image"
data-flex-grow="111"
data-flex-basis="267px"
>&lt;/p>
&lt;ul>
&lt;li>클라이언트는 새 메시지가 반환되거나 타임아웃 될 때가지 연결을 유지한다.&lt;/li>
&lt;li>새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내 모든 절차를 다시 시작한다.&lt;/li>
&lt;/ul>
&lt;p>이 방법은 다음과 같은 약점이 있다.&lt;/p>
&lt;ul>
&lt;li>메시지를 보내는 클라이언트가 수신하는 클라이언트가 같은 채팅 서버에 접속하지 않을 수 있다.
&lt;ul>
&lt;li>HTTP 서버들은 보통 무상태이다. 즉 로드 밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우(요청을 무작위로 분산하는 경우), 메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와의 롱 폴링 연결을 가지고 있지 않은 서버일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서버는 클라이언트가 연결을 해제했는지 알 수 있는 좋은 방법이 없다.&lt;/li>
&lt;li>여전히 비효율적이다.
&lt;ul>
&lt;li>메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 때마다 주기적으로 서버에 다시 접속한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="웹소켓">웹소켓&lt;/h3>
&lt;p>웹소켓은 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_3.png"
width="821"
height="498"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_3_huebfcb5cdfaf26f40aef3085b89b61c7b_77060_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_3_huebfcb5cdfaf26f40aef3085b89b61c7b_77060_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="웹소켓"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="395px"
>&lt;/p>
&lt;ul>
&lt;li>웹소켓 연결은 클라이언트가 시작하며, 한번 맺어진 연결은 항구적이며(변하지않고 오래가며) 양방향이다.&lt;/li>
&lt;li>처음에는 HTTP 연결이지만 특정 핸드셰이크 절차를 거져 웹소켓 연결로 업그레이드된다.
&lt;ul>
&lt;li>일반적으로 방화벽이 있는 환경에서도 잘 동작한다.&lt;/li>
&lt;li>HTTP, HTTPS 가 쓰는 포트를 그대로 활용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>연결이 만들어지고 나면, 서버는 클라이언트에게 비동기적으로 메시지를 전송할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>웹소켓은 메시지를 보내려는 클라이언트에게 준수한 HTTP 프로토콜의 특징에 더해 양방향 메시지 전송까지 가능하게 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_4.png"
width="607"
height="355"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_4_huc6205357ded82087fb2f30ab5b292d46_55256_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_4_huc6205357ded82087fb2f30ab5b292d46_55256_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="웹소켓 활용 예시"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="410px"
>&lt;/p>
&lt;ul>
&lt;li>웹소켓을 이용하면 메시지를 보낼 때나 받을 때 동일한 프로토콜을 사용할 수 있으므로, 설계와 구현이 단순하고 직관적이다.&lt;/li>
&lt;li>단, 웹소켓 연결은 항구적으로 유지되어야 하기 때문에 서버 측에서 연결 관리를 효율적으로 해야한다.&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>클라이언트와 서버 사이의 주 통신 프로토콜로 웹소켓을 사용하지만, 다른 부분에서는 굳이 웹소켓을 쓸 필요는 없다.&lt;/p>
&lt;p>대부분의 기능인 회원가입, 로그인, 사용자 프로파일 등은 기존 HTTP상에서 구현하는 것이 더 좋다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_5.png"
width="644"
height="853"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_5_hu3b37951fbb1bf15ccce6fcd26ff957e5_234991_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_5_hu3b37951fbb1bf15ccce6fcd26ff957e5_234991_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="75"
data-flex-basis="181px"
>&lt;/p>
&lt;p>채팅 시스템은 세 부분으로 나눠볼 수 있다.&lt;/p>
&lt;h4 id="무상태-서비스">무상태 서비스&lt;/h4>
&lt;p>이 설계안에서 무상태 서비스는 로그인, 회원가입, 사용자 프로파일 표시 등을 처리하는 &lt;strong>전통적인 요청/응답&lt;/strong> 서비스다.&lt;/p>
&lt;ul>
&lt;li>일반적인 웹과 앱이 제공하는 기능들&lt;/li>
&lt;/ul>
&lt;p>무상태 서비스는 로드밸런서 뒤에 위치한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>서비스 탐색(sevice discovery) 서비스&lt;/strong>
&lt;ul>
&lt;li>클라이언트가 접속할 채팅 서버의 DNS 호스트명을 클라이언트에게 알려주는 역할을 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="상태-유지-서비스">상태 유지 서비스&lt;/h4>
&lt;p>채팅 서비스는 각 클라이언트는 채팅 서버와 독립적인 네트워크를 유지해야한다.&lt;/p>
&lt;ul>
&lt;li>클라이언트는 보통 다른 서버로 연결을 변경하지 않는다.&lt;/li>
&lt;li>서비스 탐색 서비스가 채팅 서버스와 긴밀히 협력하여 특정 서버에 부하가 몰리지 않도록 한다.&lt;/li>
&lt;/ul>
&lt;h4 id="써드파티-서비스-연동">써드파티 서비스 연동&lt;/h4>
&lt;p>채팅 앱에서 가장 중요한 써드파티 서비스는 푸시 알림이다.&lt;/p>
&lt;ul>
&lt;li>새 메시지 수신시 앱이 실행중이지 않더라도 알림을 받아야한다.&lt;/li>
&lt;/ul>
&lt;p>따라서 푸시 알림 서비스와의 통합은 아주 중요하다.&lt;/p>
&lt;h4 id="규모-확장성">규모 확장성&lt;/h4>
&lt;p>이번 장에서 다루는 시스템은 동시 접속자가 1M 이라고 가정하는데, 접속당 10K 서버 메모리가 필요하다면, 10GB 메모리만으로도 처리 가능하다.&lt;/p>
&lt;p>하지만 이정도 규모의 트래픽을 서버 한대로 처리하는 것은 &lt;strong>SPOF&lt;/strong> 등의 이유로 적절치 않다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_6.png"
width="797"
height="872"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_6_hu2f66c0a05c004fc0f4d257e106c12a84_230686_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_6_hu2f66c0a05c004fc0f4d257e106c12a84_230686_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안 최종"
class="gallery-image"
data-flex-grow="91"
data-flex-basis="219px"
>&lt;/p>
&lt;p>유의할 것은 실시간으로 메시지를 주고받기 위해 클라이언트는 채팅 서버와 웹소켓 연결을 끊지 않고 유지한다는 것이다.&lt;/p>
&lt;ul>
&lt;li>채팅 서버
&lt;ul>
&lt;li>클라이언트 사이에 메시지를 중계하는 역할 담당&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>접속 상태 서버(Presence server)
&lt;ul>
&lt;li>사용자의 접속 여부 관리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>API 서버
&lt;ul>
&lt;li>로그인, 회원가입, 프로파일 변경 등 그 외 나머지를 전부 처리(무상태)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 서버
&lt;ul>
&lt;li>푸시 알림을 보냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>키-값 저장소
&lt;ul>
&lt;li>채팅 이력을 보관&lt;/li>
&lt;li>시스템에 접속한 사용자는 이전 채팅 이력을 전부 보게된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="저장소">저장소&lt;/h4>
&lt;p>채팅 시스템의 기술 스택중 가장 중요한 부분 중 하나는 데이터 계층으로, 이 계층을 올바르게 만드는 데는 노력이 필요하다.&lt;/p>
&lt;p>중요한 선택 중 하나는 어떤 데이터베이스를 쓰는가(관계형, NoSQL 등)이며, 고려해야 할 핵심 요인은 &lt;strong>데이터의 유형&lt;/strong>과 &lt;strong>읽기/쓰기 연산의 패턴&lt;/strong> 이다.&lt;/p>
&lt;p>채팅 시스템에서는 보통 두 가지다.&lt;/p>
&lt;p>&lt;strong>사용자 프로파일, 설정, 친구 목록과 같은 일반적인 데이터&lt;/strong>&lt;br>
안정성을 보장하는 관계형 데이터베이스가 적절하다.&lt;/p>
&lt;ul>
&lt;li>다중화(replication)와 샤딩(sharding)으로 이러한 데이터의 가용성과 규모확장성을 보증할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>채팅 시스템에 고유한 데이터(채팅 이력)&lt;/strong>&lt;br>
이러한 유형의 데이터를 어떻게 보관할 지 결정하려면 읽기/쓰기 연산 패턴을 이해해야한다.&lt;/p>
&lt;ul>
&lt;li>채팅 이력 데이터 양은 엄청나다.
&lt;ul>
&lt;li>페이스북 메신저나 왓츠앱은 매일 600억개 메시지를 처리함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>빈번하게 사용되는 것은 주로 최근에 주고받은 메시지이다.
&lt;ul>
&lt;li>대부분 사용자는 오래된 메시지는 확인하지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>검색 기능, 언급(mention)된 메시지, 특정 메시지로 점프 하는 등 무작위적인 데이터 접근을 하는 경우도 있다.&lt;/li>
&lt;li>1:1 채팅 앱의 경우 읽기:쓰기 비율은 대략 1:1&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>키-값 저장소&lt;/strong>가 이러한 패턴을 지원할 수 있는 데이터베이스이다.&lt;/p>
&lt;ul>
&lt;li>수평적 규모 확장이 쉽다.&lt;/li>
&lt;li>데이터 접근 지연시간이 낮다.&lt;/li>
&lt;li>관계형 데이터베이스는 롱 테일에 해당하는(넓고 적게 분포하는) 데이터를 잘 처리하지 못하는 경향이 있다.
&lt;ul>
&lt;li>인덱스가 커지면 무작위 접근을 처리하는 비용이 늘어난다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이미 많은 안정적인 채팅 시스템이 키-값 저장소를 채택하고있다.
&lt;ul>
&lt;li>페이스북: Hbase, 디스코드: 카산드라 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>롱테일 효과란?&lt;br>
&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_7.png"
width="487"
height="360"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_7_hub3d79bb345ad1bef179816c28fd060f6_45686_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_7_hub3d79bb345ad1bef179816c28fd060f6_45686_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="롱테일 효과"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="324px"
>&lt;br>
파레토 법칙에 의한 80:20 집중 현상을 그래프에 나타냈을 때 꼬리처림 긴 부분을 형성하는 80%의 부분&lt;/p>
&lt;/blockquote>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;h4 id="11-채팅을-위한-메시지-테이블">1:1 채팅을 위한 메시지 테이블&lt;/h4>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
Message {
message_id bigint
message_from bigint
message_to bigint
content text
created_at timestamp
}
&lt;/pre>
&lt;p>&lt;code>Message&lt;/code> 테이블의 기본키는 &lt;code>message_id&lt;/code>로, 메시지 순서를 쉽게 정할 수 있도록 하는 역할도 담당한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>created_at&lt;/code>은 메시지가 동시에 만들어 질 수 있으므로 순서를 정할 수 없다.&lt;/li>
&lt;/ul>
&lt;h4 id="그룹-채팅을-위한-메시지-테이블">그룹 채팅을 위한 메시지 테이블&lt;/h4>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
GroupMessage {
channel_id bigint
message_id bigint
message_to bigint
content text
created_at timestamp
}
&lt;/pre>
&lt;p>&lt;code>(channel_id, message_id)&lt;/code> 복합키를 기본 키로 사용한다.&lt;/p>
&lt;ul>
&lt;li>채널은 채팅 그룹과 같은 뜻&lt;/li>
&lt;li>그룹 채팅에 적용될 모든 질의는 특정 채널을 대상으로 하기 때문에 &lt;code>channel_id&lt;/code>는 파티션 키로 사용할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="메시지-id">메시지 ID&lt;/h4>
&lt;p>위에서 언급한 것 처럼 메시지 ID는 메시지들의 순서도 표현할 수 있어야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>messege_id&lt;/code>는 고유해야한다.&lt;/li>
&lt;li>ID는 정렬 가능해하하며, 시간 순서와 일치해야한다.
&lt;ul>
&lt;li>새로운 ID는 이전 ID 보다 큰 값이어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>RDMBS라면 &lt;code>auto_increment&lt;/code>가 대안이 될 수 있지만 NoSQL은 보통 해당 기능을 제공하지 않는다.&lt;/p>
&lt;ul>
&lt;li>스노 플레이크 같은 전역적 순서 번호 생성기를 이용한다.&lt;/li>
&lt;li>지역적 순서 번호 생성기를 이용한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>지역적 순서 번호 생성기(Local sequence number generator)&lt;/strong>
유일성은 같은 그룹 안에서만 보증하면 충분하다는 의미이다.&lt;/p>
&lt;ul>
&lt;li>채팅 서비스의 특징에 따라 메시지의 순서는 같은 채널, 혹은 1:1 채팅 세션 안에서만 유지되면 충분하다.&lt;/li>
&lt;li>전역적 ID 생성기에 비해 구현이 쉽다.&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>채팅 시스템의 &lt;strong>서비스 탐색&lt;/strong>(service discovery), 메시지 전달 흐름, 사용자 접속 상태 표시하는 법 정도가 세부적으로 살펴보기 적절하다.&lt;/p>
&lt;h3 id="서비스-탐색">서비스 탐색&lt;/h3>
&lt;p>서비스 탐색 기능의 주된 역할은 &lt;strong>클라이언트에게 가장 적합한 채팅 서버를 추천&lt;/strong>하는 것으로 아래의 기준을 활용하여 추천하게된다.&lt;/p>
&lt;ul>
&lt;li>클라이언트의 위치(Geographical location)&lt;/li>
&lt;li>서버의 용량 등&lt;/li>
&lt;/ul>
&lt;p>서비스 탐색 기능을 구현하는 데 널리 쓰이는 오픈 소스 솔루션으로 &lt;strong>아파치 주키퍼&lt;/strong>같은 것이 있다.&lt;/p>
&lt;ul>
&lt;li>사용 가능한 모든 채팅 서버를 등록시켜 두고, 클라이언트가 접속을 시도하면 사전에 정한 기준에 따라 최적의 채팅 서버를 골라준다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_8.png"
width="718"
height="698"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_8_hu68029a52e7e091c75ea09add17c7232a_109024_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_8_hu68029a52e7e091c75ea09add17c7232a_109024_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="주키퍼로 구현한 서비스 탐색 흐름"
class="gallery-image"
data-flex-grow="102"
data-flex-basis="246px"
>&lt;/p>
&lt;ol>
&lt;li>사용자 A가 시스템에 로그인 시도&lt;/li>
&lt;li>로드밸런서가 로그인 요청을 API 서버들 가운데 하나로 보냄&lt;/li>
&lt;li>API 서버가 사용자 인증을 처리하고 나면 서비스 탐색 기능이 동작하여 최적의 채팅 서버를 찾음&lt;/li>
&lt;li>찾은 서버와 웹소켓 연결&lt;/li>
&lt;/ol>
&lt;h3 id="메시지-흐름">메시지 흐름&lt;/h3>
&lt;p>채팅 시스템에 있어서 종단 간 메시지 흐름을 이해하는 것은 흥미로운 주제이다.&lt;/p>
&lt;p>1:1 채팅 메시지의 처리 흐름과 여러 단말 간 메시지 동기화 과정을 살펴본 후, 그룹 채팅 메시지의 처리 흐름을 살펴본다.&lt;/p>
&lt;h4 id="11-채팅-메시지-처리-흐름">1:1 채팅 메시지 처리 흐름&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_9.png"
width="675"
height="721"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_9_hu69fa1b06e4a527bf42d264a7bc16f467_126368_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_9_hu69fa1b06e4a527bf42d264a7bc16f467_126368_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="1:1 채팅 메시지 처리 흐름"
class="gallery-image"
data-flex-grow="93"
data-flex-basis="224px"
>&lt;/p>
&lt;ol>
&lt;li>사용자 A가 채팅 서버 1로 메시지 전송&lt;/li>
&lt;li>채팅 서버 1은 ID 생성기를 사용해 해당 메시지의 ID 결정&lt;/li>
&lt;li>채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송&lt;/li>
&lt;li>메시지가 키-값 저장소에 보관됨&lt;/li>
&lt;li>
&lt;ol>
&lt;li>사용자 B가 접속 중인 경우 메시지는 접속 중인 채팅 서버로 전송&lt;/li>
&lt;li>사용자가 B가 접속 중이 아닌 경우 푸시 알림 메시지를 푸시 알림 서버로 보냄&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>채팅 서버는 웹소켓 연결을 통해 메시지를 사용자 B에게 전송.&lt;/li>
&lt;/ol>
&lt;h4 id="여러-단말-사이의-메시지-동기화">여러 단말 사이의 메시지 동기화&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_10.png"
width="827"
height="601"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_10_hu237dc5988b99c0258bbc96b3a092c068_95136_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_10_hu237dc5988b99c0258bbc96b3a092c068_95136_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="메시지 동기화"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="330px"
>&lt;/p>
&lt;p>각 단말은 관측된 가장 최신 메시지의 ID를 추적하기 위한 &lt;code>cur_max_message_id&lt;/code> 라는 변수를 유지한다.&lt;/p>
&lt;ul>
&lt;li>수신자 ID가 현재 로그인한 사용자 ID와 같다.&lt;/li>
&lt;li>키-값 저장소에 보관된 메시지로서, 그 ID가 &lt;code>cur_max_message_id&lt;/code>보다 크다.&lt;/li>
&lt;/ul>
&lt;p>위 조건을 만족하는 메시지는 새 메시지로 간주된다.&lt;/p>
&lt;p>&lt;code>cur_max_message_id&lt;/code>는 단말마다 별도로 유지 관리하면 되는 값이라 키-값 저장소에서 새 메시지를 가져오는 동기화 작업도 쉽게 구현할 수 있다.&lt;/p>
&lt;h4 id="소규모-그룹-채팅에서의-메시지-흐름">소규모 그룹 채팅에서의 메시지 흐름&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_11.png"
width="747"
height="649"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_11_hu3912c41ccdd5c95c734f65d055df6d26_117861_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_11_hu3912c41ccdd5c95c734f65d055df6d26_117861_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="소규모 그룹 채팅 메시지 흐름"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="276px"
>&lt;/p>
&lt;p>1:1 채팅에 비해 조금 더 복잡하다.&lt;/p>
&lt;p>사용자 A가 그룹 채팅방에서 메시지를 보내면, 사용자 B, C의 &lt;strong>메시지 동기화 큐&lt;/strong>에 복사된다.&lt;/p>
&lt;p>이러한 설계는 소규모 그룹 채팅에 적합하다.&lt;/p>
&lt;ul>
&lt;li>새로운 메시지가 왔는지 확인하려면 자기 큐만 보면 되므로 메시지 동기화 플로가 단순하다.&lt;/li>
&lt;li>그룹이 크지 않으면 메시지를 수신자별로 복사해서 큐에 넣는 작업 비용이 문제되지 않는다.&lt;/li>
&lt;/ul>
&lt;p>많은 사용자를 지원해야 하는 경우라면 똑같은 메시지를 모든 사용자의 큐에 복사하는 게 바람직하지 않다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_12.png"
width="716"
height="620"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_12_hub1a8d58b86737e6dabf10d70f993bb1d_101204_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_12_hub1a8d58b86737e6dabf10d70f993bb1d_101204_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="수신자 관점 메시지 흐름"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="277px"
>&lt;/p>
&lt;p>위와 같은 흐름을 &lt;strong>메시지 수신자&lt;/strong> 관점에서 살펴보면, 한 수신자는 여러 사용자로부터 오는 메시지를 수신할 수 있어야 한다.&lt;/p>
&lt;h3 id="접속-상태-표시">접속 상태 표시&lt;/h3>
&lt;p>사용자 접속 상태를 표시하는 것은 상당수 채팅 애플리케이션의 핵심 기능이다.&lt;/p>
&lt;p>개략적 설계안의 &lt;strong>접속 상태 서버&lt;/strong>(presense server)를 통해 사용자의 상태를 관리하는데, 접속상태 서버는 클라이언트와 웹소켓으로 통신하는 실시간 서비스의 일부라는 점에 유의해야한다.&lt;/p>
&lt;p>&lt;strong>사용자 로그인&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_13.png"
width="766"
height="206"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_13_hub37db33c8b8c4205291185c196c0ce06_57084_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_13_hub37db33c8b8c4205291185c196c0ce06_57084_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="로그인"
class="gallery-image"
data-flex-grow="371"
data-flex-basis="892px"
>&lt;/p>
&lt;p>클라이언트와 실시간 서비스 사이에 웹소켓 연결이 맺어지고 나면 접속상태 서버는 A의 상태와 &lt;code>last_active_at&lt;/code> 타임스탬프 값을 키-값 저장소에 보관한다.&lt;/p>
&lt;p>이 절차가 끝나면 해당 사용자는 접속 중인 것으로 표시될 것이다.&lt;/p>
&lt;p>&lt;strong>로그아웃&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_14.png"
width="830"
height="167"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_14_huc82ec414ab58d2aa81718a978ef2720f_65884_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_14_huc82ec414ab58d2aa81718a978ef2720f_65884_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="로그아웃"
class="gallery-image"
data-flex-grow="497"
data-flex-basis="1192px"
>&lt;/p>
&lt;p>키-값 저장소에 보관된 사용자 상태가 &lt;code>online&lt;/code>에서 &lt;code>offline&lt;/code>으로 바뀐다.&lt;/p>
&lt;p>&lt;strong>접속 장애&lt;/strong>&lt;/p>
&lt;p>인터넷 연결이 끊어지는 상황에 대응할 수 있는 설계를 준비해야한다.&lt;/p>
&lt;p>사용자의 인터넷 연결이 끊어지면 클라이언트와 서버 사이에 맺어진 웹소켓 같은 지속성 연결도 끊어진다.&lt;/p>
&lt;p>이러한 경우 &lt;strong>사용자를 오프라인 상태로 표시하고 연결이 복구되면 온라인 상태로 변경&lt;/strong>하는 방법을 고려할 수 있지만, 짧은 시간 동안 인터넷 연결이 끊어졌다 복귀되는 현상이 흔하기 때문에 적절하지 않다.&lt;/p>
&lt;ul>
&lt;li>이런 현상마다 사용자의 접속 상태를 변경하는 것은 지나치며, 사용자 경험 측면에서도 바람직하지 않다.&lt;/li>
&lt;/ul>
&lt;p>이에 따라 &lt;strong>박동(heartbeat) 검사&lt;/strong>를 통해 이 문제를 해결한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_15.png"
width="753"
height="620"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_15_hu870405f6db98088b77813163c0a21c89_78387_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_15_hu870405f6db98088b77813163c0a21c89_78387_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="박동 검사"
class="gallery-image"
data-flex-grow="121"
data-flex-basis="291px"
>&lt;/p>
&lt;ol>
&lt;li>온라인 상태의 클라이언트로 하여금 주기적으로 박동 이벤트를 접속상태 서버로 보낸다.&lt;/li>
&lt;li>마지막 이벤트를 받은 지 x초 이내에 또 다른 박동 이벤트 메시지를 받으면 해당 사용자의 접속 상태를 계속 온라인으로 유지한다.&lt;/li>
&lt;/ol>
&lt;h3 id="상태-정보의-전송">상태 정보의 전송&lt;/h3>
&lt;p>상태정보 서버는 각각의 친구관게마다 채널을 하나씩 두는 발행-구독 모델을 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_16.png"
width="844"
height="399"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_16_huda3d97a35351d5c19e5533f1c287c481_139268_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_16_huda3d97a35351d5c19e5533f1c287c481_139268_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="상태 정보 전송"
class="gallery-image"
data-flex-grow="211"
data-flex-basis="507px"
>&lt;/p>
&lt;p>이러한 구조를 통해 친구 관계에 있는 사용자가 상태정보 변화를 쉽게 통지 받을 수 있게 된다(웹소켓 사용).&lt;/p>
&lt;p>이러한 방안은 그룹의 크기가 커지면 비용이나 시간이 많이 들게되므로 좋지 않다.&lt;/p>
&lt;ul>
&lt;li>그룹 하나의 100,000명이 있다면, 상태변화 1건당 100,000개의 이벤트 메시지가 발생한다.&lt;/li>
&lt;/ul>
&lt;p>이런 성능 문제를 해소하는 방법은&lt;/p>
&lt;ul>
&lt;li>사용자가 그룹 채팅에 입장하는 순간에만 상태 정보를 읽어가게 만든다.&lt;/li>
&lt;li>친구 리스트에 있는 사용자의 접속상태를 갱신하고 싶으면 수동으로 하도록 유도한다.&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>1:1 채팅과 그룹 채팅을 전부 지원하는 채팅 시스템의 아키텍처를 살펴보았다.&lt;/p>
&lt;ul>
&lt;li>클라이언트와 서버 사이의 통신을 가능하도록 하기 위해 웹소켓을 사용했다.&lt;/li>
&lt;li>주요 컴포넌트
&lt;ul>
&lt;li>실시간 메시징을 지원하는 채팅 서버&lt;/li>
&lt;li>접속 상태 서버&lt;/li>
&lt;li>푸시 알림 서버&lt;/li>
&lt;li>채팅 이력을 보관할 키-값 저장소&lt;/li>
&lt;li>이를 제외한 나머지 기을을 구현하는 데 쓰을 API 서버 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>시간이 남는다면 다음과 같은 내용을 논의해도 좋다.&lt;/p>
&lt;ul>
&lt;li>사진이나 비디오 등의 미디어를 지원하도록 하는 방법
&lt;ul>
&lt;li>압축 방식, 클라우드 저장소, 섬네일 생성 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>종단 간 암호화&lt;/li>
&lt;li>캐시
&lt;ul>
&lt;li>이미 읽은 메시지를 캐시해 두면 서버와 주고받는 데이터 양을 줄일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>로딩 속도 개선
&lt;ul>
&lt;li>슬랙은 사용자의 데이터, 채널 등을 지역적으로 분산하는 네트워크를 구축하여 앱 로딩 속도를 개선하였다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오류 처리
&lt;ul>
&lt;li>채팅 서버 오류
&lt;ul>
&lt;li>서버 하나가 죽으면 서비스 탐색 기능이 동작하여 클라이언트에게 새로운 서버를 배정하고 다시 접속할 수 있도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 재전송
&lt;ul>
&lt;li>재시도나 큐는 메시지의 안정적 전송을 보장하기 위해 흔히 사용되는 기법이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>11. 뉴스 피드 시스템 설계</title><link>https://codemario318.github.io/post/system-design-interview/11/</link><pubDate>Thu, 04 Jul 2024 22:51:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/11/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/11/cover.png" alt="Featured image of post 11. 뉴스 피드 시스템 설계" />&lt;h2 id="뉴스-피드란">뉴스 피드란?&lt;/h2>
&lt;p>페이스북의 도움말 페이지에서는 아래와 같이 뉴스 피드를 설명하고 있다.&lt;/p>
&lt;blockquote>
&lt;p>홈 페이지 중앙에 지속적으로 업데이트되는 스토리와 사용자 상태 정보 업데이트, 사진, 비디오, 링크, 앱 활동 팔로우하는 사람들, 페이지, 그룹으로부터 나오는 좋아요 등을 포함한다.&lt;/p>
&lt;/blockquote>
&lt;p>뉴스 피드 시스템 설계는 아주 유명한 면접 문제이다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;ul>
&lt;li>Q. 모바일 앱, 웹 어떤걸 지원해야하는가?
&lt;ul>
&lt;li>A. 둘다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 주요 기능은?
&lt;ul>
&lt;li>A. 사용자는 뉴스 피드 페이지에 새로운 스토리를 올릴 수 있어야함
&lt;ul>
&lt;li>친구들이 올리는 스토리를 볼 수도 있어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 어떤 순서로 스토리가 표시되는가? 최신 포스트? 토픽 점수 기반?
&lt;ul>
&lt;li>A. 시간 흐름 역순으로 표시(Reverse chronological order)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 한 명의 사용자는 최대 몇 명의 친구를 가질 수 있는가?
&lt;ul>
&lt;li>A. 5,000명&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 트래픽 규모는?
&lt;ul>
&lt;li>A. 매일 천만 명 방문한다고 가정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 피드에 이미지나 비디오 스토리도 올라올 수 있는가?
&lt;ul>
&lt;li>A. 이미지나 비디오 등 미디어 파일이 포함될 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="개략적-설계안-제시-및-동의-구하기">개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>뉴스 피드 시스템 설계는 &lt;strong>피드 발행&lt;/strong>(Feed publishing)과 &lt;strong>뉴스 피드 생성&lt;/strong>(News feed building) 두 가지 구분으로 나눌 수 있다.&lt;/p>
&lt;ul>
&lt;li>피드 발행
&lt;ul>
&lt;li>사용자가 스토리를 포스팅하면 해당 데이터를 캐시와 데이터베이스에 기록한다.&lt;/li>
&lt;li>새 포스팅은 친구의 뉴스 피드에도 전송된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>뉴스 피드 생성
&lt;ul>
&lt;li>뉴스 피드는 모든 친구의 포스팅을 시간 흐름 역순으로 모아서 만든다고 가정한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="뉴스-피드-api">뉴스 피드 API&lt;/h3>
&lt;p>뉴스 피드 API는 HTTP 프로토콜 기반으로 클라이언트가 서버와 통신하기 위해 사용하는 수단이다.&lt;/p>
&lt;ul>
&lt;li>상태 정보를 업데이트 할 때&lt;/li>
&lt;li>뉴스 피드를 가져올 때&lt;/li>
&lt;li>친구를 추가하는 등 다양한 작업 수행&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>피드 발행 API&lt;/strong>&lt;/p>
&lt;p>새 스토리를 포스팅하기 위한 API다.&lt;/p>
&lt;p>HTTP POST 형태로 요청을 보낸다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">POST /v1/me/feed
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>인자
&lt;ul>
&lt;li>body: 포스트 내용&lt;/li>
&lt;li>Authorization 헤더: API 호출을 인증하기 위해 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>피드 읽기 API&lt;/strong>&lt;/p>
&lt;p>뉴스 피드를 가져오는 API다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GET /v1/me/feed
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>인자
&lt;ul>
&lt;li>Authorization 헤더: API 호출을 인증하기 위해 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="피드-발행">피드 발행&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/11/img.png"
width="537"
height="818"
srcset="https://codemario318.github.io/post/system-design-interview/11/img_hu891d2a45b04e66955eabc83b2e6d7650_139382_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/11/img_hu891d2a45b04e66955eabc83b2e6d7650_139382_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="피드 발행 구조"
class="gallery-image"
data-flex-grow="65"
data-flex-basis="157px"
>&lt;/p>
&lt;ul>
&lt;li>사용자
&lt;ul>
&lt;li>모바일 앱이나 브라우저에서 새 포스팅을 올리는 주체&lt;/li>
&lt;li>&lt;code>POST /v1/me/feed&lt;/code> API를 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>로드밸런서(load balancer)
&lt;ul>
&lt;li>트래픽을 웹 서버들로 분산&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 서버
&lt;ul>
&lt;li>HTTP 요청을 내부 서비스로 중계하는 역할을 담당&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>포스팅 저장 서비스(Post service)
&lt;ul>
&lt;li>새 포스팅을 데이터베이스와 캐시에 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>포스팅 전송 서비스(Fanout service)
&lt;ul>
&lt;li>새 포스팅을 친구의 뉴스피드에 푸시(push)&lt;/li>
&lt;li>뉴스 피드 데이터는 캐시에 보관하여 빠르게 읽어갈 수 있도록 해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 서비스(notification service)
&lt;ul>
&lt;li>친구들에게 새 포스팅이 올라왔음을 알림&lt;/li>
&lt;li>푸시 알림을 보냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="뉴스-피드-생성">뉴스 피드 생성&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/11/img_1.png"
width="425"
height="634"
srcset="https://codemario318.github.io/post/system-design-interview/11/img_1_hu69fcfbc2dbdf50bdcc685e78596b2bbb_88291_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/11/img_1_hu69fcfbc2dbdf50bdcc685e78596b2bbb_88291_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="뉴스 피드 생성 구조"
class="gallery-image"
data-flex-grow="67"
data-flex-basis="160px"
>&lt;/p>
&lt;ul>
&lt;li>사용자
&lt;ul>
&lt;li>뉴스 피드를 읽는 주체&lt;/li>
&lt;li>&lt;code>GET /v1/me/feed&lt;/code>를 이용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>로드 밸런서
&lt;ul>
&lt;li>트래픽을 웹 서버들로 분산&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 서버
&lt;ul>
&lt;li>트래픽을 뉴스 피드 서비스로 보냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>뉴스 피드 서비스(news feed service)
&lt;ul>
&lt;li>캐시에서 뉴스 피드를 가져오는 서비스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>뉴스 피드 캐시(news feed cache)
&lt;ul>
&lt;li>랜더링할 때 필요한 피드ID를 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="피드-발행-흐름-상세-설계">피드 발행 흐름 상세 설계&lt;/h3>
&lt;p>웹 서버와 포스팅 전송 서비스에 초점을 두고 확인한다.&lt;/p>
&lt;p>&lt;strong>웹 서버&lt;/strong>&lt;/p>
&lt;p>클라이언트와 통신할 뿐 아니라 인증이나 처리율 제한 기능도 수행한다.&lt;/p>
&lt;ul>
&lt;li>올바른 인증 토큰을 Authorization 헤더에 넣고 API를 호출하는 사용자만 포스팅 할 수 있어야 한다.&lt;/li>
&lt;li>스팸을 막고 유해한 콘텐츠가 자주 올라오는 것을 방지하기 위해 사용자가 올리 수 있는 포스팅 수를 제한을 둬야한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>포스팅 전송(팬아웃) 서비스&lt;/strong>&lt;/p>
&lt;p>포스팅 전송, 즉 팬아웃(fanout)은 어떤 사용자의 새 포스팅을 그 사용자와 친구 관계에 있는 모든 사용자에게 전달하는 과정이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/11/img_2.png"
width="863"
height="952"
srcset="https://codemario318.github.io/post/system-design-interview/11/img_2_huda53be8af4aa5fdd5c6f7a22043667e4_267454_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/11/img_2_huda53be8af4aa5fdd5c6f7a22043667e4_267454_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="포스팅 전송 서비스"
class="gallery-image"
data-flex-grow="90"
data-flex-basis="217px"
>&lt;/p>
&lt;p>두 가지 유형이 존재하며 각기 장단점을 가진다.&lt;/p>
&lt;p>&lt;strong>푸시 모델(push model)&lt;/strong>&lt;/p>
&lt;p>새로운 포스팅을 기록하는 시점(쓰기 시점)에 뉴스피드를 갱신하게 된다.&lt;/p>
&lt;p>다시 말해, 포스팅이 완료되면 바로 해당 사용자의 캐시에 해당 포스팅을 기록한다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>뉴스피드가 실시간으로 갱신되며 친구 목록에 있는 사용자에게 &lt;strong>즉시 전송&lt;/strong>&lt;/li>
&lt;li>새 포스팅이 기록되는 순간에 뉴스 피드가 이미 갱신되므로(pre-computed) 뉴스 피드를 읽는 데 드는 시간이 짧아짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>친구가 많은 사용자의 경우 뉴스 피드를 갱신하는 데 많은 시간이 소요될 수도 있음
&lt;ul>
&lt;li>핫키(Hotkey) 문제&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서비스를 자주 이용하지 않는 사용자의 피드까지 갱신해야 하므로 자원 낭비&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>풀 모델(pull model)&lt;/strong>&lt;/p>
&lt;p>피드를 읽어야 하는 시점에 뉴스 피드를 갱신한다.&lt;/p>
&lt;p>따라서 &lt;strong>요청 기반&lt;/strong>(on-demand) 모델이며, 사용자가 본인 홈페이지나 타임 라인을 로딩하는 시점에 새로운 포스트를 가져오게 된다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>로그인하기까지는 어떤 컴퓨팅 자원도 소모하지 않으므로 비활성화된 사용자는 이 모델이 유리하다.&lt;/li>
&lt;li>데이터를 친구 각각에 푸시하는 작업이 필요 없으므로 핫키 문제도 생기지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>뉴스 피드를 읽는 데 많은 시간이 소요될 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이번 설계안은 두 가지 방법을 결합하여 장점은 취하고 단점은 버린다.&lt;/p>
&lt;ul>
&lt;li>뉴스피드를 빠르게 가져올 수 있도록 하는 것은 아주 중요하므로 대부분의 사용자에 대해서 푸시 모델 사용&lt;/li>
&lt;li>친구, 팔로워가 아주 많은 사용자의 경우는 해당 사용자의 포스팅을 필요할 때 가져가도록 하는 풀 모델을 사용&lt;/li>
&lt;li>안정 해시(consistent hashing)을 통해 요청과 데이터를 고르게 분산하여 핫 키 문제를 완화&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/11/img_3.png"
width="643"
height="597"
srcset="https://codemario318.github.io/post/system-design-interview/11/img_3_hua09b20c3092217fe155cb7d5889b4e53_145261_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/11/img_3_hua09b20c3092217fe155cb7d5889b4e53_145261_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="107"
data-flex-basis="258px"
>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>그래프 데이터베이스&lt;/strong>에서 친구 ID 목록을 가져온다.
&lt;ul>
&lt;li>그래프 데이터베이스는 친구 관계나 친구 추천을 관리하기 적합하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자 정보 캐시에서 친구들의 정보를 가져온후, 설정에 따라 일부 걸러낸다.
&lt;ul>
&lt;li>차단 등 이유로&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>친구 목록과 새 스토리의 포스팅 ID를 메시키 큐에 넣는다.&lt;/li>
&lt;li>팬아웃 작업 서버가 메시지 큐에서 데이터를 꺼내 뉴스 피드 데이터를 뉴스 피드 캐시에 넣는다.
&lt;ul>
&lt;li>뉴스 피드 캐시: &lt;code>&amp;lt;포스팅 ID, 사용자 ID&amp;gt;&lt;/code>&lt;/li>
&lt;li>모든 데이터를 포함하면 메모리 요구량이 지나치게 늘어날 수 있다.&lt;/li>
&lt;li>어떤 사용자가 뉴스 피드에 올라온 수천 개의 스토리를 볼 확률은 지극히 낮다.(캐시 미스 확률이 낮다.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="피드-읽기-흐름-상세-설계">피드 읽기 흐름 상세 설계&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/11/img_4.png"
width="724"
height="728"
srcset="https://codemario318.github.io/post/system-design-interview/11/img_4_hufb1b28fc20f324cce39c94a4369c34ac_210247_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/11/img_4_hufb1b28fc20f324cce39c94a4369c34ac_210247_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="피드 읽기 흐름"
class="gallery-image"
data-flex-grow="99"
data-flex-basis="238px"
>&lt;/p>
&lt;p>이미지나 비디오와 같은 미디어 콘텐츠는 CDN에 저장하여 빨리 읽어갈 수 있도록 한다.&lt;/p>
&lt;ol>
&lt;li>사용자가 뉴스 피드 읽기 요청을 보냄&lt;/li>
&lt;li>로드밸런서가 요청을 웹 서버 가운데 하나로 보냄&lt;/li>
&lt;li>피드를 가져오기 위해 뉴스 피드 서비스 호출&lt;/li>
&lt;li>뉴스 피드 캐시에서 포스팅 ID 목록을 조회&lt;/li>
&lt;li>사용자 이름, 사용자 사진 등을 사용자 캐시와 포스팅 캐시에서 가져와 완전한 뉴스 피드 생성&lt;/li>
&lt;li>JSON 형태로 응답&lt;/li>
&lt;/ol>
&lt;h3 id="캐시-구조">캐시 구조&lt;/h3>
&lt;p>캐시는 &lt;strong>뉴스 피드 시스템의 핵심 컴포넌트&lt;/strong>이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/11/img_5.png"
width="831"
height="461"
srcset="https://codemario318.github.io/post/system-design-interview/11/img_5_hu7a050117f609eaff8b50eedec13da585_109520_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/11/img_5_hu7a050117f609eaff8b50eedec13da585_109520_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="5계층 캐시 구조"
class="gallery-image"
data-flex-grow="180"
data-flex-basis="432px"
>&lt;/p>
&lt;ul>
&lt;li>뉴스피드
&lt;ul>
&lt;li>뉴스 피드의 ID 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>콘텐츠
&lt;ul>
&lt;li>포스팅 데이터를 보관&lt;/li>
&lt;li>인기 콘텐츠는 따로 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>소셜 그래프
&lt;ul>
&lt;li>사용자 간 관계 정보를 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>행동(action)
&lt;ul>
&lt;li>포스팅에 대한 사용자의 행위에 관한 정보를 보관&lt;/li>
&lt;li>좋아요, 답글 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>횟수(counter)
&lt;ul>
&lt;li>좋아요 횟수, 응답 수, 팔로워 수, 팔로잉 수 등 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>이번 설계안은 &lt;strong>뉴스 피드 발행&lt;/strong>, &lt;strong>뉴스 피드 생성&lt;/strong> 두 부분으로 구성되어 있다.&lt;/p>
&lt;p>설계를 진행하고 기술을 선택할 때는 그 배경에 어떤 타협적 결정들이 있었는지 잘 이해하고 설명할 수 있어야 한다.&lt;/p>
&lt;p>시간이 남는다면 &lt;strong>규모 확장성 이슈&lt;/strong>를 논의하는 것이 좋을 수 있다.&lt;/p>
&lt;h3 id="데이터베이스-규모-확장">데이터베이스 규모 확장&lt;/h3>
&lt;ul>
&lt;li>수직적 규모 확장 vs 수평적 규모 확장&lt;/li>
&lt;li>SQL vs NoSQL&lt;/li>
&lt;li>master-slave 다중화&lt;/li>
&lt;li>복제본(replica)에 대한 읽기 연산&lt;/li>
&lt;li>일관성 모델(consistency model)&lt;/li>
&lt;li>데이터베이스 샤딩&lt;/li>
&lt;/ul>
&lt;h3 id="그-외">그 외&lt;/h3>
&lt;ul>
&lt;li>웹 계층을 무상태로 운영하기&lt;/li>
&lt;li>가능한 한 많은 데이터를 캐시할 방법&lt;/li>
&lt;li>여러 데이터 센터를 지원할 방법&lt;/li>
&lt;li>메시지 큐를 사용하여 컴포넌트 사이의 결합도 낮추기&lt;/li>
&lt;li>핵심 메트릭에 대한 모니터링
&lt;ul>
&lt;li>트래픽이 몰리는 시간대의 QPS&lt;/li>
&lt;li>사용자가 뉴스 피드를 새로고침 할 때 지연 시간 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>10. 알람 시스템 설계</title><link>https://codemario318.github.io/post/system-design-interview/10/</link><pubDate>Thu, 27 Jun 2024 21:43:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/10/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/cover.png" alt="Featured image of post 10. 알람 시스템 설계" />&lt;p>알림 시스템은 최근 많은 프로그램들이 채택한 인기 있는 기능이다.&lt;/p>
&lt;p>고객에게 중요할 만한 정보를 &lt;strong>비동기적&lt;/strong>으로 제공한다.&lt;/p>
&lt;ul>
&lt;li>모마일 푸시 알림&lt;/li>
&lt;li>SMS 메시지&lt;/li>
&lt;li>이메일&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>하루에 백만 건 이상의 알림을 처리하는 확장성 높은 시스템을 구축하는건 쉬운 과제가 아니다.&lt;/p>
&lt;p>알림 시스템이 어떻게 구현되는지에 대한 깊은 이해가 필요하다.&lt;/p>
&lt;ul>
&lt;li>Q. 어떤 종류의 알림을 지원해야하는가?
&lt;ul>
&lt;li>A. 푸시 알림, SMS 메시지, 이메일&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 실시간 시스템?
&lt;ul>
&lt;li>A. 연성 실시간 시스템 &amp;gt; 빨리 전달해야하지만 시스템의 부하가 심할 때 약간의 지연은 무방함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 지원 단말?
&lt;ul>
&lt;li>A. IOS, 안드로이드, 랩톱/데스크톱&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 알림은 누가 만들 수 있는가?
&lt;ul>
&lt;li>A. 클라이언트 애플리케이션, 서버측 스케쥴링&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 알림 거부 가능?
&lt;ul>
&lt;li>A. 예&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 하루 몇 건의 알림 처리?
&lt;ul>
&lt;li>A. 천만 건 푸시 알림, 백만 건 SMS, 5백만 건 이메일&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="알림-유형-별-지원-방안">알림 유형 별 지원 방안&lt;/h3>
&lt;p>유형에 따라 동작하는 알림 메커니즘에 차이가 있다.&lt;/p>
&lt;p>&lt;strong>IOS 푸시 알림&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img.png"
width="575"
height="126"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_hu740000bab3f30bdd0a1a67ae3b5eabd1_20508_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_hu740000bab3f30bdd0a1a67ae3b5eabd1_20508_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="ios 푸시 알림 컴포넌트"
class="gallery-image"
data-flex-grow="456"
data-flex-basis="1095px"
>&lt;/p>
&lt;p>IOS에서 푸시 알림을 보내기 위해서는 3가지 컴포넌트가 필요하다.&lt;/p>
&lt;ul>
&lt;li>일림 제공자(provider)
&lt;ul>
&lt;li>알림 요청을 만들어 &lt;strong>애플 푸시 알림 서비스&lt;/strong>(APNS)로 보내는 주체로 두개의 정보가 필요하다.&lt;/li>
&lt;li>&lt;strong>단말 토큰&lt;/strong>: 알림 요청을 보내는 데 필요한 고유 식별자&lt;/li>
&lt;li>&lt;strong>페이로드&lt;/strong>: 알림 내용을 담은 JSON 딕셔너리&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;aps&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;alert&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;title&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Game Request&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;body&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Bob wants to play chess&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;action-loc-key&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;PLAY&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;badge&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>APNS
&lt;ul>
&lt;li>애플이 제공하는 원격 서비스&lt;/li>
&lt;li>푸시 알림을 IOS 장치로 보내는 역할을 담당.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>IOS 단말
&lt;ul>
&lt;li>푸시 알림을 수신하는 사용자의 단말&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>안드로이드 푸시 알림&lt;/strong>&lt;/p>
&lt;p>APNS를 사용하는 IOS와 달리 FCM(Firebase Cloud Messaging)을 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_1.png"
width="634"
height="142"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_1_hu230abd40214ac2cc9d4d6ae33273b666_22808_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_1_hu230abd40214ac2cc9d4d6ae33273b666_22808_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="AOS 푸시 알림 컴포넌트"
class="gallery-image"
data-flex-grow="446"
data-flex-basis="1071px"
>&lt;/p>
&lt;p>&lt;strong>SMS 메시지&lt;/strong>&lt;/p>
&lt;p>트윌리오(Twilio), 넥스모(Nexmo)같은 제3 사업자의 서비스를 많이 이용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_2.png"
width="645"
height="166"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_2_hua9b34508436b686eb916dc3bc2dce64b_27617_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_2_hua9b34508436b686eb916dc3bc2dce64b_27617_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="SMS 메시지 컴포넌트"
class="gallery-image"
data-flex-grow="388"
data-flex-basis="932px"
>&lt;/p>
&lt;p>&lt;strong>이메일&lt;/strong>&lt;/p>
&lt;p>대부분 고유 이메일 서버를 구축할 역량을 가지고 있지만, 상용 이메일 서비스를 이용한다.&lt;/p>
&lt;ul>
&lt;li>센드그리드, 메일침프&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_3.png"
width="635"
height="137"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_3_hu87f4edfcf86cd64dbb4cab74e62a2243_26432_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_3_hu87f4edfcf86cd64dbb4cab74e62a2243_26432_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이메일 컴포넌트"
class="gallery-image"
data-flex-grow="463"
data-flex-basis="1112px"
>&lt;/p>
&lt;hr>
&lt;p>지금까지의 언급한 모든 알림 유형을 한 시스템으로 묶어면 아래와 같다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_4.png"
width="405"
height="767"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_4_hu994f53c88cb3013bc3a97423d78ab8b7_76258_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_4_hu994f53c88cb3013bc3a97423d78ab8b7_76258_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="최종"
class="gallery-image"
data-flex-grow="52"
data-flex-basis="126px"
>&lt;/p>
&lt;h3 id="연락처-정보-수집-절차">연락처 정보 수집 절차&lt;/h3>
&lt;p>알림을 보내기 위해 &lt;strong>모바일 단말 토큰&lt;/strong>, &lt;strong>전화번호&lt;/strong>, &lt;strong>이메일 주소&lt;/strong> 등 정보가 필요하다.&lt;/p>
&lt;p>사용자가 앱을 설치하거나 처음으로 계정을 등록할 때 API 서버는 해당 사용자의 정보를 수집하여 데이터베이스에 저장한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_5.png"
width="834"
height="202"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_5_huad049bab1460305989d0ac3f2e4bbf4b_85105_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_5_huad049bab1460305989d0ac3f2e4bbf4b_85105_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="연락처 정보 수집 절차"
class="gallery-image"
data-flex-grow="412"
data-flex-basis="990px"
>&lt;/p>
&lt;p>필수적인 정보만 포함한 스키마는 아래와 같다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
USER {
bigint user_id
varchar email
integer coutry_code
integer phone_number
timestamp created_at
}
DEVICE {
bigint id
varchar device_token
bigint user_id
timestamp last_logged_in_at
}
&lt;/pre>
&lt;ul>
&lt;li>이메일 주소와 전화번호는 &lt;code>USER&lt;/code> 테이블에 저장하고, 단말 토큰은 &lt;code>DEVICE&lt;/code> 테이블에 저장한다.&lt;/li>
&lt;li>한 사용자가 여러 단말을 가질 수 있다.&lt;/li>
&lt;li>알림은 모든 단말에 전송되어야 한다.&lt;/li>
&lt;/ul>
&lt;h3 id="알림-전송-및-수신-절차">알림 전송 및 수신 절차&lt;/h3>
&lt;p>개략적으로 설계하고 점차적으로 최적화한다.&lt;/p>
&lt;p>&lt;strong>개략적 설계안(초안)&lt;/strong>&lt;/p>
&lt;p>서버를 1대만 사용하는 시스템이라 가정한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_6.png"
width="836"
height="624"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_6_hu79685c192455f85017d1b07942a95c3d_90148_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_6_hu79685c192455f85017d1b07942a95c3d_90148_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안(초안)"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="321px"
>&lt;/p>
&lt;ul>
&lt;li>Service 1 ~ N
&lt;ul>
&lt;li>마이크로서비스, 크론잡, 분산 시스템 컴포넌트 일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 시스템
&lt;ul>
&lt;li>알림 전송/수신 처리의 핵심&lt;/li>
&lt;li>Service 1 ~ N에 알림 전송을 위한 *&lt;em>API 제공&lt;/em>&lt;/li>
&lt;li>제3자 서비스에 전달할 &lt;strong>알림 페이로드 생성&lt;/strong>&lt;/li>
&lt;li>확장성을 유의해야함, 쉽게 새로운 서비스를 통합하거나 기존 서비스를 제거할 수 있어야함&lt;/li>
&lt;li>어떤 서비스는 다른 시장에서는 사용할 수 없을 수도 있다. (FCM은 중국서 사용불가)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단말&lt;/li>
&lt;/ul>
&lt;p>위와 같은 설계에는 몇 가지 문제가 있다.&lt;/p>
&lt;ul>
&lt;li>SPOF
&lt;ul>
&lt;li>알림 서비스에 서버가 하나 뿐이라 서버 장애 발생시 전체 서비스 장애로 이어진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규모 확장성
&lt;ul>
&lt;li>한 대 서비스로 푸시 알림에 관계된 모든 것을 처리하므로, 데이터베이스나 캐시 등 중요 컴포넌트의 규모를 개별적으로 늘릴 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>성능 병목
&lt;ul>
&lt;li>알림을 처리하고 보내는 것은 자원을 많이 필요로할 수 있어, 트래픽이 몰리면 과부하 상태에 빠질 수 있다.
&lt;ul>
&lt;li>HTML 페이지 생성&lt;/li>
&lt;li>제3자 서비스의 응답 대기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>개략적 설계안(개선)&lt;/strong>&lt;/p>
&lt;p>최초 개략적 설계안에서 다음과 같은 문제를 개선했다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>데이터베이스&lt;/strong>와 &lt;strong>캐시&lt;/strong>를 알림 시스템에서 분리&lt;/li>
&lt;li>&lt;strong>알림 서버 증설&lt;/strong> 및 &lt;strong>자동 수평 규모 확장&lt;/strong> 추가&lt;/li>
&lt;li>&lt;strong>메시지 큐&lt;/strong>를 이용해 시스템 컴포넌트 사이의 강한 결합을 끊는다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_7.png"
width="788"
height="495"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_7_huc5bb10796dc5d83e13d2174837213014_204960_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_7_huc5bb10796dc5d83e13d2174837213014_204960_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안(개선)"
class="gallery-image"
data-flex-grow="159"
data-flex-basis="382px"
>&lt;/p>
&lt;ul>
&lt;li>서비스(1~N)
&lt;ul>
&lt;li>알림 시스템 서버의 API를 통해 알림을 보낼 서비스들&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 서버
&lt;ul>
&lt;li>알림 전송 API
&lt;ul>
&lt;li>스팸 방지를 위해 사내 서비스 또는 인증된 클라이언트만 이용 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 검증
&lt;ul>
&lt;li>이메일, 전화번호 등 기본적 검증 수행&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터베이스 또는 캐시 질의
&lt;ul>
&lt;li>알림에 포함시킬 데이터를 가져온다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 전송
&lt;ul>
&lt;li>알림 데이터를 메시지 큐에 넣는다.&lt;/li>
&lt;li>하나 이상의 메시지 큐를 이용하면 병렬적으로 처리할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>캐시
&lt;ul>
&lt;li>사용자 정보, 단말 정보, 알림 템플릿 등을 캐시한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DB
&lt;ul>
&lt;li>사용자, 알림, 설정 등 다양한 정보 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 큐
&lt;ul>
&lt;li>시스템 컴포넌트 간 의존성을 제거한다.&lt;/li>
&lt;li>다량의 알림이 전송되어야 하는 경우 버퍼 역할도 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작업 서버
&lt;ul>
&lt;li>메시지 큐에서 전송할 알림을 꺼내 제3자 서비스로 전달한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="안정성">안정성&lt;/h3>
&lt;p>분산 환경에서 운영될 알림 시스템을 설계할 때는 안정성을 확보하기 위한 사앙 몇 가지를 반드시 고려해야한다.&lt;/p>
&lt;p>&lt;strong>데이터 손실 방지&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_8.png"
width="544"
height="319"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_8_hucbd178a7d97384a0a3abf8183f284e96_66785_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_8_hucbd178a7d97384a0a3abf8183f284e96_66785_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 손실 방지"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="409px"
>&lt;/p>
&lt;p>알림 전송 시스템의 가장 중요한 요구사항 가운데 하나는 &lt;strong>어떤 상황에서도 알림이 소실되면 안된다&lt;/strong>는 것이다.&lt;/p>
&lt;ul>
&lt;li>지연되거나 순서가 달라도 사라지면 안된다&lt;/li>
&lt;/ul>
&lt;p>이를 위해 알림 데이터를 데이터베이스에 보관하고 재시도하는 메커니즘을 구현해야 한다.&lt;/p>
&lt;p>&lt;strong>알림 중복 전송 방지&lt;/strong>&lt;/p>
&lt;p>같은 알림이 여러 번 반복되는 것을 완전히 막는 것은 불가능하다.&lt;/p>
&lt;p>그 빈도를 줄이기 위해 중복을 탐지하는 매커니즘을 도입하고, 오류를 신중하게 처리해아한다.&lt;/p>
&lt;ul>
&lt;li>보내야 할 알림이 도착하면 그 이벤트 ID를 검사하여 이전에 본 적이 있는 이벤트인지 살핀다.&lt;/li>
&lt;li>중복된 이벤트면 버리고, 그렇지 않으면 알림을 발송한다.&lt;/li>
&lt;/ul>
&lt;h3 id="추가로-필요한-컴포넌트-및-고려사항">추가로 필요한 컴포넌트 및 고려사항&lt;/h3>
&lt;p>&lt;strong>알림 템플릿&lt;/strong>&lt;/p>
&lt;p>알림 메시지 대부분은 형식이 비슷하다.&lt;/p>
&lt;p>알림 템플릿은 이런 유사성을 고려하여, 알림 메시지의 모든 부분을 처음부터 다시 만들 필요 없도록 한다.&lt;/p>
&lt;ul>
&lt;li>사전에 지정한 형식에 맞춰 알람을 만들어 내는 틀이다.&lt;/li>
&lt;li>전송될 알림들의 형식을 일관성 있게 유지할 수 있다.&lt;/li>
&lt;li>오류 가능성뿐 아니라 알림 작성에 드는 시간도 줄일 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>알림 설정&lt;/strong>&lt;/p>
&lt;p>사용자가 알림 설정을 상세히 조정할 수 있도록 한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
OPT {
bigint user_id
varchar channel
boolean opt_in
}
&lt;/pre>
&lt;p>이와 같은 설정을 도입했다면 알람을 보내기 전 반드시 해당 사용자가 알림을 켜 두었는지 확인해야한다.&lt;/p>
&lt;p>&lt;strong>전송률 제한&lt;/strong>&lt;/p>
&lt;p>한 사용자가 받을 수 있는 알림의 빈도를 제한하여 사용자에게 많은 알림을 보내지 않도록 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>알림을 너무 많이 보내기 시작하면 사용자가 알림 기능을 꺼버릴 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>재시도 방법&lt;/strong>&lt;/p>
&lt;p>써드 파티 서비스가 알림 전송에 실패하면, 해당 알림을 재시도 전용 큐에 넣고 같은 문제가 계속해서 발생하면 개발자에게 통지한다.&lt;/p>
&lt;p>&lt;strong>푸시 알림과 보안&lt;/strong>&lt;/p>
&lt;p>IOS와 안드로이드 앱의 경우, 알림 전송 API는 appKey와 appSecret을 사용하여 보안을 유지한다.&lt;/p>
&lt;p>이러한 방식으로 인증된 혹은 승인된 클라이언트만 해당 API를 사용할 수 있다.&lt;/p>
&lt;p>&lt;strong>큐 모니터링&lt;/strong>&lt;/p>
&lt;p>큐에 쌓인 알림의 개수를 보고 작업 서버들의 처리량을 쉽게 모니터링 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>너무 크면 이벤트를 빠르게 처리하지 못하고있다는 뜻&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>이벤트 추적&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_9.png"
width="769"
height="409"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_9_hud2dbc79b7de8b0aa132399e5d3082a08_62119_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_9_hud2dbc79b7de8b0aa132399e5d3082a08_62119_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이벤트 추적"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="451px"
>&lt;/p>
&lt;p>알림 확인율, 클릭율, 실제 앱 사용으로 이어지는 비율 같은 메트릭은 사용자를 이해하는데 중요하다.&lt;/p>
&lt;p>보통 알림 시스템을 만들면 데이터 분석 서비스와도 통합하는 경우가 많다.&lt;/p>
&lt;p>&lt;strong>수정된 설계안&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/10/img_10.png"
width="841"
height="514"
srcset="https://codemario318.github.io/post/system-design-interview/10/img_10_huf8cbea8348c39c7ce30b64e29ad9daf9_149286_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/10/img_10_huf8cbea8348c39c7ce30b64e29ad9daf9_149286_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="수정된 설계안"
class="gallery-image"
data-flex-grow="163"
data-flex-basis="392px"
>&lt;/p>
&lt;p>이전 설계안과의 차이점은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>알림 서버에 인증과 전송률 제한 기능이 추가&lt;/li>
&lt;li>전송 실패에 대응하기 위한 재시도 기능 추가
&lt;ul>
&lt;li>다시 큐에 넣고 지정된 횟수만큼 재시도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>전송 템플릿을 사용하여 알림 생성 과정을 단순화하고 알림 내용의 일관성을 유지&lt;/li>
&lt;li>모니터링과 추적 시스템 추가&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>규모 확장이 쉬울 뿐 아니라 푸시 알림, SMS 메시지, 이메일 등 다양한 정보 전달 방식을 지원하는 알림 시스템을 구축했다.&lt;/p>
&lt;p>시스템 컴포넌트 사이의 결함도를 낮추기 위해 메시지 큐를 적극적으로 사용하였다.&lt;/p>
&lt;ul>
&lt;li>안정성
&lt;ul>
&lt;li>메시지 전송 실패율을 낮추기 위해 안정적인 재시도 메커니즘을 도입&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>보안
&lt;ul>
&lt;li>인징된 클라이언트만이 알림을 보낼 수 있도록 보안 매커니즘 추가(appKey, appSecret)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이벤트 추적 및 모니터링&lt;/li>
&lt;li>사용자 설정
&lt;ul>
&lt;li>사용자가 알림 수신 설정을 조정할 수 있도록 함&lt;/li>
&lt;li>알람을 보내기 전 해당 설정을 확인하도록 스스템 설계를 변경&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>전송률 제한
&lt;ul>
&lt;li>사용자에게 알림을 보내는 빈도를 제한할 수 있도록 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>9. 웹 크롤러 설계</title><link>https://codemario318.github.io/post/system-design-interview/9/</link><pubDate>Tue, 18 Jun 2024 13:54:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/9/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/cover.png" alt="Featured image of post 9. 웹 크롤러 설계" />&lt;h2 id="웹-크롤러">웹 크롤러?&lt;/h2>
&lt;p>웹 크롤러는 로봇(Robot) 또는 스파이더(Spider)라고도 부르는 검색 엔진에서 널리 쓰는 기술로, &lt;strong>웹에 새로 올라오거나 갱신된 콘텐츠를 찾아내는 것이 주된 목적&lt;/strong>이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img.png"
width="690"
height="746"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_hu8939a220c98e9690727ad8216a0decb0_158151_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_hu8939a220c98e9690727ad8216a0decb0_158151_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="웹 크롤링 동작 예시"
class="gallery-image"
data-flex-grow="92"
data-flex-basis="221px"
>&lt;/p>
&lt;p>몇 개 웹 페이지에서 시작하여 그 링크를 따라 나가면서 새로운 콘텐츠를 수집한다.&lt;/p>
&lt;ul>
&lt;li>검색 엔진 인덱싱(Search engine indexing)
&lt;ul>
&lt;li>가장 보편적인 용례로 웹 페이지를 모아 검색 엔진을 위한 로컬 인덱스를 만든다.&lt;/li>
&lt;li>Googlebot&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 아카이빙(Web Archiving)
&lt;ul>
&lt;li>장기보관을 목적으로 웹에서 정보를 모으는 절차를 말한다.&lt;/li>
&lt;li>국립 도서관 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 마이닝(Web mining)
&lt;ul>
&lt;li>인터넷에서 유용한 지식을 도출해 낼 수 있다.&lt;/li>
&lt;li>금융 기업들의 기업 분석용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 모니터링(Web monitoring)
&lt;ul>
&lt;li>인터넷에서 저작권이나 상표권이 침해되는 사례를 모니터링 할 수 있다.&lt;/li>
&lt;li>디지마크(Digimarc)사는 크롤러를 통해 해적판 저작물을 찾아내 보고한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>웹 크롤러의 복잡도는 웹 크롤러가 처리해야 하는 데이터의 규모에 따라 달라지므로 설계할 웹 크롤러가 감당해야 하는 데이터의 규모와 기능들을 알아내야한다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>웹 크롤러의 기본 알고리즘은 간단하다.&lt;/p>
&lt;ol>
&lt;li>URL 집합이 입력으로 주어지면, 해당 URL들이 가르키는 모든 웹 페이지를 다운로드한다.&lt;/li>
&lt;li>다운받은 웹 페이지에서 URL들을 추출한다.&lt;/li>
&lt;li>추출된 URL들을 다운로드할 URL 목록에 추가하고 위 과정을 처음부터 반복한다.&lt;/li>
&lt;/ol>
&lt;p>하지만 엄청난 규모 확장성을 갖는 웹 크롤러를 설계하는 것은 매우 어려운 작업이다.&lt;/p>
&lt;p>질문을 던져 요구사항을 알아내고 설계 범위를 좁힌다.&lt;/p>
&lt;ul>
&lt;li>Q. 주된 용도는?
&lt;ul>
&lt;li>A. 검색 엔진 인덱싱&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 매달 수집해야하는 웹 페이지 수
&lt;ul>
&lt;li>A. 약 10억개&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 새로 만들어진 웹 페이지나 수정된 웹 페이지도 고려해야하는가?
&lt;ul>
&lt;li>A. 예&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 수집한 웹 페이지는 저장해야하는가?
&lt;ul>
&lt;li>A. 5년간 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 중복된 콘텐츠는?
&lt;ul>
&lt;li>A. 무시해도 괜찮음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>질문을 통해 알아낸 요구사항을 명확히 하면서도 좋은 웹 크롤러가 만족시켜야 할 다음과 같은 속성에 주의를 기울여야한다.&lt;/p>
&lt;ul>
&lt;li>규모 확장성
&lt;ul>
&lt;li>웹은 수십억 개의 페이지가 존재하는 것으로 알려진 만큼 매우 거대하므로, &lt;strong>병행성(Parallelism)을 활용&lt;/strong>하면 보다 효과적으로 웹 크롤링을 수행할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>안정성(Robustness)
&lt;ul>
&lt;li>비정상적인 입력이나 황경에 잘 대응할 수 있어야 한다.&lt;/li>
&lt;li>잘못 작성된 HTML, 반응 없는 서버, 장애, 악성 코드가 붙어있는 링크 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예절(Politeness)
&lt;ul>
&lt;li>짧은 시간 동안 너무 많은 요청을 보내어 서버에 무리를 주면 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장성(Extensibility)
&lt;ul>
&lt;li>새로운 형태의 콘텐츠를 지원하기 쉬워야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;ul>
&lt;li>매달 10억 개의 웹 페이지 다운로드
&lt;ul>
&lt;li>&lt;code>QPS = 10억 / 30일 / 24시간 / 3600초 = 약 400페이지/s&lt;/code>&lt;/li>
&lt;li>&lt;code>최대(peak) QPS = 2 x QPS = 800&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 페이지의 평균 크기는 500k로 가정
&lt;ul>
&lt;li>&lt;code>10억 페이지 * 500k = 500TB/월&lt;/code>&lt;/li>
&lt;li>&lt;code>1개월치 = 500TB * 12개월 * 5년 = 30PB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="개략적인-설계안-제시-및-동의-구하기">개략적인 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_1.png"
width="845"
height="607"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_1_huc28c39ee12ec2f7699c2ff04ca5e2694_53266_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_1_huc28c39ee12ec2f7699c2ff04ca5e2694_53266_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="크롤러의 작업 흐름"
class="gallery-image"
data-flex-grow="139"
data-flex-basis="334px"
>&lt;/p>
&lt;p>&lt;strong>시작 URL 집합&lt;/strong>&lt;/p>
&lt;p>시작 URL 집합은 &lt;strong>웹 크롤러가 크롤링을 시작하는 출발점&lt;/strong>이다.&lt;/p>
&lt;p>전체 웹을 크롤링해야 하는 경우 시작 URL을 고를 때 가능한 한 많은 링크를 탐색할 수 있도록 하는 URL을 고르는 것이 바람직하다.&lt;/p>
&lt;ul>
&lt;li>일반적으로 전체 URL 공간을 작은 부분집합으로 나누는 전략을 사용
&lt;ul>
&lt;li>지역적인 특색, 즉 지역별로 인기 있는 웹 사이트가 다르다는 점에 착안&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>주제별로 다른 시작 URL을 사용
&lt;ul>
&lt;li>쇼핑, 스포츠, 건강 등의 주제별로 세분화하고 그 각각에 다른 시작 URL 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>시작 URL로 무엇을 쓸 것이냐는 질문에 정담은 없으므로 의도가 무엇인지만 정확히 전달해도 충분하다.&lt;/p>
&lt;p>&lt;strong>미수집 URL 저장소&lt;/strong>&lt;/p>
&lt;p>대부분의 현대적 웹 크롤러는 크롤링 상태를 &lt;strong>다운로드할 URL&lt;/strong>, &lt;strong>다운로드된 URL&lt;/strong> 두 가지로 나눠 관리한다.&lt;/p>
&lt;p>다운로드할 URL을 저장 관리하는 컴포넌트를 미수집 URL 저장소(URL Frontier)라고 부른다.&lt;/p>
&lt;p>&lt;strong>HTML 다운로더&lt;/strong>&lt;/p>
&lt;p>HTML 다운로더는 &lt;strong>인터넷에서 웹 페이지를 다운로드하는 컴포넌트&lt;/strong>이다.&lt;/p>
&lt;p>다운로드할 페이지의 URL은 미수집 URL 저장소가 제공한다.&lt;/p>
&lt;p>&lt;strong>도메인 이름 변환기&lt;/strong>&lt;/p>
&lt;p>웹 페이지를 다운받으려면 URL을 IP로 변환하는 절차가 필요하므로, HTML 다운로더는 도메인 이름 변환기를 이용하여 &lt;strong>URL에 대응되는 IP 주소를 알아낸다.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>콘텐츠 파서&lt;/strong>&lt;/p>
&lt;p>웹 페이지를 다운로드하면 &lt;strong>파싱&lt;/strong>과 &lt;strong>검증&lt;/strong>절차를 거쳐야한다.&lt;/p>
&lt;p>크롤링 서버 안에 콘텐츠 파서를 구현하면 크롤링 과정이 느려지게 될 수 있으므로 독립된 컴포넌트로 만드는 것이 좋다.&lt;/p>
&lt;p>&lt;strong>중복 콘텐츠인가?&lt;/strong>&lt;/p>
&lt;p>연구 결과에 따르면, 29% 가량의 웹 페이지 콘텐츠는 중복이다.&lt;/p>
&lt;p>따라서 &lt;strong>같은 콘텐츠를 여러 번 저장&lt;/strong>하게 될 수 있으므로 중복을 해결하기 위한 자료 구조를 도입하여 &lt;strong>데이터 중복을 줄이고&lt;/strong> 데이터 처리에 소요되는 시간을 줄일 수 있다.&lt;/p>
&lt;p>두 HTML 문서를 비교하는 가장 간단한 방법은 문서를 문자열로 보고 비교하는 방법을 고려할 수 있지만, 문서의 수가 매우 많은 경우 느리고 비효율적이므로, 대부분 웹 페이지의 해시 값을 비교하여 처리한다.&lt;/p>
&lt;p>&lt;strong>콘텐츠 저장소&lt;/strong>&lt;/p>
&lt;p>&lt;strong>HTML 문서를 보관하는 시스템&lt;/strong>이다.&lt;/p>
&lt;p>저장소를 구현하는 데 쓰일 구술을 고를 때는 &lt;strong>저장할 데이터의 유형&lt;/strong>, &lt;strong>크기&lt;/strong>, &lt;strong>저장소 접근 빈도&lt;/strong>, &lt;strong>데이터의 유효 기간&lt;/strong> 등을 종합적으로 고려한다.&lt;/p>
&lt;p>본 설계안은 디스크와 메모리를 동시에 사용하는 저장소를 선택할 것이다.&lt;/p>
&lt;ul>
&lt;li>데이터 양이 너무 많으므로 대부분의 콘텐츠는 디스크에 저장한다.&lt;/li>
&lt;li>인기 있는 콘텐츠는 메모리에 두어 접근 지연시간을 줄인다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>URL 추출기&lt;/strong>&lt;/p>
&lt;p>HTML 페이지를 파싱하여 링크들을 골라내는 역할을 수행한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_2.png"
width="821"
height="430"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_2_hu04f4fd4b9507be952f6ff4565090f5b3_203231_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_2_hu04f4fd4b9507be952f6ff4565090f5b3_203231_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="링크 추출 사례"
class="gallery-image"
data-flex-grow="190"
data-flex-basis="458px"
>&lt;/p>
&lt;ul>
&lt;li>상대 경로를 모두 절대 경로로 변환한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>URL 필터&lt;/strong>&lt;/p>
&lt;p>특정 URL을 크롤링 대상에서 배제한다.&lt;/p>
&lt;ul>
&lt;li>특정한 콘텐츠 타입이나 파일 확장자를 갖는 URL&lt;/li>
&lt;li>접속 시 오류가 발생하는 URL&lt;/li>
&lt;li>접근 제외 목록(deny list)에 포함된 URL 등&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>이미 방문한 URL?&lt;/strong>&lt;/p>
&lt;p>이미 방문한 URL이나 미수집 URL 저장소에 보관된 URL을 추적할 수 있도록 하는 자료 구조를 활용하여 구현한다.&lt;/p>
&lt;ul>
&lt;li>URL 방문 여부를 추적하여 같은 URL을 여러번 처리하는 일을 방지할 수 있다.&lt;/li>
&lt;li>서버 부하를 줄이고 무한 루프에 빠지는 일을 방지할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>해시 테이블이나 블룸 필터가 널리 쓰인다.&lt;/p>
&lt;p>&lt;strong>URL 저장소&lt;/strong>&lt;/p>
&lt;p>이미 방문한 URL을 보관하는 저장소다.&lt;/p>
&lt;h3 id="웹-크롤러-작업-흐름">웹 크롤러 작업 흐름&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_3.png"
width="840"
height="592"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_3_hufd385b60137cff9b9db1e88901bb7b7d_62024_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_3_hufd385b60137cff9b9db1e88901bb7b7d_62024_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="웹 크롤러 작업 흐름"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="340px"
>&lt;/p>
&lt;ol>
&lt;li>시작 URL들을 미수집 URL 저장소에 저장&lt;/li>
&lt;li>HTML 다운로더는 미수집 URL 저장소에서 URL 목록을 가져옴&lt;/li>
&lt;li>HTML 다운로더는 도메인 이름 변환기를 사용하여 URL의 IP 주소를 알아내고, 웹 페이지를 다운로드&lt;/li>
&lt;li>콘텐츠 파서는 다운된 HTML 페이지를 파싱하여 올바른 형식을 갖춘 페이지인지 검증&lt;/li>
&lt;li>콘텐츠 파싱과 검증이 끝나면 중복 콘텐츠인지 확인 절차 시작&lt;/li>
&lt;li>해당 페이지가 이미 저장소에 있는지 확인
&lt;ul>
&lt;li>이미 저장소에 있는 경우 처리하지 않고 버린다.&lt;/li>
&lt;li>저장소에 없는 콘텐츠인 경우 저장소에 저장한 뒤 URL 추출기로 전달&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>URL 추출기는 해당 HTML 페이지에서 링크를 추출함&lt;/li>
&lt;li>추출한 링크를 URL 필터로 전달&lt;/li>
&lt;li>필터링이 끝나고 남은 URL만 중복 URL 판별 단계로 전달&lt;/li>
&lt;li>URL 저장소에 보관된 URL인지 살피고 이미 있는 URL은 버린다.&lt;/li>
&lt;li>저장소에 없는 URL은 URL 저장소에 저장하고, 미수집 URL 저장소에 전달&lt;/li>
&lt;/ol>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>가장 중요한 컴포넌트와 그 구현 기술을 심도있게 살펴본다.&lt;/p>
&lt;h3 id="dfs-vs-bfs">DFS vs BFS&lt;/h3>
&lt;p>웹은 유향 그래프(directed graph)와 같으며, 크롤링 프로세스는 이 유향 그래프를 탐색하는 과정이다.&lt;/p>
&lt;p>그래프 탐색에 널리 사용되는 알고리즘은 DFS, BFS 두 가지 알고리즘인데 그래프의 크기가 얼마나 클지 가늠할 수 없으므로 BFS를 주로 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_4.png"
width="745"
height="599"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_4_hua510aa57a9e56ad00992b50a10e4d6b2_76959_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_4_hua510aa57a9e56ad00992b50a10e4d6b2_76959_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="BFS"
class="gallery-image"
data-flex-grow="124"
data-flex-basis="298px"
>&lt;/p>
&lt;p>&lt;strong>BFS의 문제점&lt;/strong>&lt;/p>
&lt;p>BFS는 FIFO 큐에 탐색할 URL를 추가하는 방식인데, 이러한 구현법에는 두 가지 문제점이 있다.&lt;/p>
&lt;ul>
&lt;li>한 페이지에서 나오는 링크의 상당수는 같은 서버로 되돌아간다.
&lt;ul>
&lt;li>같은 호스트에 속한 많은 링크를 다운받게 되는데, 병렬로 처리하게 된다면 수집 대상 서버는 수많은 요청으로 과부하에 걸린다.&lt;/li>
&lt;li>예의 없는 크롤러로 간주&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>URL에 우선순위를 두지 않는다.
&lt;ul>
&lt;li>모든 웹 페이지가 같은 수준의 품질, 중요성을 갖지는 않는다.&lt;/li>
&lt;li>페이지 순위, 트래픽의 양, 업데이트 빈도 등 여러가지 척도에 따라 우선순위를 구별하는 것이 좋을 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="미수집-url-저장소">미수집 URL 저장소&lt;/h3>
&lt;p>미수집 저장소를 잘 구현하면 예의를 갖춘 크롤러, URL 사이의 우선순위와 신선도를 구별하는 크롤러를 구현할 수 있다.&lt;/p>
&lt;p>&lt;strong>예의&lt;/strong>&lt;/p>
&lt;p>웹 크롤러는 &lt;strong>수집 대상 서버로 짧은 시간 안에 너무 많은 요청을 보내는 것을 삼가&lt;/strong>야 한다.&lt;/p>
&lt;ul>
&lt;li>동일 웹 사이트에 대해서는 한 번에 한 페이지만 요청한다.
&lt;ul>
&lt;li>같은 웹 사이트의 페이지를 다운받는 태스크는 시간차를 두고 실행한다.&lt;/li>
&lt;li>호스트명과 다운로드를 수행하는 작업 스레드 사이의 관계를 유지한다.&lt;/li>
&lt;li>각 다운로드 스레드는 별도의 큐를 통해 해당 큐에서 꺼낸 URL만 다운로드한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_5.png"
width="694"
height="684"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_5_hu9b21d490c5125653d38c7ab94cc56cb6_123801_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_5_hu9b21d490c5125653d38c7ab94cc56cb6_123801_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="예의 있는 크롤러 설계 예시"
class="gallery-image"
data-flex-grow="101"
data-flex-basis="243px"
>&lt;/p>
&lt;ul>
&lt;li>큐 라우터
&lt;ul>
&lt;li>같은 호스트에 속한 URL은 언제나 같은 큐로 가도록 보장한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>매핑 테이블
&lt;ul>
&lt;li>호스트 이름과 큐 사이의 관계를 보관한다.&lt;/li>
&lt;li>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>호스트&lt;/th>
&lt;th>큐&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>wikipedia.com&lt;/td>
&lt;td>b1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>apple.com&lt;/td>
&lt;td>b2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&lt;/td>
&lt;td>&amp;hellip;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>nike.com&lt;/td>
&lt;td>bn&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>FIFO 큐
&lt;ul>
&lt;li>같은 호스트에 속한 URL은 언제나 같은 큐에 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>큐 선택기
&lt;ul>
&lt;li>큐들을 순회하면서 큐에서 URL을 꺼내어 해당 큐에서 나온 URL을 다운로드하도록 지정된 작업 스레드에 전달한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작업 스레드
&lt;ul>
&lt;li>전달된 URL을 다운로드한다.&lt;/li>
&lt;li>순차적으로 처리되며, 작업 사이에 일정한 지연시간을 둘 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>우선순위&lt;/strong>&lt;/p>
&lt;p>유용성에 따라 URL의 우선순위를 나눌 때는 페이지랭크(PageRank), 트래픽 양, 갱신 빈도(Update Frequency) 등 다양한 척도를 사용할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_6.png"
width="679"
height="682"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_6_hu2b81a326b445fb63ed389467d8b1a40b_64739_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_6_hu2b81a326b445fb63ed389467d8b1a40b_64739_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="우선순위를 고려하는 크롤러 설계 예시"
class="gallery-image"
data-flex-grow="99"
data-flex-basis="238px"
>&lt;/p>
&lt;ul>
&lt;li>순위결정장치
&lt;ul>
&lt;li>URL을 입력으로 받아 우선순위를 계산한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>큐
&lt;ul>
&lt;li>우선순위별로 큐가 하나씩 할당된다.&lt;/li>
&lt;li>우선순위가 높으면 선택될 확률도 올라간다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>큐 선택기
&lt;ul>
&lt;li>임의 큐에서 처리할 URL을 꺼낸다.&lt;/li>
&lt;li>순위가 높은 큐에서 더 자주 꺼낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>전체 설계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_7.png"
width="624"
height="1120"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_7_hua7682a46c4831907399b700105278b58_160845_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_7_hua7682a46c4831907399b700105278b58_160845_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="전체 설계"
class="gallery-image"
data-flex-grow="55"
data-flex-basis="133px"
>&lt;/p>
&lt;ul>
&lt;li>전면 큐(front queue)
&lt;ul>
&lt;li>우선순위 결과 과정을 처리한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>후면 큐(back queue)
&lt;ul>
&lt;li>크롤러가 예의 바르게 동작하도록 보증한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>신선도&lt;/strong>&lt;/p>
&lt;p>웹 페이지는 수시로 추가되고, 삭제되고, 변경되므로 &lt;strong>데이터의 신선함을 유지하기 위해 이미 다운로드한 페이지라고 해도 주기적으로 재수집&lt;/strong>할 필요가 있다.&lt;/p>
&lt;p>모든 URL을 재수집하는 것은 많은 시간과 자원이 필요한 작업이므로, 이 작업을 최적화하기 위한 전략으로 다음과 같은 것들이 있다.&lt;/p>
&lt;ul>
&lt;li>웹 페이지의 변경 이력 활용&lt;/li>
&lt;li>우선순위를 활용하여, 중요한 페이지는 좀 더 자주 재수집&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>미수집 URL 저장소를 위한 지속성 저장장치&lt;/strong>&lt;/p>
&lt;p>검색엔진을 위한 크롤러는 처리해야하는 URL이 수억 개에 달한다.&lt;/p>
&lt;p>따라서 모두 메모리에 보관하는 것은 안정성이나 규모 확장성 측면에서 바람직하지 않고, 전부 디스크에 저장하는 것도 성능 병목으로 인해 적절치 않다.&lt;/p>
&lt;p>따라서 절충안을 택하여, &lt;strong>대부분의 URL은 디스크에 두고 IO 비용을 줄이기 위해 메모리 버퍼에 큐를 두는 것&lt;/strong>을 고려한다.&lt;/p>
&lt;p>버퍼에 있는 데이터는 주기적으로 디스크에 기록된다.&lt;/p>
&lt;h3 id="html-다운로더">HTML 다운로더&lt;/h3>
&lt;p>HTML 다운로더는 HTTP 프로토콜을 통해 웹 페이지를 내려받는다.&lt;/p>
&lt;p>&lt;strong>Robots.txt&lt;/strong>&lt;/p>
&lt;p>로봇 제외 프로토콜이라고도 부르는 Robots.txt는 웹사이트가 크롤러와 소통하는 표준적 방법이다.&lt;/p>
&lt;p>Robots.txt 파일에는 크롤러가 수집해되 되는 페이지 목록이 들어있다.&lt;/p>
&lt;p>따라서 웹 사이트를 크롤링 하기 전 해당 파일에 나열된 규칙을 먼저 확인해야 한다.&lt;/p>
&lt;p>Robots.txt 파일을 거푸 다운로드하는 것을 피하기 위해, 이 파일은 주기적으로 다운받아 캐시에 보관한다.&lt;/p>
&lt;p>&lt;strong>성능 최적화&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>분산 크롤링&lt;/p>
&lt;ul>
&lt;li>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_8.png"
width="610"
height="495"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_8_hu4704f60e777f14cba6bfd4009fcd3078_47203_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_8_hu4704f60e777f14cba6bfd4009fcd3078_47203_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="분산 크롤링 예시"
class="gallery-image"
data-flex-grow="123"
data-flex-basis="295px"
>&lt;/li>
&lt;li>성능을 높이기 위해 크롤링 작업을 여러 서버에 분산하는 방법이다.&lt;/li>
&lt;li>각 서버는 여러 스레드를 돌려 다운로드 작업을 처리한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>도메인 이름 변호나 결과 캐시&lt;/p>
&lt;ul>
&lt;li>도메인 이름 변환기는 DNS 요청을 보내고 결과를 받는 작업의 동기적 틍성으로 인해 크롤러 성능의 변목 중 하나이다.&lt;/li>
&lt;li>DNS 조회 결과로 얻어진 도메인 이름과 IP 주소 사이의 관계를 캐시에 보관해 놓고 크론 잡 등을 돌려 주기적으로 갱신하도록 해놓으면 성능을 효과적으로 높힐 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>지역성&lt;/p>
&lt;ul>
&lt;li>크롤링 작업을 수행하는 서버를 지역별로 분산하는 방법이다.&lt;/li>
&lt;li>크롤링 서버가 대상 서버와 지역적으로 가까우면 페이지 다운로드 시간을 줄일 수 있다.&lt;/li>
&lt;li>이러한 전략은 크롤 서버, 캐시, 큐, 저장소 등 대부분의 컴포넌트에 적용 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>짧은 타임아웃&lt;/p>
&lt;ul>
&lt;li>응답이 느리거나 하지 않는 서버에 대한 요청은 대기시간이 길어지므로, 최대 얼마나 기다릴지를 미리 정해 다운로드를 빨리 중단하여 다음 차례로 넘어간다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>안정성&lt;/strong>&lt;/p>
&lt;p>시스템 안정성을 향상하기 위한 접근법 가운데 중요한 몇가지는 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>안정 해시
&lt;ul>
&lt;li>다운로더 서버들에 부하를 분산할 때 적용 가능&lt;/li>
&lt;li>다운로더 서버를 쉽게 추가하고 삭제할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>크롤링 상태 및 수집 데이터 저장
&lt;ul>
&lt;li>장애가 발생한 경우에도 쉽게 복구할 수 있도록 크롤링 상태와 수집된 데이터를 지속적 저장장치에 기록해 두는 것이 바람직하다.&lt;/li>
&lt;li>크롤링을 쉽게 재시작할 수 있을 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예외 처리
&lt;ul>
&lt;li>대규모 시스템에서 에러는 불가피할 뿐 아니라 흔하게 벌어진다.&lt;/li>
&lt;li>전체 시스템이 중단되는 일 없이 그 작업을 우아하게 이어나갈 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 검증
&lt;ul>
&lt;li>시스템 오류를 방지하기 위한 종요 수간 가운데 하나이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>확정성&lt;/strong>&lt;/p>
&lt;p>새로운 형태의 콘텐츠를 쉽게 지원할 수 있도록 신경 써야 한다.&lt;/p>
&lt;p>새로운 모듈을 끼워 넣음으로써 새로운 형태의 콘텐츠를 지원할 수 있도록 설계할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/9/img_9.png"
width="844"
height="555"
srcset="https://codemario318.github.io/post/system-design-interview/9/img_9_hu6bd6fe39d4fb6e162d1d6c362b2e20a7_81130_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/9/img_9_hu6bd6fe39d4fb6e162d1d6c362b2e20a7_81130_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="확장 모듈 반영 설계"
class="gallery-image"
data-flex-grow="152"
data-flex-basis="364px"
>&lt;/p>
&lt;ul>
&lt;li>PNG 다운로더
&lt;ul>
&lt;li>PNG 파일을 다운로드하는 플러그인 모듈&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 모니터
&lt;ul>
&lt;li>웹을 모니터링하여 저작권이나 상표권이 침해되는 일을 막는 모듈&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>문제 있는 콘텐츠 감지 및 회피&lt;/strong>&lt;/p>
&lt;p>중복이거나 의미 없는, 또는 유해한 콘텐츠를 감지하고 차단해야한다.&lt;/p>
&lt;ul>
&lt;li>중복 콘텐츠
&lt;ul>
&lt;li>해시나 체크섬을 사용하면 중복 콘텐츠를 쉽게 탐지할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>거미 덫
&lt;ul>
&lt;li>크롤러를 무한 루프에 빠드리도록 설계한 웹 페이지다.
&lt;ul>
&lt;li>&lt;code>www.spidertrapexample.com/foo/bar/foo/bar/foo/bar/...&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>만능 해결책은 없지만 몇가지 방법이 있다.
&lt;ul>
&lt;li>URL 최대 길이를 제한&lt;/li>
&lt;li>수작업으로 덫을 확인하고 착아낸 후 탐색 대상에서 제외하거나 필터 목록에 추가한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 노이즈
&lt;ul>
&lt;li>가치가 없는 콘텐츠는 제외한다.&lt;/li>
&lt;li>광고, 스크립트 코드, 스팸 URL 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>좋은 크롤러는 &lt;strong>규모 확정성&lt;/strong>, &lt;strong>예의&lt;/strong>, &lt;strong>확장성&lt;/strong>, &lt;strong>안정성&lt;/strong> 등을 고려해야한다.&lt;/p>
&lt;p>웹이 방대하고, 수없이 많은 덫이 도사리고 있기 때문에 규모 확장성이 뛰어난 웹 크롤러 설계는 단순하지 않다.&lt;/p>
&lt;ul>
&lt;li>서버 측 렌더링
&lt;ul>
&lt;li>비동기를 통해 동적으로 생성되는 링크는 페이지를 파싱하기 전에 서버 측 렌더링을 적용하면 해결할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>윈치 않는 페이지 필터링
&lt;ul>
&lt;li>스팸 방지 컴포넌트를 두어 품질이 조악하거나 스팸성인 페이지를 걸러내도록 하면 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터베이스 다중화 및 샤딩
&lt;ul>
&lt;li>다중화나 샤딩 같은 기법을 적용하면 데이터 계층의 가용성, 규모 확장성, 안정성이 향상된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>수평적 규모 확장성
&lt;ul>
&lt;li>대규모 크롤링을 위해 다운로스 서버가 수천 대 필요하게 될 수 있으므로, 수평적 규모 확장을 위해 무상태 서버로 만드는 것이 중요하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성, 일관성, 안정성
&lt;ul>
&lt;li>대형 시스템을 만들기 위해 필수적으로 고려해야한다. (1장 복습)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 분석 솔루션
&lt;ul>
&lt;li>데이터르 수집하고 분석하는 것은 어느 시스템에게나 중요하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>8. URL 단축기 설계</title><link>https://codemario318.github.io/post/system-design-interview/8/</link><pubDate>Tue, 04 Jun 2024 15:18:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/8/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/cover.png" alt="Featured image of post 8. URL 단축기 설계" />&lt;h2 id="1단계-문제-이해-및-설게-범위-확정">1단계: 문제 이해 및 설게 범위 확정&lt;/h2>
&lt;ul>
&lt;li>Q. URL 단축기 동작 예시
&lt;ul>
&lt;li>A. &lt;code>https://tinyurl.com/y7ke-ocwj&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 트래픽 규모는?
&lt;ul>
&lt;li>A. 매일 1억개의 단축 URL 생성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 단축 URL의 길이는?
&lt;ul>
&lt;li>A. 짧을수록 좋음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 단축 URL에 포함될 문자제한은?
&lt;ul>
&lt;li>A. 숫자(0~9), 영문자(A~z) 사용 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 단축된 URL을 지우거나 갱신 가능?
&lt;ul>
&lt;li>A. 시스템 단순화를 위해 삭제나 갱신은 할 수 없다 가정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 시스템의 기본적 기능은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>URL 단축
&lt;ul>
&lt;li>주어진 긴 URL을 훨씬 짧게 줄인다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>URL 리디렉션(redirection)
&lt;ul>
&lt;li>축약된 URL로 HTTP 요청이 오면 원래 URL로 안내&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>높은 가용성과 규모 확장성, 장애 감내 요구됨&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-추정">개략적 추정&lt;/h3>
&lt;ul>
&lt;li>쓰기 연산: 매일 1억 개의 단축 URL 생성&lt;/li>
&lt;li>초당 쓰기 연산: &lt;code>1억 / 24 / 3600 = 1160&lt;/code>&lt;/li>
&lt;li>읽기 연산:
&lt;ul>
&lt;li>읽기 연산과 쓰기 연산의 비율은 &lt;strong>10:1&lt;/strong>로 가정&lt;/li>
&lt;li>대략 초당 11,600회 발생&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>URL 단축 서비스를 10년간 운영한다고 가정하면 &lt;code>1억 * 365 * 10 = 3650억&lt;/code>개 레코드 보관&lt;/li>
&lt;li>축약 전 URL의 평균 길이는 100
&lt;ul>
&lt;li>필요한 저장 용량은 &lt;code>3650억 * 100바이트 = 36.5TB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="api-엔드포인트">API 엔드포인트&lt;/h3>
&lt;p>클라이언트는 서버가 제공하는 API 엔드포인트를 통해 서버와 통신한다.&lt;/p>
&lt;p>RESTful API로 설계한다고 가정하면, 기본적으로 두 개의 엔드포인트를 필요로 한다.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>URL 단축용 엔드포인트&lt;/strong>
&lt;ul>
&lt;li>새 단축 URL을 생성하고자 하는 클라이언트는 이 엔드포인트에 단축할 URL을 인자로 담아 POST 요청을 보내야한다.&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">POST /api/v1/data/shorten
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>인자: &lt;code>{longUrl: longURLstring}&lt;/code>&lt;/li>
&lt;li>반환: 단축 URL&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>URL 리디렉션용 엔드포인트&lt;/strong>
&lt;ul>
&lt;li>단축 URL에 대해 HTTP 요청이 오면 원래 URL로 보내주기 위한 용도의 엔드포인트&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GET /api/v1/shortUrl
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>반환: HTTP 리디렉션 목적지가 될 원래 URL&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="url-리디렉션">URL 리디렉션&lt;/h3>
&lt;p>단축 URL을 받은 서버는 그 URL을 원래 URL로 바꾸어 &lt;strong>301 응답&lt;/strong>의 &lt;strong>Location 헤더&lt;/strong>에 넣어 반환한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/img.png"
width="362"
height="363"
srcset="https://codemario318.github.io/post/system-design-interview/8/img_hu4a278bdc249e7e3e9a78362cdb2bf14f_44204_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/8/img_hu4a278bdc249e7e3e9a78362cdb2bf14f_44204_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클라이언트와 서버 사이의 통신 절차"
class="gallery-image"
data-flex-grow="99"
data-flex-basis="239px"
>&lt;/p>
&lt;p>유의할 점은 301 응답과 302 응답의 차이로, 둘 다 리디렉션 응답이지만 차이가 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>301 Permanently Moved&lt;/code>
&lt;ul>
&lt;li>URL에 대한 HTTP 요청의 처리 책임이 &lt;strong>영구적으로 Location 헤더에 반환된 URL로 이전&lt;/strong>됨&lt;/li>
&lt;li>영구적인 이전이므로 브라우저는 이 응답을 &lt;strong>캐싱&lt;/strong>한다.&lt;/li>
&lt;li>따라서 같은 단축 URL로 재요청시 캐시된 원래 URL로 요청을 보낸다.&lt;/li>
&lt;li>서버 부하를 줄이는 것이 중요할 때 사용될 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>302 Found&lt;/code>
&lt;ul>
&lt;li>URL로의 요청이 &lt;strong>일시적으로 Location 헤더의 URL에 의해 처리&lt;/strong>되어야함&lt;/li>
&lt;li>클라이언트의 요청은 &lt;strong>캐싱되지 않으므로&lt;/strong>, 언제나 단축 URL 서버에 먼저 보내짐&lt;/li>
&lt;li>트래픽 분석 같이 클릭 발생률이나 발생 위치를 파악해야할 때 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>URL 리디렉션을 구현하는 가장 직관적인 방법은 &lt;strong>해시 테이블&lt;/strong>을 사용하는 것으로 &lt;code>&amp;lt;단축 URL: 원래 URL&amp;gt;&lt;/code> 형식으로 구현될 수 있다.&lt;/p>
&lt;h3 id="url-단축">URL 단축&lt;/h3>
&lt;p>단축 URL이 &lt;code>&amp;lt;www.tinyurl.com/{hashValue}&amp;gt;&lt;/code> 같은 형태로 만들어진다면, 긴 URL을 이 해시 값으로 대응시킬 &lt;strong>해시 함수 &lt;code>fx&lt;/code>&lt;/strong> 를 찾는 것이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/img_1.png"
width="263"
height="205"
srcset="https://codemario318.github.io/post/system-design-interview/8/img_1_hu28fdb81906c71ae40d2947e410c83904_16249_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/8/img_1_hu28fdb81906c71ae40d2947e410c83904_16249_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="해시 함수 fx"
class="gallery-image"
data-flex-grow="128"
data-flex-basis="307px"
>&lt;/p>
&lt;p>해시 함수는 다음과 같은 요구사항을 만족해야 한다.&lt;/p>
&lt;ul>
&lt;li>입력으로 주어지는 긴 URL이 다른 값이면 해시 값도 달라야한다.&lt;/li>
&lt;li>계산된 해시 값은 원래 입력으로 주어졌던 긴 URL로 복원될 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>개략적 설계에서는 모든 것을 해시 테이블에 두었지만, 이 방식은 메모리는 유한하고 비싸기 때문에 실제 시스템에서 사용되기 어렵다.&lt;/p>
&lt;p>더 나은 방식은 &lt;code>&amp;lt;단축 URL, 원래 URL&amp;gt;&lt;/code>의 순서쌍을 RDB에 저장하는 것이다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
URL {
number id pk
string shortURL
string longURL
}
&lt;/pre>
&lt;h3 id="해시-함수">해시 함수&lt;/h3>
&lt;p>해시 함수는 &lt;strong>원래 URL을 단축 URL로 변환&lt;/strong>하는 데 쓰인다.&lt;/p>
&lt;p>&lt;strong>해시 값 길이&lt;/strong>&lt;br>
hashValue는 &lt;code>[0-9, a-z, A-Z]&lt;/code>의 문자들로 구성된다.&lt;/p>
&lt;ul>
&lt;li>사용할 수 있는 문자의 개수는 &lt;code>10 + 26 + 26 = 62&lt;/code>개이다.&lt;/li>
&lt;li>hashValue의 길이를 정하기 위해서는 &lt;code>62^n &amp;gt;= 3650억&lt;/code>을 만드는 n의 최소값을 찾아야한다.
&lt;ul>
&lt;li>n = 7, 약 3.5조 개&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>해시후 충돌 해소&lt;/strong>&lt;br>
긴 URL을 줄이려면, 원래 URL을 7글자 문자열로 줄이는 해시 함수가 필요하다.&lt;/p>
&lt;p>가장 쉬운 방법은 CRC32, MD5, SHA-1 같이 잘 알려진 해시 함수를 이용하는 것이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/img_2.png"
width="403"
height="141"
srcset="https://codemario318.github.io/post/system-design-interview/8/img_2_hu130b2b42d1534b4e7248d03256cabfb1_16625_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/8/img_2_hu130b2b42d1534b4e7248d03256cabfb1_16625_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="&amp;ldquo;https://en.wikipedia.org/wiki/Systems_design&amp;#34;의 해시값"
class="gallery-image"
data-flex-grow="285"
data-flex-basis="685px"
>&lt;/p>
&lt;p>잘 알려진 해시 함수를 사용한 결과가 계산한 가장 짧은 해시값조차도 7보다는 길이가 긴데, 이 문제를 해결하기 위한 첫 번째 방법으로 처음 7개 문자만 사용하는 방법을 고려할 수 있다.&lt;/p>
&lt;ul>
&lt;li>해시 결과가 충돌할 확률이 높아진다.&lt;/li>
&lt;li>충돌이 발생한 경우, 충돌이 해소될 때까지 사전에 정한 문자열을 해시값에 덧붙인다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/img_3.png"
width="527"
height="318"
srcset="https://codemario318.github.io/post/system-design-interview/8/img_3_hub0df4858afff8df13008d5e526aeee01_35083_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/8/img_3_hub0df4858afff8df13008d5e526aeee01_35083_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="해시 후 충돌 해소"
class="gallery-image"
data-flex-grow="165"
data-flex-basis="397px"
>&lt;/p>
&lt;ul>
&lt;li>단축 URL을 생성할 때 한 번 이상 데이터베이스 질의를 해야 하므로 오버헤드가 크다.&lt;/li>
&lt;li>데이터베이스 대신 블룸 필터를 사용하면 성능을 높일 수 있다.
&lt;ul>
&lt;li>어떤 집합에 특정 원소가 있는 지 검사할 수 있도록 하는, 확률론에 기초한 공간 효율이 좋은 기술&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>base-62 변환&lt;/strong>&lt;br>
진법 변환(base conversion)은 URL 단축기를 구현할 때 흔히 사용되는 접근법이다.&lt;/p>
&lt;ul>
&lt;li>수의 표현 방식이 다른 두 시스템이 같은 수를 공유하여야 하는 경우 유용하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/img_4.png"
width="460"
height="209"
srcset="https://codemario318.github.io/post/system-design-interview/8/img_4_hua0543d5a53f0486c3860430ba71667b3_17218_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/8/img_4_hua0543d5a53f0486c3860430ba71667b3_17218_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="62 진법 변환"
class="gallery-image"
data-flex-grow="220"
data-flex-basis="528px"
>&lt;/p>
&lt;p>&lt;strong>두 접근법 비교&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>해시 후 충돌 해소&lt;/th>
&lt;th>62 진법 변환&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>단축 URL 길이가 고정됨&lt;/td>
&lt;td>단축 URL 길이가 가변적, ID 값이 커지면 길어짐&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>유일성이 보장되는 ID 생성기가 필요하지 않음&lt;/td>
&lt;td>유일성 보장 ID 생성기 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>충돌이 해소 전략 필요&lt;/td>
&lt;td>ID 유일성이 보장되어야 적용 가능한 전략이라 충돌 불가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ID로 부터 단축 URL을 계산하는 방식이 아니므로 다음에 쓸 수 있는 URL을 알아내는 것이 불가능&lt;/td>
&lt;td>ID가 1씩 증가하는 값이라고 가정하면 다음에 쓸 수 있는 단축 URL이 무엇인지 쉽게 알아낼 수 있어 보안상 문제 소지가 될 수 있음&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="url-단축기-상세-설계">URL 단축기 상세 설계&lt;/h3>
&lt;p>URL 단축기는 시스템의 핵심 컴포넌트이므로, 그 처리흐름이 논리적으로는 단순해야 하고, 기능적으로는 언제나 동작하는 상태로 유지되어야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/img_5.png"
width="463"
height="348"
srcset="https://codemario318.github.io/post/system-design-interview/8/img_5_hud414c15ad06fec3825b6f1e5e69c33f5_33072_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/8/img_5_hud414c15ad06fec3825b6f1e5e69c33f5_33072_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="URL 단축 처리 흐름"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="319px"
>&lt;/p>
&lt;p>해당 ID 생성기의 주된 용도는, 단축 URL을 만들 때 사용할 ID를 만드는 것이고, 이 &lt;strong>ID는 전역적 유일성이 보장&lt;/strong>되는 것 이어야 한다.&lt;/p>
&lt;p>고도로 분산된 환경에서 이런 생성기를 만드는 것은 무척 어려운 일로 필요하다면 &lt;strong>7장 내용을 응용하여 분산 환경에 사용될 유일한 ID를 만들 수 있다&lt;/strong>.&lt;/p>
&lt;h3 id="url-리디렉션-상세-설계">URL 리디렉션 상세 설계&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/8/img_6.png"
width="526"
height="167"
srcset="https://codemario318.github.io/post/system-design-interview/8/img_6_hu33c2d1982d9952264698b9ef2bfc0ff5_38702_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/8/img_6_hu33c2d1982d9952264698b9ef2bfc0ff5_38702_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="URL 리디렉션 상세 설계"
class="gallery-image"
data-flex-grow="314"
data-flex-basis="755px"
>&lt;/p>
&lt;p>쓰기보다 읽기를 더 자주하는 시스템의 특성에 맞추어, &lt;code>&amp;lt;단축 URL, 원래 URL&amp;gt;&lt;/code>의 쌍을 &lt;strong>캐싱&lt;/strong>하여 성능을 높힐 수 있다.&lt;/p>
&lt;h2 id="마무리">마무리&lt;/h2>
&lt;p>설계를 마친 후 시간이 좀 남는다면 다음과 같은 것을 면접관과 이야기 할 수 있을것이다.&lt;/p>
&lt;ul>
&lt;li>처리율 제한 장치
&lt;ul>
&lt;li>엄청난 양은 단축 요청이 들어올 경우 무력화될 수 있다는 잠재적 보안 결함을 갖고 있다.&lt;/li>
&lt;li>처리율 제한 장치를 통해 요청을 걸러낼 수 있다. 4장 참조&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹 서버의 규모 확장
&lt;ul>
&lt;li>설계에 포함된 웹 계층은 무상태 계층이므로, 웹 서버를 자유롭게 증설, 삭제 할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터베이스 규모 확장
&lt;ul>
&lt;li>데이터베이스를 다중화하거나 샤딩하여 규모 확장성을 달성할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 분석 솔루션
&lt;ul>
&lt;li>URL 단축기에 데이터 분석 솔루션을 통합해 두면 어떤 링크를 얼마나 많은 사용자가 클릭했는지, 언제 주로 클릭했는지 등 중요한 정보를 알아낼 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성, 데이터 일관성, 안정성
&lt;ul>
&lt;li>1장 참조&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>7. 분산 시스템을 위한 유일 ID 생성기 설계</title><link>https://codemario318.github.io/post/system-design-interview/7/</link><pubDate>Tue, 04 Jun 2024 14:26:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/7/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/7/cover.png" alt="Featured image of post 7. 분산 시스템을 위한 유일 ID 생성기 설계" />&lt;p>서비스의 규모가 작을때는 &lt;code>auto_increment&lt;/code> 속성이 설정된 관계형 데이터 베이스의 기본키를 사용하는 방법을 고려할 수 있지만, &lt;strong>분산 환경&lt;/strong>에서는 이러한 방법을 사용할 수 없다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스 서버(master) 한 대로는 요구를 감당할 수 없다.&lt;/li>
&lt;li>여러 데이터베이스 서버를 쓰는 경우 지연 시간을 낮추기 매우 힘들다.&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-설정">1단계: 문제 이해 및 설계 범위 설정&lt;/h2>
&lt;ul>
&lt;li>Q. ID는 어떤 특성을 낮는가?
&lt;ul>
&lt;li>A. ID는 &lt;strong>유일&lt;/strong>해야 하고, &lt;strong>정렬 가능&lt;/strong>해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 새로운 레코드에 붙일 ID는 항상 1만큼 큰 값이어야 하는가?
&lt;ul>
&lt;li>A. &lt;strong>시간에 따라 커지지만&lt;/strong>, 언제나 &lt;strong>1씩 증가하지는 않아도 괜찮다&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. &lt;strong>ID는 숫자로만&lt;/strong> 구성되는가?
&lt;ul>
&lt;li>A. 예&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 시스템의 규모는 어느 정도 인가?
&lt;ul>
&lt;li>A. &lt;strong>초당 10,000 ID 생성&lt;/strong> 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위 질의응답을 통해 요구 사항을 정리하면 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>ID는 &lt;strong>유일&lt;/strong>해야함&lt;/li>
&lt;li>ID는 &lt;strong>숫자로만&lt;/strong> 구성되어야 함.&lt;/li>
&lt;li>ID는 &lt;strong>64비트로 표현&lt;/strong>될 수 있는 값이어야 한다.&lt;/li>
&lt;li>ID는 발급 날짜에 따라 &lt;strong>정렬 가능&lt;/strong>해야 한다.&lt;/li>
&lt;li>&lt;strong>초당 10,000개&lt;/strong>의 ID를 만들 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>분산 시스템에서 유일성이 보장되는 ID를 만드는 방법은 여러 가지다.&lt;/p>
&lt;h3 id="다중-마스터-복제">다중 마스터 복제&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/7/img.png"
width="405"
height="203"
srcset="https://codemario318.github.io/post/system-design-interview/7/img_hu9014d3795a5b6c4cab16daba760b0bfa_48519_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/7/img_hu9014d3795a5b6c4cab16daba760b0bfa_48519_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="다중 마스터 복제 구조"
class="gallery-image"
data-flex-grow="199"
data-flex-basis="478px"
>&lt;/p>
&lt;p>이 접근법은 데이터베이스의 &lt;strong>&lt;code>auto_increment&lt;/code>&lt;/strong> 기능을 활용한다.&lt;/p>
&lt;ul>
&lt;li>다음 ID의 값을 구할 때 1만큼 증가시켜 얻는 것이 아니라, &lt;strong>k만큼 증가&lt;/strong>시킨다.
&lt;ul>
&lt;li>&lt;strong>&lt;code>k = 현재 사용중인 데이터베이스 서버 대수&lt;/code>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 방식을 통해 규모 확장성 문제를 어느정도 해결할 수 있지만, 중대한 단점이 있다.&lt;/p>
&lt;ul>
&lt;li>여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.&lt;/li>
&lt;li>ID의 유일성을 보장되지만, 그 값이 시간 흐름에 맞추어 커지도록 보장할 수 없다.
&lt;ul>
&lt;li>더 많은 ID를 생성한 데이터베이스의 ID가 덜 생성한 데이터베이스의 ID보다 늦게 생성되었어도 큰 값을 가질 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다.&lt;/li>
&lt;/ul>
&lt;h3 id="uuid">UUID&lt;/h3>
&lt;p>UUID는 유일성이 보장되는 ID를 만드는 또 하나의 간단한 방법이다.&lt;/p>
&lt;ul>
&lt;li>컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수&lt;/li>
&lt;li>충돌 가능성이 지극히 낮다.
&lt;ul>
&lt;li>중복 UUID가 1개 생길 확률을 50%로 끌어 올리려면 초당 10억 개의 UUID를 100년동안 계속해서 만들어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>09c93e62-50b4-468d-bf8a-c07e1040bfb2&lt;/code> 와 같은 형태를 띈다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/7/img_1.png"
width="523"
height="136"
srcset="https://codemario318.github.io/post/system-design-interview/7/img_1_hu6256ca36668288eeedaf0076978f50bb_33014_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/7/img_1_hu6256ca36668288eeedaf0076978f50bb_33014_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="UUID를 사용하는 시스템의 구조"
class="gallery-image"
data-flex-grow="384"
data-flex-basis="922px"
>&lt;/p>
&lt;p>이러한 특성으로 UUID는 서버 간 조율 없이 독립적으로 생성 가능하므로, 각 서버가 별도의 ID 생성기를 사용해 독립적으로 ID를 만들어낸다.&lt;/p>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>UUID를 만드는 것은 단순하다.&lt;/li>
&lt;li>서버 사이의 조율이 필요 없으므로 동기화 이슈도 없다.&lt;/li>
&lt;li>각 서버가 자기가 쓸 ID를 알아서 만드는 구조이므로 규모 확장도 쉽다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>ID가 128비트로 길다.
&lt;ul>
&lt;li>요구사항은 64비트&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ID를 시간순으로 정렬할 수 없다.
&lt;ul>
&lt;li>임의의 중복이 힘든 문자열로 생성됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ID에 숫자가 아닌 값이 포함될 수 있다.
&lt;ul>
&lt;li>요구사항은 숫자로만 구성되어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="티켓-서버">티켓 서버&lt;/h3>
&lt;p>티켓 서버는 &lt;code>auto_increment&lt;/code> 기능을 낮춘 데이터베이스 서버, 즉 티켓 서버를 중앙 집중형으로 하나만 사용하는 방식으로 유일성이 보장되는 ID를 만든다.&lt;/p>
&lt;ul>
&lt;li>플리커(Flickr)는 분산 기본 키(Distributed primary key)를 만들어 내기 위해 이 기술을 이용&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/7/img_2.png"
width="514"
height="192"
srcset="https://codemario318.github.io/post/system-design-interview/7/img_2_hu35af303bc81c90e1e9d062a2cc6f0084_34398_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/7/img_2_hu35af303bc81c90e1e9d062a2cc6f0084_34398_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="티켓 서버 동작 방식"
class="gallery-image"
data-flex-grow="267"
data-flex-basis="642px"
>&lt;/p>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.&lt;/li>
&lt;li>구현하기 쉽고, 중소 구모 애플리케이션에 적합하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>티켓 서버가 SPOF가 된다.
&lt;ul>
&lt;li>티켓 서버에 장애가 발생하면 해당 서버를 이용하는 모든 시스템이 영향을 받는다.&lt;/li>
&lt;li>티켓 서버를 여러 대 준비한다면 데이터 동기화 같은 새로운 문제가 발생한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="트위터-스노플레이크-접근법">트위터 스노플레이크 접근법&lt;/h3>
&lt;p>스노플레이크 접근법은 생성해야하는 ID를 여러 절로 분할하여 독립적인 ID를 만든다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/7/img_3.png"
width="517"
height="65"
srcset="https://codemario318.github.io/post/system-design-interview/7/img_3_hu359222468aa455e79718e3251ca7189d_7642_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/7/img_3_hu359222468aa455e79718e3251ca7189d_7642_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="생성해야 하는 ID 구조"
class="gallery-image"
data-flex-grow="795"
data-flex-basis="1908px"
>&lt;/p>
&lt;ul>
&lt;li>사인(sign) 비트: 항상 0으로 설정되어 양수로 유지한다.
&lt;ul>
&lt;li>특별한 의미는 없는듯&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>타임스탬프(timestamp): 기원 시간 이후로 몇 밀리초가 경과했는지를 나타내는 값
&lt;ul>
&lt;li>41비트로 약 69년 동안의 시간을 표현할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터센터 ID: 데이터센터 ID
&lt;ul>
&lt;li>5비트로 32개 데이터 센터를 구분할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서버 ID: 서버 ID
&lt;ul>
&lt;li>5비트로 32개의 서버 구분 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>일련번호: 각 서버에서 ID를 생성할 때마다 일련번호를 1만큼 증가시킴
&lt;ul>
&lt;li>1밀리초가 경과될 때마다 0으로 초기화됨(TS가 1ms 간격으로 증가하므로)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>트위터 스노플레이크 접근법을 사용하여 보다 상세한 설계를 진행한다.&lt;/p>
&lt;ul>
&lt;li>데이터센터 ID와 서버 ID는 시스템이 시작될 때 결정되며, 일반적으로 시스템 운영중에는 바뀌지 않는다.
&lt;ul>
&lt;li>데이터센터 ID, 서버 ID를 잘못 변경하게 되면 충돌이 발생할 수 있으므로, 신중하게 해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>타임 스탬프나 일련번호는 ID 생성기가 돌고 있는 중에 만들어진다.&lt;/li>
&lt;/ul>
&lt;h3 id="타임스탬프">타임스탬프&lt;/h3>
&lt;p>타임스탬프는 시간이 흐름에 따라 점점 큰 값을 갖게 되므로, 결국 ID는 시간 순으로 정렬 가능하게 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/7/img_4.png"
width="511"
height="404"
srcset="https://codemario318.github.io/post/system-design-interview/7/img_4_hue8e03313e3458bff2af6b82679f89a78_43392_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/7/img_4_hue8e03313e3458bff2af6b82679f89a78_43392_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="타임스탬프를 이용한 UTC 추출"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="303px"
>&lt;/p>
&lt;p>41비트로 표현할 수 있는 타임스탬프 최대값은 &lt;code>2^41 - 1 = 2,199,023,255,551&lt;/code> 밀리초 이므로 대략 69년 표현할 수 있다.&lt;/p>
&lt;p>따라서 이 ID 생성기는 69년동안만 정상 동작하므로 &lt;strong>69년이 지나면 기원 시각을 바꾸거나 ID 체계를 다른 것으로 이전&lt;/strong>(migration)하여햐한다.&lt;/p>
&lt;h3 id="일련번호">일련번호&lt;/h3>
&lt;p>일련번호는 12비트이므로,&lt;code>2^12 - 1 = 4096&lt;/code>개의 값을 가질 수 있다.&lt;/p>
&lt;p>어떤 서버가 &lt;strong>같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값&lt;/strong>을 갖게 된다.&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;ul>
&lt;li>시계 동기화(Clock synchronization)
&lt;ul>
&lt;li>기존 설계는 하나의 서버가 여러 코어에서 실행될 경우 유효하지 않을 수 있다.&lt;/li>
&lt;li>물리적으로 독립된 여러 장비에서 실행되는 경우 유효하지 않을 수 있다.&lt;/li>
&lt;li>NTP(Network Time Protocol)은 이 문제를 해결하는 가장 보편적인 수단이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 절(Section)의 길이 최적화
&lt;ul>
&lt;li>동시성이 낮고 수명이 긴 애플리케이션이라면 일련번호 절의 길이를 줄이고 타임스탬프 절의 길이를 늘리는 것이 효과적일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>고가용성
&lt;ul>
&lt;li>ID 생성기는 필수 불가결(mission critical) 컴포넌트이므로 아주 높은 가용성을 제공해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>6. 키-값 저장소 설계</title><link>https://codemario318.github.io/post/system-design-interview/6/</link><pubDate>Mon, 27 May 2024 11:59:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/6/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/cover.png" alt="Featured image of post 6. 키-값 저장소 설계" />&lt;p>키-값 저장소(key-value store)는 키-값 데이터베이스라고도 불리는 비 관계형(non-relational) 데이터베이스이다.&lt;/p>
&lt;ul>
&lt;li>이 저장소에 저장되는 값은 &lt;strong>고유 식별자&lt;/strong>를 키로 가져야한다.&lt;/li>
&lt;li>키와 값 사이의 이런 연결 관계를 &lt;strong>키-값 쌍&lt;/strong>(key-value pair)이라고 지칭한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>키&lt;/strong>&lt;br>
키-값 쌍에서의 키는 &lt;strong>유일&lt;/strong>해야 하며 해당 키에 매달린 값은 &lt;strong>키를 통해서만 접근&lt;/strong>할 수 있다.&lt;/p>
&lt;p>키는 일반 텍스트일 수도 있고 해시 값일 수도 있지만, 성능상의 이유로 짧을수록 좋다.&lt;/p>
&lt;ul>
&lt;li>일반 텍스트 키: &amp;ldquo;last_logged_in_at&amp;rdquo;&lt;/li>
&lt;li>해시 키: 253DDEC4&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>값&lt;/strong>&lt;br>
키-값 저장소는 보통 &lt;strong>값으로 무엇이 오든 상관하지 않는다&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>문자열, 리스트, 객체 등&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>키-값 저장소로 널리 알려진 것은 아마존 다이나모, memcached, 레디스 같은 것들이 있다.&lt;/p>
&lt;p>또한 기본적으로 아래와 같은 연산을 지원해야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>put(key, value)&lt;/code>: 키-값 쌍을 저장소에 저장한다.&lt;/li>
&lt;li>&lt;code>get(key)&lt;/code>: 인자로 주어진 키에 매달린 값을 꺼낸다.&lt;/li>
&lt;/ul>
&lt;h2 id="문제-이해-및-설계-범위-확정">문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>완벽한 설계란 없다.&lt;/p>
&lt;p>읽기, 쓰기 그리고 메모리 사용량 사이에 어떤 균형을 찾고, 데이터의 일관성과 가용성 사이에서 타협적 결정을 내린 설계를 만들었다면 충분히 쓸만한 답이다.&lt;/p>
&lt;p>이번 장에서는 다음 특성을 갖는 키-값 저장소를 설계해본다.&lt;/p>
&lt;ul>
&lt;li>키-값 쌍의 크기는 10KB 이하이다.&lt;/li>
&lt;li>큰 데이터를 저장할 수 있어야 한다.&lt;/li>
&lt;li>높은 가용성을 제공해야한다.
&lt;ul>
&lt;li>시스템은 장애가 있더라도 빨리 응답해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>높은 규모 확장성을 제공해야 한다.
&lt;ul>
&lt;li>트래픽 양에 따라 자동적으로 서버 증설/삭제가 이루어져야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 일관성 수준은 조정이 가능해야 한다.&lt;/li>
&lt;li>응답 지연시간(latency)이 짧아야 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="단일-서버-키-값-저장소">단일 서버 키-값 저장소&lt;/h2>
&lt;p>한 대 서버만 사용하는 키-값 저장소는 설계가 쉽다.&lt;/p>
&lt;p>가장 직관적인 방법은 키-값 쌍 전부를 메모리에 해시 테이블로 저장하는 것이다.&lt;/p>
&lt;p>이 방법은 빠른 속도를 보장하지만 &lt;strong>모든 데이터를 메모리안에 두는 것이 불가능&lt;/strong>할 수도 있다.&lt;/p>
&lt;p>이 문제의 개선책은 다음과 같은 것들이 있다.&lt;/p>
&lt;ul>
&lt;li>데이터 압축&lt;/li>
&lt;li>자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장&lt;/li>
&lt;/ul>
&lt;p>이렇게 개선한다고 해도, 한 대 서버로 부족한 때가 찾아오며, 많은 데이터를 저장하기 위해서 &lt;strong>분산 키-값 저장소&lt;/strong>를 만들어야한다.&lt;/p>
&lt;h2 id="분산-키-값-저장소">분산 키 값 저장소&lt;/h2>
&lt;p>분산 키 값 저장소는 키-값 쌍을 여러 서버에 분산시키므로 &lt;strong>분산 해시 테이블&lt;/strong>이라고도 불린다.&lt;/p>
&lt;p>분산 시스템을 설계할 때는 &lt;strong>CAP 정리&lt;/strong>(Consistency, Availability, Partition Tolerance theorem)를 이해하고 있어야 한다.&lt;/p>
&lt;h3 id="cap-정리">CAP 정리&lt;/h3>
&lt;p>CAP 정리는 &lt;strong>데이터 일관성(consistency), 가용성(availability), 파티션 감내(partition tolerance)라는 세가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다&lt;/strong>는 정리이다.&lt;/p>
&lt;ul>
&lt;li>데이터 일관성
&lt;ul>
&lt;li>분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성
&lt;ul>
&lt;li>분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파티션 감내
&lt;ul>
&lt;li>파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다.&lt;/li>
&lt;li>네트워크에 파티션(분할)이 생기더라도 시스템은 계속 동작하여야 한다는 것을 뜻한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>네트워크 파티션?&lt;/strong>&lt;br>
테이터베이스 시스템의 일부 노드들이 서로 통신할 수 없는 상황으로 인해 각 노드들(파티션)이 독립적으로 동작하게 되어 각 파티션이 서로 다른 상태나 데이터를 가지게 되는 상황&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img.png"
width="828"
height="608"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_hu8399b985eaaab4d8c3cc5e2bfd3651de_149592_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_hu8399b985eaaab4d8c3cc5e2bfd3651de_149592_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="326px"
>&lt;/p>
&lt;p>따라서 이들 가운데 &lt;strong>어떤 두 가지를 충족하려면 나머지 하나는 반드시 희생되어야 한다&lt;/strong>는 것을 의미한다.&lt;/p>
&lt;p>키 값 저장소는 세 가지 요구사항 가운데 어느 두 가지를 만족하느냐에 따라 다음과 같이 분류할 수 있다.&lt;/p>
&lt;ul>
&lt;li>CP: 일관성과 파티션 감내를 지원(가용성 희생)&lt;/li>
&lt;li>AP: 가용성과 파티션 감내를 지원(데이터 일관성 희생)&lt;/li>
&lt;li>CA: 일관성과 가용성을 지원(파티션 감내 지원 안함)
&lt;ul>
&lt;li>통상 네트워크 장애는 피할 수 없는 일로 여겨지므로, 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야 한다.&lt;/li>
&lt;li>실세계에서 CA 시스템은 존재하지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="구체적-사례">구체적 사례&lt;/h3>
&lt;p>분산 시스템에서 데이터는 보통 여러 노드에 복제되어 보관된다.&lt;/p>
&lt;h4 id="이상적-상태">이상적 상태&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_1.png"
width="840"
height="592"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_1_hua0faa9aa952f92ab7c5a2fe27ee0e7c0_91753_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_1_hua0faa9aa952f92ab7c5a2fe27ee0e7c0_91753_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="340px"
>&lt;/p>
&lt;p>이상적인 환경이라면 &lt;strong>네트워크가 파티션되는 상황은 절대로 일어나지 않을 것&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>n1&lt;/strong>에 기록된 데이터는 자동적으로 &lt;strong>n2&lt;/strong>, &lt;strong>n3&lt;/strong>에 복제되며 데이터 일관성과 가용성도 만족한다.&lt;/li>
&lt;/ul>
&lt;h4 id="실세계의-분산-시스템">실세계의 분산 시스템&lt;/h4>
&lt;p>분산 시스템은 파티션 문제를 피할 수 없다.&lt;/p>
&lt;p>파티션 문제가 발생하면 &lt;strong>일관성과 가용성 사이에서 하나를 선택&lt;/strong>해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_2.png"
width="839"
height="605"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_2_hud8043c96815985a7c6b0f4ed2ff33b87_103442_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_2_hud8043c96815985a7c6b0f4ed2ff33b87_103442_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="138"
data-flex-basis="332px"
>&lt;/p>
&lt;p>&lt;strong>n3&lt;/strong>에 장애가 발생하여 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>와 통신 할 수 없는 상황에서&lt;/p>
&lt;ul>
&lt;li>클라이언트가 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>에 기록한 데이터는 &lt;strong>n3&lt;/strong>에 전달되지 않는다.&lt;/li>
&lt;li>&lt;strong>n3&lt;/strong>에 기록되었으나 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>로 전달되지 않은 데이터가 있다면 오래된 사본을 갖고 있을 것이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>CP 시스템&lt;/strong>&lt;/p>
&lt;p>가용성 대신 일관성을 선택한다면 세 서버 사이에 생길 수 있는 데이터 불일치 문제를 피하기 위해 &lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>에 대해 &lt;strong>쓰기 연산을 중단&lt;/strong>시켜야한다.&lt;/p>
&lt;p>이러한 경우 일부 노드가 장애가 발생하여도 동작해야 한다는 가용성이 깨진다.&lt;/p>
&lt;p>데이터 일관성을 양보할 수 없는 시스템은 이렇게 처리되어 상황이 해결될 때 까지 오류를 반환해야 한다.&lt;/p>
&lt;ul>
&lt;li>온라인 뱅킹 등&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>AP 시스템&lt;/strong>&lt;/p>
&lt;p>일관성 대신 가용성을 선택한 시스템은 &lt;strong>낡은 데이터를 반환할 위험이 있더라도 계속 읽기 연산을 허용&lt;/strong>해야한다.&lt;/p>
&lt;p>&lt;strong>n1&lt;/strong>, &lt;strong>n2&lt;/strong>는 계속 쓰기 연산을 허용하고, 파티션 문제가 해결된 뒤 새 데이터를 &lt;strong>n3&lt;/strong>에 전송해야한다.&lt;/p>
&lt;hr>
&lt;p>분산 키-값 저장소를 만들 때는 그 요구사항에 맞도록 CAP 정리를 적용해야 한다.&lt;/p>
&lt;p>면접 상황에서는 이 문제에 대해 면접관과 상의하고, 그 결론에 따라 시스템을 설계하도록 하자.&lt;/p>
&lt;h3 id="시스템-컴포넌트">시스템 컴포넌트&lt;/h3>
&lt;p>키-값 저장소 구형에 사용되는 핵심 컴포넌트들 및 기술을 살펴본다.&lt;/p>
&lt;ul>
&lt;li>데이터 파티션&lt;/li>
&lt;li>데이터 다중화&lt;/li>
&lt;li>일관성&lt;/li>
&lt;li>일관성 불일치 해소&lt;/li>
&lt;li>장애 처리&lt;/li>
&lt;li>시스템 아키텍처 다이어그램&lt;/li>
&lt;li>쓰기 경로&lt;/li>
&lt;li>읽기 경로&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-파티션">데이터 파티션&lt;/h4>
&lt;p>대규모 애플리케이션의 경우 전체 데이터를 한 대 서버에 욱여넣는 것은 불가능하다.&lt;/p>
&lt;p>가장 단순한 해결책은 &lt;strong>데이터를 작은 파티션들로 분할한 다음 여러 대 서버에 저장하는 것&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>데이터를 여러 서버에 고르게 분산할 수 있는가&lt;/li>
&lt;li>노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가&lt;/li>
&lt;/ul>
&lt;p>5장에서 다룬 안정 해시는 이런 문제를 푸는 데 적합한 기술로 활용될 수 있다.&lt;/p>
&lt;p>안정 해시를 사용하여 데이터를 파티션하면 몇가지 장점이 있다.&lt;/p>
&lt;ul>
&lt;li>규모 확장 자동화(automatic scaling)
&lt;ul>
&lt;li>시스템 부하에 따라 서버가 자동으로 추가되거나 삭제되도록 만들 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다양성(heterogeneity)
&lt;ul>
&lt;li>각 서버의 용량에 맞게 가상 노드의 수를 조정할 수 있다.&lt;/li>
&lt;li>고성능 서버는 더 많은 가상노드를 갖도록&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-다중화">데이터 다중화&lt;/h4>
&lt;p>높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있다.&lt;/p>
&lt;p>어떤 키를 해시 링 위에 배치한 수, 그 지점으로부터 시계 방향으로 링을 순회하면서 만나는 첫 N개 서버에 데이터 사본을 보관한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_3.png"
width="843"
height="685"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_3_hu0675f294d26db8b4acf424a88b68b693_77163_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_3_hu0675f294d26db8b4acf424a88b68b693_77163_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="123"
data-flex-basis="295px"
>&lt;/p>
&lt;p>하지만 가상 노드를 사용한다면 선택한 N개의 노드가 대응될 실제 물리 서버의 개수가 N보다 작아질 수 있다.&lt;/p>
&lt;p>이 문제를 피하려면 노드를 선택할 때 같은 물리 서버를 중복으로 선택하지 않도록 해야한다.&lt;/p>
&lt;p>같은 데이터 센터에 속한 노드는 정전, 네트워크 이슈, 자연 재해 등의 문제를 동시에 같이 겪을 가능성이 있으므로, 안정성을 담보하기 위해 데이터의 사본은 다른 센터의 서버에 보관하고, 센터들은 고속 네트워크로 연결한다.&lt;/p>
&lt;h4 id="데이터-일관성">데이터 일관성&lt;/h4>
&lt;p>여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 한다.&lt;/p>
&lt;p>&lt;strong>정족수 합의&lt;/strong>(Quorum Consensus) 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>N&lt;/code>: 사본의 개수&lt;/li>
&lt;li>&lt;code>W&lt;/code>: 쓰기 연산에 대한 정족수
&lt;ul>
&lt;li>쓰기 연산이 성공한 것으로 간주되려면 적어도 &lt;code>W&lt;/code>개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R&lt;/code>: 읽기 연산에 대한 정족수
&lt;ul>
&lt;li>읽기 연산이 성공한 것으로 간주되려면 적어도 &lt;code>R&lt;/code>개의 서버로부터 응답을 받아야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>일반적으로 &lt;code>N = R + W &amp;gt; N&lt;/code> 조건을 만족하도록 설정하며, 읽기와 쓰기 요청이 적어도 하나의 공통 노드를 통해 일관성을 유지하도록 보장한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_4.png"
width="839"
height="579"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_4_huec6b456c1e9a98e57b711c077ef003c7_99493_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_4_huec6b456c1e9a98e57b711c077ef003c7_99493_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="N = 3"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;p>&lt;code>W = 1&lt;/code>는 쓰기 연산이 성공했다고 판단하기 위해 중재자(coordinator)는 최소 한 대 서버로부터 쓰기 성공 응답을 받아야한다는 뜻이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>s1&lt;/strong>으로 부터 성공 응답을 받았다면, 나머지 응답은 기다릴 필요가 없다.&lt;/li>
&lt;/ul>
&lt;p>중재자는 클라이언트와 노드 사이에서 프락시(proxy)역할을 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;code>W&lt;/code>, &lt;code>R&lt;/code>, &lt;code>N&lt;/code>의 값을 정하는 것은 응답 지연과 데이터 일관성 사이의 타협점을 찾는 전형정인 과정이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>W = 1&lt;/code> or &lt;code>R = 1&lt;/code>
&lt;ul>
&lt;li>중재자는 한 대 서버로부터의 응답만 받으면 되므로 응답속도는 빠르다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>W &amp;gt; 1&lt;/code> or &lt;code>R &amp;gt; 1&lt;/code>
&lt;ul>
&lt;li>데이터 일관성의 수준은 향상되지만 중재자의 응답 속도는 가장 느린 서버로부터의 응답을 기다려야 하므로 느려진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>따라서 &lt;code>W + R &amp;gt; N&lt;/code>인 경우에는 일관성을 보증할 최신 데이터를 가진 노드가 최소 하나는 겹치므로 강한 일관성이 보장된다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>R = 1&lt;/code>, &lt;code>W = N&lt;/code>
&lt;ul>
&lt;li>빠른 읽기 연산에 최적화된 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R = N&lt;/code>, &lt;code>W = 1&lt;/code>
&lt;ul>
&lt;li>빠른 쓰기 연산에 최적화된 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R + W &amp;gt; N&lt;/code>
&lt;ul>
&lt;li>강한 일관성이 보장됨
&lt;ul>
&lt;li>보통 &lt;code>N = 3&lt;/code>, &lt;code>W = R = 2&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>R + W &amp;lt;= N&lt;/code>
&lt;ul>
&lt;li>강한 일관성이 보장되지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>요구되는 일관성 수준에 따라 &lt;code>W&lt;/code>, &lt;code>R&lt;/code>, &lt;code>N&lt;/code> 값을 조정한다.&lt;/p>
&lt;p>&lt;strong>일관성 모델&lt;/strong>&lt;/p>
&lt;p>일관성 모델(consistency model)은 키-값 저장소를 설계할 때 고려해야 할 요소로 데이터 일관성 수준을 결정한다.&lt;/p>
&lt;ul>
&lt;li>강한 일관성
&lt;ul>
&lt;li>모든 읽기 연산은 최신 결과를 반환한다.&lt;/li>
&lt;li>클라이언트는 절대로 낡은 데이터를 볼 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>약한 일관성
&lt;ul>
&lt;li>읽기 연산은 최신 결과를 반환하지 못할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>결과적 일관성
&lt;ul>
&lt;li>약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영(동기화)된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>강한 일관성&lt;/strong>을 달성하는 일반적인 방법은, &lt;strong>모든 사본에 현재 쓰기 연산의 결과가 반영될 때까지 해당 데이터에 대한 읽기/쓰기를 금지&lt;/strong>하는 것이다.&lt;/p>
&lt;ul>
&lt;li>새로운 요청의 처리가 중단되므로 고 가용성 시스템에는 적합하지 않다.&lt;/li>
&lt;/ul>
&lt;p>다이나모 또는 카산드라 같은 저장소는 결과적 일관성 모델을 택하고 있다.&lt;/p>
&lt;ul>
&lt;li>결과적 일관성 모델을 따를 경우 &lt;strong>쓰기 연산이 병렬적으로 발생하면 시스템에 저장된 값의 일관성이 깨어질 수 있는데&lt;/strong>, 이 문제는 클라이언트가 해결해야한다.&lt;/li>
&lt;li>클라이언트 측에서 데이터의 버전 정보를 활용해 일관성이 깨진 데이터를 읽지 않도록 해야한다.&lt;/li>
&lt;/ul>
&lt;p>데이터를 다중화하면 가용성은 높아지지만 사본 간 일관성이 깨질 가능성은 높아진다.&lt;/p>
&lt;p>&lt;strong>비 일관성 해소 기법: 데이터 버저닝&lt;/strong>&lt;/p>
&lt;p>버저닝은 데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만든다.&lt;/p>
&lt;ul>
&lt;li>각 버전은 변경 불가능하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_5.png"
width="838"
height="387"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_5_hu314294c50ed1dac3bf6da051bfbc696c_78353_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_5_hu314294c50ed1dac3bf6da051bfbc696c_78353_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="충돌하는 두 값"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="519px"
>&lt;/p>
&lt;p>서버 1, 2가 다른 노드의 같은&lt;code>name&lt;/code>의 값을 동시에 변경하여 충돌이 발생했다고 가정했을 때 각각을 버전 &lt;strong>v1&lt;/strong>, &lt;strong>v2&lt;/strong>로 볼 수 있다.&lt;/p>
&lt;p>이러한 충돌 문제를 해결하려면, 충돌을 발견하고 자동으로 해결해 낼 버저닝 시스템이 필요하다.&lt;/p>
&lt;p>&lt;strong>백터 시계&lt;/strong>(vector clock)는 &lt;strong>&lt;code>[서버, 버전]&lt;/code>의 순서 쌍을 데이터에 매단 것&lt;/strong>으로 충돌 문제를 푸는데 보편적으로 사용된다.&lt;/p>
&lt;ul>
&lt;li>어떤 버전이 선행 버전인지, 후행 버전인지, 충돌이 있는지 판별하는 데 쓰인다.&lt;/li>
&lt;/ul>
&lt;p>데이터 D를 서버 &lt;strong>Si&lt;/strong>에 기록하려면 아래 작업 가운데 하나를 수행해야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>[Si, Vi]&lt;/code>가 있으면 &lt;code>Vi&lt;/code>를 증가시킨다.&lt;/li>
&lt;li>그렇지 않다면 새 항목 &lt;code>[Si, 1]&lt;/code>을 만든다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_6.png"
width="717"
height="798"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_6_hu4d508b5e0485ac8ed5a6f6afc4aa05b9_112910_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_6_hu4d508b5e0485ac8ed5a6f6afc4aa05b9_112910_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="백터 시계"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="215px"
>&lt;/p>
&lt;ol>
&lt;li>클라이언트가 &lt;code>D1&lt;/code>을 시스템에 기록한다.
&lt;ul>
&lt;li>처리한 서버는 &lt;code>Sx&lt;/code>이므로 백터 시계는 &lt;code>D1[Sx, 1]&lt;/code>으로 변한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다른 클라이언트가 &lt;code>D1&lt;/code>을 읽고 &lt;code>D2&lt;/code>로 업데이트한 다음 기록한다.
&lt;ul>
&lt;li>&lt;code>D2&lt;/code>는 &lt;code>D1&lt;/code>의 변경이므로 덮어쓴다.&lt;/li>
&lt;li>&lt;code>Sx&lt;/code>가 처리했으므로 벡터 시계를 &lt;code>D2[Sx, 2]&lt;/code>로 변경한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다른 클라이언트가 &lt;code>D2&lt;/code>를 읽어 &lt;code>D3&lt;/code>로 갱신한 다음 기록한다.
&lt;ul>
&lt;li>&lt;code>Sy&lt;/code>가 처리했으므로 백터 시계 상태는 &lt;code>D3([Sx, 2], [Sy, 1])&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>또 다른 클라이언트가 &lt;code>D2&lt;/code>를 읽고 &lt;code>D4&lt;/code>로 갱신한 후 기록한다.
&lt;ul>
&lt;li>&lt;code>Sz&lt;/code>가 처리했으므로 백터 시계 상태는 &lt;code>D4([Sx, 2], [Sz, 1])&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>어떤 클라이언트가 D3과 D4를 읽으면 데이터 간 충돌이 있다는 것을 알게 되므로, 클라이언트가 해소한 후 서버에 기록한다.
&lt;ul>
&lt;li>&lt;code>Sx&lt;/code>가 처리했으므로 백터 시계는 &lt;code>D5([Sx, 3], [Sy, 1], [Sz, 1])&lt;/code>로 바뀐다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>벡터 시계를 이용하면 버전 Y에 포함된 모든 구성 요소의 값이 X에 포함된 모든 구성요소 값보다 같거나 큰지만 확인하면 어떤 버전 X가 버전 Y의 이전 버전인지 쉽게 판단할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>D([s0, 1], [s1, 1])&lt;/code>은 &lt;code>D([s0, 1], [s1, 2])&lt;/code>보다 이전 버전이다.(충돌 X)&lt;/li>
&lt;/ul>
&lt;p>어떤 버전 X와 Y 사이에 충돌이 있는지 보려면 &lt;strong>Y의 벡터 시계 구성 요소 가운데 X의 벡터 시계 동일 서버 구성요소보다 작은 값을 갖는 것이 있는지 확인&lt;/strong>한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>D([s0, 1], [s1, 2])&lt;/code>, &lt;code>D([s0, 2], [s1, 1])&lt;/code>는 서로 충돌한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>벡터 시계를 통해 충돌 감지하고 해소하는 방법에는 두 가지 단점이 있다.&lt;/p>
&lt;ul>
&lt;li>충돌 감지 및 해소 로직이 클라이언트에 들어가야 하므로, 클라이언트 구현이 복잡해진다.&lt;/li>
&lt;li>&lt;code>[서버: 버전]&lt;/code>의 순서쌍 개수가 굉장히 빨리 늘어난다.
&lt;ul>
&lt;li>순서쌍 개수에 임계치를 설정하고, 임계치 이상으로 길이가 길어지면 오래된 순서쌍을 백터 시계에서 제거한다.&lt;/li>
&lt;li>버전 간 선후 관계가 정확하게 결정될 수 없으므로 충돌 해소 과정의 효율성이 낮아질 수 있다.&lt;/li>
&lt;li>실제 서비스에서 그런 문제는 거의 발생하지 않으므로, 대부분 기업에서 괜찮다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="장애-처리">장애 처리&lt;/h4>
&lt;p>대규모 시스템에서 장애는 아주 흔하게 벌어지므로 장애를 어떻게 처리할 것이냐 하는 것은 굉장히 중요한 문제이다.&lt;/p>
&lt;h4 id="장애-감지">장애 감지&lt;/h4>
&lt;p>분산 시스템에서는 서버 A에 문제가 생겼을 때 바로 장애를 처리하지 않고, 보통 두 대 이상의 서버가 똑같이 서버 A에 대해 장애를 보고해야 해당 서버에 실제로 장애가 발생했다고 간주한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_7.png"
width="838"
height="636"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_7_hu135f183e800718526af99039ce9e186b_156879_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_7_hu135f183e800718526af99039ce9e186b_156879_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="멀티캐스팅 채널 구축"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="316px"
>&lt;/p>
&lt;p>모든 노드 사이에 멀티캐스팅 채널을 구축하는 것이 서버 장애를 감지하는 손쉬운 방법이나, 이 방법은 서버가 많을 때 비효율적이다.&lt;/p>
&lt;p>따라서 &lt;strong>가십 프로토콜&lt;/strong>(gossip protocol) 같은 분산형 장애 감지 솔루션을 채택하는 편이 보다 효율적이다.&lt;/p>
&lt;ul>
&lt;li>각 노드는 맴버십 목록을 유지한다.
&lt;ul>
&lt;li>맴버십 목록: 각 맴버 ID와 그 박동 카운터(heartbeat counter) 쌍의 목록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 노드는 주기적으로 자신의 박동 카운터를 증가시킨다.&lt;/li>
&lt;li>각 노드는 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터 목록을 보낸다.&lt;/li>
&lt;li>박동 카운터 목록을 받은 노드는 맴버십 목록을 최신 값으로 갱신한다.&lt;/li>
&lt;li>어떤 맴버의 박동 카운터 값이 지정된 시간 동안 갱신되지 않으면 해당 멤버는 장애 상태인 것으로 간주한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_8.png"
width="839"
height="382"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_8_hu90da88e3e0d0b1a6937865c76380943d_88593_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_8_hu90da88e3e0d0b1a6937865c76380943d_88593_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="가십 프로토콜"
class="gallery-image"
data-flex-grow="219"
data-flex-basis="527px"
>&lt;/p>
&lt;h4 id="일시적-장애-처리">일시적 장애 처리&lt;/h4>
&lt;p>장애를 감지한 시스템은 가용성을 보장하기 위해 필요한 조치를 해야한다.&lt;/p>
&lt;ul>
&lt;li>엄격한 정족수 접근법은 읽기와 쓰기 연산을 금지한다.&lt;/li>
&lt;li>느슨한 정족수 접근법은 쓰기 연산을 수행할 W개의 건강한 서버와 읽기 연산을 수행할 R개의 건강한 서버를 해시 링에서 고른다.(장애 서버는 무시)&lt;/li>
&lt;li>장애 상태인 서버로 가는 요청은 다른 서버가 잠시 맡아 처리한다.&lt;/li>
&lt;li>그동안 발생한 변경 사항은 장애 서버가 복구 되었을 때 일괄 반영하여 데이터 일관성을 보존한다.
&lt;ul>
&lt;li>임시로 쓰기 연산을 처리한 서버에는 그에 관한 단서를 남겨둔다.&lt;/li>
&lt;li>단서 후 임시 위탁(hinted handoff)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_9.png"
width="834"
height="718"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_9_hu115bfa1d5fe40c44de379ba88e53d6c2_127770_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_9_hu115bfa1d5fe40c44de379ba88e53d6c2_127770_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="116"
data-flex-basis="278px"
>&lt;/p>
&lt;p>장애 상태인 s2에 대한 읽기 및 쓰기 연산은 일시적으로 s3가 처리하며, s2가 복구되면 s3는 갱신된 데이터를 s2로 인계한다.&lt;/p>
&lt;h4 id="영구-장애-처리">영구 장애 처리&lt;/h4>
&lt;p>영구적인 노드의 장애 상태는 반-엔트로피(anti-entropy) 프로토콜을 구현하여 사본들을 동기화한다.&lt;/p>
&lt;p>반-엔트로피 프로토콜은 &lt;strong>사본들을 비교하여 최신 버전으로 갱신하는 과정을 포함&lt;/strong>한다.&lt;/p>
&lt;p>사본 간의 일관성이 망가진 상태를 탐지하고 전송 데이터의 양을 줄이기 위해서 머클(Merkle) 트리를 사용한다.&lt;/p>
&lt;blockquote>
&lt;p>머클 트리?&lt;br>
해시 트리라고 불리는 머클 트리는 각 노드에 그 자식 노드들의 보관된 값의 해시(자식 노드가 leaf인 경우) 또는 자식 노드들의 레이블로부터 계산된 해시 값을 레이블로 붙여두는 트리&lt;/p>
&lt;/blockquote>
&lt;p>해시 트리를 사용하면 &lt;strong>대규모 자료 구조의 내용을 효과적이면서도 보안상 안전한 방법으로 검증&lt;/strong>할 수 있다.&lt;/p>
&lt;p>&lt;strong>1 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_10.png"
width="844"
height="330"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_10_hu458e95c99f7dfcfac03b6157ee8c6e5b_44753_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_10_hu458e95c99f7dfcfac03b6157ee8c6e5b_44753_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="255"
data-flex-basis="613px"
>&lt;/p>
&lt;p>키 공간을 버킷으로 나눈다.&lt;/p>
&lt;p>&lt;strong>2 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_11.png"
width="842"
height="182"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_11_hu5646976f70d14d2033d017e53694f064_41493_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_11_hu5646976f70d14d2033d017e53694f064_41493_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="462"
data-flex-basis="1110px"
>&lt;/p>
&lt;p>버킷에 포함된 각각의 키에 균등 분포 해시 함수를 적용하여 해시 값을 계산한다.&lt;/p>
&lt;p>&lt;strong>3 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_12.png"
width="839"
height="260"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_12_hu38a58b95ad281add1c37ca9db00d3b58_73545_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_12_hu38a58b95ad281add1c37ca9db00d3b58_73545_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="322"
data-flex-basis="774px"
>&lt;/p>
&lt;p>버킷 별로 해시값을 계산한 후, 해당 해시 값을 레이블로 갖는 노드를 만든다.&lt;/p>
&lt;p>&lt;strong>4 단계&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_13.png"
width="840"
height="445"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_13_hu8894cdbe47f2eb2880a4148ac1861de4_101648_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_13_hu8894cdbe47f2eb2880a4148ac1861de4_101648_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;p>자식 노드의 레이블로부터 새로운 해시값을 계산하여, 이진 트리를 상향식으로 구성해 나간다.&lt;/p>
&lt;hr>
&lt;p>두 머클 트리의 비교는 루트 노드의 해시값을 비교하는 것으로 시작하며, 다른 데이터를 갖는 버킷을 찾을 경우 그 버킷들만 동기화한다.&lt;/p>
&lt;p>머클 트리를 사용하면 동기화해야 하는 데이터 양은 실제로 존재하는 차이의 크기에 비례할 뿐, 두 서버에 보관된 데이터의 총량과는 무관해진다.&lt;/p>
&lt;ul>
&lt;li>실제로 쓰이는 시스템의 경우 버킷 하나의 크기가 꽤 크다.&lt;/li>
&lt;li>10억(1B) 개의 키를 백만(1M) 개의 버킷으로 관리하면, 하나의 버킷은 1,000개 키를 관리한다.&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-센터-장애-처리">데이터 센터 장애 처리&lt;/h4>
&lt;p>데이터 센터 장애는 정전, 네트워크 장애, 자연재해 등 다양한 이유로 발생할 수 있다.&lt;/p>
&lt;p>데이터 센터의 장애에 대응할 수 있는 시스템을 만드려면 데이터를 여러 데이터 센터에 다중화하는 것이 중요하다.&lt;/p>
&lt;h3 id="시스템-아키텍처-다이어그램">시스템 아키텍처 다이어그램&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_14.png"
width="842"
height="525"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_14_hu3a1f1cde060e244af1e3932a5858e642_94830_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_14_hu3a1f1cde060e244af1e3932a5858e642_94830_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="384px"
>&lt;/p>
&lt;ul>
&lt;li>클라이언트는 키-값 저장소가 제공하는 두 가지 단순한 API, &lt;code>get(key)&lt;/code>, &lt;code>put(key, value)&lt;/code>와 통신한다.&lt;/li>
&lt;li>중재자는 클라이언트에게 키-값 저장소에 대한 프락시 역할을 하는 노드다.&lt;/li>
&lt;li>노드는 안정 해시의 해시 링 위에 분포한다.&lt;/li>
&lt;li>노드를 자동으로 추가 또는 삭제할 수 있도록, 시스템은 완전히 분산된다.&lt;/li>
&lt;li>데이터는 여러 노드에 다중화된다.&lt;/li>
&lt;li>모든 노드가 같은 책임을 지므로, SPOF(Single Point of Failure)는 존재하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_15.png"
width="830"
height="656"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_15_hud90111428b56169725aae5ee0bdfc804_100802_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_15_hud90111428b56169725aae5ee0bdfc804_100802_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="303px"
>&lt;/p>
&lt;p>완전히 분산된 설계를 채택하였으므로 모든 노드는 제시된 기능을 전부 지원해야한다.&lt;/p>
&lt;h3 id="쓰기-경로">쓰기 경로&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_16.png"
width="845"
height="458"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_16_hu216694585a97b0bfbb508eaee3fd8e8a_77802_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_16_hu216694585a97b0bfbb508eaee3fd8e8a_77802_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="카산드라의 사례"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/p>
&lt;ol>
&lt;li>쓰기 요청이 커밋 로그 파일에 기록된다.&lt;/li>
&lt;li>데이터가 메모리 캐시에 기록된다.&lt;/li>
&lt;li>메모리 캐시가 가득 차거나 사전에 정의된 임계치에 도달하면 데이터는 디스크에 있는 SSTable에 기록된다.
&lt;ul>
&lt;li>SSTable: Sorted-String Table의 약어로 &amp;lt;키, 값&amp;gt; 의 순서쌍을 정렬된 리스트로 관리하는 테이블이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="읽기-경로">읽기 경로&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_17.png"
width="845"
height="446"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_17_huaac619f90ef719991892748c739fd616_71124_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_17_huaac619f90ef719991892748c739fd616_71124_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="189"
data-flex-basis="454px"
>&lt;/p>
&lt;p>읽기 요청을 받은 노드는 데이터가 메모리 캐시에 있는지부터 살핀 후 데이터를 클라이언트에게 반환한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/6/img_18.png"
width="843"
height="425"
srcset="https://codemario318.github.io/post/system-design-interview/6/img_18_hub84a0c909dfc6b10b41bdf7efd5bb775_89775_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/6/img_18_hub84a0c909dfc6b10b41bdf7efd5bb775_89775_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="476px"
>&lt;/p>
&lt;p>데이터가 메모리에 없는 경우 디스크에서 가져온다.&lt;/p>
&lt;p>어느 SSTable에 찾는 키가 있는지 효율적으로 찾기 위해 블룸 필터(Bloom filter)가 흔히 사용된다.&lt;/p>
&lt;ol>
&lt;li>데이터가 메모리에 있는지 검사하고 있다면 반환한다.&lt;/li>
&lt;li>데이터가 메모리에 없으므로 블룸 필터를 검사한다.&lt;/li>
&lt;li>블룸 필터를 통해 어떤 SSTable에 키가 보관되어 있는지 알아낸다.&lt;/li>
&lt;li>SSTable에서 데이터를 가져온다.&lt;/li>
&lt;li>해당 데이터를 클라이언트에게 반환한다.&lt;/li>
&lt;/ol>
&lt;h2 id="요약">요약&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>목표/문제&lt;/th>
&lt;th>기술&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>대규모 데이터 저장&lt;/td>
&lt;td>안정 해시를 사용해 서버들에 부하 분산&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>읽기 연산에 대한 높은 가용성 보장&lt;/td>
&lt;td>데이터를 여러 데이터센터에 다중화&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>쓰기 연산에 대한 높은 가용성 보장&lt;/td>
&lt;td>버저닝 및 백터 시계를 사용한 충돌 해소&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 파티션&lt;/td>
&lt;td>안정 해시&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>점진적 규모 확장성&lt;/td>
&lt;td>안정 해시&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>다양성(heterogeneity)&lt;/td>
&lt;td>안정 해시&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>조절 가능한 데이터 일관성&lt;/td>
&lt;td>정족수 합의(quorum consensus)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>일시적 장애 처리&lt;/td>
&lt;td>느슨한 정족수 프로토콜(sloppy quorum)과 단서 후 임시 위탁(hinted handoff)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>영구적 장애 처리&lt;/td>
&lt;td>머클 트리(Merkle tree)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 센터 장애 대응&lt;/td>
&lt;td>여러 데이터 센터에 걸친 데이터 다중화&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>5. 안정 해시 설계</title><link>https://codemario318.github.io/post/system-design-interview/5/</link><pubDate>Thu, 23 May 2024 12:04:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/5/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/cover.png" alt="Featured image of post 5. 안정 해시 설계" />&lt;p>&lt;strong>수평적 규모 확장성&lt;/strong>을 달성하기 위해서는 요청 또는 데이터를 서버에 &lt;strong>균등하게 나누는 것&lt;/strong>이 중요하다.&lt;/p>
&lt;p>&lt;strong>안정 해시&lt;/strong>는 이 목표를 달성하기 위해 보편적으로 사용하는 기술이다.&lt;/p>
&lt;h2 id="해시-키-재배치rehash-문제">해시 키 재배치(rehash) 문제&lt;/h2>
&lt;p>N개의 캐시 서버가 있을 때, 부하를 균등하게 나누는 보편적 방법은 해시 함수를 사용하는 것이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">serverIndex = hash(key) % N
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>총 4대의 서버를 사용한다면, 주어진 각각의 키에 대해 아래와 같이 계산될 수 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>키&lt;/th>
&lt;th>해시&lt;/th>
&lt;th>해시 % 4(서버 인덱스)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>key0&lt;/td>
&lt;td>18358617&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key1&lt;/td>
&lt;td>26143584&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key2&lt;/td>
&lt;td>18131146&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key3&lt;/td>
&lt;td>35863496&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key4&lt;/td>
&lt;td>34085809&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key5&lt;/td>
&lt;td>27581703&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key6&lt;/td>
&lt;td>38164978&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key7&lt;/td>
&lt;td>22530351&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>키 값을 해싱한 값에 나머지 연산을 하여 저장될 서버가 결정된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img.png"
width="597"
height="323"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_hu8ecb82b93ef83548a97acf28dacc70e3_47080_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_hu8ecb82b93ef83548a97acf28dacc70e3_47080_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="443px"
>&lt;/p>
&lt;p>이 방식은 &lt;strong>서버 풀의 크기가 고정되어 있을 때&lt;/strong>, &lt;strong>데이터 분포가 균등할 때&lt;/strong> 잘 동작한다.&lt;/p>
&lt;p>하지만 서버가 추가되거나, 기존 서버가 삭제되면 나머지 연산 결과 값이 변하기 때문에 문제가 발생한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>키&lt;/th>
&lt;th>해시&lt;/th>
&lt;th>해시 % 3(서버 인덱스)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>key0&lt;/td>
&lt;td>18358617&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key1&lt;/td>
&lt;td>26143584&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key2&lt;/td>
&lt;td>18131146&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key3&lt;/td>
&lt;td>35863496&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key4&lt;/td>
&lt;td>34085809&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key5&lt;/td>
&lt;td>27581703&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key6&lt;/td>
&lt;td>38164978&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key7&lt;/td>
&lt;td>22530351&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>따라서 아래와 같은 형태로 키의 분포가 바뀐다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_1.png"
width="595"
height="375"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_1_hu221148814a934c0ed66cfef734ebb8e4_56907_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_1_hu221148814a934c0ed66cfef734ebb8e4_56907_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="158"
data-flex-basis="380px"
>&lt;/p>
&lt;p>장애가 발생한 1번 서버에 보관되어 있는 키 뿐만 아닌 대부분의 키가 재분배되어, 대부분 캐시 클라이언트가 데이터가 없는 서버에 접속하게된다.&lt;/p>
&lt;p>이로 인해 대규모 캐시 미스가 발생하게되는데, &lt;strong>안정 해시&lt;/strong>는 이러한 문제를 효과적으로 해결하는 방식이다.&lt;/p>
&lt;h2 id="안정-해시">안정 해시&lt;/h2>
&lt;p>안정 해시는 &lt;strong>해시 테이블 크기가 조정될 때 평균적으로 &lt;code>k/n&lt;/code>개의 키만 재비치하는 해시 기술&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>k&lt;/code>: 키의 개수&lt;/li>
&lt;li>&lt;code>n&lt;/code>: 슬롯의 개수&lt;/li>
&lt;/ul>
&lt;p>이와는 달리 대부분의 전통적인 해시 테이블은 슬롯의 수가 바뀌면 거의 대부분 키를 재배치한다.&lt;/p>
&lt;h3 id="해시-공간과-해시-링">해시 공간과 해시 링&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>SHA-1&lt;/strong> 해시함수를 사용하며, 출력 값의 범위는 &lt;code>x0, x1 ... xn&lt;/code>이라고 가정한다.&lt;/li>
&lt;li>&lt;strong>SHA-1&lt;/strong>의 해시 공간(hash space) 범위는 &lt;strong>0 부터 &lt;code>2^160 - 1&lt;/code>&lt;/strong> 까지라고 알려져 있다.&lt;/li>
&lt;/ul>
&lt;p>따라서 &lt;code>x0 = 0&lt;/code>, &lt;code>xn -1 = 2^160 - 1&lt;/code>이며, 두 수 사이의 값을 갖게 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_2.png"
width="239"
height="284"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_2_huf4d0b3acc8d8378f9f6d7202b468ee24_14360_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_2_huf4d0b3acc8d8378f9f6d7202b468ee24_14360_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="84"
data-flex-basis="201px"
>&lt;/p>
&lt;p>이 해시 공간의 양쪽을 연결하변 해시 링이 만들어진다.&lt;/p>
&lt;h3 id="해시-서버">해시 서버&lt;/h3>
&lt;p>해시 함수 &lt;code>f&lt;/code>를 사용하면 서버(IP, 이름 등)를 링 위의 어딘가에 대응시킬 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_3.png"
width="607"
height="421"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_3_hu0bc48cf4515b95e87de880bf1aab9c60_55336_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_3_hu0bc48cf4515b95e87de880bf1aab9c60_55336_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="346px"
>&lt;/p>
&lt;h3 id="해시-키">해시 키&lt;/h3>
&lt;blockquote>
&lt;p>안정 해시에서 사용되는 해시 함수는 전통적인 해시 키 방식에서 언급된 방식과 다르며, 만들어질 수 있는 모든 해시 공간 &lt;code>x0 ... xn&lt;/code>을 연결한 형태이므로 나머지 연산을 사용하지 않는다.&lt;/p>
&lt;/blockquote>
&lt;p>캐시할 키 또한 서버와 함께 해시 링 위의 어느 지점에 배치할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_4.png"
width="606"
height="390"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_4_hu2fcefd9766a218d8cface53baa2bca15_61260_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_4_hu2fcefd9766a218d8cface53baa2bca15_61260_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="372px"
>&lt;/p>
&lt;h3 id="서버-조회">서버 조회&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_5.png"
width="606"
height="390"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_5_hu2fcefd9766a218d8cface53baa2bca15_61260_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_5_hu2fcefd9766a218d8cface53baa2bca15_61260_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="372px"
>&lt;/p>
&lt;p>어떤 키가 저장되는 서버는 &lt;strong>해당 키의 위치로부터 시계 방향으로 링을 탐색해 나가면서 만나는 첫번 째 서버&lt;/strong>이다.&lt;/p>
&lt;p>따라서 &lt;strong>k0&lt;/strong>는 &lt;strong>s0&lt;/strong> 에 저장된다.&lt;/p>
&lt;h3 id="서버-추가">서버 추가&lt;/h3>
&lt;p>키가 저장되는 서버가 키의 위치로부터 시계 방향으로 링을 돌면서 만나는 첫 서버이므로, 서버를 추가하더라도 키 가운데 일부만 재배치하면 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_6.png"
width="615"
height="465"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_6_huc8545933ab2d8774b07636da6ebf7ea2_77279_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_6_huc8545933ab2d8774b07636da6ebf7ea2_77279_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="132"
data-flex-basis="317px"
>&lt;/p>
&lt;p>위 그림처럼 s4가 추가되면, k0만 재배치하면 되며, 나머지 키들은 같은 서버에 남게된다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>k0&lt;/strong>가 만나는 첫 서버가 &lt;strong>s4&lt;/strong>로 바뀌기 때문&lt;/li>
&lt;/ul>
&lt;h3 id="서버-제거">서버 제거&lt;/h3>
&lt;p>마찬가지로 한 서버가 제거되면 &lt;strong>키 일부만 재배치&lt;/strong>된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_7.png"
width="609"
height="450"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_7_hu76c16055e4220cf0e1509508dbdc7e60_68728_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_7_hu76c16055e4220cf0e1509508dbdc7e60_68728_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="324px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>s1&lt;/strong>이 삭제되었을 때 &lt;strong>k1&lt;/strong>의 첫 서버만 &lt;strong>s2&lt;/strong>로 바뀌므로 &lt;strong>k1&lt;/strong>만 &lt;strong>s2&lt;/strong>로 재배치된다.&lt;/li>
&lt;/ul>
&lt;h3 id="기존-구현법의-두-가지-문제">기존 구현법의 두 가지 문제&lt;/h3>
&lt;p>안정 해시 알고리즘은 MIT에서 처음 제안되었는데, 기본 절차는 아래와 같다.&lt;/p>
&lt;ol>
&lt;li>서버와 키를 &lt;strong>균등 분포 해시 함수&lt;/strong>를 사용해 해시 링에 배치한다.&lt;/li>
&lt;li>키의 위치에서 링을 시계방향으로 탐색하다 만나는 최초의 서버가 키가 저장될 서버이다.&lt;/li>
&lt;/ol>
&lt;p>안정 해시는 근본적으로 최소한의 추가/삭제에 대해 최소한의 재배치를 고려한다. 따라서 이러한 방식에는 두 가지 문제가 발생한다.&lt;/p>
&lt;p>&lt;strong>파티션 크기 문제&lt;/strong>&lt;/p>
&lt;p>서버가 추가되거나 삭제되는 상황을 감안하면 사용하더라도 파티션의 크기를 균등하게 유지하는 게 불가능하다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_8.png"
width="610"
height="371"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_8_hufb05e65c37497f753e3a366dbfe6320e_67873_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_8_hufb05e65c37497f753e3a366dbfe6320e_67873_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;ul>
&lt;li>파티션의 크기는 시계 방향으로 제일 가까운 서버 사이와의 거리만큼의 해시 공간으로, 서버의 해시 공간이 균등하지 않다.
&lt;ul>
&lt;li>추가 삭제될 때 시계 방향으로 제일 가까운 서버에 키들이 집중된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>키의 균등 분포 문제&lt;/strong>&lt;/p>
&lt;p>균등 분포 해시 함수는 충돌을 최소화하며 입력 키들이 해시 공간 전체에 고르게 분포되어 특정 영역에 물리지 않도록 구현되지만 완전하지는 않다.&lt;/p>
&lt;ul>
&lt;li>데이터의 비균등한 본질:
&lt;ul>
&lt;li>실제 데이터는 해시 함수의 이상적인 균등 분포를 따르지 않을 수 있다.&lt;/li>
&lt;li>특정 패턴이나 값들이 특정 해시 영역에 몰리는 경우가 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>해시 함수의 한계:
&lt;ul>
&lt;li>모든 해시 함수는 완벽한 균등 분포를 보장할 수 없다.&lt;/li>
&lt;li>특히 입력 키의 분포가 고르지 않을 경우, 해시 값의 분포도 고르지 않을 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_9.png"
width="611"
height="409"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_9_hu5257857a45f5f8de50581f3a0c6d2841_61763_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_9_hu5257857a45f5f8de50581f3a0c6d2841_61763_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="149"
data-flex-basis="358px"
>&lt;/p>
&lt;p>따라서 키의 균등 분포가 매우 달성하기 어려워 위와 같은 상황이 발생하게된다.&lt;/p>
&lt;p>&lt;strong>+ 실제 서버의 처리 능력 차이&lt;/strong>&lt;/p>
&lt;p>노드(서버)마다 처리 능력이나 저장 용량이 다를 경우, 파티션 크기의 균등성이 실제 부하의 균등성을 의미하지 않을 수 있다.&lt;/p>
&lt;h3 id="가상-노드">가상 노드&lt;/h3>
&lt;p>가상 노드는 &lt;strong>실제 노드 또는 서버를 가리키는 노드&lt;/strong>로서 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_10.png"
width="603"
height="458"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_10_hua3bd50f3317f65ef075362e2b74282e1_85776_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_10_hua3bd50f3317f65ef075362e2b74282e1_85776_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="315px"
>&lt;/p>
&lt;p>서버들의 비슷한 해시 공간을 가질 수 있도록 하는 기법으로 해시 링 위에 실제 서버를 가르키는 가상 노드들을 분포시킨 후 가상 노드에 할당되는 해시 영역을 가상 노드가 가르키는 서버가 처리하도록 한다.&lt;/p>
&lt;ul>
&lt;li>따라서 각 서버는 하나가 아닌 여러 개의 파티션을 관리해야 한다.&lt;/li>
&lt;/ul>
&lt;p>가상 노드의 개수를 늘리면 표준 편차가 작아져 데이터가 고르게 분포되므로, 키위 분포는 점점 더 균등해지지만&lt;/p>
&lt;p>가상 노드 데이터를 저장할 공간이 더 많이 필요해지므로, 시스템 요구사항에 맞도록 가상 노드 개수를 적절히 조정하는 트레이드오프가 필요하다.&lt;/p>
&lt;h3 id="재배치할-키-결정">재배치할 키 결정&lt;/h3>
&lt;p>서버가 추가되거나 제거되면 데이터의 일부는 재배치해야 한다.&lt;/p>
&lt;p>&lt;strong>서버가 추가되었을 때&lt;/strong>&lt;/p>
&lt;p>&lt;strong>s4&lt;/strong>가 추가되었다고 가정하면, 영향을 받는 위는 &lt;strong>s4&lt;/strong> 부터 그 반시계 방향에 있는 &lt;strong>s3&lt;/strong> 까지이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_11.png"
width="611"
height="463"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_11_hu56d8da2926a0ef9a8f4dcf5986502707_77091_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_11_hu56d8da2926a0ef9a8f4dcf5986502707_77091_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="316px"
>&lt;/p>
&lt;p>따라서 &lt;strong>s3&lt;/strong> 부터 &lt;strong>s4&lt;/strong> 사이에 있는 키들을 &lt;strong>s4&lt;/strong>로 재배치해야한다.&lt;/p>
&lt;p>&lt;strong>서버가 삭제되었을 때&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_12.png"
width="608"
height="449"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_12_hu33149acfb6f53d9b638ddb2443c387f3_70058_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_12_hu33149acfb6f53d9b638ddb2443c387f3_70058_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="324px"
>&lt;/p>
&lt;p>&lt;strong>s1&lt;/strong>이 삭제되면 &lt;strong>s1&lt;/strong> 부터 그 반시계 방향에 있는 최초 서버 &lt;strong>s0&lt;/strong> 사이에 있는 키들이 &lt;strong>s2&lt;/strong>로 재배치되어야 한다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>안정 해시의 이점은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>서버가 추가되거나 삭제될 때 재배치되는 키의 수가 최소화된다.&lt;/li>
&lt;li>데이터가 보다 균등하게 분포하게 되므로 수평적 규모 확장성을 달성하기 쉽다.&lt;/li>
&lt;li>핫스팟 키 문제를 줄인다.
&lt;ul>
&lt;li>특정한 샤드에 대한 접근이 지나치게 빈번하면 서버 과부화 문제가 생길 수 있는데(유명인사 문제), 데이터를 좀 더 균등하게 분배하므로 문제 발생 가능성을 줄인다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>안정해시는 실제로 널리 쓰이는 기술이다.&lt;/p>
&lt;ul>
&lt;li>아마존 다이나모 데이터베이스의 파티셔닝 관련 컴포넌트&lt;/li>
&lt;li>아파치 카산드라 클러스터에서 데이터 파티셔닝&lt;/li>
&lt;li>디스코드 채팅 어플리케이션&lt;/li>
&lt;li>아카마이 CDN&lt;/li>
&lt;li>매그레프 네트워크 부하 분산기 등&lt;/li>
&lt;/ul></description></item><item><title>4. 처리율 제한 장치의 설계</title><link>https://codemario318.github.io/post/system-design-interview/4/</link><pubDate>Wed, 15 May 2024 12:22:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/4/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/cover.png" alt="Featured image of post 4. 처리율 제한 장치의 설계" />&lt;h2 id="처리율-제한-장치rate-limiter">처리율 제한 장치(Rate limiter)?&lt;/h2>
&lt;p>클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치이다.&lt;/p>
&lt;p>HTTP의 경우 &lt;strong>특정 기간 내에 전송되는 클라이언트의 요청 횟수를 제한&lt;/strong>한다.&lt;/p>
&lt;ul>
&lt;li>사용자는 초당 2회 이상 새 글을 올릴 수 없다.&lt;/li>
&lt;li>같은 IP 주소로는 하루 10개 이상의 계정을 생성할 수 없다.&lt;/li>
&lt;li>같은 디바이스로는 주당 5회 이상 리워드(reward)를 요청할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;p>대형 IT 기업들이 공개한 거의 대부분의 API는 어떤 형태로든 처리율 제한 장치를 갖고 있으며, 아래와 같은 장점이 있다.&lt;/p>
&lt;ul>
&lt;li>DoS(Denial of Service) 공격에 의한 자원 고갈을 방지할 수 있다.&lt;/li>
&lt;li>자원 절약
&lt;ul>
&lt;li>추가 요청에 대한 처리율을 제한하면 서버를 많이 두지 않아도된다.&lt;/li>
&lt;li>우선순위가 높은 API에 더 많은 자원을 할당할 수 있다.&lt;/li>
&lt;li>3rd 파티 API를 사용하는 경우 요청 횟수만큼 과금이 된다면, 사용자가 처리율을 제한하여 비용을 절약할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서버 과부하 방지
&lt;ul>
&lt;li>봇에서 오는 트래픽이나 사용자의 잘못된 이용 패턴으로 유발된 트래픽을 걸러내는 데 처리율 제한 장치를 활용할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>처리율 제한 장치를 구현하는 데는 여러 가지 알고리즘을 고려할 수 있으며, 각각 고유한 장단점을 가지고 있다.&lt;/p>
&lt;p>따라서 면접관과 서통하며 어떤 제한 장치를 구현해야 하는 지 분명하게 파악해야한다.&lt;/p>
&lt;ul>
&lt;li>Q. 클라이언트 측 제한장치? 서버 측 제한장치?
&lt;ul>
&lt;li>A. 서버측 API를 위한 제한 장치&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 어떠한 기준으로? IP 주소 or 사용자 ID 등
&lt;ul>
&lt;li>A. 다양한 형태의 제어 규칙을 정의할 수 있도록 하는 유연한 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 시스템의 규모는? 스타트업 or 대기업
&lt;ul>
&lt;li>A. 대규모 요청 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 분산 환경에서 동작해야 하는가?
&lt;ul>
&lt;li>A. 예&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 처리율 제한 장치가 독립적인 서비스인가? 코드에 포함할 수 있는가?
&lt;ul>
&lt;li>A. 알아서&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 처리율 제한에 막힌 상황에 사용자에게 알려하하는가?
&lt;ul>
&lt;li>A. 예&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="요구사항">요구사항&lt;/h3>
&lt;p>질문을 통해 파악한 시스템의 요구사항은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>설정된 처리율을 초과하는 요청은 정확하게 제한&lt;/li>
&lt;li>낮은 응답시간
&lt;ul>
&lt;li>HTTP 응답시간에 나쁜 영향을 주어서는 곤란하다. (대규모 처리 허용 등)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가능한 적은 메모리&lt;/li>
&lt;li>분산형 처리율 제한
&lt;ul>
&lt;li>하나의 처리율 제한 장치를 여러 서버나 프로세스에서 공유할 수 있어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예외 처리
&lt;ul>
&lt;li>요청 제한시 사용자에게 분명하게 보여주어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>높은 결함 감내성
&lt;ul>
&lt;li>제한 장치에 장애가 생기더라도 전체 시스템에 영향을 주어서는 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계-제시-및-동의-구하기">2단계 개략적 설계 제시 및 동의 구하기&lt;/h2>
&lt;p>기본적인 &lt;strong>클라이언트-서버 통신 모델&lt;/strong>을 사용하여 문제를 간단하게 만든다.&lt;/p>
&lt;h3 id="어디에-둘-것인가">어디에 둘 것인가?&lt;/h3>
&lt;p>기본적인 &lt;strong>클라이언트-서버 통신 모델&lt;/strong>에서는 처리율 제한 장치는 클라이언트, 서버 측에 둘 수 있다.&lt;/p>
&lt;p>&lt;strong>클라이언트&lt;/strong>&lt;/p>
&lt;p>클라이언트 요청은 쉽게 위변조가 가능하므로 처리율 제한을 안정적으로 걸 수 있는 장소가 아니다.&lt;/p>
&lt;ul>
&lt;li>모든 클라이언트의 구현을 통제하는 것도 어려울 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>서버&lt;/strong>&lt;/p>
&lt;p>큰 틀에서 처리율 제한 장치를 API 서버와 함께 두는 방식, 미들웨어로 만드는 방식 2가지를 고려할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img.png"
width="560"
height="141"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_hu95f96bf133f868fe94b526818cbf6220_35669_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_hu95f96bf133f868fe94b526818cbf6220_35669_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="API 서버에 두는 방식"
class="gallery-image"
data-flex-grow="397"
data-flex-basis="953px"
>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_2.png"
width="549"
height="218"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_2_hu46848255408feea17de861814d1271d1_42946_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_2_hu46848255408feea17de861814d1271d1_42946_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="미들웨어 동작 예시"
class="gallery-image"
data-flex-grow="251"
data-flex-basis="604px"
>&lt;/p>
&lt;p>처리율 제한 장치를 미들웨어로 만들어 API 서버로 가는 요청을 통제하는 방식은 제한된 요청을 API 서버로 보내지 않고, HTTP 상태코드 429를 반환한다.&lt;/p>
&lt;p>마이크로서비스의 경우 보통 API 게이트웨이라고 불리는 컴포넌트에 구현된다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>API 게이트웨이?&lt;/strong>&lt;br>
처리율 제한, SSL 종단 사용자 인증, IP 허용 목록 관리등을 지원하는 완전 위탁 관리형 서비스&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>처리율 제한 장치는 회사의 현재 기술 스택이나 엔지니어링 인력, 우선순위, 목표에 따라 어디에 둘 지 결정한다.&lt;/p>
&lt;ul>
&lt;li>프로그래밍 언어, 캐시 서비스 등 현재 사용하고 있는 기술 스택을 점검한다.&lt;/li>
&lt;li>사업에 필요에 맞는 처리율 제한 알고리즘을 찾는다.
&lt;ul>
&lt;li>직접 구현시 자유롭게 선택 가능하지만, 서드파티 게이트웨이를 사용하기로 했다면 제한될 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>설계가 마이크로서비스에 기반하고 있다면, 사용자 인증이나 IP 화이트리스트 관리 등을 처리하기 위해 API 게이트웨이를 이미 포함했다면 처리율 제한 기능 또한 포함시켜야 할 수 있다.&lt;/li>
&lt;li>직접 만드는 데는 시간이 들기 때문에 인력이 충분하지 않다면 상용 API 게이트웨이를 쓰는 것이 바람직하다.&lt;/li>
&lt;/ul>
&lt;h3 id="처리율-제한-알고리즘">처리율 제한 알고리즘&lt;/h3>
&lt;p>처리율 제한을 실현하는 알고리즘은 여러가지이며, 각기 다른 장단점을 가지고 있다.&lt;/p>
&lt;ul>
&lt;li>토큰 버킷, 누출 버킷, 고정 윈도 카운터, 이동 윈도 로그, 이동 윈도 카운터 등&lt;/li>
&lt;/ul>
&lt;h4 id="토큰-버킷-알고리즘">토큰 버킷 알고리즘&lt;/h4>
&lt;p>토큰 버킷 알고리즘은 처리율 제한에 폭 넓게 이용되고 있다.&lt;/p>
&lt;p>간단하고, 알고리즘에 대한 이해도가 높아 인터넷 기업들이 보편적으로 사용하고 있다.&lt;/p>
&lt;ul>
&lt;li>아마존, 스트라이프 등&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_4.png"
width="529"
height="492"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_4_hud272ad2e7ce6d0192e191aa981cc5e7d_63798_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_4_hud272ad2e7ce6d0192e191aa981cc5e7d_63798_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="107"
data-flex-basis="258px"
>&lt;/p>
&lt;p>&lt;strong>토큰 버킷&lt;/strong>은 지정된 용량을 갖는 컨테이너로, 사전 설정된 양의 토큰이 주기적으로 채워진다.&lt;/p>
&lt;p>토큰이 꽉 찬 버킷에는 더 이상의 토큰은 추가되지 않고 버려진다.&lt;/p>
&lt;ul>
&lt;li>각 요청은 처리될 때마다 하나의 토큰을 사용한다.&lt;/li>
&lt;li>요청이 도착하면 버킷에 충분한 토큰이 있는지 검사하게 된다.&lt;/li>
&lt;li>토큰이 있는 경우 버킷에서 토큰 하나를 꺼낸 후 요청을 시스템에 전달한다.&lt;/li>
&lt;li>없는 경우 버려진다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_5.png"
width="469"
height="547"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_5_hu470c561bcff0a77f741d71f0c2c45165_78035_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_5_hu470c561bcff0a77f741d71f0c2c45165_78035_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="버킷 크기 = 4, 공급률 = 분당 4"
class="gallery-image"
data-flex-grow="85"
data-flex-basis="205px"
>&lt;/p>
&lt;p>토큰 버킷 알고리즘은 2가지 인자를 받는다.&lt;/p>
&lt;ul>
&lt;li>버킷 크기: 버킷에 담을 수 있는 토큰의 최대 개수&lt;/li>
&lt;li>토큰 공급률: 초당 몇개의 토큰이 버킷에 공급되는가&lt;/li>
&lt;/ul>
&lt;p>적절한 버킷의 개수는 공급 제한 규칙에 따라 결정된다.&lt;/p>
&lt;ul>
&lt;li>통상적으로, API 엔드포인트마다 벌도의 버킷을 둔다.
&lt;ul>
&lt;li>포스팅 1번, 친구 150명 추가 가능, 좋아요 5번 이라면 사용자마다 3개 필요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>IP 주소별 처리율 제한 필요시 IP 주소마다 버킷을 하나씩 할당해야 한다.&lt;/li>
&lt;li>시스템의 처리율을 초당 10,000개 요청으로 제한하고 싶다면, 모든 요청이 하나의 버킷을 공유하도록 한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>구현이 쉽다.&lt;/li>
&lt;li>메모리 사용 측면에서도 효율적이다.&lt;/li>
&lt;li>짧은 시간에 집중되는 트래픽도 처리 가능하다.
&lt;ul>
&lt;li>버킷에 남은 토큰이 있다면 요청은 전달된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>파라미터를 적절하게 튜닝하는 것이 까다롭다.&lt;/li>
&lt;/ul>
&lt;h4 id="누출-버킷-알고리즘">누출 버킷 알고리즘&lt;/h4>
&lt;p>누출 버킷 알고리즘은 토큰 버킷 알고리즘과 비슷하지만 &lt;strong>요청 처리율이 고정되어 있다는 점&lt;/strong>이 다르다.&lt;/p>
&lt;p>보통 FIFO 큐로 구현하며 동작 원리는 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>요청이 도착하면 큐가 가득 차 있는지 본다.
&lt;ul>
&lt;li>빈자리가 있다면 큐에 요청을 추가한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>큐가 가득 차 있는 경우에는 새 요청을 버린다.&lt;/li>
&lt;li>지정된 시간마다 큐에서 요청을 꺼내어 처리한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_6.png"
width="599"
height="221"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_6_hu20c9bad42732607dad0a83639f3502f8_30101_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_6_hu20c9bad42732607dad0a83639f3502f8_30101_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="누출 버킷 알고리즘"
class="gallery-image"
data-flex-grow="271"
data-flex-basis="650px"
>&lt;/p>
&lt;p>누출 버킷 알고리즘은 다음의 두 인자를 사용한다.&lt;/p>
&lt;ul>
&lt;li>버킷 크기: 처리될 항목들이 보관될 큐의 사이즈&lt;/li>
&lt;li>처리율: 지정된 시간당 몇 개의 항목을 처리할지 지정하는 값.(보통 초단위)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>큐의 크기가 제한되어 있어 메모리 사용량 측면에서 효율적이다.&lt;/li>
&lt;li>고정된 처리율을 가지므로 안정된 출력(Stable outflow rate)이 필요한 경우에 적합하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>단시간에 많은 트래픽이 몰리는 경우 큐에는 오래된 요청들이 쌓이고, 그 요청들을 제때 처리 못하면 최신 요청들은 버려진다.&lt;/li>
&lt;li>파라미터를 올바르게 튜닝하기 까다로울 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="고정-윈도-카운터-알고리즘">고정 윈도 카운터 알고리즘&lt;/h4>
&lt;p>고정 윈도 카운터 알고리즘은 다음과 같이 동작한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_7.png"
width="601"
height="355"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_7_huacea6638a786d893354d0e089d7abe1d_35784_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_7_huacea6638a786d893354d0e089d7abe1d_35784_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="406px"
>&lt;/p>
&lt;ol>
&lt;li>타임라인을 고정된 간격의 윈도로 나누고, 각 윈도마다 카운터를 붙인다.&lt;/li>
&lt;li>요청이 접수될 때마다 이 카운터의 값을 1씩 증가시킨다.&lt;/li>
&lt;li>카운터의 값이 사전에 설정된 임계치에 도달하면 새로운 요청은 새 윈도가 열릴 때 까지 버려진다.&lt;/li>
&lt;/ol>
&lt;p>고정 윈도 카운터 알고리즘의 가장 큰 문제는 윈도의 경계 부근에 순간적으로 많은 트래픽이 집중될 경우 윈도에 할당된 양보다 더 많은 요청이 처리될 수 있다는 점이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_8.png"
width="604"
height="296"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_8_hu06e9b333628f278fe9f5a17c951f72ed_27698_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_8_hu06e9b333628f278fe9f5a17c951f72ed_27698_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="204"
data-flex-basis="489px"
>&lt;/p>
&lt;p>분당 최대 5개 요청을 허용하는 시스템에서 &lt;code>2:00:00 ~ 2:01:00&lt;/code>, &lt;code>2:01:00 ~ 2:02:00&lt;/code> 윈도우에 각각 5개 요청을 처리하였으나, 윈도우를 30초 옮겨 &lt;code>2:00:30 ~ 2:01:30&lt;/code>를 살펴보면 총 10개의 요청을 처리하게되어 설정된 최대 처리량 5개를 초과하게 된다.&lt;/p>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>메모리 효율이 좋다.&lt;/li>
&lt;li>이해하기 쉽다.&lt;/li>
&lt;li>윈도가 닫히는 시점에 카운터를 초기화하는 방식은 특정한 트래픽 패턴을 처리하기에 적합하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>윈도 경계 부근에서 일시적으로 많은 트래픽이 몰려드는 경우, 기대했던 시스템의 처리 한도보다 많은 양의 요청을 처리하게 된다.&lt;/li>
&lt;/ul>
&lt;h4 id="이동-윈도-로깅-알고리즘">이동 윈도 로깅 알고리즘&lt;/h4>
&lt;p>고정 윈도 카운터 알고리즘의 문제를 해결한 방식이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_9.png"
width="582"
height="400"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_9_hu98c0a7c61c2865bfd0748184396a4361_43992_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_9_hu98c0a7c61c2865bfd0748184396a4361_43992_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="349px"
>&lt;/p>
&lt;ul>
&lt;li>요청의 타임 스탬프를 추적한다.
&lt;ul>
&lt;li>보통 레디스의 정렬 집합 같은 캐시에 보관한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>새 요청이 오면 만료된 타임스탬프는 제거한다.
&lt;ul>
&lt;li>타임스탬프 값이 현재 윈도의 시작 지점보다 오래된 타임 스탬프&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>새 요청의 타임스탬프 로그에 추가한다.&lt;/li>
&lt;li>로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달한다. 아닐경우 처리를 거부한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>어느 순간 윈도를 보더라도, 허용되는 요청의 개수는 시스템의 처리율 한도를 넘기지 않는다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>거부된 요청의 타임스탬프도 보관하기 때문에 다량의 메모리를 사용하게된다.&lt;/li>
&lt;/ul>
&lt;h4 id="이동-윈도-카운터-알고리즘">이동 윈도 카운터 알고리즘&lt;/h4>
&lt;p>이동 윈도 카운터 알고리즘은 고정 윈도 카운터 알고리즘과 이동 윈도 로깅 알고리즘을 결합한 것이다.&lt;/p>
&lt;p>&lt;code>현재 1분간의 요청 수 + 직전 1분간의 요청 수 * 이동 윈도와 직전 1분이 겹치는 비율&lt;/code>을 계산하여 현재 윈도에 몇개의 요청이 왔는지를 구한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_10.png"
width="581"
height="343"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_10_hu4227282d9657e7f968e2cd18b876213b_41691_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_10_hu4227282d9657e7f968e2cd18b876213b_41691_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="406px"
>&lt;/p>
&lt;p>분당 7개 요청으로 설정되어 있고, 이전 1분동안 5개의 요청이, 그리고 1분 동안 3개의 요청이 왔다면&lt;/p>
&lt;p>&lt;code>3 + 5 * 70%&lt;/code>를 계산하여 현재 6.5개의 요청이 있다고 계산하고, 분당 7개의 요청보다 적으므로 전달된다.&lt;/p>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>이전 시간대의 평균 처리율에 따라 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응한다.&lt;/li>
&lt;li>메모리 효율이 좋다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>직전 시간대에 도착한 요청이 균등하게 분포되어 있다고 가정한 상태에서 추정치를 계산하기 때문에 다소 느슨하다.
&lt;ul>
&lt;li>생각만큼은 심각한 문제는 아니다.&lt;/li>
&lt;li>클라우드플레어가 실시했던 실험에 따르면 40억 개의 요청 가운데 스템의 실제 상태와 맞지 않게 허용되거나 버려진 요청은 0.003%에 불과하였다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적인-아키텍처">개략적인 아키텍처&lt;/h3>
&lt;p>처리율 제한 알고리즘은 얼마나 많은 요청이 접수되었는지를 추적할 수 있는 카운터를 추적 대상별로 두고(사용자 or IP or API 엔드포인트) 이 카운터의 값이 어떤 한도를 넘어서면 도착한 요청을 거부하는 것이다.&lt;/p>
&lt;p>이러한 카운터는 읽기 쓰기 작업이 빈번하고, 빠르게 지워져야 하는 특성으로 인해 빠른데다 시간에 기반한 만료 정책을 지원하는 메모리 캐시가 적절하다.&lt;/p>
&lt;p>대표적으로 레디스가 많이 활용되며 이에 적합한 &lt;code>INCR&lt;/code>, &lt;code>EXPIRE&lt;/code> 명령을 제공한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>INCR&lt;/code>: 메모리에 저당된 카운터의 값을 1만큼 증가시킨다.&lt;/li>
&lt;li>&lt;code>EXPIRE&lt;/code>: 카운터에 타임아웃 값을 설정한다. 시간이 지나면 자동 삭제된다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_11.png"
width="593"
height="260"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_11_hua0ec6a8fedf59bf7e19688bf87bdb91a_52761_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_11_hua0ec6a8fedf59bf7e19688bf87bdb91a_52761_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적인 아키텍처"
class="gallery-image"
data-flex-grow="228"
data-flex-basis="547px"
>&lt;/p>
&lt;ol>
&lt;li>클라이언트가 처리율 제한 미들웨어에게 요청을 보낸다.&lt;/li>
&lt;li>처리율 제한 미들웨어는 레디스의 지정 버킷에서 카운터를 가져와 한도에 도달했는지 검사한다.
&lt;ul>
&lt;li>한도에 도달했다면 요청은 거부됨&lt;/li>
&lt;li>한도에 도달하지 않았다면 API로 요청을 전달하고, 카운터의 값을 증가시켜 레디스에 저장한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="상세-설계">상세 설계&lt;/h2>
&lt;p>개략적 설계만 봐서는 다음과 같은 사항은 알 수가 없다.&lt;/p>
&lt;ul>
&lt;li>처리율 제한 규칙은 어떻게 만들어지고 어디에 저장되는가?&lt;/li>
&lt;li>처리가 제한된 요청들은 어떻게 처리되는가?&lt;/li>
&lt;/ul>
&lt;h3 id="처리율-제한-규칙">처리율 제한 규칙&lt;/h3>
&lt;p>리프트(lyft)는 처리율 제한에 오픈 소스를 사용하고 있는데, 이 컴포넌트를 통해 어떤 처리율 제한 규칙이 사용되고 있는지 살펴볼 수 있다.&lt;/p>
&lt;p>이러한 규칙들은 보통 설정 파일 형태로 디스크에 저장된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">domain&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">messaging&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">descriptors&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">message_type&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">Value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">marketing&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rate_limit&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">unit&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">day&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">requests_per_unit&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">5&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>마케팅 메시지의 최대치를 하루 5개로 제한&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">domain&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">auth&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">descriptors&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">auth_type&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">Value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">login&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rate_limit&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">unit&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">minute&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">requests_per_unit&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">5&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>클라이언트가 분당 5회 이상 로그인 할 수 없도록 제한&lt;/li>
&lt;/ul>
&lt;h3 id="처리율-한도-초과-트래픽의-처리">처리율 한도 초과 트래픽의 처리&lt;/h3>
&lt;p>어떤 요청이 한도 제한에 걸리면 HTTP 429 응답을 보내거나, 한도 제한에 걸린 메시지를 나중에 처리하기 위해 큐에 보관할 수도 있다.&lt;/p>
&lt;p>&lt;strong>처리율 제한 장치가 사용하는 HTTP 헤더&lt;/strong>&lt;/p>
&lt;p>클라이언트가 요청이 제한에 관련된 정보들을 HTTP 응답 헤더를 확인하면 알 수 있다.&lt;/p>
&lt;p>처리율 제한 장치는 다음 HTTP 헤더를 클라이언트에 보내 제한에 걸렸음을 알린다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>X-Ratelimit-Remaining&lt;/code>: 윈도 내에 남은 처리 가능 요청 수&lt;/li>
&lt;li>&lt;code>X-Ratelimit-Limit&lt;/code>: 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수&lt;/li>
&lt;li>&lt;code>X-Ratelimit-Retry-After&lt;/code>: 한도 제한에 걸리지 않기 위해 몇초 뒤에 요청을 다시 보내야 하는지&lt;/li>
&lt;/ul>
&lt;p>사용자가 너무 많은 요청을 보내면 &lt;strong>429 too many requests&lt;/strong>오류를 &lt;code>X-Ratelimit-Retry-After&lt;/code> 헤더와 함께 반환하도록 한다.&lt;/p>
&lt;h3 id="상세-설계-1">상세 설계&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_12.png"
width="616"
height="504"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_12_hue300fb2d822881a8aa53d8fa5a83713d_105530_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_12_hue300fb2d822881a8aa53d8fa5a83713d_105530_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="122"
data-flex-basis="293px"
>&lt;/p>
&lt;ul>
&lt;li>처리율 제한 규칙은 디스크에 보관한다.
&lt;ul>
&lt;li>작업 프로세스는 수시로 규칙을 읽어 캐시에 저장한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>클라이언트가 요청을 서버에 보내면 요청은 먼저 처리율 제한 미들웨어에 도달한다.&lt;/li>
&lt;li>처리율 제한 미들웨어는 제한 규칙을 캐시에서 가져온다. 아울러 카운터 및 마지막 요청의 타임스탬프를 레디스 캐시에서 가져온다.
&lt;ul>
&lt;li>요청이 제한에 걸리지 않은 경우 API 서버로 보낸다.&lt;/li>
&lt;li>처리율 제한에 걸렸다면 에러를 클라이언트에 보낸다.
&lt;ul>
&lt;li>요청은 버리거나 메시지 큐에 보관한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="분산-환경에서의-처리율-제한-장치의-구현">분산 환경에서의 처리율 제한 장치의 구현&lt;/h3>
&lt;p>여러 대의 서버와 병렬 스레드를 지원하려면 &lt;strong>경쟁 조건&lt;/strong>과 &lt;strong>동기화&lt;/strong> 문제를 고려해야 한다.&lt;/p>
&lt;h4 id="경쟁-조건">경쟁 조건&lt;/h4>
&lt;p>처리율 제한 장치는 다음과 같이 동작한다.&lt;/p>
&lt;ol>
&lt;li>레디스에서 카운터의 값을 읽는다.&lt;/li>
&lt;li>카운터의 값이 임계치를 넘는지 본다.&lt;/li>
&lt;li>넘지 않는다면 레디스에 보관된 카운터 값을 1만큼 증가시킨다.&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_13.png"
width="602"
height="340"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_13_hu25f5b8ce1e5471668532889a2cb0e3bf_33618_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_13_hu25f5b8ce1e5471668532889a2cb0e3bf_33618_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="424px"
>&lt;/p>
&lt;p>병행성이 심한 환경에서는 위와 같이 보관될 값이 달라질 수 있는 이슈가 존재한다.&lt;/p>
&lt;p>이러한 경쟁 조건 문제를 해결하는 가장 널리 알려진 해결책은 **락(Lock)**이지만, 락은 시스템의 성능을 상당히 떨어뜨린다는 문제가 있다.&lt;/p>
&lt;p>위와 같은 설계의 경우 락 대신 **루아 스크립트(Lua script)**와 **정렬 집합(Sorted set)**이라 불리는 레디스 자료구조를 사용하여 해결할 수 있다.&lt;/p>
&lt;h4 id="동기화-이슈">동기화 이슈&lt;/h4>
&lt;p>수백만 사용자를 지원하려면 한 대의 처리율 제한 장치 서버로는 충분하지 않을 수 있어 처리율 제한 장치 서버를 여러 대 두게 되면 동기화가 필요해진다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_14.png"
width="612"
height="219"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_14_hud5d811b010ac2a69e5217967669d0f69_74199_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_14_hud5d811b010ac2a69e5217967669d0f69_74199_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="279"
data-flex-basis="670px"
>&lt;/p>
&lt;p>웹은 무상태이므로 클라이언트는 다음 요청을 다른 처리율 제한 장치로 보내게 될 수 있다.&lt;/p>
&lt;p>이때 동기화를 하지 않는다면 제한 장치 1은 클라이언트 2에 대해서는 아무것도 모르므로 처리율 제한이 올바르게 적용되지 않을 수 있다.&lt;/p>
&lt;p>이러한 문제를 해결하기 위해 같은 클라이언트로부터의 요청은 항상 같은 처리율 제한 장치로 보내는 &lt;strong>고정 세션&lt;/strong> 방식을 고려할 수 있다.&lt;/p>
&lt;p>하지만 이러한 방식은 확장 불가능, 뻣뻣하다는 단점을 가진다.&lt;/p>
&lt;p>따라서 레디스와 같은 중앙 집중형 데이터 저장소를 사용하여 해결하는 것이 좋다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/4/img_15.png"
width="559"
height="252"
srcset="https://codemario318.github.io/post/system-design-interview/4/img_15_hub3172bc6f37be502955916b9482777c8_60583_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/4/img_15_hub3172bc6f37be502955916b9482777c8_60583_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="221"
data-flex-basis="532px"
>&lt;/p>
&lt;h4 id="성능-최적화">성능 최적화&lt;/h4>
&lt;p>성능 최적화는 시스템 설계 면접의 단골 주제이며, 지금까지 살펴본 설계는 두 가지 지점에서 개선이 가능하다.&lt;/p>
&lt;ul>
&lt;li>여러 데이터센터를 지원하는 문제
&lt;ul>
&lt;li>멀리 떨어진 사용자를 지원하기 위해 지연시간이 증가할 수 밖에 없는데, 대부분의 클라우드 서비스 사업자는 세계 곳곳에 에지 서버를 심어두어 성능을 끌어올린다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>제한 장치 간에 데이터를 동기화할 때 최종 일관성 모델을 사용하는 것&lt;/li>
&lt;/ul>
&lt;h4 id="모니터링">모니터링&lt;/h4>
&lt;p>처리율 제한 장치를 설치한 이후에는 효과적으로 동작하는지 확인하기 위해 데이터를 모을 필요가 있다.&lt;/p>
&lt;ul>
&lt;li>채택된 처리율 제한 알고리즘이 효과적인지 확인하기 위해
&lt;ul>
&lt;li>이벤트 같은 이슈로 트래픽이 급증할 때 처리율 제한 장치가 비효율적으로 동작한다면 트래픽 패턴을 고려하여 알고리즘 변경을 고려한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>정의한 처리율 제한 규칙이 효과적인지 확인하기 위해
&lt;ul>
&lt;li>제한 규칙이 너무 엄격하다면 많은 유효 요청이 처리되지 못하고 버려질 경우 완화한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="마무리">마무리&lt;/h2>
&lt;p>시간이 허락된다면 다음 부분을 언급해보면 좋다.&lt;/p>
&lt;ul>
&lt;li>경성 또는 연성 처리율 제한
&lt;ul>
&lt;li>경성 처리율 제한: 요청의 개수는 임계치를 절대 넘어설 수 없다.&lt;/li>
&lt;li>연성 처리율 제한: 요청의 개수는 잠시동안은 임계치를 넘어설 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다양한 계층에서의 처리율 제한
&lt;ul>
&lt;li>애플리케이션 계층 외 다른 계층에서도 처리율 제한이 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>처리율 제한을 회피하는 방법. 클라이언트를 어떻게 설계하는 것이 최선인가?
&lt;ul>
&lt;li>클라이언트 측 캐시를 사용하여 API 호출 횟수를 줄인다.&lt;/li>
&lt;li>임계치를 이해하고, 짧은 시간 동안 너무 많은 메시지를 보내지 않도록 한다.&lt;/li>
&lt;li>예외나 에러를 처리하는 코드를 도입하여 예외적 상황을 우아하게 복구될 수 있도록 한다.&lt;/li>
&lt;li>재시도 로직을 구현할 때는 충분한 백오프 시간을 둔다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>3. 시스템 설계 면접 공략법</title><link>https://codemario318.github.io/post/system-design-interview/3/</link><pubDate>Tue, 07 May 2024 16:01:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/3/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/3/cover.png" alt="Featured image of post 3. 시스템 설계 면접 공략법" />&lt;blockquote>
&lt;p>&lt;strong>시스템 설계 면접&lt;/strong>은 두 명의 동료가 모호한 문제를 풀기 위해 협력하여 그 해결책을 찾아내는 과정에 대한 시뮬레이션이다.&lt;/p>
&lt;/blockquote>
&lt;p>시스템 설계 먼접은 특정 제품을 설계해보라는 식으로 막연하고, 넓은 범위로 인해 당황스러울 때가 많다.&lt;/p>
&lt;p>하지만 실세계에서 많은 엔지니어들이 참여하여 개발한 제품은 극도로 복잡하기 때문에 한 시간 안에 설계하는 것은 불가능 할 뿐더러, 완벽한 설계를 요구하지 않는다.&lt;/p>
&lt;ul>
&lt;li>시스템 설계 면접은 정해진 결말, 정답이 없다.
&lt;ul>
&lt;li>최종적으로 도출될 설계안은 설계 과정에서 들인 노력에 비하면 그다지 중요하지 않다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>설계 기술을 시연하는 자리이다.&lt;/li>
&lt;li>설계 과정에서 내린 결정들에 대한 방어 능력을 보이는 자리이다.&lt;/li>
&lt;li>면접관의 피드백을 건설적인 방식으로 처리할 자질이 있음을 보이는 자리이다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>면접관의 의도&lt;/strong>&lt;/p>
&lt;p>시스템 설계 면접은 지원자의 설계 능력의 기술적인 측면 뿐만 아니라 여러 시그널을 수집한다.&lt;/p>
&lt;ul>
&lt;li>협력에 적합한 사람인가?&lt;/li>
&lt;li>압박이 심한 상황도 잘 헤쳐 나갈 자질이 있는가?&lt;/li>
&lt;li>모호한 문제를 건설적으로 해결할 능력이 있는가?&lt;/li>
&lt;li>설계의 순수성에 집착한 나머지, 타협정 결정(trade off)를 도외시하는가?&lt;/li>
&lt;li>완고함, 편협함 등&lt;/li>
&lt;/ul>
&lt;h2 id="효과적인-면접을-위한-4단계-접근법">효과적인 면접을 위한 4단계 접근법&lt;/h2>
&lt;p>시스템 설계 면접은 제각각이다.&lt;/p>
&lt;p>훌륭한 설계 면접은 정해진 결말도 없고 정답도 없지만, 절차나 범위에는 &lt;strong>공통적인 부분&lt;/strong>이 존재한다.&lt;/p>
&lt;h3 id="문제-이해-및-설계-범위-확정">문제 이해 및 설계 범위 확정&lt;/h3>
&lt;p>요구사항을 완전히 이해하지 않고 답을 내놓는 행위는 아주 엄청난 부정적 신호이다.&lt;/p>
&lt;p>따라서 깊이 생각하고 질문하여 요구사항과 가정들을 분명히 해야한다.&lt;/p>
&lt;p>적절한 설계를 위해 엔지니어가 가져야 할 중요한 기술은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>올바른 질문을 하는 것&lt;/li>
&lt;li>적절한 가정을 하는 것&lt;/li>
&lt;li>시스템 구축에 필요한 정보를 모으는 것&lt;/li>
&lt;/ul>
&lt;p>따라서 올바른 질문을 통해 적절한 가정과 정보를 모아야하며, 요구사항을 정확히 이해하기 위한 질문은 아래와 같은 유형이 있다.&lt;/p>
&lt;ul>
&lt;li>구체적으로 어떤 기능을 만들어야 하나?&lt;/li>
&lt;li>제품 사용자 수는 얼마나 되나?&lt;/li>
&lt;li>회사의 규모는 얼마나 빨리 커지리라 예상하나?&lt;/li>
&lt;li>회사가 주로 사용하는 기술 스택은 무엇인가?&lt;/li>
&lt;li>설계를 단순화하기 위해 활용할 수 있는 기존 서비스로는 어떤 것들이 있는가?&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>뉴스 피드(news feed) 시스템 설계 질문 예제&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Q. 모바일 앱과 웹 앱 가운데 어느쪽을 지원해야 하는가?
&lt;ul>
&lt;li>A. 둘다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 가장 중요한 기능은?
&lt;ul>
&lt;li>A1. 새로운 포스트 올리기&lt;/li>
&lt;li>A2. 다른 친구의 뉴스 피드 조회하기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 정렬 기준은?
&lt;ul>
&lt;li>A. 시간 역순으로&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 한 사용자의 최대 친구 수
&lt;ul>
&lt;li>A. 5,000명&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 트래픽 규모는?
&lt;ul>
&lt;li>A. 일간 능동 사용자(DAU) 천만 명&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 피드는 텍스트로만 구성되는가?
&lt;ul>
&lt;li>A. 이미지나 비디오 같은 미디어 파일도 포스트 할 수 있어야함.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적인-설계안-제시-및-동의-구하기">개략적인 설계안 제시 및 동의 구하기&lt;/h3>
&lt;p>개략적인 설계안을 제시하고 면접관의 동의를 구할 때 면접관과 협력하며 진행하면 좋다.&lt;/p>
&lt;ul>
&lt;li>설계안에 대한 최초 청사진을 제시하고 의견을 구하라.
&lt;ul>
&lt;li>면접관을 마치 팀원인 것 처럼&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>화이트보드나 종이에 핵심 컴포넌트를 포함하는 다이어그램을 그려라.
&lt;ul>
&lt;li>클라이언트, API, 웹 서버, 데이터 저장소, 캐시, CDN, 메시지 큐 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>최초 설계안이 시스템 규모에 관계된 제약사항들을 만족하는지를 개략적으로 계산한다.
&lt;ul>
&lt;li>계산 과정은 소리 내어 설명한다.&lt;/li>
&lt;li>개략적 추정이 필요한지는 면접관에게 미리 물어본다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>가능하다면 시스템의 구체적 사용 사례도 몇 가지 살펴보면 고려하지 못한 에지 케이스를 발견하는 데도 도움이 될 것이다.&lt;/p>
&lt;p>&lt;strong>뉴스 피드 시스템 개략적 설계 예시&lt;/strong>&lt;/p>
&lt;p>개략적으로 보면 &lt;strong>피드 발행&lt;/strong>, &lt;strong>피드 생성&lt;/strong> 두 가지 처리 플로로 나눠 생각해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>피드 발행
&lt;ul>
&lt;li>사용자가 포스트를 올리면 관련된 데이터가 캐시/데이터베이스에 기록되고, 해당 사용자의 친구 뉴스 피드에 뜨게 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>피드 생성
&lt;ul>
&lt;li>사용자의 뉴스 피드는 해당 사용자 친구들의 포스트를 시간 역순으로 정렬하여 만든다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/3/img.png"
width="423"
height="690"
srcset="https://codemario318.github.io/post/system-design-interview/3/img_hu039827f8027f9a00b1371e9a94d12627_101123_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/3/img_hu039827f8027f9a00b1371e9a94d12627_101123_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="피드 발행"
class="gallery-image"
data-flex-grow="61"
data-flex-basis="147px"
>
&lt;img src="https://codemario318.github.io/post/system-design-interview/3/img_1.png"
width="370"
height="589"
srcset="https://codemario318.github.io/post/system-design-interview/3/img_1_hu4e33947bf61ce6fe45cda92442fd57d4_67943_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/3/img_1_hu4e33947bf61ce6fe45cda92442fd57d4_67943_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="피드 생성"
class="gallery-image"
data-flex-grow="62"
data-flex-basis="150px"
>&lt;/p>
&lt;h3 id="상세-설계">상세 설계&lt;/h3>
&lt;p>이 단계로 왔다면 아래 목표는 달성한 상태일 것이다.&lt;/p>
&lt;ul>
&lt;li>시스템에서 전반적으로 달성해야 할 목표와 가능 범위 확인&lt;/li>
&lt;li>전체 설계의 개략적 청사진 마련&lt;/li>
&lt;li>해당 청사진에 대한 면접관의 의견 청취&lt;/li>
&lt;li>상세 설계에서 집중해야 할 영역들 확인&lt;/li>
&lt;/ul>
&lt;p>이 단계에서는 면접관이 설계 대상 컴포넌트 사이의 우선순위를 정한다.&lt;/p>
&lt;p>대부분의 경우 면접관은 &lt;strong>특정 시스템 컴포넌트들의 세부사항을 깊이 있게 설명하는 것을 보길 원한다&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>단축 URL 생성기
&lt;ul>
&lt;li>해시 함수의 설계의 구체적인 내용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>채팅 시스템
&lt;ul>
&lt;li>어떻게하면 지연시간을 줄이고 사용자의 온/오프라인 상태를 표시할 것인지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위와 같은 경우 너무 과도하거나 불필요한 세부 사항을 설명하지 않는 것이 바람직하다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/3/img_2.png"
width="641"
height="725"
srcset="https://codemario318.github.io/post/system-design-interview/3/img_2_hu6034e7d7aae53ae4575eee71d3d0d535_164348_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/3/img_2_hu6034e7d7aae53ae4575eee71d3d0d535_164348_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="피드 발행 상세"
class="gallery-image"
data-flex-grow="88"
data-flex-basis="212px"
>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/3/img_3.png"
width="563"
height="566"
srcset="https://codemario318.github.io/post/system-design-interview/3/img_3_hu740b51119dfe66fb11a0bcd33bce86e0_132618_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/3/img_3_hu740b51119dfe66fb11a0bcd33bce86e0_132618_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="뉴스 피드 가져오기 상세"
class="gallery-image"
data-flex-grow="99"
data-flex-basis="238px"
>&lt;/p>
&lt;h3 id="마무리">마무리&lt;/h3>
&lt;p>마지막 단계에서 면접관은 설계 결과물에 관련된 몇 가지 후속 질문을 던질 수도 있고 스스로 추가 논의를 진행하도록 할 수도 있다.&lt;/p>
&lt;p>그럴때는 아래와 같은 내용들을 언급해보면 좋은 방향으로 마무리 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>면접관이 시스템 병목구간, 혹은 좀 더 개선 가능한 지점을 찾아내라 주문할 때
&lt;ul>
&lt;li>완벽하다거나 개선할 부분이 없다는 답은 X&lt;/li>
&lt;li>비판적 사고 능력을 보이고, 마지막으로 좋은 인상을 남길 기회이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>만든 설계를 한번 다시 요약해준다.
&lt;ul>
&lt;li>여러 해결책을 제시한 경우에는 특히 중요하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오류가 발생하면 무슨 일이 생기는지 따져본다.&lt;/li>
&lt;li>운영 이슈도 논의할 가치가 충분하다.
&lt;ul>
&lt;li>메트릭 수집, 모니터링, 로그, 배포 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>미래에 닥칠 규모 확장 요구에 어떻게 대처할 것인가?&lt;/li>
&lt;li>필요하지만 다루지 못했던 세부적 개선사항들을 제안할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>해야할 것&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>질문을 통해 확인하라. 스스로 내린 가정이 옳다 믿고 진행하지 말라.&lt;/li>
&lt;li>문제의 요구사항을 이해하라.&lt;/li>
&lt;li>정답이나 최선의 답안 같은 것은 없다는 점을 명심하라.&lt;/li>
&lt;li>면접관이 사고 흐름을 이해할 수 있도록 하라. 면접관과 소통하라.&lt;/li>
&lt;li>가능하다면 여러 해법을 함께 제시하라.&lt;/li>
&lt;li>개략적 설계에 면접관이 동의하면, 가장 중요한 컴포넌트부터 컴포넌트의 세부사항을 설명하기 시작하라.&lt;/li>
&lt;li>면접관의 아이디어를 이끌어내라. 좋은 면접관은 같은 팀원처럼 협력한다.&lt;/li>
&lt;li>포기하지 말라.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>하지 말아야 할 것&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>전형적인 면접 문제들에도 대비하지 않은 상태에서 면접장에 가지 말라.&lt;/li>
&lt;li>요구사항이나 가정들을 분명히 하지 않은 상태에서 설계를 제시하지 말라.&lt;/li>
&lt;li>처음부터 특정 컴포넌트의 세부사항을 너무 깊이 설명하지 말라. 개략적 설계를 마친 뒤 서부사항으로 나아가라.&lt;/li>
&lt;li>힌트를 청하기를 주저하지 말라.&lt;/li>
&lt;li>소통을 주저하지 말라. 침묵 속에 설계를 진행하지 말라.&lt;/li>
&lt;li>설계안을 내놓는 순간 면접이 끝난다고 생각하지 말라.&lt;/li>
&lt;li>의견을 일찍, 그리고 자주 구하라.&lt;/li>
&lt;/ul>
&lt;h2 id="시간-배분">시간 배분&lt;/h2>
&lt;p>시스템 설계 면접은 보통 매우 광범위한 영역을 다루기 때문에 시간이 충분하지 않을 수 있어 시관 관리를 잘 하는 것이 중요하다.&lt;/p>
&lt;p>대략적인 시간 분배는 아래와 같으며, 문제의 범위나 면접관의 요구사항에 따라 달라질 수 있다.&lt;/p>
&lt;ul>
&lt;li>문제 이해 및 설계 범위 확정: 3 ~ 10분&lt;/li>
&lt;li>개략적 설계안 제시 및 동의 구하기: 10 ~ 15분&lt;/li>
&lt;li>상세 설계: 10 ~ 25분&lt;/li>
&lt;li>마무리: 3 ~ 5분&lt;/li>
&lt;/ul></description></item><item><title>2. 개략적인 규모 추정</title><link>https://codemario318.github.io/post/system-design-interview/2/</link><pubDate>Tue, 30 Apr 2024 22:03:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/2/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/2/cover.png" alt="Featured image of post 2. 개략적인 규모 추정" />&lt;p>개략적인 규모 추정(back-of-the-envelope estimation)은 보편적으로 통용되는 성능 수치상에서 사고 실험(thought experiments)을 행하여 추정치를 계산하는 행위로서, 어떤 설계가 요구사항에 부합할 것인지 보기 위한 것이다.&lt;/p>
&lt;h2 id="2의-제곱수">2의 제곱수&lt;/h2>
&lt;p>분산 시스템에서 다루는 데이터 양은 매우 커질 수 있으나 계산법은 기본을 크게 벗어나지 않는다.&lt;/p>
&lt;p>제데로 된 계산 결과를 얻으려면 데이터 볼륨의 단위를 2의 제곱수로 표현하면 어떻게 되는지를 알아야한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>2의 x 제곱&lt;/th>
&lt;th>근사치&lt;/th>
&lt;th>이름&lt;/th>
&lt;th>축약형&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>10&lt;/td>
&lt;td>1천&lt;/td>
&lt;td>1킬로바이트&lt;/td>
&lt;td>1KB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>20&lt;/td>
&lt;td>1백만&lt;/td>
&lt;td>1메가바이트&lt;/td>
&lt;td>1MB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>30&lt;/td>
&lt;td>10억&lt;/td>
&lt;td>1기가바이트&lt;/td>
&lt;td>1GB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>40&lt;/td>
&lt;td>1조&lt;/td>
&lt;td>1테라바이트&lt;/td>
&lt;td>1TB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>50&lt;/td>
&lt;td>1000조&lt;/td>
&lt;td>1페타바이트&lt;/td>
&lt;td>1PB&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="모든-프로그래머가-알아야-하는-응답지연-값">모든 프로그래머가 알아야 하는 응답지연 값&lt;/h2>
&lt;p>구글의 제프 딘은 2010년에 &lt;strong>통상적인 컴퓨터에서 구현된 연산들의 응답지연 값&lt;/strong>을 공개한 바 있다.&lt;/p>
&lt;p>컴퓨터의 성능이 더 좋아지며 유효하진 않지만, 연산의 처리 속도가 어느정도인지 가늠해볼 수는 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>연산명&lt;/th>
&lt;th>시간&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>L1 캐시 참조&lt;/td>
&lt;td>0.5ns&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>분기 예측 오류(branch mispredict)&lt;/td>
&lt;td>5ns&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>L2 캐시 참조&lt;/td>
&lt;td>7ns&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>뮤텍스 락/언락&lt;/td>
&lt;td>100ns&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주 메모리 참조&lt;/td>
&lt;td>100ns&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Zippy로 1 KB 압축&lt;/td>
&lt;td>10,000ns = 10µs&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1 Gbps 네트워크로 2 KB 전송&lt;/td>
&lt;td>20,000ns = 20µs&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>메모리에서 1 MB 순차적으로 read&lt;/td>
&lt;td>250,000ns = 250µs&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>같은 데이터 센터 내에서의 메시지 왕복 지연 시간&lt;/td>
&lt;td>500,000ns = 500µs&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>디스크 탐색(seek)&lt;/td>
&lt;td>10,000,000ns = 10ms&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>네트워크에서 1 MB 순차적으로 read&lt;/td>
&lt;td>10,000,000ns = 10ms&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>디스크에서 1 MB 순차적으로 read&lt;/td>
&lt;td>30,000,000ns = 30ms&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>한 패킷의 캘리포니아로부터 네덜란드까지의 왕복 지연 시간&lt;/td>
&lt;td>150,000,000ns = 150ms&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>한 구글 엔지니어가 딘 박사가 나열한 수들을 시각화하였고, 최근 기술 동향(2020)이 반영되어있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/2/img.png"
width="606"
height="594"
srcset="https://codemario318.github.io/post/system-design-interview/2/img_hu0f7c2f161aa870801df5883ac4825f9d_187921_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/2/img_hu0f7c2f161aa870801df5883ac4825f9d_187921_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="102"
data-flex-basis="244px"
>&lt;/p>
&lt;p>이 수치들을 분석하면 다음과 같은 결론이 나온다.&lt;/p>
&lt;ul>
&lt;li>메모리는 빠르지만 디스크는 아직도 느리다.&lt;/li>
&lt;li>디스크 탐색(seek)는 가능한 한 피하라.&lt;/li>
&lt;li>단순한 압축 알고리즘은 빠르다.&lt;/li>
&lt;li>데이터를 인터넷으로 전송하기 전에 가능하면 압축하라.&lt;/li>
&lt;li>데이터 센터는 보통 여러 지역에 분산되어 있고, 센터들 간에 데이터를 주고받는 데는 시간이 걸린다.&lt;/li>
&lt;/ul>
&lt;h2 id="가용성에-관계된-수치들">가용성에 관계된 수치들&lt;/h2>
&lt;p>고가용성(high availability)은 시스템이 오랜 시간 동안 지속적으로 중단 없이 운영될 수 있는 능력을 지칭하는 용어다.&lt;/p>
&lt;p>고가용성을 표현하는 값은 퍼센트로 표현하는데, 100%는 시스템이 단 한 번도 중단된 적이 없었음을 의미하며, 대부분의 서비스는 99%에서 100% 사이의 값을 갖는다.&lt;/p>
&lt;p>SLA(Service Level Agreement)는 서비스 사업자(service provider)가 보편적으로 사용하는 용어로, &lt;strong>서비스 사업자와 고객 사이에 맺어진 합의&lt;/strong>를 의미한다.&lt;/p>
&lt;p>이 합의에는 서비스 사업자가 제공하는 서비스의 가용시간(uptime)이 공식적으로 기술되어 있다.&lt;/p>
&lt;p>가용시간은 관습적으로 숫자 9를 사용해 표시하며, 9가 많을수록 좋다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>가용률&lt;/th>
&lt;th>하루당 장애시간&lt;/th>
&lt;th>주당 장애시간&lt;/th>
&lt;th>개월당 장애시간&lt;/th>
&lt;th>연간 장애시간&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>99%&lt;/td>
&lt;td>14.40분&lt;/td>
&lt;td>1.68시간&lt;/td>
&lt;td>7.31시간&lt;/td>
&lt;td>3.65일&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>99.9%&lt;/td>
&lt;td>1.44분&lt;/td>
&lt;td>10.08분&lt;/td>
&lt;td>43.83분&lt;/td>
&lt;td>8,77시간&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>99.99%&lt;/td>
&lt;td>8.64초&lt;/td>
&lt;td>1.01분&lt;/td>
&lt;td>4.38분&lt;/td>
&lt;td>52.60분&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>99.999%&lt;/td>
&lt;td>864.00밀리초&lt;/td>
&lt;td>6.05초&lt;/td>
&lt;td>26.30&lt;/td>
&lt;td>5.26분&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>99.9999&lt;/td>
&lt;td>86.40밀리초&lt;/td>
&lt;td>604.80밀리초&lt;/td>
&lt;td>2.63초&lt;/td>
&lt;td>31.56초&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="예제-트위터-qps와-저장소-요구량-추정">예제: 트위터 QPS와 저장소 요구량 추정&lt;/h2>
&lt;p>&lt;strong>가정&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>월간 능동 사용자(monthly active user)는 3억(300million) 명이다.&lt;/li>
&lt;li>50%의 사용자가 트위터를 매일 사용한다.&lt;/li>
&lt;li>평균적으로 각 사용자는 매일 2건의 트윗을 올린다.&lt;/li>
&lt;li>미디어를 포함하는 트윗은 10% 정도다.&lt;/li>
&lt;li>데이터는 5년간 보관된다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>추정&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>QPS(Query Per Second) 추정치
&lt;ul>
&lt;li>일간 능동 사용자(Daily Active User, DAU) = 3억 * 0.5 = 1.5억&lt;/li>
&lt;li>QPS = 1.5억 * 2트윗 / 24시간 / 3600초 = 약 3500&lt;/li>
&lt;li>최대 QPS(Peek QPS) = 2 * QPS = 약 7000&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>미디어 저장을 위한 저장소 요구량
&lt;ul>
&lt;li>평균 트윗 크기
&lt;ul>
&lt;li>tweet_id에 64바이트&lt;/li>
&lt;li>텍스트에 140바이트&lt;/li>
&lt;li>미디어에 1MB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>미디어 저정소 요구량 = 1.5억 * 2 * 0.1 * 1MB = 30TB/일&lt;/li>
&lt;li>5년간 미디어를 보관하기 위한 저장소 요구량: 30TB * 365 * 5 = 약 55PB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="팁">팁&lt;/h2>
&lt;p>개략적인 규모 추정과 관계된 면접에서 가장 중요한 것은 &lt;strong>문제를 풀어 나가는 절차&lt;/strong>다.&lt;/p>
&lt;p>&lt;strong>올바른 절차를 밟느냐가 결과를 내는 것보다 중요&lt;/strong>하다.&lt;/p>
&lt;ul>
&lt;li>근사치를 활용한 계산(rounding and approximation):
&lt;ul>
&lt;li>적절한 근사치를 활용하여 시간을 절약하자.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가정(assumption)들은 적어 둔다.&lt;/li>
&lt;li>단위(unit)을 붙여라.
&lt;ul>
&lt;li>헷갈리게 되므로, 단위를 붙이는 습고나을 들여 모호함을 방지할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>QPS, 최대 QPS, 저장소 요구량, 캐시 요구량, 서버 수 등을 추정하는 것이 자주 출제된다.&lt;/li>
&lt;/ul></description></item><item><title>1. 사용자 수에 따른 규모 확장성</title><link>https://codemario318.github.io/post/system-design-interview/1/</link><pubDate>Mon, 22 Apr 2024 14:53:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/1/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/cover.png" alt="Featured image of post 1. 사용자 수에 따른 규모 확장성" />&lt;p>수백만 사용자를 지원하는 시스템을 설계하는 것은 도전적인 과제이며, 지속적인 계량과 끝없는 개선이 요구되는 여정이다.&lt;/p>
&lt;p>이번 장은 한 명의 사용자를 지원하는 시스템에서 시작하여, 최종적으로 몇백만 사용자를 지원하는 시스템을 설계해본다.&lt;/p>
&lt;h2 id="단일-서버">단일 서버&lt;/h2>
&lt;p>모든 컴포넌트가 단 한대의 서버에서 실행되는 간단한 시스템부터 설계해보자.&lt;/p>
&lt;p>웹 앱, 데이터베이스, 캐시 등이 전부 서버 한 대에서 실행된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img.png"
width="615"
height="390"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_hu499b8fa6fe43f3f924784d377eb4708e_41034_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_hu499b8fa6fe43f3f924784d377eb4708e_41034_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="157"
data-flex-basis="378px"
>&lt;/p>
&lt;p>&lt;strong>사용자 요청 처리 흐름&lt;/strong>&lt;br>
&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_1.png"
width="608"
height="382"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_1_hua0cbd5db31f0ad82b45addc6a6db9692_42287_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_1_hua0cbd5db31f0ad82b45addc6a6db9692_42287_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="159"
data-flex-basis="381px"
>&lt;/p>
&lt;ol>
&lt;li>사용자는 도메인 이름(api.mysite.com)을 이용하여 웹사이트에 접속한다. 이 접속을 위해 DNS에 질의하여 IP 주소로 변환하는 과정을 치게 된다.
&lt;ul>
&lt;li>DNS는 보통 서드 파티가 제공하는 유료 서비스를 이용하므로 시스템의 일부는 아니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DNS 조회 결과로 IP 주소가 반환된다.&lt;/li>
&lt;li>해당 IP 주소로 HTTP 요청이 전달된다.&lt;/li>
&lt;li>요청을 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환한다.&lt;/li>
&lt;/ol>
&lt;p>실제 요청은 웹 앱과 모바일 앱 두가지 종류에 단말로 부터 온다.&lt;/p>
&lt;ul>
&lt;li>웹 애플리케이션
&lt;ul>
&lt;li>비즈니스 로직, 데이터 저장 등을 처리하기 위해서 서버 구현용 언어(자바, 파이썬 등)를 사용한다.&lt;/li>
&lt;li>프레젠테이션 용으로는 클라이언트 구현용 언어(HTML, 자바스크립트 등)를 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모바일 앱
&lt;ul>
&lt;li>모바일 앱과 웹 서버 간 통신을 위해서는 HTTP 프로토콜을 이용한다.&lt;/li>
&lt;li>반환될 응답 데이터의 포맷으로는 보통 JSON이 널리 쓰인다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="데이터베이스">데이터베이스&lt;/h2>
&lt;p>사용자가 늘면 서버 하나로는 충분하지 않아서 여러 서버를 두어야 한다.&lt;/p>
&lt;ul>
&lt;li>웹/모바일 트래픽 처리&lt;/li>
&lt;li>데이터베이스&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_2.png"
width="612"
height="377"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_2_hub3bdf37c2a22d7f06e833db20a5f8b0a_53786_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_2_hub3bdf37c2a22d7f06e833db20a5f8b0a_53786_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="162"
data-flex-basis="389px"
>&lt;/p>
&lt;p>웹/모바일 트래픽 처리 서버(웹 계층)와 데이터베이스 서버(데이터 계층)를 분리하면 그 각각을 독립적으로 확장해 나갈 수 있게 된다.&lt;/p>
&lt;h3 id="어떤-데이터베이스를-사용할-것인가">어떤 데이터베이스를 사용할 것인가?&lt;/h3>
&lt;p>전통적인 관계형 데이터베이스와 비-관계형 데이터베이스 사이에서 고를 수 있다.&lt;/p>
&lt;ul>
&lt;li>관계형 데이터베이스
&lt;ul>
&lt;li>관계형 데이터베이스 관리 시스템(RDBMS)이라고도 부르며, 자료를 테이블과 열, 컬럼으로 표현한다.&lt;/li>
&lt;li>SQL을 사용하면 여러 테이블에 있는 데이터를 그 관계에 따라 조인(join)하여 합칠 수 있다.&lt;/li>
&lt;li>ex) MySQL, Oracle, PostgreSQL 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비-관계형 데이터 베이스
&lt;ul>
&lt;li>NoSQL이라고도 부른다.&lt;/li>
&lt;li>키-값 저장소(key-value store), 그래프 저장소(graph store), 컬럼 저장소(column store), 문서 저장소(document store) 네 부류로 나뉜다.&lt;/li>
&lt;li>비-관계형 데이터베이스는 일반적으로 조인 연산은 지원하지 않는다.&lt;/li>
&lt;li>ex) CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>대부분의 개발자에게는 40년 이상 시장에서 살아남아 잘 사용되어온 관계형 데이터베이스가 최선이다.&lt;/p>
&lt;p>하지만 구축하려는 시스템에 적합하지 않은 경우에는 관계형 데이터베이스 이외의 저장소도 살펴보아야한다.&lt;/p>
&lt;ul>
&lt;li>아주 낮은 응답 지연시간(latency)이 요구됨&lt;/li>
&lt;li>다루는 데이터가 비정형(unstructured)이라 관계형 데이터가 아님&lt;/li>
&lt;li>데이터(JSON, YAML, XML 등)를 직렬화하거나(serialize) 역직렬화(deserialize) 할 수 있기만 하면 됨&lt;/li>
&lt;li>아주 많은 양의 데이터를 저장할 필요가 있음&lt;/li>
&lt;/ul>
&lt;h2 id="수직적-규모-확장-vs-수평적-규모-확장">수직적 규모 확장 VS 수평적 규모 확장&lt;/h2>
&lt;h3 id="수직적-규모-확장vertical-scaling">수직적 규모 확장(vertical scaling)&lt;/h3>
&lt;p>&lt;strong>스케일 업(scale up)&lt;/strong> 이라고도 불리는 수직적 규모 확장 프로세스는 서버에 고사양 자원을 추가하는 행위를 말한다.&lt;/p>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>서버로 유입되는 트래픽의 양이 적을 때는 수직적 확장이 좋은 선택이다.&lt;/li>
&lt;li>단순하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법이 없어 한계가 있다.&lt;/li>
&lt;li>장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안을 제시하지 않는다.
&lt;ul>
&lt;li>서버에 장애가 발생하면 완전히 중단된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="수평적-규모-확장horizontal-scaling">수평적 규모 확장(horizontal scaling)&lt;/h3>
&lt;p>&lt;strong>스케일 아웃(scale out)&lt;/strong> 이라고도 불리는 수평적 규모 확장 프로세스는 더 많은 서버를 추가하여 성능을 개선하는 행위를 말한다.&lt;/p>
&lt;p>수직적 규모 확장에서 언급된 단점으로 인해 대규모 애플리케이션을 지원하는 데는 수평적 규모 확장법이 보다 적절하다.&lt;/p>
&lt;hr>
&lt;p>수평적 규모 확장을 위해 추가적인 장치가 필요하다.&lt;/p>
&lt;p>앞서 본 설계에서 사용자가 웹 서버로 바로 연결되는데,&lt;/p>
&lt;ul>
&lt;li>웹 서버가 다운되면 사용자는 웹 사이트에 접속할 수 없다.&lt;/li>
&lt;li>너무 많은 사용자가 접속하여 웹 서버가 한계에 도달하면 응답 속도가 느려지거나 서버 접속이 불가능해질 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이런 문제를 해결하는 데는 부하 분산기 또는 로드밸런서를 도입하는 것이 최선이다.&lt;/p>
&lt;h3 id="로드밸런서load-balancer">로드밸런서(Load balancer)&lt;/h3>
&lt;p>로드밸런서는 부하 분산 집합(load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_3.png"
width="608"
height="540"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_3_huf74bbc3ffd6647fb098a2fc03966306f_85207_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_3_huf74bbc3ffd6647fb098a2fc03966306f_85207_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="270px"
>&lt;/p>
&lt;ul>
&lt;li>사용자는 로드밸런서의 공개 IP 주소로 접속하므로, 웹 서버는 클라이언트의 접속을 직접 처리하지 않는다.&lt;/li>
&lt;li>보안을 위해 서버 간 통신에는 사설 IP 주소가 이용된다.
&lt;ul>
&lt;li>같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 IP 주소로, 인터넷을 통해서 접속할 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>부하 분산 집합에 또 하나의 웹 서버를 추가하고 나면, 장애를 자동복구하지 못하는 문제(no failover)는 해소되며, 웹 계층의 가용성(availability)은 향상된다.&lt;/p>
&lt;ul>
&lt;li>서버 1이 다운되면 모든 트래픽은 서버 2로 전송된다.
&lt;ul>
&lt;li>웹 사이트 전체가 다운되는 일이 방지된다.&lt;/li>
&lt;li>부하를 나누기 위해 새로운 서버를 추가할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹사이트로 유입되는 트래픽이 가파르게 증가할 경우 웹 서버 계층에 더 많은 서버를 추가하면 로드밸런스가 자동적으로 트래픽을 분산한다.&lt;/li>
&lt;/ul>
&lt;h3 id="데이터베이스-다중화">데이터베이스 다중화&lt;/h3>
&lt;p>많은 데이터베이스들이 주(master)-부(slave) 관계를 설정하여 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식으로 다중화를 지원한다.&lt;/p>
&lt;p>쓰기 연산은 마스터에만 지원하며, 부 데이터베이스는 주 데이터베이스로부터 그 사본을 전달받아 읽기 연산만을 지원한다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스를 변경하는 명령어(&lt;code>INSERT&lt;/code>, &lt;code>DELETE&lt;/code>, &lt;code>UPDATE&lt;/code> 등)는 주 데이터베이스로만 전달되어야 한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_4.png"
width="612"
height="546"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_4_hu75d2f6312382855c75a554918b468d43_102326_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_4_hu75d2f6312382855c75a554918b468d43_102326_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="269px"
>&lt;/p>
&lt;p>데이터베이스르 다중화하면 다음과 같은 이득이 있다.&lt;/p>
&lt;ul>
&lt;li>더 나은 성능
&lt;ul>
&lt;li>모든 데이터 변경 연산은 주 데이터베이스 서버로만 전달되는 반면 읽기 연산은 부 데이터베이스 서버들로 분산되어 병렬로 처리될 수 있는 질의(query)가 늘어나므로, 성능이 좋아진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>안정성
&lt;ul>
&lt;li>자연 재해 등의 이유로 데이터베이스 서버 가운데 일부가 파괴되어도 데이터는 보존된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성
&lt;ul>
&lt;li>데이터를 여러 지역에 복제해 둠으로써, 하나의 데이터베이스 서버에 장애가 발생하더라도 다른 서버에 있는 데이터로 계속 서비스할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위와 같은 데이터계층을 구성하면 데이터베이스 서버 가운데 하나가 다운되더라도 아래와 같은 상황을 감당할 수 있다.&lt;/p>
&lt;ul>
&lt;li>부 서버 한대뿐인데 다운된 경우
&lt;ul>
&lt;li>읽기 연산이 한시적으로 주 데이터베이스로 전달된다.&lt;/li>
&lt;li>즉시 새로운 부 데이터베이스 서버가 장애 서버를 대처한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>부 서버 중 한대가 다운된 경우
&lt;ul>
&lt;li>일기 연산이 나머지 부 데이터베이스 서버로 분산된다.&lt;/li>
&lt;li>새로운 부 데이터베이스 서버가 장애 서버를 대체한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>주 데이터베이스 서버가 다운된 경우
&lt;ul>
&lt;li>부 데이터베이스 서버 중 하나가 새로운 주 서버가 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="다중화를-고려한-설계">다중화를 고려한 설계&lt;/h3>
&lt;p>아래는 로드밸런서와 데이터베이스 다중화를 고려한 설계안이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_5.png"
width="615"
height="680"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_5_hu0d3cc45b151b2f2d78ede4b0a35c84d1_160088_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_5_hu0d3cc45b151b2f2d78ede4b0a35c84d1_160088_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="90"
data-flex-basis="217px"
>&lt;/p>
&lt;ol>
&lt;li>사용자는 DNS로부터 로드밸런서의 공개 IP 주소를 받는다.&lt;/li>
&lt;li>사용자는 해당 IP 주소를 사용해 로드밸런서에 접속한다.&lt;/li>
&lt;li>HTTP 요청은 서버 1이나 서버 2로 전달된다.&lt;/li>
&lt;li>웹 서버는 사용자의 데이터를 부 데이터베이스 서버에서 읽는다.&lt;/li>
&lt;li>웹 서버는 데이터 변경 연산은 주 데이터베이스로 전달한다.&lt;/li>
&lt;/ol>
&lt;h2 id="캐시-cache">캐시 Cache&lt;/h2>
&lt;p>캐시를 붙여 응답 시간(latency)를 개선해볼 수 있다.&lt;/p>
&lt;p>캐시는 &lt;strong>값비싼 연산 결과&lt;/strong> 또는 &lt;strong>자주 참조되는 데이터&lt;/strong>를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소이다.&lt;/p>
&lt;p>애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 크게 좌우되는데, 캐시는 그런 문제를 완화할 수 있다.&lt;/p>
&lt;h3 id="캐시-계층">캐시 계층&lt;/h3>
&lt;p>캐시 계층(cache tier)은 데이터가 잠시 보관되는 곳으로 데이터베이스보다 훨씬 빠르다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스보다 훨씬 빠르므로 성능이 개선된다.&lt;/li>
&lt;li>요청 분산으로 데이터베이스의 부하를 줄일 수 있다.&lt;/li>
&lt;li>캐시 계층의 규모를 독립적으로 확장시키는 것도 가능해진다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_6.png"
width="613"
height="116"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_6_huc62d7a17723bf3e18e1d3339b357022d_33317_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_6_huc62d7a17723bf3e18e1d3339b357022d_33317_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="528"
data-flex-basis="1268px"
>&lt;/p>
&lt;p>요청받은 웹 서버는 캐시에 응답이 저장되어 있는지를 확인 후 저장되어 있다면 해당 데이터 반환하고 없을 경우 데이터베이스 조회하여 결과를 반환하는데, 이러한 캐시 전략을 &lt;strong>읽기 주도형 캐시 전략(read-through caching strategy)&lt;/strong> 이라고 부른다.&lt;/p>
&lt;p>이외에도 다양한 캐시 전략이 있으며, 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 선택하면 된다.&lt;/p>
&lt;ul>
&lt;li>쓰기 주도형 캐시 전략 (Write-Through Cache)
&lt;ul>
&lt;li>데이터를 업데이트할 때 캐시와 백엔드 데이터 소스 모두에 동시에 업데이트&lt;/li>
&lt;li>데이터 일관성을 유지하면서 쓰기 작업을 처리&lt;/li>
&lt;li>쓰기 작업의 경우 백엔드 저장소로의 추가적인 I/O 작업이 필요하므로 성능 저하의 가능성이 있지만, 데이터 일관성을 보장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>쓰기 지연형 캐시 전략 (Write-Behind Cache)
&lt;ul>
&lt;li>데이터 업데이트를 먼저 캐시에만 적용하고, 나중에 백엔드 데이터 소스에 업데이트를 적용&lt;/li>
&lt;li>이는 쓰기 작업의 지연을 최소화하여 응답 시간을 줄이는 데 도움&lt;/li>
&lt;li>쓰기 지연형 캐시는 데이터 일관성을 유지하기 위해 추가적인 메커니즘을 필요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>자세한 내용의 캐시 전략 (Write-Through and Read-Through Cache):
&lt;ul>
&lt;li>읽기와 쓰기 모두에 대해 캐시를 사용하는 전략&lt;/li>
&lt;li>데이터가 요청될 때마다 읽기 주도형 캐시와 유사하게 작동하며, 데이터가 업데이트될 때마다 쓰기 주도형 캐시와 유사한 방식으로 작동&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>캐시 앞 단의 캐시 전략 (Cache-Aside Cache):
&lt;ul>
&lt;li>클라이언트가 데이터를 직접 캐시에 저장하고 검색하는 방식&lt;/li>
&lt;li>캐시에 데이터가 없는 경우 클라이언트는 백엔드 데이터 소스에서 직접 데이터를 가져와서 캐시에 저장하고 응답&lt;/li>
&lt;li>이 방식은 간단하고 유연하며, 응용 프로그램 코드 내에 캐시 로직을 명시적으로 구현할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이중 캐시 전략 (Two-Level Cache):
&lt;ul>
&lt;li>두 개의 캐시 레이어를 사용하여 성능을 최적화&lt;/li>
&lt;li>보통 두 개의 캐시는 크기와 접근 속도 등에서 차이가 있음&lt;/li>
&lt;li>먼저 작은 고속 캐시가 데이터를 저장하고, 그 다음에 큰 용량의 캐시가 데이터를 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오프힙 로컬 캐시 전략 (Off-Heap Local Cache Strategy):
&lt;ul>
&lt;li>캐시를 메모리 외의 오프힙(Off-Heap) 영역에 저장하여 자바 가상 머신의 힙 메모리 한계를 초과하는 데이터 양을 처리할 수 있게 함&lt;/li>
&lt;li>이는 대규모 캐시나 대용량 데이터를 다룰 때 유용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="캐시-사용-시-유의할-점">캐시 사용 시 유의할 점&lt;/h3>
&lt;ul>
&lt;li>데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어나는 경우 고려할 수 있다.&lt;/li>
&lt;li>캐시는 데이터를 휘발성 메모리에 두므로, 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다.&lt;/li>
&lt;li>데이터를 무기한 보존할 수 없으므로 만료에 대한 정책을 마련해야한다.
&lt;ul>
&lt;li>너무 짧으면 데이터베이스 읽기가 자주 발생한다.&lt;/li>
&lt;li>너무 길면 원본과 차이 날 가능성이 높아진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 일관성이 깨질 수 있다.&lt;/li>
&lt;li>캐시 서버를 한 대만 두는 경우 해당 서버가 단일 장애 지점(Single Point of Failure, SPOF)이 되어버릴 가능성이 있다.
&lt;ul>
&lt;li>여러 지역에 걸처 캐시 서버를 분산시켜야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>캐시 메모리가 너무 작으면 액세스 패턴에 따라 데이터가 자주 캐시에서 밀려나 성능이 떨어지게 된다.
&lt;ul>
&lt;li>캐시 메모리를 과할당하면 데이터가 갑자기 늘어났을 때 생길 문제를 방지할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>캐시가 가득 찼을 때 추가로 데이터를 넣기 위한 데이터 방출 정책을 적절히 지정해야한다.
&lt;ul>
&lt;li>가장 널리 쓰이는 것은 LRU(least Recently Used - 가장 오래 사용 안된 데이터)나 FIFO(가장 먼저 들어온) 등이 있으며 경우에 맞게 적용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="콘텐츠-전송-네트워크-cdn">콘텐츠 전송 네트워크 CDN&lt;/h2>
&lt;p>응답 시간을 개선할 방법으로 CDN(Content Delivery Network)를 적용해 볼 수 있다.&lt;/p>
&lt;p>CDN은 정적 콘텐츠를 전성하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크이다. (이미지, 비디오, CSS, JS 파일 등)&lt;/p>
&lt;ul>
&lt;li>요청 경로, 질의 문자열, 쿠키, 요청 헤더 등의 정보에 기반하여 HTML을 캐싱하는 &lt;strong>동적 콘텐츠 캐싱&lt;/strong>도 적용해 볼 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_7.png"
width="605"
height="231"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_7_hu799239a592ed42b7290231250760d8ad_30988_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_7_hu799239a592ed42b7290231250760d8ad_30988_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="261"
data-flex-basis="628px"
>&lt;/p>
&lt;p>어떤 사용자 웹 사이트를 방문하면, 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달하며, 사용자가 CDN 서버로부터 멀어질 수록 천천히 로드될 것이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_8.png"
width="612"
height="218"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_8_hu5d5fc61be434c460205659abbfd7acf0_63071_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_8_hu5d5fc61be434c460205659abbfd7acf0_63071_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="280"
data-flex-basis="673px"
>&lt;/p>
&lt;ol>
&lt;li>사용자 A가 이미지 URL을 이용해 &lt;code>image.png&lt;/code>에 접근한다.(URL의 도메인은 CDN 서비스 사업자가 제공한다.)&lt;/li>
&lt;li>CDN 서버의 캐시에 해당 이미지가 없는 경우 원본 서버에서 요청하여 파일을 가져온다.&lt;/li>
&lt;li>원본 서버가 파일을 CDN 서버에 반환한다.
&lt;ul>
&lt;li>응답 HTTP 헤더에 TTL(Time-To-Live) 값을 넣어 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CDN 서버는 파일을 캐시하고 사용자 A에게 반환한다.
&lt;ul>
&lt;li>이미지는 TTL에 명신된 시간이 끝날 때 까지만 캐시된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자 B가 같은 이미지를 CDN 서버에게 요청한다.&lt;/li>
&lt;li>만료되지 않은 이미지에 대한 요청은 캐시를 통해 처리된다.&lt;/li>
&lt;/ol>
&lt;h3 id="cdn-사용-시-고려해야-할-사항">CDN 사용 시 고려해야 할 사항&lt;/h3>
&lt;ul>
&lt;li>비용
&lt;ul>
&lt;li>CDN은 보통 서드파티에 의해 운영되며, CDN으로 들어가고 나가는 데이터 전송 양에 따라 요금을 낸다.&lt;/li>
&lt;li>자주 사용되지 않는 콘텐츠를 캐싱하는 것은 이득이 적으므로, CDN에서 빼는 것을 고려할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>적절한 만료 시한 설정
&lt;ul>
&lt;li>시의성이 중요한(time-sensitive) 콘텐츠는 만료 시점을 잘 정해야한다.&lt;/li>
&lt;li>너무 길면 콘텐츠의 신선도가 떨어진다.&lt;/li>
&lt;li>너무 짧으면 원본 서버에 빈번히 접속되어 좋지 않다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CDN 장애 대처 방안
&lt;ul>
&lt;li>CDN 자체가 죽었을 경우 애플리케이션이 어떻게 동작해야 하는지 고려해야 한다.&lt;/li>
&lt;li>응답을 감지하여 원본 서버에서 가져오는 등의 방식으로 처리한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>콘텐츠 무효화 방법
&lt;ul>
&lt;li>만료되지 않은 콘텐츠라도 CDN에서 제거할 수 있다.&lt;/li>
&lt;li>CDN 서비스 사업자가 제공하는 API 활용&lt;/li>
&lt;li>콘텐츠의 다른 버전을 서비스 하도록 오브젝트 버저닝 이용.
&lt;ul>
&lt;li>&lt;code>image.png?v=2&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="cdn과-캐시가-추가된-설계">CDN과 캐시가 추가된 설계&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_9.png"
width="625"
height="670"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_9_hu460b71978870d67db3c5f1597124e471_170383_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_9_hu460b71978870d67db3c5f1597124e471_170383_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="93"
data-flex-basis="223px"
>&lt;/p>
&lt;ol>
&lt;li>정적 콘텐츠를 CDN을 통해 제공하여 더 나은 성능을 보장한다.&lt;/li>
&lt;li>캐시가 데이터베이스 부하를 줄여준다.&lt;/li>
&lt;/ol>
&lt;h2 id="무상태stateless-웹-계층">무상태(Stateless) 웹 계층&lt;/h2>
&lt;p>웹 계층을 수평적으로 확장하는 방법을 고민해 볼 수 있다.&lt;/p>
&lt;p>이를 위해 상태 정보(사용자 세션 등)를 웹 계층에서 제거해야한다.&lt;/p>
&lt;p>바람직한 전략은 상태 정보를 관계형 데이터베이스나 NoSQL 같은 지속성 저장소에 보관하고, 필요할 때 가져오도록 하는 것이다.&lt;/p>
&lt;p>이렇게 구성된 웹 계층을 &lt;strong>무상태 웹 계층&lt;/strong>이라 부른다.&lt;/p>
&lt;h3 id="상태-정보-의존적인-아키텍처">상태 정보 의존적인 아키텍처&lt;/h3>
&lt;p>상태 정보를 보고나하는 서버는 클라이언트 정보, 즉 상태를 유지하여 요청들 사이에 공유되도록 하지만, 무상태 서버에는 이러한 장치가 없다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_10.png"
width="624"
height="387"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_10_hu5fb9397f4d4b70e8494c0677a4642dc6_65604_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_10_hu5fb9397f4d4b70e8494c0677a4642dc6_65604_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="161"
data-flex-basis="386px"
>&lt;/p>
&lt;p>위와 같은 경우 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야 한다.&lt;/p>
&lt;p>로드밸런서가 이를 지원하기 위해 고정 세션이라는 기능을 제공하지만, 이는 로드밸런서에 부담을 줄 수 있다.&lt;/p>
&lt;p>또한 로드 밸런서 뒷단에 서버를 추가하거나 제거하기도 까다로워지며, 이들 서버의 장애를 처리하기도 복잡해진다.&lt;/p>
&lt;h3 id="무상태-아키텍처">무상태 아키텍처&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_11.png"
width="601"
height="582"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_11_hu39f308bbb91eb0dc2a5c19d7114ea62c_76175_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_11_hu39f308bbb91eb0dc2a5c19d7114ea62c_76175_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="103"
data-flex-basis="247px"
>&lt;/p>
&lt;p>무상태 아키텍처는 사용자로부터의 HTTP 요청은 어떤 웹 서버로도 전달될 수 있다.&lt;/p>
&lt;p>웹 서버는 상태 정보가 필요할 경우 물리적으로 분리된 공유 저장소로부터 데이터를 가져온다.&lt;/p>
&lt;h3 id="무상태-웹-계층을-갖는-설계">무상태 웹 계층을 갖는 설계&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_12.png"
width="592"
height="593"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_12_hu8a96a4f1289cdc64fec7a7b4b0f65b88_150815_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_12_hu8a96a4f1289cdc64fec7a7b4b0f65b88_150815_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="99"
data-flex-basis="239px"
>&lt;/p>
&lt;ul>
&lt;li>세션 데이터를 웹 계층에서 분리하고 지속성 데이터 보관소에 저장하도록 만들었다.
&lt;ul>
&lt;li>공유 저장소는 관계형 데이터베이스일 수도 있고, 캐시일 수도 있으며, NoSQL일 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>상태 정보가 웹 서버들로부터 제거되었으므로 자동으로 규모를 확장할 수 있다.&lt;/li>
&lt;/ul>
&lt;h2 id="데이터-센터">데이터 센터&lt;/h2>
&lt;p>애플리케이션의 사용자가 매우 많다면 가용성을 높이고 쾌적하게 사용할 수 있도록 하기 위해 여러 데이터 센터를 지원하는 것이 필수적이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_13.png"
width="605"
height="612"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_13_huacec91b27a2e95c1fae44550dc9946c4_231088_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_13_huacec91b27a2e95c1fae44550dc9946c4_231088_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="98"
data-flex-basis="237px"
>&lt;/p>
&lt;p>&lt;strong>지리적 라우팅&lt;/strong>&lt;/p>
&lt;p>장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내되는데 이 절차를 지리적 라우팅(geoDNS-routing 또는 geo-routing)이라고 부른다.&lt;/p>
&lt;p>geoDNS는 사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변활할지 결정할 수 있도록 해주는 DNS 서비스다.&lt;/p>
&lt;p>&lt;strong>데이터 센터 장애&lt;/strong>&lt;/p>
&lt;p>데이터 센터 중 하나에 심각한 장애가 발생하면 모든 트래픽은 장애가 없는 데이터 센터로 전송된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_14.png"
width="598"
height="619"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_14_huae6b76823045f17d81dcfd1753a37701_207085_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_14_huae6b76823045f17d81dcfd1753a37701_207085_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="96"
data-flex-basis="231px"
>&lt;/p>
&lt;p>이에 따라 다중 데이터센터 아키텍처를 만들려면 몇 가지 기술적 난제를 해결해야 한다.&lt;/p>
&lt;ul>
&lt;li>트래픽 우회
&lt;ul>
&lt;li>올바른 데이터센터로 트래픽을 보내는 효과적인 방법을 찾아야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 동기화(Synchronization)
&lt;ul>
&lt;li>데이터를 여러 데이터센터에 걸쳐 다중화 하여, 장애 복구 시에도 데이터를 동기화 할 수 있도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>테스트와 배포
&lt;ul>
&lt;li>여러 데이터 센터를 사용하도록 시스템이 구성된 상황이라면 웹 사이트 또는 애플리케이션을 여러 위치에서 테스트 해보는 것이 중요하다.&lt;/li>
&lt;li>자동화된 배포 도구는 모든 데이터 센터에 동일한 서비스가 설치되도록 하는 데 중요한 일을 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="메시지-큐message-queue">메시지 큐(Message Queue)&lt;/h2>
&lt;p>시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하여, 각기 독립적으로 확장될 수 있어야 한다.&lt;/p>
&lt;p>메시지 큐는 분산 시스템이 이 문제를 풀기 위해 채용하고 있는 핵심 전략 가운데 하나다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_15.png"
width="606"
height="141"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_15_huc34a000f73eb7366f54fab25c10cd600_37954_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_15_huc34a000f73eb7366f54fab25c10cd600_37954_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="429"
data-flex-basis="1031px"
>&lt;/p>
&lt;p>메시지 큐는 메시지의 무손실을 보장하는 비동기 통신을 지원하는 컴포넌트로 메시지의 버퍼 역할을 하며, 비동기적으로 전송한다.&lt;/p>
&lt;ol>
&lt;li>생산자 또는 발행자라고 불리는 입력 서비스가 메시지를 만들어 메시지 큐에 발행한다.&lt;/li>
&lt;li>소비자 혹은 구독자라 불리는 서비스 혹은 서버가 메시지를 받아 그에 맞는 동작을 수행한다.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>메시지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해져서, 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.&lt;/p>
&lt;ul>
&lt;li>생산자는 소비자 프로세스가 다운되어 있어도 메시지를 발행할 수 있다.&lt;/li>
&lt;li>소비자는 생산자 서비스가 가용한 상태가 아니더라도 메시지를 수신할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>큐가 커지면 더 많은 작업 프로세스를 추가해야 처리 시간을 줄일 수 있으며, 큐가 거의 항상 비어있는 상태라면, 작업 프로세스의 수를 줄일 수 있다.&lt;/p>
&lt;h2 id="로그-메트릭-그리고-자동화">로그, 메트릭 그리고 자동화&lt;/h2>
&lt;p>웹 사이트와 함께 사업 규모가 커지고 나면, 로그나 메트릭, 자동화 같은 도구에 필수적으로 투자해야한다.&lt;/p>
&lt;ul>
&lt;li>로그
&lt;ul>
&lt;li>시스템의 오류와 문제들을 쉽게 찾아낼 수 있게 돕는다.&lt;/li>
&lt;li>로그를 단일 서비스로 모아주는 도구를 활용하면 더 편리하게 검색하고 조회할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메트릭
&lt;ul>
&lt;li>사업 현황에 관한 유용한 정보를 얻을 수도 있고, 시스템의 현재 상태를 쉽게 파악할 수 있다.&lt;/li>
&lt;li>호스트 단위 메트릭: CPU, 메모리, 디스크 I/O,에 관한 메트릭&lt;/li>
&lt;li>종합 메트릭: 데이터베이스 계층의 성능, 캐시 계층의 성능 등&lt;/li>
&lt;li>핵심 비즈니스 메트릭: 일별 능동 사용자, 수익, 재방문 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>자동화
&lt;ul>
&lt;li>시스템이 크고 복잡해지면 생산성을 높이기 위해 자동화 도구를 활용해야한다.&lt;/li>
&lt;li>지속적 통합을 활용한 검증 절차 수행 및 빌드, 테스트, 배포 절차 자동화 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="수정한-설계안">수정한 설계안&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_16.png"
width="595"
height="741"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_16_hu91dcf9847683962bf50eb168546423cd_177817_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_16_hu91dcf9847683962bf50eb168546423cd_177817_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="80"
data-flex-basis="192px"
>&lt;/p>
&lt;ul>
&lt;li>메시지 큐는 각 컴포넌트가 보다 느슨히 결합될 수 있도록 하고, 결함에 대한 내성을 높인다.&lt;/li>
&lt;li>로그, 모니터링, 메트릭, 자동화 등을 지원하기 위한 장치를 추가한다.&lt;/li>
&lt;/ul>
&lt;h2 id="데이터베이스-규모-확장">데이터베이스 규모 확장&lt;/h2>
&lt;p>저장할 데이터가 많아지면 데이터베이스에 대한 부하도 증가한다.&lt;/p>
&lt;p>데이터베이스의 규모를 확장하는데는 앞서 언급했던 수직적 규모 확장과 수평적 규모 확장을 고려할 수 있다.&lt;/p>
&lt;p>&lt;strong>수평적 확장&lt;/strong>&lt;/p>
&lt;p>기존 서버에 더 많은, 고성능의 자원을 증설하는 방법이다.&lt;/p>
&lt;p>스택오버플로는 천만 명의 사용자 전부를 단 한 대의 마스터 데이터베이스로 처리했다.&lt;/p>
&lt;p>하지만 언급했던대로 몇가지 심각한 약점이 있다.&lt;/p>
&lt;ul>
&lt;li>무한 증설할 수는 없다.&lt;/li>
&lt;li>SPOF로 인한 위험성이 크다.&lt;/li>
&lt;li>비용이 많이 든다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>수평적 확장&lt;/strong>&lt;/p>
&lt;p>데이터베이스의 수평적 확장은 샤딩(sharding)이라고도 부르는데, 더 많은 서버를 추가함으로써 성능을 향상시킬 수 있도록 한다.&lt;/p>
&lt;h3 id="샤딩">샤딩&lt;/h3>
&lt;ul>
&lt;li>대규모 데이터베이스를 샤드(shard)라고 부르는 작은 단위로 분할하는 기술을 일컫는다.&lt;/li>
&lt;li>모든 샤드는 같은 스키마를 쓰지만 보관되는 데이터 사이에는 중복이 없다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_17.png"
width="369"
height="266"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_17_huc997d539c0fa3f28c4bae7dad9a2068b_33539_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_17_huc997d539c0fa3f28c4bae7dad9a2068b_33539_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="138"
data-flex-basis="332px"
>&lt;/p>
&lt;p>위의 예시에서 &lt;code>user_id % 4&lt;/code>를 해시 함수로 사용하여 데이터가 보관되는 샤드를 정한다.&lt;/p>
&lt;p>이처럼 샤딩 전략을 구현할 때 고려해야 할 가장 중요한 것은 &lt;strong>샤딩 키&lt;/strong>를 어떻게 정하냐 하는 것이다.&lt;/p>
&lt;ul>
&lt;li>샤딩 키(파티션 키)는 데이터가 어떻게 분살될지 정하는 하나 이상의 컬럼으로 구성된다.&lt;/li>
&lt;li>샤딩 키를 통해 올바른 데이터베이스에 질의를 보내어 데이터 조회나 변경을 처리하므로 효율을 높일 수 있다.&lt;/li>
&lt;/ul>
&lt;p>샤딩 키를 정할 때는 데이터를 고르게 분할 할 수 있도록 하는 게 가장 중요하다.&lt;/p>
&lt;p>&lt;strong>주의사항&lt;/strong>&lt;/p>
&lt;p>샤딩은 데이터베이스 규모 확장을 실현하는 휼륭한 기술이지만 완벽하지 않으며, 도입하면 시스템이 복잡해지고 풀어야 할 새로운 문제도 생긴다.&lt;/p>
&lt;ul>
&lt;li>데이터의 재 샤딩
&lt;ul>
&lt;li>데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어려울 때&lt;/li>
&lt;li>샤드 소진: 샤드 간 데이터 분포가 균등하지 못하여 어떤 샤드에 할당된 공간 소모가 다른 사드에 비해 빨리 진행될 때&lt;/li>
&lt;li>이러한 형상이 발생하면 샤드 키를 계산하는 함수를 변경하고 데이터를 재배치 하여야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유명인사 문제(핫스팟 키 문제)
&lt;ul>
&lt;li>특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제다.&lt;/li>
&lt;li>특정 샤드의 원인에 대해 샤드를 하나씩 할당해야 할 수도 있고, 더 잘개 쪼개야 할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>조인과 비정규화
&lt;ul>
&lt;li>데이터베이스를 여러 샤드 서버로 쪼개고 나면, 여러 샤드에 걸친 데이터를 조인하기가 힘들어진다.&lt;/li>
&lt;li>데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="샤드를-적용한-아키텍처">샤드를 적용한 아키텍처&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_18.png"
width="643"
height="800"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_18_hu3cfaabe2145c01222e45ae94975b52ee_217530_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_18_hu3cfaabe2145c01222e45ae94975b52ee_217530_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="80"
data-flex-basis="192px"
>&lt;/p>
&lt;ul>
&lt;li>데이터베이스에 대한 부하를 줄이기 위해 굳이 관계형 데이터베이스가 요구되지 않는 기능들은 NoSQL로 이전할 수 있다.&lt;/li>
&lt;/ul>
&lt;h2 id="백만-사용자-그리고-그-이상">백만 사용자, 그리고 그 이상&lt;/h2>
&lt;p>시스템의 규모를 확장하는 것은 지속적이고 반복적인 과정이며, 이번 장에서 다룬 내용을 반복하다 보면 원하는 규모의 시스템을 달성할 수 있게 된다.&lt;/p>
&lt;p>그러나 수백만 사용자 이상을 지원하려면 새로운 전략을 도입해야 하고 지속적으로 시스템을 가다듬어야 할 것이다.&lt;/p>
&lt;ul>
&lt;li>시스템 최적화 및 마이크로서비스 등&lt;/li>
&lt;/ul>
&lt;h2 id="정리">정리&lt;/h2>
&lt;ul>
&lt;li>웹 계층은 무상태 계층으로&lt;/li>
&lt;li>모든 계층에 다중화 도입&lt;/li>
&lt;li>가능한 한 많은 데이터를 캐시할 것&lt;/li>
&lt;li>여러 데이터 센터를 지원할 것&lt;/li>
&lt;li>정적 콘텐츠는 CDN을 통해 서비스할 것&lt;/li>
&lt;li>데이터 계층은 샤딩을 통해 그 규모를 확장할 것&lt;/li>
&lt;li>각 계층은 독립적 서비스로 분할할 것&lt;/li>
&lt;li>시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것&lt;/li>
&lt;/ul></description></item></channel></rss>