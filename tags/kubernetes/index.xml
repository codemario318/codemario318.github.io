<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kubernetes on Mario Blog</title><link>https://codemario318.github.io/tags/kubernetes/</link><description>Recent content in Kubernetes on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Fri, 21 Apr 2023 13:57:47 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/kubernetes/index.xml" rel="self" type="application/rss+xml"/><item><title>쿠버네티스: 4. 쿠버네티스 오브젝트 관리</title><link>https://codemario318.github.io/post/kubernetes_4/</link><pubDate>Fri, 21 Apr 2023 13:57:47 +0900</pubDate><guid>https://codemario318.github.io/post/kubernetes_4/</guid><description>&lt;img src="https://codemario318.github.io/post/kubernetes_4/kubernetes_cover.webp" alt="Featured image of post 쿠버네티스: 4. 쿠버네티스 오브젝트 관리" />&lt;h2 id="관리기법">관리기법&lt;/h2>
&lt;blockquote>
&lt;p>⛔ 쿠버네티스 오브젝트는 하나의 기법만 사용하여 관리해야 한다. 동일한 오브젝트에 대해 여러 기법을 혼용하면 오동작이 발생할 수 있다.&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>관리기법&lt;/th>
&lt;th>대상&lt;/th>
&lt;th>권장 환경&lt;/th>
&lt;th>지원하는 작업자 수&lt;/th>
&lt;th>학습 난이도&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>명령형 커맨드&lt;/td>
&lt;td>활성 오브젝트&lt;/td>
&lt;td>개발 환경&lt;/td>
&lt;td>1+&lt;/td>
&lt;td>낮음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>명령형 오브젝트 구성&lt;/td>
&lt;td>개별 파일&lt;/td>
&lt;td>프로덕션 환경&lt;/td>
&lt;td>1&lt;/td>
&lt;td>보통&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>선언형 오브젝트 구성&lt;/td>
&lt;td>파일이 있는 디렉터리&lt;/td>
&lt;td>프로덕션 환경&lt;/td>
&lt;td>1+&lt;/td>
&lt;td>높음&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="명령형-커맨드">명령형 커맨드&lt;/h2>
&lt;p>사용자가 클러스터 내 활성 오브젝트를 대상으로 직접 동작시킨다. 실행할 작업을 인수 또는 플래그로 kubectl 커맨드에 지정한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">kubectl create deployment nginx --image nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="트레이드-오프">트레이드 오프&lt;/h3>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>커맨드는 하나의 동작을 나타내는 단어로 표현됨&lt;/li>
&lt;li>클러스터를 수정하기 위해 단 하나의 단계만을 필요로 한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>커맨드는 변경 검토 프로세스와 통합되지 않는다.&lt;/li>
&lt;li>변경에 관한 감사 추적(audit trail)을 제공하지 않는다.&lt;/li>
&lt;li>활성 동작 중인 경우를 제외하고는 레코드의 소스를 제공하지 않는다.&lt;/li>
&lt;li>새로운 오브젝트 생성을 위한 템플릿을 제공하지 않는다.&lt;/li>
&lt;/ul>
&lt;h2 id="명령형-오브젝트-구성">명령형 오브젝트 구성&lt;/h2>
&lt;p>kubectl 커맨드로 작업, 선택적 플래그, 파일 이름을 지정하여 실행한다.&lt;/p></description></item><item><title>쿠버네티스: 3. 쿠버네티스 오브젝트 이해하기</title><link>https://codemario318.github.io/post/kubernetes_3/</link><pubDate>Fri, 21 Apr 2023 13:53:47 +0900</pubDate><guid>https://codemario318.github.io/post/kubernetes_3/</guid><description>&lt;img src="https://codemario318.github.io/post/kubernetes_3/kubernetes_cover.webp" alt="Featured image of post 쿠버네티스: 3. 쿠버네티스 오브젝트 이해하기" />&lt;blockquote>
&lt;p>쿠버네티스 오브젝트는 &lt;strong>하나의 의도를 담은 레코드&lt;/strong>이다.&lt;/p>
&lt;/blockquote>
&lt;p>쿠버네티스 오브젝트는 쿠버네티스 시스템에서 영속성을 가지는 오브젝트이다. 쿠버네티스는 클러스터의 상태를 나타내기 위해 &lt;code>.yaml&lt;/code>로 작성된 오브젝트에 상세 내용을 기술한다.&lt;/p>
&lt;ul>
&lt;li>어떤 컨테이너화된 애플리케이션이 동작 중인지(어느 노드에서 동작중인지)&lt;/li>
&lt;li>해당 어플리케이션이 이용할 수 있는 리소스&lt;/li>
&lt;li>해당 애플리케이션이 어떻게 재구동 정책,&lt;/li>
&lt;li>업그레이드&lt;/li>
&lt;li>내고장성과 같은 것에 동작해야 하는지에 대한 정책&lt;/li>
&lt;/ul>
&lt;p>오브젝트를 생성하게 되면, 쿠버네티스 시스템은 오브젝트에 담긴 상태를 보장하기 위해 지속적으로 동작하게 된다.&lt;/p>
&lt;h2 id="오브젝트-명세spec과-상태status">오브젝트 명세(spec)과 상태(status)&lt;/h2>
&lt;p>거의 모든 쿠버네티스 오브젝트는 spec 오브젝트와 status 오브젝트로 구성된다.&lt;/p>
&lt;h3 id="spec">spec&lt;/h3>
&lt;p>spec을 가지는 오브젝트는 오브젝트를 생성할 때 리소스에 원하는 특징(의도한 상태)에 대한 설명을 제공하여 설정한다.&lt;/p>
&lt;h3 id="status">status&lt;/h3>
&lt;p>쿠버네티스 시스템과 컴포넌트에 의해 제공되고 업데이트된 오브젝트의 현재 상태를 설명한다.
컨트롤 플레인은 모든 오브젝트의 실제 상태를 사용자가 의도한 상태와 일치시키기 위해서 끊임없이 능독적으로 관리한다.&lt;/p>
&lt;p>&lt;a class="link" href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="noopener"
>https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md&lt;/a>&lt;/p>
&lt;h2 id="쿠버네티스-오브젝트-기술하기">쿠버네티스 오브젝트 기술하기&lt;/h2>
&lt;p>쿠버네티스에서 오브젝트를 생성할 때, 오브젝트에 대한 기본적인 정보와 더불어, 의도한 상태를 기술한 오브젝트 spec을 제시해야 한다.&lt;/p>
&lt;p>대부분의 경우 정보를 .yaml 파일로 kubectl에 제공한다. kubectl은 API 요청이 이루어질 때, JSON 형식으로 정보를 변환시켜준다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx-deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># tells deployment to run 2 pods matching the template&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx:1.14.2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="요구되는-필드">요구되는 필드&lt;/h3>
&lt;p>생성하고자 하는 쿠버네티스 오브젝트에 대한 &lt;code>.yaml&lt;/code> 파일 내, 다음 필드를 윟나 값들을 설정해 줘야한다.&lt;/p>
&lt;ul>
&lt;li>apiVersion: 해당 오브젝트를 생성하기 위해 사용하고 있는 쿠버네티스 API 버전&lt;/li>
&lt;li>kind: 오브젝트의 종류&lt;/li>
&lt;li>metadata: 오브젝트를 유일하게 구분지어 줄 데이터(이름 문자열, UID, 선택적인 네임스페이스 등)&lt;/li>
&lt;/ul>
&lt;p>spec에 대한 정확한 포맷은 모든 쿠버네티스 오브젝트마다다르고, 그 오브젝트 특유의 중첩된 필드를 포함한다.&lt;/p>
&lt;p>&lt;a class="link" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/" target="_blank" rel="noopener"
>https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/&lt;/a>&lt;/p></description></item><item><title>쿠버네티스: 2. 쿠버네티스 컴포넌트</title><link>https://codemario318.github.io/post/kubernetes_2/</link><pubDate>Fri, 21 Apr 2023 13:42:47 +0900</pubDate><guid>https://codemario318.github.io/post/kubernetes_2/</guid><description>&lt;img src="https://codemario318.github.io/post/kubernetes_2/kubernetes_cover.webp" alt="Featured image of post 쿠버네티스: 2. 쿠버네티스 컴포넌트" />&lt;h2 id="쿠버네티스-클러스터">쿠버네티스 클러스터&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/kubernetes_2/kubernetes_2_1.svg"
loading="lazy"
>&lt;/p>
&lt;p>컨테이너화 된 애프릴케이션을 실행하는 노드라고 하는 워커 머신의 집합으로, 모든 클러스터는 최소 한 개의 워커 노드를 가진다.&lt;/p>
&lt;p>워커 노드는 애플리케이션의 구성요소인 파드를 호스트하며, 컨트롤 플레인은 워커 노드와 클러스터 내 파드를 관리한다.&lt;/p>
&lt;p>프로덕션 환경에서는 일반적으로 컨트롤 플레인이 여러 컴퓨터에 걸쳐 실행되고, 클러스터는 일반적으로 여러 노드를 실행하므로 내결함성과 고가용성이 제공된다.&lt;/p>
&lt;h2 id="컨트롤-플레인-컴포넌트">컨트롤 플레인 컴포넌트&lt;/h2>
&lt;p>컨트롤 플레인 컴포넌트는 클러스터에 관한 전반적인 결정 (스케줄링 등)을 수행하고 클러스터 이벤트를 감지하고 반응한다.&lt;/p>
&lt;p>컨트롤 플레인 컴포넌트는 클러스터 내 어떠한 머신에서도 동작할 수 있으나, 간결성 유지를 위해 &lt;strong>구성 스크립트는 보통 동일 머신 상에 모든 컨트롤 플레인 컴포넌트를 구동&lt;/strong>시키고, 사용자 컨테이너는 해당 머신 상에 동작시키지 않는다.&lt;/p>
&lt;h3 id="kube-apiserver">kube-apiserver&lt;/h3>
&lt;blockquote>
&lt;p>API 서버는 쿠버네티스 API를 노출하는 쿠버네티스 컨트롤 플레인 컴포넌트이다. API 서버는 쿠버네티스 컨트롤 플레인의 프론트 엔드이다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://coffeewhale.com/apiserver" target="_blank" rel="noopener"
>쿠버네티스 API서버는 정말 그냥 API서버라구욧&lt;/a>&lt;/p>
&lt;p>kube-apiserver는 마스터 노드의 중심에서 모든 클라이언트, 컴포넌트로 부터 오는 요청들을 받는 REST API 서버이다.&lt;/p>
&lt;p>&lt;code>kubectl&lt;/code>와 &lt;code>Kubernetes SDK&lt;/code>를 이용할 수 있지만, 직접 REST API 호출로 쿠버네티스와 통신할 수 있다.&lt;/p>
&lt;p>쿠버네티스 API를 사용하여 애플리케이션을 작성하는 경우 클라이언트 라이브러리 중 하나를 사용하는 것이 좋다.
&lt;a class="link" href="https://kubernetes.io/ko/docs/reference/using-api/client-libraries/" target="_blank" rel="noopener"
>https://kubernetes.io/ko/docs/reference/using-api/client-libraries/&lt;/a>&lt;/p>
&lt;h3 id="etcd">etcd&lt;/h3>
&lt;blockquote>
&lt;p>모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성 및 고가용성 키-값 저장소.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://tech.kakao.com/2021/12/20/kubernetes-etcd/" target="_blank" rel="noopener"
>Kubernetes 운영을 위한 etcd 기본 동작 원리의 이해&lt;/a>&lt;/p>
&lt;p>kubernetes는 기반 스토리지(backing storage)로 etcd를 사용하고 있고, 모든 데이터가 etcd에 보관된다(클러스터에 어떤 노드가 몇 개나 있고 어떤 파드가 어떤 노드에서 동작하고 있는지등 ). 동작중인 클러스터의 etcd 데이터베이스가 유실된다면 컨테이너 뿐만 아니라 클러스터가 사용하는 모든 리소스는 미아가 된다.&lt;/p>
&lt;blockquote>
&lt;p>따라서 쿠버네티스 클러스터에서 etcd를 뒷단 저정소로 사용한다면, 이 데이터를 백업하는 계획을 필수적으로 갖추어야 한다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="kube-scheduler">kube-scheduler&lt;/h3>
&lt;blockquote>
&lt;p>노드가 배정되지 않은 새로 생성된 파드를 감지하고, 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트.&lt;/p>
&lt;/blockquote>
&lt;p>아래 항목들에 대해 고려하여 스케줄링이 이루어진다.&lt;/p>
&lt;ul>
&lt;li>리소스에 대한 개별 및 총체적 요구 사항&lt;/li>
&lt;li>하드웨어/소프트웨어/정책적 제약&lt;/li>
&lt;li>어피니티(affinity) 및 안티-어피니티(anti-affinity) 명세&lt;/li>
&lt;li>데이터 지역성&lt;/li>
&lt;li>워크로드간 간섭&lt;/li>
&lt;li>데드라인&lt;/li>
&lt;/ul>
&lt;h3 id="kube-controller-manager">kube-controller-manager&lt;/h3>
&lt;p>컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트.&lt;/p>
&lt;p>각 컨트롤러는 논리적으로 분리된 프로세스이지만, 복잡성을 낮추기 위해 모두 단일 바이너리로 컴파일되고 단일 프로세스 내에서 실행된다.&lt;/p>
&lt;ul>
&lt;li>노드 컨트롤러: 노드가 다운되었을 때 통지와 대응에 관한 책임을 가진다.&lt;/li>
&lt;li>잡 컨트롤러: 일회성 작업을 나타내는 잡 오브젝트를 감시한 다음, 해당 작업을 완료할 때까지 동작하는 파드를 생성한다.&lt;/li>
&lt;li>엔드포인트 컨트롤러: 엔드포인트 오브젝트를 채운다.(서비스와 파드를 연결시킨다.)&lt;/li>
&lt;li>서비스 어카운트 &amp;amp; 토큰 컨트롤러: 새로운 네임스페이스에 대한 기본 계정과 API 접근 토큰을 생성한다.&lt;/li>
&lt;/ul>
&lt;h3 id="cloud-controller-manager">cloud-controller-manager&lt;/h3>
&lt;blockquote>
&lt;p>클라우드 별 컨트롤 로직을 포함하는 쿠버네티스 컨트롤 플레인 컴포넌트이다.&lt;/p>
&lt;/blockquote>
&lt;p>클라우드 컨트롤러 매니저를 통해 클러스터를 클라우드 공급자의 API에 연결하고, 해당 클라우드 플랫폼과 상호 작용하는 컴포넌트와 클러스터와만 상호 작용하는 컴포넌트를 구분할 수 있게 해준다.&lt;/p>
&lt;p>클라우드 제공자 전용 컨트롤러만 실행한다. 자신의 사내 또는 PC 내부의 학습 환경에서 쿠버네티스를 실행 중인 경우 클러스터에는 클라우드 컨트롤러 매니저가 없다.&lt;/p>
&lt;p>kube-controller-manager와 마찬가지로 cloud-controller-manager는 논리적으로 독립적인 여러 컨트롤 루프를 단일 프로세스로 실행하는 단일 바이너리로 결합한다. 수평으로 확장(두 개 이상의 복제 실행)해서 성능을 향상시키거나 장애를 견딜 수 있다.&lt;/p>
&lt;ul>
&lt;li>노드 컨트롤러: 노드가 응답을 멈춘 후 클라우드 상에서 삭제되었는지 판별하기 위해 클라우드 제공 사업자에게 확인하는 것&lt;/li>
&lt;li>라우트 컨트롤러: 기본 클라우드 인프라에 경로를 구성하는 것&lt;/li>
&lt;li>서비스 컨트롤러: 클라우드 제공 사업자 로드밸런서를 생성, 업데이트 그리고 삭제하는 것&lt;/li>
&lt;/ul>
&lt;h2 id="노드-컴포넌트">노드 컴포넌트&lt;/h2>
&lt;p>노드 컴포넌트는 동작 중인 파드를 유지시키고 쿠버네티스 런타임 환경을 제공하며, 모든 노드 상에서 동작한다.&lt;/p>
&lt;h3 id="kubelet">kubelet&lt;/h3>
&lt;p>클러스터의 각 노드에서 실행되는 에이전트. &lt;code>kubelet&lt;/code>은 파드에서 컨테이너가 확실하게 동작하도록 관리한다.&lt;/p>
&lt;p>다양한 메커니즘을 통해 제공된 파드 스펙(PodSpec)의 집합을 받아 컨테이너가 해당 파드 스펙에 따라 건강하게 동작하는 것을 확실히 한다.&lt;/p>
&lt;p>kubelet은 쿠버네티스를 통해 생성되지 않는 컨테이너는 관리하지 않는다.&lt;/p>
&lt;h3 id="kube-proxy">kube-proxy&lt;/h3>
&lt;p>클러스터의 각 노드에서 실행되는 네트워크 프록시로, 크버네티스의 서비스 개념 구현부이다.&lt;/p>
&lt;p>노드의 네트워크 규칙을 관리한다. 네트워크 규칙이 내부 네트워크 세션이나 클러스터 바깥에서 파드로 네트워크 통신을 하도록 해준다.&lt;/p>
&lt;p>운영체제에 가용한 패킷 필터링 계층이 있는 경우, 이를 사용한다. 그렇지 않으면, kube-proxy는 트래픽 자체를 포워드한다.&lt;/p>
&lt;h3 id="컨테이너-런타임">컨테이너 런타임&lt;/h3>
&lt;p>컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다.&lt;/p>
&lt;p>쿠버네티스는 containerd, CRI-O와 같은 컨테이너 런타임 및 모든 Kubernetes CRI(컨테이너 런타임 인터페이스) 구현체를 지원한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>CRI란?&lt;/strong>&lt;br>
클러스터 컴포넌트를 다시 컴파일하지 않아도 Kubelet이 다양한 컨테이너 런타임을 사용할 수 있도록 하는 플러그인 인터페이스이다.&lt;/p>
&lt;/blockquote></description></item><item><title>쿠버네티스: 1. 쿠버네티스란 무엇인가?</title><link>https://codemario318.github.io/post/kubernetes_1/</link><pubDate>Fri, 21 Apr 2023 13:19:47 +0900</pubDate><guid>https://codemario318.github.io/post/kubernetes_1/</guid><description>&lt;img src="https://codemario318.github.io/post/kubernetes_1/kubernetes_cover.webp" alt="Featured image of post 쿠버네티스: 1. 쿠버네티스란 무엇인가?" />&lt;h2 id="쿠버네티스란">쿠버네티스란?&lt;/h2>
&lt;p>쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장 가능한 오픈소스 플랫폼이다.&lt;/p>
&lt;ul>
&lt;li>컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있다.&lt;/li>
&lt;li>확장가능한 오픈소스 플랫폼이다.&lt;/li>
&lt;li>선언적 구성과 자동화를 모두 용이하게 해준다.&lt;/li>
&lt;li>크고 빠르게 성장하는 생태계를 가지고 있다.&lt;/li>
&lt;li>쿠버네티스 서비서, 기술 지원 및 도구는 어디서나 쉽게 이용할 수 있다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>컨테이너 장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>기민한 애플리케이션 생성과 배포&lt;/strong>&lt;br>
VM 이미지를 사용하는 것에 비해 컨테이너 이미지 생성이 보다 쉽고 효율적임.&lt;/li>
&lt;li>&lt;strong>지속적인 개발, 통합 및 배포&lt;/strong>&lt;br>
안정적이고 주기적으로 컨테이너 이미지를 빌드해서 배포할 수 있고 (이미지의 불변성 덕에) 빠르고 효율적으로 롤백할 수 있다.&lt;/li>
&lt;li>&lt;strong>개발과 운영의 관심사 분리&lt;/strong>&lt;br>
배포 시점이 아닌 빌드/릴리스 시점에 애플리케이션 컨테이너 이미지를 만들기 때문에, 애플리케이션이 인프라스트럭처에서 분리된다.&lt;/li>
&lt;li>&lt;strong>가시성(observability)&lt;/strong>&lt;br>
OS 수준의 정보와 메트릭에 머무르지 않고, 애플리케이션의 헬스와 그 밖의 시그널을 볼 수 있다.&lt;/li>
&lt;li>&lt;strong>개발, 테스팅 및 운영 환경에 걸친 일관성&lt;/strong>&lt;br>
랩탑에서도 클라우드에서와 동일하게 구동된다.&lt;/li>
&lt;li>&lt;strong>클라우드 및 OS 배포판 간 이식성&lt;/strong>&lt;br>
Ubuntu, RHEL, CoreOS, 온-프레미스, 주요 퍼블릭 클라우드와 어디에서든 구동된다.&lt;/li>
&lt;li>&lt;strong>애플리케이션 중심 관리&lt;/strong>&lt;br>
가상 하드웨어 상에서 OS를 실행하는 수준에서 논리적인 리소스를 사용하는 OS 상에서 애플리케이션을 실행하는 수준으로 추상화 수준이 높아진다.&lt;/li>
&lt;li>&lt;strong>느슨하게 커플되고, 분산되고, 유연하며, 자유로운 마이크로서비스&lt;/strong>
애플리케이션은 단일 목적의 머신에서 모놀리식 스택으로 구동되지 않고 보다 작고 독립적인 단위로 쪼개져서 동적으로 배포되고 관리될 수 있다.&lt;/li>
&lt;li>&lt;strong>리소스 격리&lt;/strong>&lt;br>
애플리케이션 성능을 예측할 수 있다.&lt;/li>
&lt;li>&lt;strong>리소스 사용량&lt;/strong>&lt;br>
고효율 고집적.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="쿠버네티스가-왜-필요하고-무엇을-할-수-있나">쿠버네티스가 왜 필요하고 무엇을 할 수 있나&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/kubernetes_1/kubernetes_1_1.svg"
loading="lazy"
>&lt;/p>
&lt;p>기존 &amp;ldquo;전통적인 배포&amp;rdquo;, &amp;ldquo;가상화된 배포&amp;quot;를 거치며 &amp;ldquo;컨테이너를 통한 배포&amp;rdquo; 까지 발전해왔다.&lt;/p>
&lt;p>컨테이너를 통한 개발 환경은 애플리케이션을 포장하고 실행하는 좋은 방법이지만, 프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야 하는 등 여러 작업이 필요하게 된다.&lt;/p>
&lt;p>쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공한다. 애플리케이션의 확장과 장애 조치를 처리하고, 배포 패턴 등을 제공한다. 예를 들어, 쿠버네티스는 시스템의 카나리아 배포를 쉽게 관리 할 수 있다.&lt;/p>
&lt;h3 id="서비스-디스커버리와-로드-밸런싱">서비스 디스커버리와 로드 밸런싱 &lt;/h3>
&lt;p>쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.&lt;/p>
&lt;h3 id="스토리지-오케스트레이션">스토리지 오케스트레이션&lt;/h3>
&lt;p>쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있다.&lt;/p>
&lt;h3 id="자동화된-롤아웃과-롤백">자동화된 롤아웃과 롤백 &lt;/h3>
&lt;p>쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.&lt;/p>
&lt;h3 id="자동화된-빈-패킹bin-packing">자동화된 빈 패킹(bin packing)&lt;/h3>
&lt;p>컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.&lt;/p>
&lt;h3 id="자동화된-복구self-healing">자동화된 복구(self-healing)&lt;/h3>
&lt;p>쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, &amp;lsquo;사용자 정의 상태 검사&amp;rsquo;에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.&lt;/p>
&lt;h3 id="시크릿과-구성-관리">시크릿과 구성 관리 &lt;/h3>
&lt;p>쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리 할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트 할 수 있다.&lt;/p></description></item></channel></rss>