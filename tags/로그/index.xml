<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>로그 on Mario Blog</title><link>https://codemario318.github.io/tags/%EB%A1%9C%EA%B7%B8/</link><description>Recent content in 로그 on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Tue, 04 Mar 2025 13:51:49 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/%EB%A1%9C%EA%B7%B8/index.xml" rel="self" type="application/rss+xml"/><item><title>3.1. 저장소와 검색: 데이터베이스를 강력하게 만드는 데이터 구조</title><link>https://codemario318.github.io/post/designing-data-intensive-application/3/1/</link><pubDate>Tue, 04 Mar 2025 13:51:49 +0900</pubDate><guid>https://codemario318.github.io/post/designing-data-intensive-application/3/1/</guid><description>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/cover.png" alt="Featured image of post 3.1. 저장소와 검색: 데이터베이스를 강력하게 만드는 데이터 구조" />&lt;p>가장 기본적인 수준에서 데이터베이스는 &lt;strong>데이터 저장&lt;/strong>, &lt;strong>데이터 제공&lt;/strong> 두 가지 작업을 수행한다.&lt;/p>
&lt;p>애플리케이션 개발자가 처음부터 자신의 저장소 엔진을 구현하기보다는 사용 가능한 여러 저장소 엔진 중에 애플리케이션에 적합한 엔진을 선택하는 작업이 필요하다.&lt;/p>
&lt;p>따라서 특정 &lt;strong>작업부하&lt;/strong>(workload) 유형에서 좋은 성능을 내게끔 저장소 엔지을 조정하려면 저장소 엔진이 내부에서 수행되는 작업에 대해 대략적인 개념을 이해할 필요가 있다.&lt;/p>
&lt;p>특히 &lt;strong>트랜잭션&lt;/strong> 작업부하에 맞춰 최적화된 저장소 엔진과 &lt;strong>분석&lt;/strong>을 위해 최적화된 엔진 간에는 큰 차이가 있으므로, 우선 &lt;strong>관계형 데이터베이스&lt;/strong>와 &lt;strong>NoSQL&lt;/strong>이라 불리는 데이터베이스에 사용되는 저장소
엔진에 대해 간략히 살펴보고, &lt;strong>로그 구조&lt;/strong>(log-structured) 계열 저장소 엔진(B-tree 같은)과 &lt;strong>페이지 지향&lt;/strong>(page-oriented) 계열 저장소 엔진을 검토한다.&lt;/p>
&lt;h2 id="로그와-색인">로그와 색인&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>db_set &lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">,&lt;/span>&lt;span class="nv">$2&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &amp;gt;&amp;gt; database
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">db_get &lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> grep &lt;span class="s2">&amp;#34;^&lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">,&amp;#34;&lt;/span> database &lt;span class="p">|&lt;/span> sed -e &lt;span class="s2">&amp;#34;s/^&lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">,//&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> tail -n &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위는 매우 간단한 데이터베이스로 키-값 저장소를 함수 두 개로 구현되었으며, 기본적인 저장소 형식은 매 라인마다 쉼표로 구분된 키-값 쌍을 포함한 텍스트 파일이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>db_set&lt;/code>을 호출할 때마다 파일의 끝에 추가하므로 키를 여러 번 갱신해도 값의 예전 버전을 덮어 쓰지 않음&lt;/li>
&lt;li>최신 값을 찾기 위해 파일에서 키의 가장 마지막 항목 확인 (&lt;code>tail -n 1&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>일반적으로 &lt;strong>파일 추가&lt;/strong> 작업은 매우 효율적이기 때문에 &lt;code>db_set&lt;/code> 함수는 매우 간단한 작업의 경우 꽤 좋은 성능을 보이는데, 이 때문에 많은 데이터베이스는 내부적으로 추가 전용(append-only) 데이터
파일인 &lt;strong>로그&lt;/strong>(log)를 사용한다.&lt;/p>
&lt;ul>
&lt;li>실제 데이터베이스는 동시성 제어, 디스크 공간 최적화, 요류 처리 등 여러 많은 문제를 다루지만 기본 원리는 같음&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>로그(log)&lt;/strong> 란?&lt;br>
일반적인 의미로 연속된 추가 전용 레코드&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>db_set&lt;/code>에 비해 &lt;code>db_get&lt;/code> 함수는 데이터베이스에 많은 레코드가 존재하는 경우 성능이 매우 좋지 않다.&lt;/p>
&lt;ul>
&lt;li>키를 찾을 때마다 키가 있는지 찾기 위해 전체 데이터베이스 파일을 처음부터 끝까지 스캔해야함(&lt;code>O(n)&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>이 때문에 데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서는 다른 데이터 구조 즉 &lt;strong>색인&lt;/strong>이 필요하다.&lt;/p>
&lt;p>색인의 일반적인 개념은 어떤 &lt;strong>부가적인 메타데이터를 유지하는 것&lt;/strong> 이다.&lt;/p>
&lt;p>이 메타데이터는 이정표 역할을 해서 원하는 데이터의 위치를 찾는데 도움을 주며, 동일한 데이터를 여러 가지 다양한 방법으로 검색하고 싶다면 데이터의 각 부분에 다양한 색인이 필요하다.&lt;/p>
&lt;p>색인은 기본 데이터(primary data)에서 파생된 &lt;strong>추가적인&lt;/strong> 구조로, 많은 데이터베이스는 색인의 추가와 삭제를 허용한다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스의 내용에는 영향을 미치지 않음&lt;/li>
&lt;li>질의 성능에만 영향을 줌&lt;/li>
&lt;/ul>
&lt;p>이러한 추가적인 구조로 인해 특히 쓰기 과정에서 오버헤드가 발생하며, 위 예시의 로그처럼 단순히 파일에 추가하는 작업이 가장 간단한 쓰기 작업이므로 성능을 앞서기 어렵다.&lt;/p>
&lt;p>어떤 종류의 색인이라도 데이터를 쓸 때마다 색인을 갱신하기 때문에 대개 쓰기 속도를 느리게 만든다.&lt;/p>
&lt;p>이러한 성능 저하는 저장소 시스템의 중요한 트레이드 오프이며 색인을 잘 선택했다면 &lt;strong>읽기 질의 속도가 향상&lt;/strong>되지만, &lt;strong>쓰기 성능은 저하&lt;/strong> 된다.&lt;/p>
&lt;p>때문에 보통 데이터베이스는 자동으로 색인을 생성하지 않으므로, 개발자나 관리자가 애플리케이션의 질의 패턴에 대한 지식을 통해 수동으로 색인을 선택해야한다.&lt;/p>
&lt;h2 id="해시-색인">해시 색인&lt;/h2>
&lt;p>디스크 상의 데이터를 색인하기 위해 인메모리 데이터 구조를 사용할 수 있다.&lt;/p>
&lt;p>단순히 파일에 추가하는 방식으로 데이터 저장소를 구성한다고 가정할때, 가장 간단하게 가능한 색인 전략은 &lt;strong>키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지하는 전략&lt;/strong>이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img.png"
width="766"
height="387"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_hu10802d0377ceddec2b44e8f20547cd27_67858_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_hu10802d0377ceddec2b44e8f20547cd27_67858_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="인메모리 해시맵으로 키-값 쌍의 로그 저장하기"
class="gallery-image"
data-flex-grow="197"
data-flex-basis="475px"
>&lt;/p>
&lt;ul>
&lt;li>파일에 새로운 키-값 쌍을 추가할 때마다 방금 기록한 데이터의 오프셋을 반영하기 위해 해시 맵도 갱신&lt;/li>
&lt;li>값을 조회하려면 해시 맵을 사용해 데이터 파일에서 오프셋을 찾아 해당 위치를 구하고 값을 읽음&lt;/li>
&lt;/ul>
&lt;p>이 방식은 매우 단순해 보이지만 실제로 많이 사용하는 접근법이다.&lt;/p>
&lt;ul>
&lt;li>해시 맵을 전부 메모리에 유지하기 때문에 사용 가능한 램에 모든 키가 저장된다는 조건을 전제로 고성능으로 읽기, 쓰기를 보장&lt;/li>
&lt;li>값은 한 번의 디스크 탐색으로 디스크에서 적재할 수 있기 때문에 사용 가능한 메모리보다 더 많은 공간을 사용&lt;/li>
&lt;/ul>
&lt;p>이러한 저장소 엔진은 각 키의 값이 자주 갱신되는 상황에 매우 적합하다.&lt;/p>
&lt;ul>
&lt;li>쓰기가 많지만 고유 키는 많지 않은 작업부하&lt;/li>
&lt;li>ex) 키가 특정 영상의 URL, 값이 영상의 재생 횟수 인 경우&lt;/li>
&lt;/ul>
&lt;p>하지만 파일에 항상 추가만 할 경우 결국 디스크 공간이 부족해지며, 이를 위해 특정 크기의 &lt;strong>세그먼트&lt;/strong>(segment)로 로그를 나누는 방식이 좋은 해결책으로 사용된다.&lt;/p>
&lt;ul>
&lt;li>특정 크기에 도달하면 세그먼트 파일을 닫고, 새로운 세그먼트 파일에 이후 쓰기를 수행&lt;/li>
&lt;li>세그먼트 파일들에 대해 컴팩션(compaction)을 수행할 수 있음
&lt;ul>
&lt;li>로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_1.png"
width="765"
height="293"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_1_hu0bae992a8b87768d26a804495794cdcd_41454_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_1_hu0bae992a8b87768d26a804495794cdcd_41454_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="키-값 갱신 로그를 컴팩션하여 각 키의 최신 값만 유지"
class="gallery-image"
data-flex-grow="261"
data-flex-basis="626px"
>&lt;/p>
&lt;p>컴팩션은 보통 세그먼트를 더 작게 만들기 때문에 컴팩션을 수행할 때 동시에 여러 세그먼트들을 병합할 수 있다.&lt;/p>
&lt;ul>
&lt;li>이 때 세그먼트가 쓰여진 후에는 절대 변경할 수 없기 때문에 병합할 세그먼트는 새로운 파일로 만듦&lt;/li>
&lt;li>고정된 세그먼트의 병합과 컴팩션은 백그라운드 스레드에서 수행할 수 있음&lt;/li>
&lt;li>컴팩션을 수행하는 동안 이전 세그먼트 파일을 사용해 읽기와 쓰기 요청의 처리를 정상적으로 계속 수행할 수 있음&lt;/li>
&lt;/ul>
&lt;p>병합 과정이 끝난 이후에는 일기 요청은 이전 세그먼트 대신 새로 병합한 세그먼트를 사용하게끔 전환하고, 이전 세그먼트 파일을 삭제한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_2.png"
width="767"
height="401"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_2_hu7c9ff548df2e8f3ee88f72377b5e69a1_71238_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_2_hu7c9ff548df2e8f3ee88f72377b5e69a1_71238_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="컴팩션과 세그먼트 병합을 동시에 수행"
class="gallery-image"
data-flex-grow="191"
data-flex-basis="459px"
>&lt;/p>
&lt;p>각 세그먼트는 키를 파일 오프셋에 매핑한 자체 인메모리 해시 테이블을 갖게된다.&lt;/p>
&lt;ul>
&lt;li>키의 값을 찾으려면 최신 세그먼트 해시 맵을 먼저 확인&lt;/li>
&lt;li>키가 없다면 두 번째 최신 세그먼트 등을 확인&lt;/li>
&lt;/ul>
&lt;p>병합 과정을 통해 세그먼트 수를 적게 유지하므로 조회할 때 많은 해시 맵을 확인할 필요가 없다.&lt;/p>
&lt;hr>
&lt;p>이러한 아이디어를 실제로 구현하려면 세부적으로 많은 사항을 고려해야 한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>파일 형식&lt;/strong>
&lt;ul>
&lt;li>CSV는 로그에 가장 적합한 형식은 아님&lt;/li>
&lt;li>바이트 단위의 문자열 길이를 부호화한 다음 원시 문자열(이스케이핑할 필요 없이)을 부호화하는 바이너리 형식을 사용하는 편이 더 빠르고 간단함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>레코드 삭제&lt;/strong>
&lt;ul>
&lt;li>키와 관련된 값을 삭제하려면 데이터 파일에 특수한 삭제 레코드(툼스톤(tombstone))를 추가해야함&lt;/li>
&lt;li>로그 세그먼트가 병합될 때 툼스톤은 병합 과정에서 삭제된 키의 이전 값을 무시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>고장(Crash) 복구&lt;/strong>
&lt;ul>
&lt;li>데이터베이스가 재시작되면 인메모리 해시 맵은 손실&lt;/li>
&lt;li>전체 세그먼트 파일을 처음부터 끝가지 읽고 각 키에 대한 최신 값의 오프셋을 확인해서 각 세그먼트 해시 맵을 복원 가능&lt;/li>
&lt;li>하지만 세그먼트 파일이 크면 해시 맵 복원은 오랜 시간이 걸리 수 있음(서버 재시작을 고통스럽게함)&lt;/li>
&lt;li>비트캐스크 같은 경우 각 세그먼트 해시 맵을 메모리로 조금 더 빠르게 로딩할 수 있게 스냅숏을 디스크에 저장해 복수 속도를 높임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>부분적 레코드 쓰기&lt;/strong>
&lt;ul>
&lt;li>로그에 레코드를 추가하는 도중 데이터베이스가 죽을 수 있음&lt;/li>
&lt;li>비트캐스크 파일은 체크섬을 포함하고 있어 로그의 손상된 부분을 탐지해 무시할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>동시성 제어&lt;/strong>
&lt;ul>
&lt;li>쓰기를 엄격하게 순차적으로 로그에 추가할 때 일반적으로 하나의 쓰기 쓰레드만 사용&lt;/li>
&lt;li>데이터 파일 세그먼트는 추가 전용이거나 불변(immutable)이므로 다중 스레드로 동시에 읽기 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;p>추가 전용 로그는 같은 키의 여러개의 쓰기가 발생하므로 비효율 적으로 보일 수 있다.&lt;/p>
&lt;p>예전 값을 새로운 값으로 덮어써 정해진 자리에 파일을 갱신하는 방법도 있지만, 추가 전용 설계는 여러 측면에서 장점이 있다.&lt;/p>
&lt;ul>
&lt;li>추가와 세그먼트 병합은 순차적인 쓰기 작업이므로 보통 무작위 쓰기보다 훨씬 빠름
&lt;ul>
&lt;li>특히 HDD에서 두드러지며, 일부 확장된 순차 쓰기는 SSD에서도 빠름&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>세그먼트 파일이 추가 전용이나 불변이면 동시성과 고장 복구는 훨씬 간단
&lt;ul>
&lt;li>이전 값 부분과 새로운 값 부분을 포함한 파일을 나누어 담으므로, 값을 덮어 쓰는 동안 데이터베이스가 죽는 경우에 대해 걱정할 필요가 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오래된 세그먼트 병합은 시간이 지남에 따라 조각화되는 데이터 파일 문제를 피할 수 있음&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;p>하지만 해시 테이블 색인 또한 제한 사항이 있다.&lt;/p>
&lt;ul>
&lt;li>해시 테이블은 메모리에 저장해야 하므로 키가 너무 많으면 문제가 발생함
&lt;ul>
&lt;li>디스크에 해시 맵을 유지할 수 있지만 디스크 상의 해시ㅣ 맵에 좋은 성능을 기대하기 어려움
&lt;ul>
&lt;li>무작위 접근 I/O가 많이 필요함&lt;/li>
&lt;li>디스크가 가득 찼을 때 확장하는 비용이 비쌈&lt;/li>
&lt;li>해시 충돌 해소를 위해 추가 로직 필요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>점위 질의(Range query)에 적합하지 않음
&lt;ul>
&lt;li>키 값이 연속적이어도 쉽게 스캔할 수 없어 모든 개별 키를 조회해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="ss테이블과-lsm-트리">SS테이블과 LSM 트리&lt;/h2>
&lt;p>각 로그 구조화 저장소 세그먼트는 키-값 쌍의 연속으로, 이 쌍은 쓰여진 순서대로 나타나므로 로그에서 같은 키를 갖는 값 중 나중의 값이 이전 값보다 우선 하므로 이 점을 제외하면 파일에서 키-값 쌍의 순서는 문제가 되지 않는다.&lt;/p>
&lt;p>이를 개선하기 위해 키-값 쌍을 키로 정렬하는 방법을 고려할 수 있다.&lt;/p>
&lt;p>이처럼 키로 정렬된 형식을 &lt;strong>정렬된 문자열 테이블&lt;/strong>(Sorted String Table), 짧게 &lt;strong>SS테이블&lt;/strong>이라 부른다.&lt;/p>
&lt;ul>
&lt;li>각 키는 각 병합된 세그먼트 파일 내에 한 번만 나타나함
&lt;ul>
&lt;li>컴팩션 과정은 이미 이를 보장&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>SS테이블은 해시 색인을 가진 로그 세그먼트보다 몇 가지 큰 장점이 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>세그먼트 병합은 파일이 사용 가능한 메모리보다 크더라도 간단하고 효율적&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_3.png"
width="729"
height="483"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_3_hu7c722957ba7cfb7350c21df09c1076e8_90335_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_3_hu7c722957ba7cfb7350c21df09c1076e8_90335_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="SS 테이블 세그먼트 병합하고 각 키의 최신 값만 유지"
class="gallery-image"
data-flex-grow="150"
data-flex-basis="362px"
>&lt;/p>
&lt;ol>
&lt;li>입력 파일을 함께 읽고 각 파일의 첫 번째 키를 확인(정렬된 순서에 따라)&lt;/li>
&lt;li>가장 낮은 키를 출력 파일로 복사한 뒤 이 과정 반복&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>이 과정에서 새로운 병합 세그먼트 파일이 생성되며, 새로 만든 세그먼트 파일도 역시 키로 정렬&lt;/li>
&lt;li>각 세그먼트는 일정 기간 동안 쓰여진 모든 값이 포함되므로, 여러 세그먼트의 같은 값이 포함될 수 있지만, 가장 최근에 만들어진 값이 최신&lt;/li>
&lt;li>따라서 다중 세그먼트가 동일한 키를 포함하는 경우 가장 최근 세그먼트의 값을 유지하고 오래된 세그먼트의 값은 버림&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>파일에서 특정 키를 찾기 위해 메모리에 모든 키의 색인을 유지할 필요가 없음&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_4.png"
width="732"
height="369"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_4_huc566f05f79666e2208f2a7a43b254dbf_70982_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_4_huc566f05f79666e2208f2a7a43b254dbf_70982_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="인메모리 색인을 가진 SS테이블"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="476px"
>&lt;/p>
&lt;p>&lt;code>handiwork&lt;/code> 키를 찾으려 하지만 세그먼트 파일에서 키의 정확한 오프셋을 알지 못한다고 가정해도, &lt;code>handbag&lt;/code>과 &lt;code>handsome&lt;/code> 키의 오프셋을 알고 있다면, 이미 정렬되어있다는 특성을 활용하여 두 키 사이에 있다는 사실을 알 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>handbag&lt;/code> 오프셋으로 이동해 &lt;code>handiwork&lt;/code>가 나올 때까지 스캠하면 됨(키가 존재하지 않는 경우 찾을 수 없음)&lt;/li>
&lt;li>일부 키에 대한 오프셋을 알려주는 인메모리 색인은 여전히 필요&lt;/li>
&lt;li>하지만 색인 내용이 희소할 수 있는 경우, 수 킬로파이트 정도는 매우 빠르게 스캔할 수 있기 때문에 세그먼트 파일 내 수 킬로바이트당 키 하나로 충분&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>압축&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>읽기 요청은 요청 범위 내에서 여러 키-값 쌍을 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기 전 압축함&lt;/li>
&lt;li>희소 인메모리 색인의 각 항목은 압축된 블록의 시작을 가리키게 됨&lt;/li>
&lt;li>디스크 공간을 절약할 수 있고, 이로 인해 I/O 대역폭 사용을 줄일 수 있음&lt;/li>
&lt;/ul>
&lt;h3 id="ss테이블-생성과-유지">SS테이블 생성과 유지&lt;/h3>
&lt;p>유입되는 쓰기가 임의 순서로 발생하기 때문에 데이터를 키로 정렬하려면 고민이 필요하다.&lt;/p>
&lt;p>디스크 상에 정렬된 구조를 유지하는 일은 가능하지만 메모리에 유지하는 편이 훨씬 쉽다.&lt;/p>
&lt;ul>
&lt;li>레드 블랙 트리, AVL 트리 등&lt;/li>
&lt;/ul>
&lt;p>이런 데이터 구조를 이용하면 &lt;strong>임의 순서로 키를 삽입하고 정렬된 순서로 해당 키를 다시 읽을 수&lt;/strong>있다.&lt;/p>
&lt;ul>
&lt;li>쓰기가 들어오면 인메모리 균형 트리 데이터 구조에 추가
&lt;ul>
&lt;li>이 인메모리 트리는 멤테이블(memtable)이라고도 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>멤테이블이 보통 수 메가바이트 정도의 임곗값보다 커지면 SS테이블 파일로 디스크에 기록
&lt;ul>
&lt;li>트리가 이미 키로 정렬된 키-값 쌍을 유지하므로 효율적으로 수행 가능&lt;/li>
&lt;li>새로운 SS테이블 파일은 데이터베이스의 가장 최신 세그먼트가 됨&lt;/li>
&lt;li>SS테이블을 기록하는 동안 쓰기는 새로운 멤테이블 인스턴스에 기록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>읽기 요청을 제공하려면 먼제 멤테이블에서 키를 찾고 없다면 디스크 상의 가장 최신 세그먼트에서 부터 차례대로 확인&lt;/li>
&lt;li>가끔 세그먼트 파일을 합치고 덮어 쓰여지거나 삭제된 값을 버리는 병합과 컴팩션 과정을 수행
&lt;ul>
&lt;li>이 과정은 백그라운드에서 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 계획은 데이터베이스가 고장나면 &lt;strong>아직 디스크로 기록되지 않고 멤테이블에 있는 가장 최신 쓰기는 손실되는 문제&lt;/strong>가 있다.&lt;/p>
&lt;p>이를 대비하기위해 매번 쓰기를 즉시 추가할 수 있게 분리된 로그를 디스크 상 유지해야한다.&lt;/p>
&lt;ul>
&lt;li>이 로그는 멤테이블을 복원할 때만 필요하므로 순서가 정렬되지 않아도 문제되지 않음&lt;/li>
&lt;/ul>
&lt;p>멤테이블을 SS테이블로 기록하고 나면 해당 로그는 버릴 수 있다.&lt;/p>
&lt;h3 id="ss테이블에서-lsm-트리-만들기">SS테이블에서 LSM 트리 만들기&lt;/h3>
&lt;p>여기에 기술된 알고리즘은 기본적으로 레벨DB(LevelDB)와 록스DB(RocksDB), 그리고 다른 애플리케이션에내장하기 이ㅜ해 설계된 키-값 저장소 엔진 라이브러리에서 사용한다.&lt;/p>
&lt;p>구글의 빅테이블(Bigtable)논문에서 영감을 얻은 카산드라와 HBase에서도 유사한 저장소 엔진을 사용한다.&lt;/p>
&lt;p>원래 이 색인 구조는 &lt;strong>로그 구조화 병합 트리&lt;/strong>(Log-Structured Merge-Table, LSM 트리)란 이름으로 발표되었으며, 이 색인 구조는 로그 구조화 파일 시스템의 초기 작업의 기반이 됐다.&lt;/p>
&lt;p>&lt;strong>정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진&lt;/strong>을 &lt;strong>LSM 저장소 엔진&lt;/strong>이라 부른다.&lt;/p>
&lt;h3 id="성능-최적화">성능 최적화&lt;/h3>
&lt;p>LSM 트리 알고리즘은 데이터베이스에 존재하지 않는 키를 찾는 경우 느릴 수 있다.&lt;/p>
&lt;ul>
&lt;li>멤테이블을 확인한 다음 키가 존재하지 않는 사실을 확인하기 전 까지 오래된 세그먼트까지 거슬러 올라야함(디스크 I/O 발생 가능)&lt;/li>
&lt;/ul>
&lt;p>이런 종류의 접근을 최적화하기 위해 저장소 엔진은 보통 &lt;strong>블룸 필터&lt;/strong>(Bloom filter)를 추가적으로 사용한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>블룸 필터(Bloom filter)?&lt;/strong>&lt;br>
집합 내용을 근사한(approximating) 메모리 효율적 데이터 구조&lt;/p>
&lt;/blockquote>
&lt;p>블룸 필터는 키가 데이터베이스에 존재하지 않음을 알려주므로 존재하지 않는 키를 위한 불필요한 디스크 읽기를 많이 절약할 수 있다.&lt;/p>
&lt;hr>
&lt;p>SS테이블을 압축하고 병합하는 순서와 시기를 결정하는 다양한 전략이 있다.&lt;/p>
&lt;p>가장 일반적으로 선택하는 전략은 &lt;strong>크기 계층 컴팩션&lt;/strong>(size-tiered compaction)과 &lt;strong>레벨 컴팩션&lt;/strong>(leveled compaction)이다.&lt;/p>
&lt;ul>
&lt;li>크기 게층 컴팩션
&lt;ul>
&lt;li>상대적으로 새롭고 작은 SS테이블을 상대적으로 오래됐고 큰 SS테이블에 연이어 병합&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>레벨 컴팩션
&lt;ul>
&lt;li>키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 &amp;ldquo;레벨&amp;quot;로 이동&lt;/li>
&lt;li>컴팩션을 점진적으로 진행해 디스크 공간을 덜 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>여러 중요한 세부 사항이 있지만 LSM 트리의 기본 개념은 간단하고 효과적이다.&lt;/p>
&lt;ul>
&lt;li>백그라운드에서 연쇄적으로 SS테이블을 지속적으로 병합하는 것&lt;/li>
&lt;/ul>
&lt;p>이 개념은 데이터셋이 가능한 메모리보다 훨씬 크더라도 여전히 효과적이고, 데이터가 정렬된 순서로 저장돼 있다면 범위 질의를 효율적으로 수행할 수 있다.&lt;/p>
&lt;ul>
&lt;li>최소에서 최대까지 모든 키를 스캔&lt;/li>
&lt;/ul>
&lt;p>이 접근법의 디스크 쓰기는 순차적이기 때문에 LSM 트리가 매우 높은 쓰기 처리량을 보장할 수 있다.&lt;/p>
&lt;h2 id="b-트리">B 트리&lt;/h2>
&lt;p>지금까지 설명한 로그 구조화 색인이 점점 보편화되고 있지만 가장 일반적인 색인 유형은 아니며, 가장 널리 사용되는 색인 구조는 &lt;strong>B 트리&lt;/strong>(B-Tree)로 구조가 &lt;strong>로그 구조화 색인&lt;/strong>과는 상당히 다르다.&lt;/p>
&lt;p>B 트리는 SS테이블과 같이 키로 정렬된 키-값 쌍을 유지하기 때문에 키-값 검색과 범위 질의에 효율적이지만, 설계 철학이 매우 다르다.&lt;/p>
&lt;ul>
&lt;li>로그 구조화 색인
&lt;ul>
&lt;li>데이터베이스를 일반적으로 수 메가바이트 이상의 가변 크기를 가진 &lt;strong>세그먼트&lt;/strong>로 나누고 항상 순차적으로 세그먼트를 기록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>B 트리
&lt;ul>
&lt;li>전통적으로 4KB 크기의 고정 크기 &lt;strong>블록&lt;/strong>이나 &lt;strong>페이지&lt;/strong>로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기 수행&lt;/li>
&lt;li>디스크가 고정 크기 블록으로 배열되기 때문에 근본적으로 하드웨어와 조금 더 밀접한 관련이 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>B 트리의 각 페이지는 주소나 위치를 통해 식별할 수 있으며, 이러한 방식으로 하나의 페이지가 다른 페이지를 참조할 수 있다.&lt;/p>
&lt;ul>
&lt;li>포인터와 비슷하지만 메모리 대신 디스크에 있음&lt;/li>
&lt;/ul>
&lt;p>이러한 페이지 참조는 페이지 트리를 구성하는 데 사용할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_5.png"
width="766"
height="432"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_5_hu276247de4dbbe3c9ef294590e9d78f86_61955_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_5_hu276247de4dbbe3c9ef294590e9d78f86_61955_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="B 트리 색인을 이용한 키 검색"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="425px"
>&lt;/p>
&lt;p>한 페이지는 B 트리의 &lt;strong>루트&lt;/strong>(root)로 지정되며, 색인에서 키를 찾으려면 루트에서 시작한다.&lt;/p>
&lt;p>페이지는 여러 &lt;strong>키&lt;/strong>와 &lt;strong>하위 페이지의 참조&lt;/strong>를 포함되며, 각 하위 페이지는 &lt;strong>키가 계속 이어지는 범위&lt;/strong>를 담당하고 참조 사이의 키는 &lt;strong>해당 범위의 경계가 어디인지&lt;/strong> 나타낸다.&lt;/p>
&lt;p>최종적으로는 개별 키(&lt;strong>리프 페이지&lt;/strong>(leaf page))를 포함하는 페이지에 도달하게되며, 이 페이지는 각 키의 값을 포함하거나 값을 찾을 수 있는 페이지의 참조를 포함하게된다.&lt;/p>
&lt;ul>
&lt;li>B 트리의 한 페이지에서 하위 페이지를 참조하는 수를 &lt;strong>분기 계수&lt;/strong>(branching factor)라 부름&lt;/li>
&lt;li>실제로 분기 계수는 페이지 참조와 범위 경계를 저장할 공간의 양에 의존적(보통 수백개)&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_6.png"
width="767"
height="438"
srcset="https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_6_hu89ce2a7004a0b1a5586f285cb94aff3a_56106_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/designing-data-intensive-application/3/1/img_6_hu89ce2a7004a0b1a5586f285cb94aff3a_56106_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="페이지 분리로 커진 B 트리"
class="gallery-image"
data-flex-grow="175"
data-flex-basis="420px"
>&lt;/p>
&lt;p>이 알고리즘은 트리가 계속 &lt;strong>균형&lt;/strong>을 유지하는 것을 보장한다.&lt;/p>
&lt;ul>
&lt;li>n개의 키를 가진 B 트리의 깊이가 항상 &lt;code>O(log n)&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>대부분 데이터베이스는 B 트리의 깊이가 3 ~ 4 정도면 충분하므로 검색하려는 페이지를 찾기 위해 많은 페이지 참조를 따라가지 않아도 된다.&lt;/p>
&lt;ul>
&lt;li>분기 계수 500의 4KB 페이지의 4단계 트리는 256TB까지 저장할 수 있음&lt;/li>
&lt;/ul>
&lt;h3 id="신뢰할-수-있는-b-트리-만들기">신뢰할 수 있는 B 트리 만들기&lt;/h3>
&lt;p>B 트리의 기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어쓰며, 덮어쓰기가 페이지 위치를 변경하지 않는다고 가정한다.&lt;/p>
&lt;ul>
&lt;li>페이지를 덮어쓰더라도 페이지를 가르키는 모든 참조는 온전히 남음&lt;/li>
&lt;li>LSM 트리와 같은 로그 구조화 색인은 파일에 추가 할 뿐(더 이상 쓸모 없는 파일은 삭제) 같은 위치의 파일은 변경하지 않음&lt;/li>
&lt;/ul>
&lt;p>디스크의 페이지를 덮어 쓰는 일은 실제 하드웨어가 처리한다.&lt;/p>
&lt;ul>
&lt;li>하드드라이브
&lt;ul>
&lt;li>디스크 헤드를 적절한 곳으로 옮기고, 회전하는 플래터의 올바른 위치가 돌아올 때까지 기다린 다음 적합한 섹터에 새로운 데이터를 덮어씀&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>SSD
&lt;ul>
&lt;li>SSD가 저장소 칩의 상당한 블록을 한번에 지우고 다시 쓰기를 수행&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>일부 동작은 여러 다양한 페이지의 덮어쓰기를 필요로 한다.&lt;/p>
&lt;p>예를 들어, 삽입 때문에 페이지가 너무 많아져 페이지를 나눠야 하는 경우 분할된 두 페이지를 기록하고 두 하위 페이지의 참조를 갱신하게끔 상위 페이지를 덮어쓰기를 해야한다.&lt;/p>
&lt;ul>
&lt;li>이러한 처리 중 일부 페이지만 기록하고 데이터베이스가 고장난다면 결국 색인이 훼손되므로 위험함&lt;/li>
&lt;/ul>
&lt;p>데이터베이스가 고장 상황에서 스스로 복구할 수 있도록 일반적으로 디스크 상에 &lt;strong>쓰기 전 로그&lt;/strong>(write-ahead log, WAL, 재실행 로그, redo log)라는 데이터 구조를 추가해 B 트리를 구현한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>쓰기 전 로그&lt;/strong>&lt;br>
트리 페이지에 변경된 내용을 적용하기 전 모든 B 트리의 변경 사항을 기록하는 추가 전용 파일&lt;br>
데이터베이스가 복구될 때 일관성 있는 상태로 B 트리를 복원하는 데 사용됨&lt;/p>
&lt;/blockquote>
&lt;p>같은 자리의 페이지를 갱신하는 작업은 추가적인 골칫거리다.&lt;/p>
&lt;p>다중 스레드가 동시에 B 트리에 접근할 때 동시성 제어를 하지 않는다면 스레드가 일관성이 깨진 상태의 트리에 접근할 수 있다.&lt;/p>
&lt;p>동시성 제어는 보통 &lt;strong>래치&lt;/strong>(latch, 가벼운 잠금)로 트리의 데이터 구조를 보호한다.&lt;/p>
&lt;ul>
&lt;li>로그 구조화 접근 방식에서는 유입 질의의 간섭 없이 백그라운드에서 모든 병합을 수행하고 가끔 원자적으로 새로운 세그먼트를 이전 세그먼트로 바꾸기 때문에 훨씬 간단함&lt;/li>
&lt;/ul>
&lt;h3 id="b-트리-최적화">B 트리 최적화&lt;/h3>
&lt;p>B 트리는 오랫동안 사용된만큼 많은 최적화 기법이 있다.&lt;/p>
&lt;ul>
&lt;li>페이지 덮어 쓰기와 고장 복구를 위한 WAL 유지 대신, (LMDB 같은)일부 데이터베이스는 쓰기 시 복사 방식(copy-on-write scheme)을 사용함
&lt;ul>
&lt;li>변경된 페이지는 다른 위치에 기록하고 트리에 상위 페이지의 새로운 버전을 만들어 새로운 위치를 가르키게 함&lt;/li>
&lt;li>동시성 제어에도 유용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>페이지에 전체 키를 저장하는 것이 아니라 &lt;strong>키를 축약&lt;/strong>해 쓰면 공간을 절약할 수 있음
&lt;ul>
&lt;li>트리 내부 페이지에서 키가 키 범위 사이의 경계 역할을 하는 데 충분한 정보만 제공하면 됨&lt;/li>
&lt;li>페이지 하나에 키를 더 많이 채우면 트리는 더 높은 분기 계수를 얻어 트리 깊이 수준을 낮출 수 있음(B+ 트리라 부르기도 함)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>일반적으로 페이지는 디스크 상 어디에나 위치할 수 있기 때문에(키 범위가 가깝다고 가까운 위치애 페이지를 배치하지 않음) 질의가 정렬된 순서로 키 범위의 상당 부분을 스캔해야 한다면 모든 페이지에 대해 디스크 찾기가 필요하기 때문에 페이지 단위 배치는 비효율적임
&lt;ul>
&lt;li>많은 B 트리 구현에서 리프 페이지를 디스크 상에 연속된 순서로 나타나게끔 트리를 배치하려 시도하지만 트리가 커지면 순서를 유지하기 어려움&lt;/li>
&lt;li>LSM 트리는 병합하는 과정에서 저장소의 큰 세그먼트를 한 번에 다시 쓰기 때문에 디스크에서 연속된 키를 서로 가깝게 유지하기 더 쉬움&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>트리에 포인터를 추가
&lt;ul>
&lt;li>각 리프 페이지가 양쪽 형제 페이지에 대한 참조를 가지면 상위 페이지로 다시 이동하지 않아도 순서대로 키를 스캔할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>프랙탈 트리(fractal tree) 같은 변형은 디스크 찾기를 줄이기 위해 로그 구조하 개념을 일부 빌렸음
&lt;ul>
&lt;li>기하학의 프랙탈과는 아무 의미 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="b-트리와-lsm-트리-비교">B 트리와 LSM 트리 비교&lt;/h2>
&lt;p>일반적으로 B 트리가 LSM 트리보다 구현 성숙도가 더 높지만 LSM 트리도 그 성능 특성 때문에 관심을 받고 있다.&lt;/p>
&lt;p>LSM 트리는 보통 쓰기에서 더 빠르고, B 트리는 읽기에서 더 빠르다고 여겨진다.&lt;/p>
&lt;ul>
&lt;li>LSM 트리는 각 컴팩션 단계에 있는 여러 가지 데이터 구조와 SS테이블을 확인해야하므로 읽기가 보통 더 느림&lt;/li>
&lt;/ul>
&lt;p>하지만 벤치마크는 보통 결정적이지 않고 작업부하의 세부 사항에 민감하므로 정확한 비교를 위해 실제 필요한 작업부하로 시스템을 테스트해야한다.&lt;/p>
&lt;h3 id="lsm-트리의-장점">LSM 트리의 장점&lt;/h3>
&lt;p>&lt;strong>B 트리 색인&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>모든 데이터 조각을 최소한 두 번 기록해야한다. (쓰기 전 로그, 트리 페이지)&lt;/li>
&lt;li>해당 페이지 내 몇 바이트만 바뀌어도 한 번에 전체 페이지를 기록해야 하는 오버헤드&lt;/li>
&lt;li>일부 저장소 엔진은 전원에 장애가 발생했을 때 일부만 갱신된 페이지로 끝나지 않게 동일한 페이즈를 두 번 덮어씀&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>로그 구조화 색인&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>SS테이블의 반복된 컴팩션과 병함으로 인해 여러 번 데이터를 다시 씀
&lt;ul>
&lt;li>쓰기 증폭(write amplification)
&lt;ul>
&lt;li>데이터베이스에 쓰기 한 번이 데이터베이스 수명 동안 디스크에 여러 번의 쓰기를 야기하는 효과&lt;/li>
&lt;li>SSD는 수명 동안 블록 덮어쓰기 횟수가 정해져 있으므로 주의해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>쓰기가 많은 애플리케이션에서 성능 병목은 데이터베이스가 디스크에 쓰는 속도일 수 있는데, 이 경우 쓰기 증폭은 성능 비용이다.&lt;/p>
&lt;ul>
&lt;li>저장소 엔진이 디스크에 기록할수록 디스크 대역폭 내 처리할 수 있는 초당 쓰기는 점점 줄어듦&lt;/li>
&lt;/ul>
&lt;p>LSM 트리가 상대적으로 쓰기 증폭이 더 낮고, 트리에서 여러 페이지를 덮어쓰는 것이 아닌 순차적으로 컴팩션된 SS 테이블을 쓰기 때문에, 보통 B 트리보다 쓰기 처리량을 높게 유지할 수 있다.&lt;/p>
&lt;ul>
&lt;li>특히 하드디스크는 순차 쓰기가 임의 쓰기 보다 훨씬 더 빠르다.&lt;/li>
&lt;/ul>
&lt;p>LSM 트리는 압축률이 더 좋다.&lt;/p>
&lt;ul>
&lt;li>보통 B 트리보다 디스크에 더 적은 파일을 생성한다.&lt;/li>
&lt;/ul>
&lt;p>B 트리 저장소 엔진은 파편화로 인해 사용하지 않는 디스크 공간 일부가 남는다.&lt;/p>
&lt;ul>
&lt;li>페이지를 나누거나 로우가 기존 페이지에 맞지 않을 때 페이지의 일부 공간은 사용하지 않게됨&lt;/li>
&lt;li>LSM 트리는 페이지 지향적이지 않고 주기적으로 파편화를 없애기 위해 SS테이블을 다시 기록하기 때문에 저장소 오버헤드가 더 낮다.(레벨 컴팩션 사용시 특히 더)&lt;/li>
&lt;/ul>
&lt;p>대다수의 SSD 펌웨어는 내장 저장소 칩에서 임의 쓰기를 순차 쓰기로 전환하기 우해 내부적으로 로그 구조화 알고리즘을 사용한다.&lt;/p>
&lt;ul>
&lt;li>그래서 저장소 엔진의 쓰기 패턴이 SSD에 미치는 영향은 분명하지 않음&lt;/li>
&lt;li>하지만 낮은 쓰기 증폭과 파편화 감소는 SSD의 경우 훨씬 유리함&lt;/li>
&lt;/ul>
&lt;p>데이터를 더 밀집해 표현하면 가능한 I/O 대역폭 내에서 더 많은 읽기와 쓰기 요청이 가능하다.&lt;/p>
&lt;h3 id="lms-트리의-단점">LMS 트리의 단점&lt;/h3>
&lt;p>로그 구조화 저장소의 단점은 &lt;strong>컴팩션 과정&lt;/strong>이 때로는 진행 중인 읽기와 쓰기의 성능에 영향을 준다는 점이다.&lt;/p>
&lt;p>저장소 엔진은 컴팩션을 점진적으로 수행하고 동시 접근의 영향이 없게 수행하려 하지만, 디스크가 가진 자원은 한계가 있으므로 디스크에서 비싼 &lt;strong>컴팩션 연산이 끝날 때까지 요청이 대기해야하는 상황&lt;/strong>이 발생하기 쉽다.&lt;/p>
&lt;p>처리량과 평균 응답 시간이 성능에 미치는 영향은 대개 작으나 로그 구조화 저장소 엔진의 상위 백분위 질의의 응답 시간은 때때로 길다.&lt;/p>
&lt;p>반면 B 트리의 성능은 로그 구조화 저장소 엔진보다 예측하기 쉽다.&lt;/p>
&lt;hr>
&lt;p>또 다른 컴팩션 문제는 높은 쓰기 처리량에서 발생한다.&lt;/p>
&lt;p>디스크의 쓰기 대역폭은 유한하기 때문에 초기 쓰기(로깅(logging)과 멤테이블을 디스크로 방출(flushing))와 백그라운드에서 수행되는 컴팩션 스레드가 이 대역폭을 공유해야한다.&lt;/p>
&lt;p>빈 데이터베이스에 쓰는 경우 전체 디스크 대역폭을 초기 쓰기만을 위해 사용할 수 있지만, 데이터베이스가 커질수록 컴팩션을 위해 더 많은 디스크 대역폭이 필요하다.&lt;/p>
&lt;p>쓰기 처리량이 높음에도 컴팩션 설정을 주의 깊게 하지 않으면 컴팩션이 유입 쓰기 속도를 따라갈 수 없다.&lt;/p>
&lt;ul>
&lt;li>디스크 상에 병합되지 않은 세그먼트 수는 디스크 공간이 부족할 때 까지 증가할 수 있음&lt;/li>
&lt;li>더 많은 세그먼트 파일을 확인해야 하기 때문에 읽기 또한 느려짐&lt;/li>
&lt;/ul>
&lt;p>보통 SS테이블 기반 저장소 엔진은 컴팩션이 유입 속도를 따라가지 못해도 유입 쓰기의 속도를 조절하지 않으므로 이런 상황을 감지하기 위한 명시적 모니터링이 필요하다.&lt;/p>
&lt;hr>
&lt;p>B 트리의 장점은 &lt;strong>각 키가 색인의 한 곳에만 정확하게 존재한다는 점&lt;/strong>이다. 하지만 로그 구조화 저장소 엔진은 다른 세그먼트에 같은 키의 다중 복사본이 존재할 수 있다.&lt;/p>
&lt;p>이런 측면 때문에 강력한 트랜잭션 시맨틱(semantic)를 제공하는 데이터베이스에는 B 트리가 훨씬 매력적이다.&lt;/p>
&lt;ul>
&lt;li>많은 관계형 데이터베이스에서 트랜잭션 격리(transactional isolation)는 키 범위의 잠금을 사용해 구현한 반면 B 트리 색인에서는 &lt;strong>트리에 직접 잠금을 포함&lt;/strong>시킴&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>B 트리는 데이터베이스 아키텍처에 아주 깊게 뿌리내렸고, 많은 작업부하에 대해 지속적으로 좋은 성능을 제공하므로 금방 사라질 가능성은 거의 없으며, 새로운 데이터 저장소에서는 로그 구조화 색인이 점점 인기를 얻고 있다.&lt;/p>
&lt;p>사용 사례에 적합한 저장소 엔진의 유형을 결정하기 위한 빠르고 쉬운 규칙은 없기 때문에 테스트를 통해 경험적으로 결정하는 방법도 나쁘지 않다.&lt;/p>
&lt;h2 id="기타-색인-구조">기타 색인 구조&lt;/h2>
&lt;p>지금까지는 키-값 색인을 살펴봤다.&lt;/p>
&lt;p>대표적인 기-값 색인 예시는 관계형 모델의 &lt;strong>기본키(primary-key)&lt;/strong> 색인이다.&lt;/p>
&lt;ul>
&lt;li>기본키로 관계형 테이블에서 하나의 로우를, 문서 데이터베이스에서 하나의 문서를, 그래프 데이터베이스에서 하나의 정점을 고유하게 식별&lt;/li>
&lt;li>데이터베이스에서 다른 레코드는 기본키로 로우/문서/정점을 참조할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>보조 색인(secondary index)&lt;/strong> 을 사용하는 방식도 매우 일반적이다.&lt;/p>
&lt;ul>
&lt;li>관계형 데이터베이스에서 &lt;code>CREATE INDEX&lt;/code> 명령을 통해 보조 색인을 생성할 수 있음&lt;/li>
&lt;li>보조 색인은 보통 효율적인 조인을 수행하는 데 결정적인 역할을 함&lt;/li>
&lt;/ul>
&lt;p>보조 색인은 키-값 색인에서 쉽게 생성할 수 있는데, 기본키 색인과의 주요 차이점은 키가 고유하지 않다는 점이다.&lt;/p>
&lt;ul>
&lt;li>같은 키를 가진 많은 로우(문서, 정점)이 있을 수 있음&lt;/li>
&lt;/ul>
&lt;p>이 점은 두 가지 방법으로 개선될 수 있다.&lt;/p>
&lt;ul>
&lt;li>색인의 각 값에 일치하는 로우 식별자 목록을 만들기&lt;/li>
&lt;li>로우 식별자를 추가해 각 키를 고유하게 만들기&lt;/li>
&lt;/ul>
&lt;p>어느 쪽이든 보조 색인으로 B 트리와 로그 구조화 색인 둘 다 사용할 수 있다.&lt;/p>
&lt;h3 id="색인-안에-값-저장하기">색인 안에 값 저장하기&lt;/h3>
&lt;p>색인에서 키는 질의가 검색하는 대상이지만, 값은 다음의 두 가지 중 하나에 해당한다.&lt;/p>
&lt;ul>
&lt;li>질문의 실제 로우&lt;/li>
&lt;li>다른 곳에 저장된 로우를 가르키는 참조&lt;/li>
&lt;/ul>
&lt;p>후자의 경우 로우가 저장된 곳을 &lt;strong>힙 파일&lt;/strong>(heap file)이라 하고 특정 순서 없이 데이터를 저장함&lt;/p>
&lt;p>힙 파일 접근은 여러 보조 색인이 존재할 때 데이터 중복을 피할 수 있기 때문에 일반적인 방식이다.&lt;/p>
&lt;ul>
&lt;li>각 색인은 힙 파일에서 위치만 참조하고 실제 데이터는 일정한 곳에 유지함&lt;/li>
&lt;/ul>
&lt;p>힙 파일 접근 방식은 키를 변경하지 않고 값을 갱신할 때 꽤 효율적이다.&lt;/p>
&lt;ul>
&lt;li>새로운 값이 이전 값보다 많은 공간을 필요로 하지 않으면 레코드를 제자리에 덮어쓸 수 있음&lt;/li>
&lt;/ul>
&lt;p>하지만 새로운 값이 많은 공간을 필요로 한다면 힙에서 충분한 공간이 있는 새로운 곳으로 위치를 이동해야한다.&lt;/p>
&lt;ul>
&lt;li>이러한 경우 모든 색인이 레코드의 새로운 힙 위치를 가르키게끔 갱신하거나 이전 힙 위치에 전방향 포인터를 남겨야함&lt;/li>
&lt;/ul>
&lt;p>색인에서 힙 파일로 다시 이동하는 일은 읽기 성능에 불이익이 너무 많기 때문에, 어떤 상황에서는 색인 안에 바로 색인된 로우를 저장하는 편이 바람직 할 수 있다.&lt;/p>
&lt;p>이를 &lt;strong>클러스터드 색인&lt;/strong>(clustered index)라고 하며, MySQL의 InnoDB 저장소 엔진에서는 테이블의 기본키가 언제가 클러스터드 색인이고 보조 색인은 (힙 파일의 위치가 아닌) 기본키를 참조한다.&lt;/p>
&lt;p>클러스터드 색인과 비 클러스터드 색인 사이의 절충안을 커버링 색인(covering index)이나 포괄열이 있는 색인(index with included column)이라 한다.&lt;/p>
&lt;ul>
&lt;li>색인 안에 테이블의 컬럼 일부를 저장&lt;/li>
&lt;li>색인만 사용해 일부 질의에 응답이 가능함(색인이 질의를 커버했다고 말함)&lt;/li>
&lt;/ul>
&lt;p>모든 종류의 데이터 복제와 마찬가지로 클러스터드 색인과 커버링 색인은 읽기 성능을 높일 수 있지만 추가적인 저장소가 필요하고 쓰기 과정에 오버헤드가 발생한다.&lt;/p>
&lt;p>또한 애플리케이션 단에서 복제로 인한 불일치를 파악할 수 없기 때문에 데이터베이스는 트랜잭션 보장을 강화하기 위해 별도의 노력이 필요하다.&lt;/p>
&lt;h3 id="다중-컬럼-색인">다중 컬럼 색인&lt;/h3>
&lt;p>지금까지 설명한 색인은 하나의 키만 값에 대응하므로 테이블의 다중 컬럼에 동시에 질의를 해야한다면 충분하지 않다.&lt;/p>
&lt;p>다중 컬럼 색인의 가장 일반적인 유형은 &lt;strong>결합 색인&lt;/strong>(concatenated index)이라고 한다.&lt;/p>
&lt;ul>
&lt;li>하나의 컬럼에 다른 컬럼을 추가하는 방식으로 하나의 키에 여러 필드를 단순히 결합&lt;/li>
&lt;li>필드가 결합하는 순서는 색인 정의에 명시&lt;/li>
&lt;/ul>
&lt;p>이 방법은 &lt;code>(성, 이름)&lt;/code>을 키로 전화번호 값으로 하는 색인을 제공하는 전화번호부와 유사하다.&lt;/p>
&lt;ul>
&lt;li>순서가 정렬돼 있으므로 특정 성을 가진 모든 사람, 특정 성 이름 조합을 가진 모든 사람을 찾을 때도 이 색인을 활용할 수 있음&lt;/li>
&lt;li>하지만 특정 이름을 가진 모든 사람을 찾을 때는 쓸모 없음&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>다차원 색인은 한 번에 여러 컬럼에 질의하는 조금 더 일반적인 방법이다.&lt;/p>
&lt;ul>
&lt;li>지리 공간 데이터 등&lt;/li>
&lt;/ul>
&lt;p>레스토랑 검색 웹 사이트에 각 레스토랑의 위도와 경도를 포함한 데이터베이스가 있다고 가정하면, 사용자가 지도에서 레스토랑을 찾을 때 웹 사이트는 사용자가 현재 보는 네모단 지도 영역 내 모든 레스토랑을 찾아야 하므로 다음과 같은 이차원 범위 질의가 필요하다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">restaurants&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">latitude&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">51&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">4946&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">latitude&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">51&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">5079&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">longitude&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">1162&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">longitude&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">1004&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>표준 B 트리나 LSM 트리 색인은 이런 유형의 질의에 효율적으로 응답할 수 없다.&lt;/p>
&lt;ul>
&lt;li>위도 범위 안의 모든 레스토랑이나 경도 범위 안의 모든 레스토랑을 줄 수는 있지만 둘을 동시에 주진 못함&lt;/li>
&lt;/ul>
&lt;p>한 가지 방법은 이차원 위치를 공간 채움 곡선(space-filling curve)을 이용해 단일 숫자로 변환한 다음 일반 B 트리 색인을 사용하는 것이다.&lt;br>
좀 더 일반적인 방법은 R 트리처럼 전문 공간 색인(specialized spatial index)을 사용하는 것이다.&lt;/p>
&lt;p>다차원 색인의 활용은 지리학적인 위치에만 국한되지 않는다.&lt;/p>
&lt;ul>
&lt;li>색상(RGB), 날씨(날짜, 기온)&lt;/li>
&lt;/ul>
&lt;h3 id="전문-검색과-퍼지-색인">전문 검색과 퍼지 색인&lt;/h3>
&lt;p>지금까지 설명한 모든 색인은 정확한 데이터를 대상으로 키의 정확한 값이나 정렬된 키의 값의 범위를 질의할 수 있다고 가정하므로, 철자가 틀린 단어와 같이 &lt;strong>유사한&lt;/strong> 키에 대해서는 검색 할 수 없다.&lt;/p>
&lt;p>이처럼 &lt;strong>애매모호한&lt;/strong>(fuzzy) 질의에는 다른 기술이 필요하다.&lt;/p>
&lt;hr>
&lt;p>전문 검색 엔진은 일반적으로 특정 단어를 검색할 때 해당 단어의 동의어로 질의를 확장한다.&lt;/p>
&lt;p>그리고 단어의 문법적 활용을 무시하고 동일한 문서에서 서로 인접해 나타난 단어를 검색하거나 언어학적으로 텍스트를 분석해 사용하는 등 다양한 기능을 제공한다.&lt;/p>
&lt;p>아파치 루씬은 문서나 질의의 오타에 대처하기 위해 특정 편집 거리(edit distance) 내 단어를 검색할 수 있다.&lt;/p>
&lt;ul>
&lt;li>편집 거리 1은 한 글자가 추가되거나 삭제되거나 교체됐음을 의미&lt;/li>
&lt;/ul>
&lt;p>루씬은 용어 사전을 위해 SS테이블 같은 구조를 사용한다. 이 구조는 작은 인메모리 색인이 필요하며, 이 색인은 키를 찾는데 필요한 정렬 파일의 오프셋을 질의에 알려주는 데 사용한다.&lt;/p>
&lt;p>레벨DB에서 이 인메로리 색인은 일부 키의 희소 컬렉션이지만, 루씬에서 인메모리 색인은 여러 키 내 문자에 대한 &lt;strong>유한 상태 오토마톤&lt;/strong>(finite state automaton)으로 &lt;strong>트라이&lt;/strong>(trie)와 유사하다.&lt;/p>
&lt;ul>
&lt;li>이 오토마톤은 &lt;strong>레벤슈타인 오토마톤&lt;/strong>(levenshtein automaton)으로 변환할 수 있다.&lt;/li>
&lt;li>특정 편집 거리 내에서 효율적인 단어 검색을 제공&lt;/li>
&lt;/ul>
&lt;p>그 밖의 퍼지 검색 기술은 문서 분류 및 머신러닝의 방향으로 진행되고 있다.&lt;/p>
&lt;h3 id="모든-것을-메모리에-보관">모든 것을 메모리에 보관&lt;/h3>
&lt;p>지금까지 설명한 데이터 구조는 모두 디스크 한계에 대한 해결책 이었다.&lt;/p>
&lt;p>디스크는 메인 메모리와 비교해 대루기 어렵다.&lt;/p>
&lt;ul>
&lt;li>자기 디스크와 SSD를 사용할 때 읽기와 쓰기에서 좋은 성능을 원한다면 주의해서 데이터를 디스크에 배치해야 함&lt;/li>
&lt;/ul>
&lt;p>이런 불편함을 참을 수 있는 이유는 디스크의 장점 때문이다.&lt;/p>
&lt;ul>
&lt;li>지속성: 디스크 내용은 전원이 꺼져도 손실되지 않음&lt;/li>
&lt;li>가격: 램보다 훨씬 더 저렴&lt;/li>
&lt;/ul>
&lt;p>하지만 과거에 비해 메인 메모리의 가격이 매우 저렴해졌고, 데이터셋의 대부분은 그다지 크지 않기 때문에 &lt;strong>메모리에 전체를 보관하는 방식&lt;/strong>도 고려할 수 있게 되었으며, 이러한 이유로 &lt;strong>인메모리 데이터베이스&lt;/strong>가 개발되었다.&lt;/p>
&lt;hr>
&lt;p>맴캐시드 같은 일부 인베모리 키-값 저장소는 장비가 재시작되면 데이터 손실을 허용하는 캐시 용도로만 활용되었으나, 다른 인메모리 데이터베이스는 지속성을 목표로 한다.&lt;/p>
&lt;ul>
&lt;li>배터리 전원 공급 RAM 같은 특수 하드웨어 사용&lt;/li>
&lt;li>디스크에 변경 사항의 로그를 기록&lt;/li>
&lt;li>디스크에 주기적인 스냅숏 기록&lt;/li>
&lt;li>다른 장비에 인메모리 상태를 복제&lt;/li>
&lt;/ul>
&lt;p>인메모리 데이터베이스가 재시작 되는 경우 디스크나 네트워크를 통해 복제본에서 상태를 다시 적재해야 한다.&lt;/p>
&lt;p>디스크는 전적으로 지속성을 위한 추가 전용 로그로 사용되고, 읽기는 전적으로 메모리에서 제공되기 때문에 디스크에 기록하더라도 여전히 인메모리 데이터베이스이다.&lt;/p>
&lt;hr>
&lt;p>직관에 어긋나지만 인메모리 데이터베이스의 &lt;strong>성능 강점은 디스크에서 읽지 않아도 된다는 사실 때문은 아니다.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>디스크 기반 저장소 엔진도 운영체제가 최근에 사용한 디스크 블록을 메모리에 캐시하기 때문에 충분한 메모리를 가진 경우에는 디스크에서 읽을 필요 없음&lt;/li>
&lt;li>오히려 인메모리 데이터 구조를 디스크에 기록하기 위한 형태로 부호화하는 오버헤드를 피할 수 있어 더 빠를 수도 있음&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>성능 외에도 인메모리 데이터베이스는 또 다른 재미있는 영역으로서 디스크 기반 색인으로 구현하기 어려운 데이터 모델을 제공한다.&lt;/p>
&lt;ul>
&lt;li>레디스
&lt;ul>
&lt;li>우선순위 큐와 셋 같은 다양한 데이터 구조를 데이터베이스 같은 인터페이스로 제공&lt;/li>
&lt;li>메모리에 모든 데이터를 유지하기 때문에 고현이 비교적 간단&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>최근 연구에 따르면 인메모리 데이터베이스 아키텍처가 디스크 중심 아키텍처에서 발생하는 오버헤드 없이 가용한 메모리보다 더 큰 데이터셋을 지원하게끔 확장할 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>안티 캐싱(anti-caching)&lt;/strong>&lt;br>
메모리가 충분하지 않을 때 가장 최근에 사용하지 않은 데이터를 메모리에서 디스크로 보내고 나중에 다시 접근할 때 메모리에 적재하는 방식으로 동작&lt;/p>
&lt;/blockquote>
&lt;p>운영체제가 가상 메모리와스왑 파일에서 수행하는 방식과 유사하지만 데이터베이스는 전체 메모리 페이지보다 개별 레코드 단위로 작업할 수 있기 때문에 OS보다 효율적으로 메모리를 관리할 수 있다.&lt;/p>
&lt;p>하지만 이 접근 방식은 여전히 전체 색인이 메모리에 있어야 한다.&lt;/p></description></item><item><title>1. 사용자 수에 따른 규모 확장성</title><link>https://codemario318.github.io/post/system-design-interview/1/</link><pubDate>Mon, 22 Apr 2024 14:53:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/1/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/cover.png" alt="Featured image of post 1. 사용자 수에 따른 규모 확장성" />&lt;p>수백만 사용자를 지원하는 시스템을 설계하는 것은 도전적인 과제이며, 지속적인 계량과 끝없는 개선이 요구되는 여정이다.&lt;/p>
&lt;p>이번 장은 한 명의 사용자를 지원하는 시스템에서 시작하여, 최종적으로 몇백만 사용자를 지원하는 시스템을 설계해본다.&lt;/p>
&lt;h2 id="단일-서버">단일 서버&lt;/h2>
&lt;p>모든 컴포넌트가 단 한대의 서버에서 실행되는 간단한 시스템부터 설계해보자.&lt;/p>
&lt;p>웹 앱, 데이터베이스, 캐시 등이 전부 서버 한 대에서 실행된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img.png"
width="615"
height="390"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_hu499b8fa6fe43f3f924784d377eb4708e_41034_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_hu499b8fa6fe43f3f924784d377eb4708e_41034_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="157"
data-flex-basis="378px"
>&lt;/p>
&lt;p>&lt;strong>사용자 요청 처리 흐름&lt;/strong>&lt;br>
&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_1.png"
width="608"
height="382"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_1_hua0cbd5db31f0ad82b45addc6a6db9692_42287_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_1_hua0cbd5db31f0ad82b45addc6a6db9692_42287_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="159"
data-flex-basis="381px"
>&lt;/p>
&lt;ol>
&lt;li>사용자는 도메인 이름(api.mysite.com)을 이용하여 웹사이트에 접속한다. 이 접속을 위해 DNS에 질의하여 IP 주소로 변환하는 과정을 치게 된다.
&lt;ul>
&lt;li>DNS는 보통 서드 파티가 제공하는 유료 서비스를 이용하므로 시스템의 일부는 아니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DNS 조회 결과로 IP 주소가 반환된다.&lt;/li>
&lt;li>해당 IP 주소로 HTTP 요청이 전달된다.&lt;/li>
&lt;li>요청을 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환한다.&lt;/li>
&lt;/ol>
&lt;p>실제 요청은 웹 앱과 모바일 앱 두가지 종류에 단말로 부터 온다.&lt;/p>
&lt;ul>
&lt;li>웹 애플리케이션
&lt;ul>
&lt;li>비즈니스 로직, 데이터 저장 등을 처리하기 위해서 서버 구현용 언어(자바, 파이썬 등)를 사용한다.&lt;/li>
&lt;li>프레젠테이션 용으로는 클라이언트 구현용 언어(HTML, 자바스크립트 등)를 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모바일 앱
&lt;ul>
&lt;li>모바일 앱과 웹 서버 간 통신을 위해서는 HTTP 프로토콜을 이용한다.&lt;/li>
&lt;li>반환될 응답 데이터의 포맷으로는 보통 JSON이 널리 쓰인다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="데이터베이스">데이터베이스&lt;/h2>
&lt;p>사용자가 늘면 서버 하나로는 충분하지 않아서 여러 서버를 두어야 한다.&lt;/p>
&lt;ul>
&lt;li>웹/모바일 트래픽 처리&lt;/li>
&lt;li>데이터베이스&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_2.png"
width="612"
height="377"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_2_hub3bdf37c2a22d7f06e833db20a5f8b0a_53786_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_2_hub3bdf37c2a22d7f06e833db20a5f8b0a_53786_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="162"
data-flex-basis="389px"
>&lt;/p>
&lt;p>웹/모바일 트래픽 처리 서버(웹 계층)와 데이터베이스 서버(데이터 계층)를 분리하면 그 각각을 독립적으로 확장해 나갈 수 있게 된다.&lt;/p>
&lt;h3 id="어떤-데이터베이스를-사용할-것인가">어떤 데이터베이스를 사용할 것인가?&lt;/h3>
&lt;p>전통적인 관계형 데이터베이스와 비-관계형 데이터베이스 사이에서 고를 수 있다.&lt;/p>
&lt;ul>
&lt;li>관계형 데이터베이스
&lt;ul>
&lt;li>관계형 데이터베이스 관리 시스템(RDBMS)이라고도 부르며, 자료를 테이블과 열, 컬럼으로 표현한다.&lt;/li>
&lt;li>SQL을 사용하면 여러 테이블에 있는 데이터를 그 관계에 따라 조인(join)하여 합칠 수 있다.&lt;/li>
&lt;li>ex) MySQL, Oracle, PostgreSQL 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비-관계형 데이터 베이스
&lt;ul>
&lt;li>NoSQL이라고도 부른다.&lt;/li>
&lt;li>키-값 저장소(key-value store), 그래프 저장소(graph store), 컬럼 저장소(column store), 문서 저장소(document store) 네 부류로 나뉜다.&lt;/li>
&lt;li>비-관계형 데이터베이스는 일반적으로 조인 연산은 지원하지 않는다.&lt;/li>
&lt;li>ex) CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>대부분의 개발자에게는 40년 이상 시장에서 살아남아 잘 사용되어온 관계형 데이터베이스가 최선이다.&lt;/p>
&lt;p>하지만 구축하려는 시스템에 적합하지 않은 경우에는 관계형 데이터베이스 이외의 저장소도 살펴보아야한다.&lt;/p>
&lt;ul>
&lt;li>아주 낮은 응답 지연시간(latency)이 요구됨&lt;/li>
&lt;li>다루는 데이터가 비정형(unstructured)이라 관계형 데이터가 아님&lt;/li>
&lt;li>데이터(JSON, YAML, XML 등)를 직렬화하거나(serialize) 역직렬화(deserialize) 할 수 있기만 하면 됨&lt;/li>
&lt;li>아주 많은 양의 데이터를 저장할 필요가 있음&lt;/li>
&lt;/ul>
&lt;h2 id="수직적-규모-확장-vs-수평적-규모-확장">수직적 규모 확장 VS 수평적 규모 확장&lt;/h2>
&lt;h3 id="수직적-규모-확장vertical-scaling">수직적 규모 확장(vertical scaling)&lt;/h3>
&lt;p>&lt;strong>스케일 업(scale up)&lt;/strong> 이라고도 불리는 수직적 규모 확장 프로세스는 서버에 고사양 자원을 추가하는 행위를 말한다.&lt;/p>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>서버로 유입되는 트래픽의 양이 적을 때는 수직적 확장이 좋은 선택이다.&lt;/li>
&lt;li>단순하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법이 없어 한계가 있다.&lt;/li>
&lt;li>장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안을 제시하지 않는다.
&lt;ul>
&lt;li>서버에 장애가 발생하면 완전히 중단된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="수평적-규모-확장horizontal-scaling">수평적 규모 확장(horizontal scaling)&lt;/h3>
&lt;p>&lt;strong>스케일 아웃(scale out)&lt;/strong> 이라고도 불리는 수평적 규모 확장 프로세스는 더 많은 서버를 추가하여 성능을 개선하는 행위를 말한다.&lt;/p>
&lt;p>수직적 규모 확장에서 언급된 단점으로 인해 대규모 애플리케이션을 지원하는 데는 수평적 규모 확장법이 보다 적절하다.&lt;/p>
&lt;hr>
&lt;p>수평적 규모 확장을 위해 추가적인 장치가 필요하다.&lt;/p>
&lt;p>앞서 본 설계에서 사용자가 웹 서버로 바로 연결되는데,&lt;/p>
&lt;ul>
&lt;li>웹 서버가 다운되면 사용자는 웹 사이트에 접속할 수 없다.&lt;/li>
&lt;li>너무 많은 사용자가 접속하여 웹 서버가 한계에 도달하면 응답 속도가 느려지거나 서버 접속이 불가능해질 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이런 문제를 해결하는 데는 부하 분산기 또는 로드밸런서를 도입하는 것이 최선이다.&lt;/p>
&lt;h3 id="로드밸런서load-balancer">로드밸런서(Load balancer)&lt;/h3>
&lt;p>로드밸런서는 부하 분산 집합(load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_3.png"
width="608"
height="540"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_3_huf74bbc3ffd6647fb098a2fc03966306f_85207_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_3_huf74bbc3ffd6647fb098a2fc03966306f_85207_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="270px"
>&lt;/p>
&lt;ul>
&lt;li>사용자는 로드밸런서의 공개 IP 주소로 접속하므로, 웹 서버는 클라이언트의 접속을 직접 처리하지 않는다.&lt;/li>
&lt;li>보안을 위해 서버 간 통신에는 사설 IP 주소가 이용된다.
&lt;ul>
&lt;li>같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 IP 주소로, 인터넷을 통해서 접속할 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>부하 분산 집합에 또 하나의 웹 서버를 추가하고 나면, 장애를 자동복구하지 못하는 문제(no failover)는 해소되며, 웹 계층의 가용성(availability)은 향상된다.&lt;/p>
&lt;ul>
&lt;li>서버 1이 다운되면 모든 트래픽은 서버 2로 전송된다.
&lt;ul>
&lt;li>웹 사이트 전체가 다운되는 일이 방지된다.&lt;/li>
&lt;li>부하를 나누기 위해 새로운 서버를 추가할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹사이트로 유입되는 트래픽이 가파르게 증가할 경우 웹 서버 계층에 더 많은 서버를 추가하면 로드밸런스가 자동적으로 트래픽을 분산한다.&lt;/li>
&lt;/ul>
&lt;h3 id="데이터베이스-다중화">데이터베이스 다중화&lt;/h3>
&lt;p>많은 데이터베이스들이 주(master)-부(slave) 관계를 설정하여 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식으로 다중화를 지원한다.&lt;/p>
&lt;p>쓰기 연산은 마스터에만 지원하며, 부 데이터베이스는 주 데이터베이스로부터 그 사본을 전달받아 읽기 연산만을 지원한다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스를 변경하는 명령어(&lt;code>INSERT&lt;/code>, &lt;code>DELETE&lt;/code>, &lt;code>UPDATE&lt;/code> 등)는 주 데이터베이스로만 전달되어야 한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_4.png"
width="612"
height="546"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_4_hu75d2f6312382855c75a554918b468d43_102326_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_4_hu75d2f6312382855c75a554918b468d43_102326_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="269px"
>&lt;/p>
&lt;p>데이터베이스르 다중화하면 다음과 같은 이득이 있다.&lt;/p>
&lt;ul>
&lt;li>더 나은 성능
&lt;ul>
&lt;li>모든 데이터 변경 연산은 주 데이터베이스 서버로만 전달되는 반면 읽기 연산은 부 데이터베이스 서버들로 분산되어 병렬로 처리될 수 있는 질의(query)가 늘어나므로, 성능이 좋아진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>안정성
&lt;ul>
&lt;li>자연 재해 등의 이유로 데이터베이스 서버 가운데 일부가 파괴되어도 데이터는 보존된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성
&lt;ul>
&lt;li>데이터를 여러 지역에 복제해 둠으로써, 하나의 데이터베이스 서버에 장애가 발생하더라도 다른 서버에 있는 데이터로 계속 서비스할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위와 같은 데이터계층을 구성하면 데이터베이스 서버 가운데 하나가 다운되더라도 아래와 같은 상황을 감당할 수 있다.&lt;/p>
&lt;ul>
&lt;li>부 서버 한대뿐인데 다운된 경우
&lt;ul>
&lt;li>읽기 연산이 한시적으로 주 데이터베이스로 전달된다.&lt;/li>
&lt;li>즉시 새로운 부 데이터베이스 서버가 장애 서버를 대처한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>부 서버 중 한대가 다운된 경우
&lt;ul>
&lt;li>일기 연산이 나머지 부 데이터베이스 서버로 분산된다.&lt;/li>
&lt;li>새로운 부 데이터베이스 서버가 장애 서버를 대체한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>주 데이터베이스 서버가 다운된 경우
&lt;ul>
&lt;li>부 데이터베이스 서버 중 하나가 새로운 주 서버가 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="다중화를-고려한-설계">다중화를 고려한 설계&lt;/h3>
&lt;p>아래는 로드밸런서와 데이터베이스 다중화를 고려한 설계안이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_5.png"
width="615"
height="680"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_5_hu0d3cc45b151b2f2d78ede4b0a35c84d1_160088_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_5_hu0d3cc45b151b2f2d78ede4b0a35c84d1_160088_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="90"
data-flex-basis="217px"
>&lt;/p>
&lt;ol>
&lt;li>사용자는 DNS로부터 로드밸런서의 공개 IP 주소를 받는다.&lt;/li>
&lt;li>사용자는 해당 IP 주소를 사용해 로드밸런서에 접속한다.&lt;/li>
&lt;li>HTTP 요청은 서버 1이나 서버 2로 전달된다.&lt;/li>
&lt;li>웹 서버는 사용자의 데이터를 부 데이터베이스 서버에서 읽는다.&lt;/li>
&lt;li>웹 서버는 데이터 변경 연산은 주 데이터베이스로 전달한다.&lt;/li>
&lt;/ol>
&lt;h2 id="캐시-cache">캐시 Cache&lt;/h2>
&lt;p>캐시를 붙여 응답 시간(latency)를 개선해볼 수 있다.&lt;/p>
&lt;p>캐시는 &lt;strong>값비싼 연산 결과&lt;/strong> 또는 &lt;strong>자주 참조되는 데이터&lt;/strong>를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소이다.&lt;/p>
&lt;p>애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 크게 좌우되는데, 캐시는 그런 문제를 완화할 수 있다.&lt;/p>
&lt;h3 id="캐시-계층">캐시 계층&lt;/h3>
&lt;p>캐시 계층(cache tier)은 데이터가 잠시 보관되는 곳으로 데이터베이스보다 훨씬 빠르다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스보다 훨씬 빠르므로 성능이 개선된다.&lt;/li>
&lt;li>요청 분산으로 데이터베이스의 부하를 줄일 수 있다.&lt;/li>
&lt;li>캐시 계층의 규모를 독립적으로 확장시키는 것도 가능해진다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_6.png"
width="613"
height="116"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_6_huc62d7a17723bf3e18e1d3339b357022d_33317_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_6_huc62d7a17723bf3e18e1d3339b357022d_33317_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="528"
data-flex-basis="1268px"
>&lt;/p>
&lt;p>요청받은 웹 서버는 캐시에 응답이 저장되어 있는지를 확인 후 저장되어 있다면 해당 데이터 반환하고 없을 경우 데이터베이스 조회하여 결과를 반환하는데, 이러한 캐시 전략을 &lt;strong>읽기 주도형 캐시 전략(read-through caching strategy)&lt;/strong> 이라고 부른다.&lt;/p>
&lt;p>이외에도 다양한 캐시 전략이 있으며, 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 선택하면 된다.&lt;/p>
&lt;ul>
&lt;li>쓰기 주도형 캐시 전략 (Write-Through Cache)
&lt;ul>
&lt;li>데이터를 업데이트할 때 캐시와 백엔드 데이터 소스 모두에 동시에 업데이트&lt;/li>
&lt;li>데이터 일관성을 유지하면서 쓰기 작업을 처리&lt;/li>
&lt;li>쓰기 작업의 경우 백엔드 저장소로의 추가적인 I/O 작업이 필요하므로 성능 저하의 가능성이 있지만, 데이터 일관성을 보장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>쓰기 지연형 캐시 전략 (Write-Behind Cache)
&lt;ul>
&lt;li>데이터 업데이트를 먼저 캐시에만 적용하고, 나중에 백엔드 데이터 소스에 업데이트를 적용&lt;/li>
&lt;li>이는 쓰기 작업의 지연을 최소화하여 응답 시간을 줄이는 데 도움&lt;/li>
&lt;li>쓰기 지연형 캐시는 데이터 일관성을 유지하기 위해 추가적인 메커니즘을 필요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>자세한 내용의 캐시 전략 (Write-Through and Read-Through Cache):
&lt;ul>
&lt;li>읽기와 쓰기 모두에 대해 캐시를 사용하는 전략&lt;/li>
&lt;li>데이터가 요청될 때마다 읽기 주도형 캐시와 유사하게 작동하며, 데이터가 업데이트될 때마다 쓰기 주도형 캐시와 유사한 방식으로 작동&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>캐시 앞 단의 캐시 전략 (Cache-Aside Cache):
&lt;ul>
&lt;li>클라이언트가 데이터를 직접 캐시에 저장하고 검색하는 방식&lt;/li>
&lt;li>캐시에 데이터가 없는 경우 클라이언트는 백엔드 데이터 소스에서 직접 데이터를 가져와서 캐시에 저장하고 응답&lt;/li>
&lt;li>이 방식은 간단하고 유연하며, 응용 프로그램 코드 내에 캐시 로직을 명시적으로 구현할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이중 캐시 전략 (Two-Level Cache):
&lt;ul>
&lt;li>두 개의 캐시 레이어를 사용하여 성능을 최적화&lt;/li>
&lt;li>보통 두 개의 캐시는 크기와 접근 속도 등에서 차이가 있음&lt;/li>
&lt;li>먼저 작은 고속 캐시가 데이터를 저장하고, 그 다음에 큰 용량의 캐시가 데이터를 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오프힙 로컬 캐시 전략 (Off-Heap Local Cache Strategy):
&lt;ul>
&lt;li>캐시를 메모리 외의 오프힙(Off-Heap) 영역에 저장하여 자바 가상 머신의 힙 메모리 한계를 초과하는 데이터 양을 처리할 수 있게 함&lt;/li>
&lt;li>이는 대규모 캐시나 대용량 데이터를 다룰 때 유용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="캐시-사용-시-유의할-점">캐시 사용 시 유의할 점&lt;/h3>
&lt;ul>
&lt;li>데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어나는 경우 고려할 수 있다.&lt;/li>
&lt;li>캐시는 데이터를 휘발성 메모리에 두므로, 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다.&lt;/li>
&lt;li>데이터를 무기한 보존할 수 없으므로 만료에 대한 정책을 마련해야한다.
&lt;ul>
&lt;li>너무 짧으면 데이터베이스 읽기가 자주 발생한다.&lt;/li>
&lt;li>너무 길면 원본과 차이 날 가능성이 높아진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 일관성이 깨질 수 있다.&lt;/li>
&lt;li>캐시 서버를 한 대만 두는 경우 해당 서버가 단일 장애 지점(Single Point of Failure, SPOF)이 되어버릴 가능성이 있다.
&lt;ul>
&lt;li>여러 지역에 걸처 캐시 서버를 분산시켜야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>캐시 메모리가 너무 작으면 액세스 패턴에 따라 데이터가 자주 캐시에서 밀려나 성능이 떨어지게 된다.
&lt;ul>
&lt;li>캐시 메모리를 과할당하면 데이터가 갑자기 늘어났을 때 생길 문제를 방지할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>캐시가 가득 찼을 때 추가로 데이터를 넣기 위한 데이터 방출 정책을 적절히 지정해야한다.
&lt;ul>
&lt;li>가장 널리 쓰이는 것은 LRU(least Recently Used - 가장 오래 사용 안된 데이터)나 FIFO(가장 먼저 들어온) 등이 있으며 경우에 맞게 적용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="콘텐츠-전송-네트워크-cdn">콘텐츠 전송 네트워크 CDN&lt;/h2>
&lt;p>응답 시간을 개선할 방법으로 CDN(Content Delivery Network)를 적용해 볼 수 있다.&lt;/p>
&lt;p>CDN은 정적 콘텐츠를 전성하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크이다. (이미지, 비디오, CSS, JS 파일 등)&lt;/p>
&lt;ul>
&lt;li>요청 경로, 질의 문자열, 쿠키, 요청 헤더 등의 정보에 기반하여 HTML을 캐싱하는 &lt;strong>동적 콘텐츠 캐싱&lt;/strong>도 적용해 볼 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_7.png"
width="605"
height="231"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_7_hu799239a592ed42b7290231250760d8ad_30988_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_7_hu799239a592ed42b7290231250760d8ad_30988_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="261"
data-flex-basis="628px"
>&lt;/p>
&lt;p>어떤 사용자 웹 사이트를 방문하면, 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달하며, 사용자가 CDN 서버로부터 멀어질 수록 천천히 로드될 것이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_8.png"
width="612"
height="218"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_8_hu5d5fc61be434c460205659abbfd7acf0_63071_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_8_hu5d5fc61be434c460205659abbfd7acf0_63071_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="280"
data-flex-basis="673px"
>&lt;/p>
&lt;ol>
&lt;li>사용자 A가 이미지 URL을 이용해 &lt;code>image.png&lt;/code>에 접근한다.(URL의 도메인은 CDN 서비스 사업자가 제공한다.)&lt;/li>
&lt;li>CDN 서버의 캐시에 해당 이미지가 없는 경우 원본 서버에서 요청하여 파일을 가져온다.&lt;/li>
&lt;li>원본 서버가 파일을 CDN 서버에 반환한다.
&lt;ul>
&lt;li>응답 HTTP 헤더에 TTL(Time-To-Live) 값을 넣어 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CDN 서버는 파일을 캐시하고 사용자 A에게 반환한다.
&lt;ul>
&lt;li>이미지는 TTL에 명신된 시간이 끝날 때 까지만 캐시된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자 B가 같은 이미지를 CDN 서버에게 요청한다.&lt;/li>
&lt;li>만료되지 않은 이미지에 대한 요청은 캐시를 통해 처리된다.&lt;/li>
&lt;/ol>
&lt;h3 id="cdn-사용-시-고려해야-할-사항">CDN 사용 시 고려해야 할 사항&lt;/h3>
&lt;ul>
&lt;li>비용
&lt;ul>
&lt;li>CDN은 보통 서드파티에 의해 운영되며, CDN으로 들어가고 나가는 데이터 전송 양에 따라 요금을 낸다.&lt;/li>
&lt;li>자주 사용되지 않는 콘텐츠를 캐싱하는 것은 이득이 적으므로, CDN에서 빼는 것을 고려할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>적절한 만료 시한 설정
&lt;ul>
&lt;li>시의성이 중요한(time-sensitive) 콘텐츠는 만료 시점을 잘 정해야한다.&lt;/li>
&lt;li>너무 길면 콘텐츠의 신선도가 떨어진다.&lt;/li>
&lt;li>너무 짧으면 원본 서버에 빈번히 접속되어 좋지 않다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CDN 장애 대처 방안
&lt;ul>
&lt;li>CDN 자체가 죽었을 경우 애플리케이션이 어떻게 동작해야 하는지 고려해야 한다.&lt;/li>
&lt;li>응답을 감지하여 원본 서버에서 가져오는 등의 방식으로 처리한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>콘텐츠 무효화 방법
&lt;ul>
&lt;li>만료되지 않은 콘텐츠라도 CDN에서 제거할 수 있다.&lt;/li>
&lt;li>CDN 서비스 사업자가 제공하는 API 활용&lt;/li>
&lt;li>콘텐츠의 다른 버전을 서비스 하도록 오브젝트 버저닝 이용.
&lt;ul>
&lt;li>&lt;code>image.png?v=2&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="cdn과-캐시가-추가된-설계">CDN과 캐시가 추가된 설계&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_9.png"
width="625"
height="670"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_9_hu460b71978870d67db3c5f1597124e471_170383_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_9_hu460b71978870d67db3c5f1597124e471_170383_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="93"
data-flex-basis="223px"
>&lt;/p>
&lt;ol>
&lt;li>정적 콘텐츠를 CDN을 통해 제공하여 더 나은 성능을 보장한다.&lt;/li>
&lt;li>캐시가 데이터베이스 부하를 줄여준다.&lt;/li>
&lt;/ol>
&lt;h2 id="무상태stateless-웹-계층">무상태(Stateless) 웹 계층&lt;/h2>
&lt;p>웹 계층을 수평적으로 확장하는 방법을 고민해 볼 수 있다.&lt;/p>
&lt;p>이를 위해 상태 정보(사용자 세션 등)를 웹 계층에서 제거해야한다.&lt;/p>
&lt;p>바람직한 전략은 상태 정보를 관계형 데이터베이스나 NoSQL 같은 지속성 저장소에 보관하고, 필요할 때 가져오도록 하는 것이다.&lt;/p>
&lt;p>이렇게 구성된 웹 계층을 &lt;strong>무상태 웹 계층&lt;/strong>이라 부른다.&lt;/p>
&lt;h3 id="상태-정보-의존적인-아키텍처">상태 정보 의존적인 아키텍처&lt;/h3>
&lt;p>상태 정보를 보고나하는 서버는 클라이언트 정보, 즉 상태를 유지하여 요청들 사이에 공유되도록 하지만, 무상태 서버에는 이러한 장치가 없다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_10.png"
width="624"
height="387"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_10_hu5fb9397f4d4b70e8494c0677a4642dc6_65604_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_10_hu5fb9397f4d4b70e8494c0677a4642dc6_65604_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="161"
data-flex-basis="386px"
>&lt;/p>
&lt;p>위와 같은 경우 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야 한다.&lt;/p>
&lt;p>로드밸런서가 이를 지원하기 위해 고정 세션이라는 기능을 제공하지만, 이는 로드밸런서에 부담을 줄 수 있다.&lt;/p>
&lt;p>또한 로드 밸런서 뒷단에 서버를 추가하거나 제거하기도 까다로워지며, 이들 서버의 장애를 처리하기도 복잡해진다.&lt;/p>
&lt;h3 id="무상태-아키텍처">무상태 아키텍처&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_11.png"
width="601"
height="582"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_11_hu39f308bbb91eb0dc2a5c19d7114ea62c_76175_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_11_hu39f308bbb91eb0dc2a5c19d7114ea62c_76175_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="103"
data-flex-basis="247px"
>&lt;/p>
&lt;p>무상태 아키텍처는 사용자로부터의 HTTP 요청은 어떤 웹 서버로도 전달될 수 있다.&lt;/p>
&lt;p>웹 서버는 상태 정보가 필요할 경우 물리적으로 분리된 공유 저장소로부터 데이터를 가져온다.&lt;/p>
&lt;h3 id="무상태-웹-계층을-갖는-설계">무상태 웹 계층을 갖는 설계&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_12.png"
width="592"
height="593"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_12_hu8a96a4f1289cdc64fec7a7b4b0f65b88_150815_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_12_hu8a96a4f1289cdc64fec7a7b4b0f65b88_150815_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="99"
data-flex-basis="239px"
>&lt;/p>
&lt;ul>
&lt;li>세션 데이터를 웹 계층에서 분리하고 지속성 데이터 보관소에 저장하도록 만들었다.
&lt;ul>
&lt;li>공유 저장소는 관계형 데이터베이스일 수도 있고, 캐시일 수도 있으며, NoSQL일 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>상태 정보가 웹 서버들로부터 제거되었으므로 자동으로 규모를 확장할 수 있다.&lt;/li>
&lt;/ul>
&lt;h2 id="데이터-센터">데이터 센터&lt;/h2>
&lt;p>애플리케이션의 사용자가 매우 많다면 가용성을 높이고 쾌적하게 사용할 수 있도록 하기 위해 여러 데이터 센터를 지원하는 것이 필수적이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_13.png"
width="605"
height="612"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_13_huacec91b27a2e95c1fae44550dc9946c4_231088_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_13_huacec91b27a2e95c1fae44550dc9946c4_231088_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="98"
data-flex-basis="237px"
>&lt;/p>
&lt;p>&lt;strong>지리적 라우팅&lt;/strong>&lt;/p>
&lt;p>장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내되는데 이 절차를 지리적 라우팅(geoDNS-routing 또는 geo-routing)이라고 부른다.&lt;/p>
&lt;p>geoDNS는 사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변활할지 결정할 수 있도록 해주는 DNS 서비스다.&lt;/p>
&lt;p>&lt;strong>데이터 센터 장애&lt;/strong>&lt;/p>
&lt;p>데이터 센터 중 하나에 심각한 장애가 발생하면 모든 트래픽은 장애가 없는 데이터 센터로 전송된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_14.png"
width="598"
height="619"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_14_huae6b76823045f17d81dcfd1753a37701_207085_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_14_huae6b76823045f17d81dcfd1753a37701_207085_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="96"
data-flex-basis="231px"
>&lt;/p>
&lt;p>이에 따라 다중 데이터센터 아키텍처를 만들려면 몇 가지 기술적 난제를 해결해야 한다.&lt;/p>
&lt;ul>
&lt;li>트래픽 우회
&lt;ul>
&lt;li>올바른 데이터센터로 트래픽을 보내는 효과적인 방법을 찾아야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 동기화(Synchronization)
&lt;ul>
&lt;li>데이터를 여러 데이터센터에 걸쳐 다중화 하여, 장애 복구 시에도 데이터를 동기화 할 수 있도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>테스트와 배포
&lt;ul>
&lt;li>여러 데이터 센터를 사용하도록 시스템이 구성된 상황이라면 웹 사이트 또는 애플리케이션을 여러 위치에서 테스트 해보는 것이 중요하다.&lt;/li>
&lt;li>자동화된 배포 도구는 모든 데이터 센터에 동일한 서비스가 설치되도록 하는 데 중요한 일을 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="메시지-큐message-queue">메시지 큐(Message Queue)&lt;/h2>
&lt;p>시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하여, 각기 독립적으로 확장될 수 있어야 한다.&lt;/p>
&lt;p>메시지 큐는 분산 시스템이 이 문제를 풀기 위해 채용하고 있는 핵심 전략 가운데 하나다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_15.png"
width="606"
height="141"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_15_huc34a000f73eb7366f54fab25c10cd600_37954_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_15_huc34a000f73eb7366f54fab25c10cd600_37954_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="429"
data-flex-basis="1031px"
>&lt;/p>
&lt;p>메시지 큐는 메시지의 무손실을 보장하는 비동기 통신을 지원하는 컴포넌트로 메시지의 버퍼 역할을 하며, 비동기적으로 전송한다.&lt;/p>
&lt;ol>
&lt;li>생산자 또는 발행자라고 불리는 입력 서비스가 메시지를 만들어 메시지 큐에 발행한다.&lt;/li>
&lt;li>소비자 혹은 구독자라 불리는 서비스 혹은 서버가 메시지를 받아 그에 맞는 동작을 수행한다.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>메시지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해져서, 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.&lt;/p>
&lt;ul>
&lt;li>생산자는 소비자 프로세스가 다운되어 있어도 메시지를 발행할 수 있다.&lt;/li>
&lt;li>소비자는 생산자 서비스가 가용한 상태가 아니더라도 메시지를 수신할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>큐가 커지면 더 많은 작업 프로세스를 추가해야 처리 시간을 줄일 수 있으며, 큐가 거의 항상 비어있는 상태라면, 작업 프로세스의 수를 줄일 수 있다.&lt;/p>
&lt;h2 id="로그-메트릭-그리고-자동화">로그, 메트릭 그리고 자동화&lt;/h2>
&lt;p>웹 사이트와 함께 사업 규모가 커지고 나면, 로그나 메트릭, 자동화 같은 도구에 필수적으로 투자해야한다.&lt;/p>
&lt;ul>
&lt;li>로그
&lt;ul>
&lt;li>시스템의 오류와 문제들을 쉽게 찾아낼 수 있게 돕는다.&lt;/li>
&lt;li>로그를 단일 서비스로 모아주는 도구를 활용하면 더 편리하게 검색하고 조회할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메트릭
&lt;ul>
&lt;li>사업 현황에 관한 유용한 정보를 얻을 수도 있고, 시스템의 현재 상태를 쉽게 파악할 수 있다.&lt;/li>
&lt;li>호스트 단위 메트릭: CPU, 메모리, 디스크 I/O,에 관한 메트릭&lt;/li>
&lt;li>종합 메트릭: 데이터베이스 계층의 성능, 캐시 계층의 성능 등&lt;/li>
&lt;li>핵심 비즈니스 메트릭: 일별 능동 사용자, 수익, 재방문 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>자동화
&lt;ul>
&lt;li>시스템이 크고 복잡해지면 생산성을 높이기 위해 자동화 도구를 활용해야한다.&lt;/li>
&lt;li>지속적 통합을 활용한 검증 절차 수행 및 빌드, 테스트, 배포 절차 자동화 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="수정한-설계안">수정한 설계안&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_16.png"
width="595"
height="741"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_16_hu91dcf9847683962bf50eb168546423cd_177817_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_16_hu91dcf9847683962bf50eb168546423cd_177817_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="80"
data-flex-basis="192px"
>&lt;/p>
&lt;ul>
&lt;li>메시지 큐는 각 컴포넌트가 보다 느슨히 결합될 수 있도록 하고, 결함에 대한 내성을 높인다.&lt;/li>
&lt;li>로그, 모니터링, 메트릭, 자동화 등을 지원하기 위한 장치를 추가한다.&lt;/li>
&lt;/ul>
&lt;h2 id="데이터베이스-규모-확장">데이터베이스 규모 확장&lt;/h2>
&lt;p>저장할 데이터가 많아지면 데이터베이스에 대한 부하도 증가한다.&lt;/p>
&lt;p>데이터베이스의 규모를 확장하는데는 앞서 언급했던 수직적 규모 확장과 수평적 규모 확장을 고려할 수 있다.&lt;/p>
&lt;p>&lt;strong>수평적 확장&lt;/strong>&lt;/p>
&lt;p>기존 서버에 더 많은, 고성능의 자원을 증설하는 방법이다.&lt;/p>
&lt;p>스택오버플로는 천만 명의 사용자 전부를 단 한 대의 마스터 데이터베이스로 처리했다.&lt;/p>
&lt;p>하지만 언급했던대로 몇가지 심각한 약점이 있다.&lt;/p>
&lt;ul>
&lt;li>무한 증설할 수는 없다.&lt;/li>
&lt;li>SPOF로 인한 위험성이 크다.&lt;/li>
&lt;li>비용이 많이 든다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>수평적 확장&lt;/strong>&lt;/p>
&lt;p>데이터베이스의 수평적 확장은 샤딩(sharding)이라고도 부르는데, 더 많은 서버를 추가함으로써 성능을 향상시킬 수 있도록 한다.&lt;/p>
&lt;h3 id="샤딩">샤딩&lt;/h3>
&lt;ul>
&lt;li>대규모 데이터베이스를 샤드(shard)라고 부르는 작은 단위로 분할하는 기술을 일컫는다.&lt;/li>
&lt;li>모든 샤드는 같은 스키마를 쓰지만 보관되는 데이터 사이에는 중복이 없다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_17.png"
width="369"
height="266"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_17_huc997d539c0fa3f28c4bae7dad9a2068b_33539_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_17_huc997d539c0fa3f28c4bae7dad9a2068b_33539_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="138"
data-flex-basis="332px"
>&lt;/p>
&lt;p>위의 예시에서 &lt;code>user_id % 4&lt;/code>를 해시 함수로 사용하여 데이터가 보관되는 샤드를 정한다.&lt;/p>
&lt;p>이처럼 샤딩 전략을 구현할 때 고려해야 할 가장 중요한 것은 &lt;strong>샤딩 키&lt;/strong>를 어떻게 정하냐 하는 것이다.&lt;/p>
&lt;ul>
&lt;li>샤딩 키(파티션 키)는 데이터가 어떻게 분살될지 정하는 하나 이상의 컬럼으로 구성된다.&lt;/li>
&lt;li>샤딩 키를 통해 올바른 데이터베이스에 질의를 보내어 데이터 조회나 변경을 처리하므로 효율을 높일 수 있다.&lt;/li>
&lt;/ul>
&lt;p>샤딩 키를 정할 때는 데이터를 고르게 분할 할 수 있도록 하는 게 가장 중요하다.&lt;/p>
&lt;p>&lt;strong>주의사항&lt;/strong>&lt;/p>
&lt;p>샤딩은 데이터베이스 규모 확장을 실현하는 휼륭한 기술이지만 완벽하지 않으며, 도입하면 시스템이 복잡해지고 풀어야 할 새로운 문제도 생긴다.&lt;/p>
&lt;ul>
&lt;li>데이터의 재 샤딩
&lt;ul>
&lt;li>데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어려울 때&lt;/li>
&lt;li>샤드 소진: 샤드 간 데이터 분포가 균등하지 못하여 어떤 샤드에 할당된 공간 소모가 다른 사드에 비해 빨리 진행될 때&lt;/li>
&lt;li>이러한 형상이 발생하면 샤드 키를 계산하는 함수를 변경하고 데이터를 재배치 하여야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유명인사 문제(핫스팟 키 문제)
&lt;ul>
&lt;li>특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제다.&lt;/li>
&lt;li>특정 샤드의 원인에 대해 샤드를 하나씩 할당해야 할 수도 있고, 더 잘개 쪼개야 할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>조인과 비정규화
&lt;ul>
&lt;li>데이터베이스를 여러 샤드 서버로 쪼개고 나면, 여러 샤드에 걸친 데이터를 조인하기가 힘들어진다.&lt;/li>
&lt;li>데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="샤드를-적용한-아키텍처">샤드를 적용한 아키텍처&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/1/img_18.png"
width="643"
height="800"
srcset="https://codemario318.github.io/post/system-design-interview/1/img_18_hu3cfaabe2145c01222e45ae94975b52ee_217530_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/1/img_18_hu3cfaabe2145c01222e45ae94975b52ee_217530_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="80"
data-flex-basis="192px"
>&lt;/p>
&lt;ul>
&lt;li>데이터베이스에 대한 부하를 줄이기 위해 굳이 관계형 데이터베이스가 요구되지 않는 기능들은 NoSQL로 이전할 수 있다.&lt;/li>
&lt;/ul>
&lt;h2 id="백만-사용자-그리고-그-이상">백만 사용자, 그리고 그 이상&lt;/h2>
&lt;p>시스템의 규모를 확장하는 것은 지속적이고 반복적인 과정이며, 이번 장에서 다룬 내용을 반복하다 보면 원하는 규모의 시스템을 달성할 수 있게 된다.&lt;/p>
&lt;p>그러나 수백만 사용자 이상을 지원하려면 새로운 전략을 도입해야 하고 지속적으로 시스템을 가다듬어야 할 것이다.&lt;/p>
&lt;ul>
&lt;li>시스템 최적화 및 마이크로서비스 등&lt;/li>
&lt;/ul>
&lt;h2 id="정리">정리&lt;/h2>
&lt;ul>
&lt;li>웹 계층은 무상태 계층으로&lt;/li>
&lt;li>모든 계층에 다중화 도입&lt;/li>
&lt;li>가능한 한 많은 데이터를 캐시할 것&lt;/li>
&lt;li>여러 데이터 센터를 지원할 것&lt;/li>
&lt;li>정적 콘텐츠는 CDN을 통해 서비스할 것&lt;/li>
&lt;li>데이터 계층은 샤딩을 통해 그 규모를 확장할 것&lt;/li>
&lt;li>각 계층은 독립적 서비스로 분할할 것&lt;/li>
&lt;li>시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것&lt;/li>
&lt;/ul></description></item></channel></rss>