<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>웹소켓 on Mario Blog</title><link>https://codemario318.github.io/tags/%EC%9B%B9%EC%86%8C%EC%BC%93/</link><description>Recent content in 웹소켓 on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Sat, 04 Jan 2025 14:57:49 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/%EC%9B%B9%EC%86%8C%EC%BC%93/index.xml" rel="self" type="application/rss+xml"/><item><title>웹소켓 시스템의 성능 개선하기</title><link>https://codemario318.github.io/post/websocket-scale-out/</link><pubDate>Sat, 04 Jan 2025 14:57:49 +0900</pubDate><guid>https://codemario318.github.io/post/websocket-scale-out/</guid><description>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/cover.png" alt="Featured image of post 웹소켓 시스템의 성능 개선하기" />&lt;p>최근 실시간 다중 사용자 퀴즈 게임을 구현하면서 단순하게 서버 1대와 인메모리(이하 세션)를 이용한 방식으로 웹소켓을 이용해 게임 진행과 채팅 기능을 구현했었는데요.&lt;/p>
&lt;p>당시 부하 테스트 결과로 초당 5,000건 이상의 메시지 처리가 가능했기 때문에, 목표로 했던 300명 이상의 참여자 동시 진행이 가능했습니다.&lt;/p>
&lt;p>하지만 게임에 참여하는 사용자가 많아지면 현재 상황에서는 분명 한계가 있겠죠? 그래서 웹소켓 서버의 처리량을 늘리는 방법들에 대해서 알아보려 합니다.&lt;/p>
&lt;h2 id="수평-확장과-수직-확장">수평 확장과 수직 확장&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img.png"
width="1024"
height="659"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_hu1795940aac2814a197193d8fc3eed447_80445_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_hu1795940aac2814a197193d8fc3eed447_80445_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="img.png"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="372px"
>&lt;/p>
&lt;p>시스템의 성능을 향상시킬 때 기본적으로 &lt;strong>수평 확장&lt;/strong>과 &lt;strong>수직 확장&lt;/strong> 두 가지 접근 방식을 고려할 수 있습니다.&lt;/p>
&lt;h3 id="수직-확장-scale-up">수직 확장 (Scale Up)&lt;/h3>
&lt;p>단일 서버의 성능을 향상시키는 방법입니다. CPU, 메모리, 디스크 등 하드웨어 리소스를 증설하여 성능을 개선합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>장점:&lt;/strong>
&lt;ul>
&lt;li>구현이 간단하며 추가적인 아키텍처 변경이 필요 없음&lt;/li>
&lt;li>단일 서버이므로 데이터 일관성 유지가 쉬움&lt;/li>
&lt;li>네트워크 복잡도가 낮음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>단점:&lt;/strong>
&lt;ul>
&lt;li>하드웨어 비용이 기하급수적으로 증가&lt;/li>
&lt;li>물리적인 한계가 존재&lt;/li>
&lt;li>장애 발생 시 전체 시스템에 영향&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="수평-확장-scale-out">수평 확장 (Scale Out)&lt;/h3>
&lt;p>동일한 서버를 여러 대 추가하여 부하를 분산시키는 방법입니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>장점:&lt;/strong>
&lt;ul>
&lt;li>선형적인 비용 증가로 효율적&lt;/li>
&lt;li>무한한 확장이 이론적으로 가능&lt;/li>
&lt;li>고가용성과 장애 허용성 확보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>단점:&lt;/strong>
&lt;ul>
&lt;li>아키텍처가 복잡해짐&lt;/li>
&lt;li>데이터 일관성 유지가 어려움&lt;/li>
&lt;li>네트워크 오버헤드 발생&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>수직 확장은 단순히 서버 스펙을 올리는 것으로 한계가 명확하기 때문에(&lt;del>비싸기 때문에&lt;/del>), 수평 확장 위주로 성능을 개선하는 것이 바람직해보입니다.&lt;/p>
&lt;p>이제 수평 확장을 위한 구체적인 방법들을 살펴보겠습니다.&lt;/p>
&lt;h2 id="웹소켓의-특성">웹소켓의 특성&lt;/h2>
&lt;p>먼저 여러 시도를 하기 전 웹소켓의 연결 특성에 대해 이해할 필요가 있습니다.&lt;/p>
&lt;p>웹소켓은 클라이언트와 서버 간에 지속 &lt;strong>연결 상태를 유지&lt;/strong>하므로, 수평 확장 시 각 서버에 &lt;strong>클라이언트 연결이 분산&lt;/strong>됩니다.&lt;/p>
&lt;p>이를 해결하기 위해 &lt;strong>서버 간 상태를 동기화&lt;/strong>하거나 상황에 맞게 클라이언트가 &lt;strong>특정 서버에 고정&lt;/strong>되도록 설정해야 합니다.&lt;/p>
&lt;h2 id="로드-밸런싱">로드 밸런싱&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_1.png"
width="1650"
height="1275"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_1_hue58ad55d5fe691e3e59586d3994effac_81538_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_1_hue58ad55d5fe691e3e59586d3994effac_81538_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="로드 밸런싱"
class="gallery-image"
data-flex-grow="129"
data-flex-basis="310px"
>&lt;/p>
&lt;p>수평 확장을 통해 서비스의 요청을 분산하기 위해 여러 대의 서버를 배포하면 실제로 배포된 여러 서버로 요청을 분산해야겠죠&lt;/p>
&lt;p>로드 밸런싱은 들어오는 네트워크 트래픽을 여러 서버에 효율적으로 분산하는 기술입니다.&lt;/p>
&lt;h3 id="sticky-sessions-vs-non-sticky-sessions">Sticky Sessions vs Non-Sticky Sessions&lt;/h3>
&lt;p>네트워크 트래픽을 분산하기 위한 여러 알고리즘이 존재하는데, 클라이언트 요청이 같은 서버로 가는지 아닌지에 따라 나눌 수 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_2.png"
width="850"
height="400"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_2_hu00407f29da576d8704b9ee37e577ead4_25051_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_2_hu00407f29da576d8704b9ee37e577ead4_25051_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Sticky Sessions vs Non-Sticky Sessions"
class="gallery-image"
data-flex-grow="212"
data-flex-basis="510px"
>&lt;/p>
&lt;p>Non-Sticky Sessions은 클라이언트의 요청이 매번 다른 서버로 자유롭게 라우팅될 수 있는 방식으로 stateless 아키텍처를 구현할 때 선호되는 방식입니다.&lt;/p>
&lt;p>주요 차이점을 비교하면:&lt;/p>
&lt;ol>
&lt;li>상태 관리
&lt;ul>
&lt;li>Sticky Sessions: 서버가 클라이언트의 상태를 메모리에 보관&lt;/li>
&lt;li>Non-Sticky Sessions: 모든 상태를 Redis 같은 외부 저장소에 보관&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>장애 대응
&lt;ul>
&lt;li>Sticky Sessions: 서버 장애 시 해당 서버의 모든 세션 손실&lt;/li>
&lt;li>Non-Sticky Sessions: 서버 장애와 무관하게 세션 유지 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장성
&lt;ul>
&lt;li>Sticky Sessions: 특정 서버에 부하가 집중될 수 있음&lt;/li>
&lt;li>Non-Sticky Sessions: 더 균등한 부하 분산 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>웹소켓의 경우 연결 자체가 stateful하기 때문에 일반적으로 Sticky Sessions을 사용하지만, &lt;strong>대규모 시스템&lt;/strong>에서는 Non-Sticky Sessions 방식을 채택하고 모든 상태를 외부 저장소에 보관하는 방식을 사용하기도 합니다.&lt;/p>
&lt;h2 id="서버-간-상태-동기화">서버 간 상태 동기화&lt;/h2>
&lt;p>저희 서비스에서는 사용자가 퀴즈존을 기반으로 서버의 세션을 통해 관리되기 때문에, 퀴즈존에 참여하고 있는 모든 사용자가 동일한 서버에 연결되어야 합니다.&lt;/p>
&lt;p>이는 상황에 따라 사용자가 많이 참여하고 있는 퀴즈존이 특정 서버에 집중되는 경우 수평 확장의 장점을 가져갈 수 없게 되는 문제를 발생시킬 수 있습니다.&lt;/p>
&lt;p>이렇게 특정 서버에 세션에 의존하지 않게 만들기 위해 &lt;strong>서버 간의 상태를 동기화&lt;/strong> 해야할 필요가 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_3.png"
width="385"
height="131"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_3_hufe3d7b7f11325482bb16b822eb0a78ec_8599_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_3_hufe3d7b7f11325482bb16b822eb0a78ec_8599_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Redis"
class="gallery-image"
data-flex-grow="293"
data-flex-basis="705px"
>&lt;/p>
&lt;p>단순히 서버 간의 상태를 동기화 한다면, 모든 사용자에 대한 정보를 모든 서버가 메모리로 가져야하고 이를 수시로 업데이트 해야하는 문제가 있습니다.&lt;/p>
&lt;p>이는 배포된 각각의 서버의 메모리가 충분해야는 것이 기본 전제이므로 메모리로 인한 서버 비용 절감은 의미가 없어질 뿐 아니라 상태 동기화를 위한 여러 오버헤드가 발생하므로 효과적인 방식으로 보긴 어렵습니다.&lt;/p>
&lt;p>그래서 더 단순한 방법으로 배포된 여러 서버가 같은 세션을 바라보게 만드는 방법을 활용하는 경우가 많고, 세션은 빠른 읽기/쓰기가 요구되므로 주로 &lt;code>Redis&lt;/code>를 활용합니다.&lt;/p>
&lt;h2 id="pubsub-패턴-적용">Pub/Sub 패턴 적용&lt;/h2>
&lt;p>위처럼 서버 간의 상태를 동기화했다고 하더라도, 웹소켓의 특성상 특정 서버에 연결된 클라이언트에게만 직접 메시지를 전송할 수 있습니다. 다른 서버에 연결된 클라이언트에게는 직접적인 메시지 전송이 불가능한 것이죠.&lt;/p>
&lt;p>이 문제를 해결하기 위해 메시지 브로커를 활용한 Pub/Sub 패턴을 적용할 수 있습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_4.png"
width="2050"
height="1168"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_4_hu3cc9ed0eaf825475f37e7ff59c7a86c6_734061_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_4_hu3cc9ed0eaf825475f37e7ff59c7a86c6_734061_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Pub/Sub 패턴"
class="gallery-image"
data-flex-grow="175"
data-flex-basis="421px"
>&lt;/p>
&lt;ul>
&lt;li>각 서버는 메시지 브로커(예: Redis, RabbitMQ, Kafka)의 채널을 구독(Subscribe)&lt;/li>
&lt;li>메시지 전송이 필요할 때는 해당 채널에 메시지를 발행(Publish)&lt;/li>
&lt;li>모든 서버가 메시지를 수신하고, 자신에게 연결된 클라이언트에게 필요한 메시지를 전달&lt;/li>
&lt;/ul>
&lt;p>이러한 방식을 통해 서버 간 직접적인 통신 없이도 모든 클라이언트에게 메시지를 전달할 수 있습니다.&lt;/p>
&lt;h2 id="auto-scaling">Auto Scaling&lt;/h2>
&lt;p>리소스를 효율적으로 관리하기 위해, 트래픽에 따라 서버를 동적으로 확장하고 축소하는 것이 이상적입니다.&lt;/p>
&lt;ul>
&lt;li>저희 서비스도 근본적으로는 게임이라서 저녁 시간대에 트래픽이 집중되지 않을까 예상해봅니다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_5.png"
width="560"
height="332"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_5_hu8d0a7bc59b0e5202eca4aab1e4c19efd_27969_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_5_hu8d0a7bc59b0e5202eca4aab1e4c19efd_27969_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Auto Scaling"
class="gallery-image"
data-flex-grow="168"
data-flex-basis="404px"
>&lt;/p>
&lt;p>하지만 웹소켓 서버의 동적 확장 시에는 몇 가지 고려해야 할 문제들이 있습니다.&lt;/p>
&lt;h3 id="서버-추가">서버 추가&lt;/h3>
&lt;p>새로운 서버가 추가되었을 때, 기존 클라이언트들은 이미 다른 서버들과 연결이 되어있는 상태입니다. 이로 인해 새로운 서버는 새로 접속하는 클라이언트의 연결만 받게 되어 서버 간 부하 분산이 균형있게 이루어지지 않을 수 있습니다.&lt;/p>
&lt;p>이를 해결하기 위해서는 다음과 같은 방법들을 고려할 수 있습니다:&lt;/p>
&lt;ul>
&lt;li>연결 재분배 (Connection Rebalancing)
&lt;ul>
&lt;li>주기적으로 서버 간 연결 수를 확인하고 불균형이 발생하면 일부 클라이언트에게 재연결 요청&lt;/li>
&lt;li>클라이언트는 재연결 시 로드밸런서를 통해 새로운 서버에 고르게 분배됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가중치 기반 라우팅
&lt;ul>
&lt;li>새로운 서버에 더 높은 가중치를 부여하여 신규 연결을 더 많이 할당&lt;/li>
&lt;li>점진적으로 서버 간 연결 수가 균형을 이루도록 조정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="서버-제거">서버 제거&lt;/h3>
&lt;p>서버를 제거할 때는 해당 서버에 연결된 클라이언트들의 연결을 적절히 처리해야 합니다. 갑작스러운 연결 종료는 사용자 경험을 해칠 수 있으며, 서비스의 안정성에도 영향을 미칩니다.&lt;/p>
&lt;p>이를 위한 해결 방안으로는:&lt;/p>
&lt;ul>
&lt;li>Draining Mode 구현
&lt;ul>
&lt;li>서버 제거 전에 해당 서버를 &amp;lsquo;draining&amp;rsquo; 상태로 전환&lt;/li>
&lt;li>더 이상 새로운 연결을 받지 않도록 로드밸런서 설정 변경&lt;/li>
&lt;li>기존 연결은 유지하면서 자연스럽게 감소하도록 유도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Graceful Shutdown with Notification
&lt;ul>
&lt;li>종료 예정인 서버의 클라이언트들에게 재연결 필요성을 알리는 메시지 전송&lt;/li>
&lt;li>클라이언트는 메시지 수신 후 다른 서버로 재연결 시도&lt;/li>
&lt;li>일정 시간 후 남아있는 연결을 정상적으로 종료&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="zookeeper">ZooKeeper&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/websocket-scale-out/img_6.png"
width="921"
height="498"
srcset="https://codemario318.github.io/post/websocket-scale-out/img_6_hu9638b0602de60e14c3a3201684f97ad9_138457_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/websocket-scale-out/img_6_hu9638b0602de60e14c3a3201684f97ad9_138457_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Apache ZooKeeper"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="443px"
>&lt;/p>
&lt;p>이러한 처리들의 원활한 관리를 위해 서버들의 상태를 효과적으로 관리하고 모니터링하는 것이 중요합니다. Apache ZooKeeper와 같은 도구를 활용하면 이러한 분산 환경에서의 서버 관리를 효율적으로 수행할 수 있습니다.&lt;/p>
&lt;ul>
&lt;li>서버 상태 관리
&lt;ul>
&lt;li>각 서버는 ZooKeeper에 임시 노드(ephemeral node)를 생성하여 자신의 상태를 등록&lt;/li>
&lt;li>서버 장애 시 노드가 자동으로 삭제되어 빠른 장애 감지 가능&lt;/li>
&lt;li>현재 활성화된 서버 목록을 실시간으로 파악 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>부하 분산 정보 공유
&lt;ul>
&lt;li>각 서버의 현재 연결 수, 리소스 사용량 등을 ZooKeeper에 저장&lt;/li>
&lt;li>로드밸런서는 이 정보를 바탕으로 최적의 서버 선택 가능&lt;/li>
&lt;li>동적 가중치 조정에 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>설정 정보 관리
&lt;ul>
&lt;li>서버 구성 정보, 환경 설정 등을 중앙화된 저장소에서 관리&lt;/li>
&lt;li>설정 변경 시 모든 서버에 실시간으로 반영 가능&lt;/li>
&lt;li>일관된 설정 유지 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>Auto Scaling과의 연계&lt;/strong>&lt;/p>
&lt;p>ZooKeeper를 Auto Scaling과 연계하면 더욱 효과적인 서버 관리가 가능합니다:&lt;/p>
&lt;ul>
&lt;li>스케일 인/아웃 이벤트 발생 시 서버 목록 자동 업데이트&lt;/li>
&lt;li>새로운 서버 추가 시 기존 서버들과의 설정 동기화&lt;/li>
&lt;li>서버 제거 시 안전한 종료 절차 조율&lt;/li>
&lt;li>서버 간 부하 분산 상태 모니터링 및 재조정&lt;/li>
&lt;/ul>
&lt;p>이러한 ZooKeeper의 활용은 특히 Auto Scaling 환경에서 서버들의 동적인 변화를 안정적으로 관리하는 데 큰 도움이 될 수 있고, 서버의 추가와 제거가 자주 발생하는 환경에서도 서비스의 안정성과 가용성을 높은 수준으로 유지할 수 있다는 장점도 있습니다.&lt;/p>
&lt;h2 id="정리">정리&lt;/h2>
&lt;p>웹소켓 기반의 실시간 게임 서비스를 확장하면서 발생할 수 있는 문제들과 해결 방안들을 살펴보았습니다.&lt;/p>
&lt;ul>
&lt;li>서버 확장성 문제
&lt;ul>
&lt;li>수평적 확장을 통한 처리량 증가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>상태 관리 문제
&lt;ul>
&lt;li>Redis를 활용한 세션 저장소 외부화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 전달 문제
&lt;ul>
&lt;li>Pub/Sub 패턴 도입&lt;/li>
&lt;li>메시지 브로커를 통한 효율적인 메시지 전파&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>동적 확장 문제
&lt;ul>
&lt;li>서버의 동적 추가, 제거로 인한 문제&lt;/li>
&lt;li>ZooKeeper 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>연결이 유지되는 특성 때문에 발생하는 문제들이 많았네요&lt;/p>
&lt;p>어떤 방식들을 적용해야할지 고민을 더 해봐야겠습니다.&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다😊&lt;/p></description></item><item><title>2. 주변 친구</title><link>https://codemario318.github.io/post/system-design-interview-2/2/</link><pubDate>Sun, 18 Aug 2024 15:59:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/2/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/cover.png" alt="Featured image of post 2. 주변 친구" />&lt;p>이번 장에서는 &lt;strong>주변 친구&lt;/strong>(&lt;strong>nearby friends&lt;/strong>)라는 모바일 앱 기능을 지원하는 규모 확장이 용이한 백엔드 시스템을 설계해본다.&lt;/p>
&lt;blockquote>
&lt;p>앱 사용자 가운데 본인 위치 정보 접근 권한을 허락한 사용자에 한에 인근의 친구 목록을 보여주는 시스템&lt;/p>
&lt;/blockquote>
&lt;p>1장 &lt;strong>근접성 서비스&lt;/strong>와 &lt;strong>주변 친구&lt;/strong> 는 비슷해 보이지만 큰 차이가 있다.&lt;/p>
&lt;ul>
&lt;li>근접성 서비스의 사업장 주소는 정적이다.&lt;/li>
&lt;li>주변 친구 위치는 자주 바뀐다.&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>페이스북 규모를 지원하는 백엔드 시스템은 복잡하다. 따라서 설계 시작 전 질문을 통해 설계 범위를 좁혀야한다.&lt;/p>
&lt;ul>
&lt;li>Q. 지리적으로 얼마나 가까워야 &lt;strong>주변에 있다&lt;/strong>고 할 수 있는가?
&lt;ul>
&lt;li>A. 5마일. 이 수치는 설정 가능해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 두 사용자 사이의 직선 거리라고 가정?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 얼마나 많은 사용자가 이 앱을 사용하는가? 10억명을 가넝하고, 그 가운데 10% 정도가 이 기능을 활용한다고 생각해도 괜찮은가?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 사용자의 이동 이력을 보관해 둬야하는가?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 친구 관계에 있는 사용자가 10분 이상 비활성 상태면 해당 사용자를 주변 친구 목록에서 사라지도록 해야하는가? 마지막 확인 위치를 표시하는가?
&lt;ul>
&lt;li>A. 사라지게 할 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. GDPR, CCPA 같은 사생활 및 데이터 보호법도 고려해야하는가?
&lt;ul>
&lt;li>A. 과정이 너무 복잡해질 수 있으므로 배제&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="기능-요구사항">기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>사용자는 모바일 앱에서 &lt;strong>주변 친구를 확인&lt;/strong>할 수 있어야 한다.
&lt;ul>
&lt;li>&lt;strong>해당 친구까지의 거리&lt;/strong> 표시&lt;/li>
&lt;li>정보가 &lt;strong>마지막으로 갱신된 시간&lt;/strong>이 함께 표시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이 친구 목록은 &lt;strong>몇 초마다 한번 씩 갱신&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>낮은 지연 시간&lt;/strong>(low latency)
&lt;ul>
&lt;li>주변 친구의 위치 변화가 반영되는 데 너무 오랜 시간이 걸리지 않아야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>안정성&lt;/strong>
&lt;ul>
&lt;li>전반적으로 안정적이어야 하지만, 가끔 몇 개 데이터가 유실되는 것 정도는 용인 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>결과정 일관성&lt;/strong>
&lt;ul>
&lt;li>위치 데이터를 저장하기 위해 강한 일관성을 지원하는 데이터 저장소를 사용할 필요는 없다.&lt;/li>
&lt;li>복제본의 데이터가 원본과 동일하게 변경되기까지 몇 초 정도 걸리는 것은 용인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;p>제시할 솔루션이 풀어야 할 도전적 과제를 결정하기 위해, 개략적으로 문제 규모를 추정한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>주변 친구&lt;/strong>는 5마일(8km) 반경 이내 친구로 정의&lt;/li>
&lt;li>위치 정보는 &lt;strong>30초&lt;/strong> 주기로 갱신
&lt;ul>
&lt;li>사람의 걷는 속도가 &lt;code>4-6km/h&lt;/code> 정도로 느림&lt;/li>
&lt;li>30초 주기라면 주변 친구 검색 결과가 크게 달라지지는 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>평균적으로 매일 주변 친구 검색 기능을 활용하는 사용자는 &lt;strong>1억명&lt;/strong>으로 가정&lt;/li>
&lt;li>동시 접속 사용자의 수는 **DAU의 10%**로 가정
&lt;ul>
&lt;li>&lt;strong>천만명&lt;/strong>이 동시에 시스템을 이용한다고 가정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>평균적으로 한 사용자는 &lt;strong>400명&lt;/strong>의 친구를 갖는다고 가정&lt;/li>
&lt;li>모든 친구가 주변 친구 검색 기능을 활용한다고 가정&lt;/li>
&lt;li>이 기능을 제공하는 앱은 한 페이지당 20명의 주변 친구를 표시&lt;/li>
&lt;li>사용자의 요청이 있다면 더 많은 주변 친구를 노출&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>QPS 계산&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>1억 DAU&lt;/li>
&lt;li>동시 접속 사용자: &lt;code>10% * 1억 = 천만&lt;/code>&lt;/li>
&lt;li>사용자는 30초마다 자기 위치를 시스템에 전송&lt;/li>
&lt;li>&lt;code>위치 정보 갱신 QPS = 천만 / 30 = ~334,000&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>위치 정보를 모든 친구에게 전송해야 한다는 요구사항으로 인해 클라이언트와 서버 사이의 통신 프로토콜로 단순한 HTTP 프로토콜을 사용하지 못하게 될 수 있음을 감안해야한다.&lt;/p>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>이번 문제는 &lt;strong>메시지의 효과적 전송을 가능케 할 설계얀&lt;/strong>을 요구한다.&lt;/p>
&lt;p>개념적으로 보면 사용자는 근방의 모든 활성 상태 친구의 새 위치 정보를 수신하고자 한다. 이론적으로 순수한 P2P(peer-to-peer) 방식으로도 해결 가능한 문제이다.&lt;/p>
&lt;p>다시 말해, &lt;strong>활성 상태인 근방 모든 친구와 항구적 통신 상태를 유지&lt;/strong>하면 되는 것이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img.png"
width="898"
height="582"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_hudccc12625b6529e9eab4e26e4b039577_67180_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_hudccc12625b6529e9eab4e26e4b039577_67180_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="154"
data-flex-basis="370px"
>&lt;/p>
&lt;p>P2P 통신은 실용적인 아이디어는 아니지만 &lt;strong>추구해야 할 설계 방향에 대한 통찰&lt;/strong>은 얻을 수 있다.&lt;/p>
&lt;p>이보다 조금 더 실용적인 설계안은 &lt;strong>공용 백엔드&lt;/strong>를 사용하는 것이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_1.png"
width="1184"
height="552"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_1_hu5459bc5b3622841e964dbbf3c2d834b0_49710_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_1_hu5459bc5b3622841e964dbbf3c2d834b0_49710_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="214"
data-flex-basis="514px"
>&lt;/p>
&lt;p>백엔드는 다음과 같은 역할을 담당한다.&lt;/p>
&lt;ul>
&lt;li>모든 활성 상태 사용자의 위치 변화 내역을 수신&lt;/li>
&lt;li>사용자 위치 변경 내역을 수신할 때마다 해당 사용자의 모든 활성 상태 친구를 찾아 그 친구들의 단말로 변경 내역을 전달
&lt;ul>
&lt;li>두 사용자 사이의 거리가 특정 임계치보다 먼 경우 변경 내역을 전송하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>간단해 보이지만 문제의 가정이 활성 상태의 동시 접속 사용자 천만 명이므로 &lt;strong>큰 규모에 적용하기가 쉽지 않다&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>천만명이 자기 위치 정보를 30초마다 갱신하면 &lt;strong>334,000번&lt;/strong>의 위치 정보 갱신 처리가 필요하다.&lt;/li>
&lt;li>사용자 1명은 400명의 친구를 가지고, 그 중 10%가 인근에서 활성화 상태라면, 초당 &lt;code>334,000 * 400 * 10% = 1400만&lt;/code> 건의 위치 정보 갱신 요청을 처리해야한다.&lt;/li>
&lt;li>엄청난 양의 갱신 내역을 사용자 단말로 보내야한다.&lt;/li>
&lt;/ul>
&lt;h3 id="설계안">설계안&lt;/h3>
&lt;p>우선 소규모 백엔드를 위한 개략적 설계안에서 시작하여 더 큰 규모에 맞게 확장해나간다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_2.png"
width="1422"
height="1266"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="269px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>로드 밸런서&lt;/strong>&lt;/p>
&lt;p>&lt;strong>RESTful API&lt;/strong> 서버 및 양방향 유상태 웹소켓 서버 앞단에 위치한다.&lt;/p>
&lt;p>부하를 고르게 분산하기 위해 &lt;strong>트래픽을 서버들에 배분&lt;/strong>하는 역할을 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>RESTful API 서버&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>무상태 API 서버의 클러스터&lt;/li>
&lt;li>통상적인 요청/응답 트래픽을 처리&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>친구를 추가/삭제&lt;/strong>하거나 &lt;strong>사용자 정보를 갱신&lt;/strong>하는 등의 부가적인 작업을 처리한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>웹소켓 서버&lt;/strong>&lt;/p>
&lt;p>친구 위치 정보 변경을 거의 실시간에 가깝게 처리하는 &lt;strong>유상태 서버 클러스터&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>각 클라이언트는 클러스터 내 한 대 서버와 웹소켓 연결은 지속적으로 유지&lt;/li>
&lt;li>검색 반경 내 친구 위치가 변경되면 해당 내역은 이 연결을 통해 클라이언트로 전송&lt;/li>
&lt;li>주변 친구 기능을 이용하는 클라이언트의 초기화 담당
&lt;ul>
&lt;li>온라인 상태인 모든 주변 친구 위치를 해당 클라이언트로 전송&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>레디스 위치 정보 캐시&lt;/strong>&lt;/p>
&lt;p>활성 상태 사용자의 가장 최근 위치 정보를 캐시하는 데 사용한다.&lt;/p>
&lt;ul>
&lt;li>레디스에 보관하는 캐시 항목에는 TTL(Time-To-Live) 필드가 있어, 설정한 기간이 지나면 해당 사용자는 비활성으로 바뀌고 위치 정보는 캐시에서 삭제된다.&lt;/li>
&lt;li>캐시에 보관된 정보를 갱신할 때 TTL도 갱신한다.&lt;/li>
&lt;/ul>
&lt;p>레디스가 아니더라도 TTL을 지원하는 키-값 저장소는 캐시로 활용될 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>사용자 데이터 베이스&lt;/strong>&lt;/p>
&lt;p>&lt;strong>사용자 데이터&lt;/strong> 및 &lt;strong>사용자의 친구 관계 정보를 저장&lt;/strong>한다.&lt;/p>
&lt;p>관계형 데이터베이스, NoSQL 어느 쪽이든 사용 가능하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>위치 이동 이력 데이터베이스&lt;/strong>&lt;/p>
&lt;p>사용자의 위치 변동 이력을 보관한다.&lt;/p>
&lt;p>주변 친구 표시와 직접 관계된 기능은 아니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>레디스 펍/섭 서버&lt;/strong>&lt;/p>
&lt;p>레디스 펍/섭은 &lt;strong>초경량 메시지 버스&lt;/strong>(message bus)다.&lt;/p>
&lt;ul>
&lt;li>레디스 펍/섭에 새로운 채널을 생성하는 것은 아주 값싼 연결이다.&lt;/li>
&lt;li>기가바이트급 메모리를 갖춘 최신 레디스 서버에는 수백만 개의 채널(토픽)을 생성할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_4.png"
width="1380"
height="740"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_4_hu84b0294fda6052ece73743e1e4417308_92336_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_4_hu84b0294fda6052ece73743e1e4417308_92336_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="186"
data-flex-basis="447px"
>&lt;/p>
&lt;ol>
&lt;li>웹소켓 서버를 통해 수신한 &lt;strong>특정 사용자의 위치 정보 변경 이벤트&lt;/strong>는 &lt;strong>해당 사용자에게 배정된 펍/섭 채널에 발행&lt;/strong>한다.
&lt;ul>
&lt;li>해당 사용자의 친구 각각과 연결된 웹소켓 연결 핸들러는 해당 채널의 구독자로 설정되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>특정 사용자의 위치가 바뀌면 해당 사용자의 모든 친구의 웹소켓 연결 핸들러가 호출된다.&lt;/li>
&lt;li>핸들러는 위치 변경 이벤트를 수신할 친구가 활성 상태면 거리를 다시 계산한다.
&lt;ul>
&lt;li>검색 반경 이내면 갱신된 위치와 갱신 시간을 웹소켓 연결을 통해 해당 친구의 클라이언트 앱으로 보낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>다른 메시지 버스 기술도 경량의 통신 채널만 제공한다면 같은 형태로 사용 가능하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>주기적 위치 갱신&lt;/strong>&lt;/p>
&lt;p>모바일 클라이언트는 항구적으로 유지되는 웹소켓 연결을 통해 주기적으로 위치 변경 내역을 전송한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_2.png"
width="1422"
height="1266"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_2_hua344ac7794771a904330aed37800f6cc_135168_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="269px"
>&lt;/p>
&lt;ol>
&lt;li>모바일 클라이언트가 위치가 변경된 사실을 로드밸런서에 전송&lt;/li>
&lt;li>로드밸런서는 그 위치 변경 내역을 해당 클라이언트와 웹소켓 서버 사이에 설정된 연결을 통해 웹소켓 서버로 보냄&lt;/li>
&lt;li>아래 작업을 병렬로 수행
&lt;ul>
&lt;li>웹소켓 서버는 해당 이벤트를 위치 이동 이력 데이터베이스에 저장&lt;/li>
&lt;li>웹소켓 서버는 새 위치를 위치 정보 캐시에 보관
&lt;ul>
&lt;li>TTL도 새롭게 갱신&lt;/li>
&lt;li>웹소켓 연결 핸들러 안의 변수에 해당 위치를 반영(거리 계산에 활용)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹소켓 서버는 레디스 펍/섭 서버의 해당 사용자 채널에 새 위치를 발행&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>레디스 펍/섭 채널에 발행된 새로운 위치 변경 이벤트는 모든 구독자(웹소켓 이벤트 핸들러)에게 브로드캐스트된다.
&lt;ul>
&lt;li>구독자는 위치 변경 이벤트를 보낸 사용자의 온라인 상태 친구들&lt;/li>
&lt;li>구독자의 웹소켓 연결 핸들러는 친구의 위치 변경 이벤트를 수신&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지를 받는 웹 소켓 서버, 즉 웹 소켓 연결 핸들러가 위치한 웹 소켓 서버는 새 위치를 보낸 사용자와 메시지를 받은 사용자 사이의 거리를 새로 계산
&lt;ul>
&lt;li>검색 반경을 넘지 않는다면 새 위치 및 해당 위치로의 이동이 발생한 시각을 나타내는 타임스탬프를 해당 구독자의 클라이언트 앱으로 전송&lt;/li>
&lt;li>넘은 경우에는 보내지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_5.png"
width="1362"
height="1182"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_5_huf8fa9909ecee52bd94a35a1416186d93_155836_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_5_huf8fa9909ecee52bd94a35a1416186d93_155836_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="276px"
>&lt;/p>
&lt;ol>
&lt;li>사용자 1의 위치가 변경되면 그 변경 내역은 사용자 1과의 연결을 유지하고 있는 웹소켓 서버에 전송됨&lt;/li>
&lt;li>해당 변경 내역은 레디스 펍/섭 서버 내의 사용자 1 전용 채널로 발행&lt;/li>
&lt;li>레디스 펍/섭 서버는 해당 변경 내역을 모든 구독자에게 브로드캐스트한다.
&lt;ul>
&lt;li>구독자는 사용자 1과 친구 관계에 있는 모든 웹소켓 연결 핸들러&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>위치 변경 내역을 보낸 사용자와 구독자 사이의 거리(사용자 1과 2 사이의 거리)가 검색 반경을 넘지 않을 경우 새로운 위치는 사용자 2의 클라이언트로 전송&lt;/li>
&lt;/ol>
&lt;p>이 계산 과정은 해당 채널의 모든 구독자에게 반복 적용된다.&lt;/p>
&lt;ul>
&lt;li>한 사용자의 위치가 바뀔 때마다 이치 정보 전송은 40건 정도 발생할 것이다.&lt;/li>
&lt;/ul>
&lt;h3 id="api-설계">API 설계&lt;/h3>
&lt;p>필요한 API를 나열해본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>웹소켓&lt;/strong>&lt;/p>
&lt;p>사용자는 웹소켓 프로토콜을 통해 위치 정보 변경 내역을 전송하고 수신하므로, 최소한 다음 API는 구비되어야 한다.&lt;/p>
&lt;ul>
&lt;li>[서버 API] 주기적인 위치 정보 갱신
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>위도, 경도, 시각 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[클라이언트 API] 클라이언트가 갱신된 친구 위치를 수신하는 데 사용할 API
&lt;ul>
&lt;li>전송되는 데이터
&lt;ul>
&lt;li>친구 위치 데이터와 변경된 시각을 나타내는 타임스탬프&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[서버 API] 웹소켓 초기화 API
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>위도, 경도, 시각 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>자기 친구들의 위치 데이터&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[클라이언트 API] 새 친구 구독 API
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>친구 ID&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>가장 최근의 위도, 경도, 시각 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>[클라이언트 API] 구독 해지 API
&lt;ul>
&lt;li>요청
&lt;ul>
&lt;li>친구 ID&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>HTTP 요청&lt;/strong>&lt;/p>
&lt;p>API 서버는 친구를 추가/삭제하거나 사용자 정보를 갱신하는 드으이 작업을 처리할 수 있어야 한다.&lt;/p>
&lt;p>아주 흔한 종류의 API이므로 상세한 내용은 다루지 않는다.&lt;/p>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>살펴봐야하는 중요한 주제중 하나는 데이터 모델이다.&lt;/p>
&lt;p>위치 정보 캐시와 위치 이동 이력 데이터베이스만 살펴본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>위치 정보 캐시&lt;/strong>&lt;/p>
&lt;p>위치 정보 캐시는 &lt;strong>주변 친구&lt;/strong>기능을 켠 활성 상태 친구의 가장 최근 위치를 보관한다.&lt;/p>
&lt;p>설계안에서는 레디스를 사용해 이 키새를 구현하며, 해당 캐시에 보관될 키/값 쌍은 아래와 같다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>키&lt;/th>
&lt;th>값&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>사용자 ID&lt;/td>
&lt;td>{위도, 경도, 시각}&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;p>&lt;strong>위치 정보 저장에 데이터베이스를 사용하지 않는 이유는?&lt;/strong>&lt;/p>
&lt;p>주변 친구 기능은 사용자의 &lt;strong>현재 위치&lt;/strong>만 사용하므로, 사용자 위치는 하나만 보관하면 충분하다.&lt;/p>
&lt;ul>
&lt;li>읽기 및 쓰기 연산 속도가 매우 빠르다.&lt;/li>
&lt;li>TTL을 지원하여 활성 상태가 아닌 사용자 정보를 자동으로 제거할 수 있다.&lt;/li>
&lt;li>활용하는 위치 정보는 영속성을 보장할 필요가 없다.&lt;/li>
&lt;li>장애 발생시 새 서버로 바꾼 후 갱신된 위치 정보가 캐시에 채워지기만 하면 충분하다.
&lt;ul>
&lt;li>캐시가 데워질 동안은 갱신 주기가 한두 번 정도 경과하여 변경 내역을 놓칠 수도 있지만 수용 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>위치 이동 이력 데이터베이스&lt;/strong>&lt;/p>
&lt;p>위치 이동 이력 데이터베이스는 사용자의 위치 정보 변경 이력을 다음 스키마를 따르는 테이블에 저장한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>user_id&lt;/th>
&lt;th>latitude&lt;/th>
&lt;th>longitude&lt;/th>
&lt;th>timestamp&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>필요로 하는 것은 &lt;strong>막대한 쓰기 연산 부하를 감당&lt;/strong>할 수 있고, &lt;strong>수평적 규모 확장이 가능&lt;/strong>한 데이터베이스다.&lt;/p>
&lt;p>&lt;strong>카산드라&lt;/strong>(Cassandra)는 이러한 요구에 잘 부합한다.&lt;/p>
&lt;ul>
&lt;li>관계형 데이터 베이스도 사용할 수는 있으나 &lt;strong>이력 데이터의 양이 서버 한 대에 보관하기에는 너무 많을 수 있으므로 샤딩이 필요하다&lt;/strong>.
&lt;ul>
&lt;li>사용자 ID를 기준 삼는 샤딩 방안이 가장 기본&lt;/li>
&lt;li>부하를 모든 샤드에 고르게 분산시킬 수 있고, 데이터베이스 운영 관리도 간편하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>개략적 설계안은 대부분의 경우 통하지만, 주어진 문제의 규모를 감당하기는 어려울 것이다.&lt;/p>
&lt;p>이번 절에서는 규모를 늘려 나가면서 병목 및 해결책을 찾는데 집중한다.&lt;/p>
&lt;h3 id="중요-구성요소별-규모-확장성">중요 구성요소별 규모 확장성&lt;/h3>
&lt;h4 id="api-서버">API 서버&lt;/h4>
&lt;p>RESTful API 서버의 규모 확장 방법은 널리 알려져있다.&lt;/p>
&lt;p>본 설계안의 API 서버는 무상태로 이런 서버로 구성된 클러스터의 규모를 CPU 사용률이나 부하, I/O 상태에 따라 자동으로 늘리는 방법은 다양하다.&lt;/p>
&lt;h4 id="웹소켓-서버">&lt;strong>웹소켓 서버&lt;/strong>&lt;/h4>
&lt;p>웹소켓 클러스터도 사용률에 따라 규모를 자동으로 늘리는 것은 그다지 어렵지 않다.&lt;/p>
&lt;p>하지만 웹소켓 서버는 &lt;strong>유상태&lt;/strong> 서버라 기존 서버를 제거할 때는 주의가 필요하다.&lt;/p>
&lt;ul>
&lt;li>노드를 제거하기 전 기존 연결부터 종료될 수 있도록 해야한다.
&lt;ul>
&lt;li>로드 밸런서가 인식하는 노드 상태를 **연결 종료 중(draining)**으로 변경해둔다.&lt;/li>
&lt;li>해당 서버로는 새로운 웹소켓 연결이 만들어지지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모든 연결이 종료되면(충분한 시간이 흐른 후) 서버를 제거한다.&lt;/li>
&lt;/ul>
&lt;p>웹소켓 서버에 새로운 버전의 애플리케이션 소프트웨어를 설치할 때도 마찬가지로 유의해야한다.&lt;/p>
&lt;blockquote>
&lt;p>유상태 서버 클러스터의 규모를 자동으로 확장하려면 좋은 로드밸런서가 있어야한다.&lt;/p>
&lt;/blockquote>
&lt;p>대부분의 클라우드 로드밸런서는 이런 일을 잘 처리한다.&lt;/p>
&lt;h4 id="클라이언트-초기화">&lt;strong>클라이언트 초기화&lt;/strong>&lt;/h4>
&lt;p>모바일 클라이언트는 기동되면 웹소켓 클러스터 내의 서버 가운데 하나와 지속성 웹소켓 연결을 맺는다.&lt;/p>
&lt;ul>
&lt;li>연결이 오랜 시간 유지된다.&lt;/li>
&lt;li>현대적 프로그래밍 언어는 이런 연결 유지에 많은 메모리를 필요로 하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>웹소켓 연결이 초기화되면 클라이언트는 해당 모바일 단말의 위치, 즉 해당 단말을 이용중인 사용자의 위치 정보를 전송한다.&lt;/p>
&lt;p>그 정보를 받은 웹 소켓 연결 핸들러는 다음 작업을 수행한다.&lt;/p>
&lt;ol>
&lt;li>위치 정보 캐시에 보관된 해당 사용자의 위치를 갱신
&lt;ul>
&lt;li>해당 위치 정보는 뒤이은 계산 과정에 이용되므로, 연결 핸들러 내의 변수에 저장해둔다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자 데이터베이스를 뒤져 해당 사용자의 모든 친구 정보를 조회&lt;/li>
&lt;li>위치 정보 캐시에 일괄(batch) 요청을 보내 모든 친구의 위치를 한번에 조회
&lt;ul>
&lt;li>비활성화 친구의 위치는 캐시에 없을 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>친구 위치 각각에 대해, 해당 친구와 사용자 사이의 거리를 계산
&lt;ul>
&lt;li>검색 반경 이내면 해당 친구의 상세 정보, 위치, 마지막으로 확인된 사각을 웹소켓 연결을 통해 클라이언트에 반환&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 친구의 레디스 서버 펍/섭 채널을 구독
&lt;ul>
&lt;li>채널 생성 및 구독 비용이 저렴하므로 활성 상태에 관계없이 모든 친구 채널을 구독할 수 있음&lt;/li>
&lt;li>비활성화 친구의 채널을 유지하기 위해 메모리가 필요하지만 매우 적고, 활성 전까지 CPU나 I/O를 전혀 이용하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자의 현재 위치를 레디스 펍/섭 서버의 전용 채널을 통해 모든 친구에게 전송&lt;/li>
&lt;/ol>
&lt;h4 id="사용자-데이터베이스">&lt;strong>사용자 데이터베이스&lt;/strong>&lt;/h4>
&lt;p>사용자 데이터베이스에는 두 가지 종류의 데이터가 보관된다.&lt;/p>
&lt;ul>
&lt;li>사용자 ID, 사용자명, 프로파일 이미지의 URL 등 사용자 상세 정보(프로필 데이터)&lt;/li>
&lt;li>친구 관계 데이터&lt;/li>
&lt;/ul>
&lt;p>이번 장에서 다루는 설계안의 규모를 감안하면 한 대의 관계형 데이터베이스 서버로는 감당할 수 없으나, 사용자 ID를 기준으로 데이터를 샤딩하면 관계형 데이터베이스라 해도 수평적 규모 확장이 가능하다.&lt;/p>
&lt;p>설계하고 있는 규모의 시스템을 실제로 운영하려면 사용자 및 친구 데이터를 관리하는 팀이 따로 필요할 것이다.&lt;/p>
&lt;p>웹소켓 서버는 데이터베이스를 직접 질의하는 대신 API를 호출하여 사용자 및 친구 관계 데이터를 가져와야 한다.&lt;/p>
&lt;h4 id="위치-정보-캐시">&lt;strong>위치 정보 캐시&lt;/strong>&lt;/h4>
&lt;p>활성화 상태 사용자의 위치 정보를 캐시하기 위해 레디스를 활용한다.&lt;/p>
&lt;ul>
&lt;li>각 항목의 키에는 TTL을 설정한다.
&lt;ul>
&lt;li>사용자의 위치 정보가 갱신될 때마다 초기화된다.&lt;/li>
&lt;li>따라서 최대 메모리 사용량은 일정 한도 아래로 유지된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>하지만 천 만명의 활성 사용자가 대략 30초마다 변경된 위치 정보를 전송한다고 가정하면 레디스 서버가 감당해야 하는 갱신 연산의 수는 초당 334K에 달하게되는데, 최신 고사양 서버를 쓴다 해도 부담되는 수치이다.&lt;/p>
&lt;p>다행히도 각 사용자의 위치 정보는 서로 독립적인 데이터이므로 사용자 ID를 기준으로 여러 서버에 샤딩하면 부하 또한 고르게 분배할 수 있다.&lt;/p>
&lt;ul>
&lt;li>가용성을 높이려면 각 샤드에 보고나하는 위치 정보를 대기(standby) 노드에 복제해 두면 된다.&lt;/li>
&lt;/ul>
&lt;h4 id="레디스-펍섭-서버">&lt;strong>레디스 펍/섭 서버&lt;/strong>&lt;/h4>
&lt;p>본 설계안에서 펍/섭 서버를 모든 온라인 친구에게 보내는 위치 변경 내역 메시지의 라우팅(routing)계층으로 활용한다.&lt;/p>
&lt;p>레디스 펍/섭 서버를 사용하는 이유는 채널을 만들고 유지하는 비용이 매우 저렴하기 때문이다.&lt;/p>
&lt;ul>
&lt;li>새 채널은 구독하려는 채널이 없을 때 생성한다.&lt;/li>
&lt;li>구독자가 없는 채널로 전송되 메시지는 그대로 버려지는데, 서버에 가해지는 부하는 거의 없다.&lt;/li>
&lt;li>채널 하나를 유지하기 위해서는 구독자 관계를 추적하기 위한 해시 테이블과 연결 리스트가 필요한데 아주 소량의 메모리만 사용한다.&lt;/li>
&lt;li>오프라인 사용자라 어떤 변경도 없는 채널의 경우에는 생성된 이후에 CPU 자원은 전혀 사용하지 않는다.&lt;/li>
&lt;/ul>
&lt;p>본 설계안은 그 점을 활용하여 주변 친구 기능을 활용하는 모든 사용자에 채널 하나씩을 부여한다.&lt;/p>
&lt;ul>
&lt;li>해당 기능을 사용하는 사용자의 앱은 초기화 시에 모든 친구의 채널과 구독 관계를 설정한다.(친구가 비활성이라도)&lt;/li>
&lt;/ul>
&lt;p>활성화 상태로 바뀐 친구의 채널을 구독하거나 비활성 상태가 된 친구의 채널을 구독 중단하는 작업이 필요 없어지므로 설계가 간단해진다.&lt;/p>
&lt;p>더 많은 메모리를 사용하게 되지만, 메모리가 병목이 될 가능성은 매우 낮다. 아키텍처를 단순하게 만들 수 잇다면 더 많은 메모리를 투입할 가치는 충분하다.&lt;/p>
&lt;h4 id="얼마나-많은-레디스-펍섭-서버가-필요한가">&lt;strong>얼마나 많은 레디스 펍/섭 서버가 필요한가?&lt;/strong>&lt;/h4>
&lt;p>&lt;strong>메모리 사용량&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>주변 친구 찾기를 사용하는 모든 사용자에게 채널 하나씩 할당하면 채널 수는 &lt;strong>1억&lt;/strong>개&lt;/li>
&lt;li>구독자 한 명을 추적하기 위해 내부 해시 테이블과 연결 리스트에 20바이트 상당의 포인터들을 저장해야함
&lt;ul>
&lt;li>&lt;code>1억 * 20바이트 * 100명 친구 / 10^9 = 200GB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>100GB 메모리 서버 2대로 충분하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>CPU 사용량&lt;/strong>&lt;/p>
&lt;p>펍/섭 서버가 구독자에게 전송해야하는 위치 정보 업데이트 양은 초당 1400만 건에 달한다.&lt;/p>
&lt;p>최신 레디스 서버 한 대로 얼마나 많은 메시지를 전송할 수 있는지 정확히 알 수는 없지만, 서버 한 대로는 곤란할것이다.&lt;/p>
&lt;ul>
&lt;li>보수적으로 기가비트 네트워크 카드를 탑재한 현대적 아키텍처의 서버 한 대로 감당 가능한 구독자의 수는 100,000이라고 가정&lt;/li>
&lt;/ul>
&lt;p>이 추정치에 따르면 필요한 레디스 서버의 수는 &lt;code>1400만 / 100,000 = 140&lt;/code>이다.&lt;/p>
&lt;hr>
&lt;p>위 계산 결과를 통해 다음과 같은 결론을 내릴 수 있다.&lt;/p>
&lt;ul>
&lt;li>레디스 펍/섭 서버의 병목은 메모리가 아니라 CPU 사용량이다.&lt;/li>
&lt;li>문제의 규모를 감당하려면 분산 레디스 펍/섭 클러스터가 필요하다.&lt;/li>
&lt;/ul>
&lt;h4 id="분산-레디스-펍섭-서버-클러스터">분산 레디스 펍/섭 서버 클러스터&lt;/h4>
&lt;p>모든 채널을 서로 독립적이므로, 메시지를 발행할 사용자 ID를 기준으로 펍/섭 서버들을 샤딩한다.&lt;/p>
&lt;p>하지만 현실적으로는 수백 대의 펍/섭 서버가 관련된 문제이므로 동작 방식을 상세하게 집어볼 필요가 있다.&lt;/p>
&lt;ul>
&lt;li>서버에는 필연적으로 장애가 생기게 마련이므로, 매끄러운 운영을 위해 필요하다.&lt;/li>
&lt;/ul>
&lt;p>본 설계안에서는 &lt;strong>서비스 탐색&lt;/strong>(Service discovery) 컴포넌트를 도입하여 이 문제를 푼다.&lt;/p>
&lt;ul>
&lt;li>etcd&lt;/li>
&lt;li>주키퍼(ZooKeeper)&lt;/li>
&lt;/ul>
&lt;p>서비스 탐색 컴포넌트의 아래 기능을 활용한다.&lt;/p>
&lt;ul>
&lt;li>가용한 서버 목록을 유지하는 기능 및 해당 목록을 갱신하는 데 필요한 UI나 API
&lt;ul>
&lt;li>서비스 탐색 소프트웨어는 설정 데이터를 보관하기 위한 소규모의 키-값 저장소라고 보면 된다.&lt;/li>
&lt;li>키: &lt;code>/config/pub_sub_ring&lt;/code>&lt;/li>
&lt;li>값: &lt;code>[&amp;quot;p_1&amp;quot;, &amp;quot;p_2&amp;quot;, &amp;quot;p_3&amp;quot;, &amp;quot;p_4&amp;quot;]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클라이언트(웹소켓 서버)로 하여금 값에 명시된 레디스 펍/섭 서버에서 발생한 변경 내역을 구독할 수 있도록 하는 기능&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_7.png"
width="1096"
height="1254"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_7_hufa309bd8978651d9dab23e4c65bb98ec_107318_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_7_hufa309bd8978651d9dab23e4c65bb98ec_107318_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="87"
data-flex-basis="209px"
>&lt;/p>
&lt;p>키에 매달린 값에는 &lt;strong>활성 상태의 모든 레디스 펍/섭 서버&lt;/strong>로 구성된 &lt;strong>해시 링&lt;/strong>을 보관한다.&lt;/p>
&lt;p>레디스 펍/섭 서버는 메시지를 발행할 채널이나 구독할 채널을 정해야 할 때 이 해시링을 참조한다.&lt;/p>
&lt;hr>
&lt;p>웹소켓 서버가 특정 사용자 채널에 위치 정보 변경 내역을 발행하는 과정은 아래와 같다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/2/img_6.png"
width="1236"
height="1358"
srcset="https://codemario318.github.io/post/system-design-interview-2/2/img_6_hue0f6159084a4fbd8c7b86af586fea184_111737_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/2/img_6_hue0f6159084a4fbd8c7b86af586fea184_111737_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="91"
data-flex-basis="218px"
>&lt;/p>
&lt;ol>
&lt;li>해시 링을 참조하여 메시지를 발행할 레디스 펍/섭 서버를 선정한다.
&lt;ul>
&lt;li>정확한 정보는 서비스 탐색 컴포넌트에 보관되어 있으나 해시 링 사본을 웹소켓 서버에 캐시한다면 성능을 높힐 수 있다.&lt;/li>
&lt;li>그 경우 웹소켓 서버는 해시 링 원본에 구독 관례를 설정하여 사본을 원본과 동일하게 유지하도록 해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹소켓 서버는 해당 서버가 관리하는 사용자 채널에 위치 정보 변경 내역을 발행한다.&lt;/li>
&lt;/ol>
&lt;p>구독할 채널이 존재하는 레디스 펍/섭 서버를 찾는 과정도 이와 동일하다.&lt;/p>
&lt;h4 id="레디스-펍섭-서버-클러스터의-규모-확장-고려사항">레디스 펍/섭 서버 클러스터의 규모 확장 고려사항&lt;/h4>
&lt;p>무상태 서버라면 트래픽 피턴에 따라 크기를 늘리거나 줄이는 방법이 위험성이 낮고 비용을 절감하기도 좋아 널리 활용되지만, 레디스 펍/섭 서버 클러스터 특성으로 인해 고려하기 어렵다.&lt;/p>
&lt;p>펍/섭 채널에 전송되는 메시지는 메모리나 디스크에 지속적으로 보관되지않지만, 채널에 대한 상태 정보를 보관한다.(각 채널의 구독자 목록)&lt;/p>
&lt;p>따라서 특정한 채널을 담당하던 펍/섭 서버를 교체하거나 해시 링에서 제거하는 경우 기존 채널에 대한 구독 관계를 해지하고 새 서버에 마련된 대체 채널을 다시 구독하기 위해 &lt;strong>채널을 다른 서버로 이동&lt;/strong>시켜야 하고, &lt;strong>해당 채널의 모든 구독자에게 그 사실을 알려야한다&lt;/strong>.&lt;/p>
&lt;p>유상태 서버 클러스터의 규모를 늘리거나 줄이는 것은 운영 부담과 위험이 큰 작업이므로 주의 깊게 계획하고 진행해야한다.&lt;/p>
&lt;ul>
&lt;li>유상태 서버 클러스터는 혼잡 시간대 트래픽을 무리 없이 감당하고 불필요한 크기 변화를 피할 수 있도록 어느 정도 여유를 두고 오버 프로비저닝(over provisioning)하는 것이 일반적이다.&lt;/li>
&lt;/ul>
&lt;p>불가피하게 규모를 늘려야 할 때는 다음과 같은 문제가 발생할 수 있음에 유의하여야 한다.&lt;/p>
&lt;ul>
&lt;li>클러스터의 크기를 조정하면 많은 채널이 같은 해시 링 위의 다른 여러 서버로 이동한다.
&lt;ul>
&lt;li>서비스 탐색 컴포넌트가 모든 웹소켓 서버에 해시 링이 갱신되었음을 알리면 &lt;strong>엄청난 재구독&lt;/strong> 요청이 발생할 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>재구독 요청을 처리하다 보면 &lt;strong>클라이언트가 보내는 위치 정보 변경 메시지의 처리가 누락&lt;/strong>될 수 있다.
&lt;ul>
&lt;li>어느 정도는 허용할 수 있으나 빈도는 반드시 최소화해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서비스의 상태가 불안정해질 가능성이 있으므로 클러스터 크기 조정은 하루 중 시스템 부하가 가장 낮은 시간을 골라 시행한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>클러스터의 크기 조정 자체는 꽤 간단하다.&lt;/p>
&lt;ul>
&lt;li>새로운 링 크기를 계산한다.
&lt;ul>
&lt;li>크기가 늘어난다면 새 서버를 준비한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>해시 링의 키에 매달린 값을 새로운 내용으로 갱신한다.&lt;/li>
&lt;li>대시보드를 모니터링한다.
&lt;ul>
&lt;li>웹소켓 클러스터의 CPU 사용량이 어느 정도 튀는 것이 보여야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>p_5&lt;/code>, &lt;code>p_6&lt;/code> 두 노드가 추가된다면 해시 링은 다음과 같이 바뀐다.&lt;/p>
&lt;ul>
&lt;li>변경 전
&lt;ul>
&lt;li>&lt;code>[p_1, p_2, p_3, p_4]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>변경 후
&lt;ul>
&lt;li>&lt;code>[p_1, p_2, p_3, p_4, p_5, p_6]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="운영-고려사항">운영 고려사항&lt;/h4>
&lt;p>기존 레디스 펍/섭 서버를 새 서버로 교체할 때는 교체되는 서버의 채널만 처리하므로 운영 문제가 발생할 가능성은 클러스터 크기를 조정할 때보다 훨씬 낮다.&lt;/p>
&lt;p>펍/섭 서버에 장애가 발생하면 &lt;strong>모니터링 소프트웨어&lt;/strong>는 온콜(on-call) 엔지니어에게 경보를 발송하며, 온콜 담당자는 아래와 같은 처리를 수행한다.&lt;/p>
&lt;ol>
&lt;li>서비스 탐색 컴포넌트의 해시 링 키에 매달린 값을 갱신하여 장애가 발생한 노드를 대기 중인 노드와 교체&lt;/li>
&lt;li>교체 사실은 모든 웹소켓 서버에 통지되고, 각 웹소켓 서버는 실행 중인 연결 핸들러에게 새 펍/섭 서버의 채널을 다시 구독하라고 알림&lt;/li>
&lt;li>각 연결 핸들러는 구독 중인 채널의 목록을 유지하고 있으므로, 모든 채널을 해시 링과 대조하여 새 서버로 구독 관계를 다시 설정해야 하는지 검토&lt;/li>
&lt;/ol>
&lt;h3 id="친구-추가삭제">친구 추가/삭제&lt;/h3>
&lt;p>새 친구를 추가하면 해당 클라이언트에 연결된 웹소켓 서버의 연결 핸들러에 그 사실을 알려 새 친구의 펍/섭 채널을 구독할 수 있도록 해야한다.&lt;/p>
&lt;ul>
&lt;li>주변 친구 기능은 큰 앱의 일부로, 새 친구가 추가되면 호출될 콜백을 해당 앱에 등록해 둘 수 있다.&lt;/li>
&lt;li>콜백이 호출되면 웹소켓 서버로 새 친구의 펍/섭 채널을 구독하라는 메시지를 보낸다.&lt;/li>
&lt;li>이 메시지를 처리한 웹소켓 서버는 해당 친구가 활성화 상태인 경우 가장 최근 위치 및 시각 정보를 응답 메시지에 담아 보낸다.&lt;/li>
&lt;/ul>
&lt;p>마찬가지로 친구가 삭제되면 호출될 콜백도 앱에 등록해 둘 수 있다.&lt;/p>
&lt;ul>
&lt;li>콜백이 호출되면 해당 친구의 펍/섭 채널 구독을 취소하라는 메시지를 웹소켓 서버로 보낸다.&lt;/li>
&lt;/ul>
&lt;p>친구가 위치 정보 정보 전성을 허가/취소하는 경우의 처리에도 활용될 수 있다.&lt;/p>
&lt;h3 id="친구가-많은-사용자">친구가 많은 사용자&lt;/h3>
&lt;p>친구가 많은 사용자가 시스템 성능 문제를 야기할 가능성이 있는지 논의해볼 만한 주제이다.&lt;/p>
&lt;ul>
&lt;li>친구 수의 상한이 있다고 가정(페이스북은 5,000명)&lt;/li>
&lt;li>친구 관계는 양방향&lt;/li>
&lt;li>팔로워 모델 같은 단방향 관계는 배제&lt;/li>
&lt;/ul>
&lt;p>수천 명의 친구를 구독하는 데 필요한 펍/섭 구독 관계는 클러스터 내의 많은 웹소켓 서버에 분산되어 있을 것이다.&lt;/p>
&lt;ul>
&lt;li>따라서 친구들의 위치 변경에서 오는 부하는 각 웹소켓 서버가 나누어 처리하므로 핫스팟 문제는 발생하지 않을 것 이다.&lt;/li>
&lt;/ul>
&lt;p>다만 많은 친구를 둔 사용자의 채널이 존재하는 펍/섭 서버의 경우는 조금 더 많은 부하를 감당하게 될 수 있지만, 클러스터 안에 100대가 넘는 펍/섭 서버가 있고, 그런 헤비 유저들의 채널들이 모든 펍/섭 서버에 분산된다는 점을 감안하면, 특정 서버에 막대한 부담을 줄 일은 없을 것이다.&lt;/p>
&lt;h3 id="주변의-임의-사용자">주변의 임의 사용자&lt;/h3>
&lt;p>정보 공유에 동의한 주변 사용자를 무작위로 보여줄 수 있도록 한다면 어떻게 해야할까?&lt;/p>
&lt;p>기존 설계안을 크게 훼손하지 않으면서 해당 기능을 지원하는 한 가지 방법은 &lt;strong>지오해시에 따라 구축된 펍/섭 채널 풀&lt;/strong>을 두는 것 이다.&lt;/p>
&lt;ul>
&lt;li>지오 해시 격자로 나눈 다음 격자 마다 채널을 하나씩 만들어 둔다.&lt;/li>
&lt;/ul>
&lt;p>해당 격자 내의 모든 사용자는 해당 격자에 할당된 채널을 구독한다.&lt;/p>
&lt;ol>
&lt;li>사용자의 위치가 변경되면 웹소켓 연결 핸들러는 해당 사용자의 지오해시 ID를 계산한 후, 해당 지오해시 ID를 담당하는 채널에 새 위치를 전송한다.&lt;/li>
&lt;li>근방에 있는 사용자 가운데 해당 채널을 구독하고 있는 사용자는 사용자 2의 위치가 변겨오디었다는 메시지를 수신한다.&lt;/li>
&lt;/ol>
&lt;p>경계에 위치한 사용자를 잘 처리하기 위해 모든 클라이언트는 사용자가 위치한 지오해시 뿐 아니라 주변 지오해시 격자를 담당하는 채널도 구독한다.&lt;/p>
&lt;h3 id="레디스-펍섭-외의-대안">레디스 펍/섭 외의 대안&lt;/h3>
&lt;p>얼랭(Erlang)은 이문제에 특히 유용한 해결책이 될 수 있다.&lt;/p>
&lt;ul>
&lt;li>오히려 더 좋은 솔루션이 될 수 있다.&lt;/li>
&lt;li>얼랭은 사용자가 적어 좋은 개발자를 구하기 어렵다&lt;/li>
&lt;li>얼랭 전문가가 있다면 좋은 선택지가 될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>얼랭&lt;/strong>은 고도로 분산된 병렬 애플리케이션을 위해 고안된 프로그래밍 언어이자 런타임 환경이다.&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>개념적으로 보자면 어떤 사용자의 위치 정보 변경 내역을 그 친구에게 효율적으로 전달하는 시스템을 설계했다.&lt;/p>
&lt;p>설계안의 핵심 컴포넌트는 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>웹소켓
&lt;ul>
&lt;li>클라이언트와 서버 사이의 실시간 통신을 지원한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>레디스
&lt;ul>
&lt;li>위치 데이터의 빠른 읽기/쓰기를 지원한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>레디스 펍/섭
&lt;ul>
&lt;li>한 사용자의 위치 정보 변경 내역을 모든 온라인 친구에게 전달하는 라우팅 계층&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>소규모 트래픽에 적합한 개략적 설계안부터 시작하여, 규모가 커짐에 따라 발생 가능한 도전적 문제들을 살펴보았다.&lt;/p>
&lt;ul>
&lt;li>RESTful API 서버&lt;/li>
&lt;li>웹소켓 서버&lt;/li>
&lt;li>데이터 계층&lt;/li>
&lt;li>레디스 펍/섭 서버 클러스터&lt;/li>
&lt;li>레디스 펍/섭 서버의 대안&lt;/li>
&lt;/ul>
&lt;p>친구가 많은 사용자에게 발생할 수 있는 잠재적 성능 병목문제와, 주변의 임의 사용자를 보여주는 기능의 설계안도 살펴보았다.&lt;/p>
&lt;h2 id="요약">요약&lt;/h2>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
nearby(주변 친구) --> first((1단계))
nearby --> second((2단계))
nearby --> third((3단계))
first --> giyogu[기능적 요구사항]
giyogu --> display[주변 친구 목록 표시]
giyogu --> update[주변 친구 목록 갱신]
first --> biyogu[비 기능적 요구사항]
biyogu --> low_latenty[낮은 지연 시간]
first --> choo[추정]
choo --> mile[5마일 검색 반경]
choo --> interval[위치 갱신 주기: 30초]
choo --> updatedata[위치 정보 갱신 QPS: 334k/s]
second --> rufh[개략적 설계안]
rufh --> rest[RESTful API 서버]
rufh --> websocket[웹소켓 서버]
rufh --> redis[레디스 위치 정보 캐시]
rufh --> casandra[위치 이동 이력 데이터베이스]
rufh --> pubsub[레디스 펍/섭 서버]
second --> intervalpos[주기적 위치 갱신]
second --> api[API 설계]
second --> datamodel[데이터 모델]
datamodel --> position[위치 정보 캐시]
datamodel --> positionlog[위치 이동 이력 데이터베이스]
third --> components[각 컴포넌트의 규모 확장]
components --> apiComponent[API 서버]
components --> websocket_cluster[웹소켓 서버 클러스터]
components --> userDB[사용자 정보 데이터베이스]
components --> positionCache[위치 정보 캐시]
components --> pubsubCluster[레디스 펍/섭 서버 클러스터]
components --> erlang[레디스 펍/섭 외 대안]
third --> friendUD[친구 추가/삭제]
third --> manyFriend[친구가 많은 사용자]
third --> random[주변 임의 사용자]
&lt;/pre></description></item><item><title>챌린지 과정 4주차 회고</title><link>https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/</link><pubDate>Mon, 12 Aug 2024 10:44:49 +0900</pubDate><guid>https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/</guid><description>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/cover.png" alt="Featured image of post 챌린지 과정 4주차 회고" />&lt;p>부스트캠프 챌린지 과정이 4주차로 마무리되었습니다🥳&lt;/p>
&lt;p>주말을 이용하여 미뤄왔던 대청소와 약속들 덕분에 월요일이 되어서야 회고를 쓰게 되네요&lt;/p>
&lt;p>이번주는 미션들을 수행하지는 않겠지만, 그동안 바빠서 마무리하지 못했던 학습 정리로 바쁠 것 같습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img.png"
width="900"
height="752"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_huc5e3bd9d0538c93e5f494cd205f8c424_816479_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_huc5e3bd9d0538c93e5f494cd205f8c424_816479_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="아직 한발 남았다."
class="gallery-image"
data-flex-grow="119"
data-flex-basis="287px"
>&lt;/p>
&lt;p>이번 주는 저번주와 마찬가지로 &lt;strong>짝 활동&lt;/strong>을 기본으로 한 주가 구성되었습니다.&lt;/p>
&lt;p>&lt;strong>각자 개발&lt;/strong>후 &lt;strong>짝 개선&lt;/strong>하기, &lt;strong>짝 개발&lt;/strong>후 &lt;strong>각자 개선&lt;/strong>하기로 &lt;strong>데이터베이스&lt;/strong>와 &lt;strong>네트워크&lt;/strong>를 깊게 이해해야만 해결할 수 있는 미션들이 주어졌습니다.&lt;/p>
&lt;p>그리고 마지막 테스트를 위한 &lt;strong>히든 미션&lt;/strong>을 금요일에 수행하였습니다.&lt;/p>
&lt;p>개인적으로 데이터베이스 관련 미션은 많이 어려웠네요 🙃&lt;/p>
&lt;p>이번 회고에는 미션들에 대한 접근 방법에 더해 짝 활동이 어떻게, 무엇을 중심으로 진행되었는지 설명해보겠습니다.&lt;/p>
&lt;h2 id="day16--17-데이터베이스">Day16 ~ 17: 데이터베이스&lt;/h2>
&lt;p>데이터베이스 관련 미션은 &lt;strong>각자 구현&lt;/strong> 후 &lt;strong>짝 개선&lt;/strong>을 수행해야하는 미션이었습니다.&lt;/p>
&lt;p>파일 기반 데이터베이스를 직접 구현해야하는 미션이었는데, 위에서 말씀드렸던 것처럼 개인적으로 많이 어려웠습니다.&lt;/p>
&lt;h3 id="mysql">MySQL&lt;/h3>
&lt;p>이전 직장에서 풀스택 개발자로 업무를 수행해오며 오랜기간 유지되어온 PHP 백엔드 레거시를 운영하는 것이 주 업무였는데요&lt;/p>
&lt;p>그렇다보니 예전 방식으로 그대로 개발을 수행할 수 밖에 없었고, &lt;a class="link" href="https://www.php.net/manual/en/book.pdo.php" target="_blank" rel="noopener"
>PDO&lt;/a>(PHP Data Object)를 사용하고 있었기 때문에 직접 쿼리를 작성해야하는 것은 필수적이었습니다.&lt;/p>
&lt;p>예전 개발 환경과 싱글 스레드 기반으로 순차적인 처리에 중점을 두는 PHP의 특성으로 인해 지금처럼 ORM을 이용하여 작은 쿼리를 여러개 보내는 것 보다는, 굉장히 많은 테이블들을 조인하는 큰 쿼리 하나를 작성해야하는 일도 매우 빈번했습니다.&lt;/p>
&lt;p>그렇다보니 쿼리 튜닝은 저에게 필수적인 역량이었고, 학습에 꽤 많은 공을 들였었습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_5.png"
width="371"
height="136"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_5_hu6fb17a4b1ba75a00ca79acad9d84d206_8737_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_5_hu6fb17a4b1ba75a00ca79acad9d84d206_8737_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL"
class="gallery-image"
data-flex-grow="272"
data-flex-basis="654px"
>&lt;/p>
&lt;p>이러한 이유로 MySQL 내부 동작을 꽤 잘 알고 있다고 생각하여 이번 미션은 MySQL을 모방하는 방식으로 접근했었습니다.&lt;/p>
&lt;h3 id="스토리지-엔진">스토리지 엔진&lt;/h3>
&lt;p>기존 요구사항만을 만족하기 위해서는 단순하게 전체 읽기, 전체 쓰기 방식으로 접근해도 괜찮았지만, 이러한 경우 데이터가 많아지면 급격한 성능 저하가 발생하게됩니다.&lt;/p>
&lt;p>이러한 문제를 해결해보고 싶어 많은 고민을 했는데 이 부분이 정말 어려웠습니다🥲&lt;/p>
&lt;hr>
&lt;p>&lt;strong>InnoDB&lt;/strong>&lt;/p>
&lt;p>데이터베이스의 성능을 나쁘게 만드는 원인은 &lt;strong>디스크 I/O&lt;/strong>에서 발생하는 &lt;strong>병목 현상&lt;/strong>입니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_1.png"
width="904"
height="456"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_1_hu5128e5d7946208d35600b2a8a7d0222a_52925_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_1_hu5128e5d7946208d35600b2a8a7d0222a_52925_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL 구조"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="475px"
>&lt;/p>
&lt;p>MySQL은 크게 &lt;strong>MySQL 엔진&lt;/strong>, &lt;strong>스토리지 엔진&lt;/strong>으로 영역을 구분할 수 있는데, 디스크 I/O에 접근하는 역할은 &lt;strong>스토리지 엔진&lt;/strong>이 전담하여 수행하게 됩니다.&lt;/p>
&lt;p>여러 스토리지 엔진이 있지만 주로 사용되는 &lt;code>InnoDB&lt;/code> 스토리지 엔진은 &lt;strong>버퍼풀&lt;/strong>이라는 메모리 영역을 통해 사용하는 주요 데이터를 대부분 캐싱하여 디스크에 접근하는 것을 최소화합니다.&lt;/p>
&lt;p>또한 쓰기 작업을 버퍼링하여 하드웨어 자원의 여유가 있을 때 백그라운드에서 실행하는 방식들을 통해 데이터베이스의 성능을 크게 끌어올리고 있습니다.&lt;/p>
&lt;p>이를 반영하기 위해서 데이터를 저장하고 관리하는 기본 단위인 &lt;strong>페이지&lt;/strong>를 구현하야할 필요가 있었습니다만&amp;hellip;.&lt;/p>
&lt;p>페이지를 직접 구현하고 이를 이용해서 데이터 저장이나 캐싱등을 구현해야한다고 생각하니 현기증이 나는 것 같다라구요😅&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_2.png"
width="632"
height="523"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_2_huaf81590ee5a0b6795972f97e2fb827b9_593519_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_2_huaf81590ee5a0b6795972f97e2fb827b9_593519_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="290px"
>&lt;/p>
&lt;p>그래서 MySQL 인덱스의 기본 단위인 PK만을 이용해서 저장된 파일에서의 레코드 위치만을 가지게 구현하는 방식으로 접근했습니다.&lt;/p>
&lt;p>&lt;strong>B+ Tree&lt;/strong> 같은 자료 구조를 통해서 &lt;code>Index Range Scan&lt;/code> 같은 방식도 적용해보려고 했었는데, 마찬가지로 어려워서 &lt;code>PK&lt;/code> 단일 조건 처리에 관한 부분만 적용할 수 있었습니다.&lt;/p>
&lt;h3 id="짝-개선">짝 개선&lt;/h3>
&lt;p>짝 개선은 이전과 마찬가지로 새로운 기능을 추가하는 것 보다는 기존 코드를 개선하는 방향으로 지침이 주어졌습니다.&lt;/p>
&lt;p>저 같은 경우는 &lt;strong>HTTP 요청/응답 분리&lt;/strong>를, 짝은 &lt;strong>DBMS 아키텍처 반영&lt;/strong>을 통한 &lt;strong>코드 구조&lt;/strong>를 개선하는 것을 목표로 함께 개선을 진행하였습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>예외 처리&lt;/strong>&lt;/p>
&lt;p>저의 개선 목표였던 &lt;strong>HTTP 요청/응답 분리&lt;/strong> 부분 작업을 수행하면서 자연스럽게 &lt;strong>응답 코드&lt;/strong>에 관한 내용들이 개선되어야 했고, 응답을 만들기위해 &lt;strong>예외 처리&lt;/strong>를 추가하는 부분에서 짝과 의견을 나눌 수 있는 기회가 생겼습니다.&lt;/p>
&lt;p>저 같은 경우는 서비스 로직에서 에러 또는 예외를 발생시켜 해당 에러를 최상위 지점에서 한번에 핸들링하는 것을 선호하는데(&lt;a class="link" href="https://codemario318.github.io/post/clean-code/7/" >클린코드 - 에러 처리&lt;/a>) 어떠한 장점이 있는지에 대해서 물어봐 주셨습니다.&lt;/p>
&lt;p>코드를 보면서 확인해보면 아래와 같습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>개선 전&lt;/strong>&lt;/p>
&lt;p>이전 처리를 복기해보면 아래와 같은 방식으로 처리가 구현되어 있었습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">어떤_서비스_클래스&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">원하는_동작&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">값_검증&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">throw&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">status&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;value&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;입력 값을 확인해주세요.&amp;#39;&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">서비스로직을_사용하는_클래스&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">어떤_기능&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">결과&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">어떤_서비스_객체&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">원하는_동작&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">200&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;OK&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">body&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">결과&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">status&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">switch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">status&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="s1">&amp;#39;value&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">400&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">500&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이러한 방식에는 몇 가지 문제가 있습니다.&lt;/p>
&lt;ul>
&lt;li>예외를 발생 시킬 때 사용자가 직접 사유를 기억해서 매직넘버(상수가 아닌 직접 입력해야하는 값, 하드코딩)를 사용해야합니다.&lt;/li>
&lt;li>응답도 같은 문제를 가지고 있습니다.&lt;/li>
&lt;/ul>
&lt;p>이러한 방식은 개발자가 실수를 쉽게 할 수 있는 여지가 많아지게됩니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>개선 후&lt;/strong>&lt;/p>
&lt;p>이러한 부분을 아래와 같이 개선하게 되었습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">BadRequestException&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nb">Error&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">UnauthorizedException&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nb">Error&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">ForbiddenException&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nb">Error&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">NotFoundException&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nb">Error&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">NotAcceptableException&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nb">Error&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">HttpStatusCodes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">Object&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">freeze&lt;/span>&lt;span class="p">({&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">OK&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">200&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">BAD_REQUEST&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">400&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">UNAUTHORIZED&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">401&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">FORBIDDEN&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">403&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">NOT_FOUND&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">404&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">NOT_ACCEPTABLE&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">406&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">INTERNAL_SERVER_ERROR&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">500&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>각 예외 상황에 맞는 예외 클래스를 구현하였습니다.
&lt;ul>
&lt;li>Nest.js 표준 에러 참조&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Http 응답 코드에 대해 Enum을 선언하였습니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">어떤_서비스_클래스&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">원하는_동작&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">값_검증&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">BadRequestException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;입력 값을 확인해주세요.&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">서비스로직을_사용하는_최상위_클래스&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">어떤_기능&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">결과&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">어떤_서비스_객체&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">원하는_동작&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">HttpStatusCode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">OK&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">body&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">결과&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">message&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="nx">BadRequestException&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">HttpStatusCodes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">BAD_REQUEST&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="nx">NotFoundException&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">HttpStatusCodes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NOT_FOUND&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">HttpStatusCodes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">INTERNAL_SERVER_ERROR&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>발생한 예외 클래스를 확인하여 Enum으로 선언된 응답 코드를 상황에 맞게 반환할 수 있도록 변경&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이러한 형식으로 개선되어 아래와 같은 장점을 취할 수 있었습니다.&lt;/p>
&lt;ul>
&lt;li>예외 클래스를 직접 확인하므로 어떤 에러가 발생했는지 쉽게 파악할 수 있다.&lt;/li>
&lt;li>에외 코드가 어떤 의미인지 확실히 구분할 수 있다. 등&lt;/li>
&lt;/ul>
&lt;p>발생하는 예외가 HTTP 응답에 대해 직접적인 연관성이 있어 또 하나의 세부사항인 HTTP와 관계가 생겨버린다는 것이 아쉬운 점이지만 충분히 개선되었다고 생각합니다.&lt;/p>
&lt;p>제가 생각하는 장점을 코드를 함께 개선해가는 과정을 통해서 설명해 드렸고, 많은 도움이 되었다는 이야기를 들을 수 있었습니다😁&lt;/p>
&lt;h2 id="day18--19-네트워크">Day18 ~ 19: 네트워크&lt;/h2>
&lt;p>네트워크 관련 미션은 &lt;strong>페어 프로그래밍&lt;/strong>을 통해 함께 결과물을 만들고, 이후 &lt;strong>각자 개선&lt;/strong>을 수행하는 미션이었습니다.&lt;/p>
&lt;p>&lt;strong>웹 소켓&lt;/strong> 서버를 직접 구현하는 것이 전제되어있는 미션이었는데, &lt;strong>레이어드 아키텍처&lt;/strong>를 쉽게 적용할 수 있는 요구사항이어서 짝에게 설계를 적극적으로 제안하여 적용하게 되었습니다.&lt;/p>
&lt;p>이전과 달랐던 점은 짝이 이전부터 &lt;strong>TDD&lt;/strong>를 적용해오셨던 분이셔서, 자연스럽게 &lt;strong>TDD&lt;/strong>로 진행되었습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_3.png"
width="816"
height="454"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_3_hu05ec6f48f861dd6127467224c3c8452c_617786_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_3_hu05ec6f48f861dd6127467224c3c8452c_617786_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="179"
data-flex-basis="431px"
>&lt;/p>
&lt;p>기능 요구사항을 돌아가며 &lt;strong>드라이버&lt;/strong>, &lt;strong>네비게이터&lt;/strong> 역할을 수행하는 방식으로 진행되었는데, 원할하게 &lt;strong>TDD&lt;/strong>가 진행되어서 참 즐거운 경험이었습니다😁&lt;/p>
&lt;p>그리고 짝 캠퍼분이 이전부터 FE 개발을 해오셨던 경험이 있으셔서 JS에 매우 능숙하셨기 때문에 아주 원할하게 진행될 수 있었던 것 같네요&lt;/p>
&lt;p>&lt;strong>레이어드 아키텍처&lt;/strong> 기반의 설계와, &lt;strong>TDD&lt;/strong>가 합쳐지니 지금까지 결과물 중 가장 만족스러운 결과물을 만들 수 있었습니다. 👍&lt;/p>
&lt;p>&lt;del>그래도 새벽 3시가 넘어서야 마무리 할 수 있었어요🤣&lt;/del>&lt;/p>
&lt;h3 id="레이어드-아키텍처">레이어드 아키텍처&lt;/h3>
&lt;p>&lt;code>Socket&lt;/code>을 이용하여 &lt;strong>CLI 기반 클라이언트&lt;/strong>와 &lt;strong>서버&lt;/strong>를 구현해야했습니다.&lt;/p>
&lt;p>서버와 클라이언트의 연결을 만들고, 클라이언트의 요청마다 HTTP 응답을 처리하는 구조가 필요했기 때문에 짝에게 &lt;strong>레이어드 아키텍처&lt;/strong>를 적극적으로 제안하여 반영하였습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_4.png"
width="1127"
height="843"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_4_hu4e52c0ad343a0efa02fd57875f5ec4d4_47956_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_4_hu4e52c0ad343a0efa02fd57875f5ec4d4_47956_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="레이어드 아키텍처"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="320px"
>&lt;/p>
&lt;p>&lt;strong>HTTP 요청 수신 및 응답&lt;/strong>, &lt;strong>비즈니스 로직 처리&lt;/strong>, &lt;strong>데이터 조작&lt;/strong>을 각 레이어로 구현하여 분리하여, 좋은 코드 구조를 만들 수 있었습니다.&lt;/p>
&lt;p>짝과 함께 개발하는 과정에서 뿐만이 아니라, 다음 피어세션에서도 해당 설계를 보고 많은 영감을 얻으셨다는 반응이 많아서 뿌듯했네요 😎&lt;/p>
&lt;h3 id="의존성-주입">의존성 주입&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_6.png"
width="271"
height="186"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_6_hua164b4f218d2ddb10286229f1ed50614_9292_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_6_hua164b4f218d2ddb10286229f1ed50614_9292_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="의존성 주입"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="349px"
>&lt;/p>
&lt;p>레이어드 아키텍처를 구성하며 각 의존성이 있는 레이어를 &lt;strong>의존성 주입&lt;/strong>을 통해 &lt;strong>구성&lt;/strong>하였습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">Model&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">#&lt;/span>&lt;span class="nx">items&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">items&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">items&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">items&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">getItem&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">collection&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">find&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">condition&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">Service&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">#&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">model&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">model&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">businessLogic&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getItem&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">Handler&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">#&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">constructor&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">service&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">service&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">handler&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">HttpStatusCode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">OK&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">body&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">businessLogic&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">items&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">model&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Model&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">items&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">service&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Service&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">handler&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Handler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이러한 구조를 통해 결합을 낮추고 유연성을 높힐 수 있었으며, 구현 과정에서 훨씬 테스트가 용이하다는 장점을 취할 수 있었습니다.&lt;/p>
&lt;h3 id="단단한-테스트-코드">단단한 테스트 코드&lt;/h3>
&lt;p>&lt;strong>각자 개선하기&lt;/strong>에서 저는 테스트 코드 부분을 개선하였습니다.&lt;/p>
&lt;p>단단한 테스트 코드 즉 깨지지 않는 테스트 코드를 작성하기 위해서 개인적으로 테스트 원칙인 단일 책임 원칙, 독립적 테스트 부분을 개선했습니다.&lt;/p>
&lt;ul>
&lt;li>단일 책임 원칙
&lt;ul>
&lt;li>테스트 코드는 하나의 동작이나 기능만을 테스트 해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>독립적 테스트
&lt;ul>
&lt;li>테스트 간에 의존성이 있으면 한 테스트의 실패가 다른 테스트에도 영양을 줌&lt;/li>
&lt;li>테스트 간 상태 공유를 피하고, 각 테스트 케이스가 독립적으로 실행될 수 있도록 보장해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>단일 책임 원칙&lt;/strong>&lt;/p>
&lt;p>하나의 테스트 코드는 한 가지의 동작과 기능을 테스트해야 이후 변경이 적고 오래사용할 수 있는 테스트 코드를 만들 수 있습니다.&lt;/p>
&lt;p>기존 작성되어있던 테스트를 유사하게 다시 만들어봤습니다.&lt;/p>
&lt;p>어떠한 모델에서 id를 이용해 특정 무언가를 찾는 처리입니다. (어떤 내용인지 추론할 수 있으면 안되기 때문에 추상적으로 쓸 수 밖에 없는 점 양해 부탁드립니다.)&lt;/p>
&lt;hr>
&lt;p>&lt;strong>변경 전&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">makeIds&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nb">Array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">from&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">length&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">count&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">idx&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="sb">`&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">idx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">toString&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">padStart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;0&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">describe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;ID를 활용하여 무언가를 찾아 배정하고 반환하는 처리 테스트&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">each&lt;/span>&lt;span class="p">([&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">makeIds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">id1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">makeIds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">id2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">makeIds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">id3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">makeIds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">id4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">makeIds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">id5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">])(&lt;/span>&lt;span class="s2">&amp;#34;무언가를 찾아 배정하고, 배정된 무언가를 반환&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">prevIds&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">nextId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">expected&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">prevIds&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">forEach&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">assignById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">assignById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nextCampId&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">expected&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>많은 상황에 대해 정상적인 처리를 테스트하고 있습니다.&lt;/p>
&lt;p>많은 테스트케이스를 확인하고 있었기 때문에 예외가 발생해야하는 상황은 별도로 확인하고 있지 않았습니다.&lt;/p>
&lt;p>개인적인 의견으로는 알아보기 힘들다고 판단했습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>변경 후&lt;/strong>&lt;/p>
&lt;p>여러 상황을 나누어 테스트하도록 했으며, 테스트 케이스의 숫자도 줄였습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">describe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;ID를 활용하여 무언가를 찾아 배정하고 반환하는 처리 테스트&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;정상 처리 확인&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">assignedId&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">assignById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">assignedId&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toEqual&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;특정 조건이 넘으면 다른 값 반환 확인&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">clients&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">Array&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">MAX_ASSIGN_CLIENT&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="sb">`J&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">toString&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">padStart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;0&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="nx">clients&lt;/span>&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">assigned&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">assignById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">assignedId&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toEqual&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;먼저 만들어진 무언가에 빈 자리가 있다면 해당 무언가를 반환&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="nx">clients&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="p">[]});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="nx">clients&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="p">[]});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">assignedId&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">assignById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">assignedId&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toEqual&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>독립적 테스트&lt;/strong>&lt;/p>
&lt;p>일부 테스트가 스스로의 다른 기능을 호출하는 부분들이 있었습니다. 이는 기능의 변경에 취약한 테스트가 될 수 있다고 판단하여 수정하였습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>변경 전&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">describe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;count&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;횟수 반환&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">increaseCount&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>service.count&lt;/code> 메소드를 통해 현재 &lt;code>count&lt;/code>을 확인하기 위해 &lt;code>service.increaseCount&lt;/code>메소드를 통해 &lt;code>count&lt;/code>를 증가시키고 있습니다.&lt;/p>
&lt;p>이는 자기 자신의 메소드를 재 호출하는 구조로 인해 &lt;code>service.increaseCount&lt;/code>에 미쳐 검증하지 못한 케이스가 있거나, 요구사항 변경으로 인해 검증해야 할 내용이 바뀐다면, &lt;code>service.count&lt;/code>의 테스트 코드도 변경이 불가피한 상황입니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>변경 후&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">describe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;count&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;횟수 반환&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">clap&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>service&lt;/code>의 데이터 보관을 위해 주입받은 &lt;code>Map&lt;/code>에 직접 데이터를 저장, 조작하여 자기 자신의 메소드를 활용하는 테스트 처리의 의존성을 제거하였습니다.&lt;/p>
&lt;h2 id="day20-3차-문제해결력-테스트">Day20: 3차 문제해결력 테스트&lt;/h2>
&lt;p>기존 모집 정보에 3차 문제해결력 테스트가 8월 10일 토요일로 예정되어 있었는데, 마지막 날인 20일차 릴레이 프로젝트를 수행해야하는 시간에 테스트가 진행되었습니다.&lt;/p>
&lt;p>대략적으로 말씀드리면, 부캠에서 제공했던 모든 과정들이 단시간에 종합되어있는 테스트였습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_7.png"
width="491"
height="340"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_7_hu5fb8e3cf3fed11573f93053e9937564e_404795_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_7_hu5fb8e3cf3fed11573f93053e9937564e_404795_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="부캠 종합 선물세트"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="346px"
>&lt;/p>
&lt;p>부캠에 성실히 참여했다면 방식 자체는 생소하지는 않았겠지만, 역시나 시간은 많이 부족했네요🥲&lt;/p>
&lt;h2 id="마무리">마무리&lt;/h2>
&lt;p>마지막 주차에는 같이 학습을 진행한 캠퍼분들에게 영감을 줄 수 있었던것 같아 1주차 이후로 가장 뿌듯했던 한 주 였던 것 같습니다.&lt;/p>
&lt;p>마지막 주차여서 챌린지 과정 전체에대한 회고를 포함해야하나 고민했는데, 따로 작성하기로 결정하여 4주차 회고만 남기게 되었네요&lt;/p>
&lt;p>다음 글은 챌린지 과정 전체에 대한 회고를 올릴 예정이니 기대해주세요😁&lt;/p>
&lt;p>이번에는 3주차 그룹 회고에 남겼던 글로 마무리하겠습니다.&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다☺️ 모두 정말 고생 많으셨어요🔥🔥🔥&lt;/p>
&lt;blockquote>
&lt;p>소프트웨어 장인 책 부분에 성장을 위한 자세에 관해 읽었는데요, 이 부분에서 &amp;ldquo;훈련&amp;quot;을 어떻게 해야 좋은지에 대한 언급이 있습니다.&lt;/p>
&lt;p>훈련을 할 때는 시간이 아무리 많이 걸린다고 하더라도 본인이 할 수 있는 최선의 결과를 만들지 않는다면 성장에는 큰 의미가 없기 때문에 최선을 다하는 것이 중요하다고해요!&lt;/p>
&lt;p>우리 모두 지금까지 열심히 해오고있지만, 앞으로도 최선을 다해서 함께 성장했으면 좋겠어요&lt;/p>
&lt;p>한 주간 정말 고생 많으셨습니다! 맴버쉽에서 꼭 뵈어요 :D&lt;/p>
&lt;/blockquote></description></item><item><title>12. 채팅 시스템 설계</title><link>https://codemario318.github.io/post/system-design-interview/12/</link><pubDate>Fri, 05 Jul 2024 10:02:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/12/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/cover.png" alt="Featured image of post 12. 채팅 시스템 설계" />&lt;p>이번 장에서는 채팅 시스템을 설계해본다.&lt;/p>
&lt;p>채팅 앱은 중점적으로 다뤄야하는 문제에 따라 방향성이 달라질 수 있으므로, 요구사항을 확실히 파악하는것이 매우 중요하기 때문에, 어떤 채팅 앱을 설계하려는지 확실히 해 두는것이 중요하다.&lt;/p>
&lt;ul>
&lt;li>1:1 채팅 중점
&lt;ul>
&lt;li>페이스북 메신저, 위챗, 왓츠앱 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>그룹 채팅 중점
&lt;ul>
&lt;li>슬랙 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>대규모 그룹의 소통과 음성 채팅
&lt;ul>
&lt;li>디스코드 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>질문을 통해 의도를 파악한다.&lt;/p>
&lt;ul>
&lt;li>Q. 1:1 채팅, 그룹 채팅?
&lt;ul>
&lt;li>A. 둘 다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 모바일? 웹?
&lt;ul>
&lt;li>A. 둘 다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 트래픽 규모는?
&lt;ul>
&lt;li>A. DAU 5천만&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 그룹 채팅의 인원 제한?
&lt;ul>
&lt;li>A. 최대 100명&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 중요 기능으로는?
&lt;ul>
&lt;li>A. 1:1 채팅, 그룹 채팅, 사용자 접속 상태 표시, 텍스트 메시지만 허용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 메시지 길이 제한은?
&lt;ul>
&lt;li>A. 100,000자 이하&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 종단 간 암호화(end-to-end encryption) 지원?
&lt;ul>
&lt;li>A. 현재로서는 불필요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 채팅 이력은 얼마나 보관?
&lt;ul>
&lt;li>A. 영원히.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위와 같은 질의응답을 통해 아래와 같은 요구사항을 찾을 수 있다.&lt;/p>
&lt;ul>
&lt;li>응답지연이 낮은 일대일 채팅기능(DAU)&lt;/li>
&lt;li>최대 100명까지 참여할 수 있는 그룹 채팅 기능&lt;/li>
&lt;li>사용자의 접속상태 표시 기능&lt;/li>
&lt;li>다양한 단말 지원, 하나의 계정으로 여러 단말에 동시 접속 지원(웹, 앱 둘다 고려)&lt;/li>
&lt;li>푸시 알림&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>채팅 시스템의 경우 클라이언트는 모바일 앱이거나 웹 애필리케이션이다.&lt;/p>
&lt;p>클라이언트는 서로 직접 통신하지 않는 대신, 각 클라이언트는 위에 나열한 모든 기능을 지우너하는 채팅 서비스와 통신한다.&lt;/p>
&lt;p>따라서 채팅 서비스는 아래 기능을 제공해야 한다.&lt;/p>
&lt;ul>
&lt;li>클라이언트들로부터 메시지 수진&lt;/li>
&lt;li>메시지 수신자(recipient) 결정 및 전달&lt;/li>
&lt;li>수신자가 접속 상태가 아닌 경우 접속할 때까지 해당 메시지 보관&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img.png"
width="831"
height="141"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_hu846a4193e09f6599f67011f5f29692cb_42945_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_hu846a4193e09f6599f67011f5f29692cb_42945_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클라이언트와 채팅 서비스 관계"
class="gallery-image"
data-flex-grow="589"
data-flex-basis="1414px"
>&lt;/p>
&lt;p>채팅을 시작하려는 클라이언트는 네트워크 통신 프로토콜을 사용하여 서비스에 접속하므로, 어떤 통신 프로토콜을 사용할 것인가도 중요한 문제다.&lt;/p>
&lt;p>대부분의 클라이언트/서버 애플리케이션에서 요청을 보내는 것은 클라이언트이며, 채팅 시스템도 마찬가지다.&lt;/p>
&lt;p>위 예시에서는 송신 클라이언트가 수신 클라이언트에게 전달 할 메시지를 보낼 때, 오랜 세월 검증된 &lt;strong>HTTP 프로토콜&lt;/strong>을 사용한다.&lt;/p>
&lt;p>HTTP를 사용한다면, 채팅 서비스에서는 클라이언트가 지속적으로 메시지를 보낸다는 특성을 고려하여, &lt;code>keep-alive&lt;/code> 헤더를 사용해 서버와 클라이언트가 연결을 끊지 않고 유지하는 것이 좋다.&lt;/p>
&lt;p>하지만 메시지 발신에 비해 수신 시나리오는 이것보다 복잡하기 때문에 HTTP가 적절치 않을 수 있다.&lt;/p>
&lt;ul>
&lt;li>서버가 채팅 발신 요청을 받게 되면, 서버가 수신자에게 메시지를 전달해야한다.&lt;/li>
&lt;li>HTTP는 클라이언트가 연결을 만드는 특성으로, 서버에서 클라이언트로 임의 시점에 메시지를 보내는 데 쉽게 쓰일 수 없다.&lt;/li>
&lt;/ul>
&lt;p>이러한 문제를 개선하기위해 서버가 연결을 만드는 것처럼 동작하는 많은 기법이 제안되었다.&lt;/p>
&lt;ul>
&lt;li>폴링, 롱폴링, 웹소켓&lt;/li>
&lt;/ul>
&lt;h3 id="폴링">폴링&lt;/h3>
&lt;p>폴링은 클라이언트가 주기적으로 서버에게 새 메시지가 있는냐고 물어보는 방법이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_1.png"
width="831"
height="879"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_1_huaa79ccbd5858bc013d0c473ceded0490_112044_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_1_huaa79ccbd5858bc013d0c473ceded0490_112044_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="폴링"
class="gallery-image"
data-flex-grow="94"
data-flex-basis="226px"
>&lt;/p>
&lt;p>폴링 비용은 폴링을 자주하면 할수록 올라가므로, 답해줄 메시지가 없는 경우에는 서버 자원이 불필요하게 낭비된다.&lt;/p>
&lt;h3 id="롱-폴링">롱 폴링&lt;/h3>
&lt;p>폴링의 비효율성을 개선하기위해 롱 폴링이 제안되었다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_2.png"
width="831"
height="746"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_2_hu9446a286a0026c1d57706962c9f7b24e_79065_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_2_hu9446a286a0026c1d57706962c9f7b24e_79065_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="롱 폴링"
class="gallery-image"
data-flex-grow="111"
data-flex-basis="267px"
>&lt;/p>
&lt;ul>
&lt;li>클라이언트는 새 메시지가 반환되거나 타임아웃 될 때가지 연결을 유지한다.&lt;/li>
&lt;li>새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내 모든 절차를 다시 시작한다.&lt;/li>
&lt;/ul>
&lt;p>이 방법은 다음과 같은 약점이 있다.&lt;/p>
&lt;ul>
&lt;li>메시지를 보내는 클라이언트가 수신하는 클라이언트가 같은 채팅 서버에 접속하지 않을 수 있다.
&lt;ul>
&lt;li>HTTP 서버들은 보통 무상태이다. 즉 로드 밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우(요청을 무작위로 분산하는 경우), 메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와의 롱 폴링 연결을 가지고 있지 않은 서버일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서버는 클라이언트가 연결을 해제했는지 알 수 있는 좋은 방법이 없다.&lt;/li>
&lt;li>여전히 비효율적이다.
&lt;ul>
&lt;li>메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 때마다 주기적으로 서버에 다시 접속한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="웹소켓">웹소켓&lt;/h3>
&lt;p>웹소켓은 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_3.png"
width="821"
height="498"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_3_huebfcb5cdfaf26f40aef3085b89b61c7b_77060_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_3_huebfcb5cdfaf26f40aef3085b89b61c7b_77060_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="웹소켓"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="395px"
>&lt;/p>
&lt;ul>
&lt;li>웹소켓 연결은 클라이언트가 시작하며, 한번 맺어진 연결은 항구적이며(변하지않고 오래가며) 양방향이다.&lt;/li>
&lt;li>처음에는 HTTP 연결이지만 특정 핸드셰이크 절차를 거져 웹소켓 연결로 업그레이드된다.
&lt;ul>
&lt;li>일반적으로 방화벽이 있는 환경에서도 잘 동작한다.&lt;/li>
&lt;li>HTTP, HTTPS 가 쓰는 포트를 그대로 활용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>연결이 만들어지고 나면, 서버는 클라이언트에게 비동기적으로 메시지를 전송할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>웹소켓은 메시지를 보내려는 클라이언트에게 준수한 HTTP 프로토콜의 특징에 더해 양방향 메시지 전송까지 가능하게 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_4.png"
width="607"
height="355"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_4_huc6205357ded82087fb2f30ab5b292d46_55256_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_4_huc6205357ded82087fb2f30ab5b292d46_55256_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="웹소켓 활용 예시"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="410px"
>&lt;/p>
&lt;ul>
&lt;li>웹소켓을 이용하면 메시지를 보낼 때나 받을 때 동일한 프로토콜을 사용할 수 있으므로, 설계와 구현이 단순하고 직관적이다.&lt;/li>
&lt;li>단, 웹소켓 연결은 항구적으로 유지되어야 하기 때문에 서버 측에서 연결 관리를 효율적으로 해야한다.&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>클라이언트와 서버 사이의 주 통신 프로토콜로 웹소켓을 사용하지만, 다른 부분에서는 굳이 웹소켓을 쓸 필요는 없다.&lt;/p>
&lt;p>대부분의 기능인 회원가입, 로그인, 사용자 프로파일 등은 기존 HTTP상에서 구현하는 것이 더 좋다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_5.png"
width="644"
height="853"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_5_hu3b37951fbb1bf15ccce6fcd26ff957e5_234991_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_5_hu3b37951fbb1bf15ccce6fcd26ff957e5_234991_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="75"
data-flex-basis="181px"
>&lt;/p>
&lt;p>채팅 시스템은 세 부분으로 나눠볼 수 있다.&lt;/p>
&lt;h4 id="무상태-서비스">무상태 서비스&lt;/h4>
&lt;p>이 설계안에서 무상태 서비스는 로그인, 회원가입, 사용자 프로파일 표시 등을 처리하는 &lt;strong>전통적인 요청/응답&lt;/strong> 서비스다.&lt;/p>
&lt;ul>
&lt;li>일반적인 웹과 앱이 제공하는 기능들&lt;/li>
&lt;/ul>
&lt;p>무상태 서비스는 로드밸런서 뒤에 위치한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>서비스 탐색(sevice discovery) 서비스&lt;/strong>
&lt;ul>
&lt;li>클라이언트가 접속할 채팅 서버의 DNS 호스트명을 클라이언트에게 알려주는 역할을 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="상태-유지-서비스">상태 유지 서비스&lt;/h4>
&lt;p>채팅 서비스는 각 클라이언트는 채팅 서버와 독립적인 네트워크를 유지해야한다.&lt;/p>
&lt;ul>
&lt;li>클라이언트는 보통 다른 서버로 연결을 변경하지 않는다.&lt;/li>
&lt;li>서비스 탐색 서비스가 채팅 서버스와 긴밀히 협력하여 특정 서버에 부하가 몰리지 않도록 한다.&lt;/li>
&lt;/ul>
&lt;h4 id="써드파티-서비스-연동">써드파티 서비스 연동&lt;/h4>
&lt;p>채팅 앱에서 가장 중요한 써드파티 서비스는 푸시 알림이다.&lt;/p>
&lt;ul>
&lt;li>새 메시지 수신시 앱이 실행중이지 않더라도 알림을 받아야한다.&lt;/li>
&lt;/ul>
&lt;p>따라서 푸시 알림 서비스와의 통합은 아주 중요하다.&lt;/p>
&lt;h4 id="규모-확장성">규모 확장성&lt;/h4>
&lt;p>이번 장에서 다루는 시스템은 동시 접속자가 1M 이라고 가정하는데, 접속당 10K 서버 메모리가 필요하다면, 10GB 메모리만으로도 처리 가능하다.&lt;/p>
&lt;p>하지만 이정도 규모의 트래픽을 서버 한대로 처리하는 것은 &lt;strong>SPOF&lt;/strong> 등의 이유로 적절치 않다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_6.png"
width="797"
height="872"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_6_hu2f66c0a05c004fc0f4d257e106c12a84_230686_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_6_hu2f66c0a05c004fc0f4d257e106c12a84_230686_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안 최종"
class="gallery-image"
data-flex-grow="91"
data-flex-basis="219px"
>&lt;/p>
&lt;p>유의할 것은 실시간으로 메시지를 주고받기 위해 클라이언트는 채팅 서버와 웹소켓 연결을 끊지 않고 유지한다는 것이다.&lt;/p>
&lt;ul>
&lt;li>채팅 서버
&lt;ul>
&lt;li>클라이언트 사이에 메시지를 중계하는 역할 담당&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>접속 상태 서버(Presence server)
&lt;ul>
&lt;li>사용자의 접속 여부 관리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>API 서버
&lt;ul>
&lt;li>로그인, 회원가입, 프로파일 변경 등 그 외 나머지를 전부 처리(무상태)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알림 서버
&lt;ul>
&lt;li>푸시 알림을 보냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>키-값 저장소
&lt;ul>
&lt;li>채팅 이력을 보관&lt;/li>
&lt;li>시스템에 접속한 사용자는 이전 채팅 이력을 전부 보게된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="저장소">저장소&lt;/h4>
&lt;p>채팅 시스템의 기술 스택중 가장 중요한 부분 중 하나는 데이터 계층으로, 이 계층을 올바르게 만드는 데는 노력이 필요하다.&lt;/p>
&lt;p>중요한 선택 중 하나는 어떤 데이터베이스를 쓰는가(관계형, NoSQL 등)이며, 고려해야 할 핵심 요인은 &lt;strong>데이터의 유형&lt;/strong>과 &lt;strong>읽기/쓰기 연산의 패턴&lt;/strong> 이다.&lt;/p>
&lt;p>채팅 시스템에서는 보통 두 가지다.&lt;/p>
&lt;p>&lt;strong>사용자 프로파일, 설정, 친구 목록과 같은 일반적인 데이터&lt;/strong>&lt;br>
안정성을 보장하는 관계형 데이터베이스가 적절하다.&lt;/p>
&lt;ul>
&lt;li>다중화(replication)와 샤딩(sharding)으로 이러한 데이터의 가용성과 규모확장성을 보증할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>채팅 시스템에 고유한 데이터(채팅 이력)&lt;/strong>&lt;br>
이러한 유형의 데이터를 어떻게 보관할 지 결정하려면 읽기/쓰기 연산 패턴을 이해해야한다.&lt;/p>
&lt;ul>
&lt;li>채팅 이력 데이터 양은 엄청나다.
&lt;ul>
&lt;li>페이스북 메신저나 왓츠앱은 매일 600억개 메시지를 처리함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>빈번하게 사용되는 것은 주로 최근에 주고받은 메시지이다.
&lt;ul>
&lt;li>대부분 사용자는 오래된 메시지는 확인하지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>검색 기능, 언급(mention)된 메시지, 특정 메시지로 점프 하는 등 무작위적인 데이터 접근을 하는 경우도 있다.&lt;/li>
&lt;li>1:1 채팅 앱의 경우 읽기:쓰기 비율은 대략 1:1&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>키-값 저장소&lt;/strong>가 이러한 패턴을 지원할 수 있는 데이터베이스이다.&lt;/p>
&lt;ul>
&lt;li>수평적 규모 확장이 쉽다.&lt;/li>
&lt;li>데이터 접근 지연시간이 낮다.&lt;/li>
&lt;li>관계형 데이터베이스는 롱 테일에 해당하는(넓고 적게 분포하는) 데이터를 잘 처리하지 못하는 경향이 있다.
&lt;ul>
&lt;li>인덱스가 커지면 무작위 접근을 처리하는 비용이 늘어난다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이미 많은 안정적인 채팅 시스템이 키-값 저장소를 채택하고있다.
&lt;ul>
&lt;li>페이스북: Hbase, 디스코드: 카산드라 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>롱테일 효과란?&lt;br>
&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_7.png"
width="487"
height="360"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_7_hub3d79bb345ad1bef179816c28fd060f6_45686_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_7_hub3d79bb345ad1bef179816c28fd060f6_45686_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="롱테일 효과"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="324px"
>&lt;br>
파레토 법칙에 의한 80:20 집중 현상을 그래프에 나타냈을 때 꼬리처림 긴 부분을 형성하는 80%의 부분&lt;/p>
&lt;/blockquote>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;h4 id="11-채팅을-위한-메시지-테이블">1:1 채팅을 위한 메시지 테이블&lt;/h4>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
Message {
message_id bigint
message_from bigint
message_to bigint
content text
created_at timestamp
}
&lt;/pre>
&lt;p>&lt;code>Message&lt;/code> 테이블의 기본키는 &lt;code>message_id&lt;/code>로, 메시지 순서를 쉽게 정할 수 있도록 하는 역할도 담당한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>created_at&lt;/code>은 메시지가 동시에 만들어 질 수 있으므로 순서를 정할 수 없다.&lt;/li>
&lt;/ul>
&lt;h4 id="그룹-채팅을-위한-메시지-테이블">그룹 채팅을 위한 메시지 테이블&lt;/h4>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
GroupMessage {
channel_id bigint
message_id bigint
message_to bigint
content text
created_at timestamp
}
&lt;/pre>
&lt;p>&lt;code>(channel_id, message_id)&lt;/code> 복합키를 기본 키로 사용한다.&lt;/p>
&lt;ul>
&lt;li>채널은 채팅 그룹과 같은 뜻&lt;/li>
&lt;li>그룹 채팅에 적용될 모든 질의는 특정 채널을 대상으로 하기 때문에 &lt;code>channel_id&lt;/code>는 파티션 키로 사용할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="메시지-id">메시지 ID&lt;/h4>
&lt;p>위에서 언급한 것 처럼 메시지 ID는 메시지들의 순서도 표현할 수 있어야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>messege_id&lt;/code>는 고유해야한다.&lt;/li>
&lt;li>ID는 정렬 가능해하하며, 시간 순서와 일치해야한다.
&lt;ul>
&lt;li>새로운 ID는 이전 ID 보다 큰 값이어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>RDMBS라면 &lt;code>auto_increment&lt;/code>가 대안이 될 수 있지만 NoSQL은 보통 해당 기능을 제공하지 않는다.&lt;/p>
&lt;ul>
&lt;li>스노 플레이크 같은 전역적 순서 번호 생성기를 이용한다.&lt;/li>
&lt;li>지역적 순서 번호 생성기를 이용한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>지역적 순서 번호 생성기(Local sequence number generator)&lt;/strong>
유일성은 같은 그룹 안에서만 보증하면 충분하다는 의미이다.&lt;/p>
&lt;ul>
&lt;li>채팅 서비스의 특징에 따라 메시지의 순서는 같은 채널, 혹은 1:1 채팅 세션 안에서만 유지되면 충분하다.&lt;/li>
&lt;li>전역적 ID 생성기에 비해 구현이 쉽다.&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>채팅 시스템의 &lt;strong>서비스 탐색&lt;/strong>(service discovery), 메시지 전달 흐름, 사용자 접속 상태 표시하는 법 정도가 세부적으로 살펴보기 적절하다.&lt;/p>
&lt;h3 id="서비스-탐색">서비스 탐색&lt;/h3>
&lt;p>서비스 탐색 기능의 주된 역할은 &lt;strong>클라이언트에게 가장 적합한 채팅 서버를 추천&lt;/strong>하는 것으로 아래의 기준을 활용하여 추천하게된다.&lt;/p>
&lt;ul>
&lt;li>클라이언트의 위치(Geographical location)&lt;/li>
&lt;li>서버의 용량 등&lt;/li>
&lt;/ul>
&lt;p>서비스 탐색 기능을 구현하는 데 널리 쓰이는 오픈 소스 솔루션으로 &lt;strong>아파치 주키퍼&lt;/strong>같은 것이 있다.&lt;/p>
&lt;ul>
&lt;li>사용 가능한 모든 채팅 서버를 등록시켜 두고, 클라이언트가 접속을 시도하면 사전에 정한 기준에 따라 최적의 채팅 서버를 골라준다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_8.png"
width="718"
height="698"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_8_hu68029a52e7e091c75ea09add17c7232a_109024_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_8_hu68029a52e7e091c75ea09add17c7232a_109024_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="주키퍼로 구현한 서비스 탐색 흐름"
class="gallery-image"
data-flex-grow="102"
data-flex-basis="246px"
>&lt;/p>
&lt;ol>
&lt;li>사용자 A가 시스템에 로그인 시도&lt;/li>
&lt;li>로드밸런서가 로그인 요청을 API 서버들 가운데 하나로 보냄&lt;/li>
&lt;li>API 서버가 사용자 인증을 처리하고 나면 서비스 탐색 기능이 동작하여 최적의 채팅 서버를 찾음&lt;/li>
&lt;li>찾은 서버와 웹소켓 연결&lt;/li>
&lt;/ol>
&lt;h3 id="메시지-흐름">메시지 흐름&lt;/h3>
&lt;p>채팅 시스템에 있어서 종단 간 메시지 흐름을 이해하는 것은 흥미로운 주제이다.&lt;/p>
&lt;p>1:1 채팅 메시지의 처리 흐름과 여러 단말 간 메시지 동기화 과정을 살펴본 후, 그룹 채팅 메시지의 처리 흐름을 살펴본다.&lt;/p>
&lt;h4 id="11-채팅-메시지-처리-흐름">1:1 채팅 메시지 처리 흐름&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_9.png"
width="675"
height="721"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_9_hu69fa1b06e4a527bf42d264a7bc16f467_126368_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_9_hu69fa1b06e4a527bf42d264a7bc16f467_126368_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="1:1 채팅 메시지 처리 흐름"
class="gallery-image"
data-flex-grow="93"
data-flex-basis="224px"
>&lt;/p>
&lt;ol>
&lt;li>사용자 A가 채팅 서버 1로 메시지 전송&lt;/li>
&lt;li>채팅 서버 1은 ID 생성기를 사용해 해당 메시지의 ID 결정&lt;/li>
&lt;li>채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송&lt;/li>
&lt;li>메시지가 키-값 저장소에 보관됨&lt;/li>
&lt;li>
&lt;ol>
&lt;li>사용자 B가 접속 중인 경우 메시지는 접속 중인 채팅 서버로 전송&lt;/li>
&lt;li>사용자가 B가 접속 중이 아닌 경우 푸시 알림 메시지를 푸시 알림 서버로 보냄&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>채팅 서버는 웹소켓 연결을 통해 메시지를 사용자 B에게 전송.&lt;/li>
&lt;/ol>
&lt;h4 id="여러-단말-사이의-메시지-동기화">여러 단말 사이의 메시지 동기화&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_10.png"
width="827"
height="601"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_10_hu237dc5988b99c0258bbc96b3a092c068_95136_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_10_hu237dc5988b99c0258bbc96b3a092c068_95136_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="메시지 동기화"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="330px"
>&lt;/p>
&lt;p>각 단말은 관측된 가장 최신 메시지의 ID를 추적하기 위한 &lt;code>cur_max_message_id&lt;/code> 라는 변수를 유지한다.&lt;/p>
&lt;ul>
&lt;li>수신자 ID가 현재 로그인한 사용자 ID와 같다.&lt;/li>
&lt;li>키-값 저장소에 보관된 메시지로서, 그 ID가 &lt;code>cur_max_message_id&lt;/code>보다 크다.&lt;/li>
&lt;/ul>
&lt;p>위 조건을 만족하는 메시지는 새 메시지로 간주된다.&lt;/p>
&lt;p>&lt;code>cur_max_message_id&lt;/code>는 단말마다 별도로 유지 관리하면 되는 값이라 키-값 저장소에서 새 메시지를 가져오는 동기화 작업도 쉽게 구현할 수 있다.&lt;/p>
&lt;h4 id="소규모-그룹-채팅에서의-메시지-흐름">소규모 그룹 채팅에서의 메시지 흐름&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_11.png"
width="747"
height="649"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_11_hu3912c41ccdd5c95c734f65d055df6d26_117861_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_11_hu3912c41ccdd5c95c734f65d055df6d26_117861_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="소규모 그룹 채팅 메시지 흐름"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="276px"
>&lt;/p>
&lt;p>1:1 채팅에 비해 조금 더 복잡하다.&lt;/p>
&lt;p>사용자 A가 그룹 채팅방에서 메시지를 보내면, 사용자 B, C의 &lt;strong>메시지 동기화 큐&lt;/strong>에 복사된다.&lt;/p>
&lt;p>이러한 설계는 소규모 그룹 채팅에 적합하다.&lt;/p>
&lt;ul>
&lt;li>새로운 메시지가 왔는지 확인하려면 자기 큐만 보면 되므로 메시지 동기화 플로가 단순하다.&lt;/li>
&lt;li>그룹이 크지 않으면 메시지를 수신자별로 복사해서 큐에 넣는 작업 비용이 문제되지 않는다.&lt;/li>
&lt;/ul>
&lt;p>많은 사용자를 지원해야 하는 경우라면 똑같은 메시지를 모든 사용자의 큐에 복사하는 게 바람직하지 않다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_12.png"
width="716"
height="620"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_12_hub1a8d58b86737e6dabf10d70f993bb1d_101204_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_12_hub1a8d58b86737e6dabf10d70f993bb1d_101204_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="수신자 관점 메시지 흐름"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="277px"
>&lt;/p>
&lt;p>위와 같은 흐름을 &lt;strong>메시지 수신자&lt;/strong> 관점에서 살펴보면, 한 수신자는 여러 사용자로부터 오는 메시지를 수신할 수 있어야 한다.&lt;/p>
&lt;h3 id="접속-상태-표시">접속 상태 표시&lt;/h3>
&lt;p>사용자 접속 상태를 표시하는 것은 상당수 채팅 애플리케이션의 핵심 기능이다.&lt;/p>
&lt;p>개략적 설계안의 &lt;strong>접속 상태 서버&lt;/strong>(presense server)를 통해 사용자의 상태를 관리하는데, 접속상태 서버는 클라이언트와 웹소켓으로 통신하는 실시간 서비스의 일부라는 점에 유의해야한다.&lt;/p>
&lt;p>&lt;strong>사용자 로그인&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_13.png"
width="766"
height="206"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_13_hub37db33c8b8c4205291185c196c0ce06_57084_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_13_hub37db33c8b8c4205291185c196c0ce06_57084_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="로그인"
class="gallery-image"
data-flex-grow="371"
data-flex-basis="892px"
>&lt;/p>
&lt;p>클라이언트와 실시간 서비스 사이에 웹소켓 연결이 맺어지고 나면 접속상태 서버는 A의 상태와 &lt;code>last_active_at&lt;/code> 타임스탬프 값을 키-값 저장소에 보관한다.&lt;/p>
&lt;p>이 절차가 끝나면 해당 사용자는 접속 중인 것으로 표시될 것이다.&lt;/p>
&lt;p>&lt;strong>로그아웃&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_14.png"
width="830"
height="167"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_14_huc82ec414ab58d2aa81718a978ef2720f_65884_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_14_huc82ec414ab58d2aa81718a978ef2720f_65884_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="로그아웃"
class="gallery-image"
data-flex-grow="497"
data-flex-basis="1192px"
>&lt;/p>
&lt;p>키-값 저장소에 보관된 사용자 상태가 &lt;code>online&lt;/code>에서 &lt;code>offline&lt;/code>으로 바뀐다.&lt;/p>
&lt;p>&lt;strong>접속 장애&lt;/strong>&lt;/p>
&lt;p>인터넷 연결이 끊어지는 상황에 대응할 수 있는 설계를 준비해야한다.&lt;/p>
&lt;p>사용자의 인터넷 연결이 끊어지면 클라이언트와 서버 사이에 맺어진 웹소켓 같은 지속성 연결도 끊어진다.&lt;/p>
&lt;p>이러한 경우 &lt;strong>사용자를 오프라인 상태로 표시하고 연결이 복구되면 온라인 상태로 변경&lt;/strong>하는 방법을 고려할 수 있지만, 짧은 시간 동안 인터넷 연결이 끊어졌다 복귀되는 현상이 흔하기 때문에 적절하지 않다.&lt;/p>
&lt;ul>
&lt;li>이런 현상마다 사용자의 접속 상태를 변경하는 것은 지나치며, 사용자 경험 측면에서도 바람직하지 않다.&lt;/li>
&lt;/ul>
&lt;p>이에 따라 &lt;strong>박동(heartbeat) 검사&lt;/strong>를 통해 이 문제를 해결한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_15.png"
width="753"
height="620"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_15_hu870405f6db98088b77813163c0a21c89_78387_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_15_hu870405f6db98088b77813163c0a21c89_78387_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="박동 검사"
class="gallery-image"
data-flex-grow="121"
data-flex-basis="291px"
>&lt;/p>
&lt;ol>
&lt;li>온라인 상태의 클라이언트로 하여금 주기적으로 박동 이벤트를 접속상태 서버로 보낸다.&lt;/li>
&lt;li>마지막 이벤트를 받은 지 x초 이내에 또 다른 박동 이벤트 메시지를 받으면 해당 사용자의 접속 상태를 계속 온라인으로 유지한다.&lt;/li>
&lt;/ol>
&lt;h3 id="상태-정보의-전송">상태 정보의 전송&lt;/h3>
&lt;p>상태정보 서버는 각각의 친구관게마다 채널을 하나씩 두는 발행-구독 모델을 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/12/img_16.png"
width="844"
height="399"
srcset="https://codemario318.github.io/post/system-design-interview/12/img_16_huda3d97a35351d5c19e5533f1c287c481_139268_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/12/img_16_huda3d97a35351d5c19e5533f1c287c481_139268_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="상태 정보 전송"
class="gallery-image"
data-flex-grow="211"
data-flex-basis="507px"
>&lt;/p>
&lt;p>이러한 구조를 통해 친구 관계에 있는 사용자가 상태정보 변화를 쉽게 통지 받을 수 있게 된다(웹소켓 사용).&lt;/p>
&lt;p>이러한 방안은 그룹의 크기가 커지면 비용이나 시간이 많이 들게되므로 좋지 않다.&lt;/p>
&lt;ul>
&lt;li>그룹 하나의 100,000명이 있다면, 상태변화 1건당 100,000개의 이벤트 메시지가 발생한다.&lt;/li>
&lt;/ul>
&lt;p>이런 성능 문제를 해소하는 방법은&lt;/p>
&lt;ul>
&lt;li>사용자가 그룹 채팅에 입장하는 순간에만 상태 정보를 읽어가게 만든다.&lt;/li>
&lt;li>친구 리스트에 있는 사용자의 접속상태를 갱신하고 싶으면 수동으로 하도록 유도한다.&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>1:1 채팅과 그룹 채팅을 전부 지원하는 채팅 시스템의 아키텍처를 살펴보았다.&lt;/p>
&lt;ul>
&lt;li>클라이언트와 서버 사이의 통신을 가능하도록 하기 위해 웹소켓을 사용했다.&lt;/li>
&lt;li>주요 컴포넌트
&lt;ul>
&lt;li>실시간 메시징을 지원하는 채팅 서버&lt;/li>
&lt;li>접속 상태 서버&lt;/li>
&lt;li>푸시 알림 서버&lt;/li>
&lt;li>채팅 이력을 보관할 키-값 저장소&lt;/li>
&lt;li>이를 제외한 나머지 기을을 구현하는 데 쓰을 API 서버 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>시간이 남는다면 다음과 같은 내용을 논의해도 좋다.&lt;/p>
&lt;ul>
&lt;li>사진이나 비디오 등의 미디어를 지원하도록 하는 방법
&lt;ul>
&lt;li>압축 방식, 클라우드 저장소, 섬네일 생성 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>종단 간 암호화&lt;/li>
&lt;li>캐시
&lt;ul>
&lt;li>이미 읽은 메시지를 캐시해 두면 서버와 주고받는 데이터 양을 줄일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>로딩 속도 개선
&lt;ul>
&lt;li>슬랙은 사용자의 데이터, 채널 등을 지역적으로 분산하는 네트워크를 구축하여 앱 로딩 속도를 개선하였다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오류 처리
&lt;ul>
&lt;li>채팅 서버 오류
&lt;ul>
&lt;li>서버 하나가 죽으면 서비스 탐색 기능이 동작하여 클라이언트에게 새로운 서버를 배정하고 다시 접속할 수 있도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 재전송
&lt;ul>
&lt;li>재시도나 큐는 메시지의 안정적 전송을 보장하기 위해 흔히 사용되는 기법이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item></channel></rss>