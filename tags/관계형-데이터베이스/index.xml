<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>관계형 데이터베이스 on Mario Blog</title><link>https://codemario318.github.io/tags/%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/</link><description>Recent content in 관계형 데이터베이스 on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Tue, 22 Apr 2025 13:58:49 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/index.xml" rel="self" type="application/rss+xml"/><item><title>B-Tree와 LSM Tree</title><link>https://codemario318.github.io/post/db/rdbms-nosql/</link><pubDate>Tue, 22 Apr 2025 13:58:49 +0900</pubDate><guid>https://codemario318.github.io/post/db/rdbms-nosql/</guid><description>&lt;img src="https://codemario318.github.io/post/db/rdbms-nosql/cover.png" alt="Featured image of post B-Tree와 LSM Tree" />&lt;p>최근 &amp;ldquo;&lt;strong>데이터 중심 애플리케이션 개발&lt;/strong>&amp;ldquo;을 읽으면서 RDBMS와 NoSQL의 쓰기 작업의 차이를 설명하는 내용을 접하게 되었습니다. 이 내용을 기반으로 두 가지 데이터베이스를 비교해보려고 합니다.&lt;/p>
&lt;h2 id="b-tree와-lsm-tree의-기본-구조">B-Tree와 LSM Tree의 기본 구조&lt;/h2>
&lt;p>MySQL InnoDB와 같은 RDBMS는 B-Tree 기반의 저장소 엔진을 사용하는 반면, MongoDB와 같은 NoSQL 데이터베이스는 주로 로그 기반(LSM Tree) 구조를 활용합니다. 이 두 방식은 근본적인 설계 철학부터 성능 특성까지 다양한 차이점을 가지고 있습니다.&lt;/p>
&lt;h3 id="b-tree-구조">B-Tree 구조&lt;/h3>
&lt;p>B-Tree는 RDBMS에서 널리 사용되는 색인 구조입니다. B-Tree는 데이터를 균형 잡힌 트리 형태로 구성하며, 고정 크기의 페이지 단위로 디스크에 저장합니다. 트리의 각 노드(페이지)는 키와 그에 해당하는 하위 페이지 참조를 포함하고 있습니다. 일반적으로 데이터를 삽입, 삭제, 수정할 때는 해당 페이지의 내용을 &lt;strong>직접 덮어쓰는 방식&lt;/strong>을 사용합니다.&lt;/p>
&lt;p>이러한 &lt;strong>균형 트리 구조&lt;/strong>를 통해 어떤 &lt;strong>키&lt;/strong>에 대해서도 &lt;code>O(log n)&lt;/code> 시간 복잡도로 검색이 가능하며, 대부분의 데이터베이스에서 B-Tree의 깊이는 3-4 수준에 불과해 매우 빠른 접근 시간을 제공합니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> [루트 페이지]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> / | \
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">[페이지1] [페이지2] [페이지3]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> / \ / \ / \
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">... ... ... ... ... ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="lsm-tree-구조">LSM Tree 구조&lt;/h3>
&lt;p>LSM Tree(로그 구조화 병합 트리)는 로그 기반의 저장 구조를 사용합니다.&lt;/p>
&lt;p>데이터를 수정할 때마다 디스크에 &lt;strong>순차적으로 추가&lt;/strong>하는 방식을 사용하기 때문에, 기존 데이터를 덮어쓰지 않습니다. 새로운 데이터는 먼저 메모리 내의 멤테이블(MemTable)에 버퍼링되고, 멤테이블이 일정 크기에 도달하면 디스크의 SS테이블(Sorted String Table)로 기록됩니다.&lt;/p>
&lt;p>시간이 지남에 따라 여러 SS테이블이 생성되며, 백그라운드에서 주기적으로 이들을 &lt;strong>병합&lt;/strong>하고 &lt;strong>압축&lt;/strong>하는 &lt;strong>컴팩션&lt;/strong> 프로세스가 실행됩니다. 이러한 순차적 쓰기 방식은 B-Tree에서 정해진 위치의 데이터를 덮어쓰는 방법과 달리 파일에 맨 뒤에 추가만 하는 방식이므로 별도의 특정 위치에 대한 확인 같은 부수적인 처리가 없고 디스크의 물리적 특성에 최적화되어 있으므로 일반적으로 쓰기 작업에서 뛰어난 성능을 보입니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[MemTable(메모리)] → [SS테이블1(디스크)] → [SS테이블2(디스크)] → ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ↓ ↓
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [컴팩션 프로세스] [컴팩션 프로세스]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ↓ ↓
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [병합된 SS테이블] [병합된 SS테이블]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="읽기쓰기-성능-특성-비교">읽기/쓰기 성능 특성 비교&lt;/h2>
&lt;p>B-Tree 계열과 LSM Tree 동작 방식의 차이로 인해 읽기/쓰기 작업에도 다른 양상을 보여줍니다.&lt;/p>
&lt;h3 id="읽기-성능">읽기 성능&lt;/h3>
&lt;p>&lt;strong>B-Tree 의 읽기 성능&lt;/strong>&lt;/p>
&lt;p>B-Tree 구조에서는 인덱스를 통해 데이터에 직접 접근할 수 있습니다.&lt;/p>
&lt;p>균형 잡힌 트리 구조를 통해 어떤 키에 대해서도 &lt;code>O(log n)&lt;/code> 시간 내에 검색이 가능하며, 대부분의 경우 단 몇 번의 디스크 I/O만으로 원하는 레코드에 도달할 수 있습니다. 특히 기본 키를 이용한 검색은 매우 효율적이며, 색인된 열을 기준으로 한 범위 쿼리(B+ Tree)도 높은 성능을 보입니다.&lt;/p>
&lt;p>또한 B-Tree는 데이터가 정렬된 상태로 유지되므로 정렬된 결과가 필요한 쿼리에서도 유리합니다. 인덱스가 메모리에 캐시되어 있다면 더욱 빠른 접근이 가능합니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>LSM Tree의 읽기 성능&lt;/strong>&lt;/p>
&lt;p>LSM Tree 구조에서는 특정 키를 검색할 때 여러 SS테이블을 차례로 확인해야 할 수 있습니다.&lt;/p>
&lt;p>키를 찾기 위해 먼저 메모리의 멤테이블을 확인하고, 없다면 가장 최근에 생성된 SS테이블부터 차례대로 확인합니다. 이 과정에서 여러 번의 디스크 접근이 필요할 수 있어 B-Tree보다 읽기 성능이 떨어질 수 있습니다.&lt;/p>
&lt;p>그러나 &lt;strong>블룸 필터&lt;/strong>와 같은 최적화 기법을 사용하여 특정 키가 존재하지 않는 SS테이블을 효율적으로 건너뛸 수 있습니다. 또한 컴팩션 작업이 진행 중일 때는 읽기 성능이 일시적으로 저하될 수 있습니다.&lt;/p>
&lt;p>한편, 순차적 읽기나 스캔 작업에서는 데이터의 연속적 배치로 인해 우수한 성능을 보일 수 있습니다.&lt;/p>
&lt;h3 id="쓰기-성능">쓰기 성능&lt;/h3>
&lt;p>&lt;strong>B-Tree의 쓰기 성능&lt;/strong>&lt;/p>
&lt;p>B-Tree 구조에서는 데이터를 수정할 때 해당 페이지를 직접 덮어써야 합니다. 이는 &lt;strong>무작위 I/O&lt;/strong> 패턴을 유발하여 특히 하드 디스크 드라이브(HDD)에서 성능 저하의 원인이 됩니다. 또한 B-Tree의 균형을 유지하기 위해 데이터 삽입 시 &lt;strong>페이지 분할&lt;/strong>이 발생할 수 있으며, 이는 &lt;strong>추가적인 디스크 I/O&lt;/strong>를 필요로 합니다.&lt;/p>
&lt;p>또한 인덱스가 여러 개 있는 경우, 데이터 수정 시 &lt;strong>모든 관련 인덱스를 업데이트&lt;/strong>해야 하므로 쓰기 오버헤드가 증가합니다.&lt;/p>
&lt;p>데이터 변경의 안전한 복구를 위해 WAL(Write-Ahead Log)을 유지해야 하므로, 하나의 트랜잭션에 대해 여러 번의 디스크 쓰기가 필요할 수 있습니다. 이러한 특성으로 인해 B-Tree는 쓰기 작업이 많은 워크로드에서는 성능 병목이 될 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>LSM Tree의 쓰기 성능&lt;/strong>&lt;/p>
&lt;p>LSM Tree 구조는 쓰기 작업에 최적화되어 있습니다.&lt;/p>
&lt;p>데이터 변경 시 디스크에 &lt;strong>순차적으로 추가&lt;/strong>하므로, 특히 HDD에서 효율적입니다. 새로운 데이터는 먼저 메모리의 멤테이블에 버퍼링되므로 디스크 I/O 횟수를 크게 줄일 수 있습니다. 대량의 데이터를 삽입할 때도 멤테이블이 가득 차기 전까지는 디스크에 기록할 필요가 없어 빠른 속도로 처리됩니다.&lt;/p>
&lt;p>기존 데이터를 덮어쓰지 않고 새 버전을 추가하는 방식이므로 페이지 분할과 같은 구조 재조정이 필요 없습니다. 물론 컴팩션 과정이 필요하지만, 이는 백그라운드에서 처리되므로 전면적인 쓰기 성능에는 영향이 적습니다.&lt;/p>
&lt;p>이러한 특성으로 인해 LSM Tree는 특히 쓰기가 많은 워크로드에서 우수한 성능을 보입니다.&lt;/p>
&lt;h2 id="innodb의-쓰기-성능-최적화-전략">InnoDB의 쓰기 성능 최적화 전략&lt;/h2>
&lt;p>RDBMS의 대표적인 예시로 MySQL의 InnoDB 스토리지 엔진이 있는데요, InnoDB에서 쓰기 작업 성능을 개선하기 위해 여러 방법들을 활용하고 있습니다. 대략적으로 살펴볼까요?&lt;/p>
&lt;h3 id="버퍼풀을-통한-쓰기-성능-개선">버퍼풀을 통한 쓰기 성능 개선&lt;/h3>
&lt;p>InnoDB의 버퍼풀을 통해 쓰기 성능에 도움을 줄 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>쓰기 버퍼링과 지연된 일괄 처리&lt;/strong>&lt;/p>
&lt;p>InnoDB는 데이터 변경 작업이 발생하면 즉시 디스크에 기록하지 않고 버퍼풀에 더티 페이지(Dirty Page)로 유지합니다. 이 방식은 다음과 같은 이점을 제공합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>랜덤 I/O 최소화&lt;/strong>:
&lt;ul>
&lt;li>&lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 쿼리는 데이터 파일의 흩어진 레코드를 변경하는 랜덤한 디스크 작업을 발생시키지만, 버퍼풀을 통해 이러한 변경을 일정 시간 동안 모아서 효율적으로 처리합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>쓰기 병합&lt;/strong>:
&lt;ul>
&lt;li>같은 페이지에 대한 여러 변경 사항이 버퍼풀 내에서 병합되어 디스크 I/O 횟수를 크게 줄입니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>순차적 I/O 전환&lt;/strong>:
&lt;ul>
&lt;li>여러 랜덤 쓰기 작업을 모아 더 효율적인 순차적 I/O 패턴으로 변환합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>변경 버퍼(Change Buffer)&lt;/strong>&lt;/p>
&lt;p>보조 인덱스 변경에 특화된 최적화 기법으로, LSM Tree의 쓰기 지연 원리와 유사한 방식을 도입했습니다.&lt;/p>
&lt;ul>
&lt;li>보조 인덱스 변경 사항을 즉시 디스크에 반영하지 않고 메모리에 버퍼링합니다.&lt;/li>
&lt;li>시스템 리소스가 여유 있을 때나 해당 페이지가 다른 이유로 메모리에 로드될 때 변경 사항을 적용합니다.&lt;/li>
&lt;li>보조 인덱스가 많은 테이블에서 특히 큰 성능 향상을 제공합니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>리두 로그(Redo Log)와 버퍼풀의 협업&lt;/strong>&lt;/p>
&lt;p>리두 로그와 버퍼풀의 효율적인 상호작용은 데이터 안전성을 보장하면서도 쓰기 성능에 도움을 줄 수 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>선로깅(Write-Ahead Logging)&lt;/strong>:
&lt;ul>
&lt;li>데이터 변경이 발생하면 먼저 순차적인 리두 로그에 기록하고, 실제 데이터 페이지는 버퍼풀에 더티 페이지로 유지합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>그룹 커밋(Group Commit)&lt;/strong>:
&lt;ul>
&lt;li>여러 트랜잭션의 커밋을 함께 묶어 처리하여 I/O 오버헤드를 줄입니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>체크포인트 최적화&lt;/strong>:
&lt;ul>
&lt;li>리두 로그와 버퍼풀의 크기를 적절히 조정하여 체크포인트 빈도를 최적화함으로써 디스크 I/O 폭발 현상을 방지합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>더티 페이지 관리 및 플러시 최적화&lt;/strong>&lt;/p>
&lt;p>InnoDB는 더티 페이지의 디스크 기록을 효율적으로 관리하기 위한 다양한 메커니즘을 제공합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>플러시 리스트(Flush List)&lt;/strong>:
&lt;ul>
&lt;li>변경 시점을 기준으로 더티 페이지를 관리하며, 오래된 변경 사항부터 순차적으로 디스크에 기록합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>어댑티브 플러시(Adaptive Flushing)&lt;/strong>:
&lt;ul>
&lt;li>리두 로그의 증가 속도를 분석하여 최적의 시점에 적절한 양의 더티 페이지를 디스크에 기록합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>버퍼풀 인스턴스 분할&lt;/strong>:
&lt;ul>
&lt;li>여러 개의 버퍼풀 인스턴스로 나누어 내부 잠금 경합을 줄이고 병렬 처리 효율을 높입니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>페이지 클리너 스레드(Page Cleaner Thread)&lt;/strong>:
&lt;ul>
&lt;li>백그라운드에서 더티 페이지를 디스크로 동기화하는 전용 스레드를 통해 사용자 쿼리 처리에 영향을 최소화합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>이중 쓰기 버퍼(Doublewrite Buffer)&lt;/strong>&lt;/p>
&lt;p>데이터 무결성을 보장하면서도 쓰기 성능을 향상시키는 매커니즘입니다.&lt;/p>
&lt;ul>
&lt;li>더티 페이지를 데이터 파일에 직접 쓰기 전에 먼저 연속된 이중 쓰기 버퍼 영역에 기록합니다.&lt;/li>
&lt;li>연속된 영역에 순차적으로 기록하므로 I/O 효율성이 향상됩니다.&lt;/li>
&lt;li>&amp;ldquo;부분 페이지 쓰기&amp;rdquo; 문제를 방지하여 시스템 충돌 시에도 데이터 일관성을 보장합니다.&lt;/li>
&lt;/ul>
&lt;h3 id="mvcc의-쓰기-성능-개선-효과">MVCC의 쓰기 성능 개선 효과&lt;/h3>
&lt;p>MVCC는 여러 트랜잭션이 동시에 적용되는 상황에서 잠금 수준에 따라 다른 버전을 유지, 제공하여 잠금으로 인한 읽기 성능 저하를 개선하려는 목적으로 활용하지만, 트랜잭션의 유지 시간을 줄여 쓰기 성능 향상을 기대할 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>읽기-쓰기 충돌 감소&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>쓰기 블로킹 최소화&lt;/strong>:
&lt;ul>
&lt;li>전통적인 잠금 기반 시스템에서는 쓰기 작업이 읽기 작업을 차단하거나 그 반대의 경우가 발생하지만, MVCC는 쓰기 중에도 일관된 데이터 스냅샷을 통해 읽기가 가능하게 함으로써 블로킹을 최소화합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>동시성 향상&lt;/strong>:
&lt;ul>
&lt;li>읽기 작업이 쓰기 작업을 기다릴 필요가 없기 때문에, 높은 동시성 환경에서 쓰기 처리량이 크게 향상됩니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>적은 락 획득&lt;/strong>:
&lt;ul>
&lt;li>읽기 작업이 락을 획득할 필요가 없으므로, 쓰기 작업에 필요한 락을 더 빠르게 획득할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>트랜잭션 처리 효율성&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>빠른 롤백 처리&lt;/strong>:
&lt;ul>
&lt;li>변경 사항을 새 버전으로 만들기 때문에, 롤백 시 이전 버전의 데이터가 이미 보존되어 있어 복잡한 복구 작업이 필요하지 않습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>효율적인 충돌 해결&lt;/strong>:
&lt;ul>
&lt;li>트랜잭션 간 충돌을 버전 비교를 통해 효율적으로 감지하고 관리할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>더 짧은 트랜잭션 시간&lt;/strong>:
&lt;ul>
&lt;li>읽기 작업이 쓰기를 차단하지 않아 트랜잭션 완료 시간이 단축됩니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="rdbms-쓰기-작업-성능-저하">RDBMS 쓰기 작업 성능 저하&lt;/h2>
&lt;p>InnoDB 에서는 위와 같은 노력을 통해 실제 디스크에 변경 내역을 반영하는 작업은 백그라운드로 실행할 수 있게 하고 있습니다. 이 때문에 실제 디스크에 반영되기까지 시간을 걸릴 지 모르겠지만, RDBMS를 사용하는 클라이언트 입장에서는 빠르게 처리되는 것 처럼 동작하게 됩니다.&lt;/p>
&lt;p>하지만 그럼에도 불구하고 성능 저하가 발생하는 이유가 있습니다.&lt;/p>
&lt;h3 id="트랜잭션-일관성-유지-비용">트랜잭션 일관성 유지 비용&lt;/h3>
&lt;p>ACID 특성을 완벽하게 보장하기 위한 오버헤드가 발생합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>트랜잭션 로깅&lt;/strong>:
&lt;ul>
&lt;li>모든 변경 사항은 리두 로그와 언두 로그에 기록되어야 합니다.&lt;/li>
&lt;li>이 로깅 작업은 추가적인 I/O를 발생시키며, 특히 &lt;code>innodb_flush_log_at_trx_commit=1&lt;/code> 설정에서는 모든 트랜잭션 커밋마다 로그를 디스크에 동기화해야 합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>원자성 보장&lt;/strong>:
&lt;ul>
&lt;li>트랜잭션의 모든 작업이 완료되거나 아무것도 적용되지 않아야 하는 원자성을 보장하기 위해, 시스템은 복잡한 롤백 메커니즘을 유지해야 합니다. 이는 롤백 세그먼트 관리와 같은 추가 오버헤드를 발생시킵니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>지속성 보장&lt;/strong>:
&lt;ul>
&lt;li>데이터 변경이 영구적으로 저장되도록 보장하기 위해 데이터베이스는 메모리상의 변경 사항을 주기적으로 디스크에 동기화해야 합니다.&lt;/li>
&lt;li>이 동기화 작업은 비용이 크며, 특히 대규모 변경 작업 후 발생하는 체크포인트는 급격한 I/O 증가를 유발할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="인덱스-관리의-복잡성">인덱스 관리의 복잡성&lt;/h3>
&lt;p>B-Tree 기반 인덱스 구조가 가지는 특성으로 인한 오버헤드가 발생합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>다중 인덱스 업데이트&lt;/strong>:
&lt;ul>
&lt;li>하나의 테이블에 여러 인덱스가 있는 경우, 데이터 변경 시 모든 관련 인덱스를 함께 업데이트해야 합니다.&lt;/li>
&lt;li>인덱스의 수가 많을수록 쓰기 작업의 부담이 기하급수적으로 증가합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>B-Tree 재조정&lt;/strong>:
&lt;ul>
&lt;li>데이터 삽입이나 삭제로 인해 B-Tree 구조의 균형이 깨지면, 시스템은 페이지 분할(Page Split)이나 페이지 병합(Page Merge)을 수행해야 합니다.&lt;/li>
&lt;li>이 과정은 추가적인 I/O와 CPU 비용을 발생시키며, 특히 페이지 분할은 연쇄적인 분할을 유발할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>인덱스 단편화&lt;/strong>:
&lt;ul>
&lt;li>시간이 지남에 따라 B-Tree 인덱스는 단편화되어 공간 효율성과 성능이 저하될 수 있습니다.&lt;/li>
&lt;li>이를 해결하기 위한 인덱스 재구성 작업은 추가적인 시스템 부하를 발생시킵니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="제약-조건-검증">제약 조건 검증&lt;/h3>
&lt;p>데이터 무결성을 위한 다양한 제약 조건 검증 과정이 쓰기 성능에 영향을 미칩니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>외래 키 제약 조건&lt;/strong>:
&lt;ul>
&lt;li>외래 키를 포함하는 테이블에서 데이터를 변경할 때, 시스템은 참조 무결성을 유지하기 위해 참조된 테이블을 검사해야 합니다&lt;/li>
&lt;li>이는 추가적인 쿼리와 락을 필요로 합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>유니크 제약 조건&lt;/strong>:
&lt;ul>
&lt;li>고유 인덱스가 있는 열에 데이터를 삽입할 때, 시스템은 중복 값이 없는지 확인해야 합니다.&lt;/li>
&lt;li>이 검증 과정은 특히 대량 삽입 작업에서 상당한 오버헤드를 발생시킬 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>체크 제약 조건&lt;/strong>:
&lt;ul>
&lt;li>데이터 값이 특정 조건을 만족하는지 확인하는 체크 제약 조건은 추가적인 검증 로직이 필요하며, 이는 쓰기 작업의 복잡성을 증가시킵니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 때문에 실제 제약 조건을 애플리케이션 수준에서 처리하는 경우가 다수 있습니다.&lt;/p>
&lt;h3 id="버퍼-관리의-복잡성">버퍼 관리의 복잡성&lt;/h3>
&lt;p>메모리와 디스크 사이의 데이터 관리가 복잡한 오버헤드를 발생시킵니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>버퍼풀 경합&lt;/strong>:
&lt;ul>
&lt;li>고부하 상황에서 버퍼풀의 제한된 페이지를 두고 여러 쿼리가 경쟁할 수 있으며, 이는 상호 간섭과 성능 저하를 초래할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>메모리 제약&lt;/strong>:
&lt;ul>
&lt;li>데이터셋이 사용 가능한 메모리보다 클 경우, 페이지를 지속적으로 디스크에서 읽고 쓰는 스래싱(thrashing) 현상이 발생할 수 있으며, 이는 성능을 크게 저하시킵니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>더티 페이지 관리&lt;/strong>:
&lt;ul>
&lt;li>버퍼풀에 많은 더티 페이지가 누적되면, 체크포인트 동안 디스크에 대량의 데이터를 쓰는 &amp;ldquo;쓰기 폭발(write burst)&amp;rdquo; 현상이 발생할 수 있습니다.&lt;/li>
&lt;li>이는 특히 대량 데이터 로드 작업 후에 심각한 성능 문제를 일으킬 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="잠금lock-메커니즘의-오버헤드">잠금(Lock) 메커니즘의 오버헤드&lt;/h3>
&lt;p>데이터 일관성을 보장하기 위한 다양한 수준의 잠금 메커니즘이 성능에 영향을 미칩니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>테이블 잠금(Table Lock)&lt;/strong>:
&lt;ul>
&lt;li>&lt;code>ALTER TABLE&lt;/code>과 같은 스키마 변경 작업은 테이블 전체를 잠그기 때문에, 해당 테이블에 대한 모든 쓰기 작업이 차단됩니다.&lt;/li>
&lt;li>이는 특히 대형 테이블이나 고부하 환경에서 심각한 성능 문제를 일으킬 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>행 잠금(Row Lock)&lt;/strong>:
&lt;ul>
&lt;li>개별 행 수준의 잠금은 더 높은 동시성을 제공하지만, 관리해야 할 잠금의 수가 많아지면서 오버헤드가 증가합니다.&lt;/li>
&lt;li>특히 많은 행을 수정하는 트랜잭션에서는 수많은 잠금을 획득하고 관리해야 하므로 성능이 저하될 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>갭 잠금(Gap Lock)&lt;/strong>:
&lt;ul>
&lt;li>InnoDB의 기본 격리 수준인 REPEATABLE READ에서는 팬텀 읽기(phantom reads)를 방지하기 위해 갭 잠금을 사용합니다.&lt;/li>
&lt;li>이는 실제 레코드뿐만 아니라 레코드 사이의 간격까지 잠그기 때문에 동시성이 감소하고 교착 상태 가능성이 증가합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>의도 잠금(Intention Lock)&lt;/strong>:
&lt;ul>
&lt;li>테이블과 행 간의 잠금 관계를 효율적으로 관리하기 위한 의도 잠금도 추가적인 관리 오버헤드를 발생시킵니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="잠금-경합lock-contention과-교착-상태deadlock">잠금 경합(Lock Contention)과 교착 상태(Deadlock)&lt;/h3>
&lt;p>고부하 상황에서 잠금 관련 문제가 성능을 크게 저하시킬 수 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>잠금 대기(Lock Wait)&lt;/strong>:
&lt;ul>
&lt;li>한 트랜잭션이 이미 잠긴 리소스에 접근하려 할 때, 해당 리소스가 해제될 때까지 대기해야 합니다.&lt;/li>
&lt;li>이러한 대기 시간은 전체 쿼리 실행 시간을 크게 증가시킬 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>교착 상태(Deadlock)&lt;/strong>:
&lt;ul>
&lt;li>서로 다른 트랜잭션이 상대방이 필요로 하는 잠금을 보유한 채로 서로의 잠금을 기다리는 교착 상태가 발생할 수 있습니다.&lt;/li>
&lt;li>InnoDB는 이를 감지하고 자동으로 한 트랜잭션을 롤백시키지만, 이로 인해 애플리케이션에서 트랜잭션을 재시도해야 하는 추가 비용이 발생합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>핫스팟(Hotspot)&lt;/strong>:
&lt;ul>
&lt;li>특정 행이나 페이지가 많은 트랜잭션에 의해 빈번하게 접근되는 경우, 해당 리소스에 대한 경합이 심해지고 이는 전체 시스템 성능을 저하시키는 병목 지점이 될 수 있습니다.&lt;/li>
&lt;li>일반적인 예로는 시퀀스 테이블이나 카운터 업데이트 등이 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이러한 다양한 요인들이 RDBMS에서 쓰기 작업의 성능을 제약하는 근본적인 이유가 됩니다. MySQL InnoDB와 같은 현대적인 엔진은 이러한 제약을 최소화하기 위해 다양한 최적화 기법을 도입했지만, 기본적인 아키텍처 특성으로 인한 한계가 존재합니다.&lt;/p>
&lt;h2 id="lsm-tree가-적절한-상황은">LSM Tree가 적절한 상황은?&lt;/h2>
&lt;p>InnoDB의 다양한 최적화에도 불구하고, 특정 상황에서는 여전히 NoSQL 데이터베이스가 더 적합한 선택일 수 있습니다.&lt;/p>
&lt;h3 id="대규모-쓰기-워크로드">대규모 쓰기 워크로드&lt;/h3>
&lt;p>극단적으로 쓰기가 많은 워크로드에서는 LSM Tree 기반 시스템이 본질적으로 유리합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>고빈도 삽입 작업&lt;/strong>:
&lt;ul>
&lt;li>로그 수집, IoT 센서 데이터, 클릭스트림 추적과 같이 초당 수만에서 수십만 건의 삽입이 필요한 경우, NoSQL 시스템의 순차적 쓰기 방식이 큰 이점을 제공합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>쓰기 최적화 구조&lt;/strong>:
&lt;ul>
&lt;li>NoSQL 시스템은 쓰기 작업을 위해 특별히 설계되었으며, 디스크 I/O 패턴이 쓰기에 최적화되어 있습니다.&lt;/li>
&lt;li>인덱스 구조의 재구성 없이 순차 쓰기만 수행하므로 CPU 오버헤드가 적습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>배치 처리 효율성&lt;/strong>:
&lt;ul>
&lt;li>대량의 데이터를 일괄 처리하는 작업에서 NoSQL은 스키마 검증, 트랜잭션 오버헤드, 인덱스 재구성과 같은 RDBMS의 제약 없이 더 빠르게 데이터를 로드할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="스키마리스schemaless-데이터-모델-필요">스키마리스(Schemaless) 데이터 모델 필요&lt;/h3>
&lt;p>데이터 구조가 자주 변경되거나 매우 다양한 경우 LSM Tree가 유리합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>유연한 스키마&lt;/strong>:
&lt;ul>
&lt;li>문서 기반 NoSQL 데이터베이스는 스키마 변경 없이 새로운 필드를 추가할 수 있어, 빠르게 변화하는 비즈니스 요구사항에 더 민첩하게 대응할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>다양한 데이터 형태&lt;/strong>:
&lt;ul>
&lt;li>같은 컬렉션 내에서도 서로 다른 구조의 데이터를 저장할 수 있어, 이기종 데이터를 관리하는 데 유리합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>개발 속도&lt;/strong>:
&lt;ul>
&lt;li>스키마 정의 및 마이그레이션 부담이 없어, 프로토타이핑이나 애자일 개발 환경에서 빠른 반복 개발이 가능합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="수평적-확장성-요구">수평적 확장성 요구&lt;/h3>
&lt;p>대규모 데이터와 트래픽을 처리해야 하는 경우 NoSQL의 분산 아키텍처가 유리합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>기본 샤딩 지원&lt;/strong>:
&lt;ul>
&lt;li>많은 NoSQL 솔루션은 처음부터 분산 시스템으로 설계되어 있어, 데이터를 여러 노드에 자동으로 분산하는 샤딩 기능이 기본으로 제공됩니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>선형적 확장성&lt;/strong>:
&lt;ul>
&lt;li>노드를 추가하는 것만으로 거의 선형적인 성능 향상을 얻을 수 있어, 성장하는 서비스의 수요에 유연하게 대응할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>클라우드 친화적&lt;/strong>:
&lt;ul>
&lt;li>대부분의 NoSQL 시스템은 클라우드 환경에서 효율적으로 동작하도록 설계되어 있어, 탄력적인 리소스 관리와 자동화된 운영이 용이합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>또한 RDBMS에서는 읽기 전용 레플리카를 통해 읽기 작업에 부하를 비교적 쉽게 개선할 수 있지만, 쓰기 작업에 대한 쓰기 레플리카를 운영하는 것은 RDBMS의 쓰기 과정의 복잡함으로 인해 굉장히 비효율적인 것으로 알려져 있습니다.&lt;/p>
&lt;h3 id="지리적으로-분산된-데이터-저장">지리적으로 분산된 데이터 저장&lt;/h3>
&lt;p>글로벌 서비스나 지역적으로 분산된 애플리케이션의 경우 복제가 유리한 LSM Tree가 적합할 수 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>멀티 리전 복제&lt;/strong>:
&lt;ul>
&lt;li>많은 NoSQL 시스템은 지리적으로 분산된 데이터 센터 간의 복제를 기본 기능으로 지원하여, 글로벌 사용자에게 낮은 지연 시간의 서비스를 제공할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>파티션 허용성&lt;/strong>:
&lt;ul>
&lt;li>CAP 이론에서 가용성(A)과 파티션 허용성(P)에 중점을 두어, 네트워크 지연이나 단절이 있는 환경에서도 서비스를 계속 제공할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>지역성 최적화&lt;/strong>:
&lt;ul>
&lt;li>사용자와 가까운 지역에 데이터를 위치시켜 접근 지연 시간을 최소화할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="높은-가용성-요구">높은 가용성 요구&lt;/h3>
&lt;p>중단 없는 서비스 제공이 필수적인 경우 분산 특성이 유리합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>마스터리스(Masterless) 아키텍처&lt;/strong>:
&lt;ul>
&lt;li>카산드라와 같은 일부 NoSQL 시스템은 모든 노드가 동등한 역할을 하는 마스터리스 아키텍처를 제공하여, 단일 장애점이 없는 고가용성 시스템을 구축할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>자동 복구 메커니즘&lt;/strong>:
&lt;ul>
&lt;li>노드 장애 시 자동으로 데이터를 재분배하고 복구하는 메커니즘이 내장되어 있어, 운영 부담이 줄어듭니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>읽기/쓰기 가용성 조정&lt;/strong>:
&lt;ul>
&lt;li>일부 NoSQL 시스템에서는 일관성 수준을 조정하여 가용성과 일관성 사이의 균형을 애플리케이션 요구에 맞게 조정할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>LSM Tree를 활용하는 NoSQL 데이터베이스는 이러한 특정 사용 사례에서 RDBMS보다 뛰어난 성능과 적합성을 제공할 수 있습니다. 그러나 트랜잭션 일관성, 복잡한 쿼리, 조인 작업이 중요한 경우에는 여전히 RDBMS가 더 적합할 수 있으므로, 데이터베이스 선택은 실제 애플리케이션의 요구사항과 워크로드 특성을 면밀히 분석한 후 이루어져야 합니다.&lt;/p>
&lt;h2 id="실제-환경에서의-데이터베이스-선택">실제 환경에서의 데이터베이스 선택&lt;/h2>
&lt;p>이론적인 차이점만으로는 실제 환경에서의 성능을 정확히 예측하기 어렵습니다. 다음과 같은 요소들이 성능에 큰 영향을 미칩니다.&lt;/p>
&lt;h3 id="워크로드-특성">워크로드 특성&lt;/h3>
&lt;p>워크로드의 읽기/쓰기 비율은 데이터베이스 선택에 중요한 요소입니다.&lt;/p>
&lt;p>읽기가 대부분인 워크로드(일반적인 웹 서비스)에서는 B-Tree 기반 RDBMS가 유리할 수 있습니다. 반면, 쓰기가 많은 워크로드(예: 로깅, 이벤트 수집)에서는 LSM Tree 기반 NoSQL이 더 효율적일 수 있습니다.&lt;/p>
&lt;p>쿼리 패턴도 중요한데, &lt;strong>복잡한 조인&lt;/strong>이나 &lt;strong>트랜잭션&lt;/strong>이 필요한 경우 RDBMS가 적합하며, 단순한 &lt;strong>키-값 조회&lt;/strong>가 주된 작업이라면 NoSQL이 더 간단하고 효율적일 수 있습니다.&lt;/p>
&lt;p>&lt;strong>데이터 크기&lt;/strong>와 &lt;strong>성장 속도&lt;/strong>도 고려해야 하는데, 대용량 데이터에서는 LSM Tree의 우수한 압축률과 확장성이 장점이 될 수 있습니다.&lt;/p>
&lt;h3 id="하드웨어-환경">하드웨어 환경&lt;/h3>
&lt;p>하드웨어 환경은 데이터베이스 성능에 직접적인 영향을 미칩니다.&lt;/p>
&lt;p>HDD를 사용하는 경우, 순차적 I/O에 최적화된 LSM Tree가 무작위 I/O가 많은 B-Tree보다 유리합니다. SSD에서는 무작위 I/O의 패널티가 줄어들어 B-Tree의 단점이 완화됩니다.&lt;/p>
&lt;p>&lt;strong>사용 가능한 메모리&lt;/strong> 양도 중요한 요소입니다. 대용량 버퍼풀이 가능한 환경에서는 B-Tree의 읽기/쓰기 성능이 크게 향상되며, LSM Tree의 컴팩션 오버헤드가 상대적으로 더 부담스러울 수 있습니다.&lt;/p>
&lt;p>&lt;strong>CPU 자원&lt;/strong>도 고려해야 하는데, LSM Tree의 백그라운드 컴팩션 작업은 추가적인 CPU 자원을 소모하므로, CPU 제한이 있는 환경에서는 이점이 감소할 수 있습니다.&lt;/p>
&lt;h3 id="애플리케이션-요구사항">애플리케이션 요구사항&lt;/h3>
&lt;p>애플리케이션의 &lt;strong>데이터 일관성&lt;/strong>, &lt;strong>트랜잭션&lt;/strong>, &lt;strong>가용성&lt;/strong> 요구사항도 데이터베이스 선택에 중요한 요소입니다.&lt;/p>
&lt;p>ACID 트랜잭션이 중요한 금융, 전자상거래 등의 애플리케이션에서는 RDBMS를 선호하는 경향이 있습니다. 반면, 일시적인 데이터 불일치를 허용할 수 있는 소셜 미디어, 로깅 등의 애플리케이션에서는 NoSQL의 유연성과 확장성이 장점이 될 수 있습니다.&lt;/p>
&lt;p>&lt;strong>스키마 변경 빈도&lt;/strong>도 고려사항입니다. 스키마가 자주 변경되는 환경에서는 스키마리스 또는 스키마 유연성이 높은 NoSQL이 유리할 수 있습니다. 지리적 분산이나 고가용성 요구사항이 있는 경우, 분산 설계가 기본적으로 포함된 일부 NoSQL 솔루션이 적합할 수 있습니다.&lt;/p>
&lt;h2 id="실제-벤치마크-테스트의-중요성">실제 벤치마크 테스트의 중요성&lt;/h2>
&lt;p>이론적인 성능 특성은 중요한 지침이 되지만, 실제 운영 환경에서 예상과 다른 결과가 나올 수 있기 때문에 최종 결정은 실제 애플리케이션 데이터와 워크로드를 사용한 벤치마크 테스트를 통해 이루어져야 한다고 언급하고 있습니다.&lt;/p>
&lt;h3 id="실제-데이터-크기와-분포-반영">실제 데이터 크기와 분포 반영&lt;/h3>
&lt;p>벤치마크 테스트는 반드시 &lt;strong>실제 애플리케이션에서 사용할 데이터의 크기와 분포&lt;/strong>를 반영해야 합니다.&lt;/p>
&lt;p>합성 데이터나 균일하게 분포된 테스트 데이터는 실제 환경에서의 성능을 정확히 예측하지 못할 수 있습니다. 실제 데이터는 종종 불균형하게 분포되어 있으며, 이런 데이터 편향(skew)은 데이터베이스 성능에 큰 영향을 미칩니다. 특히 인덱스 효율성, 캐시 히트율, 쿼리 실행 계획 등에 영향을 줍니다.&lt;br>
가능하다면 프로덕션 데이터의 익명화된 사본이나 통계적으로 유사한 데이터셋을 사용하여 테스트하는 것이 좋습니다.&lt;/p>
&lt;h3 id="실제-쿼리-패턴-테스트">실제 쿼리 패턴 테스트&lt;/h3>
&lt;p>애플리케이션의 &lt;strong>실제 쿼리 패턴&lt;/strong>을 사용한 벤치마크가 중요합니다.&lt;/p>
&lt;p>단순한 CRUD 작업만으로는 복잡한 애플리케이션의 성능을 예측하기 어렵습니다. 실제 애플리케이션에서 자주 사용되는 쿼리, 특히 &lt;strong>성능 병목이 될 가능성이 있는 복잡한 쿼리들을 포함&lt;/strong>시켜야 합니다.&lt;/p>
&lt;p>실제 워크로드의 &lt;strong>읽기/쓰기 비율&lt;/strong>, &lt;strong>동시 접속 수준&lt;/strong>, &lt;strong>쿼리 복잡성&lt;/strong> 등을 반영한 &lt;strong>테스트 시나리오를 구성&lt;/strong>해야 합니다. 또한 피크 시간대의 부하를 시뮬레이션하여 최악의 상황에서도 성능 요구사항을 충족하는지 확인해야 합니다.&lt;/p>
&lt;h3 id="확장성-테스트">확장성 테스트&lt;/h3>
&lt;p>데이터베이스는 시간이 지남에 따라 데이터 볼륨이 증가하므로, 확장성 테스트가 필요할 수 있습니다. 현재 데이터 크기뿐만 아니라 예상되는 미래 데이터 크기에서도 테스트를 수행하면 좋습니다.&lt;/p>
&lt;p>데이터 증가에 따른 쿼리 성능 변화, 인덱스 효율성 변화, 저장 공간 요구사항 등을 측정해야 합니다. 또한 데이터 증가에 따른 백업, 복구, 유지보수 작업의 성능도 고려해야 합니다. 하드웨어 리소스(CPU, 메모리, 디스크 I/O, 네트워크 대역폭) 사용률을 모니터링하여 어떤 리소스가 병목이 되는지 파악하고, 스케일업 또는 스케일아웃 전략을 계획해야 합니다.&lt;/p>
&lt;h3 id="장기-실행-테스트">장기 실행 테스트&lt;/h3>
&lt;p>데이터베이스 성능은 시간이 지남에 따라 변화할 수 있으므로, 장기 실행 테스트가 필요할 수 있습니다.&lt;/p>
&lt;p>LSM Tree 기반 데이터베이스는 시간이 지남에 따라 컴팩션 오버헤드가 누적될 수 있고, B-Tree 기반 데이터베이스는 메모리 단편화나 인덱스 불균형 문제가 발생할 수 있습니다. 따라서 단기 성능뿐만 아니라 며칠 또는 몇 주에 걸친 장기 실행 테스트를 통해 성능 저하 패턴을 분석해야 합니다.&lt;/p>
&lt;p>백그라운드 작업(컴팩션, 통계 업데이트, 백업 등)이 전체 시스템 성능에 미치는 영향도 평가해야 합니다. 또한 장애 상황(노드 장애, 디스크 오류 등) 후 복구 성능과 데이터 일관성도 테스트해야 합니다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>B-Tree 기반의 MySQL InnoDB와 LSM Tree 기반의 NoSQL 데이터베이스는 각각 고유한 성능 특성과 장단점을 가지고 있습니다. 전통적으로 RDBMS는 읽기에 최적화되어 있고, NoSQL은 쓰기에 최적화되어 있다고 여겨졌지만, 현대적인 데이터베이스 엔진들은 이러한 격차를 상당 부분 줄였습니다.&lt;/p>
&lt;p>MySQL InnoDB는 버퍼풀, 변경 버퍼, MVCC 등 다양한 최적화 기법을 통해 B-Tree의 전통적인 쓰기 성능 약점을 크게 개선했습니다. 이러한 최적화는 많은 일반적인 워크로드에서 NoSQL과 비교할 만한 쓰기 성능을 제공할 수 있게 했습니다. 또한 트랜잭션 특성, 강력한 일관성, 복잡한 쿼리 지원 등 RDBMS만의 강점을 유지하고 있습니다.&lt;/p>
&lt;p>반면, 대규모 쓰기 작업, 스키마리스 데이터 모델, 수평적 확장성, 지리적 분산 등이 필요한 특정 사례에서는 여전히 NoSQL 솔루션이 더 적합할 수 있습니다. 특히 초당 수십만 건 이상의 쓰기나 페타바이트 규모의 데이터를 다루는 환경에서는 NoSQL의 분산 아키텍처와 쓰기 최적화 설계가 큰 이점을 제공합니다.&lt;/p>
&lt;p>데이터베이스 선택에 있어 가장 중요한 것은 &amp;ldquo;어떤 데이터베이스가 더 좋은가&amp;quot;라는 단순한 질문이 아닌, 다음과 같은 실제 요구사항과 제약 조건을 종합적으로 고려하는 것입니다.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>워크로드 특성&lt;/strong>:
&lt;ul>
&lt;li>읽기/쓰기 비율, 쿼리 복잡성, 트랜잭션 요구사항&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>데이터 모델&lt;/strong>:
&lt;ul>
&lt;li>관계형 데이터 vs 비구조화 데이터, 스키마 변경 빈도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>확장성 요구사항&lt;/strong>:
&lt;ul>
&lt;li>데이터 증가 예측, 필요한 처리량, 확장 전략&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>운영 고려사항&lt;/strong>:
&lt;ul>
&lt;li>유지보수, 백업, 복구, 모니터링 용이성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>리소스 제약&lt;/strong>:
&lt;ul>
&lt;li>하드웨어 환경, 예산, 팀의 기술적 역량&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>또한, 현대적인 시스템 아키텍처에서는 단일 데이터베이스에 의존하기보다 다중 데이터베이스 접근법(polyglot persistence)을 채택하는 경우가 늘고 있습니다. 트랜잭션 처리에는 RDBMS를, 로깅이나 분석에는 NoSQL을 사용하는 방식으로, 각 부분에 가장 적합한 데이터 저장소를 선택하는 접근법입니다.&lt;/p>
&lt;p>무엇보다 중요한 것은 이론적인 성능 특성만으로 판단하지 말고, 실제 데이터와 워크로드를 사용한 벤치마크 테스트를 통해 결정을 검증하는 것입니다. 데이터베이스 성능은 특정 워크로드, 데이터 크기, 하드웨어 환경에 따라 크게 달라질 수 있으므로, 실제 환경과 유사한 조건에서의 테스트가 필수적입니다.&lt;/p>
&lt;p>결론적으로, MySQL InnoDB와 같은 현대적인 RDBMS는 다양한 최적화를 통해 쓰기 성능을 크게 개선했지만, 특정 사용 사례에서는 여전히 NoSQL의 장점이 두드러집니다. 데이터베이스 선택은 기술적인 특성뿐만 아니라 비즈니스 요구사항, 개발 생산성, 운영 비용 등을 종합적으로 고려한 균형 잡힌 접근이 필요합니다.&lt;/p></description></item><item><title>10. 실시간 게임 순위표</title><link>https://codemario318.github.io/post/system-design-interview-2/10/</link><pubDate>Sun, 17 Nov 2024 14:41:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/10/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/cover.png" alt="Featured image of post 10. 실시간 게임 순위표" />&lt;p>이번 장에서는 &lt;strong>온라인 게임 리더보드&lt;/strong>, 즉 순위표를 설계해본다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>순위표?&lt;/strong>&lt;br>
누가 선두를 달리고 있는지 보여주기 위해 게임 등에서 흔히 사용하는 장치로, 가장 많은 포인트를 획득한 사람이 순위표의 맨 위에 자리한다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img.png"
width="1390"
height="560"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_hu968a6c0a83c3daa84d4ec97bc604aae0_41694_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_hu968a6c0a83c3daa84d4ec97bc604aae0_41694_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="순위표"
class="gallery-image"
data-flex-grow="248"
data-flex-basis="595px"
>&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;ul>
&lt;li>게임에 승리하면 포인트 획득&lt;/li>
&lt;li>모든 플레이어가 순위표에 포함&lt;/li>
&lt;li>새로운 토너먼트를 시작할 때 마다 새로운 순위표 생성&lt;/li>
&lt;li>상위 10명의 사용자와 특정 사용자의 순위를 순위표에 표시
&lt;ul>
&lt;li>특정 사용자의 순위를 보여줄 때 위, 아래로 4순위 차이 사용자 포함(추가 요구사항)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DAU 500만명, MAU 2,500만명&lt;/li>
&lt;li>각 선수는 하루에 평균 10 경기 진행&lt;/li>
&lt;li>실시간 또는 실시간에 가깝게 결과를 표시&lt;/li>
&lt;li>누적된 결과 이력을 보여주는건 바람직하지 않음&lt;/li>
&lt;/ul>
&lt;h3 id="기능-요구사항">기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>순위표에 상위 10명의 플레이어를 표시&lt;/li>
&lt;li>특정 사용자의 순위를 표시&lt;/li>
&lt;li>어떤 사용자보다 4순위 위, 아래에 있는 사용자를 표시(추가 요구 사항)&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>점수 업데이트는 실시간으로 순위표에 반영&lt;/li>
&lt;li>일반적인 확장성, 가용성 및 안정성 요구사항&lt;/li>
&lt;/ul>
&lt;h3 id="개략적인-규모-추정">개략적인 규모 추정&lt;/h3>
&lt;p>설계를 통해 해결해야 할 문제의 잠재적 규모와 과제를 결정하기 위한 몇가지 계산 결과를 살펴본다.&lt;/p>
&lt;p>게임은 대부분 사용량이 균등한 경우가 없으며, 북미 기준 저녁 시간이 피크 시간대일 가능성이 높다.&lt;/p>
&lt;p>이를 고려하여 최대 부하는 평균의 다섯배 정도로 가정한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>사용자 수&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>500만 / 10^5 초 =~ 50 * 5 = 초당 250 사용자&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>점수 획득 QPS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>한 사용자가 하루 평균 10개의 게임을 플레이한다고 가정&lt;/li>
&lt;li>점수를 획득하는 이벤트가 발생하는 평균 QPS는 &lt;code>50 * 10 =~ 500&lt;/code>&lt;/li>
&lt;li>최대 QPS는 평균의 5배로 가정하였으므로 &lt;code>500 * 5 = 2,500&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>상위 10명 순위표 가져오기&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>각 사용자가 하루 한 번 게임을 실행&lt;/li>
&lt;li>상위 10명 순위표는 사용자가 처음 게임을 열 때만 표시한다고 가정&lt;/li>
&lt;li>&lt;code>QPS =~ 50&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="api-설계">API 설계&lt;/h3>
&lt;p>개략적으로 3가지 API가 필요하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>POST /v1/scores&lt;/code>&lt;/strong>&lt;/p>
&lt;p>사용자가 게임에서 승리하면 순위표에서 사용자의 순위를 갱신한다.&lt;/p>
&lt;p>API는 게임 서버에서만 호출할 수 있는 내부 API로 클라이언트는 해당 API를 통하지 않고 순위표 점수를 직접 업데이트 할 수 없다.&lt;/p>
&lt;ul>
&lt;li>요청&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>필드&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>user_id&lt;/code>&lt;/td>
&lt;td>게임에서 승리한 사용자&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>points&lt;/code>&lt;/td>
&lt;td>사용자가 게임에서 승리하여 획득한 포인트 수&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>응답&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>이름&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>200 OK&lt;/code>&lt;/td>
&lt;td>사용자 점수를 성공적으로 갱신&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>400 Bad Request&lt;/code>&lt;/td>
&lt;td>잘못된 인자가 전달되어 사용자 점수를 갱신할 수 없음&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/scores&lt;/code>&lt;/strong>&lt;/p>
&lt;p>순위표에서 상위 10명의 플레이어를 조회&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;data&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;user_id1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;alice&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;rank&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;score&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">12543&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;user_id2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;bob&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;rank&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;score&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">11500&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;total&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>`GET /v1/scores/{:user_id}&lt;/strong>&lt;/p>
&lt;p>특정 사용자의 순위를 가져옴&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>필드&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>user_id&lt;/code>&lt;/td>
&lt;td>순위 정보를 가져올 사용자 ID&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_info&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;user5&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;score&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;rank&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>두 가지 서비스가 포함된다.&lt;/p>
&lt;ul>
&lt;li>게임 서비스
&lt;ul>
&lt;li>사용자가 게임을 플레이할 수 있도록 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>순위표 서비스
&lt;ul>
&lt;li>순위표를 생성하고 표시하는 역할 담당&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_1.png"
width="1102"
height="1066"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_1_hu51c0eaf019b910cb8404ff183ad3d839_54249_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_1_hu51c0eaf019b910cb8404ff183ad3d839_54249_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계"
class="gallery-image"
data-flex-grow="103"
data-flex-basis="248px"
>&lt;/p>
&lt;ol>
&lt;li>사용자가 게임에서 승리하면 클라이언트는 게임 서비스에 요청을 보낸다.&lt;/li>
&lt;li>게임 서비스는 해당 승리가 정당하고 유효한 것인지 확인한 다음 순위표 서비스에 점수 갱신 요청을 보낸다.&lt;/li>
&lt;li>순위표 서비스는 순위표 저장소에 기록된 해당 사용자의 점수를 갱신한다.&lt;/li>
&lt;li>해당 사용자의 클라이언트는 순위표 서비스에 직접 요청하여 다음과 같은 데이터를 가져온다.
&lt;ul>
&lt;li>상위 10명 순위표&lt;/li>
&lt;li>해당 사용자 순위&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>다른 대안들도 있지만 채택하지 않은 이유를 살펴보면 도움이 될 것이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>클라이언트가 순위표 서비스와 직접 통신해야 하나?&lt;/strong>&lt;/p>
&lt;p>클라이언트가 점수를 정하는 방식(클라이언트가 직접 순위표 서비스에 요청하는 방식)은, 사용자가 프락시를 설치하고 점수를 마음대로 바꾸는 중간자 공격을 할 수 있기 때문에 보안상 안전하지 않다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_2.png"
width="1366"
height="1108"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_2_hu9c2130220f7a6e4a19f502b9d6fb58c8_75990_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_2_hu9c2130220f7a6e4a19f502b9d6fb58c8_75990_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="순위표 점수는 누가 설정하는가"
class="gallery-image"
data-flex-grow="123"
data-flex-basis="295px"
>&lt;/p>
&lt;p>서버가 게임 전반을 통솔하는 경우 클라이언트가 점수를 설정하기 위해서 게임 서버를 명시적으로 호출할 필요가 없을수도 있다.&lt;/p>
&lt;ul>
&lt;li>게임 서버가 모든 게임 로직을 처리하고 게임이 언제 끝나는지 알기 때문에 클라이언트의 개입 없이도 점수를 정할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>게임 서비스와 순위표 서버 사이에 메시지 큐가 필요한가?&lt;/strong>&lt;/p>
&lt;p>게임 점수가 어떻게 사용되는지에 따라 크게 달라질 수 있다.&lt;/p>
&lt;p>해당 데이터가 다른 곳에서도 이용되거나 여러 기능을 지원해야 한다면 카프카에 데이터를 넣는 것이 합리적일 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_3.png"
width="1372"
height="516"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_3_hu1571b99ddafa8ab0beb62502c9444491_33359_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_3_hu1571b99ddafa8ab0beb62502c9444491_33359_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="게임 점수를 여러 서비스에서 사용하는 방안"
class="gallery-image"
data-flex-grow="265"
data-flex-basis="638px"
>&lt;/p>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>순위표 저장소는 시스템의 핵심 구성 요소 중 하나다.&lt;/p>
&lt;p>저장소 구현에 사용할 수 있는 세 가지 기술을 살펴본다.&lt;/p>
&lt;h4 id="관계형-데이터베이스">&lt;strong>관계형 데이터베이스&lt;/strong>&lt;/h4>
&lt;p>규모 확정성이 중요하지 않고, 사용자 수가 적다면 관계형 데이터베이스 시스템을 활용할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_4.png"
width="884"
height="580"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_4_hu87323fa7d86eb1b53840a0a18b78a259_68258_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_4_hu87323fa7d86eb1b53840a0a18b78a259_68258_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="leaderboard 테이블"
class="gallery-image"
data-flex-grow="152"
data-flex-basis="365px"
>&lt;/p>
&lt;p>각 &lt;strong>월별 순위표&lt;/strong>는 사용자 ID와 점수 열을 갖는 데이블로 표현할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>사용자가 점수를 딴 경우&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_5.png"
width="1354"
height="216"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_5_hu0a7ccfe89d76bf8da6055832ddc6d048_15214_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_5_hu0a7ccfe89d76bf8da6055832ddc6d048_15214_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="사용자가 점수를 획득한 경우"
class="gallery-image"
data-flex-grow="626"
data-flex-basis="1504px"
>&lt;/p>
&lt;p>점수가 1점씩만 늘어난다고 가정하면 해당 월의 순위표에 아직 햊당 사용자가 없다면 새로운 레코드를 만들어 넣고,&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leaderboard&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;mary1934&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>있다면 증가시킨다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">UPDATE leaderboard set score=score + 1 where user_id=&amp;#39;mary1934&amp;#39;;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>특정 사용자 순위 검색&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_6.png"
width="1364"
height="242"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_6_hu9653a2a00caf7b6c21525c7fedeabb71_17500_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_6_hu9653a2a00caf7b6c21525c7fedeabb71_17500_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="사용자의 순위 검색"
class="gallery-image"
data-flex-grow="563"
data-flex-basis="1352px"
>&lt;/p>
&lt;p>사용자의 순위를 가져오려면 순위표 테이블을 점수 기준으로 정렬한 후 순위를 매긴다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">@&lt;/span>&lt;span class="n">rownum&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@&lt;/span>&lt;span class="n">rownum&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rank&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leaderboard&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>이 방안은 데이터가 많지 않을 때는 효과적이지만, 레코드가 수백만 개 정도로 많아지면 성능이 너무 나빠지는 문제가 있다.&lt;/p>
&lt;ul>
&lt;li>사용자의 순위를 파악하려면 모든 플레이어를 순외표의 정확산 위치에 정렬해야한다.&lt;/li>
&lt;li>같은 점수를 받은 사용자가 여럿일 수 있으므로, 순위는 단순히 해당 목록 내의 사용자 위치라고도 할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>SQL 데이터베이스는 지속적으로 변화하는 대량의 정보를 신속하게 처리하지 못한다.&lt;/p>
&lt;ul>
&lt;li>수백만 개 레코드에 순위를 매기려면 대략 수십 초 정도가 걸린다.&lt;/li>
&lt;/ul>
&lt;p>따라서 실시간성을 요구하는 애플레키에션에는 적합하지 않고, 데이터가 지속적으로 변경되므로 캐시 도입도 어렵다.&lt;/p>
&lt;ul>
&lt;li>일괄 작업(배치)로 처리하면 가능할 수 있지만 실시간 순위를 보여주어야 한다는 요구사항에는 적절치 않다.&lt;/li>
&lt;/ul>
&lt;p>인덱스를 추가하고 &lt;code>LIMIT&lt;/code> 절을 사용하여 스캔할 페이지 수를 제한할 수 있지만, 확장성이 좋지 않다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">@&lt;/span>&lt;span class="n">rownum&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@&lt;/span>&lt;span class="n">rownum&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rank&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leaderboard&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>특정 사용자의 순위를 알아내려면 기본적으로 전체 테이블을 훑어야 한다.&lt;/li>
&lt;li>순위표 상단에 있지 않은 사용자의 순위를 간단히 찾을 수 없다.&lt;/li>
&lt;/ul>
&lt;h4 id="레디스">레디스&lt;/h4>
&lt;p>레디스는 메모리 기반 키-값 저장소 시스템으로 메모리에서 동작하여 빠른 읽기 및 쓰기가 가능하다.&lt;/p>
&lt;p>이를 통해 수백만 명의 사용자에 대해서도 예측 가능한 ㅅ어능ㅇ르 제공하고 복잡한 DB 쿼리 없이도 일반적인 순위표 작업을 쉽게 수행할 수 있다.&lt;/p>
&lt;p>아울러 순위표 시스템 설계 문제를 해결하는 데 이상적인 &lt;strong>정렬 집합&lt;/strong>(sorted set)이라는 자료형을 제공한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>정렬 집합이란?&lt;/strong>&lt;/p>
&lt;p>집합과 유사항 자료형으로 저장된 각 원소는 점수에 연결되어 있다.&lt;/p>
&lt;p>집합 내 원소는 고유해야 하지만 같은 점수는 있을 수도 있고, 정렬 집합 내 원소를 오름차순 정렬하는 데 이용된다.&lt;/p>
&lt;p>정렬 집합은 내부적으로 해시 테이블과 스킵 리스트라는 두 가지 자료 구조를 사용한다.&lt;/p>
&lt;ul>
&lt;li>해시 테이블: 사용자의 점수를 저장&lt;/li>
&lt;li>스킵 리스트: 특정 점수를 딴 사용자들의 목록을 저장&lt;/li>
&lt;/ul>
&lt;p>사용자는 점수를 기준으로 정렬한다.&lt;/p>
&lt;ul>
&lt;li>점수 및 사용자 열이 있는 테이블로 생각하면 이해하기 쉽다.
&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_7.png"
width="1352"
height="760"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_7_hu85fd85f56d1e350543434c4ec022a6b0_119803_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_7_hu85fd85f56d1e350543434c4ec022a6b0_119803_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="정렬 집합으로 표현한 2월 순위표"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>스킵 리스트&lt;/strong>&lt;/p>
&lt;p>빠른 검색을 가능하게 하는 자료구조로, 정렬된 연결 리스트에 다단계 색인을 두는 구조이다.&lt;/p>
&lt;p>이 자료 구조의 근간은 정렬된 단방향 연결 리스트로, 이 연결 리스트에 삽입, 삭제, 검색 연산을 실행하는 시간 복잡도는 &lt;code>O(n)&lt;/code>이다.&lt;/p>
&lt;p>연산이 더 빨리 실행할 수 있도록 하기 위해 이진 검색 알고리즘을 통해 중간 지점에 더 빨리 도달할 수 있도록 한다.&lt;/p>
&lt;ul>
&lt;li>중간 노드를 하나씩 건너뛰는 1차 색인과 1차 색인 노드를 하나씩 건너 뛰는 2차 색인을 추가한다.&lt;/li>
&lt;/ul>
&lt;p>새로운 색인을 추가할 때마다 이전 차수의 노드를 하나씩 건너뛸 수 있다.&lt;/p>
&lt;ul>
&lt;li>노드 사이의 거리가 &lt;code>n-1&lt;/code>이 되면 더 이상의 색인을 추가하지 않는다.&lt;/li>
&lt;li>n은 총 노드의 개수&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_8.png"
width="1342"
height="1182"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_8_hu61e3939b81b6b789001ba6d07810bb60_81509_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_8_hu61e3939b81b6b789001ba6d07810bb60_81509_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="스킵 리스트"
class="gallery-image"
data-flex-grow="113"
data-flex-basis="272px"
>&lt;/p>
&lt;p>다단계 색인을 사용하면 특정 값을 훨씬 빠르게 찾을 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_9.png"
width="1956"
height="322"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_9_hu9354600d37260ed8b8d530bf7b5a8225_24588_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_9_hu9354600d37260ed8b8d530bf7b5a8225_24588_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="5차 색인까지 사용하는 스킵 리스트"
class="gallery-image"
data-flex-grow="607"
data-flex-basis="1457px"
>&lt;/p>
&lt;p>데이터 양이 적을 때는 스킵 리스트의 속도 개선 효과가 분명하지 않지만, 5차 색인까지 사용하는 스킵 리스트를 예시로 들면 개선을 확인할 수 있다.&lt;/p>
&lt;p>기본 리스트만 있는 경우 찾는 노드에 도달하기 위해 62개의 노드를 거쳐야하지만, 스킵 리스트의 경우에는 11개의 노드만 통과하면 된다.&lt;/p>
&lt;p>정렬 집합은 삽입이나 갱신 연산을 할 때 모든 원소가 올바른 위치에 자동으로 배치되며 새 원소를 추가하거나 기존 원소를 검색하는 연산의 시간 복잡도가 &lt;code>O(log(n))&lt;/code>이므로 관계형 데이터베이스보다 성능이 좋다.&lt;/p>
&lt;p>관계형 데이터베이스에서 특정 사용자의 순위를 계산하려면 중첩 질의문을 수행해야한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">,(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COUNT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leaderboard&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lb2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lb2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lb1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RANK&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">leaderboard&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lb1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lb1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">{&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>레디스 정렬 집합을 사용한 구현&lt;/strong>&lt;/p>
&lt;p>순위표 구현에 사용할 레디스 연산들을 살펴본다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>ZADD&lt;/code>
&lt;ul>
&lt;li>기존에 없던 사용자를 집합에 추가한다.&lt;/li>
&lt;li>기존 사용자의 경우에는 점수를 업데이트한다.&lt;/li>
&lt;li>&lt;code>O(log(n))&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ZINCRBY&lt;/code>
&lt;ul>
&lt;li>사용자 점수를 지정된 값 만큼 증가시킨다.&lt;/li>
&lt;li>집합에 없는 사용자는 0점으로 가정한다.&lt;/li>
&lt;li>&lt;code>O(log(n))&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ZRANGE&lt;/code>/&lt;code>ZREVRANGE&lt;/code>
&lt;ul>
&lt;li>점수에 따라 정렬된 사용자 중 특정 범위에 드는 사용자들을 가져온다.&lt;/li>
&lt;li>순서, 항목 수, 시작 위치를 지정할 수 있다.&lt;/li>
&lt;li>&lt;code>O(log(n) + m)&lt;/code>
&lt;ul>
&lt;li>&lt;code>m&lt;/code>: 가져올 항목 수&lt;/li>
&lt;li>&lt;code>n&lt;/code>: 정렬 집합의 크기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ZRANK&lt;/code>/&lt;code>ZREVRANK&lt;/code>
&lt;ul>
&lt;li>오름차순/내림차순 정렬하였을 때 특정 사용자의 위치를 가져온다.&lt;/li>
&lt;li>&lt;code>O(log(n))&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;code>ZREVRANGE&lt;/code>는 향후 사용이 중단될 명령으로, &lt;code>ZRANGE&lt;/code> 명령에 추가 속성을 전달하면 같은 결과를 얻을 수 있다.&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>&lt;strong>사용자가 점수를 획득한 경우&lt;/strong>&lt;/p>
&lt;p>매 월 새로운 순위표를 위한 정렬 집합을 만들고 이전 순위표는 이력 데이터 저장소로 보낸다.&lt;/p>
&lt;p>사용자는 승리하면 점수를 얻은데, &lt;code>ZINCRBY&lt;/code>를 호출하여 사용자 점수를 증가시키거나 순위표 세트에 없는 경우 사용자를 순위표 집합에 추가한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZINCRBY leaderboard_feb_2021 1 &amp;#39;mary1934&amp;#39;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>사용자가 순위표 상위 10명을 조회하는 경우&lt;/strong>&lt;/p>
&lt;p>가장 높은 점수를 받은 사용자로부터 내림차순으로 정렬한 결과를 가져와야 하므로 &lt;code>ZREVRANGE&lt;/code>를 호출한다.&lt;/p>
&lt;p>사용자 목록뿐 아니라 각 사용자의 현재 점수도 가져와야 하므로 &lt;code>WITHSCORES&lt;/code> 속성도 전달한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZREVRANGE leaderboard_feb_2021 0 9 WITHSCORES
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>다음과 같은 목록이 반환된다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[(user2,score2),(user1,score1),(user5,score5)...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>사용자가 자기 순위를 조회하는 경우&lt;/strong>&lt;/p>
&lt;p>&lt;code>ZREVRANK&lt;/code>를 호출하면 특정 사용자의 순위를 가져올 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZREVRANGE leaderboard_feb_2021 357 365
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>특정 사용자 순위를 기준으로 일정 범위 내 사용자를 질의하는 경우&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_10.png"
width="1344"
height="1112"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_10_hucd013a2567009eacc82bc2b2f59fca18_84653_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_10_hucd013a2567009eacc82bc2b2f59fca18_84653_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="특정 사용자 직전 순위 사용자 4명, 직후 순위 사용자 4명"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="290px"
>&lt;/p>
&lt;p>&lt;code>ZREVRANGE&lt;/code>를 활용하면 특정한 사용자 전/후 순위 사용자 목록을 얻어낼 수 있다.&lt;/p>
&lt;p>&lt;code>Mallow007&lt;/code>의 사용자가 361등이고, 전 후로 4명씩 조회한다면&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ZREVRANGE leaderboard_feb_2021 357 365
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="저장소-요구사항">저장소 요구사항&lt;/h3>
&lt;p>최소한 &lt;code>사용자 ID&lt;/code>와 &lt;code>점수&lt;/code>는 저장해야 한다.&lt;/p>
&lt;p>최악의 시나리오는 월간 활성 사용자 2,500만 명 모두가 최소 한 번 이상 게임에서 승리하는 바람에 모두 월 순위표에 올라야 하는 경우이다.&lt;/p>
&lt;ul>
&lt;li>ID: 24자 문자열&lt;/li>
&lt;li>점수: 16비트 정수&lt;/li>
&lt;li>순위표 한 항목당 26바이트 필요&lt;/li>
&lt;li>MAU 순위표 항목이 하나라는 최악의 시나리오를 가정하면 &lt;code>26바이트 * 2,500만 = 650MB&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>이 정도라면 스킵 리스트 구현에 필요한 오베헤드와 정렬 집합 해시를 고려해 메모리 사용량을 두 배로 늘린다고 해도 최신 레디스 서버 한 대만으로도 데이터를 충분히 저장할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>CPU 및 I/O 사용량&lt;/strong>&lt;/p>
&lt;p>개략적인 추정치에 따르면 갱신 연산의 최대 QPS는 2500/초 정도로 레디스 서버로도 충분히 감당할 수 있는 부하이다.&lt;/p>
&lt;p>하지만 레디스 노드에 장애 발생으로 인한 영속성을 고려해야한다.&lt;/p>
&lt;p>레디스는 데이터를 디스크에 영속적으로 보관하는 옵션도 지원하나, 디스크에서 데이터를 읽어 대규모 레디스 인스턴스를 재시작하려면 시간이 많이 걸린다.&lt;/p>
&lt;ul>
&lt;li>그래서 보통은 레디스에 읽기 사본을 두는 방식으로 구성한다.&lt;/li>
&lt;/ul>
&lt;p>MySQL과 같은 관계형 데이터베이스를 사용하는 경우에는 사용자와 점수 테이블이 필요하다.&lt;/p>
&lt;p>점수 테이블에는 사용자 ID, 점수, 게임에서 승리한 시각(타임스템프)를 저장하여 경연 기록 등과 같은 다른 게임 기능 구현에 활용될 수 있고, 인프라 장애 발생 시 레디스 순위표를 복구하는 데에도 활용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>가장 자주 검색되는 상위 10명의 사용자 정보를 캐시하면 쉽게 성능을 최적화 할 수 있다.&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="클라우드-서비스-사용-여부">클라우드 서비스 사용 여부&lt;/h3>
&lt;p>솔루션 배포 방식은 기존 인프라 구성 형태에 따라 일반적으로 두 가지로 나눌 수 있다.&lt;/p>
&lt;h4 id="자체-서비스-사용">자체 서비스 사용&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_11.png"
width="1836"
height="770"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_11_huc99aadd03e637796689cc9fe1c2d43ef_172903_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_11_huc99aadd03e637796689cc9fe1c2d43ef_172903_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="자체 서버스를 이용하는 방안"
class="gallery-image"
data-flex-grow="238"
data-flex-basis="572px"
>&lt;/p>
&lt;ul>
&lt;li>매월 정렬 집합을 생성하여 사용자 및 점수 정보를 이용해 해당 기간의 순위표를 저장한다.&lt;/li>
&lt;li>이름 및 프로필 이미지와 같은 사용자 세부 정보는 MySQL 데이터베이스에 저장한다.&lt;/li>
&lt;/ul>
&lt;p>순위표를 가져올 때 API 서버는 순위 데이터와 더불어 데이터베이스에 저장된 사용자 이름과 프로필 이미지도 가져온다.&lt;/p>
&lt;ul>
&lt;li>이 작업이 장기적으로 너무 비효율적이면 상위 사용자 10명의 세부 정보를 저장하는 프로필 캐시를 두어 해결할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="클라우드-서비스-이용">클라우드 서비스 이용&lt;/h4>
&lt;blockquote>
&lt;p>기존 인프라가 AWS에 있어 클라우드로 순위표를 구축하는 것이 자연스러운 상황이라 가정한다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>아마존 API 게이트웨이&lt;/strong>와 &lt;strong>AWS 람다&lt;/strong>(Lambda) 두 가지를 활용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>API 게이트웨이를 사용하면 RESTful API의 HTTP 엔드포인트를 정의하고 아무 백엔드 서비스에나 연결할 수 있다.&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>람다 함수&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>GET /v1/scores&lt;/code>&lt;/td>
&lt;td>&lt;code>LeaderboardFetchTop10&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>GET /v1/scores/{:user_id}&lt;/code>&lt;/td>
&lt;td>&lt;code>LeaderboardFetchPlayerRank&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>GET /v1/scores&lt;/code>&lt;/td>
&lt;td>&lt;code>LeaderboardUpdateScores&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>&lt;strong>AWS 람다&lt;/strong>&lt;br>
가장 인기있는 서버리스 컴퓨팅 플랫폼 중 하나로 서버를 직접 준비하거나 관리할 필요 없이 코드를 실행할 수 있다.&lt;br>
람다는 필요할 때만 실행되며 트래픽에 따라 규모가 자동으로 확장된다.&lt;/p>
&lt;/blockquote>
&lt;p>개략적으로 설명하면&lt;/p>
&lt;ol>
&lt;li>API 게이트웨이를 호출&lt;/li>
&lt;li>게이트웨이는 적절한 람다 함수를 호출&lt;/li>
&lt;li>스토리지 계층(레디스 및 MySQL)의 명령을 호출하여 얻은 결과를 API 게이트웨이에 반환&lt;/li>
&lt;li>API 게이트웨이는 그 결과를 애플리케이션에 전달&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>람다 함수를 사용하면 서버 인스턴스를 만들지 않아도 질의를 실행할 수 있다.
&lt;ul>
&lt;li>레디스를 호출할 수 있도록 하는 클라이언트를 제공한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>람다를 사용하면 DAU 성장세에 맞춰 자동으로 서비스 규모를 확장할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>점수 획득&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_12.png"
width="1978"
height="496"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_12_hua00e417a6ce8d46751065c258b5a49fc_148407_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_12_hua00e417a6ce8d46751065c258b5a49fc_148407_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="점수 획득"
class="gallery-image"
data-flex-grow="398"
data-flex-basis="957px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>순위 검색&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_13.png"
width="1964"
height="506"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_13_hud870a85155701f522546b2affcdafcf0_158178_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_13_hud870a85155701f522546b2affcdafcf0_158178_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="순위 검색"
class="gallery-image"
data-flex-grow="388"
data-flex-basis="931px"
>&lt;/p>
&lt;hr>
&lt;p>람다는 서비리스 접근 방식이라 인프라의 규모가 필요에 맞게 자동으로 확장되며, 환경 설정, 유지 보수 등의 문제를 직접 관리할 필요가 없다.&lt;/p>
&lt;h3 id="레디스-규모-확장">레디스 규모 확장&lt;/h3>
&lt;p>5백만 DAU 정도라면 한 대의 레디스 캐시 서버로도 충분히 지원 가능하나, 원래 규모의 100배인 5억 DAU를 처리해야한다면 규모 확장이 필요하다.&lt;/p>
&lt;ul>
&lt;li>저장 용량은 65GB&lt;/li>
&lt;li>250,000 QPS 처리&lt;/li>
&lt;/ul>
&lt;p>이 정도 규모를 감당하려면 샤딩이 필요하다.&lt;/p>
&lt;h4 id="데이터-샤딩-방안">데이터 샤딩 방안&lt;/h4>
&lt;p>고정 파티션과 해시 파티션 방식을 고려할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>고정 파티션&lt;/strong>&lt;/p>
&lt;p>순위표에 등장하는 점수의 범위에 따라 파티션을 나누는 방안이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_14.png"
width="1856"
height="206"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_14_hu7658f9e716ce647a0256027405e30bb0_20879_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_14_hu7658f9e716ce647a0256027405e30bb0_20879_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="고정 파티션"
class="gallery-image"
data-flex-grow="900"
data-flex-basis="2162px"
>&lt;/p>
&lt;ul>
&lt;li>획득할 수 있는 점수가 1~1000 이라면 데이터를 범위별로 나눈다.&lt;/li>
&lt;li>(1~100), (101~200) &amp;hellip;, (901, 1000)&lt;/li>
&lt;/ul>
&lt;p>이 기능이 제대로 작동하려면 순위표 전반에 점수가 고르게 분포되어야 하며, 그렇지 않다면 각 샤드에 할당되는 점수 범위를 조정하여 비교적 고른 분포가 되도록 해야한다.&lt;/p>
&lt;hr>
&lt;p>애플리케이션이 샤딩 처리의 추제라면 특정 사용자의 점수를 입력하거나 갱신할 때 해당 사용자가 어느 샤드에 있는지 알아야 한다.&lt;/p>
&lt;ul>
&lt;li>MySQL 질의로 사용자의 현재 점수를 계산하여 알아낼 수도 있다.&lt;/li>
&lt;li>사용자 ID와 점수 사이의 관계를 저장하는 2차 캐시를 활용하면 성능을 더 높일 수 있다.&lt;/li>
&lt;/ul>
&lt;p>사용자의 점수가 높아져서 다른 샤드로 옮겨야 할 때는 기존 샤드에서 해당 사용자를 제거한 다음 새 샤드로 옮겨야 한다.&lt;/p>
&lt;hr>
&lt;p>순위표에서 상위 10명의 플레이어를 가져오려면, 가장 높은 점수가 저장되는 샤드에서 상위 10명을 가져온다.&lt;/p>
&lt;p>특정 사용자의 순위를 알려면 해당 사용자가 속한 샤드 내 순위뿐 아니라 해당 샤드보다 높은 점수를 커버하는 모든 샤드의 모든 사용자 수를 알아야 한다.&lt;/p>
&lt;ul>
&lt;li>특정 샤드에 속한 모든 사용자 수는 &lt;code>info keyspace&lt;/code> 명령을 통해 &lt;code>O(1)&lt;/code>시간에 알아낼 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>해시 파티션&lt;/strong>&lt;/p>
&lt;p>레디스 클러스터를 사용하는 방법으로 사용자들의 점수가 특정 대역에 과도하게 모여있는 경우 효과적이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_15.png"
width="1694"
height="1344"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_15_huf77687aca255ea1376fddaaa280306c9_415936_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_15_huf77687aca255ea1376fddaaa280306c9_415936_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="해시 파티션"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="302px"
>&lt;/p>
&lt;blockquote>
&lt;p>레디스 클러스터&lt;br>
안정 해시는 사용하지 않지만 각 키가 특정한 해시 슬롯에 속하도록 하는 샤딩 기법을 사용한다.&lt;/p>
&lt;ul>
&lt;li>총 16384개 해시 슬롯이 있으며, &lt;code>CRC16(key) % 16384&lt;/code>의 연산을 수행하여 어떤 키가 어느 슬롯에 속하는지 계산한다.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>모든 키를 재분배하지 않아도 클러스터에 쉽게 노드를 추가하거나 제거할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>점수 갱신&lt;/strong>&lt;br>
점수를 갱신하려면 해당 사용자의 샤드를 찾아(&lt;code>CRC16(key) % 16394&lt;/code>) 해당 사용자의 점수를 변경한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>상위 10명 플레이어 검색&lt;/strong>&lt;/p>
&lt;p>모든 샤드에서 상위 10명을 받아 애플리케이션 내에서 다시 정렬하는 &lt;strong>분산-수집&lt;/strong>(scatter-gather) 접근법을 사용해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_16.png"
width="1460"
height="1388"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_16_hu1e8e084fe62cd2c4275cacc14a07a2eb_271118_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_16_hu1e8e084fe62cd2c4275cacc14a07a2eb_271118_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="분산-수집 방안"
class="gallery-image"
data-flex-grow="105"
data-flex-basis="252px"
>&lt;/p>
&lt;p>모든 샤드에 사용자를 질의하는 절차를 병렬화하면 지연 시간을 줄일수 있지만 다음과 같은 문제가 있다.&lt;/p>
&lt;ul>
&lt;li>상위 k개의 결과를 반환해야 하는 경우(k는 매우 큰 값) 각 샤드에서 많은 데이터를 읽고 정렬해야 하므로 지연 시간이 늘어난다.&lt;/li>
&lt;li>가장 느린 파티션에서 데이터를 다 읽고 나서야 질의 결과를 계산할 수 있으므로 지연 시간이 길어진다.&lt;/li>
&lt;li>특정 사용자의 순위를 결정할 간단한 방법이 없다.&lt;/li>
&lt;/ul>
&lt;p>따라서 고정 파티션 방안을 활용한다.&lt;/p>
&lt;h4 id="레디스-노드-크기-조정">&lt;strong>레디스 노드 크기 조정&lt;/strong>&lt;/h4>
&lt;p>레디스 노드의 크기를 조정할 때 여러가지를 고려해야한다.&lt;/p>
&lt;p>쓰기 작업이 많은 애플리케이션에서는 장애에 대비해 스냇숏을 생성할 때 필요한 모든 쓰기 연산을 감당할 수 있어야 하므로 많은 메모리가 필요하다.&lt;/p>
&lt;ul>
&lt;li>메모리를 두 배 더 할당하는 것이 안전하다.&lt;/li>
&lt;/ul>
&lt;p>레디스는 성능 밴체마킹을 위해 &lt;code>redis-benchmark&lt;/code>라는 도구를 제공하므로, 여러 클라이언트가 동시에 여러 질의를 실행하는 것을 실뮬레이션하여 주어진 하드웨어로 초당 얼마나 많은 요청을 처리할 수 있는지 측정할 수 있다.&lt;/p>
&lt;h4 id="대안-nosql">대안: NoSQL&lt;/h4>
&lt;p>NoSQL 데이터베이스를 다른 솔루션으로 고려할 수 있으며, 다음과 같은 데이터베이스가 이상적이다.&lt;/p>
&lt;ul>
&lt;li>쓰기 연산에 최적화&lt;/li>
&lt;li>같은 파티션 내의 항목을 점수에 따라 효율적으로 정렬 가능&lt;/li>
&lt;/ul>
&lt;p>아마존 DynamoDB, 카산드라, MongoDB 등을 고려할 수 있는데, DynamoDB를 예시로 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_17.png"
width="1344"
height="286"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_17_huc61d6265b699516ef39c14922102b774_97876_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_17_huc61d6265b699516ef39c14922102b774_97876_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="DynamoDB 기반 솔루션"
class="gallery-image"
data-flex-grow="469"
data-flex-basis="1127px"
>&lt;/p>
&lt;blockquote>
&lt;p>DynamoDB&lt;br>
안정적인 성능과 뛰어난 확장성을 제공하는 완전 관리형 NoSQL 데이터베이스로, 기본키 이외의 속성을 활용하여 데이터를 효과적으로 질의할 수 있도록, 전역 보조 색인을 제공한다.&lt;/p>
&lt;/blockquote>
&lt;p>전역 보조 색인은 부모 테이블의 속성들로 구성되지만 기본 키는 부모 테이블과는 다르다.&lt;/p>
&lt;hr>
&lt;p>체스 게임의 순위표를 설계하고, 데이터베이스 테이블은 순위표와 사용자 테이블을 비정규화 한 것으로 순위표를 화면에 표시하는 데 필요한 모든 정보를 담고 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_18.png"
width="1452"
height="532"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_18_hu9da5772d01231304c597cd3dfad33994_246694_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_18_hu9da5772d01231304c597cd3dfad33994_246694_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="순위표 및 사용자 테이블의 비정규화"
class="gallery-image"
data-flex-grow="272"
data-flex-basis="655px"
>&lt;/p>
&lt;p>이 방안은 레코드가 많아지면 상위 점수를 찾기 위해 전체 테이블을 뒤져야 하므로 사용자가 많아지면 성능이 떨어져 규모 확장이 어렵다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_19.png"
width="1464"
height="614"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_19_hua32ae9c65839c9e9bdba8742ab5270bb_257414_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_19_hua32ae9c65839c9e9bdba8742ab5270bb_257414_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="파티션 키 및 정렬 키"
class="gallery-image"
data-flex-grow="238"
data-flex-basis="572px"
>&lt;/p>
&lt;p>위와 같이 &lt;code>game_name#{year-month}&lt;/code>를 파티션 키로, 점수를 정렬 키로 사용하면 테이블 전체를 읽어야 하는 일을 피할 수 있지만, 부하가 높을 때 문제가 발생한다.&lt;/p>
&lt;p>DynamoDB는 안정 해시를 사용하여 여러 노드에 데이터를 분산하는데, 각 항목이 파티션 키에 따라 선정된 노드에 저장된다.&lt;/p>
&lt;p>위와 같이 테이블을 설계하면 가장 최근 한 달치 데이터가 동일한 파티션에 저장될 뿐 아니라 핫 파티션이 되고 만다.&lt;/p>
&lt;p>따라서 데이터를 n개 파티션으로 분할하고 파티션 번호(&lt;code>user_id % number_of_partitinons&lt;/code>)를 파티션 키에 추가하는 &lt;strong>쓰기 샤딩&lt;/strong>이라고 부르틑 패턴을 활용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>하지만 읽기 및 쓰기 작업 모두를 복잡하게 만드므로, 장단점을 꼼꼼히 따져봐야 한다.&lt;/li>
&lt;/ul>
&lt;p>쓰기 볼륨 또는 DAU를 기준으로 파티션의 수를 결정할 수 있으나 파티션이 받는 부하와 읽기 복잡도 사이에는 타협적인 부분이 있다.&lt;/p>
&lt;ul>
&lt;li>같은 달 데이터를 여러 파티션에 고르게 분산시키면 한 파티션이 받는 부하는 낮아짐&lt;/li>
&lt;li>특정한 달의 데이터를 읽으려고 하면 모든 파티션을 질의한 결과를 합쳐야 하므로 구현은 복잡해짐&lt;/li>
&lt;/ul>
&lt;p>파티션 키는 &lt;code>game#{year-moth}#p{partition_number}&lt;/code>와 같이 지정할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_20.png"
width="1450"
height="598"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_20_hu3a0e87c0bef2264457ba3bd9686d164f_269843_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_20_hu3a0e87c0bef2264457ba3bd9686d164f_269843_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="새로운 파티션 키"
class="gallery-image"
data-flex-grow="242"
data-flex-basis="581px"
>&lt;/p>
&lt;p>전역 보조 색인은 &lt;code>game#{year-moth}#p{partition_number}&lt;/code>를 파티션 키로, 점수를 정렬 키로 사용하게 구성한다.&lt;/p>
&lt;ul>
&lt;li>같은 파티션 내 데이터는 전부 점수 기준으로 정렬된 n개의 파티션이 만들어진다.&lt;/li>
&lt;/ul>
&lt;p>3개 파티션이 있다고 했을 때 상위 10명의 사용자를 가져오려면 &lt;strong>분산-수집&lt;/strong> 접근법을 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/10/img_21.png"
width="1744"
height="1284"
srcset="https://codemario318.github.io/post/system-design-interview-2/10/img_21_hu7ef60b94fc6260de3accc6dec63a7cc1_363372_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/10/img_21_hu7ef60b94fc6260de3accc6dec63a7cc1_363372_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="분산 수집"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="325px"
>&lt;/p>
&lt;p>파티션 수는 신중한 벤치마킹이 필요할 수 있다.&lt;/p>
&lt;ul>
&lt;li>파티션이 많으면 각 파티션의 부하는 줄지만 최종 순위표를 만들기 위해 읽어야 하는 파티션은 더 많으므로 복잡성은 증가&lt;/li>
&lt;/ul>
&lt;p>그러나 앞서 언급한 레디스 파티션 기법과 마찬가지로, 사용자의 상대적 순위를 쉽게 정할 수 없다.&lt;/p>
&lt;p>하지만 사용자의 위치의 백분위수를 구하는 것은 가능하며, 충분히 괜찮은 방법일 수 있다.&lt;/p>
&lt;ul>
&lt;li>ex) 상위 10~20%에 속함&lt;/li>
&lt;li>규모가 충분히 커서 샤딩이 필요한 상황이라면 모든 샤드의 점수 분포는 거의 같다고 가정할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이 가정이 사실이라면 각 샤드의 점수 분포를 분석한 결과를 캐시하는 크론 작업을 만들어 볼 수도 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">10th percentile = score &amp;lt; 100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">20th percentile = score &amp;lt; 500
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">90th percentile = score &amp;lt; 6500
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이를 통해 사용자의 상대적 순위를 빠르게 계산할 수 있다.&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>이번 장에서는 수백만 DAU 규모의 실시간 게임 순위표를 구축하기 위한 솔루션을 설계해 보았다.&lt;/p>
&lt;ul>
&lt;li>MySQL 데이터베이스를 사용하는 간단한 솔루션부터 검토하여, 정렬 집합을 사용하여 순위표를 구현하기로 했다.&lt;/li>
&lt;li>여러 레디스 캐시에 데이터르 샤딩하여 5억 DAU도 지언할 수 있도록 규모를 확장하는 방안도 살펴보았다.&lt;/li>
&lt;li>대안으로 NoSQL 데이터베이스를 이용하는 방법도 살펴보았다.&lt;/li>
&lt;/ul>
&lt;p>시간이 남는다면 아래와 같은 주제도 살펴볼 수 있을것이다.&lt;/p>
&lt;h3 id="더-빠른-조회-및-동점자-순위-판정">더 빠른 조회 및 동점자 순위 판정&lt;/h3>
&lt;p>레디스 해시를 사용하면 문자열 필드와 값 사이의 대응 관계를 저장해 둘 수 있으며 아래와 같이 활용할 수 있다.&lt;/p>
&lt;ul>
&lt;li>순위표에 표시할 사용자 ID와 사용자 객체 사이의 대응 관계를 저장하여 데이터베이스 질의를 줄일 수 있다.&lt;/li>
&lt;li>동점자는 누가 먼저 점수를 받았는지에 따라 순위를 정할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="시스템-장애-복구">시스템 장애 복구&lt;/h3>
&lt;p>레디스 클러스터에도 대규모 장애는 발생할 수 있다.&lt;/p>
&lt;p>지금까지 살펴본 설계안에서는 사용자가 게임에서 이길 때마다 MySQL 데이터베이스에 타임 스탬프와 함께 저장하므로, 이를 활용한 스크립트를 만들어 간단히 복구할 수 있다.&lt;/p>
&lt;ul>
&lt;li>사용자별로 모든 레코드를 훑으며 레코드당 한 번씩 &lt;code>ZINFRBY&lt;/code>를 호출&lt;/li>
&lt;/ul></description></item></channel></rss>