<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>소프트웨어 아키텍처 on Mario Blog</title><link>https://codemario318.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</link><description>Recent content in 소프트웨어 아키텍처 on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Thu, 04 Apr 2024 09:16:13 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/index.xml" rel="self" type="application/rss+xml"/><item><title>25. 계층과 경계</title><link>https://codemario318.github.io/post/clean-architecture/25/</link><pubDate>Thu, 04 Apr 2024 09:16:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/25/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/25/cover.png" alt="Featured image of post 25. 계층과 경계" />&lt;p>단순한 시스템에서는 UI, 업무 규칙, 데이터베이스 컴포넌트만으로도 충분하지만, 대다수의 시스템에서 컴포넌트의 개수는 이보다 훨씬 많다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>아키텍처 경계는 어디에나 존재하며, 아키텍트는 아키텍처 경계가 언제 필요한지를 신중하게 파악해내야한다.&lt;/p>
&lt;p>이러한 경계를 제대로 구현하는 비용은 크며, 경계가 무시되었다면 나중에 다시 추가하는 비용도 매우 크다.&lt;/p>
&lt;p>오버 엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많으므로 XP의 원칙인 &lt;strong>YAGNI&lt;/strong>가 말하는 것 처럼 추상화가 필요하리라고 미리 예측해서는 안 된다.&lt;/p>
&lt;p>하지만, 경계가 존재하지 않는 상황에서 경계가 필요하다는 것을 깨닳고 추가하려면 비용이 매우 많이 들고 큰 위험을 감수해야한다.&lt;/p>
&lt;hr>
&lt;p>이처럼 소프트웨어 아키텍트는 여러 상황들을 적절히 고려하여 소프트웨어가 어떻게 발전할지 예측해야한다.&lt;/p>
&lt;p>이를 통해 완벽하게 구현할 경계와 부분적으로 구현할 경계, 무시할 경계가 무엇인지 결정해야만 한다.&lt;/p>
&lt;p>그렇지만 프로젝트 초반에는 경계를 쉽게 결정할 수 없기 때문에 한번에 정해지는 것은 아니므로, 시스템이 발전함에 따라 주의를 기울여야한다.&lt;/p>
&lt;ul>
&lt;li>경계가 필요할 수 있는 부분에 주목한다.&lt;/li>
&lt;li>경계가 존재하지 않아 생기는 마찰의 첫 조짐을 신중하게 관찰한다.
&lt;ul>
&lt;li>경계를 구현하는 비용가 무시할 때 감수할 비용을 가늠해본다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>결정된 사항을 자주 검토한다.&lt;/li>
&lt;/ul>
&lt;p>경계의 구현 비용이 그것을 무시하여 생기는 비용보다 적어지는 시점에 경계를 구현해야하며, 적절한 시점에 경계를 구현하기 위해 빈틈없이 지켜봐야한다.&lt;/p></description></item><item><title>24. 부분적 경계</title><link>https://codemario318.github.io/post/clean-architecture/24/</link><pubDate>Thu, 04 Apr 2024 08:49:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/24/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/24/cover.png" alt="Featured image of post 24. 부분적 경계" />&lt;p>아키텍처 경계를 완벽하게 만드는 데는 엄청난 노력을 기율여야 하고, 유지하는 데도 엄청난 노력이 든다.&lt;/p>
&lt;ul>
&lt;li>쌍방향의 다형적 &lt;code>Boundary&lt;/code> 인터페이스&lt;/li>
&lt;li>&lt;code>Input&lt;/code>, &lt;code>Output&lt;/code>을 위한 데이터 구조&lt;/li>
&lt;li>두 영역을 독립적으로 컴파일하고 배포할 수 있는 컴포넌트로 젹리하는 데 필요한 모든 의존성 관리&lt;/li>
&lt;/ul>
&lt;p>많은 경우에 이러한 경계를 만드는 비용이 크다고 판단하면서도, 필요한 작업만 해야한다는 XP 원칙인 &lt;strong>YAGNI&lt;/strong>(You Aren&amp;rsquo;t going to Need It)을 위배하며 나중에 필요할 것이라 예상대는 것들에 대한 대비하길 원한다.&lt;/p>
&lt;p>이렇게 필요할 것으로 예상되는 것을 꼭 대비해야 한다면 완벽한 경계가 아닌 &lt;strong>부분적 경계&lt;/strong>(Patial boundary)를 활용해 볼 수 있다.&lt;/p>
&lt;h2 id="마지막-단계를-건너-뛰기">마지막 단계를 건너 뛰기&lt;/h2>
&lt;p>독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 방법이다.&lt;/p>
&lt;p>&lt;strong>장점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>다수의 컴포넌트를 관리하는 작업을 하지 않아도 된다.&lt;/li>
&lt;li>추적을 위한 버전 번호도 필요없다.&lt;/li>
&lt;li>배포 관리 부담이 없다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>단점&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>부분적 경계를 만들기 위해 완벽한 경계를 만들 때 만큼의 코드량과 사전 설계가 필요하다.&lt;/li>
&lt;li>시간이 흐르며 별도로 분리한 컴포넌트가 재사용될 가능성이 전혀 없을 것임이 명백해지는 경우가 있다.&lt;/li>
&lt;li>시간이 흐르며 컴포넌트 사이의 구분이 점점 약화된다.&lt;/li>
&lt;/ul>
&lt;h2 id="일차원-경계">일차원 경계&lt;/h2>
&lt;p>완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 &lt;code>Boundary&lt;/code> 인터페이스를 사용하는데, 이러한 형태는 초기 설정할 때나 지속적으로 유지할 때도 비용이 많이 든다.&lt;/p>
&lt;p>이러한 경우 추후 완벽한 형태의 경계로 확장할 수 있는 공간을 확보하고자 할 때, 전통적인 전략 패턴을 사용하여 간단한 구조를 활용해 볼 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/24/img.png"
width="720"
height="292"
srcset="https://codemario318.github.io/post/clean-architecture/24/img_huf66003e0682ccdb8f85feab7e684d52d_81657_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/24/img_huf66003e0682ccdb8f85feab7e684d52d_81657_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="246"
data-flex-basis="591px"
>&lt;/p>
&lt;p>&lt;code>Client&lt;/code>를 &lt;code>ServiceImpl&lt;/code>로 부터 격리시키는 데 필요한 의존성 역전이 적용되었기 때문에 미래에 필요한 아키텍처 경계를 대비할 수 있다.&lt;/p>
&lt;p>하지만 이러한 형태의 분리는 쌍방향 인터페이스가 없고 개발자와 아키텍트의 능력에 따라, 점선과 같은 비밀 통로가 생기는 일을 막을 방법이 없다.&lt;/p>
&lt;h2 id="퍼사드">퍼사드&lt;/h2>
&lt;p>더 단순한 경계는 퍼사드 패턴으로, 이 경우에는 의존성 역전까지 희생한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/24/img_1.png"
width="720"
height="299"
srcset="https://codemario318.github.io/post/clean-architecture/24/img_1_huda7c855c7c3463c0aff875896060fffa_46486_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/24/img_1_huda7c855c7c3463c0aff875896060fffa_46486_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="240"
data-flex-basis="577px"
>&lt;/p>
&lt;p>경계는 &lt;code>Facade&lt;/code> 클래스로만 간단히 전의되며, 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 서비스 클래스로 호출을 전달한다.&lt;/p>
&lt;p>클라이언트는 서비스 클래스에 직접 접근할 수 없지만, &lt;code>Client&lt;/code>가 이 모든 서비스 클래스에 대해 추이 종속성을 가지게 되었다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>아키텍처 경계를 부분적으로 구현하는 방법은 많다.&lt;/p>
&lt;p>이러한 접근법은 각각 나름의 비용과 장점을 지니며, 완벽한 형태의 경계를 담기 위한 공간으로써, 적절하게 사용할 수 있는 상황이 서로 다르다.&lt;/p>
&lt;p>또한 추후에 완벽한 형태의 경계가 실제로 구체회되지 않으면 가치가 떨어질 수 있다.&lt;/p></description></item><item><title>23. 프레젠터와 험블 객체</title><link>https://codemario318.github.io/post/clean-architecture/23/</link><pubDate>Wed, 03 Apr 2024 22:31:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/23/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/23/cover.png" alt="Featured image of post 23. 프레젠터와 험블 객체" />&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/23/img.png"
width="772"
height="567"
srcset="https://codemario318.github.io/post/clean-architecture/23/img_hudd764f775c86d6d6fb1802d465c14dac_405598_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/23/img_hudd764f775c86d6d6fb1802d465c14dac_405598_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="326px"
>&lt;/p>
&lt;p>프레젠터는 험블 객체(Humble Object) 패턴을 따른 형태로, 아키텍처 경계를 식별하고 보호하는 데 도움이 된다.&lt;/p>
&lt;h2 id="험블-객체-패턴">험블 객체 패턴&lt;/h2>
&lt;p>험블 객체 패턴은 디자인 패턴으로, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.&lt;/p>
&lt;ul>
&lt;li>행위들을 두 개의 모듈 또는 클래스로 나눈다.&lt;/li>
&lt;li>가장 기본적인 본질은 남기고, 테스트하기 어려운 행우를 모두 험블 객체로 옮긴다.&lt;/li>
&lt;li>나머지 모듈에는 험블 객체에 속하지 않은, 테스트하기 쉬운 행위를 모두 옮긴다.&lt;/li>
&lt;/ul>
&lt;p>GUI는 화면에서 각 요소가 필요한 위치에 적절히 표시되었는지 테스트 해야하므로 작성하기 어려운 반면, GUI에서 수행하는 행위의 대다수는 쉽게 테스트할 수 있다.&lt;/p>
&lt;p>험블 객체 패턴을 사용하면 두 부류의 행위를 분리하여 프레젠터와 뷰라는 서로 다른 클래스로 만들 수 있다.&lt;/p>
&lt;h2 id="프레젠터와-뷰">프레젠터와 뷰&lt;/h2>
&lt;p>&lt;strong>뷰&lt;/strong>&lt;br>
뷰는 데이터를 GUI로 이동시키지만, 데이터를 직접 처리하지는 않는다.&lt;/p>
&lt;ul>
&lt;li>험블 객체이고 테스트하기 어렵다.&lt;/li>
&lt;li>포함된 코드를 가능한 간단하게 유지한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>프레젠터&lt;/strong>&lt;br>
애플리케이션으로 부터 데이터를 받아 화면에 표현할 수 있는 포멧으로 만든다.&lt;/p>
&lt;ul>
&lt;li>뷰가 데이터를 받아 화면에 전달하는 간단한 일만 처리하도록 만들어준다.&lt;/li>
&lt;li>테스트하기 쉬워진다.&lt;/li>
&lt;/ul>
&lt;p>뷰는 뷰 모델의 데이터를 화면으로 로드할 뿐이며, 이 외에 뷰가 밭은 역할은 전혀 없기 때문에 뷰는 보잘것없다(Humble)&lt;/p>
&lt;h2 id="테스트와-아키텍처">테스트와 아키텍처&lt;/h2>
&lt;p>테스트 용이성은 좋은 아키텍처가 지녀야 할 속성으로 오랫동안 알려저 왔다.&lt;/p>
&lt;p>험블 객체 패턴은 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하여 아키텍처 경계를 정의하므로 테스트가 용이하다.&lt;/p>
&lt;p>즉, 아키텍처에 험블 객체 패턴을 적절히 활용하면 프레젠터와 뷰와 같이 테스트드가 용이한 구조를 만들 수 있다.&lt;/p>
&lt;h2 id="데이터베이스-게이트웨이">데이터베이스 게이트웨이&lt;/h2>
&lt;p>유스케이스 인터랙터와 데이터베이스 사이에는 데이터베이스 게이트웨이(데이터베이스의 쿼리를 처리하는 모든 메서드가 포함)가 위치한다.&lt;/p>
&lt;p>유스케이스 레이어는 SQL을 허용하지 않아야 하므로 필요한 메서드를 제공하는 게이트웨이 인터페이스를 호출하게 되는데, 이 때 데이터베이스 레이어에 존재하는 인터페이스의 구현체가 험블 객체이다.&lt;/p>
&lt;p>이와 달리 인터랙터는 애플리케이션에 특화된 업무 규칙을 캡슐화화기 때문에 험블 객체가 아니므로 게이트웨이는 가짜 데이터(Mock, stub, test-double, fake)를 통해서도 테스트를 할 수 있기 때문에 테스트하기 쉬워진다.&lt;/p>
&lt;h2 id="데이터-매퍼">데이터 매퍼&lt;/h2>
&lt;p>하이버네이트와 같은 ORM은 어느 계층에 속하는가?&lt;/p>
&lt;p>객체는 데이터 구조가 아니기 때문에, 사실 객체 관계 매퍼(Object Relational Model, ORM)같은 건 사실 존재하지 않는다.&lt;/p>
&lt;p>객체를 사용하는 관점에서 공개된 메서드만 볼 수 있으므로, 단순히 오퍼레이션의 집합이다.&lt;/p>
&lt;p>객체와 달리 데이터 구조는 함축된 행위를 가지지 않는 공개된 변수의 집합이고 사용되는 ORM은 관계형 데이터베이스 테이블로부터 가져온 데이터를 데이터 구조에 맞게 담아주는 역할을 수행하므로 사실 데이터 매퍼이다.&lt;/p>
&lt;p>이러한 ORM 시스템은 데이터베이스 레이어에 위치하며 게이트웨이 인터페이스와 데이터베이스 사이의 일종에 또 다른 험블 객체 경계를 형성한다.&lt;/p>
&lt;h2 id="서비스-리스너">서비스 리스너&lt;/h2>
&lt;p>서비스에서도 험블 객체 패턴을 발견할 수 있다.&lt;/p>
&lt;p>애플리케이션은 데이터를 간단한 데이터 구조 형태로 로드한 후, 이 데이터 구조를 경계를 거슬러 특정 모듈로 전달하고, 데이터 구조를 전달받은 모듈이 적절한 포맷으로 만들어 외부 서비스로 전송하게 된다.&lt;/p>
&lt;p>외부로부터 데이터를 수신하는 서비스는 서비스 리스너가 서비스 인터페이스로부터 데이터를 수신하고, 데이터를 애플리케이션에서 사용할 수 있게 간단한 데이터 구조로 포맷을 변경하여 서비스 경계를 가로질러 내부로 전달된다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>아키텍처 경계마다 험블 객체 패턴을 발견할 수 있다.&lt;/p>
&lt;p>경계를 넘나드는 통신은 거의 모두 간단한 데이터 구조를 수반할 때가 많고, 대개 그 경계는 테스트하기 어려운 무언가와 테스트하기 쉬운 무언가로 분리된다.&lt;/p>
&lt;p>이러한 아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다.&lt;/p></description></item><item><title>22. 클린 아키텍처</title><link>https://codemario318.github.io/post/clean-architecture/22/</link><pubDate>Wed, 03 Apr 2024 16:22:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/22/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/22/cover.png" alt="Featured image of post 22. 클린 아키텍처" />&lt;ul>
&lt;li>육각형 아키텍처(Hexagonal Architecture)&lt;/li>
&lt;li>DCI(Data, Context and Interaction)&lt;/li>
&lt;li>BCE(Boundary-Control-Entity)&lt;/li>
&lt;/ul>
&lt;p>위와 같은 아키텍처들의 목적은 &lt;strong>관심사의 분리&lt;/strong>(Separation of concerns)이다.&lt;/p>
&lt;p>소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성할 수 있었다.&lt;/p>
&lt;p>각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함하며, 시스템이 다음과 같은 특징을 가지도록 만든다.&lt;/p>
&lt;ul>
&lt;li>프레임워크 독립성&lt;/li>
&lt;li>테스트 용이성&lt;/li>
&lt;li>UI 독립성&lt;/li>
&lt;li>데이터베이스 독립성&lt;/li>
&lt;li>모든 외부 에이전시에 대한 독립성&lt;/li>
&lt;/ul>
&lt;h2 id="의존성-규칙">의존성 규칙&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/clean-architecture/22/img.png"
width="772"
height="567"
srcset="https://codemario318.github.io/post/clean-architecture/22/img_hudd764f775c86d6d6fb1802d465c14dac_405598_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/clean-architecture/22/img_hudd764f775c86d6d6fb1802d465c14dac_405598_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="326px"
>&lt;/p>
&lt;p>그림의 각 동원은 소프트웨어의 서로 다른 영역을 표현하는데, 안으로 들어갈수록 고수준의 소프트웨어가 된다.(바깥쪽은 메커니즘, 안쪽은 정책)&lt;/p>
&lt;p>이러한 아키텍처가 동작하도록 하는 가장 중요한 규칙은 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다는 &lt;strong>의존성 규칙&lt;/strong>(Dependency Rule)이다.&lt;/p>
&lt;ul>
&lt;li>내부의 원에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못한다.
&lt;ul>
&lt;li>함수, 클래스, 변수, 엔티티 등&lt;/li>
&lt;li>외부의 원에 선언된 데이터 형식도 내부의 원에서 절대 사용해서는 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>외부 원에 위치한 어떤 것도 내부 원에 영향을 주지 않아야한다.&lt;/p>
&lt;h3 id="엔티티">엔티티&lt;/h3>
&lt;p>엔티티는 전사적인 핵심 업무 규칙을 캡슐화한 것이다.(단순한 단일 애플리케이션이라면 애플리케이션의 업무 객체)&lt;/p>
&lt;ul>
&lt;li>메서드를 가지는 객체&lt;/li>
&lt;li>일련의 데이터 구조와 함수의 집합&lt;/li>
&lt;/ul>
&lt;p>기업의 다양한 애플리케이션에서 엔티티를 재사용할 수만 있다면, 그 형태는 그다지 중요하지 않다.&lt;/p>
&lt;p>운영 관점에서 특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안 된다.&lt;/p>
&lt;h3 id="유스케이스">유스케이스&lt;/h3>
&lt;p>유스케이스 계층의 소프트웨어는 애플리케이션에 특화된 업무 규칙을 포함하며, 시스템의 모든 유스케이스를 캡슐화하고 구현한다.&lt;/p>
&lt;ul>
&lt;li>엔티티로 들어오고 나가는 데이터 흐름을 조정한다.&lt;/li>
&lt;li>엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다.&lt;/li>
&lt;/ul>
&lt;p>유스케이스 레이어를 잘 격리하여 발생한 변경이 엔티티에 영향을 줘서는 안될 뿐만 아니라, 외부 요소에서 발생한 변경이 이 계층에 영향을 줘서도 안된다.&lt;/p>
&lt;p>유스케이스 레이어는 아래와 같은 상황에서만 영향을 받아야한다.&lt;/p>
&lt;ul>
&lt;li>운영 관점에서 애플리케이션이 변경되어 유스케이스 자체가 영향을 받은 경우&lt;/li>
&lt;li>유스케이스의 세부 사항이 변경된 경우&lt;/li>
&lt;/ul>
&lt;h3 id="인터페이스-어댑터">인터페이스 어댑터&lt;/h3>
&lt;p>인터페이스 어댑터 레이어는 일련의 어댑터들(Controllers, Gateways, Presenters)로 구성된다.&lt;/p>
&lt;p>어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환한다.&lt;/p>
&lt;ul>
&lt;li>ex) GUI의 MVC 아키텍처&lt;/li>
&lt;/ul>
&lt;p>모델은 데이터 구조 정도에 지나지 않으며, 컨트롤러에서 유스케이스로 전달되고, 다시 유스케이스에서 프레젠터와 뷰로 되돌아간다.&lt;/p>
&lt;p>인터페이스 어댑터 레이어는 데이터를 엔티티와 유스케이스에게 가장 편리한 형식에서 영속성용으로 사용 중인 임의의 프레임워크(ex. DB)가 이용하기에 가장 편리한 형식으로 변환한다.&lt;/p>
&lt;p>또한 데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또 다른 어댑터가 필요하다.&lt;/p>
&lt;h3 id="프레임워크와-드라이버">프레임워크와 드라이버&lt;/h3>
&lt;p>가장 바깥 레이어인 프레임워크와 드라이버 레이어는 모든 세부사항이 위치하는 곳으로, 일반적으로 데이터베이스나 웹 프레임워크 같은 프레임워크나 도구들로 구성된다.&lt;/p>
&lt;p>이 계층에서는 안쪽 원과 통신하기 위한 접합 코드 외에는 특별히 더 작성해야 할 코드가 그다지 많지 않다.&lt;/p>
&lt;p>웹, 데이터베이스와 같은 세부사항을 모두 외부에 위치시켜서 피해를 최소화한다.&lt;/p>
&lt;h3 id="원은-네-개여야만-하는가">원은 네 개여야만 하는가?&lt;/h3>
&lt;p>그림의 원들은 하나의 예시일 뿐이며 더 많은 원이 필요할 수 있다.&lt;/p>
&lt;p>하지만 어떤 경우에도 &lt;strong>의존성 규칙&lt;/strong>은 적용된다.&lt;/p>
&lt;ul>
&lt;li>소스코드 의존성은 항상 안족을 향한다.&lt;/li>
&lt;li>안쪽으로 이동할수록 추상화와 정책의 수준은 높아진다.&lt;/li>
&lt;li>가장 바깥쪽 원은 저수준의 구체적인 세부사항으로 구성된다.&lt;/li>
&lt;li>안쪽으로 이동할수록 소프트웨어는 점점 추상화되고 더 높은 수준의 정책들을 캡슐화한다.&lt;/li>
&lt;/ul>
&lt;h3 id="경계-횡단하기">경계 횡단하기&lt;/h3>
&lt;p>위 예시에서 컨트롤러와 프레젠터가 다음 계층에 속한 유스케이스와 통신하는 모습을 확인할 수 있다.&lt;/p>
&lt;ol>
&lt;li>컨트롤에서 시작&lt;/li>
&lt;li>유스케이스를 지남&lt;/li>
&lt;li>프레젠터에서 실행&lt;/li>
&lt;/ol>
&lt;p>유스케이스가 내부 원의 인터페이스를 호출하도록 하고, 외부 원의 프레젠터가 그 인터페이스를 구현하도록 만들어 의존성 흐름을 역전시켰다.&lt;/p>
&lt;p>이처럼 제어흐름과 의존성의 방향이 명백히 반대여야 하는 경우, 의존성 역전 원칙을 사용하여 해결한다.&lt;/p>
&lt;ul>
&lt;li>인터페이스와 상속 관계 등&lt;/li>
&lt;/ul>
&lt;p>아키텍처 경계를 횡단할 때 언제라도 동일한 기법을 사용할 수 있다.&lt;/p>
&lt;h3 id="경계를-횡단하는-데이터는-어떤-모습인가">경계를 횡단하는 데이터는 어떤 모습인가?&lt;/h3>
&lt;p>경계를 가로지르는 데이터는 흔히 간단한 데이터 구조로 이루어져 있다.&lt;/p>
&lt;ul>
&lt;li>기본적인 구조체, 간단한 데이터 전송 객체(DTO) 등&lt;/li>
&lt;li>함수 호출 시 간단한 인자&lt;/li>
&lt;li>해시맵, 객체&lt;/li>
&lt;/ul>
&lt;p>중요한 점은 엔티티 객체나 데이터베이스의 행을 전달하는 것이 아닌 격리되어 있는 간단한 데이터 구조가 경계를 가로질러 전달되어야 한다.&lt;/p>
&lt;p>위와 같은 경우 결과적으로 어떠한 형태로든 전달되는 데이터 구조를 통해 내부의 원에서 외부 원의 무언가를 알게 되므로 의존성 규칙을 위배하게된다.&lt;/p>
&lt;p>따라서 경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야한다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>위와같은 간단한 규칙들을 준수하는 것은 어렵지 않으며, 향후에 겪을 수많은 고통거리를 덜어준다.&lt;/p>
&lt;p>소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며, 그에 다른 이점을 누릴 수 있다.&lt;/p>
&lt;ul>
&lt;li>데이터베이스나 프레임워크와 같은 시스템의 외부 요소를 교체하더라도 훨씬 수월해진다.&lt;/li>
&lt;/ul></description></item><item><title>21. 소리치는 아키텍처</title><link>https://codemario318.github.io/post/clean-architecture/21/</link><pubDate>Tue, 02 Apr 2024 16:19:13 +0900</pubDate><guid>https://codemario318.github.io/post/clean-architecture/21/</guid><description>&lt;img src="https://codemario318.github.io/post/clean-architecture/21/cover.png" alt="Featured image of post 21. 소리치는 아키텍처" />&lt;p>건물의 청사진을 살펴본다고 가정했을 때, 커다란 정문, 체크인과 체크아웃을 담당할 사서를 위한 공간, 독서 공간, 작은 회의실, 책장을 배치한 진열실이 나타난다면, 이 아키텍처는 &amp;ldquo;도서관&amp;quot;을 위한 아키텍처임을 예상해볼 수 있다.&lt;/p>
&lt;p>이처럼 잘 만들어진 소프트웨어 아키텍처라면 상위 수준의 디렉터리 구조, 최상위 패키지에 담긴 소스 파일등을 살펴보면 어떠한 역할을 수행하는 소프트웨어인지 한눈에 파악할 수 있다.&lt;/p>
&lt;h2 id="아키텍처의-테마">아키텍처의 테마&lt;/h2>
&lt;blockquote>
&lt;p>소프트웨어 아키텍처는 시스템의 유스케이스를 지원하는 구조이다.&lt;br>
- 이바 야콥슨 Ivar Jacobson,&lt;br>
Object-Oriented Software Engineering: Use Case Driven Approach&lt;/p>
&lt;/blockquote>
&lt;p>소프트웨어 애플리케이션의 아키텍처도 애플리케이션의 유스케이스에 대해 소리처야한다.&lt;/p>
&lt;ul>
&lt;li>아키텍처는 프레임워크에 대한 것이 아니며 절대로 그래서도 안된다.&lt;/li>
&lt;li>아키텍처를 프레임워크로부터 제공받아서는 절대 안된다.&lt;/li>
&lt;/ul>
&lt;p>프레임워크는 사용하는 도구일 뿐, 아키텍처가 준수해야 할 대상이 아니다.&lt;/p>
&lt;p>아키텍처를 프레임워크 중심으로 만들어버리면 유스케이스가 중심이 되는 아키텍처는 절대 나올 수 없다.&lt;/p>
&lt;h2 id="아키텍처의-목적">아키텍처의 목적&lt;/h2>
&lt;p>좋은 아키텍처는 유스케이스를 그 중심에 두기 때문에, 프레임워크나 도구, 환경에 전혀 구애받지 않고 유스케이스를 지원하는 구조를 아무런 문제 없이 기술할 수 있다.&lt;/p>
&lt;ul>
&lt;li>건물의 청사진의 관심사는 목적에 맞는 공간임을 확실히 하는 것이지, 어떤 기법, 재질로 지어지는지 확인하는 것이 아니다.&lt;/li>
&lt;/ul>
&lt;p>좋은 소프트웨어 아키텍처는 유스케이스에 중점을 두며, 지엽적인 관심사에 대한 결합을 분리시켜 개발 환경 문제나 도구에 대해서는 결정을 미루고, 쉽게 번복할 수 있도록 한다.&lt;/p>
&lt;h2 id="하지만-웹은">하지만 웹은?&lt;/h2>
&lt;p>웹은 전달 메커니즘(입출력 장치)이며, 애플리케이션 아키텍처에서도 그와 같이 취급해야한다.&lt;/p>
&lt;ul>
&lt;li>웹을 통해 전달된다는 사실 자체가 세부 사항이므로, 시스템 구조를 지배해서는 안된다.&lt;/li>
&lt;/ul>
&lt;p>시스템 아키텍처는 과도한 문제를 일으키거나 근본적인 아키텍처를 뜯어고치지 않더라도 시스템을 콘솔 앱, 웹 앱, 리치 클라이언트, 웹서비스 앱등 다양한 방식으로 전달할 수 있어야 한다.&lt;/p>
&lt;h2 id="프레임워크는-도구일-뿐-삶의-방식은-아니다">프레임워크는 도구일 뿐, 삶의 방식은 아니다&lt;/h2>
&lt;p>프레임워크는 매우 강력하고 상당히 유용할 수 있지만, 프레임워크가 아키텍처의 기준이 되서는 안된다.&lt;/p>
&lt;p>좋은 아키텍트라면 아키텍처를 유스케이스에 중점을 둔 채 그대로 보존할 수 있을지를 생각해야 하며, 프레임워크가 아키텍처의 중심을 차지하는 일을 막을 수 있는 전략을 개발해야한다.&lt;/p>
&lt;h2 id="테스트하기-쉬운-아키텍처">테스트하기 쉬운 아키텍처&lt;/h2>
&lt;p>아키텍처가 유스케이스를 최우선으로 하고, 이로인해 프레임워크와는 적당한 거리를 둔다면, 프레임워크를 전혀 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다.&lt;/p>
&lt;ul>
&lt;li>테스트를 돌리는 데 웹 서버가 반드시 필요한 상황이 되어서는 안된다.&lt;/li>
&lt;li>데이터베이스가 반드시 연결되어 있어야만 테스트를 돌릴 수 있어서도 안된다.&lt;/li>
&lt;/ul>
&lt;p>엔티티 객체는 반드시 오래된 방식의 간단한 객체(Plain Old Object)여야 하며, 여타 복잡한 것들에 의존해서는 안된다.&lt;/p>
&lt;p>유스케이스 객체가 엔티티 객체를 조작하도록 해야하며, 최종적으로 프레임워크로 인한 어려움을 겪지 않고도 이 모두를 있는 그래도 테스트할 수 있어야 한다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>아키텍처는 유스케이스를 통해 시스템을 이야기해야 하며, 시스템에 적용한 프레임워크에 대해 이야기해서는 안된다.&lt;/p>
&lt;p>시스템이 어떻게 전달될지 알지 못한 상태에서도 시스템의 모든 유스케이스를 이해할 수 있어야한다.&lt;/p></description></item></channel></rss>