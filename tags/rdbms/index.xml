<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RDBMS on Mario Blog</title><link>https://codemario318.github.io/tags/rdbms/</link><description>Recent content in RDBMS on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Tue, 22 Apr 2025 13:58:49 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/rdbms/index.xml" rel="self" type="application/rss+xml"/><item><title>B-Tree와 LSM Tree</title><link>https://codemario318.github.io/post/db/rdbms-nosql/</link><pubDate>Tue, 22 Apr 2025 13:58:49 +0900</pubDate><guid>https://codemario318.github.io/post/db/rdbms-nosql/</guid><description>&lt;img src="https://codemario318.github.io/post/db/rdbms-nosql/cover.png" alt="Featured image of post B-Tree와 LSM Tree" />&lt;p>최근 &amp;ldquo;&lt;strong>데이터 중심 애플리케이션 개발&lt;/strong>&amp;ldquo;을 읽으면서 RDBMS와 NoSQL의 쓰기 작업의 차이를 설명하는 내용을 접하게 되었습니다. 이 내용을 기반으로 두 가지 데이터베이스를 비교해보려고 합니다.&lt;/p>
&lt;h2 id="b-tree와-lsm-tree의-기본-구조">B-Tree와 LSM Tree의 기본 구조&lt;/h2>
&lt;p>MySQL InnoDB와 같은 RDBMS는 B-Tree 기반의 저장소 엔진을 사용하는 반면, MongoDB와 같은 NoSQL 데이터베이스는 주로 로그 기반(LSM Tree) 구조를 활용합니다. 이 두 방식은 근본적인 설계 철학부터 성능 특성까지 다양한 차이점을 가지고 있습니다.&lt;/p>
&lt;h3 id="b-tree-구조">B-Tree 구조&lt;/h3>
&lt;p>B-Tree는 RDBMS에서 널리 사용되는 색인 구조입니다. B-Tree는 데이터를 균형 잡힌 트리 형태로 구성하며, 고정 크기의 페이지 단위로 디스크에 저장합니다. 트리의 각 노드(페이지)는 키와 그에 해당하는 하위 페이지 참조를 포함하고 있습니다. 일반적으로 데이터를 삽입, 삭제, 수정할 때는 해당 페이지의 내용을 &lt;strong>직접 덮어쓰는 방식&lt;/strong>을 사용합니다.&lt;/p>
&lt;p>이러한 &lt;strong>균형 트리 구조&lt;/strong>를 통해 어떤 &lt;strong>키&lt;/strong>에 대해서도 &lt;code>O(log n)&lt;/code> 시간 복잡도로 검색이 가능하며, 대부분의 데이터베이스에서 B-Tree의 깊이는 3-4 수준에 불과해 매우 빠른 접근 시간을 제공합니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> [루트 페이지]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> / | \
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">[페이지1] [페이지2] [페이지3]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> / \ / \ / \
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">... ... ... ... ... ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="lsm-tree-구조">LSM Tree 구조&lt;/h3>
&lt;p>LSM Tree(로그 구조화 병합 트리)는 로그 기반의 저장 구조를 사용합니다.&lt;/p>
&lt;p>데이터를 수정할 때마다 디스크에 &lt;strong>순차적으로 추가&lt;/strong>하는 방식을 사용하기 때문에, 기존 데이터를 덮어쓰지 않습니다. 새로운 데이터는 먼저 메모리 내의 멤테이블(MemTable)에 버퍼링되고, 멤테이블이 일정 크기에 도달하면 디스크의 SS테이블(Sorted String Table)로 기록됩니다.&lt;/p>
&lt;p>시간이 지남에 따라 여러 SS테이블이 생성되며, 백그라운드에서 주기적으로 이들을 &lt;strong>병합&lt;/strong>하고 &lt;strong>압축&lt;/strong>하는 &lt;strong>컴팩션&lt;/strong> 프로세스가 실행됩니다. 이러한 순차적 쓰기 방식은 B-Tree에서 정해진 위치의 데이터를 덮어쓰는 방법과 달리 파일에 맨 뒤에 추가만 하는 방식이므로 별도의 특정 위치에 대한 확인 같은 부수적인 처리가 없고 디스크의 물리적 특성에 최적화되어 있으므로 일반적으로 쓰기 작업에서 뛰어난 성능을 보입니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[MemTable(메모리)] → [SS테이블1(디스크)] → [SS테이블2(디스크)] → ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ↓ ↓
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [컴팩션 프로세스] [컴팩션 프로세스]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ↓ ↓
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [병합된 SS테이블] [병합된 SS테이블]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="읽기쓰기-성능-특성-비교">읽기/쓰기 성능 특성 비교&lt;/h2>
&lt;p>B-Tree 계열과 LSM Tree 동작 방식의 차이로 인해 읽기/쓰기 작업에도 다른 양상을 보여줍니다.&lt;/p>
&lt;h3 id="읽기-성능">읽기 성능&lt;/h3>
&lt;p>&lt;strong>B-Tree 의 읽기 성능&lt;/strong>&lt;/p>
&lt;p>B-Tree 구조에서는 인덱스를 통해 데이터에 직접 접근할 수 있습니다.&lt;/p>
&lt;p>균형 잡힌 트리 구조를 통해 어떤 키에 대해서도 &lt;code>O(log n)&lt;/code> 시간 내에 검색이 가능하며, 대부분의 경우 단 몇 번의 디스크 I/O만으로 원하는 레코드에 도달할 수 있습니다. 특히 기본 키를 이용한 검색은 매우 효율적이며, 색인된 열을 기준으로 한 범위 쿼리(B+ Tree)도 높은 성능을 보입니다.&lt;/p>
&lt;p>또한 B-Tree는 데이터가 정렬된 상태로 유지되므로 정렬된 결과가 필요한 쿼리에서도 유리합니다. 인덱스가 메모리에 캐시되어 있다면 더욱 빠른 접근이 가능합니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>LSM Tree의 읽기 성능&lt;/strong>&lt;/p>
&lt;p>LSM Tree 구조에서는 특정 키를 검색할 때 여러 SS테이블을 차례로 확인해야 할 수 있습니다.&lt;/p>
&lt;p>키를 찾기 위해 먼저 메모리의 멤테이블을 확인하고, 없다면 가장 최근에 생성된 SS테이블부터 차례대로 확인합니다. 이 과정에서 여러 번의 디스크 접근이 필요할 수 있어 B-Tree보다 읽기 성능이 떨어질 수 있습니다.&lt;/p>
&lt;p>그러나 &lt;strong>블룸 필터&lt;/strong>와 같은 최적화 기법을 사용하여 특정 키가 존재하지 않는 SS테이블을 효율적으로 건너뛸 수 있습니다. 또한 컴팩션 작업이 진행 중일 때는 읽기 성능이 일시적으로 저하될 수 있습니다.&lt;/p>
&lt;p>한편, 순차적 읽기나 스캔 작업에서는 데이터의 연속적 배치로 인해 우수한 성능을 보일 수 있습니다.&lt;/p>
&lt;h3 id="쓰기-성능">쓰기 성능&lt;/h3>
&lt;p>&lt;strong>B-Tree의 쓰기 성능&lt;/strong>&lt;/p>
&lt;p>B-Tree 구조에서는 데이터를 수정할 때 해당 페이지를 직접 덮어써야 합니다. 이는 &lt;strong>무작위 I/O&lt;/strong> 패턴을 유발하여 특히 하드 디스크 드라이브(HDD)에서 성능 저하의 원인이 됩니다. 또한 B-Tree의 균형을 유지하기 위해 데이터 삽입 시 &lt;strong>페이지 분할&lt;/strong>이 발생할 수 있으며, 이는 &lt;strong>추가적인 디스크 I/O&lt;/strong>를 필요로 합니다.&lt;/p>
&lt;p>또한 인덱스가 여러 개 있는 경우, 데이터 수정 시 &lt;strong>모든 관련 인덱스를 업데이트&lt;/strong>해야 하므로 쓰기 오버헤드가 증가합니다.&lt;/p>
&lt;p>데이터 변경의 안전한 복구를 위해 WAL(Write-Ahead Log)을 유지해야 하므로, 하나의 트랜잭션에 대해 여러 번의 디스크 쓰기가 필요할 수 있습니다. 이러한 특성으로 인해 B-Tree는 쓰기 작업이 많은 워크로드에서는 성능 병목이 될 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>LSM Tree의 쓰기 성능&lt;/strong>&lt;/p>
&lt;p>LSM Tree 구조는 쓰기 작업에 최적화되어 있습니다.&lt;/p>
&lt;p>데이터 변경 시 디스크에 &lt;strong>순차적으로 추가&lt;/strong>하므로, 특히 HDD에서 효율적입니다. 새로운 데이터는 먼저 메모리의 멤테이블에 버퍼링되므로 디스크 I/O 횟수를 크게 줄일 수 있습니다. 대량의 데이터를 삽입할 때도 멤테이블이 가득 차기 전까지는 디스크에 기록할 필요가 없어 빠른 속도로 처리됩니다.&lt;/p>
&lt;p>기존 데이터를 덮어쓰지 않고 새 버전을 추가하는 방식이므로 페이지 분할과 같은 구조 재조정이 필요 없습니다. 물론 컴팩션 과정이 필요하지만, 이는 백그라운드에서 처리되므로 전면적인 쓰기 성능에는 영향이 적습니다.&lt;/p>
&lt;p>이러한 특성으로 인해 LSM Tree는 특히 쓰기가 많은 워크로드에서 우수한 성능을 보입니다.&lt;/p>
&lt;h2 id="innodb의-쓰기-성능-최적화-전략">InnoDB의 쓰기 성능 최적화 전략&lt;/h2>
&lt;p>RDBMS의 대표적인 예시로 MySQL의 InnoDB 스토리지 엔진이 있는데요, InnoDB에서 쓰기 작업 성능을 개선하기 위해 여러 방법들을 활용하고 있습니다. 대략적으로 살펴볼까요?&lt;/p>
&lt;h3 id="버퍼풀을-통한-쓰기-성능-개선">버퍼풀을 통한 쓰기 성능 개선&lt;/h3>
&lt;p>InnoDB의 버퍼풀을 통해 쓰기 성능에 도움을 줄 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>쓰기 버퍼링과 지연된 일괄 처리&lt;/strong>&lt;/p>
&lt;p>InnoDB는 데이터 변경 작업이 발생하면 즉시 디스크에 기록하지 않고 버퍼풀에 더티 페이지(Dirty Page)로 유지합니다. 이 방식은 다음과 같은 이점을 제공합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>랜덤 I/O 최소화&lt;/strong>:
&lt;ul>
&lt;li>&lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>, &lt;code>DELETE&lt;/code> 쿼리는 데이터 파일의 흩어진 레코드를 변경하는 랜덤한 디스크 작업을 발생시키지만, 버퍼풀을 통해 이러한 변경을 일정 시간 동안 모아서 효율적으로 처리합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>쓰기 병합&lt;/strong>:
&lt;ul>
&lt;li>같은 페이지에 대한 여러 변경 사항이 버퍼풀 내에서 병합되어 디스크 I/O 횟수를 크게 줄입니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>순차적 I/O 전환&lt;/strong>:
&lt;ul>
&lt;li>여러 랜덤 쓰기 작업을 모아 더 효율적인 순차적 I/O 패턴으로 변환합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>변경 버퍼(Change Buffer)&lt;/strong>&lt;/p>
&lt;p>보조 인덱스 변경에 특화된 최적화 기법으로, LSM Tree의 쓰기 지연 원리와 유사한 방식을 도입했습니다.&lt;/p>
&lt;ul>
&lt;li>보조 인덱스 변경 사항을 즉시 디스크에 반영하지 않고 메모리에 버퍼링합니다.&lt;/li>
&lt;li>시스템 리소스가 여유 있을 때나 해당 페이지가 다른 이유로 메모리에 로드될 때 변경 사항을 적용합니다.&lt;/li>
&lt;li>보조 인덱스가 많은 테이블에서 특히 큰 성능 향상을 제공합니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>리두 로그(Redo Log)와 버퍼풀의 협업&lt;/strong>&lt;/p>
&lt;p>리두 로그와 버퍼풀의 효율적인 상호작용은 데이터 안전성을 보장하면서도 쓰기 성능에 도움을 줄 수 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>선로깅(Write-Ahead Logging)&lt;/strong>:
&lt;ul>
&lt;li>데이터 변경이 발생하면 먼저 순차적인 리두 로그에 기록하고, 실제 데이터 페이지는 버퍼풀에 더티 페이지로 유지합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>그룹 커밋(Group Commit)&lt;/strong>:
&lt;ul>
&lt;li>여러 트랜잭션의 커밋을 함께 묶어 처리하여 I/O 오버헤드를 줄입니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>체크포인트 최적화&lt;/strong>:
&lt;ul>
&lt;li>리두 로그와 버퍼풀의 크기를 적절히 조정하여 체크포인트 빈도를 최적화함으로써 디스크 I/O 폭발 현상을 방지합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>더티 페이지 관리 및 플러시 최적화&lt;/strong>&lt;/p>
&lt;p>InnoDB는 더티 페이지의 디스크 기록을 효율적으로 관리하기 위한 다양한 메커니즘을 제공합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>플러시 리스트(Flush List)&lt;/strong>:
&lt;ul>
&lt;li>변경 시점을 기준으로 더티 페이지를 관리하며, 오래된 변경 사항부터 순차적으로 디스크에 기록합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>어댑티브 플러시(Adaptive Flushing)&lt;/strong>:
&lt;ul>
&lt;li>리두 로그의 증가 속도를 분석하여 최적의 시점에 적절한 양의 더티 페이지를 디스크에 기록합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>버퍼풀 인스턴스 분할&lt;/strong>:
&lt;ul>
&lt;li>여러 개의 버퍼풀 인스턴스로 나누어 내부 잠금 경합을 줄이고 병렬 처리 효율을 높입니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>페이지 클리너 스레드(Page Cleaner Thread)&lt;/strong>:
&lt;ul>
&lt;li>백그라운드에서 더티 페이지를 디스크로 동기화하는 전용 스레드를 통해 사용자 쿼리 처리에 영향을 최소화합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>이중 쓰기 버퍼(Doublewrite Buffer)&lt;/strong>&lt;/p>
&lt;p>데이터 무결성을 보장하면서도 쓰기 성능을 향상시키는 매커니즘입니다.&lt;/p>
&lt;ul>
&lt;li>더티 페이지를 데이터 파일에 직접 쓰기 전에 먼저 연속된 이중 쓰기 버퍼 영역에 기록합니다.&lt;/li>
&lt;li>연속된 영역에 순차적으로 기록하므로 I/O 효율성이 향상됩니다.&lt;/li>
&lt;li>&amp;ldquo;부분 페이지 쓰기&amp;rdquo; 문제를 방지하여 시스템 충돌 시에도 데이터 일관성을 보장합니다.&lt;/li>
&lt;/ul>
&lt;h3 id="mvcc의-쓰기-성능-개선-효과">MVCC의 쓰기 성능 개선 효과&lt;/h3>
&lt;p>MVCC는 여러 트랜잭션이 동시에 적용되는 상황에서 잠금 수준에 따라 다른 버전을 유지, 제공하여 잠금으로 인한 읽기 성능 저하를 개선하려는 목적으로 활용하지만, 트랜잭션의 유지 시간을 줄여 쓰기 성능 향상을 기대할 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>읽기-쓰기 충돌 감소&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>쓰기 블로킹 최소화&lt;/strong>:
&lt;ul>
&lt;li>전통적인 잠금 기반 시스템에서는 쓰기 작업이 읽기 작업을 차단하거나 그 반대의 경우가 발생하지만, MVCC는 쓰기 중에도 일관된 데이터 스냅샷을 통해 읽기가 가능하게 함으로써 블로킹을 최소화합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>동시성 향상&lt;/strong>:
&lt;ul>
&lt;li>읽기 작업이 쓰기 작업을 기다릴 필요가 없기 때문에, 높은 동시성 환경에서 쓰기 처리량이 크게 향상됩니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>적은 락 획득&lt;/strong>:
&lt;ul>
&lt;li>읽기 작업이 락을 획득할 필요가 없으므로, 쓰기 작업에 필요한 락을 더 빠르게 획득할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>트랜잭션 처리 효율성&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>빠른 롤백 처리&lt;/strong>:
&lt;ul>
&lt;li>변경 사항을 새 버전으로 만들기 때문에, 롤백 시 이전 버전의 데이터가 이미 보존되어 있어 복잡한 복구 작업이 필요하지 않습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>효율적인 충돌 해결&lt;/strong>:
&lt;ul>
&lt;li>트랜잭션 간 충돌을 버전 비교를 통해 효율적으로 감지하고 관리할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>더 짧은 트랜잭션 시간&lt;/strong>:
&lt;ul>
&lt;li>읽기 작업이 쓰기를 차단하지 않아 트랜잭션 완료 시간이 단축됩니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="rdbms-쓰기-작업-성능-저하">RDBMS 쓰기 작업 성능 저하&lt;/h2>
&lt;p>InnoDB 에서는 위와 같은 노력을 통해 실제 디스크에 변경 내역을 반영하는 작업은 백그라운드로 실행할 수 있게 하고 있습니다. 이 때문에 실제 디스크에 반영되기까지 시간을 걸릴 지 모르겠지만, RDBMS를 사용하는 클라이언트 입장에서는 빠르게 처리되는 것 처럼 동작하게 됩니다.&lt;/p>
&lt;p>하지만 그럼에도 불구하고 성능 저하가 발생하는 이유가 있습니다.&lt;/p>
&lt;h3 id="트랜잭션-일관성-유지-비용">트랜잭션 일관성 유지 비용&lt;/h3>
&lt;p>ACID 특성을 완벽하게 보장하기 위한 오버헤드가 발생합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>트랜잭션 로깅&lt;/strong>:
&lt;ul>
&lt;li>모든 변경 사항은 리두 로그와 언두 로그에 기록되어야 합니다.&lt;/li>
&lt;li>이 로깅 작업은 추가적인 I/O를 발생시키며, 특히 &lt;code>innodb_flush_log_at_trx_commit=1&lt;/code> 설정에서는 모든 트랜잭션 커밋마다 로그를 디스크에 동기화해야 합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>원자성 보장&lt;/strong>:
&lt;ul>
&lt;li>트랜잭션의 모든 작업이 완료되거나 아무것도 적용되지 않아야 하는 원자성을 보장하기 위해, 시스템은 복잡한 롤백 메커니즘을 유지해야 합니다. 이는 롤백 세그먼트 관리와 같은 추가 오버헤드를 발생시킵니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>지속성 보장&lt;/strong>:
&lt;ul>
&lt;li>데이터 변경이 영구적으로 저장되도록 보장하기 위해 데이터베이스는 메모리상의 변경 사항을 주기적으로 디스크에 동기화해야 합니다.&lt;/li>
&lt;li>이 동기화 작업은 비용이 크며, 특히 대규모 변경 작업 후 발생하는 체크포인트는 급격한 I/O 증가를 유발할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="인덱스-관리의-복잡성">인덱스 관리의 복잡성&lt;/h3>
&lt;p>B-Tree 기반 인덱스 구조가 가지는 특성으로 인한 오버헤드가 발생합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>다중 인덱스 업데이트&lt;/strong>:
&lt;ul>
&lt;li>하나의 테이블에 여러 인덱스가 있는 경우, 데이터 변경 시 모든 관련 인덱스를 함께 업데이트해야 합니다.&lt;/li>
&lt;li>인덱스의 수가 많을수록 쓰기 작업의 부담이 기하급수적으로 증가합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>B-Tree 재조정&lt;/strong>:
&lt;ul>
&lt;li>데이터 삽입이나 삭제로 인해 B-Tree 구조의 균형이 깨지면, 시스템은 페이지 분할(Page Split)이나 페이지 병합(Page Merge)을 수행해야 합니다.&lt;/li>
&lt;li>이 과정은 추가적인 I/O와 CPU 비용을 발생시키며, 특히 페이지 분할은 연쇄적인 분할을 유발할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>인덱스 단편화&lt;/strong>:
&lt;ul>
&lt;li>시간이 지남에 따라 B-Tree 인덱스는 단편화되어 공간 효율성과 성능이 저하될 수 있습니다.&lt;/li>
&lt;li>이를 해결하기 위한 인덱스 재구성 작업은 추가적인 시스템 부하를 발생시킵니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="제약-조건-검증">제약 조건 검증&lt;/h3>
&lt;p>데이터 무결성을 위한 다양한 제약 조건 검증 과정이 쓰기 성능에 영향을 미칩니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>외래 키 제약 조건&lt;/strong>:
&lt;ul>
&lt;li>외래 키를 포함하는 테이블에서 데이터를 변경할 때, 시스템은 참조 무결성을 유지하기 위해 참조된 테이블을 검사해야 합니다&lt;/li>
&lt;li>이는 추가적인 쿼리와 락을 필요로 합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>유니크 제약 조건&lt;/strong>:
&lt;ul>
&lt;li>고유 인덱스가 있는 열에 데이터를 삽입할 때, 시스템은 중복 값이 없는지 확인해야 합니다.&lt;/li>
&lt;li>이 검증 과정은 특히 대량 삽입 작업에서 상당한 오버헤드를 발생시킬 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>체크 제약 조건&lt;/strong>:
&lt;ul>
&lt;li>데이터 값이 특정 조건을 만족하는지 확인하는 체크 제약 조건은 추가적인 검증 로직이 필요하며, 이는 쓰기 작업의 복잡성을 증가시킵니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 때문에 실제 제약 조건을 애플리케이션 수준에서 처리하는 경우가 다수 있습니다.&lt;/p>
&lt;h3 id="버퍼-관리의-복잡성">버퍼 관리의 복잡성&lt;/h3>
&lt;p>메모리와 디스크 사이의 데이터 관리가 복잡한 오버헤드를 발생시킵니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>버퍼풀 경합&lt;/strong>:
&lt;ul>
&lt;li>고부하 상황에서 버퍼풀의 제한된 페이지를 두고 여러 쿼리가 경쟁할 수 있으며, 이는 상호 간섭과 성능 저하를 초래할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>메모리 제약&lt;/strong>:
&lt;ul>
&lt;li>데이터셋이 사용 가능한 메모리보다 클 경우, 페이지를 지속적으로 디스크에서 읽고 쓰는 스래싱(thrashing) 현상이 발생할 수 있으며, 이는 성능을 크게 저하시킵니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>더티 페이지 관리&lt;/strong>:
&lt;ul>
&lt;li>버퍼풀에 많은 더티 페이지가 누적되면, 체크포인트 동안 디스크에 대량의 데이터를 쓰는 &amp;ldquo;쓰기 폭발(write burst)&amp;rdquo; 현상이 발생할 수 있습니다.&lt;/li>
&lt;li>이는 특히 대량 데이터 로드 작업 후에 심각한 성능 문제를 일으킬 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="잠금lock-메커니즘의-오버헤드">잠금(Lock) 메커니즘의 오버헤드&lt;/h3>
&lt;p>데이터 일관성을 보장하기 위한 다양한 수준의 잠금 메커니즘이 성능에 영향을 미칩니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>테이블 잠금(Table Lock)&lt;/strong>:
&lt;ul>
&lt;li>&lt;code>ALTER TABLE&lt;/code>과 같은 스키마 변경 작업은 테이블 전체를 잠그기 때문에, 해당 테이블에 대한 모든 쓰기 작업이 차단됩니다.&lt;/li>
&lt;li>이는 특히 대형 테이블이나 고부하 환경에서 심각한 성능 문제를 일으킬 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>행 잠금(Row Lock)&lt;/strong>:
&lt;ul>
&lt;li>개별 행 수준의 잠금은 더 높은 동시성을 제공하지만, 관리해야 할 잠금의 수가 많아지면서 오버헤드가 증가합니다.&lt;/li>
&lt;li>특히 많은 행을 수정하는 트랜잭션에서는 수많은 잠금을 획득하고 관리해야 하므로 성능이 저하될 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>갭 잠금(Gap Lock)&lt;/strong>:
&lt;ul>
&lt;li>InnoDB의 기본 격리 수준인 REPEATABLE READ에서는 팬텀 읽기(phantom reads)를 방지하기 위해 갭 잠금을 사용합니다.&lt;/li>
&lt;li>이는 실제 레코드뿐만 아니라 레코드 사이의 간격까지 잠그기 때문에 동시성이 감소하고 교착 상태 가능성이 증가합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>의도 잠금(Intention Lock)&lt;/strong>:
&lt;ul>
&lt;li>테이블과 행 간의 잠금 관계를 효율적으로 관리하기 위한 의도 잠금도 추가적인 관리 오버헤드를 발생시킵니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="잠금-경합lock-contention과-교착-상태deadlock">잠금 경합(Lock Contention)과 교착 상태(Deadlock)&lt;/h3>
&lt;p>고부하 상황에서 잠금 관련 문제가 성능을 크게 저하시킬 수 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>잠금 대기(Lock Wait)&lt;/strong>:
&lt;ul>
&lt;li>한 트랜잭션이 이미 잠긴 리소스에 접근하려 할 때, 해당 리소스가 해제될 때까지 대기해야 합니다.&lt;/li>
&lt;li>이러한 대기 시간은 전체 쿼리 실행 시간을 크게 증가시킬 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>교착 상태(Deadlock)&lt;/strong>:
&lt;ul>
&lt;li>서로 다른 트랜잭션이 상대방이 필요로 하는 잠금을 보유한 채로 서로의 잠금을 기다리는 교착 상태가 발생할 수 있습니다.&lt;/li>
&lt;li>InnoDB는 이를 감지하고 자동으로 한 트랜잭션을 롤백시키지만, 이로 인해 애플리케이션에서 트랜잭션을 재시도해야 하는 추가 비용이 발생합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>핫스팟(Hotspot)&lt;/strong>:
&lt;ul>
&lt;li>특정 행이나 페이지가 많은 트랜잭션에 의해 빈번하게 접근되는 경우, 해당 리소스에 대한 경합이 심해지고 이는 전체 시스템 성능을 저하시키는 병목 지점이 될 수 있습니다.&lt;/li>
&lt;li>일반적인 예로는 시퀀스 테이블이나 카운터 업데이트 등이 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이러한 다양한 요인들이 RDBMS에서 쓰기 작업의 성능을 제약하는 근본적인 이유가 됩니다. MySQL InnoDB와 같은 현대적인 엔진은 이러한 제약을 최소화하기 위해 다양한 최적화 기법을 도입했지만, 기본적인 아키텍처 특성으로 인한 한계가 존재합니다.&lt;/p>
&lt;h2 id="lsm-tree가-적절한-상황은">LSM Tree가 적절한 상황은?&lt;/h2>
&lt;p>InnoDB의 다양한 최적화에도 불구하고, 특정 상황에서는 여전히 NoSQL 데이터베이스가 더 적합한 선택일 수 있습니다.&lt;/p>
&lt;h3 id="대규모-쓰기-워크로드">대규모 쓰기 워크로드&lt;/h3>
&lt;p>극단적으로 쓰기가 많은 워크로드에서는 LSM Tree 기반 시스템이 본질적으로 유리합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>고빈도 삽입 작업&lt;/strong>:
&lt;ul>
&lt;li>로그 수집, IoT 센서 데이터, 클릭스트림 추적과 같이 초당 수만에서 수십만 건의 삽입이 필요한 경우, NoSQL 시스템의 순차적 쓰기 방식이 큰 이점을 제공합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>쓰기 최적화 구조&lt;/strong>:
&lt;ul>
&lt;li>NoSQL 시스템은 쓰기 작업을 위해 특별히 설계되었으며, 디스크 I/O 패턴이 쓰기에 최적화되어 있습니다.&lt;/li>
&lt;li>인덱스 구조의 재구성 없이 순차 쓰기만 수행하므로 CPU 오버헤드가 적습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>배치 처리 효율성&lt;/strong>:
&lt;ul>
&lt;li>대량의 데이터를 일괄 처리하는 작업에서 NoSQL은 스키마 검증, 트랜잭션 오버헤드, 인덱스 재구성과 같은 RDBMS의 제약 없이 더 빠르게 데이터를 로드할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="스키마리스schemaless-데이터-모델-필요">스키마리스(Schemaless) 데이터 모델 필요&lt;/h3>
&lt;p>데이터 구조가 자주 변경되거나 매우 다양한 경우 LSM Tree가 유리합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>유연한 스키마&lt;/strong>:
&lt;ul>
&lt;li>문서 기반 NoSQL 데이터베이스는 스키마 변경 없이 새로운 필드를 추가할 수 있어, 빠르게 변화하는 비즈니스 요구사항에 더 민첩하게 대응할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>다양한 데이터 형태&lt;/strong>:
&lt;ul>
&lt;li>같은 컬렉션 내에서도 서로 다른 구조의 데이터를 저장할 수 있어, 이기종 데이터를 관리하는 데 유리합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>개발 속도&lt;/strong>:
&lt;ul>
&lt;li>스키마 정의 및 마이그레이션 부담이 없어, 프로토타이핑이나 애자일 개발 환경에서 빠른 반복 개발이 가능합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="수평적-확장성-요구">수평적 확장성 요구&lt;/h3>
&lt;p>대규모 데이터와 트래픽을 처리해야 하는 경우 NoSQL의 분산 아키텍처가 유리합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>기본 샤딩 지원&lt;/strong>:
&lt;ul>
&lt;li>많은 NoSQL 솔루션은 처음부터 분산 시스템으로 설계되어 있어, 데이터를 여러 노드에 자동으로 분산하는 샤딩 기능이 기본으로 제공됩니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>선형적 확장성&lt;/strong>:
&lt;ul>
&lt;li>노드를 추가하는 것만으로 거의 선형적인 성능 향상을 얻을 수 있어, 성장하는 서비스의 수요에 유연하게 대응할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>클라우드 친화적&lt;/strong>:
&lt;ul>
&lt;li>대부분의 NoSQL 시스템은 클라우드 환경에서 효율적으로 동작하도록 설계되어 있어, 탄력적인 리소스 관리와 자동화된 운영이 용이합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>또한 RDBMS에서는 읽기 전용 레플리카를 통해 읽기 작업에 부하를 비교적 쉽게 개선할 수 있지만, 쓰기 작업에 대한 쓰기 레플리카를 운영하는 것은 RDBMS의 쓰기 과정의 복잡함으로 인해 굉장히 비효율적인 것으로 알려져 있습니다.&lt;/p>
&lt;h3 id="지리적으로-분산된-데이터-저장">지리적으로 분산된 데이터 저장&lt;/h3>
&lt;p>글로벌 서비스나 지역적으로 분산된 애플리케이션의 경우 복제가 유리한 LSM Tree가 적합할 수 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>멀티 리전 복제&lt;/strong>:
&lt;ul>
&lt;li>많은 NoSQL 시스템은 지리적으로 분산된 데이터 센터 간의 복제를 기본 기능으로 지원하여, 글로벌 사용자에게 낮은 지연 시간의 서비스를 제공할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>파티션 허용성&lt;/strong>:
&lt;ul>
&lt;li>CAP 이론에서 가용성(A)과 파티션 허용성(P)에 중점을 두어, 네트워크 지연이나 단절이 있는 환경에서도 서비스를 계속 제공할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>지역성 최적화&lt;/strong>:
&lt;ul>
&lt;li>사용자와 가까운 지역에 데이터를 위치시켜 접근 지연 시간을 최소화할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="높은-가용성-요구">높은 가용성 요구&lt;/h3>
&lt;p>중단 없는 서비스 제공이 필수적인 경우 분산 특성이 유리합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>마스터리스(Masterless) 아키텍처&lt;/strong>:
&lt;ul>
&lt;li>카산드라와 같은 일부 NoSQL 시스템은 모든 노드가 동등한 역할을 하는 마스터리스 아키텍처를 제공하여, 단일 장애점이 없는 고가용성 시스템을 구축할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>자동 복구 메커니즘&lt;/strong>:
&lt;ul>
&lt;li>노드 장애 시 자동으로 데이터를 재분배하고 복구하는 메커니즘이 내장되어 있어, 운영 부담이 줄어듭니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>읽기/쓰기 가용성 조정&lt;/strong>:
&lt;ul>
&lt;li>일부 NoSQL 시스템에서는 일관성 수준을 조정하여 가용성과 일관성 사이의 균형을 애플리케이션 요구에 맞게 조정할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>LSM Tree를 활용하는 NoSQL 데이터베이스는 이러한 특정 사용 사례에서 RDBMS보다 뛰어난 성능과 적합성을 제공할 수 있습니다. 그러나 트랜잭션 일관성, 복잡한 쿼리, 조인 작업이 중요한 경우에는 여전히 RDBMS가 더 적합할 수 있으므로, 데이터베이스 선택은 실제 애플리케이션의 요구사항과 워크로드 특성을 면밀히 분석한 후 이루어져야 합니다.&lt;/p>
&lt;h2 id="실제-환경에서의-데이터베이스-선택">실제 환경에서의 데이터베이스 선택&lt;/h2>
&lt;p>이론적인 차이점만으로는 실제 환경에서의 성능을 정확히 예측하기 어렵습니다. 다음과 같은 요소들이 성능에 큰 영향을 미칩니다.&lt;/p>
&lt;h3 id="워크로드-특성">워크로드 특성&lt;/h3>
&lt;p>워크로드의 읽기/쓰기 비율은 데이터베이스 선택에 중요한 요소입니다.&lt;/p>
&lt;p>읽기가 대부분인 워크로드(일반적인 웹 서비스)에서는 B-Tree 기반 RDBMS가 유리할 수 있습니다. 반면, 쓰기가 많은 워크로드(예: 로깅, 이벤트 수집)에서는 LSM Tree 기반 NoSQL이 더 효율적일 수 있습니다.&lt;/p>
&lt;p>쿼리 패턴도 중요한데, &lt;strong>복잡한 조인&lt;/strong>이나 &lt;strong>트랜잭션&lt;/strong>이 필요한 경우 RDBMS가 적합하며, 단순한 &lt;strong>키-값 조회&lt;/strong>가 주된 작업이라면 NoSQL이 더 간단하고 효율적일 수 있습니다.&lt;/p>
&lt;p>&lt;strong>데이터 크기&lt;/strong>와 &lt;strong>성장 속도&lt;/strong>도 고려해야 하는데, 대용량 데이터에서는 LSM Tree의 우수한 압축률과 확장성이 장점이 될 수 있습니다.&lt;/p>
&lt;h3 id="하드웨어-환경">하드웨어 환경&lt;/h3>
&lt;p>하드웨어 환경은 데이터베이스 성능에 직접적인 영향을 미칩니다.&lt;/p>
&lt;p>HDD를 사용하는 경우, 순차적 I/O에 최적화된 LSM Tree가 무작위 I/O가 많은 B-Tree보다 유리합니다. SSD에서는 무작위 I/O의 패널티가 줄어들어 B-Tree의 단점이 완화됩니다.&lt;/p>
&lt;p>&lt;strong>사용 가능한 메모리&lt;/strong> 양도 중요한 요소입니다. 대용량 버퍼풀이 가능한 환경에서는 B-Tree의 읽기/쓰기 성능이 크게 향상되며, LSM Tree의 컴팩션 오버헤드가 상대적으로 더 부담스러울 수 있습니다.&lt;/p>
&lt;p>&lt;strong>CPU 자원&lt;/strong>도 고려해야 하는데, LSM Tree의 백그라운드 컴팩션 작업은 추가적인 CPU 자원을 소모하므로, CPU 제한이 있는 환경에서는 이점이 감소할 수 있습니다.&lt;/p>
&lt;h3 id="애플리케이션-요구사항">애플리케이션 요구사항&lt;/h3>
&lt;p>애플리케이션의 &lt;strong>데이터 일관성&lt;/strong>, &lt;strong>트랜잭션&lt;/strong>, &lt;strong>가용성&lt;/strong> 요구사항도 데이터베이스 선택에 중요한 요소입니다.&lt;/p>
&lt;p>ACID 트랜잭션이 중요한 금융, 전자상거래 등의 애플리케이션에서는 RDBMS를 선호하는 경향이 있습니다. 반면, 일시적인 데이터 불일치를 허용할 수 있는 소셜 미디어, 로깅 등의 애플리케이션에서는 NoSQL의 유연성과 확장성이 장점이 될 수 있습니다.&lt;/p>
&lt;p>&lt;strong>스키마 변경 빈도&lt;/strong>도 고려사항입니다. 스키마가 자주 변경되는 환경에서는 스키마리스 또는 스키마 유연성이 높은 NoSQL이 유리할 수 있습니다. 지리적 분산이나 고가용성 요구사항이 있는 경우, 분산 설계가 기본적으로 포함된 일부 NoSQL 솔루션이 적합할 수 있습니다.&lt;/p>
&lt;h2 id="실제-벤치마크-테스트의-중요성">실제 벤치마크 테스트의 중요성&lt;/h2>
&lt;p>이론적인 성능 특성은 중요한 지침이 되지만, 실제 운영 환경에서 예상과 다른 결과가 나올 수 있기 때문에 최종 결정은 실제 애플리케이션 데이터와 워크로드를 사용한 벤치마크 테스트를 통해 이루어져야 한다고 언급하고 있습니다.&lt;/p>
&lt;h3 id="실제-데이터-크기와-분포-반영">실제 데이터 크기와 분포 반영&lt;/h3>
&lt;p>벤치마크 테스트는 반드시 &lt;strong>실제 애플리케이션에서 사용할 데이터의 크기와 분포&lt;/strong>를 반영해야 합니다.&lt;/p>
&lt;p>합성 데이터나 균일하게 분포된 테스트 데이터는 실제 환경에서의 성능을 정확히 예측하지 못할 수 있습니다. 실제 데이터는 종종 불균형하게 분포되어 있으며, 이런 데이터 편향(skew)은 데이터베이스 성능에 큰 영향을 미칩니다. 특히 인덱스 효율성, 캐시 히트율, 쿼리 실행 계획 등에 영향을 줍니다.&lt;br>
가능하다면 프로덕션 데이터의 익명화된 사본이나 통계적으로 유사한 데이터셋을 사용하여 테스트하는 것이 좋습니다.&lt;/p>
&lt;h3 id="실제-쿼리-패턴-테스트">실제 쿼리 패턴 테스트&lt;/h3>
&lt;p>애플리케이션의 &lt;strong>실제 쿼리 패턴&lt;/strong>을 사용한 벤치마크가 중요합니다.&lt;/p>
&lt;p>단순한 CRUD 작업만으로는 복잡한 애플리케이션의 성능을 예측하기 어렵습니다. 실제 애플리케이션에서 자주 사용되는 쿼리, 특히 &lt;strong>성능 병목이 될 가능성이 있는 복잡한 쿼리들을 포함&lt;/strong>시켜야 합니다.&lt;/p>
&lt;p>실제 워크로드의 &lt;strong>읽기/쓰기 비율&lt;/strong>, &lt;strong>동시 접속 수준&lt;/strong>, &lt;strong>쿼리 복잡성&lt;/strong> 등을 반영한 &lt;strong>테스트 시나리오를 구성&lt;/strong>해야 합니다. 또한 피크 시간대의 부하를 시뮬레이션하여 최악의 상황에서도 성능 요구사항을 충족하는지 확인해야 합니다.&lt;/p>
&lt;h3 id="확장성-테스트">확장성 테스트&lt;/h3>
&lt;p>데이터베이스는 시간이 지남에 따라 데이터 볼륨이 증가하므로, 확장성 테스트가 필요할 수 있습니다. 현재 데이터 크기뿐만 아니라 예상되는 미래 데이터 크기에서도 테스트를 수행하면 좋습니다.&lt;/p>
&lt;p>데이터 증가에 따른 쿼리 성능 변화, 인덱스 효율성 변화, 저장 공간 요구사항 등을 측정해야 합니다. 또한 데이터 증가에 따른 백업, 복구, 유지보수 작업의 성능도 고려해야 합니다. 하드웨어 리소스(CPU, 메모리, 디스크 I/O, 네트워크 대역폭) 사용률을 모니터링하여 어떤 리소스가 병목이 되는지 파악하고, 스케일업 또는 스케일아웃 전략을 계획해야 합니다.&lt;/p>
&lt;h3 id="장기-실행-테스트">장기 실행 테스트&lt;/h3>
&lt;p>데이터베이스 성능은 시간이 지남에 따라 변화할 수 있으므로, 장기 실행 테스트가 필요할 수 있습니다.&lt;/p>
&lt;p>LSM Tree 기반 데이터베이스는 시간이 지남에 따라 컴팩션 오버헤드가 누적될 수 있고, B-Tree 기반 데이터베이스는 메모리 단편화나 인덱스 불균형 문제가 발생할 수 있습니다. 따라서 단기 성능뿐만 아니라 며칠 또는 몇 주에 걸친 장기 실행 테스트를 통해 성능 저하 패턴을 분석해야 합니다.&lt;/p>
&lt;p>백그라운드 작업(컴팩션, 통계 업데이트, 백업 등)이 전체 시스템 성능에 미치는 영향도 평가해야 합니다. 또한 장애 상황(노드 장애, 디스크 오류 등) 후 복구 성능과 데이터 일관성도 테스트해야 합니다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>B-Tree 기반의 MySQL InnoDB와 LSM Tree 기반의 NoSQL 데이터베이스는 각각 고유한 성능 특성과 장단점을 가지고 있습니다. 전통적으로 RDBMS는 읽기에 최적화되어 있고, NoSQL은 쓰기에 최적화되어 있다고 여겨졌지만, 현대적인 데이터베이스 엔진들은 이러한 격차를 상당 부분 줄였습니다.&lt;/p>
&lt;p>MySQL InnoDB는 버퍼풀, 변경 버퍼, MVCC 등 다양한 최적화 기법을 통해 B-Tree의 전통적인 쓰기 성능 약점을 크게 개선했습니다. 이러한 최적화는 많은 일반적인 워크로드에서 NoSQL과 비교할 만한 쓰기 성능을 제공할 수 있게 했습니다. 또한 트랜잭션 특성, 강력한 일관성, 복잡한 쿼리 지원 등 RDBMS만의 강점을 유지하고 있습니다.&lt;/p>
&lt;p>반면, 대규모 쓰기 작업, 스키마리스 데이터 모델, 수평적 확장성, 지리적 분산 등이 필요한 특정 사례에서는 여전히 NoSQL 솔루션이 더 적합할 수 있습니다. 특히 초당 수십만 건 이상의 쓰기나 페타바이트 규모의 데이터를 다루는 환경에서는 NoSQL의 분산 아키텍처와 쓰기 최적화 설계가 큰 이점을 제공합니다.&lt;/p>
&lt;p>데이터베이스 선택에 있어 가장 중요한 것은 &amp;ldquo;어떤 데이터베이스가 더 좋은가&amp;quot;라는 단순한 질문이 아닌, 다음과 같은 실제 요구사항과 제약 조건을 종합적으로 고려하는 것입니다.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>워크로드 특성&lt;/strong>:
&lt;ul>
&lt;li>읽기/쓰기 비율, 쿼리 복잡성, 트랜잭션 요구사항&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>데이터 모델&lt;/strong>:
&lt;ul>
&lt;li>관계형 데이터 vs 비구조화 데이터, 스키마 변경 빈도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>확장성 요구사항&lt;/strong>:
&lt;ul>
&lt;li>데이터 증가 예측, 필요한 처리량, 확장 전략&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>운영 고려사항&lt;/strong>:
&lt;ul>
&lt;li>유지보수, 백업, 복구, 모니터링 용이성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>리소스 제약&lt;/strong>:
&lt;ul>
&lt;li>하드웨어 환경, 예산, 팀의 기술적 역량&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>또한, 현대적인 시스템 아키텍처에서는 단일 데이터베이스에 의존하기보다 다중 데이터베이스 접근법(polyglot persistence)을 채택하는 경우가 늘고 있습니다. 트랜잭션 처리에는 RDBMS를, 로깅이나 분석에는 NoSQL을 사용하는 방식으로, 각 부분에 가장 적합한 데이터 저장소를 선택하는 접근법입니다.&lt;/p>
&lt;p>무엇보다 중요한 것은 이론적인 성능 특성만으로 판단하지 말고, 실제 데이터와 워크로드를 사용한 벤치마크 테스트를 통해 결정을 검증하는 것입니다. 데이터베이스 성능은 특정 워크로드, 데이터 크기, 하드웨어 환경에 따라 크게 달라질 수 있으므로, 실제 환경과 유사한 조건에서의 테스트가 필수적입니다.&lt;/p>
&lt;p>결론적으로, MySQL InnoDB와 같은 현대적인 RDBMS는 다양한 최적화를 통해 쓰기 성능을 크게 개선했지만, 특정 사용 사례에서는 여전히 NoSQL의 장점이 두드러집니다. 데이터베이스 선택은 기술적인 특성뿐만 아니라 비즈니스 요구사항, 개발 생산성, 운영 비용 등을 종합적으로 고려한 균형 잡힌 접근이 필요합니다.&lt;/p></description></item><item><title>8. 분산 메일 서비스</title><link>https://codemario318.github.io/post/system-design-interview-2/8/</link><pubDate>Wed, 23 Oct 2024 13:53:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/8/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/cover.png" alt="Featured image of post 8. 분산 메일 서비스" />&lt;p>이번 장에서는 지메일, 아웃룩 같은 대규모 이메일 서비스를 설계해본다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>현대적 이메일 서비스는 다양한 기능을 갖춘 복잡한 시스템으로 발전했다. 따라서 짧은시간에 설계는 불가능하므로 질문을 통해 설계 범위를 좁혀야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;del>인증&lt;/del>&lt;/li>
&lt;li>이메일 발송/수신&lt;/li>
&lt;li>모든 이메일 가져오기&lt;/li>
&lt;li>읽음 여부에 따른 이메일 필터링&lt;/li>
&lt;li>제목, 발신인, 메일 내용에 따른 검색 기능&lt;/li>
&lt;li>스팸 및 바이러스 방지 기능&lt;/li>
&lt;li>프로토콜
&lt;ul>
&lt;li>SMTP, POP, IMAP 등과 같은 서비스 제공자 전용 프로토콜이 있으나 HTTP 사용한다고 가정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부파일 지원&lt;/li>
&lt;/ul>
&lt;h3 id="비기능적-요구사항">비기능적 요구사항&lt;/h3>
&lt;ul>
&lt;li>안정성
&lt;ul>
&lt;li>이메일 데이터는 소실되어선 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성
&lt;ul>
&lt;li>이메일과 사용자 데이터를 여러 노드에 자동으로 복제하여 가용성을 보장해야한다.&lt;/li>
&lt;li>부분적으로 장애가 발생해도 시스템은 계속 동작해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확정성
&lt;ul>
&lt;li>사용자 수가 늘어나더라도 감당할 수 있어야 한다.&lt;/li>
&lt;li>사용자나 이메일이 많아져도 시스템 성능은 저하되지 않아야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유연성과 확장성
&lt;ul>
&lt;li>새 컴포넌트를 더하여 쉽게 기능을 추가하고 성능을 개선할 수 있는 유연하고 확장성 높은 시스템이어야 한다.&lt;/li>
&lt;li>POP나 IMAP 같은 기존 이메일 프로토콜은 기능이 매우 제한적이므로, 요구사항을 만족하기 위해 맞춤형 프로토콜이 필요할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적인-규모-추정">개략적인 규모 추정&lt;/h3>
&lt;ul>
&lt;li>10억 사용자&lt;/li>
&lt;li>한 사람이 하루에 보내는 평균 이메일 수는 10건 가정
&lt;ul>
&lt;li>&lt;code>QPS = 10^9 * 10 / 10^5 = 100,000&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>한 사람이 하루에 수신하는 이메일 수는 평균 40건 가정&lt;/li>
&lt;li>메일 하나의 메타데이터는 평균 50KB로 가정(첨부파일 X)&lt;/li>
&lt;li>메타데이터는 데이터베이스에 저장한다고 가정
&lt;ul>
&lt;li>1년간 메타데이터를 유지하기 위한 스토리지 요구사항은 &lt;code>10억 사용자 * 하루 40건 * 365일 * 50KB = 730PB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부 파일을 포함하는 이메일의 비율은 20%, 평균 크기는 50KB 가정
&lt;ul>
&lt;li>1년간 첨부 파일을 보관하는 데 필요한 저장 용량은 &lt;code>10억 사용자 * 하루 40건 * 365 * 20% * 500KB = 1,460PB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>많은 데이터를 처리해야하므로 분산 데이터베이스 솔루션이 필요하다.&lt;/p>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>이메일 서버에 대해 알아야 할 기본적인 사항과 더불어 서버가 시간이 흐름에 따라 어떻게 진화하는지 논의한다.&lt;/p>
&lt;p>그 후 분산 이메일 서버의 개략적인 설계안을 살펴본다.&lt;/p>
&lt;h3 id="이메일-101">이메일 101&lt;/h3>
&lt;p>이메일을 주고받는 프로토콜에는 대부분 POP, IMAP, SMTP 같은 프로토콜을 사용해왔다.&lt;/p>
&lt;h4 id="이메일-프로토콜">이메일 프로토콜&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>SMTP&lt;/strong>(Simple Mail Transfer Protocol)
&lt;ul>
&lt;li>이메일을 한 서버에서 다른 서버로 보내는 표준 프로토콜&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>POP&lt;/strong>(Post Office Protocol)
&lt;ul>
&lt;li>이메일을 가져오는 목적으로 널리 사용&lt;/li>
&lt;li>이메일 클라이언트가 원격 메일 서버에서 이메일을 수신하고 다운로드하기 위해 사용하는 표준 프로토콜&lt;/li>
&lt;li>단말로 다운로드된 이메일은 서버에서 삭제
&lt;ul>
&lt;li>결과적으로 한 대 단말에서만 이메일을 읽을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일을 확인하기 위해 전부 내려받아야 함
&lt;ul>
&lt;li>용량이 큰 첨부 파일이 붙은 이메일은 읽으려면 시간이 오래걸림&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>IMAP&lt;/strong>(Internet Mail Access Protocol)
&lt;ul>
&lt;li>이메일을 가져오는 목적으로 널리 사용&lt;/li>
&lt;li>POP과 달리 클리하지 않으면 메시지는 다운로드 되지 않으며, 메일 서버에서 지워지지도 않음
&lt;ul>
&lt;li>여러 단말에서 이메일을 읽을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개인 이메일 계정에서 가장 널리 사용되는 프로토콜&lt;/li>
&lt;li>이메일을 실제로 열기 전에는 헤더만 다운로드
&lt;ul>
&lt;li>인터넷 속도가 느려도 잘 동작함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>HTTPS&lt;/strong>
&lt;ul>
&lt;li>메일 전송 프로토콜은 아니지만 웹 기반 이메일 시스템의 메일함 접속에 이용될 수 있음&lt;/li>
&lt;li>ex) 아웃룩의 액티브 싱크&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="dns---도메인-이름-서비스">DNS - 도메인 이름 서비스&lt;/h4>
&lt;p>수신자 도메인의 메일 교환기 레코드(Mail Exchange, MX) 검색에 이용된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img.png"
width="1494"
height="546"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_hub7f0eb4bd2d0a33dfc88796a278dea75_678809_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_hub7f0eb4bd2d0a33dfc88796a278dea75_678809_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MX 레코드"
class="gallery-image"
data-flex-grow="273"
data-flex-basis="656px"
>&lt;/p>
&lt;ul>
&lt;li>숫자는 우선순위 값으로 선호도를 나타내어 값이 낮으면 높은 우선순위로 처리됨&lt;/li>
&lt;/ul>
&lt;h4 id="첨부-파일">첨부 파일&lt;/h4>
&lt;p>첨부 파일은 이메일 메시지와 함께 전송되며 일반적으로 Base64 인코딩을 활용한다.&lt;/p>
&lt;p>일반적으로 첨부 파일에는 크기 제한이 있고, 설정 가능한 수치로, 개인 계정이냐 기업 계정이냐에 따라 다르게 설정된다.(필요한 만큼 알아서 설정한다)&lt;/p>
&lt;ul>
&lt;li>아웃룩 20MB, 지메일 25MB&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>MIME&lt;/strong>( Multi-purpose Internet Mail Extension)&lt;br>
인터넷을 통해 첨부 파일을 전송할 수 있도록 하는 표준 규격&lt;/p>
&lt;/blockquote>
&lt;h4 id="전통적-메일-서버">전통적 메일 서버&lt;/h4>
&lt;p>분산 메일 서버에 알아보기 전 기존 메일 서버의 역사와 동작 방식에 대해 살펴본다.&lt;/p>
&lt;p>전통적인 메일 서버는 보통 &lt;strong>서버 한 대로 운용되는, 사용자가 많지 않을 때 잘 동작하는 시스템&lt;/strong>이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>전통적 메일 서버 아키텍처&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_1.png"
width="1166"
height="928"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_1_hu802478e41453ab6fdfaa430529afc2d8_190128_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_1_hu802478e41453ab6fdfaa430529afc2d8_190128_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="전통적 메일 서버"
class="gallery-image"
data-flex-grow="125"
data-flex-basis="301px"
>&lt;/p>
&lt;ol>
&lt;li>보내기 버튼을 누르면 메일 서버로 전송된다.(SMTP)&lt;/li>
&lt;li>메일 서버는 DNS 질의를 통해 수신 SMTP 서버를 찾고 해당 서버로 이메일을 보낸다(SMTP)&lt;/li>
&lt;li>메일을 수신한 서버는 이메일을 저장하고 수신자가 읽어갈 수 있도록 한다.&lt;/li>
&lt;li>수신자가 로그인하면 IMAP/POP 서버를 통해 새 이메일을 가져온다.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>&lt;strong>저장소&lt;/strong>&lt;/p>
&lt;p>전통적 메일 서버는 &lt;strong>이메일을 파일 시스템의 디렉터리에 저장&lt;/strong>한다.&lt;/p>
&lt;p>각각의 이메일은 고유한 이름을 가진 별도 파일로 보관도며, 각 사용자의 설정 데이터와 메일함은 사용자 디렉터리에 보관한다.&lt;/p>
&lt;ul>
&lt;li>이러한 디렉터리 구조를 &lt;strong>Maildir&lt;/strong> 이라고 함&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_2.png"
width="920"
height="1166"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_2_hu2474c31464cc06986e6e832f2b67e40e_32499_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_2_hu2474c31464cc06986e6e832f2b67e40e_32499_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Maildir"
class="gallery-image"
data-flex-grow="78"
data-flex-basis="189px"
>&lt;/p>
&lt;p>파일과 디렉터리를 활용하는 방안은 사용자가 많지 않을 때는 잘 동작하나 디스크 I/O로 인한 병목으로 인해 수십억 개의 이메일을 검색하고 백업하는 목적으로 활용하기에는 곤란했다.&lt;/p>
&lt;p>그리고 &lt;strong>이메일을 서버의 파일 시스템에 보관&lt;/strong>하였기 때문에 &lt;strong>가용성과 안정성&lt;/strong> 요구사항도 만족할 수 없었기 때문에 더 안정적인 분산 데이터 저장소 계층이 필요했다.&lt;/p>
&lt;ul>
&lt;li>디스크 손상, 서버 장애 등&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이메일 기능은 1960년대에 발명된 이래로 텍스트 중심에서 멀티미디어, 메일 스레드, 검색, 레이블 등 다양한 기능을 지원하도록 발전해 왔지만, POP, IMAP, SMTP 같은 이메일 프로토콜은 이러한 기능을 지원하도록 설계되지 않았기 때문에 확장할 수 없었다.&lt;/p>
&lt;h3 id="분산-메일-서버">분산 메일 서버&lt;/h3>
&lt;p>분산 메일 서버는 현대적 사용 패턴을 지원하고 확장성과 안정성 문제를 해결한다.&lt;/p>
&lt;h4 id="이메일-api">이메일 API&lt;/h4>
&lt;p>이메일 API의 의미는 메일 클라이언트, 이메일 생명주기 단계마다 달라질 수 있다.&lt;/p>
&lt;ul>
&lt;li>모바일 단말 클라이언트를 위한 SMTP/POP/IMAP API&lt;/li>
&lt;li>송신 측 메일 서버와 수신 측 메일 서버 간의 SMTP 통신&lt;/li>
&lt;li>대화형 웹 기반 이메일 애플리케이션을 위한 HTTP 기반 RESTful API&lt;/li>
&lt;/ul>
&lt;p>이 책에서는 가장 중요한 API만 다루며, 웹메일 통신에는 일반적으로 HTTP 프로토콜이 쓰인다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>POST /v1/messages&lt;/code>&lt;/strong>&lt;/p>
&lt;p>To, Tc, Bcc 헤더에 명시된 수신자에게 메시지를 전송한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/folders&lt;/code>&lt;/strong>&lt;/p>
&lt;p>주어진 이메일 계정에 존재하는 모든 폴더를 반환한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">[{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;id&amp;#34;: string,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;name&amp;#34;: string,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;user_id&amp;#34;: string
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/folders/{:folder_id}/messages&lt;/code>&lt;/strong>&lt;/p>
&lt;p>주어진 폴더 아래의 모든 메시지를 반환한다.&lt;/p>
&lt;ul>
&lt;li>단순화한 명세로 페이지네이션을 지원해야 하는 등 훨씬 복잡할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/messages/{:message_id}&lt;/code>&lt;/strong>&lt;/p>
&lt;p>주어진 특정 메시지에 대한 모든 정보를 반환한다.&lt;/p>
&lt;p>메시지는 이메일 애플리케이션의 핵심 구성 요소이다.&lt;/p>
&lt;ul>
&lt;li>발신자, 수신자, 메시지 제목, 본문, 첨부 파일 등의 정보로 구성&lt;/li>
&lt;/ul>
&lt;h4 id="분산-메일-서버-아키텍처">분산 메일 서버 아키텍처&lt;/h4>
&lt;p>전통적인 이메일 서버가 단일 장비 위에서만 동작하도록 설계되었기 때문에 한 대 이상의 서버로 규모를 늘리는 것은 까다롭다.&lt;/p>
&lt;ul>
&lt;li>여러 서버 사이에 데이터를 동기화하는 것은 어려운 작업이다.&lt;/li>
&lt;li>수신자 메일 서버에서 이메일이 스팸으로 잘못 분류되지 않도록 하려면 까다로운 문제들을 풀어야한다.&lt;/li>
&lt;/ul>
&lt;p>이번 절에서는 클라우드 기술을 활용하여 이러한 문제를 쉽게 푸는 방법을 알아본다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_3.png"
width="1328"
height="1040"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_3_hu97293f0920808d780af3a4f7f2404b28_190471_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_3_hu97293f0920808d780af3a4f7f2404b28_190471_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="127"
data-flex-basis="306px"
>&lt;/p>
&lt;ul>
&lt;li>웹메일
&lt;ul>
&lt;li>사용자는 웹브라우저를 사용해 메일을 받고 보냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹서버
&lt;ul>
&lt;li>사용자가 이용하는 요청/응답 서비스로, 로그인, 가입, 사용자 프로파일 등에 대한 관리 기능을 담당&lt;/li>
&lt;li>본 설계안에서는 이메일 발송, 폴더 목록 확인, 폴더 내 모든 메시지 확인 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>실시간 서버
&lt;ul>
&lt;li>새로운 이메일 내역을 클라이언트에 실시간으로 전달한다.&lt;/li>
&lt;li>지속성 연결을 맺고 유지해야하므로 상태 유지 서버다.
&lt;ul>
&lt;li>롱폴링, 웹소켓 등&lt;/li>
&lt;li>웹소켓이 좀 더 우아하지만 브라우저 호환성 문제가 있을 수 있다.&lt;/li>
&lt;li>기본적으로는 웹 소켓을 쓰되 여의치 않으면 롱 폴링을 백업으로 이용할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 데이터베이스
&lt;ul>
&lt;li>이메일 제목, 본문, 발신인, 수신인 목록 등 메타 데이터를 저장하는 데이터베이스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부 파일 저장소
&lt;ul>
&lt;li>아마존 S3(Simple Storage Service) 같은 객체 저장소를 사용할 것이다.
&lt;ul>
&lt;li>이미지나 동영상 등의 대용량 파일을 저장하는 데 적합하고 확장이 용이한 인프라이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부파일 크기는 25MB로 제한한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>분산 캐시
&lt;ul>
&lt;li>최근에 수신된 이메일은 자주 읽을 가능성이 높으므로 클라이언트로 하여금 메모리에 캐시해 두도록 하면 메일을 표시하는 시간을 많이 줄일 수 있다.&lt;/li>
&lt;li>레디스
&lt;ul>
&lt;li>리스트와 같은 다양한 기능을 제공하고, 규모 확장이 용이하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>검색 저장소
&lt;ul>
&lt;li>검색 저장소는 분산 문서 저장소이다.&lt;/li>
&lt;li>고속 텍스트 검색을 지원하는 &lt;strong>역 인덱스&lt;/strong>를 자료 구조로 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>카산드라가 첨부 파일 저장소로 적합하지 않은 이유&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>카산드라가 BLOB 자료형을 지원하고 해당 자료형이 지원하는 데이터의 최대 크기가 2GB이긴 하지만 실질적으로는 1MB 이상의 파일은 지원하지 못한다.&lt;/li>
&lt;li>카산드라에 첨부 파일을 저장하면 첨부 파일이 너무 많은 메모리를 사용하게되어 레코드 캐시를 사용하기 어렵다.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="이메일-전송-절차">이메일 전송 절차&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_4.png"
width="1698"
height="1126"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_4_hu6c1accd62c346f29cf05623f72575dc4_306833_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_4_hu6c1accd62c346f29cf05623f72575dc4_306833_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이메일 전송 절차"
class="gallery-image"
data-flex-grow="150"
data-flex-basis="361px"
>&lt;/p>
&lt;ol>
&lt;li>사용자가 웹에서 메일을 정송하면 요청은 로드밸런서로 전송된다.&lt;/li>
&lt;li>로드벨런서가 처리율 제한 한도를 넘지 않는 선에서 요청을 웹 서버로 전달한다.&lt;/li>
&lt;li>웹 서버는 다음 역할을 담당한다.
&lt;ul>
&lt;li>기본적인 이메일 검증
&lt;ul>
&lt;li>이메일 크기 한도 같은 사전 미리 정의된 규칙을 사용하여 수신된 이메일을 검사한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>수신자 이메일 주소 도메인이 송신자 이메일 주소 도메인과 같은지 검사
&lt;ul>
&lt;li>이메일 내용의 스팸 여부와 바이러스 감염 여부를 검사&lt;/li>
&lt;li>검사를 통과한 이메일은 송신인의 보낸 편지함과 수신인의 받은 편지함에 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>수신인 측 클라이언트는 RESTful API를 사용하여 이메일을 바로 가져올 수 있어 4단계 이후는 수행할 필요가 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 큐
&lt;ol>
&lt;li>기본적인 검증을 통과한 이메일은 외부 전송 큐로 전달된다.
&lt;ul>
&lt;li>&lt;strong>첨부 파일의 크기가 너무 큰 이메일&lt;/strong>의 경우 &lt;strong>첨부 파일을 객체 저장소에 따로 저장&lt;/strong>하고 해당 &lt;strong>저장 위치에 대한 참조 정보만 저장&lt;/strong>한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>기본적인 검증에 실패한 이메일은 에러 큐에 보관한다.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>외부 전송 담당 SMTP 작엄 프로세스는 외부 전송 큐에서 메시지를 꺼내어 이메일의 스팸 및 바이러스 감염 여부를 확인한다.&lt;/li>
&lt;li>검증 절차를 통과한 이메일은 저장소 계층 내의 보낸 편지함에 저장된다.&lt;/li>
&lt;li>외부 전송 담당 SMTP 작업 프로세스가 수신자의 메일 서버로 메일을 전송한다.&lt;/li>
&lt;/ol>
&lt;p>외부 전송 큐에 보관되는 모든 메시지에는 &lt;strong>이메일을 생성하는 데 필요한 모든 메타데이터가 포함&lt;/strong>되어 있다.&lt;/p>
&lt;p>&lt;strong>분산 메시지 큐&lt;/strong>는 비동기적 메일 처리를 가능케 하는 핵심적 컴포넌트이다.&lt;/p>
&lt;ul>
&lt;li>웹 서버에서 외부 전송 담당 SMTP 프로세스를 분리함으로 전송용 SMTP 프로세스의 규모를 독립적으로 조정할 수 있게 된다.&lt;/li>
&lt;/ul>
&lt;p>외부 전송 큐의 크기를 모니터링 할 때 메일이 처리되지 않고 큐에 오랫동안 남아 있으면 그 이유를 분석해야한다.&lt;/p>
&lt;ul>
&lt;li>수신자 측 메일 서버에 장애 발생
&lt;ul>
&lt;li>나중에 메일을 다시 전송해야 한다.&lt;/li>
&lt;li>ex) 지수적 백오프(Exponential Backoff)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일을 보낼 큐의 소비자 수가 불충분
&lt;ul>
&lt;li>더 많은 소비자를 추가하여 처리 시간을 단축하는 방법을 생각해 볼 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="이메일-수신-절차">이메일 수신 절차&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_5.png"
width="1824"
height="946"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_5_hufa935ff62aaff4ec9a22919e7479ce7e_259381_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_5_hufa935ff62aaff4ec9a22919e7479ce7e_259381_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이메일 수신 절차"
class="gallery-image"
data-flex-grow="192"
data-flex-basis="462px"
>&lt;/p>
&lt;ol>
&lt;li>이메일이 SMTP 로드밸런서에 도착&lt;/li>
&lt;li>트래픽을 여러 SMTP 서버로 분산
&lt;ul>
&lt;li>SMTP 연결에는 이메일 수락 정책을 구성하여 적용 가능&lt;/li>
&lt;li>유효하지 않은 이메일은 방송하도록 하여 불필요한 이메일 처리를 피할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일의 첨부 파일이 큐에 들어가기 너무 큰 경우 첨부 파일 저장소(S3)에 보관&lt;/li>
&lt;li>이메일을 수신 이메일 큐에 넣는다
&lt;ul>
&lt;li>메일 처리 작업 프로세스와 SMTP 간 결합도를 낮추어 각자 독립적으로 규모 확장이 가능하도록 함&lt;/li>
&lt;li>수신 이메일이 폭증하는 경우 버퍼 역할도 하게됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메일 처리 작업 프로세스(worker)는 스팸 메일을 걸러내고 바이러스를 차단하는 등의 다양한 역할 담당
&lt;ul>
&lt;li>이후 처리는 검증 작업이 끝난 이메일을 대상으로 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일을 메일 저장소, 캐시, 객체 저장소 등에 보관&lt;/li>
&lt;li>수신자가 온라인 상태일 경우 실시간 서버로 전달&lt;/li>
&lt;li>실시간 서버는 수신자 클라이언트가 새 이메일을 실시간으로 받을 수 있도록 하는 웹소켓 서버&lt;/li>
&lt;li>오프라인 상태 사용자의 이메일은 저장소 계층에 보관
&lt;ul>
&lt;li>온라인 상태가 되면 클라이언트가 웹 서버에 RESTful API를 통해 열결됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>새로운 이메일을 저장소 계층에서 가져와 클라이언트에 반환&lt;/li>
&lt;/ol>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>몇 가지 핵심 요소에 대해 더 자세히 알아보고 규모 확장 방안을 점검한다.&lt;/p>
&lt;h3 id="메타데이터-데이터베이스">메타데이터 데이터베이스&lt;/h3>
&lt;p>이메일 메타데이터의 특성을 알아보고 올바른 데이터베이스와 데이터 모델을 고르는 문제, 이메일 스레드 지원 방안에 대해 알아본다.&lt;/p>
&lt;h4 id="이메일-메타데이터의-특성">이메일 메타데이터의 특성&lt;/h4>
&lt;ul>
&lt;li>이메일의 헤더는 일반적으로 작고, 빈번하게 이용&lt;/li>
&lt;li>이메일 본문의 크기는 다양하지만 사용 빈도는 낮음
&lt;ul>
&lt;li>일반적으로 한 번만 읽음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일 가져오기, 읽은 메일로 표시, 검색 등의 이메일 관련 작업은 사용자 별로 격리 수행되어야함
&lt;ul>
&lt;li>어떤 사용자의 이메일은 해당 사용자만 읽을 수 있어야함&lt;/li>
&lt;li>이메일에 대한 작업도 그 사용자만이 수행할 수 있어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 신선도는 데이터 사용 패턴에 영향을 미침
&lt;ul>
&lt;li>사용자는 보통 최근 메일만 읽음&lt;/li>
&lt;li>만들어진 지 16일 이하에 발생하는 읽기 질의 비율은 전체 질의의 82%에 달함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터의 높은 안정성이 보장되어야 함
&lt;ul>
&lt;li>&lt;strong>데이터 손실은 용납되지 않음&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="올바른-데이터베이스의-선정">올바른 데이터베이스의 선정&lt;/h4>
&lt;p>지메일이나 아웃룩 정도의 규모가 되면 시스템의 부하로 인해, 초당 입/출력 연산 빈도(Input/Output Operations Per Second, IOPS)를 낮추기 위한 맞춤 제장 데이터베이스를 사용한다.&lt;/p>
&lt;p>올바른 데이터베이스 선택은 쉽지 않은데, 가능한 모든 선택지를 미리 살펴보면 도움이 된다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>관계형 데이터베이스&lt;/strong>&lt;/p>
&lt;p>관계형 데이터베이스를 고르는 주된 동기는 이메일을 효율적으로 검색할 수 있다는 장점 때문이다.&lt;/p>
&lt;ul>
&lt;li>이메일 헤더와 본문에 대한 인덱스를 만들면 효율적으로 검색할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>하지만 관계형 데이터베이스는 데이터 크기가 작을 때 적합하다.&lt;/p>
&lt;ul>
&lt;li>이메일은 수 KB보다 크고 HTML이 포함되면 쉽게 100KB를 넘어간다.&lt;/li>
&lt;li>BLOB 자료형을 쓰면 큰 이메일도 처리할 수 있으나, 비정형 BLOB에 대한 검색 질의 성능은 좋지 않다.
&lt;ul>
&lt;li>BLOB이 고정된 크기 페이지를 연결하여 큰 데이터를 저장하도록 하고 있어 해당 컬럼의 데이터를 접근할 때마다 많은 디스크 I/O가 발생한다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>따라서 관계형 데이터베이스는 바람직하지 않다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>분산 객체 저장소&lt;/strong>&lt;/p>
&lt;p>이메일의 원시 데이터를 그대로 아마존 S3 같은 객체 저장소에 보관하는 방법도 고려할 수 있다.&lt;/p>
&lt;p>하지만 객체 저장소는 백업 데이터를 보관하기에는 좋지만 이메일의 읽음 표시, 키워드 검색, 이메일 스레드 드의 기능을 구현하기에 그다지 좋지 않다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>NoSQL 데이터베이스&lt;/strong>&lt;/p>
&lt;p>지메일은 구글 빅테이블을 저장소로 사용하는데 충분히 실현 가능한 방안이다.&lt;/p>
&lt;p>하지만 빅테이블은 오픈소스로 공개되어 있지 않고 이메일 검색을 빅테이블 위에서 어떻게 구현했는지는 공개되어있지않다.&lt;/p>
&lt;p>카산드라가 좋은 대안이 될 수도 있지만 대형 이메일 서비스 제공 업체 가운데 카산드라를 사용하는 곳은 아직 확인된 바가 없다.&lt;/p>
&lt;hr>
&lt;p>위 후보들을 봤을 때 본 설계안이 필요로 하는 기능을 완벽히 지원하는 데이터베이스는 없다고 봐도 좋을 것 같다.&lt;/p>
&lt;p>이러한 이유로 대형 이메일 서버스 업체는 대체로 독자적인 데이터베이스 시스템을 만들어 사용한다.&lt;/p>
&lt;p>이러한 데이터베이스를 설계하기엔 시간이 부족하므로, 해당 데이터베이스가 아래와 같은 조건을 충족해야 한다는 점을 설명할 수 있어야한다.&lt;/p>
&lt;ul>
&lt;li>어떤 단일 컬럼의 크기는 한 자리수의 MB 정도일 수 있다.&lt;/li>
&lt;li>강력한 데이터 일관성이 보장되어야 한다.&lt;/li>
&lt;li>디스크 I/O가 최소화되도록 설계되어야 한다.&lt;/li>
&lt;li>가용성이 아주 높아야 하고 일부 장애를 감내할 수 있어야 한다.&lt;/li>
&lt;li>증분 백업(incremental backup)이 쉬워야 한다.&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-모델">데이터 모델&lt;/h4>
&lt;p>데이터를 저장하는 한 가지 방법은 &lt;code>user_id&lt;/code>를 파티션 키로 사용하여 특정한 사용자의 데이터는 항상 같은 샤드에 보관하는 것이다.&lt;/p>
&lt;ul>
&lt;li>메시지를 여러 사용자와 공유할 수 없지만 요구사항과는 관계 없다.&lt;/li>
&lt;/ul>
&lt;p>기본 키는 파티션 키(partition key)와 클러스터 키(clustering key)의 두 가지 부분으로 구성된다.&lt;/p>
&lt;ul>
&lt;li>파티션 키
&lt;ul>
&lt;li>데이터를 여러 노드에 분산하는 기준&lt;/li>
&lt;li>데이터가 모든 노드에 균등하게 분산되도록 하는 파티션 키를 골라야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클러스터 키
&lt;ul>
&lt;li>파티션에 속한 데이터를 정렬하는 기준&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>개략적으로 이메일 서비스의 데이터 계층은 다음과 같은 질의를 지원해야 한다.&lt;/p>
&lt;ul>
&lt;li>주어진 사용자의 모든 폴더를 구한다.&lt;/li>
&lt;li>특정 폴더 내의 모든 이메일을 표시한다.&lt;/li>
&lt;li>메일을 생성, 삭제, 조회한다.&lt;/li>
&lt;li>읽은 메일 전부, 또는 읽지 않은 메일 전부를 가져온다.&lt;/li>
&lt;li>이메일 스레드를 전부 가져온다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_6.png"
width="856"
height="518"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_6_hu00ad76f03bcbd533c2a84dbc6e348eb4_89085_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_6_hu00ad76f03bcbd533c2a84dbc6e348eb4_89085_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="키 구성"
class="gallery-image"
data-flex-grow="165"
data-flex-basis="396px"
>&lt;/p>
&lt;p>&lt;strong>질의 1: 특정 사용자의 모든 폴더 질의&lt;/strong>&lt;/p>
&lt;p>파티션 키는 &lt;code>user_id&lt;/code>다. 따라서 어떤 사용자의 모든 폴더는 같은 파티션 안에 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_7.png"
width="872"
height="544"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_7_hu156bc7a2fc679faefe0f0978519d3cb5_79626_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_7_hu156bc7a2fc679faefe0f0978519d3cb5_79626_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="사용자 별 폴더 목록"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="384px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>질의 2: 특정 폴더에 속한 모든 이메일 표시&lt;/strong>&lt;/p>
&lt;p>사용자가 자기 메일 폴더를 열면 이메일은 가장 최근 이메일부터 오래된 것 순으로 정렬되어 표시된다.&lt;/p>
&lt;p>같은 폴더에 속한 모든 이메일이 같은 파티션에 속하도록 하려면 &lt;code>&amp;lt;user_id, foler_id&amp;gt;&lt;/code> 형태의 복합 파티션 키를 사용해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_9.png"
width="876"
height="982"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_9_hu41305bc042d3fec07ebe69ff8294aa6a_136085_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_9_hu41305bc042d3fec07ebe69ff8294aa6a_136085_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="폴더별 이메일"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="214px"
>&lt;/p>
&lt;p>&lt;code>email_id&lt;/code>의 자료형은 &lt;code>TIMEUUID&lt;/code>로 이메일을 시간순으로 정렬하는 데 사용되는 클러스터 키다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>질의 3: 이메일 생성/삭제/수신&lt;/strong>&lt;/p>
&lt;p>이메일 상세 정로를 가져오는 방법을 살펴본다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">emails_by_user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">email_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">123&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이 질의를 지원하기 위해 두 테이블이 필요하다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_10.png"
width="1328"
height="642"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_10_hucad2710252b37d32d309b4b9de9854c5_132150_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_10_hucad2710252b37d32d309b4b9de9854c5_132150_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="사용자별 이메일"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="496px"
>&lt;/p>
&lt;p>한 이메일에는 여러 첨부 파일이 있을 수 있으므로, &lt;code>email_id&lt;/code>, &lt;code>filename&lt;/code> 필드를 같이 사용하면 모든 첨부 파일을 질의할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>질의 4: 읽은, 또는 읽지 않은 모든 메일&lt;/strong>&lt;/p>
&lt;p>관계형 데이터베이스로 도메인 모델을 구현하는 경우, 읽은 메일 전부는 다음과 같이 질의할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">emails_by_folder&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">is_read&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">email_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>본 설계안의 데이터모델은 NoSQL로 보통 파티션 키와 클러스터 키에 대한 질의만 허용하므로 &lt;code>emails_by_folder&lt;/code> 테이블의 &lt;code>is_read&lt;/code> 필드는 이에 해당하지 않기 때문에 대부분의 NoSQL 데이터베이스에서는 위 쿼리를 실행할 수 없다.&lt;/p>
&lt;p>이 문제를 해결하기 위한 방법으로 &lt;strong>주어진 폴더에 속한 모든 메시지를 가져온 다음 애플리케이션 단에서 필터링&lt;/strong> 해줄 수 있다.&lt;/p>
&lt;ul>
&lt;li>대규모 서비스에는 적합하지 않다.&lt;/li>
&lt;/ul>
&lt;p>따라서 이런 문데는 NoSQL 데이터베이스 테이블을 비정규화(denormalization)하여 해결하는 것이 보통이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>emails_by_folder&lt;/code> 테이블을 두 테이블로 분할한다.&lt;/li>
&lt;li>&lt;code>read_emails&lt;/code>: 읽은 상태의 모든 이메일을 보관&lt;/li>
&lt;li>&lt;code>unread_eamils&lt;/code>: 읽지 않은 모든 이메일을 보관&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_11.png"
width="1288"
height="568"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_11_hueb1288bc525b10d750ab98ffc79e7b70_139881_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_11_hueb1288bc525b10d750ab98ffc79e7b70_139881_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비정규화"
class="gallery-image"
data-flex-grow="226"
data-flex-basis="544px"
>&lt;/p>
&lt;p>특정 폴더 안의 읽지 않은 모든 메일을 가져오는 질의는 다음과 같이 표현될 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">unread_mails&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">email_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이러한 비정규화는 흔한 관행으로, 애플리케이션 코드가 좀 더 복잡해지고 관리하기 까다로워지지만, 질의 성능은 대규모 서비스에 어울리는 수준으로 개선한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>보너스: 이메일 스레드 가져오기&lt;/strong>&lt;/p>
&lt;p>이메일 스레드는 많은 이메일 클라이언트가 지원하는 기능으로 모든 답장을 최초 메시지에 스레드로 엮어 보여주는 기능이다.&lt;/p>
&lt;p>사용자가 특정한 대화에 관련된 모든 메일을 한 번에 확인할 수 있게된다.&lt;/p>
&lt;ul>
&lt;li>전통적으로 &lt;strong>JWZ&lt;/strong> 같은 알고리즘을 통해 구현한다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;headers&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;Message-Id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;7BA04B2A-430C-4D12-8B57-862103C34501@gmail.com&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;In-Reply-To&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;CAEWTXuPfN=LzECjDJtgY9Vu03kgFvJnJUSHTt6TW@gmail.com&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;References&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;lt;7BA04B2A-430C-4D12-8B57-862103C34501@gmail.com&amp;gt;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>Message-Id&lt;/strong>
&lt;ul>
&lt;li>메시지 식별자&lt;/li>
&lt;li>메시지를 보내는 클라이언트가 생성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>In-Reply-To&lt;/strong>
&lt;ul>
&lt;li>어떤 메시지가 어떤 메시지에 대한 답신인지 나타내는 식별자&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>References&lt;/strong>
&lt;ul>
&lt;li>스레드에 관계된 메시지 식별자 목록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 필드들로 이메일 클라이언트는 타래 내의 모든 메시지가 사전에 메모리에 로드되어 있는 경우 전체 대화 스레드를 재구성해 낼 수 있게된다.&lt;/p>
&lt;h4 id="일관성-문제">일관성 문제&lt;/h4>
&lt;p>높은 가용성을 달성하기 위해 다중화에 의존하는 분산 데이터베이스는 데이터 일관성과 가용성 사이에서 타협적인 결정을 내릴 수 밖에 없다.&lt;/p>
&lt;p>이메일 시스템의 경우 &lt;strong>데이터의 정확성이 아주 중요&lt;/strong>하므로, 모든 메일함은 반드시 하나의ㅏ 주 사본을 통해 서비스된다고 가정해야한다.&lt;/p>
&lt;p>따라서 장애가 발생하면 클라이언트는 다른 사본을 통해 주 사본이 복원될 때까지 동기화/갱신 작업을 완료할 수 없다.&lt;/p>
&lt;ul>
&lt;li>일관성을 위해 가용성을 희생한다.&lt;/li>
&lt;/ul>
&lt;h3 id="이메일-전송-가능성">이메일 전송 가능성&lt;/h3>
&lt;p>메일 서버를 구성하고 이메일을 보내는 것은 쉽지만 특정 사용자의 메일함에 실제로 메일이 전달되도록 하는 것은 어려운 문제이다.&lt;/p>
&lt;p>이메일이 &lt;strong>스팸 폴더&lt;/strong>에 들어가 버리면 수신자가 메일을 읽을 가능성은 아주 낮아진다.&lt;/p>
&lt;ul>
&lt;li>연구에 따르면 메일 가운데 50%가 그팸으로 분류된다.&lt;/li>
&lt;/ul>
&lt;p>새로 구성한 메일 서버는 인터넷에서 좋은 평판을 쌓을 기회가 전혀 없었기 때문에 보내는 메일이 대부분 스팸 폴더로 떨어진다.&lt;/p>
&lt;p>따라서 이메일의 전송 가능성을 높이기 이ㅜ해서 다음과 같은 요소들을 고려한다.&lt;/p>
&lt;ul>
&lt;li>전용 IP
&lt;ul>
&lt;li>전용 IP 주소를 사용하라&lt;/li>
&lt;li>대부분의 이메일 서비스 사업자는 아무 이력이 없는 IP 새로운 IP 주소에서 온 메일을 무시한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>범주화
&lt;ul>
&lt;li>범주가 다른 이메일은 다른 IP 주소를 통해 보내라&lt;/li>
&lt;li>마케팅 목적의 메일을 중요한 이메일과 같은 서버에서 발송하면 ISP가 모든 이메일을 판촉 메일로 분류할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>발신인 평판
&lt;ul>
&lt;li>새로운 이메일 서버의 IP 주소는 사용 빈도를 서서히 올리는 것이 좋다.&lt;/li>
&lt;li>그래야 좋은 평판이 쌓여 해당 IP 주소에서 발송되는 메일을 스팸으로 분류할 가능성이 낮아진다.&lt;/li>
&lt;li>아마존 SES에 따르면 새로운 IP 주소를 메일 발송해 아무 문제 없이 쓸 수 있게 되는 데는 대략 2 ~ 6주가 소요된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>스팸 발송자의 신속한 차단
&lt;ul>
&lt;li>스팸을 뿌리는 사용자는 서버 평판을 심각하게 훼손하기 전에 시스템에서 신속히 차단한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>피드백 처리
&lt;ul>
&lt;li>불만 신고가 접수되는 비율을 낮추고 스팸 계정을 신속히 차단하기위해서는 ISP 측에서의 피드백을 쉽게 받아 처리할 수 있는 경로를 만드는 것이 중요하다.&lt;/li>
&lt;li>이메일이 전달되지 못하거나 사용자로부터 불만 신고가 접수된 경우 다음과 같은 일들이 벌어질 수 있다.
&lt;ul>
&lt;li>경성 반송(hard bounce)
&lt;ul>
&lt;li>수신인의 이메일 주소가 올바르지 않아 ISP가 전달을 거부한 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>연성 반송(soft bounce)
&lt;ul>
&lt;li>ISP 측의 이메일 처리 자원 부족 등의 이유로 일시적으로 이메일을 전달할 수 없었던 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>불만 신고(complaint)
&lt;ul>
&lt;li>수신인이 스팸으로 신고 버튼을 누르는 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일 인증
&lt;ul>
&lt;li>2018년도 데이터 유출 조사 보고서에 따르면 ㅍ피싱이나 프리텍스팅이 전체 유철 사고에서 차지하는 비중은 93%에 달한다.&lt;/li>
&lt;li>보편적으로 SPF(Sender Policy Framework), DKIM(DomainKeys Identified Mail), DMARC(Domain-based Message Authentication, Reporting and Conformance) 등으로 피싱에 대응한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>명심해야할 점은 이메일이 목적지에 성공적으로 도착하도록 하기 어렵다는 사실이다. 도메인 지식은 물론 ISP와 좋은 관계를 유지할 필요도 있다.&lt;/p>
&lt;h3 id="검색">검색&lt;/h3>
&lt;p>기본적인 이메일 검색은 보통 이메일 제목이나 본문에 특정 키워드가 포함되었는지 찾는 것을 뜻하며, 고급 기능에는 발신인, 제목, 읽지 않음 같이 메일 속성에 따른 필터링 기능이 포함된다.&lt;/p>
&lt;p>검색 기능을 제공하려면 이메일이 전송, 수신, 삭제 될 때마다 색인(indexing) 작업을 수행해야 한다.&lt;/p>
&lt;p>그에 반해 검색은 사용자가 검색 버튼을 누를 때만 실행되므로, 이메일 시스템의 검색 기능에서는 쓰기 연산이 읽기 연산보다 훨씬 많이 발생한다.&lt;/p>
&lt;p>검색 기능을 지원하기 위해 일래스틱서치(ElasticSearch)를 이용하는 방안과 데이터 저장소에 내장된 기본 검색 기능을 활용하는 방안의 두 가지 선택지를 비교해본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>방안 1: 일래스틱서치&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_12.png"
width="1210"
height="1224"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_12_hu3000d4f01569124c541bea50802fb702_56268_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_12_hu3000d4f01569124c541bea50802fb702_56268_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="일래스틱 서치"
class="gallery-image"
data-flex-grow="98"
data-flex-basis="237px"
>&lt;/p>
&lt;p>질의가 대부분 사용자의 이메일 서버에서 실행되므로 &lt;code>user_id&lt;/code>를 파티션 키로 사용하여 같은 사용자의 이메일은 같은 노드에 묶어 놓는다.&lt;/p>
&lt;ul>
&lt;li>사용자가 검색 버튼을 누른 다음 결과가 수신될 때 까지 기다리므로, 검색 요청은 동기 방식으로 처리되어야 한다.&lt;/li>
&lt;li>이메일 전송, 이메일 수신, 이메일 삭제 같은 이벤트는 처리 결과를 클라이언트로 전달할 필요는 없으며, 추가로 색인 작업이 필요하다.&lt;/li>
&lt;/ul>
&lt;p>본 설계안은 카프카를 활용하여 색인 작업을 시작하는 서비스와 실제로 색인을 수행할 서비스 사이의 결합도를 낮추는 방안을 채택한다.&lt;/p>
&lt;ul>
&lt;li>일래스틱서치는 2021년 6월 기준으로 가장 널리 사용되고 있는 검색 엔진 데이터베이스이며 이메일 검색에 필요한 텍스트 기반 검색을 잘 지원한다.&lt;/li>
&lt;/ul>
&lt;p>일래스틱서치를 사용할 경우 주 이메일 저장소와 동기화를 맞추는 부분이 까다롭다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>방안 2: 맞춤형 검색 솔루션&lt;/strong>&lt;/p>
&lt;p>대규모 이메일 서비스 사업자는 보통 자기 제품에 고유한 요구사항을 만족시키기 위해 검색 엔진을 자체적으로 개발해 사용한다.&lt;/p>
&lt;p>매우 어렵고 범위를 넘어서기 때문에 자체적으로 검색 솔루션을 구현하는 경우 마주하게 될 주요 과제인 디스크 I/O 병목 문제를 살펴본다.&lt;/p>
&lt;p>개략적 규모 추정 결과 메타 데이터와 첨부 파일은 매일 페타바이트 수준으로 저장소에 추가되며, 하나의 이메일 계정에 몇십 만개 넘는 이메일이 저장되는 것도 흔하다.&lt;/p>
&lt;ul>
&lt;li>따라서 메일 색인 서버의 주된 병복은 보통 디스크 I/O다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_13.png"
width="1926"
height="1002"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_13_hu495b352c0880296eb3398fcf25077ab9_380701_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_13_hu495b352c0880296eb3398fcf25077ab9_380701_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="LSM 트리"
class="gallery-image"
data-flex-grow="192"
data-flex-basis="461px"
>&lt;/p>
&lt;p>색인을 구축하는 프로세스는 다량의 쓰기 연산을 발생시킬 수 밖에 없으므로 LSM(Log-Structured Merge)트리를 사용하여 &lt;strong>디스크에 저장되는 색인을 구조화하는 것이 바람직한 전략&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>쓰기 경로는 순차적 쓰기 연산(sequential write)만 수행하도록 최적화 되어있다.&lt;/li>
&lt;li>빅테이블이나 카산드라, RocksDB 같은 데이터베이스의 핵심 자료 구조다.&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>새로운 이메일이 도착하면 우선 메모리 캐시로 구현되는 0번 계층에 저장된다.&lt;/li>
&lt;li>메모리에 보관된 데이터의 양이 사전에 정의된 임계치를 넘으면 데이터는 다음 계층에 병합된다.&lt;/li>
&lt;/ol>
&lt;p>자주 바뀌는 데이터를 그렇지 않은 데이터와 분리하는 효과도 얻을 수 있다.&lt;/p>
&lt;ul>
&lt;li>이메일 데이터는 보통 바뀌지 않지만 메일 폴더의 정보는 상이한 필터링 규칙들 때문에 자주 바뀌는 경향이 있다.&lt;/li>
&lt;li>데이터를 두 개 파트로 나누거 어떤 요청이 폴더 변경에 관한 것 이면 폴더 정보만 바꾸고 이메일 데이터는 내벼려둔다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>소규모의 이메일 시스템을 구축하는 경우 통합하기 쉽고 엔지니어링에 많은 노력이 필요하지 않은 일래스틱서치가 좋은 선택지이다.&lt;/p>
&lt;p>대규모 시스템을 구축하는 경에도 일래스틱서치를 사용할 수 있겠지만 이메일 검색 인프라를 개발하고 관리하는 전담 팀이 필요할 수 있다.&lt;/p>
&lt;p>지메일이나 아웃룩 규모의 이메일 시스템을 지원하려면 독립적인 검색 전용 시스템을 두기보다는 데이터베이스에 내장된 전용 검색 솔루션을 사용하는 것이 바람직할 수도 있다.&lt;/p>
&lt;h3 id="규모-확장성-및-가용성">규모 확장성 및 가용성&lt;/h3>
&lt;p>각 사용자의 데이터 접근 패턴은 다른 사용자와 무고나하므로, 시스템의 대부분 컴포넌트는 수평적으로 규모 확장이 가능할 것으로 기대할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_14.png"
width="1362"
height="1260"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_14_hu7aa95457bd45ad9d0fc44f5368731ee7_86292_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_14_hu7aa95457bd45ad9d0fc44f5368731ee7_86292_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="시스템 다중화"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="259px"
>&lt;/p>
&lt;p>가용성을 향상시키기 위해서는 데이터를 여러 데이터센터에 다중화하는 것이 필요하다.&lt;/p>
&lt;ul>
&lt;li>자신과 물리적으로 가까운 메일 서버와 통신한다.&lt;/li>
&lt;li>네트워크 파티션 발생시 다른 데이터센터에 보관된 메시지를 이용한다.&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>면접장에서 시간이 남는다면 추가로 논의해 볼 만한 주제로는 다음과 같은 것들이 있다.&lt;/p>
&lt;ul>
&lt;li>결함 내성
&lt;ul>
&lt;li>노드 장애, 네트워크 문제, 이벤트 전달 지연 등의 문제에 어떻게 대처할지 살펴보면 좋을 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규정 준수
&lt;ul>
&lt;li>전 세계 다양한 시스템과 연동해야 하고 각 나라에는 준수해야할 법규가 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>보안
&lt;ul>
&lt;li>민감한 정보가 포함되므로 보안이 매우 중요하다.&lt;/li>
&lt;li>피싱 방지, 안전 브라우징, 첨부 파일 사전 경고, 계정 안전, 기밀 모드, 이메일 암호화 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>최적화
&lt;ul>
&lt;li>같은 이메일이 여러 수신자에 전송되는 경우 동일한 첨부 파일이 있는지 확인하는 방식으로 최적화를 진행할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>7. 호텔 예약 시스템</title><link>https://codemario318.github.io/post/system-design-interview-2/7/</link><pubDate>Sat, 12 Oct 2024 14:59:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/7/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/cover.png" alt="Featured image of post 7. 호텔 예약 시스템" />&lt;p>이번 장에서는 호텔 체인의 예약 시스템을 설계한다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>호텔 예약 시스템은 복잡하고 그 컴포넌트는 시스템을 사업에 어떻게 이용할지에 따라 달라지므로 범위를 명확히 해야한다.&lt;/p>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>높은 수준의 동시성 지원
&lt;ul>
&lt;li>성수기, 대규모 이벤트 기간에는 일부 인기 호텔의 특정 객실을 예약하려는 고객이 많이 몰릴 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>적절한 지연 시간
&lt;ul>
&lt;li>사용자가 예약을 할 때는 응답 시간이 빠르면 이상적이겠으나 &lt;strong>예약 요청 처리&lt;/strong>에 &lt;strong>몇 초 정도&lt;/strong> 걸리는 것은 괜찮다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;ul>
&lt;li>총 5,000개 호텔, 100만 개의 객실이 있다고 가정&lt;/li>
&lt;li>평균 &lt;strong>객실의 70%가 사용 중&lt;/strong>, 평균 &lt;strong>투숙 기간은 3일&lt;/strong>이라고 가정&lt;/li>
&lt;li>&lt;code>일일 예상 예약 건수 = (1백만 * 0.7) / 3 ~= 240,000&lt;/code>&lt;/li>
&lt;li>&lt;code>초당 예약 건수 = 240,000 / 하루에 10^5초 ~= 3&lt;/code>
&lt;ul>
&lt;li>초당 예약 트랜잭션 수(TPS)는 높지 않다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>시스템 내 모든 페이지의 QPS를 계산해본다.&lt;/p>
&lt;p>호텔 예약 시스템은 일반적으로 고객이 아래와 같은 흐름을 거친다.&lt;/p>
&lt;ol>
&lt;li>호텔/객실 상세 페이지
&lt;ul>
&lt;li>사용자가 호텔/객실 정보를 확인한다.(조회)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예약 상세 정보 페이지
&lt;ul>
&lt;li>날짜, 투숙 인원, 결제 방법 등의 상세 정보를 예약 전에 확인한다.(조회)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객실 예약 페이지
&lt;ul>
&lt;li>사용자가 &amp;lsquo;예약&amp;rsquo; 버튼을 눌러 객실을 예약한다.(트랜잭션 발생)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img.png"
width="1290"
height="630"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_hudca757551e48c8d1d2e333630b9f6cbe_51951_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_hudca757551e48c8d1d2e333630b9f6cbe_51951_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="QPS 분포"
class="gallery-image"
data-flex-grow="204"
data-flex-basis="491px"
>&lt;/p>
&lt;p>대략 10%의 사용자가 간 단계에서 다음 단계를 진행한다고 가정하면 최종 예약 TPS는 3이므로, 예약 페이지의 QPS는 30, 객실 정보 확인 페이지의 QPS는 300이다.&lt;/p>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="api-설계">API 설계&lt;/h3>
&lt;p>호텔 예약 시스템의 가장 중요한 API만 RESTful 관례에 따라 표현하면 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>검색 기능 등의 직관적인 기능도 필요하나, 기술적으로 도전적이지는 않다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>호텔 관련 API&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/hotels/id&lt;/td>
&lt;td>호텔의 상세 정보 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST /v1/hotels&lt;/td>
&lt;td>신규 호텔 추가(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PUT /v1/hotels/id&lt;/td>
&lt;td>호텔 정보 갱신(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE /v1/hotels/id&lt;/td>
&lt;td>호텔 정보 삭제(관리자)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>객실 관련 API&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/hotels/:id/rooms/id&lt;/td>
&lt;td>객실 상세 정보 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST /v1/hotels/:id/rooms&lt;/td>
&lt;td>신규 객실 추가(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PUT /v1/hotels/:id/rooms/id&lt;/td>
&lt;td>객실 정보 갱신(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE /v1/hotels/:id/rooms/id&lt;/td>
&lt;td>객실 정보 삭제(관리자)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>예약 관련 API&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/reservations&lt;/td>
&lt;td>로그인 사용자의 예약 이력 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GET /v1/reservations/id&lt;/td>
&lt;td>특정 예약의 상세 정보 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST /v1/reservations&lt;/td>
&lt;td>신규 예약&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE /v1/reservations/id&lt;/td>
&lt;td>예약 취소&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>신규 예약 접수는 아주 중요한 기능으로, 새 예약을 만들 때 전달하는 인자의 형태는 아래와 같은데&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;startDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-28&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;endDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-30&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;hotelID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;245&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;roomID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;U12354673389&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;reservationID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;13422445&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>researvationID&lt;/code>는 &lt;strong>이중 예약을 방지하고 동일한 예약은 단 한 번만 이루어지도록 보증하는 멱등 키(idempotent key)다.&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>멱등성?&lt;/strong>
연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질&lt;/p>
&lt;/blockquote>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>어떤 데이터베이스를 사용할지 결정하기위해 데이터 접근 패턴을 확인해야한다.&lt;/p>
&lt;ol>
&lt;li>호텔 상세 정보 확인&lt;/li>
&lt;li>지정된 날짜 범위에 사용 가능한 객실 유형 확인&lt;/li>
&lt;li>예약 정보 기록&lt;/li>
&lt;li>예약 내역 또는 과거 예약 이력 정보 조회&lt;/li>
&lt;/ol>
&lt;p>시스템 규모가 크지 않지만 대규모 이벤트 등으로 인해 트래픽이 급증할 수도 있으니 대비가 필요하다.&lt;/p>
&lt;p>이런 요구사항을 종합적으로 고려하였을 때 &lt;strong>관계형 데이터베이스&lt;/strong>가 적절해보인다.&lt;/p>
&lt;ul>
&lt;li>읽기 빈도가 쓰기 연산에 비해 높은 작업 흐름을 잘 지원한다.
&lt;ul>
&lt;li>읽기 반도가 압도적인 작업 흐름은 충분히 잘 지원한다.&lt;/li>
&lt;li>NoSQL 데이터베이스는 대체로 쓰기 연산에 최적화되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ACID 속성(원자성, 일관성, 격리성, 영속성)을 보장한다.
&lt;ul>
&lt;li>예약이라는 도메인 특성으로 인해 ACID 속성은 매우 중요하다.&lt;/li>
&lt;li>ACID를 보장하지 않으면 잔액 마이너스 문제, 이중 청구 문제, 이중 예약 문제 등을 방지하기 어렵다.&lt;/li>
&lt;li>ACID 속성이 충족되는 데이터베이스를 사용하면 코드는 단순해지고 이해하기 쉬워진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터를 쉽게 모델링 할 수 있다.
&lt;ul>
&lt;li>비즈니스 데이터의 구조를 명확하게 표현할 수 있을 뿐 아니라 엔티티 간의 간계를 안정적으로 지원할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_1.png"
width="1622"
height="1138"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_1_hude4e50a98d4fd9adb0d8d3f89cda06c5_259967_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_1_hude4e50a98d4fd9adb0d8d3f89cda06c5_259967_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터베이스 스키마"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="342px"
>&lt;/p>
&lt;p>&lt;code>reservation&lt;/code> 테이블의 &lt;code>status&lt;/code> 필드는 &lt;code>Pending&lt;/code>, &lt;code>Paid&lt;/code>, &lt;code>Refunded&lt;/code>, &lt;code>Canceled&lt;/code>, &lt;code>Rejected&lt;/code> 다섯 상태 가운데 하나를 값으로 가질 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_2.png"
width="1320"
height="630"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_2_hu654fdd7d1e7937dbeca03f4655f81aa1_21966_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_2_hu654fdd7d1e7937dbeca03f4655f81aa1_21966_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="예약 상태"
class="gallery-image"
data-flex-grow="209"
data-flex-basis="502px"
>&lt;/p>
&lt;p>이 스키마에서 &lt;code>room_id&lt;/code>는 에어비엔비 같은 회사에는 적합하나, 특정 호텔의 특정 객실 유형을 예약하는 호텔에는 적절하지 않을 수 있다.&lt;/p>
&lt;ul>
&lt;li>객실 번호는 예약할 때가 아닌, 투숙객이 체크인 하는 시점에 부여된다.&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>이번 호텔 예약 시스템에는 마이크로서비스 아키텍처를 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_3.png"
width="1946"
height="1100"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_3_hu282c3b24ada39ab6809ed01eac989c4e_87808_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_3_hu282c3b24ada39ab6809ed01eac989c4e_87808_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="176"
data-flex-basis="424px"
>&lt;/p>
&lt;p>마이크로 서비스 간 상호작용을 나타내는 화살표 상당수를 생략하였다.&lt;/p>
&lt;p>실제 상업적으로 이용되는 시스템의 서비스 간 통신에는 gRPC와 같은 고성능 원격 프로세서 호출 프레임워크를 사용하곤 한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>gRPC?&lt;/strong>&lt;br>
gRPC는 Google에서 개발한 고성능, 오픈 소스 원격 프로시저 호출(Remote Procedure Call, RPC) 프레임워크이다.
클라이언트와 서버 간에 원격 프로시저를 호출할 수 있게 해 주며, 마치 로컬에서 함수를 호출하는 것처럼 네트워크를 통해 다른 시스템의 메서드를 실행할 수 있다.
주로 프로토콜 버퍼(Protocol Buffers, protobuf)라는 직렬화 방식을 사용해 데이터를 효율적으로 전송하며, HTTP/2를 기반으로 동작해 성능과 확장성을 높인다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="개선된-데이터-모델">개선된 데이터 모델&lt;/h3>
&lt;p>호텔 객실을 예약할 때는 특정 객실이 아니라 특정한 객실 유형을 예약하게 된다.&lt;/p>
&lt;p>이러한 특성을 반영하기 위해 예약 API의 경우 호출 인자 가운데 &lt;code>roomID&lt;/code>는 &lt;code>roomTypeID&lt;/code>로 변경한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;startDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-28&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;endDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-30&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;hotelID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;245&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;roomTypeID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;U12354673389&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;reservationID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;13422445&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>스키마는 아래와 같이 변경된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_4.png"
width="1366"
height="1028"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_4_hu481f8e14d20d4e775dd6afb82166b25a_281965_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_4_hu481f8e14d20d4e775dd6afb82166b25a_281965_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="갱신된 스키마"
class="gallery-image"
data-flex-grow="132"
data-flex-basis="318px"
>&lt;/p>
&lt;p>주요 변경 사항은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>room&lt;/code>: 객실에 관계된 정보&lt;/li>
&lt;li>&lt;code>room_type_rate&lt;/code>: 특정 객실 유형의 특정 일자 요금 정보&lt;/li>
&lt;li>&lt;code>reservation&lt;/code>: 투숙객 예약 정보&lt;/li>
&lt;li>&lt;code>room_type_inventory&lt;/code>: 호텔의 모든 객실 유형
&lt;ul>
&lt;li>&lt;code>hotel_id&lt;/code>: 호텔 식별자&lt;/li>
&lt;li>&lt;code>room_type_id&lt;/code>: 객실 유형 식별자&lt;/li>
&lt;li>&lt;code>date&lt;/code>: 일자&lt;/li>
&lt;li>&lt;code>total_inventory&lt;/code>: 총 객실 수에서 일시적으로 제외한 객실 수를 뺀 값
&lt;ul>
&lt;li>유지 보수를 위해 예약 가능 목록에서 제외할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>total_reserved&lt;/code>: 저정된 hotel_id, room_type_id, date에 예약된 모든 객실의 수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>날짜당 하나의 레코드를 사용하면 날짜 범위 내에서 예약을 쉽게 관리하고 질의할 수 있다.&lt;/p>
&lt;p>이 테이블의 기본키는 &lt;code>(hotel_id, room_type_id, date)&lt;/code>의 복합키로, 2년 이내 모든 미래 날짜에 대한 가용 객실 데이터 질의 결과를 토대로 미리 채워 놓고, 시간이 흐름에 따라 새로 추가해야 하는 객실 정보는 매일 한 번씩 일괄 작업을 돌려 반영한다.&lt;/p>
&lt;hr>
&lt;p>5,000개의 호텔이 있고 각 호텔에는 20개의 객실 유형이 있으므로 테이블에 저장해야 하는 레코드의 수는 &lt;code>5,000 * 20 * 2년 * 365일 = 7,300만 개&lt;/code> 정도이다.&lt;/p>
&lt;p>많은 데이터가 아니므로 데이터베이스 하나면 저장하기 충분하지만, 하나만 둔다면 SPOF 문제를 피할 수 없게된다.&lt;/p>
&lt;p>고가용성을 달성하려면 여러 지역, 또는 가용성 구역에 데이터베이스를 복제해 두어야 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;code>room_type_inventory&lt;/code> 테이블은 고객이 특정 유형의 객실을 예약할 수 있는지 여부를 확인할 때 사용한다.&lt;/p>
&lt;ul>
&lt;li>입력
&lt;ul>
&lt;li>&lt;code>startDate&lt;/code>&lt;/li>
&lt;li>&lt;code>endDate&lt;/code>&lt;/li>
&lt;li>&lt;code>roomTypeId&lt;/code>&lt;/li>
&lt;li>&lt;code>hotelId&lt;/code>&lt;/li>
&lt;li>&lt;code>numberOfRoomsToReserve&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>출력
&lt;ul>
&lt;li>해당 유형의 객실에 여유가 있고 예약 가능한 상태라면 &lt;code>True&lt;/code>, 아니면 &lt;code>False&lt;/code>를 반환한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>SQL 관점에서 두 절차를 거친다.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>주어진 기간에 해당하는 레코드를 구한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">date&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_inventory&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_reserved&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">room_type_inventory&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">room_type_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">roomTypeId&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">hotel_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">hotelId&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BETWEEN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">startDate&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">endDate&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>반환한 각 레코드마다 다음 조건을 확인한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">if ((total_reserved + ${numberOfRoomsToReserve}) &amp;lt;= total_inventory)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>레코드의 모든 행을 검사한 결과 &lt;code>True&lt;/code>가 반환되면 주어진 기간 내 모든 날짜에 충분한 객실이 있다는 뜻 이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>예약 데이터가 단을 데이터베이스에 담기에 너무 크다면 다음과 같은 방안을 생각해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>현재 및 향후 예약 데이터만 저장한다.
&lt;ul>
&lt;li>예약 이력은 자주 접근하지 않으므로 아카이빙 하거나 냉동 저장소로 옮길 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터베이스를 샤딩한다.
&lt;ul>
&lt;li>자주 사용되는 질의는 &lt;strong>예약&lt;/strong> 및 &lt;strong>예약 확인&lt;/strong>이므로, 두 질의에서 모두 먼저 알아야하는 &lt;code>hotel_id&lt;/code>를 샤딩키로 사용한다.&lt;/li>
&lt;li>데이터는 &lt;code>hash(hotel_id) % number_of_service&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="동시성-문제">동시성 문제&lt;/h3>
&lt;p>또 하나의 중요한 문제는 &lt;strong>이중 예약 방지&lt;/strong>이며, 이를 위해 두가지 문제를 해결해야한다.&lt;/p>
&lt;ul>
&lt;li>같은 사용자가 예약 요청을 여러번 시도할 수 있다.&lt;/li>
&lt;li>여러 사용자가 같은 객실을 동시에 예약하려 할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="같은-사용자가-같은-예약-요청을-시도하는-경우">&lt;strong>같은 사용자가 같은 예약 요청을 시도하는 경우&lt;/strong>&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_5.png"
width="1508"
height="986"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_5_hueb9926d5bdf21d1ae178c13f6ba855ec_83059_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_5_hueb9926d5bdf21d1ae178c13f6ba855ec_83059_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="같은 고객의 이중 예약"
class="gallery-image"
data-flex-grow="152"
data-flex-basis="367px"
>&lt;/p>
&lt;p>이 문제를 푸는 일반적인 접근법으로는 다음 두가지가 있다.&lt;/p>
&lt;ul>
&lt;li>클라이언트 측 구현
&lt;ul>
&lt;li>요청 전송 후 예약 버튼을 비활성화 한다.
&lt;ul>
&lt;li>클라이언트에서 우회 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>멱등 API
&lt;ul>
&lt;li>예약 API 요청에 멱등 키를 추가하는 방안&lt;/li>
&lt;li>&lt;code>reservation_id&lt;/code>를 멱등 키로 사용하여 이중 예약 문제를 해결하는 방안이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_6.png"
width="1130"
height="1066"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_6_hu48c6b4b2100602be71a6178ae06987e2_69862_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_6_hu48c6b4b2100602be71a6178ae06987e2_69862_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="유일성 조건"
class="gallery-image"
data-flex-grow="106"
data-flex-basis="254px"
>&lt;/p>
&lt;ol>
&lt;li>예약 주문서를 만든다.&lt;/li>
&lt;li>고객이 검토할 수 있도록 예약 주문서를 반환한다.&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>반환 결과에 &lt;code>reservation_id&lt;/code>를 넣는다.(전역적 유일성을 보증하는 ID, 예제에서는의 예약 테이블의 기본키)&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>검토가 끝난 예약을 전송한다.
&lt;ul>
&lt;li>요청에 &lt;code>reservation_id&lt;/code>를 포함한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예약 완료 버튼을 한 번 더 눌러 보내도 &lt;code>reservation_id&lt;/code>가 예약 테이블의 기본 키 이므로 유일성 조건에 위반되어 처리되지 않는다.&lt;/li>
&lt;/ol>
&lt;h4 id="여러-사용자가-하나뿐인-객실을-동시에-예약하는-경우">&lt;strong>여러 사용자가 하나뿐인 객실을 동시에 예약하는 경우&lt;/strong>&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_7.png"
width="1438"
height="1262"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_7_hu8a18da16175039b3cfa48b49d042fdf5_80735_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_7_hu8a18da16175039b3cfa48b49d042fdf5_80735_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="경쟁 조건"
class="gallery-image"
data-flex-grow="113"
data-flex-basis="273px"
>&lt;/p>
&lt;p>이 문제를 해결하려면 어떤 형태로든 락을 활용해야 한다.&lt;/p>
&lt;p>&lt;strong>비관적 락&lt;/strong>&lt;/p>
&lt;p>비관적 락은 비관적 동시성 제어 방안이라고도 불리며, 사용자가 &lt;strong>레코드를 갱신하려고 하는 순간 즉시 락을 걸어 동시 업데이트를 방지하는 기술&lt;/strong>이다.&lt;/p>
&lt;p>따라서 해당 레코드를 갱신하려는 다른 사용자는 락 해제를 기다려야 한다.&lt;/p>
&lt;ul>
&lt;li>MySQL 같은 경우는 &lt;code>SELECT ... FOR UPDATE&lt;/code> 문을 실행하면 &lt;code>SELECT&lt;/code>가 반환한 레코드에 락이 걸린다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_8.png"
width="1994"
height="1320"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_8_hu40fa4d62dd848fb68c0b889e46e94f87_126013_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_8_hu40fa4d62dd848fb68c0b889e46e94f87_126013_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비관적 락"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="362px"
>&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>변경 중이거나 변경이 끝난 데이터를 갱신하는 일을 막을 수 있다.&lt;/li>
&lt;li>구현이 쉽고 모든 갱신 연산을 직렬화하여 충돌을 막는다.&lt;/li>
&lt;li>데이터에 대한 경합이 심할 때 유용하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>여러 레코드에 락을 걸면 교착 상태가 발생할 수 있다.
&lt;ul>
&lt;li>교착 상태가 발생하지 않는 코드 작성은 어렵다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장성이 낮다.&lt;/li>
&lt;li>트랜잭션이 너무 오랫동안 락을 해제하지 않고 있으면 다른 트랜잭션은 락이 걸린 자원에 접근할 수 없어 트랜잭션 수명이 길거나 많은 엔티티에 관련된 경우 성능에 심각한 영향을 끼친다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 이유로 비관적 락 메커니즘은 군장하지 않는다.&lt;/p>
&lt;p>&lt;strong>낙관적 락&lt;/strong>&lt;/p>
&lt;p>낙관적 락은 &lt;strong>낙관적 동시성 제어&lt;/strong>라고도 불리는 방안으로 &lt;strong>여러 사용자가 동시에 같은 자원을 갱신하려 시도하는 것을 허용&lt;/strong>한다.&lt;/p>
&lt;p>일반적으로 버전 번호(version_number)와 타임스탬프(timestamp) 두 가지 방법으로 구현한다.&lt;/p>
&lt;ul>
&lt;li>서버 시계는 시간이 지남에 따라 부정확해질 수 있으므로 일반적으로는 버전 번호를 더 나은 선택지로 본다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_9.png"
width="1938"
height="1142"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_9_hu9411dd474af31fd86c2a43d5119b3270_97882_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_9_hu9411dd474af31fd86c2a43d5119b3270_97882_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="낙관적 락"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="407px"
>&lt;/p>
&lt;p>낙관적 락은 데이터베이스에 직접 락을 걸지 않으므로 일반적으로 비관적 락 보다 빠르지만 동시성 수준이 아주 높으면 성능이 급격히 나빠진다.&lt;/p>
&lt;p>예를 들어 설명하면 잔여 객실 수를 읽을 수 있는 클라이언트 수에는 제한이 없으므로, 모든 클라이언트는 같은 잔여 객실 수와 같은 버전 정보를 취득하게 될 수 있기 때문에 모든 클라이언트는 같은 잔여 객실 수와 같은 버전 번호 정보를 취득한다.&lt;/p>
&lt;p>하지만 실제로 버전 번호 갱신에 성공하는 클라이언트는 하나이므로, 다른 모든 클라이언트는 버전 번호 검사에 실패하게된다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>애플리케이션이 유효하지 않은 데이터를 편집하는 일을 막는다.&lt;/li>
&lt;li>데이터베이스 자원에 락을 걸 필요가 없다.(데이터베이스 관점에서 락은 없다.) 책임은 애플리케이션에 있다.&lt;/li>
&lt;li>데이터에 대한 경쟁이 치열하지 않은 상황에 적합하다.
&lt;ul>
&lt;li>락을 관리하는 비용 없이 트랜잭션을 실행할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>데이터에 대한 경쟁이 치열한 상황에서는 성능이 좋지 못하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>낙관적 락은 예약 QPS가 일반적으로 높지 않은 호텔 예약 시스템에서는 적합한 선택지이다.&lt;/p>
&lt;p>&lt;strong>데이터베이스 제약 조건&lt;/strong>&lt;/p>
&lt;p>낙관적 락과 아주 유사하게 동작한다.&lt;/p>
&lt;p>&lt;code>room_type_inventory&lt;/code> 테이블에 다음 제약 조건을 추가한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CONSTRAINT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">check_room_count&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">CHECK&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">total_inventory&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_reserved&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_10.png"
width="1478"
height="1368"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_10_hu8a54ba9888669d6b439cae205e8f7b91_81051_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_10_hu8a54ba9888669d6b439cae205e8f7b91_81051_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 베이스 제약 조건"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="259px"
>&lt;/p>
&lt;p>사용자가 객실을 예약하려면 &lt;code>total_reserved&lt;/code>의 값이 101으로 제약 조건을 위반하게되어 롤백된다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>구현이 쉽다.&lt;/li>
&lt;li>데이터에 대한 경쟁이 심하지 않을 때 잘 동작한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>데이터에 대한 경쟁이 심하면 실패하는 연산 수가 매우 늘어날 수 있다.&lt;/li>
&lt;li>데이터베이스 제약 조건은 애플리케이션 코드와 달라서 버전을 통제하기 어렵다.&lt;/li>
&lt;li>제약 조건을 허용하지 않는 데이터베이스도 있으므로 마이그레이션 등에 문제가 될 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="시스템-규모-확장">시스템 규모 확장&lt;/h3>
&lt;p>일반적으로 호텔 예약 시스템에 대한 부하는 높지 않지만, 유명한 여행 예약 웹 사이트와 연동이 되어야한다면 QPS는 매우 늘어날 수 있다.&lt;/p>
&lt;p>시스템 부하가 높을 때는 무엇이 병목이 될 수 있는지 이해해야한다.&lt;/p>
&lt;ul>
&lt;li>해당 시스템의 모든 서비스는 무상태 서비스이므로 서버를 추가하는 것으로 성능 문제는 해결할 수 있다.&lt;/li>
&lt;li>데이터베이스는 단순히 데이터베이스 서버를 늘리는 것만으로는 성능 문제를 해결할 수 없다.&lt;/li>
&lt;/ul>
&lt;h4 id="데이터베이스-샤딩">데이터베이스 샤딩&lt;/h4>
&lt;p>데이터베이스를 여러 대 두고, 각각에 데이터의 일부만 보관하도록 하는 방식이다.&lt;/p>
&lt;p>데이터베이스를 샤딩할 때는 데이터를 어떻게 분배할 지 먼저 정한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>hotel_id&lt;/code>를 필터링 조건으로 사용하므로 샤딩 조건으로 쓰면 좋다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_11.png"
width="1964"
height="1122"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_11_hu98af43fce089f7bbf6f6bf1fb85b60d6_147947_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_11_hu98af43fce089f7bbf6f6bf1fb85b60d6_147947_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터베이스 샤딩"
class="gallery-image"
data-flex-grow="175"
data-flex-basis="420px"
>&lt;/p>
&lt;p>위는 16개 샤드로 분산하는 사례로, QPS가 30,000이라면 샤딩 후에는 1875QPS 정도로 한 대의 MySQL 서버로도 감당할 수 있는 부하가 된다.&lt;/p>
&lt;h4 id="캐시">캐시&lt;/h4>
&lt;p>호텔 잔여 객실 데이터는 현재와 미래의 데이터만 중요하다는 특성이 있다.&lt;/p>
&lt;p>따라서 데이터를 보관할 때 낡은 데이터는 자동적으로 소멸되도록 TTL을 설정할 수 있다면 바람직하다.&lt;/p>
&lt;ul>
&lt;li>이력 데이터는 다른 데이터베이스를 통해 질의하도록 하면 된다.&lt;/li>
&lt;/ul>
&lt;p>이런 상황에 레디스는 매우 적합하다.&lt;/p>
&lt;hr>
&lt;p>데이터 로딩 속도와 데이터베이스 확장성이 문제가 되기 시작하면 데이터베이스 앞에 캐시 계층을 두고 잔여 객실 확인 및 객실 예약 로직이 해당 계층에서 실행되도록 할 수 있다.&lt;/p>
&lt;p>요청의 일부만 잔여 객실 데이터베이스가 처리하고 나머지는 캐시가 담당하도록 한다.&lt;/p>
&lt;ul>
&lt;li>레디스 캐시 데이터에는 잔여 객실이 충분해 보여도 실제 데이터베이스를 다시 한번 확인해야한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_12.png"
width="1094"
height="682"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_12_hu5d3b54b38dcf02612143f1622e8a715a_133204_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_12_hu5d3b54b38dcf02612143f1622e8a715a_133204_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="캐시"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="384px"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>예약 서비스&lt;/strong>: 다음과 같은 잔여 객실 관리 API를 제공한다.&lt;/p>
&lt;ul>
&lt;li>지정된 호텔과 객실 유형, 주어진 날짜 범위에 이용 가능한 객실의 수를 질의&lt;/li>
&lt;li>객실을 예약하고 &lt;code>total_reserved&lt;/code>의 값을 1 증가&lt;/li>
&lt;li>고객이 예약을 취소하면 잔여 객실 수를 갱신&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>잔여 객실 캐시&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>모든 잔여 객실 관리에 필요한 질의는 레디스로 구현되는 잔여 객실 캐시로 옮긴다.&lt;/li>
&lt;li>따라서 사전에 잔여 객실 정보를 캐시에 미리 저장해두어야 한다.&lt;/li>
&lt;li>캐시에 저장되는 데이터 형식
&lt;ul>
&lt;li>키: &lt;code>hotelID_roomTypeId_{날짜}&lt;/code>&lt;/li>
&lt;li>값
&lt;ul>
&lt;li>주어진 호텔 ID&lt;/li>
&lt;li>객실 유형 ID&lt;/li>
&lt;li>날짜에 맞는 잔여 객실 수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>호텔 예약 시스템은 잔여 객실 확인 작업 때문에 읽기 연산 빈도가 쓰기 연산보다 훨씬 많으므로 대부분의 읽기 연산을 캐시로 처리하면 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>잔여 객실 데이터베이스&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>잔여 객실 수에 대한 가장 믿을 만한 정보가 보관되는 장소&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>캐시가 주는 새로운 과제&lt;/strong>&lt;/p>
&lt;p>캐시 계층을 추가하면 시스템의 확장성과 처리량은 대폭 증가하지만 데이터베이스와 캐시 사이의 데이터 일관성 유지에 관한 새로운 문제가 생긴다.&lt;/p>
&lt;p>사용자가 객실을 예약할 때 아무 문제가 없는 경우에는 다음 두 가지 작업이 이루어진다.&lt;/p>
&lt;ol>
&lt;li>잔여 객실 수를 질의하여 충분한지 확인(캐시)&lt;/li>
&lt;li>잔여 객실 데이터를 갱신
&lt;ul>
&lt;li>데이터베이스 갱신 이후 캐시 갱신&lt;/li>
&lt;li>비동기적으로 실행&lt;/li>
&lt;li>변경 데이터 감지(CDC) 매커니즘을 활용할 수 있다.
&lt;ul>
&lt;li>데이터베이스에서 발생한 변화를 감지하여 해당 변경 내역을 다른 시스템에 적용할 수 있도록 하는 매커니즘&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>잔여 객실 데이터에 대한 변화를 데이터베이스에 먼저 반영하므로 캐시에는 최신 데이터가 없을 가능성이 있다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>이러한 불일치 문제는 데이터베이스가 최종적으로 잔여 객실 확인을 하도록 한다면 문제가 되지는 않는다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>장점&lt;/p>
&lt;ul>
&lt;li>읽기 질의를 캐시가 처리하므로 데이터베이스의 부하가 크게 줄어든다.&lt;/li>
&lt;li>읽기 질의를 메모리에서 실행하므로 높은 성능을 보장할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>단점&lt;/p>
&lt;ul>
&lt;li>데이터베이스와 캐시 사이의 데이터 일관성을 유지하는 것은 어렵다.
&lt;ul>
&lt;li>데이터 불일치가 사용자 경험에 끼치는 영향을 신중하게 살펴야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="서비스-간-데이터-일관성">서비스 간 데이터 일관성&lt;/h3>
&lt;p>모노리스 아키텍처의 경우 데이터의 일광성을 보장하기 위해 관계형 데이터베이스를 공유하는 것이 보통이지만, 해당 시스템은 예약 테이블과 잔여 객실 테이블만 동일한 관계형 데이터베이스에 저장하는 MSA 하이브리드 접근법을 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_13.png"
width="1920"
height="514"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_13_huc5f5e8f7744db63fc867cea3c0d26387_55893_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_13_huc5f5e8f7744db63fc867cea3c0d26387_55893_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="모노리스 vs 마이크로서비스"
class="gallery-image"
data-flex-grow="373"
data-flex-basis="896px"
>&lt;/p>
&lt;p>이를 통해 관계형 데이터베이스의 ACID 속성을 활용하여 동시성 문제를 효과적으로 대응할 수 있지만, MSA 순수 주의자라면 마이크로 서비스가 독자적인 데이터베이스를 갖추고 있어야 한다고 주장할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_15.png"
width="1362"
height="1150"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_15_hu1651b063c3947755463e1494fe52dabe_39875_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_15_hu1651b063c3947755463e1494fe52dabe_39875_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="모노리스 아키텍처"
class="gallery-image"
data-flex-grow="118"
data-flex-basis="284px"
>&lt;/p>
&lt;p>모노리스 아키텍처는 하나의 데이터베이스만 사용하므로 여러 연산을 하나의 트랜잭션으로 묶어 ACID 속성이 만족되도록 보장할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_14.png"
width="1748"
height="1062"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_14_hu657f4a94828478d72376098f027fabfa_59765_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_14_hu657f4a94828478d72376098f027fabfa_59765_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="마이크로서비스 아키텍처"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="395px"
>&lt;/p>
&lt;p>하지만 서비스가 독자적인 데이터베이스를 갖도록 하면, 논리적으로는 하나의 원자적 연산이 여러 데이터베이스에 걸쳐 실행되는 일을 피할 수 없다.&lt;/p>
&lt;ul>
&lt;li>하나의 트랜잭션으로 데이터 일관성을 보증하는 기법을 사용할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>이러한 데이터 일관성 문제를 해결하기 위해 널리 사용되는 방법은 2가지 정도가 있다.&lt;/p>
&lt;ul>
&lt;li>2단계 커밋(2-phase commit, 2PC)
&lt;ul>
&lt;li>여러 노드에 걸친 원자적 트랜잭션 실행을 보증하는 데이터베이스 프로토콜&lt;/li>
&lt;li>모든 노드가 성공하든 아니면 실패하든 둘 중 하나로 트랜잭션이 마무리되도록 보증&lt;/li>
&lt;li>비중단 실행이 가능한 프로토콜이 아니므로 어느 한 노드에 장애가 발생하면 해당 장애가 복구될 때까지 진행이 중단된다.(성능이 뛰어난 프로토콜은 아니다.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사가(Saga)
&lt;ul>
&lt;li>각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮는다.&lt;/li>
&lt;li>각각의 트랜잭션은 완료되면 다음 트랜잭션을 시작하는 트리거로 쓰일 메시지를 만드러 보낸다.&lt;/li>
&lt;li>한 트랜잭션이라도 실패하면 그 이전 트랜잭션의 결과를 전부 되될리는 트랜잭션들을 순차적으로 실행한다.&lt;/li>
&lt;li>2pc는 여러 노드에 걸친 하나의 트랜잭션을 통해 ACID 속성을 만족시키는 개념이지만 사가는 각 단계가 하나의 트랜잭션이라서 결과적 일관성에 의존하는 것으로 본다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>마이크로서비스 간의 데이터 불일치를 해결하기 위해 사용되는 복잡한 매커니즘은 시스템 전체 설계의 복잡성을 크게 증가시킨다.&lt;br>
증가한 복잡성이 그만한 가치가 있는 지 결정하는 것은 설계자의 몫이다.&lt;/p>
&lt;ul>
&lt;li>이번 설계안은 그만한 가치는 없다고 판단하여 예약 및 잔여 객실 정보를 동일한 관계형 데이터베이스에 저장하는 좀 더 실용적인 접근 방법을 선택했다.&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;ul>
&lt;li>경쟁 조건이 발생할 수 있는 시나리오
&lt;ul>
&lt;li>비관적 락&lt;/li>
&lt;li>낙관적 락&lt;/li>
&lt;li>데이터베이스 제약 조건&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규모 확장
&lt;ul>
&lt;li>데이터베이스 샤딩&lt;/li>
&lt;li>레디스 캐시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>마이크로아키텍처의 데이터 일관성 문제&lt;/li>
&lt;/ul></description></item><item><title>챌린지 과정 4주차 회고</title><link>https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/</link><pubDate>Mon, 12 Aug 2024 10:44:49 +0900</pubDate><guid>https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/</guid><description>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/cover.png" alt="Featured image of post 챌린지 과정 4주차 회고" />&lt;p>부스트캠프 챌린지 과정이 4주차로 마무리되었습니다🥳&lt;/p>
&lt;p>주말을 이용하여 미뤄왔던 대청소와 약속들 덕분에 월요일이 되어서야 회고를 쓰게 되네요&lt;/p>
&lt;p>이번주는 미션들을 수행하지는 않겠지만, 그동안 바빠서 마무리하지 못했던 학습 정리로 바쁠 것 같습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img.png"
width="900"
height="752"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_huc5e3bd9d0538c93e5f494cd205f8c424_816479_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_huc5e3bd9d0538c93e5f494cd205f8c424_816479_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="아직 한발 남았다."
class="gallery-image"
data-flex-grow="119"
data-flex-basis="287px"
>&lt;/p>
&lt;p>이번 주는 저번주와 마찬가지로 &lt;strong>짝 활동&lt;/strong>을 기본으로 한 주가 구성되었습니다.&lt;/p>
&lt;p>&lt;strong>각자 개발&lt;/strong>후 &lt;strong>짝 개선&lt;/strong>하기, &lt;strong>짝 개발&lt;/strong>후 &lt;strong>각자 개선&lt;/strong>하기로 &lt;strong>데이터베이스&lt;/strong>와 &lt;strong>네트워크&lt;/strong>를 깊게 이해해야만 해결할 수 있는 미션들이 주어졌습니다.&lt;/p>
&lt;p>그리고 마지막 테스트를 위한 &lt;strong>히든 미션&lt;/strong>을 금요일에 수행하였습니다.&lt;/p>
&lt;p>개인적으로 데이터베이스 관련 미션은 많이 어려웠네요 🙃&lt;/p>
&lt;p>이번 회고에는 미션들에 대한 접근 방법에 더해 짝 활동이 어떻게, 무엇을 중심으로 진행되었는지 설명해보겠습니다.&lt;/p>
&lt;h2 id="day16--17-데이터베이스">Day16 ~ 17: 데이터베이스&lt;/h2>
&lt;p>데이터베이스 관련 미션은 &lt;strong>각자 구현&lt;/strong> 후 &lt;strong>짝 개선&lt;/strong>을 수행해야하는 미션이었습니다.&lt;/p>
&lt;p>파일 기반 데이터베이스를 직접 구현해야하는 미션이었는데, 위에서 말씀드렸던 것처럼 개인적으로 많이 어려웠습니다.&lt;/p>
&lt;h3 id="mysql">MySQL&lt;/h3>
&lt;p>이전 직장에서 풀스택 개발자로 업무를 수행해오며 오랜기간 유지되어온 PHP 백엔드 레거시를 운영하는 것이 주 업무였는데요&lt;/p>
&lt;p>그렇다보니 예전 방식으로 그대로 개발을 수행할 수 밖에 없었고, &lt;a class="link" href="https://www.php.net/manual/en/book.pdo.php" target="_blank" rel="noopener"
>PDO&lt;/a>(PHP Data Object)를 사용하고 있었기 때문에 직접 쿼리를 작성해야하는 것은 필수적이었습니다.&lt;/p>
&lt;p>예전 개발 환경과 싱글 스레드 기반으로 순차적인 처리에 중점을 두는 PHP의 특성으로 인해 지금처럼 ORM을 이용하여 작은 쿼리를 여러개 보내는 것 보다는, 굉장히 많은 테이블들을 조인하는 큰 쿼리 하나를 작성해야하는 일도 매우 빈번했습니다.&lt;/p>
&lt;p>그렇다보니 쿼리 튜닝은 저에게 필수적인 역량이었고, 학습에 꽤 많은 공을 들였었습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_5.png"
width="371"
height="136"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_5_hu6fb17a4b1ba75a00ca79acad9d84d206_8737_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_5_hu6fb17a4b1ba75a00ca79acad9d84d206_8737_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL"
class="gallery-image"
data-flex-grow="272"
data-flex-basis="654px"
>&lt;/p>
&lt;p>이러한 이유로 MySQL 내부 동작을 꽤 잘 알고 있다고 생각하여 이번 미션은 MySQL을 모방하는 방식으로 접근했었습니다.&lt;/p>
&lt;h3 id="스토리지-엔진">스토리지 엔진&lt;/h3>
&lt;p>기존 요구사항만을 만족하기 위해서는 단순하게 전체 읽기, 전체 쓰기 방식으로 접근해도 괜찮았지만, 이러한 경우 데이터가 많아지면 급격한 성능 저하가 발생하게됩니다.&lt;/p>
&lt;p>이러한 문제를 해결해보고 싶어 많은 고민을 했는데 이 부분이 정말 어려웠습니다🥲&lt;/p>
&lt;hr>
&lt;p>&lt;strong>InnoDB&lt;/strong>&lt;/p>
&lt;p>데이터베이스의 성능을 나쁘게 만드는 원인은 &lt;strong>디스크 I/O&lt;/strong>에서 발생하는 &lt;strong>병목 현상&lt;/strong>입니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_1.png"
width="904"
height="456"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_1_hu5128e5d7946208d35600b2a8a7d0222a_52925_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_1_hu5128e5d7946208d35600b2a8a7d0222a_52925_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL 구조"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="475px"
>&lt;/p>
&lt;p>MySQL은 크게 &lt;strong>MySQL 엔진&lt;/strong>, &lt;strong>스토리지 엔진&lt;/strong>으로 영역을 구분할 수 있는데, 디스크 I/O에 접근하는 역할은 &lt;strong>스토리지 엔진&lt;/strong>이 전담하여 수행하게 됩니다.&lt;/p>
&lt;p>여러 스토리지 엔진이 있지만 주로 사용되는 &lt;code>InnoDB&lt;/code> 스토리지 엔진은 &lt;strong>버퍼풀&lt;/strong>이라는 메모리 영역을 통해 사용하는 주요 데이터를 대부분 캐싱하여 디스크에 접근하는 것을 최소화합니다.&lt;/p>
&lt;p>또한 쓰기 작업을 버퍼링하여 하드웨어 자원의 여유가 있을 때 백그라운드에서 실행하는 방식들을 통해 데이터베이스의 성능을 크게 끌어올리고 있습니다.&lt;/p>
&lt;p>이를 반영하기 위해서 데이터를 저장하고 관리하는 기본 단위인 &lt;strong>페이지&lt;/strong>를 구현하야할 필요가 있었습니다만&amp;hellip;.&lt;/p>
&lt;p>페이지를 직접 구현하고 이를 이용해서 데이터 저장이나 캐싱등을 구현해야한다고 생각하니 현기증이 나는 것 같다라구요😅&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_2.png"
width="632"
height="523"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_2_huaf81590ee5a0b6795972f97e2fb827b9_593519_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_2_huaf81590ee5a0b6795972f97e2fb827b9_593519_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="290px"
>&lt;/p>
&lt;p>그래서 MySQL 인덱스의 기본 단위인 PK만을 이용해서 저장된 파일에서의 레코드 위치만을 가지게 구현하는 방식으로 접근했습니다.&lt;/p>
&lt;p>&lt;strong>B+ Tree&lt;/strong> 같은 자료 구조를 통해서 &lt;code>Index Range Scan&lt;/code> 같은 방식도 적용해보려고 했었는데, 마찬가지로 어려워서 &lt;code>PK&lt;/code> 단일 조건 처리에 관한 부분만 적용할 수 있었습니다.&lt;/p>
&lt;h3 id="짝-개선">짝 개선&lt;/h3>
&lt;p>짝 개선은 이전과 마찬가지로 새로운 기능을 추가하는 것 보다는 기존 코드를 개선하는 방향으로 지침이 주어졌습니다.&lt;/p>
&lt;p>저 같은 경우는 &lt;strong>HTTP 요청/응답 분리&lt;/strong>를, 짝은 &lt;strong>DBMS 아키텍처 반영&lt;/strong>을 통한 &lt;strong>코드 구조&lt;/strong>를 개선하는 것을 목표로 함께 개선을 진행하였습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>예외 처리&lt;/strong>&lt;/p>
&lt;p>저의 개선 목표였던 &lt;strong>HTTP 요청/응답 분리&lt;/strong> 부분 작업을 수행하면서 자연스럽게 &lt;strong>응답 코드&lt;/strong>에 관한 내용들이 개선되어야 했고, 응답을 만들기위해 &lt;strong>예외 처리&lt;/strong>를 추가하는 부분에서 짝과 의견을 나눌 수 있는 기회가 생겼습니다.&lt;/p>
&lt;p>저 같은 경우는 서비스 로직에서 에러 또는 예외를 발생시켜 해당 에러를 최상위 지점에서 한번에 핸들링하는 것을 선호하는데(&lt;a class="link" href="https://codemario318.github.io/post/clean-code/7/" >클린코드 - 에러 처리&lt;/a>) 어떠한 장점이 있는지에 대해서 물어봐 주셨습니다.&lt;/p>
&lt;p>코드를 보면서 확인해보면 아래와 같습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>개선 전&lt;/strong>&lt;/p>
&lt;p>이전 처리를 복기해보면 아래와 같은 방식으로 처리가 구현되어 있었습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">어떤_서비스_클래스&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">원하는_동작&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">값_검증&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">throw&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">status&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;value&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;입력 값을 확인해주세요.&amp;#39;&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">서비스로직을_사용하는_클래스&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">어떤_기능&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">결과&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">어떤_서비스_객체&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">원하는_동작&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">200&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;OK&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">body&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">결과&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">status&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">switch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">status&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="s1">&amp;#39;value&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">400&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">500&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이러한 방식에는 몇 가지 문제가 있습니다.&lt;/p>
&lt;ul>
&lt;li>예외를 발생 시킬 때 사용자가 직접 사유를 기억해서 매직넘버(상수가 아닌 직접 입력해야하는 값, 하드코딩)를 사용해야합니다.&lt;/li>
&lt;li>응답도 같은 문제를 가지고 있습니다.&lt;/li>
&lt;/ul>
&lt;p>이러한 방식은 개발자가 실수를 쉽게 할 수 있는 여지가 많아지게됩니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>개선 후&lt;/strong>&lt;/p>
&lt;p>이러한 부분을 아래와 같이 개선하게 되었습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">BadRequestException&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nb">Error&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">UnauthorizedException&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nb">Error&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">ForbiddenException&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nb">Error&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">NotFoundException&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nb">Error&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">NotAcceptableException&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nb">Error&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">HttpStatusCodes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">Object&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">freeze&lt;/span>&lt;span class="p">({&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">OK&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">200&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">BAD_REQUEST&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">400&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">UNAUTHORIZED&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">401&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">FORBIDDEN&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">403&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">NOT_FOUND&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">404&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">NOT_ACCEPTABLE&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">406&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">INTERNAL_SERVER_ERROR&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">500&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>각 예외 상황에 맞는 예외 클래스를 구현하였습니다.
&lt;ul>
&lt;li>Nest.js 표준 에러 참조&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Http 응답 코드에 대해 Enum을 선언하였습니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">어떤_서비스_클래스&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">원하는_동작&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">값_검증&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">BadRequestException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;입력 값을 확인해주세요.&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">서비스로직을_사용하는_최상위_클래스&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">어떤_기능&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">결과&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">어떤_서비스_객체&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">원하는_동작&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">HttpStatusCode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">OK&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">body&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">결과&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">message&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="nx">BadRequestException&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">HttpStatusCodes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">BAD_REQUEST&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="nx">NotFoundException&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">HttpStatusCodes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NOT_FOUND&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">HttpStatusCodes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">INTERNAL_SERVER_ERROR&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>발생한 예외 클래스를 확인하여 Enum으로 선언된 응답 코드를 상황에 맞게 반환할 수 있도록 변경&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이러한 형식으로 개선되어 아래와 같은 장점을 취할 수 있었습니다.&lt;/p>
&lt;ul>
&lt;li>예외 클래스를 직접 확인하므로 어떤 에러가 발생했는지 쉽게 파악할 수 있다.&lt;/li>
&lt;li>에외 코드가 어떤 의미인지 확실히 구분할 수 있다. 등&lt;/li>
&lt;/ul>
&lt;p>발생하는 예외가 HTTP 응답에 대해 직접적인 연관성이 있어 또 하나의 세부사항인 HTTP와 관계가 생겨버린다는 것이 아쉬운 점이지만 충분히 개선되었다고 생각합니다.&lt;/p>
&lt;p>제가 생각하는 장점을 코드를 함께 개선해가는 과정을 통해서 설명해 드렸고, 많은 도움이 되었다는 이야기를 들을 수 있었습니다😁&lt;/p>
&lt;h2 id="day18--19-네트워크">Day18 ~ 19: 네트워크&lt;/h2>
&lt;p>네트워크 관련 미션은 &lt;strong>페어 프로그래밍&lt;/strong>을 통해 함께 결과물을 만들고, 이후 &lt;strong>각자 개선&lt;/strong>을 수행하는 미션이었습니다.&lt;/p>
&lt;p>&lt;strong>웹 소켓&lt;/strong> 서버를 직접 구현하는 것이 전제되어있는 미션이었는데, &lt;strong>레이어드 아키텍처&lt;/strong>를 쉽게 적용할 수 있는 요구사항이어서 짝에게 설계를 적극적으로 제안하여 적용하게 되었습니다.&lt;/p>
&lt;p>이전과 달랐던 점은 짝이 이전부터 &lt;strong>TDD&lt;/strong>를 적용해오셨던 분이셔서, 자연스럽게 &lt;strong>TDD&lt;/strong>로 진행되었습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_3.png"
width="816"
height="454"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_3_hu05ec6f48f861dd6127467224c3c8452c_617786_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_3_hu05ec6f48f861dd6127467224c3c8452c_617786_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="179"
data-flex-basis="431px"
>&lt;/p>
&lt;p>기능 요구사항을 돌아가며 &lt;strong>드라이버&lt;/strong>, &lt;strong>네비게이터&lt;/strong> 역할을 수행하는 방식으로 진행되었는데, 원할하게 &lt;strong>TDD&lt;/strong>가 진행되어서 참 즐거운 경험이었습니다😁&lt;/p>
&lt;p>그리고 짝 캠퍼분이 이전부터 FE 개발을 해오셨던 경험이 있으셔서 JS에 매우 능숙하셨기 때문에 아주 원할하게 진행될 수 있었던 것 같네요&lt;/p>
&lt;p>&lt;strong>레이어드 아키텍처&lt;/strong> 기반의 설계와, &lt;strong>TDD&lt;/strong>가 합쳐지니 지금까지 결과물 중 가장 만족스러운 결과물을 만들 수 있었습니다. 👍&lt;/p>
&lt;p>&lt;del>그래도 새벽 3시가 넘어서야 마무리 할 수 있었어요🤣&lt;/del>&lt;/p>
&lt;h3 id="레이어드-아키텍처">레이어드 아키텍처&lt;/h3>
&lt;p>&lt;code>Socket&lt;/code>을 이용하여 &lt;strong>CLI 기반 클라이언트&lt;/strong>와 &lt;strong>서버&lt;/strong>를 구현해야했습니다.&lt;/p>
&lt;p>서버와 클라이언트의 연결을 만들고, 클라이언트의 요청마다 HTTP 응답을 처리하는 구조가 필요했기 때문에 짝에게 &lt;strong>레이어드 아키텍처&lt;/strong>를 적극적으로 제안하여 반영하였습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_4.png"
width="1127"
height="843"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_4_hu4e52c0ad343a0efa02fd57875f5ec4d4_47956_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_4_hu4e52c0ad343a0efa02fd57875f5ec4d4_47956_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="레이어드 아키텍처"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="320px"
>&lt;/p>
&lt;p>&lt;strong>HTTP 요청 수신 및 응답&lt;/strong>, &lt;strong>비즈니스 로직 처리&lt;/strong>, &lt;strong>데이터 조작&lt;/strong>을 각 레이어로 구현하여 분리하여, 좋은 코드 구조를 만들 수 있었습니다.&lt;/p>
&lt;p>짝과 함께 개발하는 과정에서 뿐만이 아니라, 다음 피어세션에서도 해당 설계를 보고 많은 영감을 얻으셨다는 반응이 많아서 뿌듯했네요 😎&lt;/p>
&lt;h3 id="의존성-주입">의존성 주입&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_6.png"
width="271"
height="186"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_6_hua164b4f218d2ddb10286229f1ed50614_9292_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_6_hua164b4f218d2ddb10286229f1ed50614_9292_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="의존성 주입"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="349px"
>&lt;/p>
&lt;p>레이어드 아키텍처를 구성하며 각 의존성이 있는 레이어를 &lt;strong>의존성 주입&lt;/strong>을 통해 &lt;strong>구성&lt;/strong>하였습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">Model&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">#&lt;/span>&lt;span class="nx">items&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">items&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">items&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">items&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">getItem&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">collection&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">find&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">condition&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">Service&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">#&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">model&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">model&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">businessLogic&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getItem&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">Handler&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">#&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">constructor&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">service&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">service&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">handler&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">HttpStatusCode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">OK&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">body&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">businessLogic&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">items&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">model&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Model&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">items&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">service&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Service&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">handler&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Handler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이러한 구조를 통해 결합을 낮추고 유연성을 높힐 수 있었으며, 구현 과정에서 훨씬 테스트가 용이하다는 장점을 취할 수 있었습니다.&lt;/p>
&lt;h3 id="단단한-테스트-코드">단단한 테스트 코드&lt;/h3>
&lt;p>&lt;strong>각자 개선하기&lt;/strong>에서 저는 테스트 코드 부분을 개선하였습니다.&lt;/p>
&lt;p>단단한 테스트 코드 즉 깨지지 않는 테스트 코드를 작성하기 위해서 개인적으로 테스트 원칙인 단일 책임 원칙, 독립적 테스트 부분을 개선했습니다.&lt;/p>
&lt;ul>
&lt;li>단일 책임 원칙
&lt;ul>
&lt;li>테스트 코드는 하나의 동작이나 기능만을 테스트 해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>독립적 테스트
&lt;ul>
&lt;li>테스트 간에 의존성이 있으면 한 테스트의 실패가 다른 테스트에도 영양을 줌&lt;/li>
&lt;li>테스트 간 상태 공유를 피하고, 각 테스트 케이스가 독립적으로 실행될 수 있도록 보장해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>단일 책임 원칙&lt;/strong>&lt;/p>
&lt;p>하나의 테스트 코드는 한 가지의 동작과 기능을 테스트해야 이후 변경이 적고 오래사용할 수 있는 테스트 코드를 만들 수 있습니다.&lt;/p>
&lt;p>기존 작성되어있던 테스트를 유사하게 다시 만들어봤습니다.&lt;/p>
&lt;p>어떠한 모델에서 id를 이용해 특정 무언가를 찾는 처리입니다. (어떤 내용인지 추론할 수 있으면 안되기 때문에 추상적으로 쓸 수 밖에 없는 점 양해 부탁드립니다.)&lt;/p>
&lt;hr>
&lt;p>&lt;strong>변경 전&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">makeIds&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nb">Array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">from&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">length&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">count&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">idx&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="sb">`&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">idx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">toString&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">padStart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;0&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">describe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;ID를 활용하여 무언가를 찾아 배정하고 반환하는 처리 테스트&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">each&lt;/span>&lt;span class="p">([&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">makeIds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">id1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">makeIds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">id2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">makeIds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">id3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">makeIds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">id4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">makeIds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">id5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">])(&lt;/span>&lt;span class="s2">&amp;#34;무언가를 찾아 배정하고, 배정된 무언가를 반환&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">prevIds&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">nextId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">expected&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">prevIds&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">forEach&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">assignById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">assignById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nextCampId&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">expected&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>많은 상황에 대해 정상적인 처리를 테스트하고 있습니다.&lt;/p>
&lt;p>많은 테스트케이스를 확인하고 있었기 때문에 예외가 발생해야하는 상황은 별도로 확인하고 있지 않았습니다.&lt;/p>
&lt;p>개인적인 의견으로는 알아보기 힘들다고 판단했습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>변경 후&lt;/strong>&lt;/p>
&lt;p>여러 상황을 나누어 테스트하도록 했으며, 테스트 케이스의 숫자도 줄였습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">describe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;ID를 활용하여 무언가를 찾아 배정하고 반환하는 처리 테스트&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;정상 처리 확인&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">assignedId&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">assignById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">assignedId&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toEqual&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;특정 조건이 넘으면 다른 값 반환 확인&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">clients&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">Array&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">MAX_ASSIGN_CLIENT&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="sb">`J&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">toString&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">padStart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;0&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="nx">clients&lt;/span>&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">assigned&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">assignById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">assignedId&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toEqual&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;먼저 만들어진 무언가에 빈 자리가 있다면 해당 무언가를 반환&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="nx">clients&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="p">[]});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="nx">clients&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="p">[]});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">assignedId&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">assignById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">assignedId&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toEqual&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>독립적 테스트&lt;/strong>&lt;/p>
&lt;p>일부 테스트가 스스로의 다른 기능을 호출하는 부분들이 있었습니다. 이는 기능의 변경에 취약한 테스트가 될 수 있다고 판단하여 수정하였습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>변경 전&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">describe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;count&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;횟수 반환&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">increaseCount&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>service.count&lt;/code> 메소드를 통해 현재 &lt;code>count&lt;/code>을 확인하기 위해 &lt;code>service.increaseCount&lt;/code>메소드를 통해 &lt;code>count&lt;/code>를 증가시키고 있습니다.&lt;/p>
&lt;p>이는 자기 자신의 메소드를 재 호출하는 구조로 인해 &lt;code>service.increaseCount&lt;/code>에 미쳐 검증하지 못한 케이스가 있거나, 요구사항 변경으로 인해 검증해야 할 내용이 바뀐다면, &lt;code>service.count&lt;/code>의 테스트 코드도 변경이 불가피한 상황입니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>변경 후&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">describe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;count&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;횟수 반환&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">clap&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>service&lt;/code>의 데이터 보관을 위해 주입받은 &lt;code>Map&lt;/code>에 직접 데이터를 저장, 조작하여 자기 자신의 메소드를 활용하는 테스트 처리의 의존성을 제거하였습니다.&lt;/p>
&lt;h2 id="day20-3차-문제해결력-테스트">Day20: 3차 문제해결력 테스트&lt;/h2>
&lt;p>기존 모집 정보에 3차 문제해결력 테스트가 8월 10일 토요일로 예정되어 있었는데, 마지막 날인 20일차 릴레이 프로젝트를 수행해야하는 시간에 테스트가 진행되었습니다.&lt;/p>
&lt;p>대략적으로 말씀드리면, 부캠에서 제공했던 모든 과정들이 단시간에 종합되어있는 테스트였습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_7.png"
width="491"
height="340"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_7_hu5fb8e3cf3fed11573f93053e9937564e_404795_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_7_hu5fb8e3cf3fed11573f93053e9937564e_404795_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="부캠 종합 선물세트"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="346px"
>&lt;/p>
&lt;p>부캠에 성실히 참여했다면 방식 자체는 생소하지는 않았겠지만, 역시나 시간은 많이 부족했네요🥲&lt;/p>
&lt;h2 id="마무리">마무리&lt;/h2>
&lt;p>마지막 주차에는 같이 학습을 진행한 캠퍼분들에게 영감을 줄 수 있었던것 같아 1주차 이후로 가장 뿌듯했던 한 주 였던 것 같습니다.&lt;/p>
&lt;p>마지막 주차여서 챌린지 과정 전체에대한 회고를 포함해야하나 고민했는데, 따로 작성하기로 결정하여 4주차 회고만 남기게 되었네요&lt;/p>
&lt;p>다음 글은 챌린지 과정 전체에 대한 회고를 올릴 예정이니 기대해주세요😁&lt;/p>
&lt;p>이번에는 3주차 그룹 회고에 남겼던 글로 마무리하겠습니다.&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다☺️ 모두 정말 고생 많으셨어요🔥🔥🔥&lt;/p>
&lt;blockquote>
&lt;p>소프트웨어 장인 책 부분에 성장을 위한 자세에 관해 읽었는데요, 이 부분에서 &amp;ldquo;훈련&amp;quot;을 어떻게 해야 좋은지에 대한 언급이 있습니다.&lt;/p>
&lt;p>훈련을 할 때는 시간이 아무리 많이 걸린다고 하더라도 본인이 할 수 있는 최선의 결과를 만들지 않는다면 성장에는 큰 의미가 없기 때문에 최선을 다하는 것이 중요하다고해요!&lt;/p>
&lt;p>우리 모두 지금까지 열심히 해오고있지만, 앞으로도 최선을 다해서 함께 성장했으면 좋겠어요&lt;/p>
&lt;p>한 주간 정말 고생 많으셨습니다! 맴버쉽에서 꼭 뵈어요 :D&lt;/p>
&lt;/blockquote></description></item><item><title>[MovieLens] 2. DB 설계</title><link>https://codemario318.github.io/post/movielens/2/</link><pubDate>Tue, 19 Mar 2024 16:00:01 +0900</pubDate><guid>https://codemario318.github.io/post/movielens/2/</guid><description>&lt;img src="https://codemario318.github.io/post/movielens/2/cover.jpeg" alt="Featured image of post [MovieLens] 2. DB 설계" />&lt;p>앞서 진행한 데이터셋 구조 확인을 바탕으로, 간단하게 데이터베이스 설계를 해봤습니다.&lt;/p>
&lt;p>&lt;code>TAGS&lt;/code>, &lt;code>RATINGS&lt;/code> 테이블은 &lt;code>user_id&lt;/code>, &lt;code>movie_id&lt;/code> 컬럼을 활용한 관계 테이블인데 &lt;code>USERS&lt;/code> 테이블에 관련된 데이터들을 별도로 제공하지 않았기 때문에 있다고 가정하고 진행했습니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
MOVIES {
int movie_id PK
string title
string genres
int rating_count
bigint rating_total
}
RATINGS {
int user_id PK,FK
int movie_id PK,FK
int rating
timestamp created_at
}
REVIEWS {
int review_id PK
int user_id FK
int movie_id FK
string content
timestamp created_at
timestamp updated_at
}
TAGS {
string name PK
timestamp created_at
}
REVIEWS_TAGS {
int user_id PK,FK
int movie_id PK,FK
int tag_name PK,FK
}
USERS {
int id PK
}
MOVIES ||--o{ RATINGS: ""
RATINGS }o--|| USERS: ""
MOVIES ||--o{ REVIEWS: ""
REVIEWS }o--|| USERS: ""
REVIEWS ||--o{ REVIEWS_TAGS: ""
REVIEWS_TAGS }o--|| TAGS: ""
&lt;/pre>
&lt;p>기존 데이터를 기반으로 일부 컬럼들과 테이블을 추가하였습니다.&lt;/p>
&lt;p>자세한 내용은 테이블 별로 설명해보겠습니다.&lt;/p>
&lt;h2 id="movies">MOVIES&lt;/h2>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
MOVIES {
int movie_id PK
string title
string genres
int rating_count
bigint rating_total
}
&lt;/pre>
&lt;p>기존 제공된 &lt;code>movie_id&lt;/code>, &lt;code>title&lt;/code>, &lt;code>genres&lt;/code>는 그대로 활용하고, 평균 평점 계산에 활용될 &lt;code>rating_count&lt;/code>, &lt;code>rating_total&lt;/code> 컬럼을 추가했습니다.&lt;/p>
&lt;p>&lt;code>genres&lt;/code> 컬럼은 장르들이 &lt;code>|&lt;/code> 문자로 구분되어 문자열 형태로 저장되는 형식이었는데, 처음 RDBMS를 이용해 만드는 방식에서는 검색 조건등의 활용을 배제하고, 이후 검색 엔진 같은 다른 방식으로 제공해 볼 예정입니다.&lt;/p>
&lt;p>&lt;code>rating_count&lt;/code>, &lt;code>rating_total&lt;/code> 컬럼은 조회 후 서버나 클라이언트 측에서 직접 계산하는 방식을 사용할 수 있고, &lt;strong>MySQL&lt;/strong>, &lt;strong>PostgreSQL&lt;/strong>등과 같이 &lt;strong>함수 기반 인덱스&lt;/strong> 기능을 제공하는 RDBMS를 활용한다면 조건을 활용한 조회 성능에도 이슈가 발생하지 않을 것이라 생각되어 추가하였습니다.&lt;/p>
&lt;p>&lt;code>rating_count&lt;/code>, &lt;code>rating_total&lt;/code> 컬럼은 사용자가 평점을 추가하거나 수정할 때 변경되는 값이므로 평점 등록, 수정, 삭제 처리시 해당 컬럼 처리 로직 구현에 주의가 필요하겠습니다.&lt;/p>
&lt;h2 id="ratings">RATINGS&lt;/h2>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
RATINGS {
int user_id PK,FK
int movie_id PK,FK
int rating
timestamp create_ts
}
&lt;/pre>
&lt;p>기존 제공된 &lt;code>user_id&lt;/code>, &lt;code>movie_id&lt;/code>, &lt;code>create_ts&lt;/code>는 그대로 활용하고, &lt;code>rating&lt;/code> 컬럼의 데이터 타입을 변경하였습니다.&lt;/p>
&lt;p>&lt;code>rating&lt;/code> 같은 경우 기존에는 &lt;strong>0.5 간격 0~5 까지의 소수&lt;/strong>를 저장하고 있었지만, &lt;code>MOVIES&lt;/code> 테이블의 &lt;code>rating_total&lt;/code> 처리와 평균 평점 계산 처리가 필요하므로, 개인 최고점을 10점으로 변경하고 서비스 로직에서 평점을 계산하는 방식을 고려하는게 더 합리적이라 판단하여 정수형 데이터타입을 선택하였습니다.&lt;/p>
&lt;p>이외에도 &lt;code>rating_id&lt;/code>와 같은 별도 PK를 만드는 것을 고려해봤지만, &lt;code>rating_id&lt;/code> 컬럼이 다른 테이블에서 활용되거나 PK가 변경거나 &lt;code>user_id&lt;/code>, &lt;code>movie_id&lt;/code> 없이 단독으로 할용되는 경우는 없을 것이라 판단되어 별도로 추가하지는 않았습니다.&lt;/p>
&lt;h2 id="tags-reviews-reviews_tags">TAGS, REVIEWS, REVIEWS_TAGS&lt;/h2>
&lt;p>기본 제공된 데이터에서 &lt;code>TAGS&lt;/code>는 전체 2,328,315건 중 유니크한 &lt;code>tag&lt;/code>는 153,950개 였습니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
TAGS {
int user_id PK,FK
int movie_id PK,FK
int tag PK,FK
timestamp create_ts
}
&lt;/pre>
&lt;p>위와 같은 구조를 확인할 수 있었는데, 일반적으로 이러한 형태의 태그는 글과 함께 사용되는 해시태그 같은 기능이어서 어떻게 구조를 가져가야할지 고민이 들었습니다.&lt;/p>
&lt;p>제 추측으로는 이 데이터의 목적은 추천 모델 개발이므로 사용자와 영화의 관계, 사용자가 자주 활용한 태그, 특정 영화에 많이 활용된 태그 등 &lt;code>user_id&lt;/code>, &lt;code>movie_id&lt;/code>를 기준으로 활용하는 것이 더 적합했기 때문이라고 생각되었습니다.&lt;/p>
&lt;p>이 부분들을 고려하여 구성한 테이블 구조는 아래와 같습니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
TAGS {
string name PK
timestamp create_ts
}
REVIEWS_TAGS {
int user_id PK,FK
int movie_id PK,FK
int tag_name PK,FK
}
REVIEWS {
int review_id PK
int user_id FK
int movie_id FK
string content
timestamp create_ts
timestamp update_ts
}
TAGS ||--o{ REVIEWS_TAGS: ""
REVIEWS_TAGS }o--|| REVIEWS: ""
&lt;/pre>
&lt;p>기존 &lt;code>TAGS&lt;/code>를 &lt;code>REVIEWS_TAGS&lt;/code>로 바꿔 연결 테이블로 구성했습니다.&lt;/p>
&lt;p>&lt;code>TAGS&lt;/code> 테이블은 &lt;code>tag&lt;/code>만을 가지게 구성하고, 사용자가 영화에 후기를 남기는 기능을 고려하여 &lt;code>REVIEWS&lt;/code> 테이블을 추가하였습니다.&lt;/p>
&lt;p>&lt;code>TAGS&lt;/code> 테이블은 앞서 언급했던 데이터 중복 뿐만 아니라 특정 태그를 활용한 게시글 검색등 활용될 여지가 많기 때문에 추가하였습니다.&lt;/p>
&lt;p>사용 횟수 같은 컬럼들을 추가하는 것도 고려하였으나, 현 상황에서는 &lt;code>(tag_name)&lt;/code> 인덱스 추가 정도로 충분히 빠른 조회를 수행할 수 있기 때문에 게시글 작성, 수정, 삭제 등의 로직 처리에 변수들을 배제하는것이 좋겠다고 판단하였습니다.&lt;/p>
&lt;p>&lt;code>REVIEWS&lt;/code> 테이블은 비즈니스 요구사항(베스트 후기 등)에 따라 단독으로 활용될 여지가 많다고 생각되어 &lt;code>RATINGS&lt;/code> 테이블과 다르게 &lt;code>review_id&lt;/code>를 추가하였습니다.&lt;/p>
&lt;p>&lt;code>REVIEWS_TAGS&lt;/code> 테이블은 기존 외래키인 &lt;code>user_id&lt;/code>, &lt;code>movie_id&lt;/code>를 &lt;code>review_id&lt;/code>로 변경하지 않고 사용했는데, 위에서 언급한대로 사용자와 영화의 관계를 쉽게 이용하려면 기존 방식이 더 적합하고, &lt;code>REVIEWS&lt;/code>와 관련된 처리가 필요하다면 인덱스를 활용하여 충분히 쉽게 처리할 수 있다고 판단되었습니다.&lt;/p>
&lt;h2 id="끝으로">끝으로&lt;/h2>
&lt;p>데이터셋 구조 확인에 이어 간단히 데이터베이스 구조를 구상해봤습니다.&lt;/p>
&lt;p>만들어 놓고 보니 뭔가 찜찜한 기분이 계속 남네요..&lt;/p>
&lt;p>제 역량이 부족해서 어떤 문제들이 발생하게 될지 예상할 수는 없지만 앞으로 발견되는 부족한 부분들은 프로젝트를 진행하면서 조금씩 수정해나가겠습니다.&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다 :)&lt;/p></description></item></channel></rss>