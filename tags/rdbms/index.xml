<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RDBMS on Mario Blog</title><link>https://codemario318.github.io/tags/rdbms/</link><description>Recent content in RDBMS on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Tue, 22 Apr 2025 13:58:49 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/rdbms/index.xml" rel="self" type="application/rss+xml"/><item><title>B-Tree VS LSM Tree</title><link>https://codemario318.github.io/post/db/rdbms-nosql/</link><pubDate>Tue, 22 Apr 2025 13:58:49 +0900</pubDate><guid>https://codemario318.github.io/post/db/rdbms-nosql/</guid><description>&lt;img src="https://codemario318.github.io/post/db/rdbms-nosql/cover.png" alt="Featured image of post B-Tree VS LSM Tree" />&lt;p>최근 &amp;ldquo;&lt;strong>데이터 중심 애플리케이션 설계&lt;/strong>&amp;ldquo;을 읽으면서 데이터베이스의 저장소 엔진의 처리 방식이 성능에 미치는 영향에 대해 구체적으로 알게 되었습니다.&lt;/p>
&lt;p>책에서 해당 부분의 도입부를 읽으며, &amp;ldquo;&lt;strong>데이터를 처리하는 방식에 따라 유리한 형태는 다르고 적절한 방법을 선택 해야 한다&lt;/strong>&amp;ldquo;와 같은 조언으로 마무리 될 것으로 예상했었는데요&lt;/p>
&lt;p>실제로는 각 스토리지 엔진 구조의 장단점을 설명하면서 최근 인기를 끌고 있는것은 로그 구조화 스토리지 엔진이지만, B-Tree 계열은 오랜 기간 발전하면서 많은 작업 부하에도 대응할 수 있다는 내용이 언급하며, 실제 사용 사례에 적합한지 실제로 테스트 해보는 것도 좋은 방법이라는 언급이 있었습니다.&lt;/p>
&lt;p>그런 의미로 이 글에서는 &lt;strong>페이지 지향 계열 저장소 엔진&lt;/strong>(B-Tree)과 &lt;strong>로그 구조 계열 저장소 엔진&lt;/strong>(LSM Tree) 두 가지 주요 저장 구조를 비교 해보고, 어떤 식으로 약점을 개선했는지 자세히 살펴보려고 합니다.&lt;/p>
&lt;h2 id="두-저장-구조의-기본-원리">두 저장 구조의 기본 원리&lt;/h2>
&lt;p>책에서는 B-Tree와 로그 구조 계열 저장소 엔진(대표적으로 LSM Tree)의 쓰기 방식의 차이 주목하고 있습니다.&lt;/p>
&lt;h3 id="b-tree-구조">B-Tree 구조&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> [루트 페이지]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> / | \
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">[페이지1] [페이지2] [페이지3]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> / \ / \ / \
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">... ... ... ... ... ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>B-Tree는 MySQL InnoDB와 같은 대부분의 관계형 데이터베이스에서 사용하는 색인 구조입니다. MySQL의 InnoDB 스토리지 엔진은 기본키(PK)를 B-Tree로 관리하는 클러스터드 인덱스 방식을 사용합니다. B-Tree는 다음과 같은 특징을 가집니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>균형 잡힌 트리 구조&lt;/strong>:
&lt;ul>
&lt;li>모든 리프 노드가 같은 깊이에 위치하여 어떤 키에 대해서도 &lt;code>O(log n)&lt;/code> 시간 복잡도로 검색 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>페이지 단위 저장&lt;/strong>:
&lt;ul>
&lt;li>데이터를 고정 크기의 페이지 단위로 디스크에 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>제자리 갱신(in-place update)&lt;/strong>:
&lt;ul>
&lt;li>데이터를 삽입, 삭제, 수정할 때 해당 페이지의 내용을 직접 덮어쓰는 방식 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 특성으로 인해 InnoDB 에서 처리되는 쓰기 작업(&lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code> , &lt;code>DELETE&lt;/code>)은 B-Tree의 리프 노드에 달려있는 PK를 통해, 물리 기억 장치의 저장된 위치의 내용을 찾고, 해당 내용을 직접 덮어쓰는 방식으로 처리됩니다.&lt;/p>
&lt;h3 id="lsm-tree-구조">LSM Tree 구조&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[MemTable(메모리)] → [SS테이블1(디스크)] → [SS테이블2(디스크)] → ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ↓ ↓
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [컴팩션 프로세스] [컴팩션 프로세스]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ↓ ↓
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [병합된 SS테이블] [병합된 SS테이블]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>LSM Tree(Log-Structured Merge Tree)는 Cassandra, RocksDB, MongoDB의 WiredTiger 등 여러 NoSQL 데이터베이스에서 사용하는 저장 구조입니다. 주요 특징은 다음과 같습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>로그 기반 쓰기&lt;/strong>:
&lt;ul>
&lt;li>데이터 변경 사항을 로그처럼 디스크에 순차적으로 추가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>쓰기 버퍼링&lt;/strong>:
&lt;ul>
&lt;li>새로운 데이터를 먼저 메모리 내의 멤테이블(MemTable)에 버퍼링&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>컴팩션 프로세스&lt;/strong>:
&lt;ul>
&lt;li>주기적으로 데이터를 병합하고 압축하는 백그라운드 프로세스 실행&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>로그 기반 쓰기 특성으로 인해 값을 갱신하는 것이 아닌 최신 내용을 디스크에 추가만 하도록 처리되고, 백그라운드 컴팩션 작업을 통해 최신 내용만 남게되는 방식으로 처리됩니다.&lt;/p>
&lt;h2 id="성능-특성-비교">성능 특성 비교&lt;/h2>
&lt;p>쓰기 방식의 차이로 인해 데이터를 관리하는 방식도 달라지게되고, 이에 따라 요청하는 데이터를 처리하는 방식에도 차이가 있습니다.&lt;/p>
&lt;h3 id="읽기-성능">읽기 성능&lt;/h3>
&lt;p>&lt;strong>B-Tree의 읽기 성능&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>균형 잡힌 트리 구조로 인해 어떤 키든 일정한 시간 내에 조회 가능 (&lt;code>O(log n)&lt;/code>)&lt;/li>
&lt;li>실제 환경에서는 대부분 3-4단계 내에 데이터 접근 가능&lt;/li>
&lt;li>데이터가 정렬된 상태로 유지되어 범위 쿼리와 정렬된 스캔에 효율적&lt;/li>
&lt;li>인덱스가 메모리에 캐시될 경우 매우 빠른 접근 가능&lt;/li>
&lt;/ul>
&lt;p>위 설명처럼 어떤 키 값도 &lt;code>O(log n)&lt;/code> 시간 복잡도로 조회가 가능하고, 정렬된 상태로 키 값이 관리되기 때문에 B+Tree를 사용하게 되는 경우 Range Scan 작업도 빠르게 처리될 수 있습니다.&lt;/p>
&lt;p>특히 인덱스가 조회하려는 데이터를 모두 가지고 있는 Covering Index로 처리될 수 있다면, 읽기가 메모리 내에서만 처리될 수 있기 때문에 매우 빠르게 처리될 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>LSM Tree의 읽기 성능&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>특정 키를 찾기 위해 여러 SS테이블을 차례로 검색해야 할 수 있음&lt;/li>
&lt;li>메모리의 멤테이블부터 최신 SS테이블까지 순차적으로 확인 필요&lt;/li>
&lt;li>블룸 필터(Bloom Filter)와 같은 최적화를 통해 불필요한 SS테이블 검색을 줄일 수 있음&lt;/li>
&lt;li>컴팩션 작업 중에는 일시적으로 읽기 성능이 저하될 수 있음&lt;/li>
&lt;/ul>
&lt;p>같은 키를 가지는 새로운 데이터를 갱신하는 것이 아닌 파일에 추가하는 방식으로 처리되기 때문에, 메모리 상의 멤테이블에 데이터가 없다면, 가장 최신 SS테이블부터 해당 키를 가지는 데이터를 찾을 때 까지 모든 SS테이블을 확인해야합니다.&lt;/p>
&lt;p>이런 상황은 해당 키를 가지는 데이터가 존재하지 않는 경우 모든 SS테이블에 데이터가 없다는 것을 확인해야하기 때문에 성능이 많이 떨어질 수 있습니다.&lt;/p>
&lt;p>이런 경우를 대비하여 블룸 필터를 통해 최악의 경우는 회피하는 방식으로 최적화가 되어있습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>블룸 필터 Bloom filter&lt;/strong>&lt;br>
원소가 집합에 속하는지 여부를 검사하는데 사용되는 확률적 자료구조.&lt;br>
어떤 원소가 집합에 속한다고 판단된 경우 실제로는 원소가 집합에 속하지 않는 긍정 오류가 발생하는 것은 가능하지만, 원소가 집합에 속하지 않는 것으로 판단되었는데 실제로 원소가 집합에 속하는 부정 오류는 절대 발생하지 않는다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="쓰기-성능">쓰기 성능&lt;/h3>
&lt;p>&lt;strong>B-Tree의 쓰기 성능&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>데이터 수정 시 해당 페이지를 직접 덮어써야 함 (무작위 I/O 발생)&lt;/li>
&lt;li>균형 유지를 위한 페이지 분할 작업이 발생할 수 있음&lt;/li>
&lt;li>인덱스가 여러 개인 경우 모든 관련 인덱스 업데이트 필요&lt;/li>
&lt;li>WAL(Write-Ahead Log)을 통한 안전한 데이터 변경으로 추가적인 I/O 발생&lt;/li>
&lt;/ul>
&lt;p>위에서 살짝 언급한 것 처럼 데이터 수정이 필요할 경우 PK를 통해서 해당 페이지를 찾고 직접 덮어 써야 하기 때문에 무작위 I/O가 많이 발생하게 됩니다.&lt;/p>
&lt;p>그리고 데이터베이스에 따라 테이블에 여러 개의 보조 인덱스를 추가하는 경우 해당 인덱스(B-Tree) 갱신을 위해 추가적인 작업이 발생할 수 있습니다.&lt;/p>
&lt;p>또한 데이터 갱신 중 비정상적인 처리(종료)로 인해 데이터 변경 요청이 손실되는 것을 막기 위해 추가적인 쓰기 작업이 추가되는 경우도 있습니다(WAL).&lt;/p>
&lt;hr>
&lt;p>&lt;strong>LSM Tree의 쓰기 성능&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>데이터를 순차적으로 추가하므로 디스크 쓰기 효율이 높음&lt;/li>
&lt;li>메모리 버퍼링을 통해 디스크 I/O 횟수를 크게 줄임&lt;/li>
&lt;li>기존 데이터를 덮어쓰지 않으므로 페이지 분할 같은 구조 재조정이 필요 없음&lt;/li>
&lt;li>백그라운드 컴팩션이 필요하지만 쓰기 성능에 직접적인 영향은 적음&lt;/li>
&lt;/ul>
&lt;p>기본적으로 데이터 순차 쓰기 방식으로 처리되기 때문에 운영체제 수준에서 최적화가 잘 되어 Random I/O보다 훨씬 빠르게 처리될 수 있습니다.&lt;/p>
&lt;p>그리고 경우에 따라서 이 마저도 효과적으로 수행할 수 있도록 버퍼링을 통해 데이터를 모아 처리하는 방식으로 최적화 하기도 합니다.&lt;/p>
&lt;h2 id="실제-구현에서의-최적화-기법">실제 구현에서의 최적화 기법&lt;/h2>
&lt;p>지금까지의 내용만 본다면, B-Tree 기반 데이터베이스는 쓰기에 불리하고 로그 기반 데이터베이스는 읽기에 불리한 것 처럼 느껴집니다. (사실 일반적으로 그렇게 생각되는 경우가 많은 것 같습니다.)&lt;/p>
&lt;p>그렇지만 불리한 성능을 개선하기 위해 여러 최적화가 적용되어 있습니다.&lt;/p>
&lt;h3 id="b-tree-기반-시스템의-주요-최적화-innodb-사례">B-Tree 기반 시스템의 주요 최적화 (InnoDB 사례)&lt;/h3>
&lt;p>MySQL의 InnoDB 스토리지 엔진은 데이터를 갱신해야함으로 발생하는 Random I/O로 인한 병목을 개선하기 위해 여러 아이디어를 적용했습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/db/rdbms-nosql/img.png"
width="856"
height="667"
srcset="https://codemario318.github.io/post/db/rdbms-nosql/img_hue3e0905a4663bd838b952fb1b242c93f_73721_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/db/rdbms-nosql/img_hue3e0905a4663bd838b952fb1b242c93f_73721_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="InnoDB 아키텍처"
class="gallery-image"
data-flex-grow="128"
data-flex-basis="308px"
>&lt;/p>
&lt;p>기본적으로 InnoDB 스토리지 엔진은 버퍼풀을 통해 메모리 영역에 당장 활용되어야 하는 데이터들을 캐싱하고, 변경 내용들을 버퍼링(더티 페이지)하여 주기적인 플러싱(flushing)으로 백그라운드 작업을 통해 디스크에 실제로 반영하게 됩니다.&lt;/p>
&lt;p>이러한 내용들을 요약해보면 아래와 같습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>버퍼링과 지연 쓰기&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>버퍼풀&lt;/strong>:
&lt;ul>
&lt;li>자주 접근하는 데이터 페이지를 메모리에 캐싱하여 I/O 감소&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>변경 버퍼(Change Buffer)&lt;/strong>:
&lt;ul>
&lt;li>보조 인덱스 변경 사항을 메모리에 버퍼링하여 나중에 적용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>쓰기 지연&lt;/strong>:
&lt;ul>
&lt;li>변경 사항을 즉시 디스크에 쓰지 않고 더티 페이지로 유지하다가 효율적으로 일괄 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>로깅과 복구 최적화&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>리두 로그&lt;/strong>:
&lt;ul>
&lt;li>변경 사항을 순차적인 로그에 먼저 기록하여 I/O 효율성 향상&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>그룹 커밋&lt;/strong>:
&lt;ul>
&lt;li>여러 트랜잭션의 커밋을 묶어 처리하여 I/O 오버헤드 감소&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>이중 쓰기 버퍼&lt;/strong>:
&lt;ul>
&lt;li>데이터 무결성을 보장하면서도 순차적 쓰기를 통해 I/O 효율성 향상&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>동시성 향상 기법&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>MVCC(다중 버전 동시성 제어)&lt;/strong>:
&lt;ul>
&lt;li>읽기 작업이 쓰기 작업을 차단하지 않도록 하여 전반적인 동시성 향상&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>버퍼풀 인스턴스 분할&lt;/strong>:
&lt;ul>
&lt;li>내부 잠금 경합을 줄이고 병렬 처리 효율 향상&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>백그라운드 처리&lt;/strong>:
&lt;ul>
&lt;li>페이지 클리너 스레드가 더티 페이지를 비동기적으로 디스크에 기록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="lsm-tree-기반-시스템의-주요-최적화-cassandra-사례">LSM Tree 기반 시스템의 주요 최적화 (Cassandra 사례)&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/db/rdbms-nosql/img_1.png"
width="1355"
height="854"
srcset="https://codemario318.github.io/post/db/rdbms-nosql/img_1_hub64386be61c9330102f53e13d81bc75b_321472_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/db/rdbms-nosql/img_1_hub64386be61c9330102f53e13d81bc75b_321472_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="LSM Tree 기반 시스템 처리"
class="gallery-image"
data-flex-grow="158"
data-flex-basis="380px"
>&lt;/p>
&lt;p>카산드라는 아래와 같은 순서로 쓰기 작업이 수행됩니다.&lt;/p>
&lt;ul>
&lt;li>커밋 로그에 데이터 기록하기&lt;/li>
&lt;li>멤테이블에 데이터 쓰기&lt;/li>
&lt;li>멤테이블에서 데이터 플러시하기&lt;/li>
&lt;li>SSTables의 디스크에 데이터 저장&lt;/li>
&lt;/ul>
&lt;p>처음 커밋 로그에 데이터를(내구성 보장을 위해) 기록하고 멤테이블에 데이터를 쓰게되는데, 멤테이블은 쓰기를 버퍼링하고 데이터 파티션을 캐싱하는 역할도 함께 수행하게 됩니다.&lt;/p>
&lt;p>멤테이블은 지정한 크기에 도달할 때 까지 정렬된 순서를 유지하며 쓰기를 캐싱하고, 한계에 도달하면 디스크에 플러시되어 SS테이블로 저장됩니다.&lt;/p>
&lt;p>SS테이블은 변경 불가능하므로 데이터가 업데이트되거나 삭제될 때 이전 데이터를 삽입 또는 업데이트로 덮어쓰거나 SS테이블에서 제거하지 않습니다.&lt;/p>
&lt;p>대신 새 타임스탬프가 있는 업데이트된 데이터로 새 SS테이블이 만들어지고 이전 SS테이블은 삭제 표시가 됩니다. (삭제된 데이터 조각을 툼스톤이라고 함)&lt;/p>
&lt;hr>
&lt;p>&lt;strong>컴팩션 전략 최적화&lt;/strong>&lt;/p>
&lt;p>이러한 특성으로 인해 여러 버전의 행을 여러 SS테이블에 기록할 수 있고, SS테이블이 많아지면 전체 행을 검색하기 위해 점점 더 많은 SS테이블에 액세스해야 할 수 있습니다.&lt;/p>
&lt;p>이로 인해 읽기 성능이 떨어지는 것을 막기 위해 주기적으로 SS테이블을 병합하고 오래된 데이터를 폐기하는데, 이를 컴팩션이라고 합니다.&lt;/p>
&lt;p>컴팩션은 백그라운드로 수행되긴 하지만 쓰기 작업을 발생시키므로 이를 최적화하는 방법들이 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>레벨 컴팩션(Leveled Compaction)&lt;/strong>:
&lt;ul>
&lt;li>데이터를 여러 레벨로 구성하여 컴팩션 비용 분산&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>사이즈 단계별 컴팩션(Size-Tiered Compaction)&lt;/strong>:
&lt;ul>
&lt;li>비슷한 크기의 SS테이블끼리 병합하여 효율성 향상&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>컴팩션 스로틀링&lt;/strong>:
&lt;ul>
&lt;li>컴팩션이 다른 작업에 미치는 영향을 제한하여 일관된 성능 유지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>읽기 성능 향상 기법&lt;/strong>&lt;/p>
&lt;p>컴팩션 외에도 읽기 성능을 향상시키는 기법들도 존재합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>블룸 필터&lt;/strong>:
&lt;ul>
&lt;li>특정 키가 SS테이블에 없다는 것을 효율적으로 확인하여 불필요한 디스크 접근 감소&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>파티셔닝&lt;/strong>:
&lt;ul>
&lt;li>데이터를 파티션으로 나누어 병렬 처리 및 검색 범위 축소&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>인덱스 요약(Index Summary)&lt;/strong>:
&lt;ul>
&lt;li>각 SS테이블의 키 범위 정보를 메모리에 유지하여 검색 효율 향상&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>쓰기 최적화&lt;/strong>&lt;/p>
&lt;p>아래와 같은 방법들이 도움이 될 수 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>WAL 최적화&lt;/strong>:
&lt;ul>
&lt;li>로그 압축, 그룹 커밋 등을 통한 로깅 효율성 향상&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>멤테이블 구현 최적화&lt;/strong>:
&lt;ul>
&lt;li>효율적인 자료구조(스킵 리스트 등) 사용으로 메모리 내 작업 속도 향상&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>직접 I/O&lt;/strong>:
&lt;ul>
&lt;li>운영체제 캐시를 우회하여 데이터베이스가 자체적으로 메모리 관리 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="어떤-상황에-어떤-저장-구조가-적합한가">어떤 상황에 어떤 저장 구조가 적합한가?&lt;/h2>
&lt;p>완벽하게 적합한지 결정하기는 어렵지만, 일반적으로 아래와 같은 상황에 맞는 저장 구조를 활용하면 좋다고 알려져 있습니다.&lt;/p>
&lt;h3 id="b-tree가-적합한-상황">B-Tree가 적합한 상황&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>복잡한 트랜잭션이 필요한 경우&lt;/strong>:
&lt;ul>
&lt;li>ACID 속성이 중요한 금융, 전자상거래 애플리케이션&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>다양한 인덱싱과 복잡한 쿼리가 필요한 경우&lt;/strong>:
&lt;ul>
&lt;li>다중 인덱스, 조인, 집계 함수 등을 활용하는 분석 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>읽기 작업이 쓰기보다 훨씬 많은 경우&lt;/strong>:
&lt;ul>
&lt;li>데이터 변경이 적고 조회가 빈번한 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>데이터 크기가 메모리에 대부분 캐싱될 수 있는 경우&lt;/strong>:
&lt;ul>
&lt;li>데이터셋이 상대적으로 작은 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="lsm-tree가-적합한-상황">LSM Tree가 적합한 상황&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>대규모 쓰기 워크로드&lt;/strong>:
&lt;ul>
&lt;li>로그 수집, IoT 센서 데이터, 클릭스트림 추적 등 초당 수만에서 수십만 건의 삽입이 필요한 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>스키마리스 데이터 모델이 필요한 경우&lt;/strong>:
&lt;ul>
&lt;li>빠르게 변화하는 비즈니스 요구사항에 대응해야 하는 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>수평적 확장성이 중요한 경우&lt;/strong>:
&lt;ul>
&lt;li>샤딩을 통해 쉽게 확장해야 하는 분산 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>압축률이 중요한 경우&lt;/strong>:
&lt;ul>
&lt;li>저장 공간 효율성이 중요한 대용량 데이터 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="선택-시-고려사항">선택 시 고려사항&lt;/h2>
&lt;p>적합한 저장 구조를 선택할 때 아래와 같은 내용을 고려한다면 조금 더 쉽게 결정할 수 있습니다.&lt;/p>
&lt;h3 id="워크로드-특성">워크로드 특성&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>읽기/쓰기 비율&lt;/strong>:
&lt;ul>
&lt;li>읽기가 주로 필요하면 B-Tree, 쓰기가 많으면 LSM Tree 고려&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>쿼리 패턴&lt;/strong>:
&lt;ul>
&lt;li>복잡한 조인과 트랜잭션이 필요하면 B-Tree, 단순 키-값 조회가 주된 작업이면 LSM Tree 적합&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>데이터 크기와 성장 속도&lt;/strong>:
&lt;ul>
&lt;li>대용량 데이터와 빠른 성장이 예상되면 LSM Tree의 압축률과 확장성이 유리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="하드웨어-환경">하드웨어 환경&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>스토리지 유형&lt;/strong>:
&lt;ul>
&lt;li>HDD 환경에서는 순차적 I/O에 최적화된 LSM Tree가 유리, SSD에서는 차이가 줄어듦&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>메모리 용량&lt;/strong>:
&lt;ul>
&lt;li>대용량 메모리가 가능한 환경에서는 B-Tree의 캐싱 효과가 극대화됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>CPU 자원&lt;/strong>:
&lt;ul>
&lt;li>LSM Tree의 컴팩션은 추가 CPU 리소스를 소모하므로 CPU 제한 환경에서는 고려 필요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="실제-벤치마크-테스트의-중요성">실제 벤치마크 테스트의 중요성&lt;/h3>
&lt;p>이론적인 성능 특성은 중요한 지침이 되지만, 실제 운영 환경에서는 예상과 다른 결과가 나올 수 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>실제 데이터와 패턴 사용&lt;/strong>:
&lt;ul>
&lt;li>실제 애플리케이션의 데이터 분포와 쿼리 패턴을 반영한 벤치마크 수행&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>확장성 테스트&lt;/strong>:
&lt;ul>
&lt;li>현재 데이터 크기뿐만 아니라 예상되는 미래 데이터 크기에서도 테스트&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>장기 실행 테스트&lt;/strong>:
&lt;ul>
&lt;li>시간이 지남에 따른 성능 변화(단편화, 컴팩션 오버헤드 등) 평가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>B-Tree와 LSM Tree는 각각 고유한 장단점을 가진 저장 구조입니다. 전통적으로 B-Tree는 읽기에, LSM Tree는 쓰기에 최적화되어 있다고 여겨지고 일반적으로 그렇지만, 현대적인 데이터베이스 엔진들은 다양한 최적화를 통해 이러한 문제들을 보완하고 있습니다.&lt;/p>
&lt;p>이전 직장에서도 다양한 유형의 워크로드를 RDBMS 만으로도 처리했었고, 쓰기 작업이 불리하다고 여겨지는 RDBMS가 실제 사용했을 때 큰 문제가 발생하지 않는 이유를 살펴보니, 극단적으로 많은 처리가 필요한 상황이 아니라면 &amp;ldquo;적합한 데이터베이스 선택&amp;quot;과 같은 문제는 사소한 문제인걸까? 라는 생각도 들었습니다.&lt;/p>
&lt;p>더 나아가서 새로운 기술들을 적용하는 것 자체가 대부분의 상황에서 불필요할 수도 있겠다는 회의감도 새삼스럽게 드는 것 같습니다.&lt;/p>
&lt;p>이러한 고민을 적용해 볼 수 있는 곳에서 꼭 일해보고 싶네요! 끝까지 읽어주셔서 감사합니다😊&lt;/p></description></item><item><title>8. 분산 메일 서비스</title><link>https://codemario318.github.io/post/system-design-interview-2/8/</link><pubDate>Wed, 23 Oct 2024 13:53:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/8/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/cover.png" alt="Featured image of post 8. 분산 메일 서비스" />&lt;p>이번 장에서는 지메일, 아웃룩 같은 대규모 이메일 서비스를 설계해본다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>현대적 이메일 서비스는 다양한 기능을 갖춘 복잡한 시스템으로 발전했다. 따라서 짧은시간에 설계는 불가능하므로 질문을 통해 설계 범위를 좁혀야한다.&lt;/p>
&lt;ul>
&lt;li>&lt;del>인증&lt;/del>&lt;/li>
&lt;li>이메일 발송/수신&lt;/li>
&lt;li>모든 이메일 가져오기&lt;/li>
&lt;li>읽음 여부에 따른 이메일 필터링&lt;/li>
&lt;li>제목, 발신인, 메일 내용에 따른 검색 기능&lt;/li>
&lt;li>스팸 및 바이러스 방지 기능&lt;/li>
&lt;li>프로토콜
&lt;ul>
&lt;li>SMTP, POP, IMAP 등과 같은 서비스 제공자 전용 프로토콜이 있으나 HTTP 사용한다고 가정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부파일 지원&lt;/li>
&lt;/ul>
&lt;h3 id="비기능적-요구사항">비기능적 요구사항&lt;/h3>
&lt;ul>
&lt;li>안정성
&lt;ul>
&lt;li>이메일 데이터는 소실되어선 안된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가용성
&lt;ul>
&lt;li>이메일과 사용자 데이터를 여러 노드에 자동으로 복제하여 가용성을 보장해야한다.&lt;/li>
&lt;li>부분적으로 장애가 발생해도 시스템은 계속 동작해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확정성
&lt;ul>
&lt;li>사용자 수가 늘어나더라도 감당할 수 있어야 한다.&lt;/li>
&lt;li>사용자나 이메일이 많아져도 시스템 성능은 저하되지 않아야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유연성과 확장성
&lt;ul>
&lt;li>새 컴포넌트를 더하여 쉽게 기능을 추가하고 성능을 개선할 수 있는 유연하고 확장성 높은 시스템이어야 한다.&lt;/li>
&lt;li>POP나 IMAP 같은 기존 이메일 프로토콜은 기능이 매우 제한적이므로, 요구사항을 만족하기 위해 맞춤형 프로토콜이 필요할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적인-규모-추정">개략적인 규모 추정&lt;/h3>
&lt;ul>
&lt;li>10억 사용자&lt;/li>
&lt;li>한 사람이 하루에 보내는 평균 이메일 수는 10건 가정
&lt;ul>
&lt;li>&lt;code>QPS = 10^9 * 10 / 10^5 = 100,000&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>한 사람이 하루에 수신하는 이메일 수는 평균 40건 가정&lt;/li>
&lt;li>메일 하나의 메타데이터는 평균 50KB로 가정(첨부파일 X)&lt;/li>
&lt;li>메타데이터는 데이터베이스에 저장한다고 가정
&lt;ul>
&lt;li>1년간 메타데이터를 유지하기 위한 스토리지 요구사항은 &lt;code>10억 사용자 * 하루 40건 * 365일 * 50KB = 730PB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부 파일을 포함하는 이메일의 비율은 20%, 평균 크기는 50KB 가정
&lt;ul>
&lt;li>1년간 첨부 파일을 보관하는 데 필요한 저장 용량은 &lt;code>10억 사용자 * 하루 40건 * 365 * 20% * 500KB = 1,460PB&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>많은 데이터를 처리해야하므로 분산 데이터베이스 솔루션이 필요하다.&lt;/p>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>이메일 서버에 대해 알아야 할 기본적인 사항과 더불어 서버가 시간이 흐름에 따라 어떻게 진화하는지 논의한다.&lt;/p>
&lt;p>그 후 분산 이메일 서버의 개략적인 설계안을 살펴본다.&lt;/p>
&lt;h3 id="이메일-101">이메일 101&lt;/h3>
&lt;p>이메일을 주고받는 프로토콜에는 대부분 POP, IMAP, SMTP 같은 프로토콜을 사용해왔다.&lt;/p>
&lt;h4 id="이메일-프로토콜">이메일 프로토콜&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>SMTP&lt;/strong>(Simple Mail Transfer Protocol)
&lt;ul>
&lt;li>이메일을 한 서버에서 다른 서버로 보내는 표준 프로토콜&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>POP&lt;/strong>(Post Office Protocol)
&lt;ul>
&lt;li>이메일을 가져오는 목적으로 널리 사용&lt;/li>
&lt;li>이메일 클라이언트가 원격 메일 서버에서 이메일을 수신하고 다운로드하기 위해 사용하는 표준 프로토콜&lt;/li>
&lt;li>단말로 다운로드된 이메일은 서버에서 삭제
&lt;ul>
&lt;li>결과적으로 한 대 단말에서만 이메일을 읽을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일을 확인하기 위해 전부 내려받아야 함
&lt;ul>
&lt;li>용량이 큰 첨부 파일이 붙은 이메일은 읽으려면 시간이 오래걸림&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>IMAP&lt;/strong>(Internet Mail Access Protocol)
&lt;ul>
&lt;li>이메일을 가져오는 목적으로 널리 사용&lt;/li>
&lt;li>POP과 달리 클리하지 않으면 메시지는 다운로드 되지 않으며, 메일 서버에서 지워지지도 않음
&lt;ul>
&lt;li>여러 단말에서 이메일을 읽을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개인 이메일 계정에서 가장 널리 사용되는 프로토콜&lt;/li>
&lt;li>이메일을 실제로 열기 전에는 헤더만 다운로드
&lt;ul>
&lt;li>인터넷 속도가 느려도 잘 동작함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>HTTPS&lt;/strong>
&lt;ul>
&lt;li>메일 전송 프로토콜은 아니지만 웹 기반 이메일 시스템의 메일함 접속에 이용될 수 있음&lt;/li>
&lt;li>ex) 아웃룩의 액티브 싱크&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="dns---도메인-이름-서비스">DNS - 도메인 이름 서비스&lt;/h4>
&lt;p>수신자 도메인의 메일 교환기 레코드(Mail Exchange, MX) 검색에 이용된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img.png"
width="1494"
height="546"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_hub7f0eb4bd2d0a33dfc88796a278dea75_678809_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_hub7f0eb4bd2d0a33dfc88796a278dea75_678809_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MX 레코드"
class="gallery-image"
data-flex-grow="273"
data-flex-basis="656px"
>&lt;/p>
&lt;ul>
&lt;li>숫자는 우선순위 값으로 선호도를 나타내어 값이 낮으면 높은 우선순위로 처리됨&lt;/li>
&lt;/ul>
&lt;h4 id="첨부-파일">첨부 파일&lt;/h4>
&lt;p>첨부 파일은 이메일 메시지와 함께 전송되며 일반적으로 Base64 인코딩을 활용한다.&lt;/p>
&lt;p>일반적으로 첨부 파일에는 크기 제한이 있고, 설정 가능한 수치로, 개인 계정이냐 기업 계정이냐에 따라 다르게 설정된다.(필요한 만큼 알아서 설정한다)&lt;/p>
&lt;ul>
&lt;li>아웃룩 20MB, 지메일 25MB&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>MIME&lt;/strong>( Multi-purpose Internet Mail Extension)&lt;br>
인터넷을 통해 첨부 파일을 전송할 수 있도록 하는 표준 규격&lt;/p>
&lt;/blockquote>
&lt;h4 id="전통적-메일-서버">전통적 메일 서버&lt;/h4>
&lt;p>분산 메일 서버에 알아보기 전 기존 메일 서버의 역사와 동작 방식에 대해 살펴본다.&lt;/p>
&lt;p>전통적인 메일 서버는 보통 &lt;strong>서버 한 대로 운용되는, 사용자가 많지 않을 때 잘 동작하는 시스템&lt;/strong>이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>전통적 메일 서버 아키텍처&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_1.png"
width="1166"
height="928"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_1_hu802478e41453ab6fdfaa430529afc2d8_190128_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_1_hu802478e41453ab6fdfaa430529afc2d8_190128_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="전통적 메일 서버"
class="gallery-image"
data-flex-grow="125"
data-flex-basis="301px"
>&lt;/p>
&lt;ol>
&lt;li>보내기 버튼을 누르면 메일 서버로 전송된다.(SMTP)&lt;/li>
&lt;li>메일 서버는 DNS 질의를 통해 수신 SMTP 서버를 찾고 해당 서버로 이메일을 보낸다(SMTP)&lt;/li>
&lt;li>메일을 수신한 서버는 이메일을 저장하고 수신자가 읽어갈 수 있도록 한다.&lt;/li>
&lt;li>수신자가 로그인하면 IMAP/POP 서버를 통해 새 이메일을 가져온다.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>&lt;strong>저장소&lt;/strong>&lt;/p>
&lt;p>전통적 메일 서버는 &lt;strong>이메일을 파일 시스템의 디렉터리에 저장&lt;/strong>한다.&lt;/p>
&lt;p>각각의 이메일은 고유한 이름을 가진 별도 파일로 보관도며, 각 사용자의 설정 데이터와 메일함은 사용자 디렉터리에 보관한다.&lt;/p>
&lt;ul>
&lt;li>이러한 디렉터리 구조를 &lt;strong>Maildir&lt;/strong> 이라고 함&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_2.png"
width="920"
height="1166"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_2_hu2474c31464cc06986e6e832f2b67e40e_32499_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_2_hu2474c31464cc06986e6e832f2b67e40e_32499_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Maildir"
class="gallery-image"
data-flex-grow="78"
data-flex-basis="189px"
>&lt;/p>
&lt;p>파일과 디렉터리를 활용하는 방안은 사용자가 많지 않을 때는 잘 동작하나 디스크 I/O로 인한 병목으로 인해 수십억 개의 이메일을 검색하고 백업하는 목적으로 활용하기에는 곤란했다.&lt;/p>
&lt;p>그리고 &lt;strong>이메일을 서버의 파일 시스템에 보관&lt;/strong>하였기 때문에 &lt;strong>가용성과 안정성&lt;/strong> 요구사항도 만족할 수 없었기 때문에 더 안정적인 분산 데이터 저장소 계층이 필요했다.&lt;/p>
&lt;ul>
&lt;li>디스크 손상, 서버 장애 등&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이메일 기능은 1960년대에 발명된 이래로 텍스트 중심에서 멀티미디어, 메일 스레드, 검색, 레이블 등 다양한 기능을 지원하도록 발전해 왔지만, POP, IMAP, SMTP 같은 이메일 프로토콜은 이러한 기능을 지원하도록 설계되지 않았기 때문에 확장할 수 없었다.&lt;/p>
&lt;h3 id="분산-메일-서버">분산 메일 서버&lt;/h3>
&lt;p>분산 메일 서버는 현대적 사용 패턴을 지원하고 확장성과 안정성 문제를 해결한다.&lt;/p>
&lt;h4 id="이메일-api">이메일 API&lt;/h4>
&lt;p>이메일 API의 의미는 메일 클라이언트, 이메일 생명주기 단계마다 달라질 수 있다.&lt;/p>
&lt;ul>
&lt;li>모바일 단말 클라이언트를 위한 SMTP/POP/IMAP API&lt;/li>
&lt;li>송신 측 메일 서버와 수신 측 메일 서버 간의 SMTP 통신&lt;/li>
&lt;li>대화형 웹 기반 이메일 애플리케이션을 위한 HTTP 기반 RESTful API&lt;/li>
&lt;/ul>
&lt;p>이 책에서는 가장 중요한 API만 다루며, 웹메일 통신에는 일반적으로 HTTP 프로토콜이 쓰인다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>POST /v1/messages&lt;/code>&lt;/strong>&lt;/p>
&lt;p>To, Tc, Bcc 헤더에 명시된 수신자에게 메시지를 전송한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/folders&lt;/code>&lt;/strong>&lt;/p>
&lt;p>주어진 이메일 계정에 존재하는 모든 폴더를 반환한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">[{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;id&amp;#34;: string,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;name&amp;#34;: string,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;user_id&amp;#34;: string
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/folders/{:folder_id}/messages&lt;/code>&lt;/strong>&lt;/p>
&lt;p>주어진 폴더 아래의 모든 메시지를 반환한다.&lt;/p>
&lt;ul>
&lt;li>단순화한 명세로 페이지네이션을 지원해야 하는 등 훨씬 복잡할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>&lt;code>GET /v1/messages/{:message_id}&lt;/code>&lt;/strong>&lt;/p>
&lt;p>주어진 특정 메시지에 대한 모든 정보를 반환한다.&lt;/p>
&lt;p>메시지는 이메일 애플리케이션의 핵심 구성 요소이다.&lt;/p>
&lt;ul>
&lt;li>발신자, 수신자, 메시지 제목, 본문, 첨부 파일 등의 정보로 구성&lt;/li>
&lt;/ul>
&lt;h4 id="분산-메일-서버-아키텍처">분산 메일 서버 아키텍처&lt;/h4>
&lt;p>전통적인 이메일 서버가 단일 장비 위에서만 동작하도록 설계되었기 때문에 한 대 이상의 서버로 규모를 늘리는 것은 까다롭다.&lt;/p>
&lt;ul>
&lt;li>여러 서버 사이에 데이터를 동기화하는 것은 어려운 작업이다.&lt;/li>
&lt;li>수신자 메일 서버에서 이메일이 스팸으로 잘못 분류되지 않도록 하려면 까다로운 문제들을 풀어야한다.&lt;/li>
&lt;/ul>
&lt;p>이번 절에서는 클라우드 기술을 활용하여 이러한 문제를 쉽게 푸는 방법을 알아본다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_3.png"
width="1328"
height="1040"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_3_hu97293f0920808d780af3a4f7f2404b28_190471_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_3_hu97293f0920808d780af3a4f7f2404b28_190471_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="127"
data-flex-basis="306px"
>&lt;/p>
&lt;ul>
&lt;li>웹메일
&lt;ul>
&lt;li>사용자는 웹브라우저를 사용해 메일을 받고 보냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹서버
&lt;ul>
&lt;li>사용자가 이용하는 요청/응답 서비스로, 로그인, 가입, 사용자 프로파일 등에 대한 관리 기능을 담당&lt;/li>
&lt;li>본 설계안에서는 이메일 발송, 폴더 목록 확인, 폴더 내 모든 메시지 확인 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>실시간 서버
&lt;ul>
&lt;li>새로운 이메일 내역을 클라이언트에 실시간으로 전달한다.&lt;/li>
&lt;li>지속성 연결을 맺고 유지해야하므로 상태 유지 서버다.
&lt;ul>
&lt;li>롱폴링, 웹소켓 등&lt;/li>
&lt;li>웹소켓이 좀 더 우아하지만 브라우저 호환성 문제가 있을 수 있다.&lt;/li>
&lt;li>기본적으로는 웹 소켓을 쓰되 여의치 않으면 롱 폴링을 백업으로 이용할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메타데이터 데이터베이스
&lt;ul>
&lt;li>이메일 제목, 본문, 발신인, 수신인 목록 등 메타 데이터를 저장하는 데이터베이스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부 파일 저장소
&lt;ul>
&lt;li>아마존 S3(Simple Storage Service) 같은 객체 저장소를 사용할 것이다.
&lt;ul>
&lt;li>이미지나 동영상 등의 대용량 파일을 저장하는 데 적합하고 확장이 용이한 인프라이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첨부파일 크기는 25MB로 제한한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>분산 캐시
&lt;ul>
&lt;li>최근에 수신된 이메일은 자주 읽을 가능성이 높으므로 클라이언트로 하여금 메모리에 캐시해 두도록 하면 메일을 표시하는 시간을 많이 줄일 수 있다.&lt;/li>
&lt;li>레디스
&lt;ul>
&lt;li>리스트와 같은 다양한 기능을 제공하고, 규모 확장이 용이하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>검색 저장소
&lt;ul>
&lt;li>검색 저장소는 분산 문서 저장소이다.&lt;/li>
&lt;li>고속 텍스트 검색을 지원하는 &lt;strong>역 인덱스&lt;/strong>를 자료 구조로 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>카산드라가 첨부 파일 저장소로 적합하지 않은 이유&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>카산드라가 BLOB 자료형을 지원하고 해당 자료형이 지원하는 데이터의 최대 크기가 2GB이긴 하지만 실질적으로는 1MB 이상의 파일은 지원하지 못한다.&lt;/li>
&lt;li>카산드라에 첨부 파일을 저장하면 첨부 파일이 너무 많은 메모리를 사용하게되어 레코드 캐시를 사용하기 어렵다.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="이메일-전송-절차">이메일 전송 절차&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_4.png"
width="1698"
height="1126"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_4_hu6c1accd62c346f29cf05623f72575dc4_306833_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_4_hu6c1accd62c346f29cf05623f72575dc4_306833_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이메일 전송 절차"
class="gallery-image"
data-flex-grow="150"
data-flex-basis="361px"
>&lt;/p>
&lt;ol>
&lt;li>사용자가 웹에서 메일을 정송하면 요청은 로드밸런서로 전송된다.&lt;/li>
&lt;li>로드벨런서가 처리율 제한 한도를 넘지 않는 선에서 요청을 웹 서버로 전달한다.&lt;/li>
&lt;li>웹 서버는 다음 역할을 담당한다.
&lt;ul>
&lt;li>기본적인 이메일 검증
&lt;ul>
&lt;li>이메일 크기 한도 같은 사전 미리 정의된 규칙을 사용하여 수신된 이메일을 검사한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>수신자 이메일 주소 도메인이 송신자 이메일 주소 도메인과 같은지 검사
&lt;ul>
&lt;li>이메일 내용의 스팸 여부와 바이러스 감염 여부를 검사&lt;/li>
&lt;li>검사를 통과한 이메일은 송신인의 보낸 편지함과 수신인의 받은 편지함에 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>수신인 측 클라이언트는 RESTful API를 사용하여 이메일을 바로 가져올 수 있어 4단계 이후는 수행할 필요가 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 큐
&lt;ol>
&lt;li>기본적인 검증을 통과한 이메일은 외부 전송 큐로 전달된다.
&lt;ul>
&lt;li>&lt;strong>첨부 파일의 크기가 너무 큰 이메일&lt;/strong>의 경우 &lt;strong>첨부 파일을 객체 저장소에 따로 저장&lt;/strong>하고 해당 &lt;strong>저장 위치에 대한 참조 정보만 저장&lt;/strong>한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>기본적인 검증에 실패한 이메일은 에러 큐에 보관한다.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>외부 전송 담당 SMTP 작엄 프로세스는 외부 전송 큐에서 메시지를 꺼내어 이메일의 스팸 및 바이러스 감염 여부를 확인한다.&lt;/li>
&lt;li>검증 절차를 통과한 이메일은 저장소 계층 내의 보낸 편지함에 저장된다.&lt;/li>
&lt;li>외부 전송 담당 SMTP 작업 프로세스가 수신자의 메일 서버로 메일을 전송한다.&lt;/li>
&lt;/ol>
&lt;p>외부 전송 큐에 보관되는 모든 메시지에는 &lt;strong>이메일을 생성하는 데 필요한 모든 메타데이터가 포함&lt;/strong>되어 있다.&lt;/p>
&lt;p>&lt;strong>분산 메시지 큐&lt;/strong>는 비동기적 메일 처리를 가능케 하는 핵심적 컴포넌트이다.&lt;/p>
&lt;ul>
&lt;li>웹 서버에서 외부 전송 담당 SMTP 프로세스를 분리함으로 전송용 SMTP 프로세스의 규모를 독립적으로 조정할 수 있게 된다.&lt;/li>
&lt;/ul>
&lt;p>외부 전송 큐의 크기를 모니터링 할 때 메일이 처리되지 않고 큐에 오랫동안 남아 있으면 그 이유를 분석해야한다.&lt;/p>
&lt;ul>
&lt;li>수신자 측 메일 서버에 장애 발생
&lt;ul>
&lt;li>나중에 메일을 다시 전송해야 한다.&lt;/li>
&lt;li>ex) 지수적 백오프(Exponential Backoff)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일을 보낼 큐의 소비자 수가 불충분
&lt;ul>
&lt;li>더 많은 소비자를 추가하여 처리 시간을 단축하는 방법을 생각해 볼 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="이메일-수신-절차">이메일 수신 절차&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_5.png"
width="1824"
height="946"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_5_hufa935ff62aaff4ec9a22919e7479ce7e_259381_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_5_hufa935ff62aaff4ec9a22919e7479ce7e_259381_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="이메일 수신 절차"
class="gallery-image"
data-flex-grow="192"
data-flex-basis="462px"
>&lt;/p>
&lt;ol>
&lt;li>이메일이 SMTP 로드밸런서에 도착&lt;/li>
&lt;li>트래픽을 여러 SMTP 서버로 분산
&lt;ul>
&lt;li>SMTP 연결에는 이메일 수락 정책을 구성하여 적용 가능&lt;/li>
&lt;li>유효하지 않은 이메일은 방송하도록 하여 불필요한 이메일 처리를 피할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일의 첨부 파일이 큐에 들어가기 너무 큰 경우 첨부 파일 저장소(S3)에 보관&lt;/li>
&lt;li>이메일을 수신 이메일 큐에 넣는다
&lt;ul>
&lt;li>메일 처리 작업 프로세스와 SMTP 간 결합도를 낮추어 각자 독립적으로 규모 확장이 가능하도록 함&lt;/li>
&lt;li>수신 이메일이 폭증하는 경우 버퍼 역할도 하게됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메일 처리 작업 프로세스(worker)는 스팸 메일을 걸러내고 바이러스를 차단하는 등의 다양한 역할 담당
&lt;ul>
&lt;li>이후 처리는 검증 작업이 끝난 이메일을 대상으로 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일을 메일 저장소, 캐시, 객체 저장소 등에 보관&lt;/li>
&lt;li>수신자가 온라인 상태일 경우 실시간 서버로 전달&lt;/li>
&lt;li>실시간 서버는 수신자 클라이언트가 새 이메일을 실시간으로 받을 수 있도록 하는 웹소켓 서버&lt;/li>
&lt;li>오프라인 상태 사용자의 이메일은 저장소 계층에 보관
&lt;ul>
&lt;li>온라인 상태가 되면 클라이언트가 웹 서버에 RESTful API를 통해 열결됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>새로운 이메일을 저장소 계층에서 가져와 클라이언트에 반환&lt;/li>
&lt;/ol>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;p>몇 가지 핵심 요소에 대해 더 자세히 알아보고 규모 확장 방안을 점검한다.&lt;/p>
&lt;h3 id="메타데이터-데이터베이스">메타데이터 데이터베이스&lt;/h3>
&lt;p>이메일 메타데이터의 특성을 알아보고 올바른 데이터베이스와 데이터 모델을 고르는 문제, 이메일 스레드 지원 방안에 대해 알아본다.&lt;/p>
&lt;h4 id="이메일-메타데이터의-특성">이메일 메타데이터의 특성&lt;/h4>
&lt;ul>
&lt;li>이메일의 헤더는 일반적으로 작고, 빈번하게 이용&lt;/li>
&lt;li>이메일 본문의 크기는 다양하지만 사용 빈도는 낮음
&lt;ul>
&lt;li>일반적으로 한 번만 읽음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일 가져오기, 읽은 메일로 표시, 검색 등의 이메일 관련 작업은 사용자 별로 격리 수행되어야함
&lt;ul>
&lt;li>어떤 사용자의 이메일은 해당 사용자만 읽을 수 있어야함&lt;/li>
&lt;li>이메일에 대한 작업도 그 사용자만이 수행할 수 있어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 신선도는 데이터 사용 패턴에 영향을 미침
&lt;ul>
&lt;li>사용자는 보통 최근 메일만 읽음&lt;/li>
&lt;li>만들어진 지 16일 이하에 발생하는 읽기 질의 비율은 전체 질의의 82%에 달함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터의 높은 안정성이 보장되어야 함
&lt;ul>
&lt;li>&lt;strong>데이터 손실은 용납되지 않음&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="올바른-데이터베이스의-선정">올바른 데이터베이스의 선정&lt;/h4>
&lt;p>지메일이나 아웃룩 정도의 규모가 되면 시스템의 부하로 인해, 초당 입/출력 연산 빈도(Input/Output Operations Per Second, IOPS)를 낮추기 위한 맞춤 제장 데이터베이스를 사용한다.&lt;/p>
&lt;p>올바른 데이터베이스 선택은 쉽지 않은데, 가능한 모든 선택지를 미리 살펴보면 도움이 된다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>관계형 데이터베이스&lt;/strong>&lt;/p>
&lt;p>관계형 데이터베이스를 고르는 주된 동기는 이메일을 효율적으로 검색할 수 있다는 장점 때문이다.&lt;/p>
&lt;ul>
&lt;li>이메일 헤더와 본문에 대한 인덱스를 만들면 효율적으로 검색할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>하지만 관계형 데이터베이스는 데이터 크기가 작을 때 적합하다.&lt;/p>
&lt;ul>
&lt;li>이메일은 수 KB보다 크고 HTML이 포함되면 쉽게 100KB를 넘어간다.&lt;/li>
&lt;li>BLOB 자료형을 쓰면 큰 이메일도 처리할 수 있으나, 비정형 BLOB에 대한 검색 질의 성능은 좋지 않다.
&lt;ul>
&lt;li>BLOB이 고정된 크기 페이지를 연결하여 큰 데이터를 저장하도록 하고 있어 해당 컬럼의 데이터를 접근할 때마다 많은 디스크 I/O가 발생한다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>따라서 관계형 데이터베이스는 바람직하지 않다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>분산 객체 저장소&lt;/strong>&lt;/p>
&lt;p>이메일의 원시 데이터를 그대로 아마존 S3 같은 객체 저장소에 보관하는 방법도 고려할 수 있다.&lt;/p>
&lt;p>하지만 객체 저장소는 백업 데이터를 보관하기에는 좋지만 이메일의 읽음 표시, 키워드 검색, 이메일 스레드 드의 기능을 구현하기에 그다지 좋지 않다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>NoSQL 데이터베이스&lt;/strong>&lt;/p>
&lt;p>지메일은 구글 빅테이블을 저장소로 사용하는데 충분히 실현 가능한 방안이다.&lt;/p>
&lt;p>하지만 빅테이블은 오픈소스로 공개되어 있지 않고 이메일 검색을 빅테이블 위에서 어떻게 구현했는지는 공개되어있지않다.&lt;/p>
&lt;p>카산드라가 좋은 대안이 될 수도 있지만 대형 이메일 서비스 제공 업체 가운데 카산드라를 사용하는 곳은 아직 확인된 바가 없다.&lt;/p>
&lt;hr>
&lt;p>위 후보들을 봤을 때 본 설계안이 필요로 하는 기능을 완벽히 지원하는 데이터베이스는 없다고 봐도 좋을 것 같다.&lt;/p>
&lt;p>이러한 이유로 대형 이메일 서버스 업체는 대체로 독자적인 데이터베이스 시스템을 만들어 사용한다.&lt;/p>
&lt;p>이러한 데이터베이스를 설계하기엔 시간이 부족하므로, 해당 데이터베이스가 아래와 같은 조건을 충족해야 한다는 점을 설명할 수 있어야한다.&lt;/p>
&lt;ul>
&lt;li>어떤 단일 컬럼의 크기는 한 자리수의 MB 정도일 수 있다.&lt;/li>
&lt;li>강력한 데이터 일관성이 보장되어야 한다.&lt;/li>
&lt;li>디스크 I/O가 최소화되도록 설계되어야 한다.&lt;/li>
&lt;li>가용성이 아주 높아야 하고 일부 장애를 감내할 수 있어야 한다.&lt;/li>
&lt;li>증분 백업(incremental backup)이 쉬워야 한다.&lt;/li>
&lt;/ul>
&lt;h4 id="데이터-모델">데이터 모델&lt;/h4>
&lt;p>데이터를 저장하는 한 가지 방법은 &lt;code>user_id&lt;/code>를 파티션 키로 사용하여 특정한 사용자의 데이터는 항상 같은 샤드에 보관하는 것이다.&lt;/p>
&lt;ul>
&lt;li>메시지를 여러 사용자와 공유할 수 없지만 요구사항과는 관계 없다.&lt;/li>
&lt;/ul>
&lt;p>기본 키는 파티션 키(partition key)와 클러스터 키(clustering key)의 두 가지 부분으로 구성된다.&lt;/p>
&lt;ul>
&lt;li>파티션 키
&lt;ul>
&lt;li>데이터를 여러 노드에 분산하는 기준&lt;/li>
&lt;li>데이터가 모든 노드에 균등하게 분산되도록 하는 파티션 키를 골라야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클러스터 키
&lt;ul>
&lt;li>파티션에 속한 데이터를 정렬하는 기준&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>개략적으로 이메일 서비스의 데이터 계층은 다음과 같은 질의를 지원해야 한다.&lt;/p>
&lt;ul>
&lt;li>주어진 사용자의 모든 폴더를 구한다.&lt;/li>
&lt;li>특정 폴더 내의 모든 이메일을 표시한다.&lt;/li>
&lt;li>메일을 생성, 삭제, 조회한다.&lt;/li>
&lt;li>읽은 메일 전부, 또는 읽지 않은 메일 전부를 가져온다.&lt;/li>
&lt;li>이메일 스레드를 전부 가져온다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_6.png"
width="856"
height="518"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_6_hu00ad76f03bcbd533c2a84dbc6e348eb4_89085_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_6_hu00ad76f03bcbd533c2a84dbc6e348eb4_89085_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="키 구성"
class="gallery-image"
data-flex-grow="165"
data-flex-basis="396px"
>&lt;/p>
&lt;p>&lt;strong>질의 1: 특정 사용자의 모든 폴더 질의&lt;/strong>&lt;/p>
&lt;p>파티션 키는 &lt;code>user_id&lt;/code>다. 따라서 어떤 사용자의 모든 폴더는 같은 파티션 안에 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_7.png"
width="872"
height="544"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_7_hu156bc7a2fc679faefe0f0978519d3cb5_79626_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_7_hu156bc7a2fc679faefe0f0978519d3cb5_79626_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="사용자 별 폴더 목록"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="384px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>질의 2: 특정 폴더에 속한 모든 이메일 표시&lt;/strong>&lt;/p>
&lt;p>사용자가 자기 메일 폴더를 열면 이메일은 가장 최근 이메일부터 오래된 것 순으로 정렬되어 표시된다.&lt;/p>
&lt;p>같은 폴더에 속한 모든 이메일이 같은 파티션에 속하도록 하려면 &lt;code>&amp;lt;user_id, foler_id&amp;gt;&lt;/code> 형태의 복합 파티션 키를 사용해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_9.png"
width="876"
height="982"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_9_hu41305bc042d3fec07ebe69ff8294aa6a_136085_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_9_hu41305bc042d3fec07ebe69ff8294aa6a_136085_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="폴더별 이메일"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="214px"
>&lt;/p>
&lt;p>&lt;code>email_id&lt;/code>의 자료형은 &lt;code>TIMEUUID&lt;/code>로 이메일을 시간순으로 정렬하는 데 사용되는 클러스터 키다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>질의 3: 이메일 생성/삭제/수신&lt;/strong>&lt;/p>
&lt;p>이메일 상세 정로를 가져오는 방법을 살펴본다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">emails_by_user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">email_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">123&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이 질의를 지원하기 위해 두 테이블이 필요하다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_10.png"
width="1328"
height="642"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_10_hucad2710252b37d32d309b4b9de9854c5_132150_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_10_hucad2710252b37d32d309b4b9de9854c5_132150_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="사용자별 이메일"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="496px"
>&lt;/p>
&lt;p>한 이메일에는 여러 첨부 파일이 있을 수 있으므로, &lt;code>email_id&lt;/code>, &lt;code>filename&lt;/code> 필드를 같이 사용하면 모든 첨부 파일을 질의할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>질의 4: 읽은, 또는 읽지 않은 모든 메일&lt;/strong>&lt;/p>
&lt;p>관계형 데이터베이스로 도메인 모델을 구현하는 경우, 읽은 메일 전부는 다음과 같이 질의할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">emails_by_folder&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">is_read&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">email_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>본 설계안의 데이터모델은 NoSQL로 보통 파티션 키와 클러스터 키에 대한 질의만 허용하므로 &lt;code>emails_by_folder&lt;/code> 테이블의 &lt;code>is_read&lt;/code> 필드는 이에 해당하지 않기 때문에 대부분의 NoSQL 데이터베이스에서는 위 쿼리를 실행할 수 없다.&lt;/p>
&lt;p>이 문제를 해결하기 위한 방법으로 &lt;strong>주어진 폴더에 속한 모든 메시지를 가져온 다음 애플리케이션 단에서 필터링&lt;/strong> 해줄 수 있다.&lt;/p>
&lt;ul>
&lt;li>대규모 서비스에는 적합하지 않다.&lt;/li>
&lt;/ul>
&lt;p>따라서 이런 문데는 NoSQL 데이터베이스 테이블을 비정규화(denormalization)하여 해결하는 것이 보통이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>emails_by_folder&lt;/code> 테이블을 두 테이블로 분할한다.&lt;/li>
&lt;li>&lt;code>read_emails&lt;/code>: 읽은 상태의 모든 이메일을 보관&lt;/li>
&lt;li>&lt;code>unread_eamils&lt;/code>: 읽지 않은 모든 이메일을 보관&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_11.png"
width="1288"
height="568"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_11_hueb1288bc525b10d750ab98ffc79e7b70_139881_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_11_hueb1288bc525b10d750ab98ffc79e7b70_139881_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비정규화"
class="gallery-image"
data-flex-grow="226"
data-flex-basis="544px"
>&lt;/p>
&lt;p>특정 폴더 안의 읽지 않은 모든 메일을 가져오는 질의는 다음과 같이 표현될 수 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">unread_mails&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;%&lt;/span>&lt;span class="n">folder_id&lt;/span>&lt;span class="o">%&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">email_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이러한 비정규화는 흔한 관행으로, 애플리케이션 코드가 좀 더 복잡해지고 관리하기 까다로워지지만, 질의 성능은 대규모 서비스에 어울리는 수준으로 개선한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>보너스: 이메일 스레드 가져오기&lt;/strong>&lt;/p>
&lt;p>이메일 스레드는 많은 이메일 클라이언트가 지원하는 기능으로 모든 답장을 최초 메시지에 스레드로 엮어 보여주는 기능이다.&lt;/p>
&lt;p>사용자가 특정한 대화에 관련된 모든 메일을 한 번에 확인할 수 있게된다.&lt;/p>
&lt;ul>
&lt;li>전통적으로 &lt;strong>JWZ&lt;/strong> 같은 알고리즘을 통해 구현한다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;headers&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;Message-Id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;7BA04B2A-430C-4D12-8B57-862103C34501@gmail.com&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;In-Reply-To&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;CAEWTXuPfN=LzECjDJtgY9Vu03kgFvJnJUSHTt6TW@gmail.com&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;References&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;lt;7BA04B2A-430C-4D12-8B57-862103C34501@gmail.com&amp;gt;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>Message-Id&lt;/strong>
&lt;ul>
&lt;li>메시지 식별자&lt;/li>
&lt;li>메시지를 보내는 클라이언트가 생성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>In-Reply-To&lt;/strong>
&lt;ul>
&lt;li>어떤 메시지가 어떤 메시지에 대한 답신인지 나타내는 식별자&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>References&lt;/strong>
&lt;ul>
&lt;li>스레드에 관계된 메시지 식별자 목록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이 필드들로 이메일 클라이언트는 타래 내의 모든 메시지가 사전에 메모리에 로드되어 있는 경우 전체 대화 스레드를 재구성해 낼 수 있게된다.&lt;/p>
&lt;h4 id="일관성-문제">일관성 문제&lt;/h4>
&lt;p>높은 가용성을 달성하기 위해 다중화에 의존하는 분산 데이터베이스는 데이터 일관성과 가용성 사이에서 타협적인 결정을 내릴 수 밖에 없다.&lt;/p>
&lt;p>이메일 시스템의 경우 &lt;strong>데이터의 정확성이 아주 중요&lt;/strong>하므로, 모든 메일함은 반드시 하나의ㅏ 주 사본을 통해 서비스된다고 가정해야한다.&lt;/p>
&lt;p>따라서 장애가 발생하면 클라이언트는 다른 사본을 통해 주 사본이 복원될 때까지 동기화/갱신 작업을 완료할 수 없다.&lt;/p>
&lt;ul>
&lt;li>일관성을 위해 가용성을 희생한다.&lt;/li>
&lt;/ul>
&lt;h3 id="이메일-전송-가능성">이메일 전송 가능성&lt;/h3>
&lt;p>메일 서버를 구성하고 이메일을 보내는 것은 쉽지만 특정 사용자의 메일함에 실제로 메일이 전달되도록 하는 것은 어려운 문제이다.&lt;/p>
&lt;p>이메일이 &lt;strong>스팸 폴더&lt;/strong>에 들어가 버리면 수신자가 메일을 읽을 가능성은 아주 낮아진다.&lt;/p>
&lt;ul>
&lt;li>연구에 따르면 메일 가운데 50%가 그팸으로 분류된다.&lt;/li>
&lt;/ul>
&lt;p>새로 구성한 메일 서버는 인터넷에서 좋은 평판을 쌓을 기회가 전혀 없었기 때문에 보내는 메일이 대부분 스팸 폴더로 떨어진다.&lt;/p>
&lt;p>따라서 이메일의 전송 가능성을 높이기 이ㅜ해서 다음과 같은 요소들을 고려한다.&lt;/p>
&lt;ul>
&lt;li>전용 IP
&lt;ul>
&lt;li>전용 IP 주소를 사용하라&lt;/li>
&lt;li>대부분의 이메일 서비스 사업자는 아무 이력이 없는 IP 새로운 IP 주소에서 온 메일을 무시한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>범주화
&lt;ul>
&lt;li>범주가 다른 이메일은 다른 IP 주소를 통해 보내라&lt;/li>
&lt;li>마케팅 목적의 메일을 중요한 이메일과 같은 서버에서 발송하면 ISP가 모든 이메일을 판촉 메일로 분류할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>발신인 평판
&lt;ul>
&lt;li>새로운 이메일 서버의 IP 주소는 사용 빈도를 서서히 올리는 것이 좋다.&lt;/li>
&lt;li>그래야 좋은 평판이 쌓여 해당 IP 주소에서 발송되는 메일을 스팸으로 분류할 가능성이 낮아진다.&lt;/li>
&lt;li>아마존 SES에 따르면 새로운 IP 주소를 메일 발송해 아무 문제 없이 쓸 수 있게 되는 데는 대략 2 ~ 6주가 소요된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>스팸 발송자의 신속한 차단
&lt;ul>
&lt;li>스팸을 뿌리는 사용자는 서버 평판을 심각하게 훼손하기 전에 시스템에서 신속히 차단한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>피드백 처리
&lt;ul>
&lt;li>불만 신고가 접수되는 비율을 낮추고 스팸 계정을 신속히 차단하기위해서는 ISP 측에서의 피드백을 쉽게 받아 처리할 수 있는 경로를 만드는 것이 중요하다.&lt;/li>
&lt;li>이메일이 전달되지 못하거나 사용자로부터 불만 신고가 접수된 경우 다음과 같은 일들이 벌어질 수 있다.
&lt;ul>
&lt;li>경성 반송(hard bounce)
&lt;ul>
&lt;li>수신인의 이메일 주소가 올바르지 않아 ISP가 전달을 거부한 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>연성 반송(soft bounce)
&lt;ul>
&lt;li>ISP 측의 이메일 처리 자원 부족 등의 이유로 일시적으로 이메일을 전달할 수 없었던 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>불만 신고(complaint)
&lt;ul>
&lt;li>수신인이 스팸으로 신고 버튼을 누르는 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이메일 인증
&lt;ul>
&lt;li>2018년도 데이터 유출 조사 보고서에 따르면 ㅍ피싱이나 프리텍스팅이 전체 유철 사고에서 차지하는 비중은 93%에 달한다.&lt;/li>
&lt;li>보편적으로 SPF(Sender Policy Framework), DKIM(DomainKeys Identified Mail), DMARC(Domain-based Message Authentication, Reporting and Conformance) 등으로 피싱에 대응한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>명심해야할 점은 이메일이 목적지에 성공적으로 도착하도록 하기 어렵다는 사실이다. 도메인 지식은 물론 ISP와 좋은 관계를 유지할 필요도 있다.&lt;/p>
&lt;h3 id="검색">검색&lt;/h3>
&lt;p>기본적인 이메일 검색은 보통 이메일 제목이나 본문에 특정 키워드가 포함되었는지 찾는 것을 뜻하며, 고급 기능에는 발신인, 제목, 읽지 않음 같이 메일 속성에 따른 필터링 기능이 포함된다.&lt;/p>
&lt;p>검색 기능을 제공하려면 이메일이 전송, 수신, 삭제 될 때마다 색인(indexing) 작업을 수행해야 한다.&lt;/p>
&lt;p>그에 반해 검색은 사용자가 검색 버튼을 누를 때만 실행되므로, 이메일 시스템의 검색 기능에서는 쓰기 연산이 읽기 연산보다 훨씬 많이 발생한다.&lt;/p>
&lt;p>검색 기능을 지원하기 위해 일래스틱서치(ElasticSearch)를 이용하는 방안과 데이터 저장소에 내장된 기본 검색 기능을 활용하는 방안의 두 가지 선택지를 비교해본다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>방안 1: 일래스틱서치&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_12.png"
width="1210"
height="1224"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_12_hu3000d4f01569124c541bea50802fb702_56268_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_12_hu3000d4f01569124c541bea50802fb702_56268_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="일래스틱 서치"
class="gallery-image"
data-flex-grow="98"
data-flex-basis="237px"
>&lt;/p>
&lt;p>질의가 대부분 사용자의 이메일 서버에서 실행되므로 &lt;code>user_id&lt;/code>를 파티션 키로 사용하여 같은 사용자의 이메일은 같은 노드에 묶어 놓는다.&lt;/p>
&lt;ul>
&lt;li>사용자가 검색 버튼을 누른 다음 결과가 수신될 때 까지 기다리므로, 검색 요청은 동기 방식으로 처리되어야 한다.&lt;/li>
&lt;li>이메일 전송, 이메일 수신, 이메일 삭제 같은 이벤트는 처리 결과를 클라이언트로 전달할 필요는 없으며, 추가로 색인 작업이 필요하다.&lt;/li>
&lt;/ul>
&lt;p>본 설계안은 카프카를 활용하여 색인 작업을 시작하는 서비스와 실제로 색인을 수행할 서비스 사이의 결합도를 낮추는 방안을 채택한다.&lt;/p>
&lt;ul>
&lt;li>일래스틱서치는 2021년 6월 기준으로 가장 널리 사용되고 있는 검색 엔진 데이터베이스이며 이메일 검색에 필요한 텍스트 기반 검색을 잘 지원한다.&lt;/li>
&lt;/ul>
&lt;p>일래스틱서치를 사용할 경우 주 이메일 저장소와 동기화를 맞추는 부분이 까다롭다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>방안 2: 맞춤형 검색 솔루션&lt;/strong>&lt;/p>
&lt;p>대규모 이메일 서비스 사업자는 보통 자기 제품에 고유한 요구사항을 만족시키기 위해 검색 엔진을 자체적으로 개발해 사용한다.&lt;/p>
&lt;p>매우 어렵고 범위를 넘어서기 때문에 자체적으로 검색 솔루션을 구현하는 경우 마주하게 될 주요 과제인 디스크 I/O 병목 문제를 살펴본다.&lt;/p>
&lt;p>개략적 규모 추정 결과 메타 데이터와 첨부 파일은 매일 페타바이트 수준으로 저장소에 추가되며, 하나의 이메일 계정에 몇십 만개 넘는 이메일이 저장되는 것도 흔하다.&lt;/p>
&lt;ul>
&lt;li>따라서 메일 색인 서버의 주된 병복은 보통 디스크 I/O다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_13.png"
width="1926"
height="1002"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_13_hu495b352c0880296eb3398fcf25077ab9_380701_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_13_hu495b352c0880296eb3398fcf25077ab9_380701_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="LSM 트리"
class="gallery-image"
data-flex-grow="192"
data-flex-basis="461px"
>&lt;/p>
&lt;p>색인을 구축하는 프로세스는 다량의 쓰기 연산을 발생시킬 수 밖에 없으므로 LSM(Log-Structured Merge)트리를 사용하여 &lt;strong>디스크에 저장되는 색인을 구조화하는 것이 바람직한 전략&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>쓰기 경로는 순차적 쓰기 연산(sequential write)만 수행하도록 최적화 되어있다.&lt;/li>
&lt;li>빅테이블이나 카산드라, RocksDB 같은 데이터베이스의 핵심 자료 구조다.&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>새로운 이메일이 도착하면 우선 메모리 캐시로 구현되는 0번 계층에 저장된다.&lt;/li>
&lt;li>메모리에 보관된 데이터의 양이 사전에 정의된 임계치를 넘으면 데이터는 다음 계층에 병합된다.&lt;/li>
&lt;/ol>
&lt;p>자주 바뀌는 데이터를 그렇지 않은 데이터와 분리하는 효과도 얻을 수 있다.&lt;/p>
&lt;ul>
&lt;li>이메일 데이터는 보통 바뀌지 않지만 메일 폴더의 정보는 상이한 필터링 규칙들 때문에 자주 바뀌는 경향이 있다.&lt;/li>
&lt;li>데이터를 두 개 파트로 나누거 어떤 요청이 폴더 변경에 관한 것 이면 폴더 정보만 바꾸고 이메일 데이터는 내벼려둔다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>소규모의 이메일 시스템을 구축하는 경우 통합하기 쉽고 엔지니어링에 많은 노력이 필요하지 않은 일래스틱서치가 좋은 선택지이다.&lt;/p>
&lt;p>대규모 시스템을 구축하는 경에도 일래스틱서치를 사용할 수 있겠지만 이메일 검색 인프라를 개발하고 관리하는 전담 팀이 필요할 수 있다.&lt;/p>
&lt;p>지메일이나 아웃룩 규모의 이메일 시스템을 지원하려면 독립적인 검색 전용 시스템을 두기보다는 데이터베이스에 내장된 전용 검색 솔루션을 사용하는 것이 바람직할 수도 있다.&lt;/p>
&lt;h3 id="규모-확장성-및-가용성">규모 확장성 및 가용성&lt;/h3>
&lt;p>각 사용자의 데이터 접근 패턴은 다른 사용자와 무고나하므로, 시스템의 대부분 컴포넌트는 수평적으로 규모 확장이 가능할 것으로 기대할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/8/img_14.png"
width="1362"
height="1260"
srcset="https://codemario318.github.io/post/system-design-interview-2/8/img_14_hu7aa95457bd45ad9d0fc44f5368731ee7_86292_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/8/img_14_hu7aa95457bd45ad9d0fc44f5368731ee7_86292_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="시스템 다중화"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="259px"
>&lt;/p>
&lt;p>가용성을 향상시키기 위해서는 데이터를 여러 데이터센터에 다중화하는 것이 필요하다.&lt;/p>
&lt;ul>
&lt;li>자신과 물리적으로 가까운 메일 서버와 통신한다.&lt;/li>
&lt;li>네트워크 파티션 발생시 다른 데이터센터에 보관된 메시지를 이용한다.&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>면접장에서 시간이 남는다면 추가로 논의해 볼 만한 주제로는 다음과 같은 것들이 있다.&lt;/p>
&lt;ul>
&lt;li>결함 내성
&lt;ul>
&lt;li>노드 장애, 네트워크 문제, 이벤트 전달 지연 등의 문제에 어떻게 대처할지 살펴보면 좋을 것이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규정 준수
&lt;ul>
&lt;li>전 세계 다양한 시스템과 연동해야 하고 각 나라에는 준수해야할 법규가 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>보안
&lt;ul>
&lt;li>민감한 정보가 포함되므로 보안이 매우 중요하다.&lt;/li>
&lt;li>피싱 방지, 안전 브라우징, 첨부 파일 사전 경고, 계정 안전, 기밀 모드, 이메일 암호화 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>최적화
&lt;ul>
&lt;li>같은 이메일이 여러 수신자에 전송되는 경우 동일한 첨부 파일이 있는지 확인하는 방식으로 최적화를 진행할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>7. 호텔 예약 시스템</title><link>https://codemario318.github.io/post/system-design-interview-2/7/</link><pubDate>Sat, 12 Oct 2024 14:59:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/7/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/cover.png" alt="Featured image of post 7. 호텔 예약 시스템" />&lt;p>이번 장에서는 호텔 체인의 예약 시스템을 설계한다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;p>호텔 예약 시스템은 복잡하고 그 컴포넌트는 시스템을 사업에 어떻게 이용할지에 따라 달라지므로 범위를 명확히 해야한다.&lt;/p>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>높은 수준의 동시성 지원
&lt;ul>
&lt;li>성수기, 대규모 이벤트 기간에는 일부 인기 호텔의 특정 객실을 예약하려는 고객이 많이 몰릴 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>적절한 지연 시간
&lt;ul>
&lt;li>사용자가 예약을 할 때는 응답 시간이 빠르면 이상적이겠으나 &lt;strong>예약 요청 처리&lt;/strong>에 &lt;strong>몇 초 정도&lt;/strong> 걸리는 것은 괜찮다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;ul>
&lt;li>총 5,000개 호텔, 100만 개의 객실이 있다고 가정&lt;/li>
&lt;li>평균 &lt;strong>객실의 70%가 사용 중&lt;/strong>, 평균 &lt;strong>투숙 기간은 3일&lt;/strong>이라고 가정&lt;/li>
&lt;li>&lt;code>일일 예상 예약 건수 = (1백만 * 0.7) / 3 ~= 240,000&lt;/code>&lt;/li>
&lt;li>&lt;code>초당 예약 건수 = 240,000 / 하루에 10^5초 ~= 3&lt;/code>
&lt;ul>
&lt;li>초당 예약 트랜잭션 수(TPS)는 높지 않다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>시스템 내 모든 페이지의 QPS를 계산해본다.&lt;/p>
&lt;p>호텔 예약 시스템은 일반적으로 고객이 아래와 같은 흐름을 거친다.&lt;/p>
&lt;ol>
&lt;li>호텔/객실 상세 페이지
&lt;ul>
&lt;li>사용자가 호텔/객실 정보를 확인한다.(조회)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예약 상세 정보 페이지
&lt;ul>
&lt;li>날짜, 투숙 인원, 결제 방법 등의 상세 정보를 예약 전에 확인한다.(조회)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객실 예약 페이지
&lt;ul>
&lt;li>사용자가 &amp;lsquo;예약&amp;rsquo; 버튼을 눌러 객실을 예약한다.(트랜잭션 발생)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img.png"
width="1290"
height="630"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_hudca757551e48c8d1d2e333630b9f6cbe_51951_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_hudca757551e48c8d1d2e333630b9f6cbe_51951_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="QPS 분포"
class="gallery-image"
data-flex-grow="204"
data-flex-basis="491px"
>&lt;/p>
&lt;p>대략 10%의 사용자가 간 단계에서 다음 단계를 진행한다고 가정하면 최종 예약 TPS는 3이므로, 예약 페이지의 QPS는 30, 객실 정보 확인 페이지의 QPS는 300이다.&lt;/p>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="api-설계">API 설계&lt;/h3>
&lt;p>호텔 예약 시스템의 가장 중요한 API만 RESTful 관례에 따라 표현하면 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>검색 기능 등의 직관적인 기능도 필요하나, 기술적으로 도전적이지는 않다.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>호텔 관련 API&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/hotels/id&lt;/td>
&lt;td>호텔의 상세 정보 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST /v1/hotels&lt;/td>
&lt;td>신규 호텔 추가(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PUT /v1/hotels/id&lt;/td>
&lt;td>호텔 정보 갱신(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE /v1/hotels/id&lt;/td>
&lt;td>호텔 정보 삭제(관리자)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>객실 관련 API&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/hotels/:id/rooms/id&lt;/td>
&lt;td>객실 상세 정보 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST /v1/hotels/:id/rooms&lt;/td>
&lt;td>신규 객실 추가(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PUT /v1/hotels/:id/rooms/id&lt;/td>
&lt;td>객실 정보 갱신(관리자)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE /v1/hotels/:id/rooms/id&lt;/td>
&lt;td>객실 정보 삭제(관리자)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>예약 관련 API&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/reservations&lt;/td>
&lt;td>로그인 사용자의 예약 이력 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GET /v1/reservations/id&lt;/td>
&lt;td>특정 예약의 상세 정보 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST /v1/reservations&lt;/td>
&lt;td>신규 예약&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE /v1/reservations/id&lt;/td>
&lt;td>예약 취소&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>신규 예약 접수는 아주 중요한 기능으로, 새 예약을 만들 때 전달하는 인자의 형태는 아래와 같은데&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;startDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-28&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;endDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-30&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;hotelID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;245&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;roomID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;U12354673389&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;reservationID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;13422445&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>researvationID&lt;/code>는 &lt;strong>이중 예약을 방지하고 동일한 예약은 단 한 번만 이루어지도록 보증하는 멱등 키(idempotent key)다.&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>멱등성?&lt;/strong>
연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질&lt;/p>
&lt;/blockquote>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>어떤 데이터베이스를 사용할지 결정하기위해 데이터 접근 패턴을 확인해야한다.&lt;/p>
&lt;ol>
&lt;li>호텔 상세 정보 확인&lt;/li>
&lt;li>지정된 날짜 범위에 사용 가능한 객실 유형 확인&lt;/li>
&lt;li>예약 정보 기록&lt;/li>
&lt;li>예약 내역 또는 과거 예약 이력 정보 조회&lt;/li>
&lt;/ol>
&lt;p>시스템 규모가 크지 않지만 대규모 이벤트 등으로 인해 트래픽이 급증할 수도 있으니 대비가 필요하다.&lt;/p>
&lt;p>이런 요구사항을 종합적으로 고려하였을 때 &lt;strong>관계형 데이터베이스&lt;/strong>가 적절해보인다.&lt;/p>
&lt;ul>
&lt;li>읽기 빈도가 쓰기 연산에 비해 높은 작업 흐름을 잘 지원한다.
&lt;ul>
&lt;li>읽기 반도가 압도적인 작업 흐름은 충분히 잘 지원한다.&lt;/li>
&lt;li>NoSQL 데이터베이스는 대체로 쓰기 연산에 최적화되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ACID 속성(원자성, 일관성, 격리성, 영속성)을 보장한다.
&lt;ul>
&lt;li>예약이라는 도메인 특성으로 인해 ACID 속성은 매우 중요하다.&lt;/li>
&lt;li>ACID를 보장하지 않으면 잔액 마이너스 문제, 이중 청구 문제, 이중 예약 문제 등을 방지하기 어렵다.&lt;/li>
&lt;li>ACID 속성이 충족되는 데이터베이스를 사용하면 코드는 단순해지고 이해하기 쉬워진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터를 쉽게 모델링 할 수 있다.
&lt;ul>
&lt;li>비즈니스 데이터의 구조를 명확하게 표현할 수 있을 뿐 아니라 엔티티 간의 간계를 안정적으로 지원할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_1.png"
width="1622"
height="1138"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_1_hude4e50a98d4fd9adb0d8d3f89cda06c5_259967_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_1_hude4e50a98d4fd9adb0d8d3f89cda06c5_259967_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터베이스 스키마"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="342px"
>&lt;/p>
&lt;p>&lt;code>reservation&lt;/code> 테이블의 &lt;code>status&lt;/code> 필드는 &lt;code>Pending&lt;/code>, &lt;code>Paid&lt;/code>, &lt;code>Refunded&lt;/code>, &lt;code>Canceled&lt;/code>, &lt;code>Rejected&lt;/code> 다섯 상태 가운데 하나를 값으로 가질 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_2.png"
width="1320"
height="630"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_2_hu654fdd7d1e7937dbeca03f4655f81aa1_21966_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_2_hu654fdd7d1e7937dbeca03f4655f81aa1_21966_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="예약 상태"
class="gallery-image"
data-flex-grow="209"
data-flex-basis="502px"
>&lt;/p>
&lt;p>이 스키마에서 &lt;code>room_id&lt;/code>는 에어비엔비 같은 회사에는 적합하나, 특정 호텔의 특정 객실 유형을 예약하는 호텔에는 적절하지 않을 수 있다.&lt;/p>
&lt;ul>
&lt;li>객실 번호는 예약할 때가 아닌, 투숙객이 체크인 하는 시점에 부여된다.&lt;/li>
&lt;/ul>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>이번 호텔 예약 시스템에는 마이크로서비스 아키텍처를 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_3.png"
width="1946"
height="1100"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_3_hu282c3b24ada39ab6809ed01eac989c4e_87808_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_3_hu282c3b24ada39ab6809ed01eac989c4e_87808_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="176"
data-flex-basis="424px"
>&lt;/p>
&lt;p>마이크로 서비스 간 상호작용을 나타내는 화살표 상당수를 생략하였다.&lt;/p>
&lt;p>실제 상업적으로 이용되는 시스템의 서비스 간 통신에는 gRPC와 같은 고성능 원격 프로세서 호출 프레임워크를 사용하곤 한다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>gRPC?&lt;/strong>&lt;br>
gRPC는 Google에서 개발한 고성능, 오픈 소스 원격 프로시저 호출(Remote Procedure Call, RPC) 프레임워크이다.
클라이언트와 서버 간에 원격 프로시저를 호출할 수 있게 해 주며, 마치 로컬에서 함수를 호출하는 것처럼 네트워크를 통해 다른 시스템의 메서드를 실행할 수 있다.
주로 프로토콜 버퍼(Protocol Buffers, protobuf)라는 직렬화 방식을 사용해 데이터를 효율적으로 전송하며, HTTP/2를 기반으로 동작해 성능과 확장성을 높인다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="개선된-데이터-모델">개선된 데이터 모델&lt;/h3>
&lt;p>호텔 객실을 예약할 때는 특정 객실이 아니라 특정한 객실 유형을 예약하게 된다.&lt;/p>
&lt;p>이러한 특성을 반영하기 위해 예약 API의 경우 호출 인자 가운데 &lt;code>roomID&lt;/code>는 &lt;code>roomTypeID&lt;/code>로 변경한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;startDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-28&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;endDate&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2021-04-30&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;hotelID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;245&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;roomTypeID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;U12354673389&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;reservationID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;13422445&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>스키마는 아래와 같이 변경된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_4.png"
width="1366"
height="1028"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_4_hu481f8e14d20d4e775dd6afb82166b25a_281965_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_4_hu481f8e14d20d4e775dd6afb82166b25a_281965_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="갱신된 스키마"
class="gallery-image"
data-flex-grow="132"
data-flex-basis="318px"
>&lt;/p>
&lt;p>주요 변경 사항은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>room&lt;/code>: 객실에 관계된 정보&lt;/li>
&lt;li>&lt;code>room_type_rate&lt;/code>: 특정 객실 유형의 특정 일자 요금 정보&lt;/li>
&lt;li>&lt;code>reservation&lt;/code>: 투숙객 예약 정보&lt;/li>
&lt;li>&lt;code>room_type_inventory&lt;/code>: 호텔의 모든 객실 유형
&lt;ul>
&lt;li>&lt;code>hotel_id&lt;/code>: 호텔 식별자&lt;/li>
&lt;li>&lt;code>room_type_id&lt;/code>: 객실 유형 식별자&lt;/li>
&lt;li>&lt;code>date&lt;/code>: 일자&lt;/li>
&lt;li>&lt;code>total_inventory&lt;/code>: 총 객실 수에서 일시적으로 제외한 객실 수를 뺀 값
&lt;ul>
&lt;li>유지 보수를 위해 예약 가능 목록에서 제외할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>total_reserved&lt;/code>: 저정된 hotel_id, room_type_id, date에 예약된 모든 객실의 수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>날짜당 하나의 레코드를 사용하면 날짜 범위 내에서 예약을 쉽게 관리하고 질의할 수 있다.&lt;/p>
&lt;p>이 테이블의 기본키는 &lt;code>(hotel_id, room_type_id, date)&lt;/code>의 복합키로, 2년 이내 모든 미래 날짜에 대한 가용 객실 데이터 질의 결과를 토대로 미리 채워 놓고, 시간이 흐름에 따라 새로 추가해야 하는 객실 정보는 매일 한 번씩 일괄 작업을 돌려 반영한다.&lt;/p>
&lt;hr>
&lt;p>5,000개의 호텔이 있고 각 호텔에는 20개의 객실 유형이 있으므로 테이블에 저장해야 하는 레코드의 수는 &lt;code>5,000 * 20 * 2년 * 365일 = 7,300만 개&lt;/code> 정도이다.&lt;/p>
&lt;p>많은 데이터가 아니므로 데이터베이스 하나면 저장하기 충분하지만, 하나만 둔다면 SPOF 문제를 피할 수 없게된다.&lt;/p>
&lt;p>고가용성을 달성하려면 여러 지역, 또는 가용성 구역에 데이터베이스를 복제해 두어야 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;code>room_type_inventory&lt;/code> 테이블은 고객이 특정 유형의 객실을 예약할 수 있는지 여부를 확인할 때 사용한다.&lt;/p>
&lt;ul>
&lt;li>입력
&lt;ul>
&lt;li>&lt;code>startDate&lt;/code>&lt;/li>
&lt;li>&lt;code>endDate&lt;/code>&lt;/li>
&lt;li>&lt;code>roomTypeId&lt;/code>&lt;/li>
&lt;li>&lt;code>hotelId&lt;/code>&lt;/li>
&lt;li>&lt;code>numberOfRoomsToReserve&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>출력
&lt;ul>
&lt;li>해당 유형의 객실에 여유가 있고 예약 가능한 상태라면 &lt;code>True&lt;/code>, 아니면 &lt;code>False&lt;/code>를 반환한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>SQL 관점에서 두 절차를 거친다.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>주어진 기간에 해당하는 레코드를 구한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">date&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_inventory&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_reserved&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">room_type_inventory&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">room_type_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">roomTypeId&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">hotel_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">hotelId&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BETWEEN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">startDate&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">${&lt;/span>&lt;span class="n">endDate&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>반환한 각 레코드마다 다음 조건을 확인한다.&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">if ((total_reserved + ${numberOfRoomsToReserve}) &amp;lt;= total_inventory)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>레코드의 모든 행을 검사한 결과 &lt;code>True&lt;/code>가 반환되면 주어진 기간 내 모든 날짜에 충분한 객실이 있다는 뜻 이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>예약 데이터가 단을 데이터베이스에 담기에 너무 크다면 다음과 같은 방안을 생각해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>현재 및 향후 예약 데이터만 저장한다.
&lt;ul>
&lt;li>예약 이력은 자주 접근하지 않으므로 아카이빙 하거나 냉동 저장소로 옮길 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터베이스를 샤딩한다.
&lt;ul>
&lt;li>자주 사용되는 질의는 &lt;strong>예약&lt;/strong> 및 &lt;strong>예약 확인&lt;/strong>이므로, 두 질의에서 모두 먼저 알아야하는 &lt;code>hotel_id&lt;/code>를 샤딩키로 사용한다.&lt;/li>
&lt;li>데이터는 &lt;code>hash(hotel_id) % number_of_service&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="동시성-문제">동시성 문제&lt;/h3>
&lt;p>또 하나의 중요한 문제는 &lt;strong>이중 예약 방지&lt;/strong>이며, 이를 위해 두가지 문제를 해결해야한다.&lt;/p>
&lt;ul>
&lt;li>같은 사용자가 예약 요청을 여러번 시도할 수 있다.&lt;/li>
&lt;li>여러 사용자가 같은 객실을 동시에 예약하려 할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="같은-사용자가-같은-예약-요청을-시도하는-경우">&lt;strong>같은 사용자가 같은 예약 요청을 시도하는 경우&lt;/strong>&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_5.png"
width="1508"
height="986"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_5_hueb9926d5bdf21d1ae178c13f6ba855ec_83059_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_5_hueb9926d5bdf21d1ae178c13f6ba855ec_83059_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="같은 고객의 이중 예약"
class="gallery-image"
data-flex-grow="152"
data-flex-basis="367px"
>&lt;/p>
&lt;p>이 문제를 푸는 일반적인 접근법으로는 다음 두가지가 있다.&lt;/p>
&lt;ul>
&lt;li>클라이언트 측 구현
&lt;ul>
&lt;li>요청 전송 후 예약 버튼을 비활성화 한다.
&lt;ul>
&lt;li>클라이언트에서 우회 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>멱등 API
&lt;ul>
&lt;li>예약 API 요청에 멱등 키를 추가하는 방안&lt;/li>
&lt;li>&lt;code>reservation_id&lt;/code>를 멱등 키로 사용하여 이중 예약 문제를 해결하는 방안이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_6.png"
width="1130"
height="1066"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_6_hu48c6b4b2100602be71a6178ae06987e2_69862_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_6_hu48c6b4b2100602be71a6178ae06987e2_69862_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="유일성 조건"
class="gallery-image"
data-flex-grow="106"
data-flex-basis="254px"
>&lt;/p>
&lt;ol>
&lt;li>예약 주문서를 만든다.&lt;/li>
&lt;li>고객이 검토할 수 있도록 예약 주문서를 반환한다.&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>반환 결과에 &lt;code>reservation_id&lt;/code>를 넣는다.(전역적 유일성을 보증하는 ID, 예제에서는의 예약 테이블의 기본키)&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>검토가 끝난 예약을 전송한다.
&lt;ul>
&lt;li>요청에 &lt;code>reservation_id&lt;/code>를 포함한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예약 완료 버튼을 한 번 더 눌러 보내도 &lt;code>reservation_id&lt;/code>가 예약 테이블의 기본 키 이므로 유일성 조건에 위반되어 처리되지 않는다.&lt;/li>
&lt;/ol>
&lt;h4 id="여러-사용자가-하나뿐인-객실을-동시에-예약하는-경우">&lt;strong>여러 사용자가 하나뿐인 객실을 동시에 예약하는 경우&lt;/strong>&lt;/h4>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_7.png"
width="1438"
height="1262"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_7_hu8a18da16175039b3cfa48b49d042fdf5_80735_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_7_hu8a18da16175039b3cfa48b49d042fdf5_80735_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="경쟁 조건"
class="gallery-image"
data-flex-grow="113"
data-flex-basis="273px"
>&lt;/p>
&lt;p>이 문제를 해결하려면 어떤 형태로든 락을 활용해야 한다.&lt;/p>
&lt;p>&lt;strong>비관적 락&lt;/strong>&lt;/p>
&lt;p>비관적 락은 비관적 동시성 제어 방안이라고도 불리며, 사용자가 &lt;strong>레코드를 갱신하려고 하는 순간 즉시 락을 걸어 동시 업데이트를 방지하는 기술&lt;/strong>이다.&lt;/p>
&lt;p>따라서 해당 레코드를 갱신하려는 다른 사용자는 락 해제를 기다려야 한다.&lt;/p>
&lt;ul>
&lt;li>MySQL 같은 경우는 &lt;code>SELECT ... FOR UPDATE&lt;/code> 문을 실행하면 &lt;code>SELECT&lt;/code>가 반환한 레코드에 락이 걸린다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_8.png"
width="1994"
height="1320"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_8_hu40fa4d62dd848fb68c0b889e46e94f87_126013_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_8_hu40fa4d62dd848fb68c0b889e46e94f87_126013_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="비관적 락"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="362px"
>&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>변경 중이거나 변경이 끝난 데이터를 갱신하는 일을 막을 수 있다.&lt;/li>
&lt;li>구현이 쉽고 모든 갱신 연산을 직렬화하여 충돌을 막는다.&lt;/li>
&lt;li>데이터에 대한 경합이 심할 때 유용하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>여러 레코드에 락을 걸면 교착 상태가 발생할 수 있다.
&lt;ul>
&lt;li>교착 상태가 발생하지 않는 코드 작성은 어렵다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장성이 낮다.&lt;/li>
&lt;li>트랜잭션이 너무 오랫동안 락을 해제하지 않고 있으면 다른 트랜잭션은 락이 걸린 자원에 접근할 수 없어 트랜잭션 수명이 길거나 많은 엔티티에 관련된 경우 성능에 심각한 영향을 끼친다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 이유로 비관적 락 메커니즘은 군장하지 않는다.&lt;/p>
&lt;p>&lt;strong>낙관적 락&lt;/strong>&lt;/p>
&lt;p>낙관적 락은 &lt;strong>낙관적 동시성 제어&lt;/strong>라고도 불리는 방안으로 &lt;strong>여러 사용자가 동시에 같은 자원을 갱신하려 시도하는 것을 허용&lt;/strong>한다.&lt;/p>
&lt;p>일반적으로 버전 번호(version_number)와 타임스탬프(timestamp) 두 가지 방법으로 구현한다.&lt;/p>
&lt;ul>
&lt;li>서버 시계는 시간이 지남에 따라 부정확해질 수 있으므로 일반적으로는 버전 번호를 더 나은 선택지로 본다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_9.png"
width="1938"
height="1142"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_9_hu9411dd474af31fd86c2a43d5119b3270_97882_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_9_hu9411dd474af31fd86c2a43d5119b3270_97882_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="낙관적 락"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="407px"
>&lt;/p>
&lt;p>낙관적 락은 데이터베이스에 직접 락을 걸지 않으므로 일반적으로 비관적 락 보다 빠르지만 동시성 수준이 아주 높으면 성능이 급격히 나빠진다.&lt;/p>
&lt;p>예를 들어 설명하면 잔여 객실 수를 읽을 수 있는 클라이언트 수에는 제한이 없으므로, 모든 클라이언트는 같은 잔여 객실 수와 같은 버전 정보를 취득하게 될 수 있기 때문에 모든 클라이언트는 같은 잔여 객실 수와 같은 버전 번호 정보를 취득한다.&lt;/p>
&lt;p>하지만 실제로 버전 번호 갱신에 성공하는 클라이언트는 하나이므로, 다른 모든 클라이언트는 버전 번호 검사에 실패하게된다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>애플리케이션이 유효하지 않은 데이터를 편집하는 일을 막는다.&lt;/li>
&lt;li>데이터베이스 자원에 락을 걸 필요가 없다.(데이터베이스 관점에서 락은 없다.) 책임은 애플리케이션에 있다.&lt;/li>
&lt;li>데이터에 대한 경쟁이 치열하지 않은 상황에 적합하다.
&lt;ul>
&lt;li>락을 관리하는 비용 없이 트랜잭션을 실행할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>데이터에 대한 경쟁이 치열한 상황에서는 성능이 좋지 못하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>낙관적 락은 예약 QPS가 일반적으로 높지 않은 호텔 예약 시스템에서는 적합한 선택지이다.&lt;/p>
&lt;p>&lt;strong>데이터베이스 제약 조건&lt;/strong>&lt;/p>
&lt;p>낙관적 락과 아주 유사하게 동작한다.&lt;/p>
&lt;p>&lt;code>room_type_inventory&lt;/code> 테이블에 다음 제약 조건을 추가한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CONSTRAINT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">check_room_count&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">CHECK&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">total_inventory&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_reserved&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_10.png"
width="1478"
height="1368"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_10_hu8a54ba9888669d6b439cae205e8f7b91_81051_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_10_hu8a54ba9888669d6b439cae205e8f7b91_81051_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터 베이스 제약 조건"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="259px"
>&lt;/p>
&lt;p>사용자가 객실을 예약하려면 &lt;code>total_reserved&lt;/code>의 값이 101으로 제약 조건을 위반하게되어 롤백된다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>구현이 쉽다.&lt;/li>
&lt;li>데이터에 대한 경쟁이 심하지 않을 때 잘 동작한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>데이터에 대한 경쟁이 심하면 실패하는 연산 수가 매우 늘어날 수 있다.&lt;/li>
&lt;li>데이터베이스 제약 조건은 애플리케이션 코드와 달라서 버전을 통제하기 어렵다.&lt;/li>
&lt;li>제약 조건을 허용하지 않는 데이터베이스도 있으므로 마이그레이션 등에 문제가 될 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="시스템-규모-확장">시스템 규모 확장&lt;/h3>
&lt;p>일반적으로 호텔 예약 시스템에 대한 부하는 높지 않지만, 유명한 여행 예약 웹 사이트와 연동이 되어야한다면 QPS는 매우 늘어날 수 있다.&lt;/p>
&lt;p>시스템 부하가 높을 때는 무엇이 병목이 될 수 있는지 이해해야한다.&lt;/p>
&lt;ul>
&lt;li>해당 시스템의 모든 서비스는 무상태 서비스이므로 서버를 추가하는 것으로 성능 문제는 해결할 수 있다.&lt;/li>
&lt;li>데이터베이스는 단순히 데이터베이스 서버를 늘리는 것만으로는 성능 문제를 해결할 수 없다.&lt;/li>
&lt;/ul>
&lt;h4 id="데이터베이스-샤딩">데이터베이스 샤딩&lt;/h4>
&lt;p>데이터베이스를 여러 대 두고, 각각에 데이터의 일부만 보관하도록 하는 방식이다.&lt;/p>
&lt;p>데이터베이스를 샤딩할 때는 데이터를 어떻게 분배할 지 먼저 정한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>hotel_id&lt;/code>를 필터링 조건으로 사용하므로 샤딩 조건으로 쓰면 좋다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_11.png"
width="1964"
height="1122"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_11_hu98af43fce089f7bbf6f6bf1fb85b60d6_147947_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_11_hu98af43fce089f7bbf6f6bf1fb85b60d6_147947_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="데이터베이스 샤딩"
class="gallery-image"
data-flex-grow="175"
data-flex-basis="420px"
>&lt;/p>
&lt;p>위는 16개 샤드로 분산하는 사례로, QPS가 30,000이라면 샤딩 후에는 1875QPS 정도로 한 대의 MySQL 서버로도 감당할 수 있는 부하가 된다.&lt;/p>
&lt;h4 id="캐시">캐시&lt;/h4>
&lt;p>호텔 잔여 객실 데이터는 현재와 미래의 데이터만 중요하다는 특성이 있다.&lt;/p>
&lt;p>따라서 데이터를 보관할 때 낡은 데이터는 자동적으로 소멸되도록 TTL을 설정할 수 있다면 바람직하다.&lt;/p>
&lt;ul>
&lt;li>이력 데이터는 다른 데이터베이스를 통해 질의하도록 하면 된다.&lt;/li>
&lt;/ul>
&lt;p>이런 상황에 레디스는 매우 적합하다.&lt;/p>
&lt;hr>
&lt;p>데이터 로딩 속도와 데이터베이스 확장성이 문제가 되기 시작하면 데이터베이스 앞에 캐시 계층을 두고 잔여 객실 확인 및 객실 예약 로직이 해당 계층에서 실행되도록 할 수 있다.&lt;/p>
&lt;p>요청의 일부만 잔여 객실 데이터베이스가 처리하고 나머지는 캐시가 담당하도록 한다.&lt;/p>
&lt;ul>
&lt;li>레디스 캐시 데이터에는 잔여 객실이 충분해 보여도 실제 데이터베이스를 다시 한번 확인해야한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_12.png"
width="1094"
height="682"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_12_hu5d3b54b38dcf02612143f1622e8a715a_133204_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_12_hu5d3b54b38dcf02612143f1622e8a715a_133204_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="캐시"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="384px"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>예약 서비스&lt;/strong>: 다음과 같은 잔여 객실 관리 API를 제공한다.&lt;/p>
&lt;ul>
&lt;li>지정된 호텔과 객실 유형, 주어진 날짜 범위에 이용 가능한 객실의 수를 질의&lt;/li>
&lt;li>객실을 예약하고 &lt;code>total_reserved&lt;/code>의 값을 1 증가&lt;/li>
&lt;li>고객이 예약을 취소하면 잔여 객실 수를 갱신&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>잔여 객실 캐시&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>모든 잔여 객실 관리에 필요한 질의는 레디스로 구현되는 잔여 객실 캐시로 옮긴다.&lt;/li>
&lt;li>따라서 사전에 잔여 객실 정보를 캐시에 미리 저장해두어야 한다.&lt;/li>
&lt;li>캐시에 저장되는 데이터 형식
&lt;ul>
&lt;li>키: &lt;code>hotelID_roomTypeId_{날짜}&lt;/code>&lt;/li>
&lt;li>값
&lt;ul>
&lt;li>주어진 호텔 ID&lt;/li>
&lt;li>객실 유형 ID&lt;/li>
&lt;li>날짜에 맞는 잔여 객실 수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>호텔 예약 시스템은 잔여 객실 확인 작업 때문에 읽기 연산 빈도가 쓰기 연산보다 훨씬 많으므로 대부분의 읽기 연산을 캐시로 처리하면 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>잔여 객실 데이터베이스&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>잔여 객실 수에 대한 가장 믿을 만한 정보가 보관되는 장소&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>캐시가 주는 새로운 과제&lt;/strong>&lt;/p>
&lt;p>캐시 계층을 추가하면 시스템의 확장성과 처리량은 대폭 증가하지만 데이터베이스와 캐시 사이의 데이터 일관성 유지에 관한 새로운 문제가 생긴다.&lt;/p>
&lt;p>사용자가 객실을 예약할 때 아무 문제가 없는 경우에는 다음 두 가지 작업이 이루어진다.&lt;/p>
&lt;ol>
&lt;li>잔여 객실 수를 질의하여 충분한지 확인(캐시)&lt;/li>
&lt;li>잔여 객실 데이터를 갱신
&lt;ul>
&lt;li>데이터베이스 갱신 이후 캐시 갱신&lt;/li>
&lt;li>비동기적으로 실행&lt;/li>
&lt;li>변경 데이터 감지(CDC) 매커니즘을 활용할 수 있다.
&lt;ul>
&lt;li>데이터베이스에서 발생한 변화를 감지하여 해당 변경 내역을 다른 시스템에 적용할 수 있도록 하는 매커니즘&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>잔여 객실 데이터에 대한 변화를 데이터베이스에 먼저 반영하므로 캐시에는 최신 데이터가 없을 가능성이 있다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>이러한 불일치 문제는 데이터베이스가 최종적으로 잔여 객실 확인을 하도록 한다면 문제가 되지는 않는다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>장점&lt;/p>
&lt;ul>
&lt;li>읽기 질의를 캐시가 처리하므로 데이터베이스의 부하가 크게 줄어든다.&lt;/li>
&lt;li>읽기 질의를 메모리에서 실행하므로 높은 성능을 보장할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>단점&lt;/p>
&lt;ul>
&lt;li>데이터베이스와 캐시 사이의 데이터 일관성을 유지하는 것은 어렵다.
&lt;ul>
&lt;li>데이터 불일치가 사용자 경험에 끼치는 영향을 신중하게 살펴야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="서비스-간-데이터-일관성">서비스 간 데이터 일관성&lt;/h3>
&lt;p>모노리스 아키텍처의 경우 데이터의 일광성을 보장하기 위해 관계형 데이터베이스를 공유하는 것이 보통이지만, 해당 시스템은 예약 테이블과 잔여 객실 테이블만 동일한 관계형 데이터베이스에 저장하는 MSA 하이브리드 접근법을 사용한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_13.png"
width="1920"
height="514"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_13_huc5f5e8f7744db63fc867cea3c0d26387_55893_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_13_huc5f5e8f7744db63fc867cea3c0d26387_55893_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="모노리스 vs 마이크로서비스"
class="gallery-image"
data-flex-grow="373"
data-flex-basis="896px"
>&lt;/p>
&lt;p>이를 통해 관계형 데이터베이스의 ACID 속성을 활용하여 동시성 문제를 효과적으로 대응할 수 있지만, MSA 순수 주의자라면 마이크로 서비스가 독자적인 데이터베이스를 갖추고 있어야 한다고 주장할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_15.png"
width="1362"
height="1150"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_15_hu1651b063c3947755463e1494fe52dabe_39875_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_15_hu1651b063c3947755463e1494fe52dabe_39875_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="모노리스 아키텍처"
class="gallery-image"
data-flex-grow="118"
data-flex-basis="284px"
>&lt;/p>
&lt;p>모노리스 아키텍처는 하나의 데이터베이스만 사용하므로 여러 연산을 하나의 트랜잭션으로 묶어 ACID 속성이 만족되도록 보장할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/7/img_14.png"
width="1748"
height="1062"
srcset="https://codemario318.github.io/post/system-design-interview-2/7/img_14_hu657f4a94828478d72376098f027fabfa_59765_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/7/img_14_hu657f4a94828478d72376098f027fabfa_59765_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="마이크로서비스 아키텍처"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="395px"
>&lt;/p>
&lt;p>하지만 서비스가 독자적인 데이터베이스를 갖도록 하면, 논리적으로는 하나의 원자적 연산이 여러 데이터베이스에 걸쳐 실행되는 일을 피할 수 없다.&lt;/p>
&lt;ul>
&lt;li>하나의 트랜잭션으로 데이터 일관성을 보증하는 기법을 사용할 수 없다.&lt;/li>
&lt;/ul>
&lt;p>이러한 데이터 일관성 문제를 해결하기 위해 널리 사용되는 방법은 2가지 정도가 있다.&lt;/p>
&lt;ul>
&lt;li>2단계 커밋(2-phase commit, 2PC)
&lt;ul>
&lt;li>여러 노드에 걸친 원자적 트랜잭션 실행을 보증하는 데이터베이스 프로토콜&lt;/li>
&lt;li>모든 노드가 성공하든 아니면 실패하든 둘 중 하나로 트랜잭션이 마무리되도록 보증&lt;/li>
&lt;li>비중단 실행이 가능한 프로토콜이 아니므로 어느 한 노드에 장애가 발생하면 해당 장애가 복구될 때까지 진행이 중단된다.(성능이 뛰어난 프로토콜은 아니다.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사가(Saga)
&lt;ul>
&lt;li>각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮는다.&lt;/li>
&lt;li>각각의 트랜잭션은 완료되면 다음 트랜잭션을 시작하는 트리거로 쓰일 메시지를 만드러 보낸다.&lt;/li>
&lt;li>한 트랜잭션이라도 실패하면 그 이전 트랜잭션의 결과를 전부 되될리는 트랜잭션들을 순차적으로 실행한다.&lt;/li>
&lt;li>2pc는 여러 노드에 걸친 하나의 트랜잭션을 통해 ACID 속성을 만족시키는 개념이지만 사가는 각 단계가 하나의 트랜잭션이라서 결과적 일관성에 의존하는 것으로 본다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>마이크로서비스 간의 데이터 불일치를 해결하기 위해 사용되는 복잡한 매커니즘은 시스템 전체 설계의 복잡성을 크게 증가시킨다.&lt;br>
증가한 복잡성이 그만한 가치가 있는 지 결정하는 것은 설계자의 몫이다.&lt;/p>
&lt;ul>
&lt;li>이번 설계안은 그만한 가치는 없다고 판단하여 예약 및 잔여 객실 정보를 동일한 관계형 데이터베이스에 저장하는 좀 더 실용적인 접근 방법을 선택했다.&lt;/li>
&lt;/ul>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;ul>
&lt;li>경쟁 조건이 발생할 수 있는 시나리오
&lt;ul>
&lt;li>비관적 락&lt;/li>
&lt;li>낙관적 락&lt;/li>
&lt;li>데이터베이스 제약 조건&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>규모 확장
&lt;ul>
&lt;li>데이터베이스 샤딩&lt;/li>
&lt;li>레디스 캐시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>마이크로아키텍처의 데이터 일관성 문제&lt;/li>
&lt;/ul></description></item><item><title>챌린지 과정 4주차 회고</title><link>https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/</link><pubDate>Mon, 12 Aug 2024 10:44:49 +0900</pubDate><guid>https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/</guid><description>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/cover.png" alt="Featured image of post 챌린지 과정 4주차 회고" />&lt;p>부스트캠프 챌린지 과정이 4주차로 마무리되었습니다🥳&lt;/p>
&lt;p>주말을 이용하여 미뤄왔던 대청소와 약속들 덕분에 월요일이 되어서야 회고를 쓰게 되네요&lt;/p>
&lt;p>이번주는 미션들을 수행하지는 않겠지만, 그동안 바빠서 마무리하지 못했던 학습 정리로 바쁠 것 같습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img.png"
width="900"
height="752"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_huc5e3bd9d0538c93e5f494cd205f8c424_816479_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_huc5e3bd9d0538c93e5f494cd205f8c424_816479_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="아직 한발 남았다."
class="gallery-image"
data-flex-grow="119"
data-flex-basis="287px"
>&lt;/p>
&lt;p>이번 주는 저번주와 마찬가지로 &lt;strong>짝 활동&lt;/strong>을 기본으로 한 주가 구성되었습니다.&lt;/p>
&lt;p>&lt;strong>각자 개발&lt;/strong>후 &lt;strong>짝 개선&lt;/strong>하기, &lt;strong>짝 개발&lt;/strong>후 &lt;strong>각자 개선&lt;/strong>하기로 &lt;strong>데이터베이스&lt;/strong>와 &lt;strong>네트워크&lt;/strong>를 깊게 이해해야만 해결할 수 있는 미션들이 주어졌습니다.&lt;/p>
&lt;p>그리고 마지막 테스트를 위한 &lt;strong>히든 미션&lt;/strong>을 금요일에 수행하였습니다.&lt;/p>
&lt;p>개인적으로 데이터베이스 관련 미션은 많이 어려웠네요 🙃&lt;/p>
&lt;p>이번 회고에는 미션들에 대한 접근 방법에 더해 짝 활동이 어떻게, 무엇을 중심으로 진행되었는지 설명해보겠습니다.&lt;/p>
&lt;h2 id="day16--17-데이터베이스">Day16 ~ 17: 데이터베이스&lt;/h2>
&lt;p>데이터베이스 관련 미션은 &lt;strong>각자 구현&lt;/strong> 후 &lt;strong>짝 개선&lt;/strong>을 수행해야하는 미션이었습니다.&lt;/p>
&lt;p>파일 기반 데이터베이스를 직접 구현해야하는 미션이었는데, 위에서 말씀드렸던 것처럼 개인적으로 많이 어려웠습니다.&lt;/p>
&lt;h3 id="mysql">MySQL&lt;/h3>
&lt;p>이전 직장에서 풀스택 개발자로 업무를 수행해오며 오랜기간 유지되어온 PHP 백엔드 레거시를 운영하는 것이 주 업무였는데요&lt;/p>
&lt;p>그렇다보니 예전 방식으로 그대로 개발을 수행할 수 밖에 없었고, &lt;a class="link" href="https://www.php.net/manual/en/book.pdo.php" target="_blank" rel="noopener"
>PDO&lt;/a>(PHP Data Object)를 사용하고 있었기 때문에 직접 쿼리를 작성해야하는 것은 필수적이었습니다.&lt;/p>
&lt;p>예전 개발 환경과 싱글 스레드 기반으로 순차적인 처리에 중점을 두는 PHP의 특성으로 인해 지금처럼 ORM을 이용하여 작은 쿼리를 여러개 보내는 것 보다는, 굉장히 많은 테이블들을 조인하는 큰 쿼리 하나를 작성해야하는 일도 매우 빈번했습니다.&lt;/p>
&lt;p>그렇다보니 쿼리 튜닝은 저에게 필수적인 역량이었고, 학습에 꽤 많은 공을 들였었습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_5.png"
width="371"
height="136"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_5_hu6fb17a4b1ba75a00ca79acad9d84d206_8737_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_5_hu6fb17a4b1ba75a00ca79acad9d84d206_8737_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL"
class="gallery-image"
data-flex-grow="272"
data-flex-basis="654px"
>&lt;/p>
&lt;p>이러한 이유로 MySQL 내부 동작을 꽤 잘 알고 있다고 생각하여 이번 미션은 MySQL을 모방하는 방식으로 접근했었습니다.&lt;/p>
&lt;h3 id="스토리지-엔진">스토리지 엔진&lt;/h3>
&lt;p>기존 요구사항만을 만족하기 위해서는 단순하게 전체 읽기, 전체 쓰기 방식으로 접근해도 괜찮았지만, 이러한 경우 데이터가 많아지면 급격한 성능 저하가 발생하게됩니다.&lt;/p>
&lt;p>이러한 문제를 해결해보고 싶어 많은 고민을 했는데 이 부분이 정말 어려웠습니다🥲&lt;/p>
&lt;hr>
&lt;p>&lt;strong>InnoDB&lt;/strong>&lt;/p>
&lt;p>데이터베이스의 성능을 나쁘게 만드는 원인은 &lt;strong>디스크 I/O&lt;/strong>에서 발생하는 &lt;strong>병목 현상&lt;/strong>입니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_1.png"
width="904"
height="456"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_1_hu5128e5d7946208d35600b2a8a7d0222a_52925_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_1_hu5128e5d7946208d35600b2a8a7d0222a_52925_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="MySQL 구조"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="475px"
>&lt;/p>
&lt;p>MySQL은 크게 &lt;strong>MySQL 엔진&lt;/strong>, &lt;strong>스토리지 엔진&lt;/strong>으로 영역을 구분할 수 있는데, 디스크 I/O에 접근하는 역할은 &lt;strong>스토리지 엔진&lt;/strong>이 전담하여 수행하게 됩니다.&lt;/p>
&lt;p>여러 스토리지 엔진이 있지만 주로 사용되는 &lt;code>InnoDB&lt;/code> 스토리지 엔진은 &lt;strong>버퍼풀&lt;/strong>이라는 메모리 영역을 통해 사용하는 주요 데이터를 대부분 캐싱하여 디스크에 접근하는 것을 최소화합니다.&lt;/p>
&lt;p>또한 쓰기 작업을 버퍼링하여 하드웨어 자원의 여유가 있을 때 백그라운드에서 실행하는 방식들을 통해 데이터베이스의 성능을 크게 끌어올리고 있습니다.&lt;/p>
&lt;p>이를 반영하기 위해서 데이터를 저장하고 관리하는 기본 단위인 &lt;strong>페이지&lt;/strong>를 구현하야할 필요가 있었습니다만&amp;hellip;.&lt;/p>
&lt;p>페이지를 직접 구현하고 이를 이용해서 데이터 저장이나 캐싱등을 구현해야한다고 생각하니 현기증이 나는 것 같다라구요😅&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_2.png"
width="632"
height="523"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_2_huaf81590ee5a0b6795972f97e2fb827b9_593519_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_2_huaf81590ee5a0b6795972f97e2fb827b9_593519_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="290px"
>&lt;/p>
&lt;p>그래서 MySQL 인덱스의 기본 단위인 PK만을 이용해서 저장된 파일에서의 레코드 위치만을 가지게 구현하는 방식으로 접근했습니다.&lt;/p>
&lt;p>&lt;strong>B+ Tree&lt;/strong> 같은 자료 구조를 통해서 &lt;code>Index Range Scan&lt;/code> 같은 방식도 적용해보려고 했었는데, 마찬가지로 어려워서 &lt;code>PK&lt;/code> 단일 조건 처리에 관한 부분만 적용할 수 있었습니다.&lt;/p>
&lt;h3 id="짝-개선">짝 개선&lt;/h3>
&lt;p>짝 개선은 이전과 마찬가지로 새로운 기능을 추가하는 것 보다는 기존 코드를 개선하는 방향으로 지침이 주어졌습니다.&lt;/p>
&lt;p>저 같은 경우는 &lt;strong>HTTP 요청/응답 분리&lt;/strong>를, 짝은 &lt;strong>DBMS 아키텍처 반영&lt;/strong>을 통한 &lt;strong>코드 구조&lt;/strong>를 개선하는 것을 목표로 함께 개선을 진행하였습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>예외 처리&lt;/strong>&lt;/p>
&lt;p>저의 개선 목표였던 &lt;strong>HTTP 요청/응답 분리&lt;/strong> 부분 작업을 수행하면서 자연스럽게 &lt;strong>응답 코드&lt;/strong>에 관한 내용들이 개선되어야 했고, 응답을 만들기위해 &lt;strong>예외 처리&lt;/strong>를 추가하는 부분에서 짝과 의견을 나눌 수 있는 기회가 생겼습니다.&lt;/p>
&lt;p>저 같은 경우는 서비스 로직에서 에러 또는 예외를 발생시켜 해당 에러를 최상위 지점에서 한번에 핸들링하는 것을 선호하는데(&lt;a class="link" href="https://codemario318.github.io/post/clean-code/7/" >클린코드 - 에러 처리&lt;/a>) 어떠한 장점이 있는지에 대해서 물어봐 주셨습니다.&lt;/p>
&lt;p>코드를 보면서 확인해보면 아래와 같습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>개선 전&lt;/strong>&lt;/p>
&lt;p>이전 처리를 복기해보면 아래와 같은 방식으로 처리가 구현되어 있었습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">어떤_서비스_클래스&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">원하는_동작&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">값_검증&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">throw&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">status&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;value&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;입력 값을 확인해주세요.&amp;#39;&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">서비스로직을_사용하는_클래스&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">어떤_기능&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">결과&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">어떤_서비스_객체&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">원하는_동작&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">200&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;OK&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">body&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">결과&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">status&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">switch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">status&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="s1">&amp;#39;value&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">400&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">500&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이러한 방식에는 몇 가지 문제가 있습니다.&lt;/p>
&lt;ul>
&lt;li>예외를 발생 시킬 때 사용자가 직접 사유를 기억해서 매직넘버(상수가 아닌 직접 입력해야하는 값, 하드코딩)를 사용해야합니다.&lt;/li>
&lt;li>응답도 같은 문제를 가지고 있습니다.&lt;/li>
&lt;/ul>
&lt;p>이러한 방식은 개발자가 실수를 쉽게 할 수 있는 여지가 많아지게됩니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>개선 후&lt;/strong>&lt;/p>
&lt;p>이러한 부분을 아래와 같이 개선하게 되었습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">BadRequestException&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nb">Error&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">UnauthorizedException&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nb">Error&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">ForbiddenException&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nb">Error&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">NotFoundException&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nb">Error&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">NotAcceptableException&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nb">Error&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">HttpStatusCodes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">Object&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">freeze&lt;/span>&lt;span class="p">({&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">OK&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">200&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">BAD_REQUEST&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">400&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">UNAUTHORIZED&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">401&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">FORBIDDEN&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">403&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">NOT_FOUND&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">404&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">NOT_ACCEPTABLE&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">406&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">INTERNAL_SERVER_ERROR&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">500&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>각 예외 상황에 맞는 예외 클래스를 구현하였습니다.
&lt;ul>
&lt;li>Nest.js 표준 에러 참조&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Http 응답 코드에 대해 Enum을 선언하였습니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">어떤_서비스_클래스&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">원하는_동작&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">값_검증&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">BadRequestException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;입력 값을 확인해주세요.&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">서비스로직을_사용하는_최상위_클래스&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">어떤_기능&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">결과&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">어떤_서비스_객체&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">원하는_동작&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">HttpStatusCode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">OK&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">body&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">결과&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">message&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="nx">BadRequestException&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">HttpStatusCodes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">BAD_REQUEST&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="nx">NotFoundException&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">HttpStatusCodes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NOT_FOUND&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">HttpStatusCodes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">INTERNAL_SERVER_ERROR&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">message&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>발생한 예외 클래스를 확인하여 Enum으로 선언된 응답 코드를 상황에 맞게 반환할 수 있도록 변경&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>이러한 형식으로 개선되어 아래와 같은 장점을 취할 수 있었습니다.&lt;/p>
&lt;ul>
&lt;li>예외 클래스를 직접 확인하므로 어떤 에러가 발생했는지 쉽게 파악할 수 있다.&lt;/li>
&lt;li>에외 코드가 어떤 의미인지 확실히 구분할 수 있다. 등&lt;/li>
&lt;/ul>
&lt;p>발생하는 예외가 HTTP 응답에 대해 직접적인 연관성이 있어 또 하나의 세부사항인 HTTP와 관계가 생겨버린다는 것이 아쉬운 점이지만 충분히 개선되었다고 생각합니다.&lt;/p>
&lt;p>제가 생각하는 장점을 코드를 함께 개선해가는 과정을 통해서 설명해 드렸고, 많은 도움이 되었다는 이야기를 들을 수 있었습니다😁&lt;/p>
&lt;h2 id="day18--19-네트워크">Day18 ~ 19: 네트워크&lt;/h2>
&lt;p>네트워크 관련 미션은 &lt;strong>페어 프로그래밍&lt;/strong>을 통해 함께 결과물을 만들고, 이후 &lt;strong>각자 개선&lt;/strong>을 수행하는 미션이었습니다.&lt;/p>
&lt;p>&lt;strong>웹 소켓&lt;/strong> 서버를 직접 구현하는 것이 전제되어있는 미션이었는데, &lt;strong>레이어드 아키텍처&lt;/strong>를 쉽게 적용할 수 있는 요구사항이어서 짝에게 설계를 적극적으로 제안하여 적용하게 되었습니다.&lt;/p>
&lt;p>이전과 달랐던 점은 짝이 이전부터 &lt;strong>TDD&lt;/strong>를 적용해오셨던 분이셔서, 자연스럽게 &lt;strong>TDD&lt;/strong>로 진행되었습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_3.png"
width="816"
height="454"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_3_hu05ec6f48f861dd6127467224c3c8452c_617786_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_3_hu05ec6f48f861dd6127467224c3c8452c_617786_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="179"
data-flex-basis="431px"
>&lt;/p>
&lt;p>기능 요구사항을 돌아가며 &lt;strong>드라이버&lt;/strong>, &lt;strong>네비게이터&lt;/strong> 역할을 수행하는 방식으로 진행되었는데, 원할하게 &lt;strong>TDD&lt;/strong>가 진행되어서 참 즐거운 경험이었습니다😁&lt;/p>
&lt;p>그리고 짝 캠퍼분이 이전부터 FE 개발을 해오셨던 경험이 있으셔서 JS에 매우 능숙하셨기 때문에 아주 원할하게 진행될 수 있었던 것 같네요&lt;/p>
&lt;p>&lt;strong>레이어드 아키텍처&lt;/strong> 기반의 설계와, &lt;strong>TDD&lt;/strong>가 합쳐지니 지금까지 결과물 중 가장 만족스러운 결과물을 만들 수 있었습니다. 👍&lt;/p>
&lt;p>&lt;del>그래도 새벽 3시가 넘어서야 마무리 할 수 있었어요🤣&lt;/del>&lt;/p>
&lt;h3 id="레이어드-아키텍처">레이어드 아키텍처&lt;/h3>
&lt;p>&lt;code>Socket&lt;/code>을 이용하여 &lt;strong>CLI 기반 클라이언트&lt;/strong>와 &lt;strong>서버&lt;/strong>를 구현해야했습니다.&lt;/p>
&lt;p>서버와 클라이언트의 연결을 만들고, 클라이언트의 요청마다 HTTP 응답을 처리하는 구조가 필요했기 때문에 짝에게 &lt;strong>레이어드 아키텍처&lt;/strong>를 적극적으로 제안하여 반영하였습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_4.png"
width="1127"
height="843"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_4_hu4e52c0ad343a0efa02fd57875f5ec4d4_47956_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_4_hu4e52c0ad343a0efa02fd57875f5ec4d4_47956_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="레이어드 아키텍처"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="320px"
>&lt;/p>
&lt;p>&lt;strong>HTTP 요청 수신 및 응답&lt;/strong>, &lt;strong>비즈니스 로직 처리&lt;/strong>, &lt;strong>데이터 조작&lt;/strong>을 각 레이어로 구현하여 분리하여, 좋은 코드 구조를 만들 수 있었습니다.&lt;/p>
&lt;p>짝과 함께 개발하는 과정에서 뿐만이 아니라, 다음 피어세션에서도 해당 설계를 보고 많은 영감을 얻으셨다는 반응이 많아서 뿌듯했네요 😎&lt;/p>
&lt;h3 id="의존성-주입">의존성 주입&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_6.png"
width="271"
height="186"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_6_hua164b4f218d2ddb10286229f1ed50614_9292_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_6_hua164b4f218d2ddb10286229f1ed50614_9292_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="의존성 주입"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="349px"
>&lt;/p>
&lt;p>레이어드 아키텍처를 구성하며 각 의존성이 있는 레이어를 &lt;strong>의존성 주입&lt;/strong>을 통해 &lt;strong>구성&lt;/strong>하였습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">Model&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">#&lt;/span>&lt;span class="nx">items&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">items&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">items&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">items&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">getItem&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">collection&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">find&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">condition&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">Service&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">#&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">model&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">model&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">businessLogic&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getItem&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">Handler&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">#&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">constructor&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">service&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">service&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">handler&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">code&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">HttpStatusCode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">OK&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">body&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">businessLogic&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">items&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">model&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Model&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">items&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">service&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Service&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">handler&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Handler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이러한 구조를 통해 결합을 낮추고 유연성을 높힐 수 있었으며, 구현 과정에서 훨씬 테스트가 용이하다는 장점을 취할 수 있었습니다.&lt;/p>
&lt;h3 id="단단한-테스트-코드">단단한 테스트 코드&lt;/h3>
&lt;p>&lt;strong>각자 개선하기&lt;/strong>에서 저는 테스트 코드 부분을 개선하였습니다.&lt;/p>
&lt;p>단단한 테스트 코드 즉 깨지지 않는 테스트 코드를 작성하기 위해서 개인적으로 테스트 원칙인 단일 책임 원칙, 독립적 테스트 부분을 개선했습니다.&lt;/p>
&lt;ul>
&lt;li>단일 책임 원칙
&lt;ul>
&lt;li>테스트 코드는 하나의 동작이나 기능만을 테스트 해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>독립적 테스트
&lt;ul>
&lt;li>테스트 간에 의존성이 있으면 한 테스트의 실패가 다른 테스트에도 영양을 줌&lt;/li>
&lt;li>테스트 간 상태 공유를 피하고, 각 테스트 케이스가 독립적으로 실행될 수 있도록 보장해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>단일 책임 원칙&lt;/strong>&lt;/p>
&lt;p>하나의 테스트 코드는 한 가지의 동작과 기능을 테스트해야 이후 변경이 적고 오래사용할 수 있는 테스트 코드를 만들 수 있습니다.&lt;/p>
&lt;p>기존 작성되어있던 테스트를 유사하게 다시 만들어봤습니다.&lt;/p>
&lt;p>어떠한 모델에서 id를 이용해 특정 무언가를 찾는 처리입니다. (어떤 내용인지 추론할 수 있으면 안되기 때문에 추상적으로 쓸 수 밖에 없는 점 양해 부탁드립니다.)&lt;/p>
&lt;hr>
&lt;p>&lt;strong>변경 전&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">makeIds&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nb">Array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">from&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">length&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">count&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">idx&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="sb">`&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">idx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">toString&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">padStart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;0&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">describe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;ID를 활용하여 무언가를 찾아 배정하고 반환하는 처리 테스트&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">each&lt;/span>&lt;span class="p">([&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">makeIds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">id1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">makeIds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">id2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">makeIds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">id3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">makeIds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">id4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">makeIds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">id5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">])(&lt;/span>&lt;span class="s2">&amp;#34;무언가를 찾아 배정하고, 배정된 무언가를 반환&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">prevIds&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">nextId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">expected&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">prevIds&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">forEach&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">assignById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">assignById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nextCampId&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">expected&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>많은 상황에 대해 정상적인 처리를 테스트하고 있습니다.&lt;/p>
&lt;p>많은 테스트케이스를 확인하고 있었기 때문에 예외가 발생해야하는 상황은 별도로 확인하고 있지 않았습니다.&lt;/p>
&lt;p>개인적인 의견으로는 알아보기 힘들다고 판단했습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>변경 후&lt;/strong>&lt;/p>
&lt;p>여러 상황을 나누어 테스트하도록 했으며, 테스트 케이스의 숫자도 줄였습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">describe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;ID를 활용하여 무언가를 찾아 배정하고 반환하는 처리 테스트&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;정상 처리 확인&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">assignedId&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">assignById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">assignedId&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toEqual&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;특정 조건이 넘으면 다른 값 반환 확인&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">clients&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">Array&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">MAX_ASSIGN_CLIENT&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="sb">`J&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">toString&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">padStart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;0&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="nx">clients&lt;/span>&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">assigned&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">assignById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">assignedId&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toEqual&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;먼저 만들어진 무언가에 빈 자리가 있다면 해당 무언가를 반환&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="nx">clients&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="p">[]});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="nx">clients&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="p">[]});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">assignedId&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">assignById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">assignedId&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toEqual&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>&lt;strong>독립적 테스트&lt;/strong>&lt;/p>
&lt;p>일부 테스트가 스스로의 다른 기능을 호출하는 부분들이 있었습니다. 이는 기능의 변경에 취약한 테스트가 될 수 있다고 판단하여 수정하였습니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>변경 전&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">describe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;count&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;횟수 반환&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">increaseCount&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>service.count&lt;/code> 메소드를 통해 현재 &lt;code>count&lt;/code>을 확인하기 위해 &lt;code>service.increaseCount&lt;/code>메소드를 통해 &lt;code>count&lt;/code>를 증가시키고 있습니다.&lt;/p>
&lt;p>이는 자기 자신의 메소드를 재 호출하는 구조로 인해 &lt;code>service.increaseCount&lt;/code>에 미쳐 검증하지 못한 케이스가 있거나, 요구사항 변경으로 인해 검증해야 할 내용이 바뀐다면, &lt;code>service.count&lt;/code>의 테스트 코드도 변경이 불가피한 상황입니다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>변경 후&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">describe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;count&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">it&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;횟수 반환&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">clap&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">service&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nx">toBe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>service&lt;/code>의 데이터 보관을 위해 주입받은 &lt;code>Map&lt;/code>에 직접 데이터를 저장, 조작하여 자기 자신의 메소드를 활용하는 테스트 처리의 의존성을 제거하였습니다.&lt;/p>
&lt;h2 id="day20-3차-문제해결력-테스트">Day20: 3차 문제해결력 테스트&lt;/h2>
&lt;p>기존 모집 정보에 3차 문제해결력 테스트가 8월 10일 토요일로 예정되어 있었는데, 마지막 날인 20일차 릴레이 프로젝트를 수행해야하는 시간에 테스트가 진행되었습니다.&lt;/p>
&lt;p>대략적으로 말씀드리면, 부캠에서 제공했던 모든 과정들이 단시간에 종합되어있는 테스트였습니다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_7.png"
width="491"
height="340"
srcset="https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_7_hu5fb8e3cf3fed11573f93053e9937564e_404795_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/boostcamp-9th/review/challenge/4/img_7_hu5fb8e3cf3fed11573f93053e9937564e_404795_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="부캠 종합 선물세트"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="346px"
>&lt;/p>
&lt;p>부캠에 성실히 참여했다면 방식 자체는 생소하지는 않았겠지만, 역시나 시간은 많이 부족했네요🥲&lt;/p>
&lt;h2 id="마무리">마무리&lt;/h2>
&lt;p>마지막 주차에는 같이 학습을 진행한 캠퍼분들에게 영감을 줄 수 있었던것 같아 1주차 이후로 가장 뿌듯했던 한 주 였던 것 같습니다.&lt;/p>
&lt;p>마지막 주차여서 챌린지 과정 전체에대한 회고를 포함해야하나 고민했는데, 따로 작성하기로 결정하여 4주차 회고만 남기게 되었네요&lt;/p>
&lt;p>다음 글은 챌린지 과정 전체에 대한 회고를 올릴 예정이니 기대해주세요😁&lt;/p>
&lt;p>이번에는 3주차 그룹 회고에 남겼던 글로 마무리하겠습니다.&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다☺️ 모두 정말 고생 많으셨어요🔥🔥🔥&lt;/p>
&lt;blockquote>
&lt;p>소프트웨어 장인 책 부분에 성장을 위한 자세에 관해 읽었는데요, 이 부분에서 &amp;ldquo;훈련&amp;quot;을 어떻게 해야 좋은지에 대한 언급이 있습니다.&lt;/p>
&lt;p>훈련을 할 때는 시간이 아무리 많이 걸린다고 하더라도 본인이 할 수 있는 최선의 결과를 만들지 않는다면 성장에는 큰 의미가 없기 때문에 최선을 다하는 것이 중요하다고해요!&lt;/p>
&lt;p>우리 모두 지금까지 열심히 해오고있지만, 앞으로도 최선을 다해서 함께 성장했으면 좋겠어요&lt;/p>
&lt;p>한 주간 정말 고생 많으셨습니다! 맴버쉽에서 꼭 뵈어요 :D&lt;/p>
&lt;/blockquote></description></item><item><title>[MovieLens] 2. DB 설계</title><link>https://codemario318.github.io/post/movielens/2/</link><pubDate>Tue, 19 Mar 2024 16:00:01 +0900</pubDate><guid>https://codemario318.github.io/post/movielens/2/</guid><description>&lt;img src="https://codemario318.github.io/post/movielens/2/cover.jpeg" alt="Featured image of post [MovieLens] 2. DB 설계" />&lt;p>앞서 진행한 데이터셋 구조 확인을 바탕으로, 간단하게 데이터베이스 설계를 해봤습니다.&lt;/p>
&lt;p>&lt;code>TAGS&lt;/code>, &lt;code>RATINGS&lt;/code> 테이블은 &lt;code>user_id&lt;/code>, &lt;code>movie_id&lt;/code> 컬럼을 활용한 관계 테이블인데 &lt;code>USERS&lt;/code> 테이블에 관련된 데이터들을 별도로 제공하지 않았기 때문에 있다고 가정하고 진행했습니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
MOVIES {
int movie_id PK
string title
string genres
int rating_count
bigint rating_total
}
RATINGS {
int user_id PK,FK
int movie_id PK,FK
int rating
timestamp created_at
}
REVIEWS {
int review_id PK
int user_id FK
int movie_id FK
string content
timestamp created_at
timestamp updated_at
}
TAGS {
string name PK
timestamp created_at
}
REVIEWS_TAGS {
int user_id PK,FK
int movie_id PK,FK
int tag_name PK,FK
}
USERS {
int id PK
}
MOVIES ||--o{ RATINGS: ""
RATINGS }o--|| USERS: ""
MOVIES ||--o{ REVIEWS: ""
REVIEWS }o--|| USERS: ""
REVIEWS ||--o{ REVIEWS_TAGS: ""
REVIEWS_TAGS }o--|| TAGS: ""
&lt;/pre>
&lt;p>기존 데이터를 기반으로 일부 컬럼들과 테이블을 추가하였습니다.&lt;/p>
&lt;p>자세한 내용은 테이블 별로 설명해보겠습니다.&lt;/p>
&lt;h2 id="movies">MOVIES&lt;/h2>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
MOVIES {
int movie_id PK
string title
string genres
int rating_count
bigint rating_total
}
&lt;/pre>
&lt;p>기존 제공된 &lt;code>movie_id&lt;/code>, &lt;code>title&lt;/code>, &lt;code>genres&lt;/code>는 그대로 활용하고, 평균 평점 계산에 활용될 &lt;code>rating_count&lt;/code>, &lt;code>rating_total&lt;/code> 컬럼을 추가했습니다.&lt;/p>
&lt;p>&lt;code>genres&lt;/code> 컬럼은 장르들이 &lt;code>|&lt;/code> 문자로 구분되어 문자열 형태로 저장되는 형식이었는데, 처음 RDBMS를 이용해 만드는 방식에서는 검색 조건등의 활용을 배제하고, 이후 검색 엔진 같은 다른 방식으로 제공해 볼 예정입니다.&lt;/p>
&lt;p>&lt;code>rating_count&lt;/code>, &lt;code>rating_total&lt;/code> 컬럼은 조회 후 서버나 클라이언트 측에서 직접 계산하는 방식을 사용할 수 있고, &lt;strong>MySQL&lt;/strong>, &lt;strong>PostgreSQL&lt;/strong>등과 같이 &lt;strong>함수 기반 인덱스&lt;/strong> 기능을 제공하는 RDBMS를 활용한다면 조건을 활용한 조회 성능에도 이슈가 발생하지 않을 것이라 생각되어 추가하였습니다.&lt;/p>
&lt;p>&lt;code>rating_count&lt;/code>, &lt;code>rating_total&lt;/code> 컬럼은 사용자가 평점을 추가하거나 수정할 때 변경되는 값이므로 평점 등록, 수정, 삭제 처리시 해당 컬럼 처리 로직 구현에 주의가 필요하겠습니다.&lt;/p>
&lt;h2 id="ratings">RATINGS&lt;/h2>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
RATINGS {
int user_id PK,FK
int movie_id PK,FK
int rating
timestamp create_ts
}
&lt;/pre>
&lt;p>기존 제공된 &lt;code>user_id&lt;/code>, &lt;code>movie_id&lt;/code>, &lt;code>create_ts&lt;/code>는 그대로 활용하고, &lt;code>rating&lt;/code> 컬럼의 데이터 타입을 변경하였습니다.&lt;/p>
&lt;p>&lt;code>rating&lt;/code> 같은 경우 기존에는 &lt;strong>0.5 간격 0~5 까지의 소수&lt;/strong>를 저장하고 있었지만, &lt;code>MOVIES&lt;/code> 테이블의 &lt;code>rating_total&lt;/code> 처리와 평균 평점 계산 처리가 필요하므로, 개인 최고점을 10점으로 변경하고 서비스 로직에서 평점을 계산하는 방식을 고려하는게 더 합리적이라 판단하여 정수형 데이터타입을 선택하였습니다.&lt;/p>
&lt;p>이외에도 &lt;code>rating_id&lt;/code>와 같은 별도 PK를 만드는 것을 고려해봤지만, &lt;code>rating_id&lt;/code> 컬럼이 다른 테이블에서 활용되거나 PK가 변경거나 &lt;code>user_id&lt;/code>, &lt;code>movie_id&lt;/code> 없이 단독으로 할용되는 경우는 없을 것이라 판단되어 별도로 추가하지는 않았습니다.&lt;/p>
&lt;h2 id="tags-reviews-reviews_tags">TAGS, REVIEWS, REVIEWS_TAGS&lt;/h2>
&lt;p>기본 제공된 데이터에서 &lt;code>TAGS&lt;/code>는 전체 2,328,315건 중 유니크한 &lt;code>tag&lt;/code>는 153,950개 였습니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
TAGS {
int user_id PK,FK
int movie_id PK,FK
int tag PK,FK
timestamp create_ts
}
&lt;/pre>
&lt;p>위와 같은 구조를 확인할 수 있었는데, 일반적으로 이러한 형태의 태그는 글과 함께 사용되는 해시태그 같은 기능이어서 어떻게 구조를 가져가야할지 고민이 들었습니다.&lt;/p>
&lt;p>제 추측으로는 이 데이터의 목적은 추천 모델 개발이므로 사용자와 영화의 관계, 사용자가 자주 활용한 태그, 특정 영화에 많이 활용된 태그 등 &lt;code>user_id&lt;/code>, &lt;code>movie_id&lt;/code>를 기준으로 활용하는 것이 더 적합했기 때문이라고 생각되었습니다.&lt;/p>
&lt;p>이 부분들을 고려하여 구성한 테이블 구조는 아래와 같습니다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
TAGS {
string name PK
timestamp create_ts
}
REVIEWS_TAGS {
int user_id PK,FK
int movie_id PK,FK
int tag_name PK,FK
}
REVIEWS {
int review_id PK
int user_id FK
int movie_id FK
string content
timestamp create_ts
timestamp update_ts
}
TAGS ||--o{ REVIEWS_TAGS: ""
REVIEWS_TAGS }o--|| REVIEWS: ""
&lt;/pre>
&lt;p>기존 &lt;code>TAGS&lt;/code>를 &lt;code>REVIEWS_TAGS&lt;/code>로 바꿔 연결 테이블로 구성했습니다.&lt;/p>
&lt;p>&lt;code>TAGS&lt;/code> 테이블은 &lt;code>tag&lt;/code>만을 가지게 구성하고, 사용자가 영화에 후기를 남기는 기능을 고려하여 &lt;code>REVIEWS&lt;/code> 테이블을 추가하였습니다.&lt;/p>
&lt;p>&lt;code>TAGS&lt;/code> 테이블은 앞서 언급했던 데이터 중복 뿐만 아니라 특정 태그를 활용한 게시글 검색등 활용될 여지가 많기 때문에 추가하였습니다.&lt;/p>
&lt;p>사용 횟수 같은 컬럼들을 추가하는 것도 고려하였으나, 현 상황에서는 &lt;code>(tag_name)&lt;/code> 인덱스 추가 정도로 충분히 빠른 조회를 수행할 수 있기 때문에 게시글 작성, 수정, 삭제 등의 로직 처리에 변수들을 배제하는것이 좋겠다고 판단하였습니다.&lt;/p>
&lt;p>&lt;code>REVIEWS&lt;/code> 테이블은 비즈니스 요구사항(베스트 후기 등)에 따라 단독으로 활용될 여지가 많다고 생각되어 &lt;code>RATINGS&lt;/code> 테이블과 다르게 &lt;code>review_id&lt;/code>를 추가하였습니다.&lt;/p>
&lt;p>&lt;code>REVIEWS_TAGS&lt;/code> 테이블은 기존 외래키인 &lt;code>user_id&lt;/code>, &lt;code>movie_id&lt;/code>를 &lt;code>review_id&lt;/code>로 변경하지 않고 사용했는데, 위에서 언급한대로 사용자와 영화의 관계를 쉽게 이용하려면 기존 방식이 더 적합하고, &lt;code>REVIEWS&lt;/code>와 관련된 처리가 필요하다면 인덱스를 활용하여 충분히 쉽게 처리할 수 있다고 판단되었습니다.&lt;/p>
&lt;h2 id="끝으로">끝으로&lt;/h2>
&lt;p>데이터셋 구조 확인에 이어 간단히 데이터베이스 구조를 구상해봤습니다.&lt;/p>
&lt;p>만들어 놓고 보니 뭔가 찜찜한 기분이 계속 남네요..&lt;/p>
&lt;p>제 역량이 부족해서 어떤 문제들이 발생하게 될지 예상할 수는 없지만 앞으로 발견되는 부족한 부분들은 프로젝트를 진행하면서 조금씩 수정해나가겠습니다.&lt;/p>
&lt;p>끝까지 읽어주셔서 감사합니다 :)&lt;/p></description></item></channel></rss>