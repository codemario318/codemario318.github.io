<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cassandra on Mario Blog</title><link>https://codemario318.github.io/tags/cassandra/</link><description>Recent content in Cassandra on Mario Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Sun, 06 Oct 2024 17:20:50 +0900</lastBuildDate><atom:link href="https://codemario318.github.io/tags/cassandra/index.xml" rel="self" type="application/rss+xml"/><item><title>6. 광고 클릭 이벤트 집계</title><link>https://codemario318.github.io/post/system-design-interview-2/6/</link><pubDate>Sun, 06 Oct 2024 17:20:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/6/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/cover.png" alt="Featured image of post 6. 광고 클릭 이벤트 집계" />&lt;p>이번 장은 페이스북이나 구글 규모에 걸맞는 &lt;strong>광고 클릭 이벤트 집계 시스템&lt;/strong>(ad click event aggregation system)을 설계해본다.&lt;/p>
&lt;p>기술적인 세부사항을 깊이 살펴보기 전 온라인 광고의 핵심 개념부터 살펴본다.&lt;/p>
&lt;p>온라인 광고의 핵심적 혜택은 &lt;strong>실시간 데이터를 통해 광고 효과를 정량적으로 측정할 수 있다&lt;/strong>는 점이다.&lt;/p>
&lt;p>핵심 프로세스는 &lt;strong>RTB&lt;/strong>(Real-Time Bidding)으로, 이 &lt;strong>경매 절차를 통해 광고가 나갈 지면(inventory)을 거래&lt;/strong>한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
subgraph 지면수요자
direction LR
광고주 --> DSP[DSP: 수요자 플랫폼]
end
DSP --> 광고거래소
SSP --> 광고거래소
subgraph 지면공급자
direction RL
공급자 --> SSP[SSP: 공급자 플랫폼]
end
&lt;/pre>
&lt;ul>
&lt;li>속도
&lt;ul>
&lt;li>보통 1초 내에 모든 프로세스가 마무리되어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 정확성
&lt;ul>
&lt;li>광고 클릭 이벤트 집계는 온라인 광고가 얼마나 효율적이었는지 측정하는 데 결정적인 역할을 한다.
&lt;ul>
&lt;li>광고주가 얼마나 많은 돈을 지불할지에 영향을 끼친다.&lt;/li>
&lt;li>클릭 집계 결과에 따라 광고 캠페인 관리자는 예산을 조절할 수 있다.&lt;/li>
&lt;li>타깃이나 키워드를 변경하는 등 공고 전략을 수정할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CTR(Click-Through Rate, 클릭률), CVR(Conversion Rate, 전환률)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;h3 id="기능-요구사항">기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>지난 M분 동안의 &lt;code>ad_id&lt;/code> 클릭 수 집계&lt;/li>
&lt;li>매분 가장 많이 클릭된 상위 100개 광고 아이디를 반환&lt;/li>
&lt;li>다양한 속성에 따른 집계 필터링을 지원&lt;/li>
&lt;li>데이터의 양은 페이스북이나 구글 규모&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항">비기능 요구사항&lt;/h3>
&lt;ul>
&lt;li>집계 결과 정확성은 데이터가 RTB 및 광고 과금에 사용되므로 중요&lt;/li>
&lt;li>지연되거나 중복된 이벤트를 적절히 처리할 수 있어야 함&lt;/li>
&lt;li>견고성
&lt;ul>
&lt;li>부분적인 장애는 감내할 수 있어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>지연 시간 요구사항
&lt;ul>
&lt;li>전체 처리 시간은 최대 수 분을 넘지 않아야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="개력적-추정">개력적 추정&lt;/h3>
&lt;p>시스템 규모 및 풀어야 할 잠재적 문제점을 파악하기 이해 개략적인 규모를 추정해본다.&lt;/p>
&lt;ul>
&lt;li>DAU 10억&lt;/li>
&lt;li>각 사용자는 하루에 평균 1개 광고를 클릭한다 가정
&lt;ul>
&lt;li>따라서 하루에 10억 건의 광고 클릭 이벤트 발생&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>광고 클릭 QPS = 10^9 / 10^5 = 10,000&lt;/code>&lt;/li>
&lt;li>최대 광고 클릭 QPS는 평균 QPS의 5배로 가정(50,000)&lt;/li>
&lt;li>광고 클릭 이벤트 하나당 &lt;code>0.1KB&lt;/code> 용량이 필요하다고 가정
&lt;ul>
&lt;li>&lt;code>일일 저장소 요구량 = 0.1KB * 10억 = 100GB&lt;/code>&lt;/li>
&lt;li>월간 저장 용량 요구량은 대략 3TB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;h3 id="질의-api-설계">질의 API 설계&lt;/h3>
&lt;p>API를 설계하는 목적은 클라이언트와 서버 간의 통신 규약을 만드는 것 이다.&lt;/p>
&lt;p>본 설계안의 클라이언트는 대시보드를 이용하는 데이터 과학자, 제품 관리자, 광고주 같은 사람으로, 대시보드를 이용하는 순간 집계 서비스에 질의가 발생한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>지난 M분간 각 &lt;code>ad_id&lt;/code>에 발생한 클릭 수 집계&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>용도&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/ads/{:ad_id}/aggregated_count&lt;/td>
&lt;td>주어진 ad_id에 발생한 이벤트 수를 집계하여 반환&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>
&lt;p>호출 인자&lt;/p>
&lt;ul>
&lt;li>from : 집계 시작 시간&lt;/li>
&lt;li>to: 집계 종료 시간&lt;/li>
&lt;li>filter: 필터링 전략 식별자&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>반환 응답&lt;/p>
&lt;ul>
&lt;li>ad_id: 광고 식별자&lt;/li>
&lt;li>count: 집계된 클릭 횟수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>지난 M분간 가장 많은 클릭이 발생한 상위 N개 ad_id 목록&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>용도&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET /v1/ads/popular_ads&lt;/td>
&lt;td>지난 M분간 가장 많은 클릭이 발생한 상위 N개 광고 목록 반환&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>호출 인자
&lt;ul>
&lt;li>count: 상위 몇 개의 광고를 반환할 것인가&lt;/li>
&lt;li>window: 분 단위로 표현된 집계 윈도 크기&lt;/li>
&lt;li>filter: 필터링 전략 식별자&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>응답
&lt;ul>
&lt;li>ad_ids: 공고 식별자 목록&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;p>이 시스템은 &lt;strong>원시 데이터&lt;/strong>와 &lt;strong>집계 결과 데이터&lt;/strong>를 다룬다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>원시 데이터&lt;/strong>&lt;/p>
&lt;p>로그 파일 등으로 저장된 가공되지 않은 데이터를 의미한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[AdClickEvent] ad001, 2021-01-01 00:00:01, user 1, 270.148.22.22, USA
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>위와 같은 데이터가 여러 애플리케이션 서버에 산재해있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>집계 결과 데이터&lt;/strong>&lt;/p>
&lt;p>공고 클릭 이벤트가 매분 집계된다고 가정한다면 아래처럼 표현될 수 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>ad_id&lt;/th>
&lt;th>click_minute&lt;/th>
&lt;th>count&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ad001&lt;/td>
&lt;td>202101010000&lt;/td>
&lt;td>5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ad001&lt;/td>
&lt;td>202101010001&lt;/td>
&lt;td>7&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>광고 필터링을 지원하기 위해 &lt;code>filter_id&lt;/code>를 추가하고 같은 &lt;code>ad_id&lt;/code>와 &lt;code>click_minute&lt;/code> 값을 갖는 레코드를 &lt;code>filter_id&lt;/code>가 가리키는 필터 적용 결과에 따라 집계하면 아래와 같은 결과가 만들어진다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>ad_id&lt;/th>
&lt;th>click_minute&lt;/th>
&lt;th>filter_id&lt;/th>
&lt;th>count&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ad001&lt;/td>
&lt;td>2021010000&lt;/td>
&lt;td>0012&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ad001&lt;/td>
&lt;td>2021010000&lt;/td>
&lt;td>0023&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ad001&lt;/td>
&lt;td>2021010001&lt;/td>
&lt;td>0012&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ad001&lt;/td>
&lt;td>2021010001&lt;/td>
&lt;td>0023&lt;/td>
&lt;td>6&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>filter_id&lt;/th>
&lt;th>region&lt;/th>
&lt;th>ip&lt;/th>
&lt;th>user_id&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0012&lt;/td>
&lt;td>US&lt;/td>
&lt;td>0012&lt;/td>
&lt;td>*&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0013&lt;/td>
&lt;td>*&lt;/td>
&lt;td>0023&lt;/td>
&lt;td>123.1.2.3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>지난 M분 동안 가장 많이 클릭된 상위 N개의 광고를 반환하는 질의를 지원하기 위해서는 다음 구조를 사용한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">erDiagram
most_clicked_ads {
window_size integer
update_time_minute timestamp
most_clicked_ads array
}
&lt;/pre>
&lt;hr>
&lt;p>&lt;strong>비교&lt;/strong>&lt;/p>
&lt;p>원시 데이터를 저장하는 방안과 집계 결과 데이터만 보관하는 방안의 장점을 비교해보면 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>원시 데이터만 보관하는 방안
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>원본 데이터를 손실 없이 보관&lt;/li>
&lt;li>데이터 필터링 및 재계산 지원&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>막대한 데이터 용량&lt;/li>
&lt;li>낮은 질의 성능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>집계 결과 데이터만 보관하는 방안
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>데이터 용량 절감&lt;/li>
&lt;li>빠른 질의 기능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>데이터 손실
&lt;ul>
&lt;li>원본 데이터가 아닌 계산/유도된 데이터를 저정하는 데서 오는 결과임&lt;/li>
&lt;li>예시 &amp;gt; 10개의 원본 데이터는 1개의 집계 결과로 축약된다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>원시 데이터와 집계 결과 데이터의 특성으로 인해 모두 저장하는 것이 바람직하다.&lt;/p>
&lt;ul>
&lt;li>문제가 발생하면 디버깅에 활용할 수 있도록 원시 데이터도 보관하는 것이 좋다.
&lt;ul>
&lt;li>데이터가 손상되면 버그 수정 후에 원시 데이터에서 집계 결과를 다시 만들 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>원시 데이터는 양이 엄청나므로 직접 질의하는 것은 비효율적이다.
&lt;ul>
&lt;li>집계 결과 데이터를 질의한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>원시 데이터는 백업 데이터로 활용할 수 있다.
&lt;ul>
&lt;li>재계산을 하는 경우가 아니라면 굳이 원시 데이터를 질의할 필요는 없다.&lt;/li>
&lt;li>오래된 원시 데이터는 cold storage로 옮기면 비용을 절감할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>집계 결과 데이터는 활성 데이터 구실을 한다.
&lt;ul>
&lt;li>질의 성능을 높이기 위해 튜닝하는 것이 일반적이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="올바른-데이터베이스-선택">올바른 데이터베이스 선택&lt;/h3>
&lt;p>올바른 데이터베이스를 선택하기 위해 여러 사항을 고려해야한다.&lt;/p>
&lt;ul>
&lt;li>데이터는 어떤 모습인가?
&lt;ul>
&lt;li>관계형 데이터?, 문서 데이터?, 이진 대형 객체(BLOB)?&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작업 흐름이 읽기 중심인가 쓰기 중심인가?(아님 둘다?)&lt;/li>
&lt;li>트랜잭션을 지원해야 하는가?&lt;/li>
&lt;li>질의 과정에서 SUM, COUNT 같은 온라인 분석 처리 함수를 많이 활용해야 하는가?&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>원시 데이터&lt;/strong>&lt;/p>
&lt;p>일상적인 작업을 위해서라면 질의할 필요가 없지만, 데이터 과학자나 기계 학습 엔지니어가 연구등으로 활용될 수 있다.&lt;/p>
&lt;ul>
&lt;li>이 설계안이 다루는 시스템에서 발생하는 평균 쓰기 QPS는 10,000, 최대 50,000 이므로 &lt;strong>쓰기 중심 시스템&lt;/strong>이라고 볼 수 있다.&lt;/li>
&lt;li>원시 데이터는 백업과 재계산 용도로 활용하므로 읽기 연산 빈도는 낮다.&lt;/li>
&lt;/ul>
&lt;p>관계형 데이터베이스도 활용 가능하지만 큰 규모의 쓰기 연산이 가능하도록 구성하기 매우 어려우므로, 쓰기 및 시간 범위 질의에 최적화된 카산드라나 InfluxDB를 사용하는 것이 좀 더 바람직하다.&lt;/p>
&lt;ul>
&lt;li>칼럼형(columnar) 데이터 형식 가운데 하나를 사용하여 아마존 S3에 데이터를 저장하는 방법도 고려할 수 있다.
&lt;ul>
&lt;li>ORC, 파케이(Parquet), AVRO&lt;/li>
&lt;li>각 파일의 최대 크기를 제한하면 원시 데이터 기록 담당 스트림 프로세서가 새 파일을 만든다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>집계 데이터&lt;/strong>&lt;/p>
&lt;p>집계 데이터는 본질적으로 시계열 데이터이며, 이 데이터를 처리하는 워크 플로는 읽기 연산과 쓰기 연산 둘 다 많이 사용한다.&lt;/p>
&lt;p>집계 서비스가 데이터를 매 분 집계하고 그 결과 데이터를 저장하는 데는 같은 유형의 데이터베이스를 활용하는 것이 가능하다(카산드라).&lt;/p>
&lt;h3 id="개략적-설계안">개략적 설계안&lt;/h3>
&lt;p>실시간으로 빅데이터를 처리할 때 데이터는 보통 무제한으로 시스템에 흘러들어왔다가 나간다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart
subgraph 입력
logMonitor[로그모니터]
end
subgraph 프로세스
dataAgg[데이터 집계 서비스]
end
subgraph 출력
db[(데이터베이스)]
end
subgraph 표시
query[질의 서비스]
end
logMonitor --데이터 푸시--> dataAgg
dataAgg --광고 수--> db
dataAgg --가장 많이 클릭된 상위 100개 광고--> db
query --질의--> db
&lt;/pre>
&lt;hr>
&lt;p>&lt;strong>비동기 처리&lt;/strong>&lt;/p>
&lt;p>제시한 설계안은 동기식 처리를 기반으로 하지만, 생산자와 소비자의 용량이 항상 같을 수는 없기 때문에 좋지 않을 수 있다.&lt;/p>
&lt;ul>
&lt;li>트래픽이 갑자기 증가하여 발생하는 이벤트 수가 소비자의 처리 용량을 훨씬 넘어서는 경우 소비자는 메모리 부족 오류 등의 예기치 않은 문제를 겪게 될 수 있다.&lt;/li>
&lt;li>동기식 시스템의 경우 특정 컴포넌트의 장애는 전체 시스템의 장애로 이어진다.&lt;/li>
&lt;/ul>
&lt;p>이 문제를 해결하는 일반적인 방안은 카프카 같은 &lt;strong>메시지 큐를 도입하여 생산자와 소비자의 결함을 끊는 것&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>전체 프로세스가 비동기로 동작하게된다.&lt;/li>
&lt;li>비동기로 동작하므로 생산자와 소비자의 규모를 독립적으로 확장해 나갈 수 있게된다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img.png"
width="826"
height="468"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_hu308e0d8138a48f72649f62b8270e02b9_127555_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_hu308e0d8138a48f72649f62b8270e02b9_127555_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="176"
data-flex-basis="423px"
>&lt;/p>
&lt;p>로그 감시자, 집계 서비스, 데이터베이스는 두 개의 메시지 큐로 분리되어있다.&lt;/p>
&lt;p>데이터베이스 기록 프로세스는 메시지는 메시지 큐에서 데이터를 꺼내 데이터베이스가 지원하는 형식으로 변환 후 기록하는 역할을 수행한다.&lt;/p>
&lt;ul>
&lt;li>첫 번째 메시지 큐
&lt;ul>
&lt;li>광고 클릭 이벤트가 기록된다.&lt;/li>
&lt;li>ad_id, click_timestamp, user_id, ip, country&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>두 번째 메시지 큐
&lt;ul>
&lt;li>분 단위로 집게된 광고 클릭 수&lt;/li>
&lt;li>분 단위로 집계한, 가장 많이 클릭한 상위 N개 광고&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>집계 결과를 데이터베이스에 바로 기록하지 않는 이유는 정확하게 한 번(exactly once) 데이터를 처리하기 위해(atomic commit, 원자적 커밋) 카프카 같은 시스템을 두 번 째 메시지 큐로 도입해야 하기 때문이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_1.png"
width="805"
height="479"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_1_hu1c9282359cbbacf359a25482b125e71b_138566_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_1_hu1c9282359cbbacf359a25482b125e71b_138566_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="정확하게 한 번 처리하기 위한 메커니즘"
class="gallery-image"
data-flex-grow="168"
data-flex-basis="403px"
>&lt;/p>
&lt;h3 id="집계-서비스">집계 서비스&lt;/h3>
&lt;p>광고 클릭 이벤트를 집계하는 좋은 방안 하나는 &lt;strong>맵리듀스&lt;/strong>(MapReduce) 프레임워크를 사용하는 것 이다.&lt;/p>
&lt;p>맵리듀스 프레임워크에 좋은 모델은 유향 비순환 그래프(DAG) 모델이며, 시스템을 맵/집계/리듀스 노드 드으이 작은 컴퓨팅 단위로 세분화 할 수 있다.&lt;/p>
&lt;ul>
&lt;li>각 노드는 한 가지 작업만 처리하며, 처리 결과를 다음 노드에 인계한다.&lt;/li>
&lt;/ul>
&lt;pre class="mermaid" style="text-align: center;">flowchart LR
data --데이터 입력-->
Map((Map)) --ad_id % 2 = 0--> node1((집계 노드 1))
Map --ad_id % 2 = 1--> node2((집계 노드 2))
&lt;/pre>
&lt;hr>
&lt;p>&lt;strong>맵 노드&lt;/strong>&lt;/p>
&lt;p>맵 노드는 데이터 출처에서 읽은 데이터를 필터링하고 변환하는 역할을 담당한다.&lt;/p>
&lt;ul>
&lt;li>카프카 파티션이나 태그를 구성한 후 집계 노드가 카프카를 직접 구독하도록 할 경우 맵 노드를 활용하지 않을 수 있지만, 입력 데이터를 정리하거나 정규화해야 하는 경우에는 맵 노드가 필요하다.&lt;/li>
&lt;li>데이터가 생성되는 방식에 대한 제어권이 없는 경우 동일한 ad_id를 갖는 이벤트가 서로 다른 카프카 파티션에 입력될 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>집계 노드&lt;/strong>&lt;/p>
&lt;p>집계 노드는 ad_id 별 광고 클릭 이벤트 수를 매 분 메모리에서 집계한다.&lt;/p>
&lt;p>맵리듀스 패러다임에서 사실 집계 노드는 리듀스 프로세스의 일부여서, &lt;strong>맵-집계-리듀스&lt;/strong> 프로세스는 &lt;strong>맵-리듀스-리듀스&lt;/strong> 프로세스라고도 할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>리듀스 노드&lt;/strong>&lt;/p>
&lt;p>리듀스 노드는 모든 집계 노드가 산출한 결과를 최종 결과로 축약한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_2.png"
width="664"
height="314"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_2_hu4f114adc039c7d0d8d1bf45626dddb0d_89514_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_2_hu4f114adc039c7d0d8d1bf45626dddb0d_89514_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="리듀스 노드"
class="gallery-image"
data-flex-grow="211"
data-flex-basis="507px"
>&lt;/p>
&lt;p>DAG는 맵리듀스 패러다임을 표현하기 위한 모델로, 빅데이터를 입력으로 받아 병렬 분산 컴퓨팅 자원을 활용하여 빅데이터를 작은(일반적) 크기 데이터로 변환할 수 있도록 설계된 모델이다.&lt;/p>
&lt;p>중간 데이터는 메모리에 저장될 수 있으며, 노드 간 통신은 서로 다른 프로세스에서 실행되는 경우 TCP, 서로 다른 스레드에서 실해오디는 경우 공유 메모리로 처리할 수도 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>주요 사용 사례&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>클릭 이벤트 수 집계
&lt;ul>
&lt;li>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_3.png"
width="834"
height="332"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_3_hu15a9c90a865279d5a482021e1c73ca05_120267_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_3_hu15a9c90a865279d5a482021e1c73ca05_120267_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="클릭 이벤트 수 집계"
class="gallery-image"
data-flex-grow="251"
data-flex-basis="602px"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가장 많이 클릭된 상위 N개 광고 반환
&lt;ul>
&lt;li>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_4.png"
width="806"
height="453"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_4_hu9e0acdcb57074c8157c74737a33fe94e_193386_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_4_hu9e0acdcb57074c8157c74737a33fe94e_193386_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="가장 많이 클릭된 상위 N개 광고 반환"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="427px"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 필터링
&lt;ul>
&lt;li>필터링 기준을 사전에 정의한 후 해당 기준에 따라 집계한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>스타 스키마&lt;/strong>&lt;/p>
&lt;p>데이터 웨어하우스에서 널리 쓰이는 기법으로, 필터링에 사용되는 필드는 차원이라 부른다.&lt;/p>
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>이해하기 쉽고 구축하기 간단하다.&lt;/li>
&lt;li>기존 집계 서비스를 재사용하여 스타 스키마에 더 많은 차원을 생성할 수 있다. 다른 추가 컴포넌트는 필요없다.&lt;/li>
&lt;li>결과를 미리 계산해 두는 방식이므로, 필터링 기준에 따라 데이터에 빠르게 접근할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>많은 버킷과 레코드가 생성된다. (필터링 기준이 많을 경우 더더욱)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="스트리밍-vs-일괄-처리">스트리밍 vs 일괄 처리&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>서비스(온라인 시스템)&lt;/th>
&lt;th>일괄 처리 시스템(오프라인 시스템)&lt;/th>
&lt;th>스트리밍 처리 시스템(실시간에 가깝게 처리하는 시스템)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>응답성&lt;/td>
&lt;td>클라이언트에게 빠르게 응답&lt;/td>
&lt;td>클라이언트에게 응답할 필요가 없음&lt;/td>
&lt;td>클라이언트에게 응답할 필요가 없음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>입력&lt;/td>
&lt;td>사용자의 요청&lt;/td>
&lt;td>유한한 크기를 갖는 입력. 큰 규모의 데이터&lt;/td>
&lt;td>입력에 경계가 없음(무한 스트림)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>출력&lt;/td>
&lt;td>클라이언트에 대한 응답&lt;/td>
&lt;td>구체화 뷰, 집계 결과 지표 등&lt;/td>
&lt;td>구체화 뷰, 집계 결과 지표 등&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>성능 측정 기준&lt;/td>
&lt;td>가용성, 지연 시간&lt;/td>
&lt;td>처리량&lt;/td>
&lt;td>처리량, 지연 시간&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사례&lt;/td>
&lt;td>온라인 쇼핑&lt;/td>
&lt;td>맵리듀스&lt;/td>
&lt;td>플링크&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>본 설계안은 스트림 처리와 일괄 처리 방식을 모두 사용한다.&lt;/p>
&lt;ul>
&lt;li>스트림 처리는 데이터를 오는 대로 처리하고 거의 실시간으로 집계된 결과를 생성하는 데 사용한다.&lt;/li>
&lt;li>일괄 처리는 이력 데이터를 백업하기 위해 활용한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_5.png"
width="874"
height="648"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_5_huc5dc5bec0ac92440f8db6a7292969bc9_305717_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_5_huc5dc5bec0ac92440f8db6a7292969bc9_305717_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="람다, 카파 아키첵처"
class="gallery-image"
data-flex-grow="134"
data-flex-basis="323px"
>&lt;/p>
&lt;p>&lt;strong>람다 아키텍처&lt;/strong>&lt;/p>
&lt;p>일괄 및 스트리밍 처리 경로를 동시에 지원하는 시스템의 아키텍처를 람다(lambda)라고 부른다.&lt;/p>
&lt;p>람다 아키텍처의 단점은 두 가지 처리 경로를 지원하므로 유지 관리 해야할 코드가 두 벌이라는 점이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>카파 아키텍처&lt;/strong>&lt;/p>
&lt;p>카파 아키텍처(Kappa architecture)는 일괄 처리와 스트리밍 처리 경로를 하나로 결합하여 람다 아키텍처의 단점을 해결한다.&lt;/p>
&lt;p>핵심 아이디어는 단일 스트림 처리 엔진을 사용하여 실시간 데이터 처리 및 끊임없는 데이터 재처리 문제를 모두 해결하는 것이다.&lt;/p>
&lt;hr>
&lt;p>본 시스템의 개략적 설계안은 카파 아키텍처를 따른다. 따라서 이력 데이터의 재처리도 실시간 집계 서비스를 거치게된다.&lt;/p>
&lt;h3 id="데이터-재계산">데이터 재계산&lt;/h3>
&lt;p>이미 집계한 데이터를 다시 계산해야 하는 경우가 있는데, 이를 &lt;strong>이력 데이터 재처리&lt;/strong>(historical data replay)라고도 부른다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_6.png"
width="846"
height="274"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_6_hu3a7f884ae78691745bb1093350943e0b_109182_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_6_hu3a7f884ae78691745bb1093350943e0b_109182_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="재계산 서비스"
class="gallery-image"
data-flex-grow="308"
data-flex-basis="741px"
>&lt;/p>
&lt;ol>
&lt;li>원시 데이터 저장소에서 데이터를 검색한다.&lt;/li>
&lt;li>추출된 데이터를 전용 집계 서비스로 전송한다.
&lt;ul>
&lt;li>전용 집계 서비스는 실시간 데이터 처리 과정이 과거 데이터 재처리 프로세스와 간섭하는 일을 막기 위해 추가한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>집계 결과는 두 번째 메시지 큐로 전송되어 집계 결과 데이터베이스에 반영된다.&lt;/li>
&lt;/ol>
&lt;p>재계산 프로세스는 데이터 집계 서비스를 재사용하기는 하지만 처리 대상 데이터는 다른 곳에서 읽는다(원시 데이터).&lt;/p>
&lt;h3 id="시간">시간&lt;/h3>
&lt;p>집계를 하려면 타임스탬프가 필요한데, 타임 스탬프는 두 가지 다른 위치에서 만들어질 수 있다.&lt;/p>
&lt;ul>
&lt;li>이벤트 시각: 광고 클릭이 발생한 시각&lt;/li>
&lt;li>처리 시각: 집계 서버가 이벤트를 처리한 시스템 시각&lt;/li>
&lt;/ul>
&lt;p>네트워크 지연이나 비동기 처리 환경(데이터가 메시지 큐를 거쳐야 하는 환경)때문에 이벤트가 발생한 시각과 처리 시각 사이의 간격이 커질 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_7.png"
width="669"
height="188"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_7_huf8002690287510900e2c2679f234f3b3_47016_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_7_huf8002690287510900e2c2679f234f3b3_47016_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="늦게 도착한 이벤트"
class="gallery-image"
data-flex-grow="355"
data-flex-basis="854px"
>&lt;/p>
&lt;p>이벤트가 발생한 시각을 집계에 사용하는 경우 지연된 이벤트 처리 문제를 잘 해결해야 하며, 처리 시각을 집계에 사용하는 경우 집계 결과가 부정확할 수 있다는 점을 고려해야 한다.&lt;/p>
&lt;p>완벽한 솔루션은 없으므로, 두 방은의 장단점을 고려하여 적절한 결정을 내린다.&lt;/p>
&lt;ul>
&lt;li>이벤트 발생 시각
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>광고 클릭 시점을 정확히 아는 것은 클라이언트이므로 집계 결과가 보다 정확&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>클라이언트가 생성한 타임스탬프에 의존하는 방식이므로 클라이언트에 설정된 시각이 잘못 되었거나 악성 사용자가 타임스탬프를 고의로 조작하는 문제에서 자유로울 수 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>처리 시각
&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>서버 타임스탬프가 클라이언트 타임스탬프보다 안정적&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>이벤트가 시스템에 도착한 시각이 함참 뒤인 경우에는 집계 결과가 부정확해짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>데이터 정확도는 아주 중요하므로, 이벤트 발생 시각을 사용할 것을 추천한다.&lt;/p>
&lt;p>이러한 경우 시스템에 늦게 도착한 이벤트를 올바르게 처리하기 위해 &lt;strong>워터마크&lt;/strong>(watermark)라는 기술이 일반적으로 사용된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_8.png"
width="783"
height="245"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_8_huba72022b748b87378d5ddc854e8995cd_104439_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_8_huba72022b748b87378d5ddc854e8995cd_104439_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="집계 윈도에 누락되는 이벤트"
class="gallery-image"
data-flex-grow="319"
data-flex-basis="767px"
>&lt;/p>
&lt;p>이벤트 발생 시각을 기준으로 이벤트가 어떤 윈도에 속하는지 결정하면 이벤트가 집계 윈도가 끝나는 시점보다 살짝 늦게 도착하게되는 경우 집계에 실패하게된다.&lt;/p>
&lt;p>워터마크는 집계 윈도를 확장하여 집계 정확도를 높힐 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_9.png"
width="782"
height="236"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_9_huaa56781eaf1b8e81055800fd2830b619_103298_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_9_huaa56781eaf1b8e81055800fd2830b619_103298_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="워터마크"
class="gallery-image"
data-flex-grow="331"
data-flex-basis="795px"
>&lt;/p>
&lt;p>15초 워터마크를 윈도 마다 붙이면 윈도 1, 3이 누락된 이벤트를 집계할 수 있게 된다.&lt;/p>
&lt;p>워터마크의 크기는 비즈니스 요구사항에 따라 달리 잡는다.&lt;/p>
&lt;ul>
&lt;li>워터마크 구간이 길면 늦게 도착하는 이벤트도 포착할 수 있지만 시스템의 이벤트 처리 시간은 늘어난다.&lt;/li>
&lt;li>짧으면 데이터 정확도는 떨어지지만 시스템의 응답 지연은 낮아진다.&lt;/li>
&lt;/ul>
&lt;p>워터마크를 사용하더라도 시간이 한참 흐른 후에 시스템에 도달하는 이벤트는 처리할 수 없다.&lt;/p>
&lt;p>발생할 확률이 낮은 이벤트 처리를 위해 시스템을 복잡하게 설계하면 투자 대비 효능(ROI)는 떨어지고, 사소한 데이터 오류는 하루치 데이터 처리를 마감할 때 조정할 수 있으므로 워터마크 구간을 길게 가져갈 이유는 없다.&lt;/p>
&lt;h3 id="집계-윈도">집계 윈도&lt;/h3>
&lt;p>윈도에는 텀블링 윈도(tumbling window, 고정 윈도(fixed window) 라고도 함), 호핑 윈도(hopping window), 슬라이딩 윈도(sliding window), 세션 윈도(session window) 총 네 종류가 있다.&lt;/p>
&lt;p>이 가운데 텀플링 윈도와 슬라이딩 윈도가 설계안과 관련있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>텀블링 윈도&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_10.png"
width="773"
height="183"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_10_huceeb3723b2780057ddaa40743569e45d_66924_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_10_huceeb3723b2780057ddaa40743569e45d_66924_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="텀블링 윈도"
class="gallery-image"
data-flex-grow="422"
data-flex-basis="1013px"
>&lt;/p>
&lt;p>시간을 같은 크기의 겹치지 않는 구간으로 분할하므로, 매 분 발생한 클릭 이벤트를 집계하기 적합하다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>슬라이딩 윈도&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_11.png"
width="795"
height="185"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_11_hu9468ea01e7b032fc68b0427be3506431_67457_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_11_hu9468ea01e7b032fc68b0427be3506431_67457_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="슬라이딩 윈도"
class="gallery-image"
data-flex-grow="429"
data-flex-basis="1031px"
>&lt;/p>
&lt;p>데이터 스트림을 미끄러져 나아가면서 같은 시간 구간 안에 있는 이벤트를 집계한다. 슬라이딩 윈도는 서로 겹칠 수 있어 시스템의 두 번째 요구사항인 지난 M분간 가장 많이 클릭된 상위 N개 광고를 알아내기 적합하다.&lt;/p>
&lt;h3 id="전달-보장">전달 보장&lt;/h3>
&lt;p>집계 결과는 과금 등에 활용될 수 있기 때문에 데이터의 정확성과 무결성이 아주 중요하다.&lt;/p>
&lt;ul>
&lt;li>이벤트의 중보 처리를 어떻게 피할 수 있는가?&lt;/li>
&lt;li>모든 이벤트의 처리를 어떻게 보장할 수 있는가?&lt;/li>
&lt;/ul>
&lt;p>카프카와 같은 메시지 큐는 보통 최대 한 번, 최소 한 번, 정확히 한 번 총 세 가지 유형의 전달 방식을 지원한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>어떤 전달 방식을 택할 것 인가?&lt;/strong>&lt;/p>
&lt;p>약간의 중복이 괜찮다면 대체로 &lt;strong>최 소 한번&lt;/strong>이 적절하나, 본 설계안은 데이터의 몇 퍼센트 차이가 수백만 달러 차이로 이어질 수 있으므로 &lt;strong>정확히 한 번&lt;/strong>방식을 권장한다.&lt;/p>
&lt;p>&lt;strong>데이터 중복 제거&lt;/strong>&lt;/p>
&lt;p>가장 흔한 데이터 품질 이슈 가운데 하나는 중복된 데이터이다.&lt;/p>
&lt;ul>
&lt;li>클라이언트측
&lt;ul>
&lt;li>한 클라이언트가 같은 이벤트를 여러 번 보내는 경우&lt;/li>
&lt;li>악의적인 의도로 전송되는 중복 이벤트를 처리하는 데는 &lt;strong>광고 사기/위험 제어 컴포넌트&lt;/strong>(ad fraud/risk controller)가 적합하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서버 장애
&lt;ul>
&lt;li>집계 도중에 집계 서비스 노드에서 장애가 발생하였고, 업 스트림 서비스가 이벤트 메시지에 대해 응답을 받지 못한경우, 같은 이벤트가 다시 전송되어 재차 집계될 가능성이 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_12.png"
width="593"
height="468"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_12_huede191de92b81be00b9a3ae48a395ffa_158639_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_12_huede191de92b81be00b9a3ae48a395ffa_158639_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="중복 데이터"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="304px"
>&lt;/p>
&lt;p>집계 서비스 노드에 장애가 생겨 6단계를 실행하지 못하면 100에서 110 까지의 이벤트는 이비 다운 스트림에 전송되었으나 새 오프셋은 업스트림 카프카에 반영되지 않아, 새로 북고된 집계 서비스 노드는 오프셋 100부터 이벤트를 다시 소비하려고 할 것이다, 그 결과로 데이터 중복이 발생한다.&lt;/p>
&lt;p>이 문제의 간단한 해결책으로 HDFS나 S3 같은 외부 파일 저장소에 오프셋을 기록하는 방법이 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_13.png"
width="768"
height="529"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_13_hu6b78f3cdb30d0caba5a7a8cd6c6b715e_161577_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_13_hu6b78f3cdb30d0caba5a7a8cd6c6b715e_161577_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="오프셋 기록"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="348px"
>&lt;/p>
&lt;p>집계 결과를 다운 스트림으로 전송하기 전에 오프셋을 외부에 저장하고 있는데, 만일 그 직후 집계 서비스 노드에 장애가 발생하여 4단계를 완료하지 못했다면, 외부 저장소에 저장된 오프셋은 110이므로 복구된 집계 서비스 노드는 100부터 110 까지의 이벤트를 다시 처리하지 않는다.&lt;/p>
&lt;p>따라서 데이터 손실을 막으려면 다운스트림에서 집계 결과 수신 확인 응답을 받은 후에 오프셋을 저장해야 한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_14.png"
width="814"
height="573"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_14_hu2ab70a303052b4a2adad9c1e83700448_163160_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_14_hu2ab70a303052b4a2adad9c1e83700448_163160_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="수신 확인 후 오프셋 저장"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="340px"
>&lt;/p>
&lt;p>이벤트를 정확하게 한 번만 처리하고 싶다면 4단계부터 6단계가지의 작업을 하나의 분산 트랜잭션에 넣어야한다.&lt;/p>
&lt;p>분산 트랜잭션은 여러 노드에서 작동하는 트랜잭션으로 그 안에서 실행하는 작업 가운데 하나라도 실패하면 모든 작업의 상태를 실행 전으로 되돌린다.&lt;/p>
&lt;h3 id="시스템-규모-확장">시스템 규모 확장&lt;/h3>
&lt;p>본 설계안은 메시지 큐, 집계 서버, 데이터베이스의 세 가지 독립 구성 요소로 이루어져, 상호 결합도가 낮으므로 각기 독립적으로 규모를 늘릴 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>메시지 큐의 규모 확장&lt;/strong>&lt;/p>
&lt;p>메시지 큐의 규모 학장법에 대해서는 4장 분산 메시지 큐에서 광범위하게 설명했으므로 요점만 확인한다.&lt;/p>
&lt;ul>
&lt;li>생산자
&lt;ul>
&lt;li>생산자 인스턴스 수에는 제한을 두지 않으므로 따라서 확정성은 쉽게 달성할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>소비자
&lt;ul>
&lt;li>소비자 그룹 내의 재조정 매커니즘은 노드 추가/삭제를 통해 그 규모를 쉽게 조장할 수 있도록 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>수백 개 카프카 소비자가 있는 경우 재조정 작업 시간이 길어져서 수 분 이상 걸리게 될 수 있으므로 더 많은 소비자를 추가하는 작업은 시스템 사용량이 많지 않은 시간에 실행하여 영향을 최소화하는 것이 좋다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>브로커&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>해시 키
&lt;ul>
&lt;li>같은 ad_id를 갖는 이벤트를 같은 카프카 파티션에 저장하기 위해 ad_id를 해시 키로 사용한다.&lt;/li>
&lt;li>집계 서비스는 같은 ad_id를 갖는 이벤트를 전부 같은 파티션에서 구독할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파티션의 수
&lt;ul>
&lt;li>파티션의 수가 변하면 같은 ad_id르 ㄹ갖는 이벤트가 다른 파티션에 기록되는 일이 생길 수 있으므로 사전에 충분한 파티션을 확보하여 프로덕션 환경에서 파티션의 수가 동적으로 늘어나는 일을 피하는 것이 좋다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>토픽의 물리적 샤딩
&lt;ul>
&lt;li>하나의 토픽만으로 충분한 경우는 거의 없다.&lt;/li>
&lt;li>지역에 따라, 사업 유형에 따라 여러 토픽을 둘 수 있다.&lt;/li>
&lt;li>장점
&lt;ul>
&lt;li>데이터를 여러 토픽으로 나누면 시스템의 처리 대역폭을 높일 수 있다.&lt;/li>
&lt;li>단일 토픽에 대한 소비자의 수가 줄면 소비자 그룹의 재조정 시간도 단축된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>복잡성이 증가하고 유지 관리 비용이 늘어난다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>집게 서비스의 규모 확장&lt;/strong>&lt;/p>
&lt;p>집계 서비스는 본질적으로 맵리듀스 연산으로 구현된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_15.png"
width="849"
height="546"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_15_hu20e8fafda3109e5f006bddac6e6ffbd9_270584_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_15_hu20e8fafda3109e5f006bddac6e6ffbd9_270584_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="집계 서비스"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="373px"
>&lt;/p>
&lt;p>집계 서비스의 규모는 노드의 추가/삭제를 통해 수평적으로 조정이 가능하다.&lt;/p>
&lt;p>집계 서비스의 처리 대역폭을 높이는 방법으로 두 가지 선택지가 있다.&lt;/p>
&lt;ul>
&lt;li>ad_id마다 별도의 처리 스레드를 두는 방식
&lt;ul>
&lt;li>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_16.png"
width="778"
height="632"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_16_hu9240b727125146b5187adbdd80d812ee_164979_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_16_hu9240b727125146b5187adbdd80d812ee_164979_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="다중 스레드"
class="gallery-image"
data-flex-grow="123"
data-flex-basis="295px"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>집계 서비스 노드를 아파치 하둡 YARN 같은 자원 공급자에 배포하는 방식&lt;/li>
&lt;/ul>
&lt;p>두 가지 방안 중 첫 번째가 더 구현하기 쉽고, 자원 공급자에 대한 의존 관계도 없다.&lt;/p>
&lt;p>하지만, 더 많은 컴퓨팅 자원을 추가하여 시스템의 규모를 확장할 수 있는 두 번째 방안이 많이 활용된다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>데이터베이스의 규모 확장&lt;/strong>&lt;/p>
&lt;p>카산드라는 안정 해시와 유사한 방식으로 수평적인 규모 확장을 기본적으로 지원한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_17.png"
width="626"
height="613"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_17_hu5415acd9f61d814ec2621993794f7a7c_402592_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_17_hu5415acd9f61d814ec2621993794f7a7c_402592_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="가상 노드"
class="gallery-image"
data-flex-grow="102"
data-flex-basis="245px"
>&lt;/p>
&lt;h3 id="핫스팟-문제">핫스팟 문제&lt;/h3>
&lt;p>다른 서비스나 샤드보다 더 많은 데이터를 수신하는 서비스나 샤드를 핫스팟이라 부른다.&lt;/p>
&lt;p>광고 클릭 집계 시스템은 큰 회사가 큰 광고예산을 집행하여 더 많은 노출을 하게 만들수 있고, 이로 인해 특정 광고에 더 많은 클릭이 발생할 수 있다.&lt;/p>
&lt;p>이벤트 파티션을 ad_id로 나누기 때문에 어떤 집계 서비스 노드는 다른 노드보다 더 많은 광고 클릭 이벤트를 수신하게 될 것이고, 그러다보면 서버 과부하 문제가 발생할 수 있다.&lt;/p>
&lt;p>이러한 문제는 더 많은 집계 서비스 노드를 할당하여 완화할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_18.png"
width="824"
height="646"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_18_hu7889c8879218e6422a2a8525761062d5_152491_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_18_hu7889c8879218e6422a2a8525761062d5_152491_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="추가 집계 서비스 노드의 할당"
class="gallery-image"
data-flex-grow="127"
data-flex-basis="306px"
>&lt;/p>
&lt;ol>
&lt;li>집계 서비스 노드에 300개 이벤트가 도착하여 노드가 감당할 수 있는 양을 초과 하였기 때문에 자원 관리자에게 추가 자원을 신청한다.&lt;/li>
&lt;li>자원 관리자는 해당 서비스 노드에 과부하가 걸리지 않도록, 추가 자원을 할당한다.(예시는 두 개의 집계 서비스 노드)&lt;/li>
&lt;li>원래 집계 서비스 노드는 각 서비스 노드가 100개씩의 이벤트를 처리할 수 있도록 이벤트를 세 개 그룹으로 분할한다.&lt;/li>
&lt;li>집계가 끝나 축약된 결과는 다시 원래 집계 서비스 노드에 기록한다.&lt;/li>
&lt;/ol>
&lt;p>전역-지역 집계(Global-Local Aggregation)나 분할 고유 집계(Split Distinct Aggregation) 같은 복잡한 방법도 고려할 수 있다.&lt;/p>
&lt;h3 id="결함-내성">결함 내성&lt;/h3>
&lt;p>집게는 메모리에서 이루어지므로 집계 노드에 장애가 생기면 집계 결과도 손실된다.&lt;/p>
&lt;p>하지만 업스트림 카프카 브로커에서 이벤트를 다시 받아오면 그 숫자를 다시 만들어 낼 수 있다.&lt;/p>
&lt;p>카프카 데이터를 원점 주터 다시 재생하여 집계하면 시간이 오래 걸리므로, 업스트림 오프셋 같은 시스템 상태를 스냅숏으로 저장하고 마지막으로 저장된 상태부터 복구해 나가는 것이 바람직하다.&lt;/p>
&lt;ul>
&lt;li>시스템 상태에 해당하는 정보는 업스트림 오프셋 뿐만 아니라 지난 M분간 가장 많이 클릭된 광고 N개 같은 데이터도 시스템 상태의 일부로 저장한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_19.png"
width="764"
height="247"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_19_hua2281ddfd0fa3d6e52ee3d7483f287c2_75340_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_19_hua2281ddfd0fa3d6e52ee3d7483f287c2_75340_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="스냅솟 데이터"
class="gallery-image"
data-flex-grow="309"
data-flex-basis="742px"
>&lt;/p>
&lt;p>스냅숏을 이용하면 집계 서비스의 복구 절차가 단순해진다.&lt;/p>
&lt;p>어떤 집계 서비스 노드 하나에 장애가 발생하면 해당 노드를 새 것으로 대체한 다음 마지막 스냅숏에서 데이터를 복구하면 된다.&lt;/p>
&lt;h3 id="데이터-모니터링-및-정확성">데이터 모니터링 및 정확성&lt;/h3>
&lt;p>집계 결과는 RTB 및 청구서 발행 목적으로 사용될 수 있으므로ㅓ 시스템이 정상적으로 동작하는 지 모니터링 하고 데이터 정확성을 보장하는 것은 아주 중요한 과제이다.&lt;/p>
&lt;p>&lt;strong>지속적 모니터링&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>지연 시간
&lt;ul>
&lt;li>데이터를 처리하는 각 단계마다 지연 시간이 추가될 수 있으므로, 시스템의 중요 부분마다 시각 추적이 가능하도록 해야한다.&lt;/li>
&lt;li>기록된 사각 사이의 차이를 지연 시간 지표로 변환해서 모니터링한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메시지 큐 크기
&lt;ul>
&lt;li>큐의 크기가 갑자기 늘어난다면 더 많은 집계 서비스 노드를 추가해야 할 수 있다.&lt;/li>
&lt;li>카프카는 분산 커밋 로그 형태로 구현된 메시지 큐 이므로, 카프카를 사용하는 경우 레코드 처리 지연 지표를 대신 추적한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>집계 노드의 시스템 자원
&lt;ul>
&lt;li>CPU, 디스크, JVM 같은 것에 관계된 지표&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>조정&lt;/strong>&lt;/p>
&lt;p>조정(reconciliation)은 다양한 데이터를 비교하여 데이터 무결성을 보증하는 기법을 일컫는다.&lt;/p>
&lt;p>광고 클릭 집게 결과는 비교할 제 3자가 없으므로 매일 각 파이션에 기록된 클릭 이벤트를 이벤트 발생 시각에 따라 정렬한 결과를 일괄 처리하여 만들어낸 후, 실시간 집계 결과와 비교해 볼 수 있다.&lt;/p>
&lt;ul>
&lt;li>더 높은 정확도가 필요하다면 더작은 집계 작은 집계 윈도를 사용한다.&lt;/li>
&lt;li>윈도 크기와 관계 없이 일부 이벤트는 늦게 도착할 수 있으므로 배치 작업 결과가 실시간 집계 결과와 정확히 일치하지 않을 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_20.png"
width="833"
height="346"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_20_hub35bf4c448d6cf0170ffb4ecf93d6924_122803_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_20_hub35bf4c448d6cf0170ffb4ecf93d6924_122803_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="최종 설계안"
class="gallery-image"
data-flex-grow="240"
data-flex-basis="577px"
>&lt;/p>
&lt;h3 id="대안적-설계안">대안적 설계안&lt;/h3>
&lt;p>다른 한 가지 가능한 설계안은 광고 클릭 데이터를 하이브에 저장한 다음 빠른 질의는 일래스틱서치 계층을 얹어서 처리할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/6/img_21.png"
width="833"
height="286"
srcset="https://codemario318.github.io/post/system-design-interview-2/6/img_21_hu8585af607f9fff0160c43d5a0ee15e53_80257_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/6/img_21_hu8585af607f9fff0160c43d5a0ee15e53_80257_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="img_21.png"
class="gallery-image"
data-flex-grow="291"
data-flex-basis="699px"
>&lt;/p>
&lt;p>집계는 클릭하우스, 드루이드 같은 OLAP 데이터베이스를 통해 처리할 수 있다.&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>이번 장에서는 페이스북이나 구글 규모의 광고 클릭 이벤트 집계 시스템을 설계하는 프로세스를 다루어 보았다.&lt;/p>
&lt;ul>
&lt;li>데이터 모델 및 API 설계&lt;/li>
&lt;li>맵리듀스 데이터 처리 패러다임을 통해 광고 클릭 이벤트를 집계하는 방법&lt;/li>
&lt;li>메시지 큐, 집계 서비스, 데이터베이스의 규모 확장 방안&lt;/li>
&lt;li>핫스팟 문제를 해결하는 방안&lt;/li>
&lt;li>시스템의 지속적 모니터링&lt;/li>
&lt;li>데이터 조정을 통한 정확성 보증 방안&lt;/li>
&lt;li>결함 내성&lt;/li>
&lt;/ul>
&lt;p>광고 클릭 이벤트 집계 시스템은 전형적인 빅데이터 처리 시스템이다.&lt;/p>
&lt;p>아파치 카프카, 아파치 플링크, 아파치 스파크 같은 업계 표준 솔루션에 대한 사전 지식이나 경험이 있다면 이해하고 설계하기 쉬울 것이다.&lt;/p></description></item><item><title>3. 구글 맵</title><link>https://codemario318.github.io/post/system-design-interview-2/3/</link><pubDate>Sat, 24 Aug 2024 16:38:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview-2/3/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/cover.png" alt="Featured image of post 3. 구글 맵" />&lt;p>구글 맵은 위성 이미지, 거리 뷰, 실시간 교통 상항, 경로 계획 등 다양한 서비스를 제공하고 있다.&lt;/p>
&lt;p>엄청나게 복잡한 제품이므로, 설계에 앞서 어떤 기능에 초점을 맞추어야 하는지 확인해야 한다.&lt;/p>
&lt;h2 id="1단계-문제-이해-및-설계-범위-확정">1단계: 문제 이해 및 설계 범위 확정&lt;/h2>
&lt;ul>
&lt;li>Q. 일간 능동 사용자 수는?
&lt;ul>
&lt;li>A. 10억 DAU&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 초점을 두어야하는 기능은?
&lt;ul>
&lt;li>A. 위치 갱신, 경로 안내, ETA, 지도 표시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 도로 데이터는 어느정도, 데이터는 확보 되었다고 가정?
&lt;ul>
&lt;li>A. 도로 데이터는 다양한 결로로 확보해 두었다고 가정, 수 TB 수준의 가공되지 않은 데이터&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 교통 상황도 고려해야하는가?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 여러 이동 수단 고려?
&lt;ul>
&lt;li>A. Y&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 경유지 선택 가능?
&lt;ul>
&lt;li>A. N&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Q. 사업장 정보도 포함?
&lt;ul>
&lt;li>A. N&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="기능-요구사항">기능 요구사항&lt;/h3>
&lt;p>이번 장에서는 3가지 기능에 집중 할 것이며, 지원할 주 단말은 스마트폰이다.&lt;/p>
&lt;ul>
&lt;li>사용자 위치 갱신&lt;/li>
&lt;li>경로 안내 서비스(ETA 포함)&lt;/li>
&lt;li>지도 표시&lt;/li>
&lt;/ul>
&lt;h3 id="비기능-요구사항-및-제약사항">비기능 요구사항 및 제약사항&lt;/h3>
&lt;ul>
&lt;li>정확도
&lt;ul>
&lt;li>사용자에게 잘못된 경로를 안내하면 안됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>부드러운 경로 표시
&lt;ul>
&lt;li>제공되는 경로는 화면에 부드럽게 표시되고 갱신되어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 및 배터리 사용량
&lt;ul>
&lt;li>클라이언트가 최소한의 데이터와 배터리를 사용해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>일반적으로 널리 통용되는 가용성 및 규모 확장성 요구사항을 만족해야함&lt;/li>
&lt;/ul>
&lt;h3 id="지도-101">지도 101&lt;/h3>
&lt;p>&lt;strong>측위 시스템&lt;/strong>&lt;/p>
&lt;p>측위 시스템은 구 표면상의 위치를 표현하는 체계를 말한다.&lt;/p>
&lt;p>위경도 기반 측위 시스템의 경우, 최상단에는 북극이 있고 최하단에는 남극이 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img.png"
width="469"
height="460"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_hu4ecfd35b0eaef394414174e94c849f4b_312747_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_hu4ecfd35b0eaef394414174e94c849f4b_312747_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="위도와 경도"
class="gallery-image"
data-flex-grow="101"
data-flex-basis="244px"
>&lt;/p>
&lt;ul>
&lt;li>위도(Latitude, Lat.)
&lt;ul>
&lt;li>주어진 위치가 얼마나 남/북쪽인지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>경도(Longitude)
&lt;ul>
&lt;li>얼마나 동/서 쪽인지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>3차원 위치를 2차원 변환&lt;/strong>&lt;/p>
&lt;p>3차원 구 위의 위치를 2차원 평면에 대응시키는 절차를 &lt;strong>지도 투영법&lt;/strong>(map projection)또는 &lt;strong>도법&lt;/strong>이라 부른다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_1.png"
width="1920"
height="1108"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_1_hu6679b85ef3a54a92f40f68b74cd7f354_2863712_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_1_hu6679b85ef3a54a92f40f68b74cd7f354_2863712_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="지도 투영법 사이의 차이점"
class="gallery-image"
data-flex-grow="173"
data-flex-basis="415px"
>&lt;/p>
&lt;p>여러 도법이 있으며 각각 차별되는 장점이 있으나 공통적으로 실제 지형의 기하학적 틍성을 왜곡한다는 공통점을 갖는다.&lt;/p>
&lt;p>구글 맵은 메르카토르 도법을 조금 변경한 &lt;strong>웹 메르카토르&lt;/strong>(WebMercator) 도법을 사용한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>지오코딩&lt;/strong>&lt;/p>
&lt;p>지오코딩은 주소를 지리적 측위 시스템의 좌표로 변환하는 프로세스이다.&lt;/p>
&lt;p>지오 코딩을 수행하는 한 가지 방법은 GIS와 같은 다양한 시스템이 제공하는 데이터를 결합하는 인터폴레이션(interpolation)이 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>GIS - Geographic Information System&lt;/strong>&lt;br>
도로망을 지리적 좌표 공간에 대응시키는 방법을 제공하는 시스템들 중 하나&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>&lt;strong>지오해싱&lt;/strong>&lt;/p>
&lt;p>지도 위 특정 영역을 영문자와 숫자로 구성된 짧은 문자열에 대응시키는 인코딩 체계이다.&lt;/p>
&lt;p>2차원의 평면 공간으로 표현된 지리적 영역 위의 격자를 더 작은 격자로 재귀적으로 분할해나간다.&lt;/p>
&lt;ul>
&lt;li>각 격자는 정사각형, 사각형 일 수 있다.&lt;/li>
&lt;/ul>
&lt;p>격자를 재귀적으로 분할한 결과로 생성된 더 작은 격자에는 0~3의 번호를 부여한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_2.png"
width="623"
height="365"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_2_hue1d5f8bcb8e879d614ad41727ff0e80a_250766_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_2_hue1d5f8bcb8e879d614ad41727ff0e80a_250766_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="지오해싱"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="409px"
>&lt;/p>
&lt;p>이번 설계에서는 &lt;strong>맵 타일&lt;/strong>관리를 위해 지오해싱을 활용한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>지도 표시&lt;/strong>&lt;/p>
&lt;p>지도를 화면에 표시하는 데 가장 기본이 되는 개념은 &lt;strong>타일&lt;/strong>(Tile)이다.&lt;/p>
&lt;ul>
&lt;li>지도 전부를 하나의 이미지로 표시하는 대신, 작은 타일로 쪼개어 표현한다.&lt;/li>
&lt;li>클라이언트는 보려는 영역에 관계된 타일만 다운받아 모자이크처럼 이어 붙인 다음 화면에 뿌린다.&lt;/li>
&lt;/ul>
&lt;p>확대/축소를 지원하기 위해 확대 수준에 따라 다른 종류의 타일을 준비한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>경로 안내 알고리즘을 위한 도로 데이터 처리&lt;/strong>&lt;/p>
&lt;p>대부분의 경로 탐색 알고리즘은 &lt;strong>데이크스트라 알고리즘&lt;/strong>이나 &lt;strong>A* 알고리즘&lt;/strong>의 변종이다.(그래프 기반 최단거리 탐색)&lt;/p>
&lt;p>따라서 모든 경로 탐색 알고리즘은 교차로를 노드, 도로를 간선으로 표현하는 그래프 자료 구조를 가정한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_3.png"
width="1400"
height="639"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_3_hu7451bd66519cb9a67ca931e55612e325_1658967_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_3_hu7451bd66519cb9a67ca931e55612e325_1658967_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="그래프로 표현한 지도"
class="gallery-image"
data-flex-grow="219"
data-flex-basis="525px"
>&lt;/p>
&lt;p>대부분 경로 탐색 알고리즘은 주어진 그래프 크기에 성능이 좌우된다.&lt;/p>
&lt;p>따라서 성능을 위해 전 세계 도로망을 하나의 그래프로 표현하는 것이 아닌 &lt;strong>관리 가능 단위로 분할&lt;/strong>해야한다.&lt;/p>
&lt;p>타일 기반 분할법을 적용하여 세계를 작은 격자로 나누고, 각 격자 안의 도로망을 노드와 간선으로 구성된 그래프 자료구조로 변환한다.&lt;/p>
&lt;ul>
&lt;li>경로 안내 타일로 분할한다.&lt;/li>
&lt;li>각 타일은 도로로 연결된 다른 타일에 대한 참조를 유지한다.&lt;/li>
&lt;/ul>
&lt;p>도로망을 언제든 불러올 수 있는 경로 안내 타일로 분할해 놓으면 여러 장점이 있다.&lt;/p>
&lt;ul>
&lt;li>경로 탐색 알고리즘이 동ㅈ가하는 데 필요한 메모리 요구량을 낮출 수 있다.&lt;/li>
&lt;li>한 번에 처리해야 하는 경로의 양이 준다.&lt;/li>
&lt;li>필요한 만큼 만 불러오면 되므로 경로 탐색 성능도 좋아진다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>경로 안내 타일은 지도와 다르게 도로 데이터로 이루어진 이진 파일(binary file)이다.&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>&lt;strong>계층적 경로 안내 타일&lt;/strong>&lt;/p>
&lt;p>경로 안내가 효과적으로 동작하려면 &lt;strong>필요한 수준의 구체성&lt;/strong>을 갖춘 도로 데이터가 필요하다.&lt;/p>
&lt;p>보통 구체성 정도를 상, 중, 하로 구분하여 세 가지 종류의 경로 안내 타일을 준비한다.&lt;/p>
&lt;ul>
&lt;li>상
&lt;ul>
&lt;li>지방도(local roads) 데이터를 둔다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>중
&lt;ul>
&lt;li>규모가 비교적 큰 관할구(district)를 잇는 간선 도로 데이터를 둔다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>하
&lt;ul>
&lt;li>도시와 주를 연결하는 주요 고속도로 데이터만 둔다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_4.png"
width="1109"
height="910"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_4_hu07eab4d6f4ef51d47536904f92e584d5_498010_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_4_hu07eab4d6f4ef51d47536904f92e584d5_498010_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="크기가 서로 다른 경로 안내 타일"
class="gallery-image"
data-flex-grow="121"
data-flex-basis="292px"
>&lt;/p>
&lt;h3 id="개략적-규모-추정">개략적 규모 추정&lt;/h3>
&lt;p>설계 초점이 모바일 단말이므로, 데이터 사용량과 배터리 효율을 중요하게 따져 봐야 한다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>저장소 사용량 - 세계 지도&lt;/strong>&lt;/p>
&lt;p>지원하는 확대 수준(Zoom level)별로 지도 타일을 한 벌씩 두어야 한다.&lt;/p>
&lt;p>지도를 확대할 때 마다 하나의 타일을 네 장의 타일로 펼친다고 가정하면, 세계 지도를 21번 확대하여 볼 수 있으려면 최대 확대 수준을 대산으로 하였을 때 약 &lt;strong>4.4조&lt;/strong>개의 타일이 필요하다.&lt;/p>
&lt;ul>
&lt;li>한 장의 타일이 &lt;code>256 * 256&lt;/code> PNG 파일이라면 장당 100KB의 저장 공간이 필요하므로 440PB 만큼의 저장 공간이 필요하다.&lt;/li>
&lt;/ul>
&lt;p>하지만 지구 표면 가운데 90%는 인간이 살지 않는 자연 그대로의 바다, 사막, 호수, 산간 지역이라 아주 높은 비유롤 압축할 수 있다.&lt;/p>
&lt;p>보수적으로 80% ~ 90% 저장 용량을 절감할 수 있다고 가정하면, 50PB 정도 필요하다.&lt;/p>
&lt;p>1 ~ 21 까지 수준을 지원하기 위해 &lt;code>50 + (50/4) + (50/16) ... = ~ 67PB&lt;/code> 정도로 대충 100PB 정도가 소요된다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>서버 대역폭&lt;/strong>&lt;/p>
&lt;p>서버 대역폭을 추정하기 위해서는 어떤 유형의 요청을 처리해야 하는지 살펴 봐야 한다.&lt;/p>
&lt;ul>
&lt;li>경로 안내 요청
&lt;ul>
&lt;li>클라이언트가 경로 안내 세션을 시작할 때 전송하는 메시지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>위치 갱신 요청
&lt;ul>
&lt;li>클라이언트가 경로 안내를 진행하는 동안 변경된 사용자 위치를 전송하는 메시지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>경로 안내 요청을 처리하기 위한 대역폭을 계산해본다.&lt;/p>
&lt;ul>
&lt;li>DAU 10억, 평균 주당 35분 사용한다고 가정
&lt;ul>
&lt;li>하루에 50억 분&lt;/li>
&lt;li>요청을 클라이언트 쪽에 모아두었다가 덜 자주보내도록 하면 QPS를 낮출 수 있다.&lt;/li>
&lt;li>15초마다 한 번씩 보낸다고 가정하면 QPS는 20만&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계: 개략적 설계안 제시 및 동의 구하기&lt;/h2>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_5.png"
width="710"
height="489"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_5_hu4e7e3e07d71836bb687df78814d2fbb6_116709_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_5_hu4e7e3e07d71836bb687df78814d2fbb6_116709_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="개략적 설계안"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="348px"
>&lt;/p>
&lt;ul>
&lt;li>위치 서비스&lt;/li>
&lt;li>경로 안내 서비스&lt;/li>
&lt;li>지도 표시&lt;/li>
&lt;/ul>
&lt;h3 id="위치-서비스">위치 서비스&lt;/h3>
&lt;p>사용자의 위치를 기록하는 역할을 담당한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart TD
mobile([모바일 사용자]) -->
loadBalancer[로드밸런서] -->
location[위치 서비스] -->
db[(사용자 위치 DB)]
&lt;/pre>
&lt;p>클라이언트가 &lt;strong>t&lt;/strong>초마다 자기 위치를 전송한다고 가정하는데, 주기적으로 위치 정보를 전송하면 몇 가지 좋은 점이 있다.&lt;/p>
&lt;ul>
&lt;li>해당 데이터 스트림을 활용하여 시스템을 점차 개선할 수 있다.
&lt;ul>
&lt;li>실시간 교통 상황 모니터링&lt;/li>
&lt;li>새로 만들어진 도로나 폐쇄된 도로 탐지&lt;/li>
&lt;li>사용자 행동 양태를 분석하여 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클라이언트가 보내는 위치 정보가 실시간 정보에 가까우므로 ETA를 좀 더 정확하게 산출할 수 있다.
&lt;ul>
&lt;li>교통 상황에 따라 다른 경로를 안내할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위치 이력을 클라이언트에 버퍼링해 두었다가 일괄 요청하면 전송 빈도를 줄일 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_6.png"
width="768"
height="230"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_6_hu4c9106ced49971975257ab1b7be74bab_135532_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_6_hu4c9106ced49971975257ab1b7be74bab_135532_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="일괄 요청"
class="gallery-image"
data-flex-grow="333"
data-flex-basis="801px"
>&lt;/p>
&lt;p>위치 갱신 요청 빈도를 줄여도 여전히 많은 쓰기 요청을 처리해야하므로 아주 높은 쓰기 요청 빈도에 최적화되어 있고 규모 확장이 용이한 카산드라같은 데이터베이스가 필요하다.&lt;/p>
&lt;p>카프카 같은 스트림 처리 엔진을 활용하여 위치 데이터를 로깅해야 할 수도 있다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">POST /v1/locations
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">body:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> locs: JSON으로 인코딩한 (위도, 경도, 시각) 순서쌍 배열
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="경로-안내-서비스">경로 안내 서비스&lt;/h3>
&lt;p>A에서 B 지점으로 가는 합리적으로 빠른 경로를 찾아 주는 역할을 담당한다.&lt;/p>
&lt;ul>
&lt;li>결과를 얻는 데 드는 시간 지연은 어느 정도 감내할 수 있다.&lt;/li>
&lt;li>최단 시간 경로일 필요는 없으나 정확도는 보장되어야 한다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">GET /v1/nav?origin=1355+market+street,SF&amp;amp;destination=Disneyland
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="지도-표시">지도 표시&lt;/h3>
&lt;p>확대 수준별로 한 벌씩 지도 타일을 저장하려면 수백 PB가 필요하므로, 그 모두를 클라이언트가 가지고 있는 것은 실용적이지 않다.&lt;/p>
&lt;p>클라이언트의 위치 및 현재 클라이언트가 보는 확대 수준에 따라 필요한 타을을 서버에서 가져오는 접근법이 바람직하다.&lt;/p>
&lt;ul>
&lt;li>사용자가 지도를 확대 또는 이동시키며 주변을 탐색&lt;/li>
&lt;li>경로 안내가 진행되는 동안 사용자의 위치가 현재 지도 타일을 벗어나 인접한 타일로 이동&lt;/li>
&lt;/ul>
&lt;p>다량의 지도 타일 데이터를 효과적으로 가져오기 위해 아래와 같은 방법들을 고려할 수 있다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>선택지 1&lt;/strong>&lt;/p>
&lt;p>클라이언트가 보는 지도의 확대 수준에 근거하여 필요한 지도 타일을 즉석에서 만든다.&lt;/p>
&lt;p>사용자 위치 및 확대 수준의 조합이 무한하므로 몇 가지 심각한 문제가 있다.&lt;/p>
&lt;ul>
&lt;li>모든 지도 타일을 동적으로 만들어야 하는 서버 클러스터에 심각한 부하가 걸린다.&lt;/li>
&lt;li>캐시를 활용하기 어렵다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>선택지 2&lt;/strong>&lt;/p>
&lt;p>미리 만들어 둔 지도 타일을 클라이언트에 전달하기만 한다.&lt;/p>
&lt;p>지도 타일이 담당하는 지리적 영역은 지오해싱 같은 분할법을 사용해 만든 고정된 사각형의 격자로 표현되어 정적이다.&lt;/p>
&lt;ul>
&lt;li>지도 타일이 필요할 경우 현재 확대 수준에 근거하여 필요한 지도 타일 집합을 결정하고, 각 위치를 지오해시 URL로 변환하여 보낸다.&lt;/li>
&lt;li>미리 만들어 둔 정적 이미지를 CDN을 통해 서비스한다.&lt;/li>
&lt;/ul>
&lt;p>이 접근법은 규모 확장이 용이하고 성능 측면에서도 유리하다.&lt;/p>
&lt;ul>
&lt;li>가장 가까운 POP에서 파일을 서비스한다.&lt;/li>
&lt;li>지도 타일은 정적이므로 캐시를 통해 서비스하기 아주 적합하다.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_7.png"
width="659"
height="633"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_7_hu95af23d21653015c716fa288ebdc0b72_148322_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_7_hu95af23d21653015c716fa288ebdc0b72_148322_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="CDN 기반 서비스 구조의 강점"
class="gallery-image"
data-flex-grow="104"
data-flex-basis="249px"
>&lt;/p>
&lt;p>지도 타일은 이미 정의된 격자에 맞게 확대 수준별로 한 벌식 미리 만들어 둔 것을 사용하게 된다.&lt;/p>
&lt;p>지오해시를 사용해 격자를 나누므로 모든 격자는 고유한 지오해시 값을 갖는다.&lt;/p>
&lt;p>따라서 위도/경도로 표현된 클라이언트의 위치 및 현재 지도 확대 수준을 입력으로 화면에 표시할 지도 타일에 대응되는 지오해시는 아주 쉽게 계산해 낼 수 있다.&lt;/p>
&lt;p>이 계산은 클라이언트가 수행하며, 해당 지오해시 및 URL로 CDN에서 지도 타일을 가져오면 된다.&lt;/p>
&lt;hr>
&lt;p>지오해시 계산은 클라이언트가 수행해되 괜찮지만, 알고리즘을 클라이언트 단에 구현할 경우 지원해야 할 플랫폼이 많을 때 문제가 될 수 있다.&lt;/p>
&lt;p>모바일 앱 업데이트 배포는 시간도 많이 걸리고 때로는 위험하므로 앞으로 오랫동안 맵 타일 인코딩에는 지오해싱을 사용해야한다는 전제가 있어야 한다.&lt;/p>
&lt;ul>
&lt;li>다른 방식으로 변경이 필요하다면 많은 노력과 위험이 따른다.&lt;/li>
&lt;/ul>
&lt;p>이에따라 주어진 위도/경도 및 확대 수준을 타일 URL로 변환하는 알고리즘 구현을 &lt;strong>별도 서비스&lt;/strong>에 두는 방법을 고려할 수 있다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart
user([user])
lb[로드밸런서]
service[지도 타일 서비스&lt;br/> 3. 타일 URL들을 생성]
cdn((CDN))
user---|'1. 타일 URL 집합 요청'| lb
lb---|'2. 요청 전달'| service
user---|'4. 타일 다운로드'| cdn
&lt;/pre>
&lt;p>새로운 위치로 이동하거나 확대 수준을 변경하면 지도 타일 서비스는 어떤 타일이 필요한지 결정하여 해당 타일들을 가져오는 데 필요한 URL 집합을 계산하여 응답한다.&lt;/p>
&lt;h2 id="3단계-상세-설계">3단계: 상세 설계&lt;/h2>
&lt;h3 id="데이터-모델">데이터 모델&lt;/h3>
&lt;h4 id="경로-안내-타일">경로 안내 타일&lt;/h4>
&lt;p>확보한 도로 데이터는 가공되지 않았기 때문에 &lt;strong>경로 안내 타일 처리 서비스&lt;/strong>라 불리는 오프라인 데이터 가공 파이프라인을 주기적으로 실행하여 경로 안내 타일로 변환해야한다.&lt;/p>
&lt;ul>
&lt;li>도로 데이터에 발생한 새로운 변경사항을 반영하기 위해 주기적으로 실행한다.&lt;/li>
&lt;/ul>
&lt;p>경로 안내 타일을 만들 때는 해당도를 달리 하여 세 벌(상, 중, 하) 만든다.&lt;/p>
&lt;ul>
&lt;li>그래프의 노드와 간선으로 표현된 해당 지역 내 교차로와 도로 정보&lt;/li>
&lt;li>다른 타일의 도로와 연결되는 경우 해당 타일에 대한 참조 정보 포함&lt;/li>
&lt;/ul>
&lt;p>경로 안내 알고리즘은 이들 타일이 모인 결과로 만들어지는 도로망 데이터를 점진적으로 소비한다.&lt;/p>
&lt;p>가공 결과로 만들어진 타일은 어디에 저장해야 할까?&lt;/p>
&lt;p>일반적으로 그래프 데이터는 메모리에 인접 리스트 형태로 보관하나, 메모리에 두기에는 양이 너무 많다.&lt;/p>
&lt;p>그래프의 노드와 간선을 데이터베이스 레코드로 저장하는 것 도 방법이겠지만 비용이 많이 들 것이며, 경로 안내 타일의 경우 데이터베이스가 제공하는 기능이 필요 없다.&lt;/p>
&lt;p>따라서 &lt;strong>S3 같은 객체 저장소에 파일을 보관&lt;/strong>하고 그 파일을 이용할 &lt;strong>경로 안내 서비스에서 적극적으로 캐싱&lt;/strong>하는 방법을 고려할 수 있다.&lt;/p>
&lt;p>위도와 경도가 주어졌을 때 타일을 신속하게 찾기 위해 지오해시 기준으로 분류해 두는 것이 좋다.&lt;/p>
&lt;h4 id="사용자-위치-데이터">사용자 위치 데이터&lt;/h4>
&lt;p>사용자의 위치 정보는 아주 값진 데이터다.&lt;/p>
&lt;ul>
&lt;li>도로 데이터 및 경로 안내 타일을 갱신하는데 이용된다.&lt;/li>
&lt;li>실시간 교통 상황 데이터나 교통 상황 이력 데이터베이스를 구축하는 데도 활용된다.&lt;/li>
&lt;li>데이터 스트림 프로세싱 서비스는 이 위치 데이터를 처리하여 지도 데이터를 갱신한다.&lt;/li>
&lt;/ul>
&lt;p>사용자 위치 데이터를 저장하려면 엄청난 양의 쓰기 연산을 잘 처리할 수 있으면서 수평적 규모 확장이 가능한 데이터베이스가 필요하다.&lt;/p>
&lt;ul>
&lt;li>카산드라&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>user_id&lt;/th>
&lt;th>timestamp&lt;/th>
&lt;th>user_mode&lt;/th>
&lt;th>driving_mode&lt;/th>
&lt;th>location&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>101&lt;/td>
&lt;td>1635740977&lt;/td>
&lt;td>active&lt;/td>
&lt;td>driving&lt;/td>
&lt;td>(20.0, 30.5)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="지오코딩-데이터베이스">지오코딩 데이터베이스&lt;/h4>
&lt;p>주소를 위도/경도 쌍으로 변환하는 정보를 보관한다.&lt;/p>
&lt;p>읽기 연산은 빈번한 반면 쓰기 연산은 드물게 발생하는 특성으로 레디스와 같이 빠른 읽기 연산을 제공하는 키-값 저장소가 적합하다.&lt;/p>
&lt;p>출발지와 목적지 주소는 경로 계획 서비스에 전달하기 전 이 데이터베이스를 통해 위도/경도 쌍으로 변환된다.&lt;/p>
&lt;h4 id="미리-만들어-둔-지도-이미지">미리 만들어 둔 지도 이미지&lt;/h4>
&lt;p>단말이 특정 영역의 지도를 요청하면 인근 도로 정보를 취합하여 모든 도로 및 관련 상세 정보가 포함된 이미지를 만들어 내야 한다.&lt;/p>
&lt;ul>
&lt;li>계산 자원을 많이 사용한다.&lt;/li>
&lt;li>같은 이미지를 중복 요청하는 경우가 많다.&lt;/li>
&lt;/ul>
&lt;p>이미지느 ㄴ한 번만 계산하고 그 결과는 캐시해 두는 전략을 쓰는 것이 좋다.&lt;/p>
&lt;p>이미지는 지도 표시에 사용하는 확대 수준 별로 미리 만들어 두고 CDN을 통해 전송한다.&lt;/p>
&lt;h3 id="서비스">서비스&lt;/h3>
&lt;h4 id="위치-서비스-1">위치 서비스&lt;/h4>
&lt;p>데이터베이스 설계 및 사용자 위치 정보가 이용되는 방식에 초점을 맞추어 상세 설계를 진행해본다.&lt;/p>
&lt;p>사용자 위치 데이터 저장에는 키-값 저장소를 활용한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart TD
mobile([모바일 사용자]) -->
loadBalancer[로드밸런서] -->
location[위치 서비스] -->
db[(사용자 위치 DB)]
&lt;/pre>
&lt;ul>
&lt;li>초당 백만 건의 위치 정보 업데이트가 발생한다는 점을 감안하면 쓰기 연산 지원에 탁월한 데이터베이스가 필요하다.&lt;/li>
&lt;li>사용자 위치는 계속 변화하며, 일단 변경되고 나면 이전 정보는 바로 무용해지므로, 데이터 일관성 보다는 가용성이 더 중요하다.
&lt;ul>
&lt;li>CAP 정리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이러한 요구사항에는 &lt;strong>NoSQL 키-값 데이터베이스&lt;/strong>나 &lt;em>&lt;em>열-중심&lt;/em> 데이터베이스&lt;/em>(column-oriented database)가 적합하며, 이 중 가용성과 분할 내성 두가지를 만족 시키는 데이터베이스에는 &lt;strong>카산드라&lt;/strong>가 있다.&lt;/p>
&lt;hr>
&lt;p>데이터 베이스 키로는 &lt;code>(user_id, timestamp)&lt;/code> 조합을 사용하며, 해당 키에 매달리는 값으로 &lt;code>위도/경도&lt;/code> 쌍을 저장한다.&lt;/p>
&lt;ul>
&lt;li>user_id는 파티션 키
&lt;ul>
&lt;li>같은 파티션 키를 갖는 데이터는 함께 저장됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>timestamp는 클러스터링 키
&lt;ul>
&lt;li>클러스터링 키 값에 따라 정렬된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>이렇게 해 두면 특정 사용자의 특정 기간 내 위치도 효율적으로 읽어낼 수 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>key(uesr_id)&lt;/th>
&lt;th>timestamp&lt;/th>
&lt;th>lat&lt;/th>
&lt;th>long&lt;/th>
&lt;th>user_mode&lt;/th>
&lt;th>navigation_mode&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>51&lt;/td>
&lt;td>132053000&lt;/td>
&lt;td>21.9&lt;/td>
&lt;td>89.8&lt;/td>
&lt;td>active&lt;/td>
&lt;td>driving&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="사용자-위치-데이터는-어떻게-이용되는가">사용자 위치 데이터는 어떻게 이용되는가&lt;/h4>
&lt;p>사용자 위치는 쓰임새가 다양한 중요 데이터다.&lt;/p>
&lt;ul>
&lt;li>새로 개설되었거나 폐쇄된 도로를 감지할 수 있다.&lt;/li>
&lt;li>지도 데이터의 정확성을 점차로 개선하는 입력으로 활용될 수 있다.&lt;/li>
&lt;li>실시간 교통 현황을 파악하는 입력이 될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>이러한 용례를 지원하기 위해 사용자 위치를 데이터베이스에 기록하는 것과 별도로 &lt;strong>카프카&lt;/strong>와 같은 메시지 큐에 로깅한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_8.png"
width="802"
height="437"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_8_hu7e5de397c61cacf1f854f32e04691977_149242_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_8_hu7e5de397c61cacf1f854f32e04691977_149242_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="여러 서비스에 위치 데이터 제공"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="440px"
>&lt;/p>
&lt;p>개별 서비스들은 카프카를 통해 전달되는 사용자 위치 데이터 스트림을 각자 용도에 맞게 활용할 수 있다.&lt;/p>
&lt;h3 id="지도-표시-1">지도 표시&lt;/h3>
&lt;p>지도 타일을 미리 만들어 놓는 방법과 지도 표시 최적화 기법을 살펴본다.&lt;/p>
&lt;h4 id="지도-타일-사전-계산">지도 타일 사전 계산&lt;/h4>
&lt;p>사용자가 보는 지도 크기나 확대 수준에 맞는 세부사항을 보여주기 위해 확대 수준별 지도 타일을 미리 만들어 둘 필요가 있다.&lt;/p>
&lt;ul>
&lt;li>구글맵은 21단계로 지도를 확대할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>확대 수준 0은 세계 전부를 256 * 256 픽셀짜리 타일 하나로 표현하며, 1단계 올릴 때마다 동서, 남북 방향으로 2배 씩 늘어난다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_9.png"
width="623"
height="365"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_9_hufe332efd68ce7553509f6a6bfaaa3fd6_248243_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_9_hufe332efd68ce7553509f6a6bfaaa3fd6_248243_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="확대 수준별 지도"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="409px"
>&lt;/p>
&lt;p>따라서 해상도도 4배 증가하게 된다.&lt;/p>
&lt;p>이렇게 늘어난 해상도 덕에 사용자에게 더 상세한 정보를 제공할 수 있으며, 클라이언트는 해당 정보를 제공하기 위한 타을을 다운 받는 데 많은 네트워크 대역폭을 소진하지 않고도 클라이언트에 설정된 확대 수준에 최적인 크기의 지도를 표시할 수 있다.&lt;/p>
&lt;h4 id="최적화-벡터-사용">최적화: 벡터 사용&lt;/h4>
&lt;p>지도 표시에 WebGL 기술을 채택하여 이미지 대신 경로와 다각형 등의 벡터 정보를 보낸다.&lt;/p>
&lt;ul>
&lt;li>벡터 타일은 이미지에 비해 월등한 압축률을 가지므로 네트워크 대역폭을 많이 아낄 수 있다.&lt;/li>
&lt;li>레스터 방식 이미지(Rasterized image)는 확대 수준을 높이는 순간 이미지가 늘어지고 픽셀이 도드라져 보이는 것과 달리 벡터화 된 이미지는 이러한 단점이 없다.&lt;/li>
&lt;/ul>
&lt;h3 id="경로-안내-서비스-1">경로 안내 서비스&lt;/h3>
&lt;p>경로 안내 서비스는 가장 빠른 경로를 안내하는 역할을 담당한다.&lt;/p>
&lt;pre class="mermaid" style="text-align: center;">flowchart
ac(모바일 사용자)
lb[로드밸런서]
ns[경로 안내 서비스]
gs[지오코딩 서비스]
nps[경로 계획 서비스]
rnks[순위 결정 서비스]
fsns[최단 경로 서비스]
arrs[예상 도착 서비스]
pss[실시간 교통 상황 서비스]
gdb(지오코딩 DB)
ndb(경로 안내 타일 DB)
pdb(교통량 DB)
udb(사용자 위치 DB)
ac-->lb
lb-->ns
ns-->gs
ns-->nps
gs-->gdb
nps-->fsns
nps-->rnks
nps-->arrs
fsns-->ndb
arrs-->pdb
pss-->pdb
pss-->udb
&lt;/pre>
&lt;h4 id="지오코딩-서비스">지오코딩 서비스&lt;/h4>
&lt;p>주소를 위도와 경도 쌍으로 바꾸어준다.&lt;/p>
&lt;p>주소의 표현 방식은 다양할 수 있다는 점을 고려해야한다.&lt;/p>
&lt;ul>
&lt;li>장소 이름으로 나타낸 주소&lt;/li>
&lt;li>지번 형태로 나타낸 주소 등&lt;/li>
&lt;/ul>
&lt;p>경로 안내 서비스는 이 서비스를 호출하여 출발지와 목적지 주소를 위도/경도 쌍으로 변환한 뒤 추후 다른 서비스 호출에 이용한다.&lt;/p>
&lt;h4 id="경로-계획-서비스">경로 계획 서비스&lt;/h4>
&lt;p>경로 계획 서비스(route planner service)는 현재 교통 상황과 도로 상태에 입각하여 이동 시간 측면에서 최적화된 경로를 제안한다.&lt;/p>
&lt;h4 id="최단-경로-서비스">최단 경로 서비스&lt;/h4>
&lt;p>최단 경로 서비스(shortest path service)는 출발지와 목적지 위도/경도를 입력으로 받아 k개의 최단 경로를 반환하는 서비스이다.&lt;/p>
&lt;p>이때 교통이나 도로 상황은 고려하지 않고, 도로 구조에만 의존하여 계산을 수행한다.&lt;/p>
&lt;ul>
&lt;li>도로망 그래프는 거의 정적이므로 캐시해 두면 좋다.&lt;/li>
&lt;/ul>
&lt;p>최단 경로 서비스는 객체 저장소에 저장된 경로 안내 타일에 대해 A* 경로 탐색 알고리즘의 한 형태를 실행한다.&lt;/p>
&lt;ol>
&lt;li>입력으로 출발지와 목적지의 위도/경도를 받는다.
&lt;ul>
&lt;li>이 위치 정보를 지오해시로 변호나한 다음 출발지와 목적지 경로 안내 타일을 얻는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>출발지 타일에서 시작하여 그래프 자료 구조를 탐색해 나간다.
&lt;ul>
&lt;li>탐색 범위를 넓히는 과정에서 필요한 주변 타일은 객체 저장소(캐시)에서 가져온다.&lt;/li>
&lt;li>같은 지역의 다른 확대 수준 타일로도 연결이 존재할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>최단 경로가 충분히 확보될 때까지 알고리즘은 검색 범위를 계속 확대해 나가면서 필요한 만큼 타일을 가져오는 작업을 반복한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_11.png"
width="1080"
height="458"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_11_huf7f7afc7caa46f16dc28ef7b8c08d390_800218_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_11_huf7f7afc7caa46f16dc28ef7b8c08d390_800218_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="그래프 탐색"
class="gallery-image"
data-flex-grow="235"
data-flex-basis="565px"
>&lt;/p>
&lt;h4 id="예상-도착-시간-서비스">예상 도착 시간 서비스&lt;/h4>
&lt;p>경로 계획 서비스는 최단 경로 목록을 수신하면 예상 도착 시간 서비스를 호출하여 그 경로 각각에 대한 소요 시간 추정치를 구한다.&lt;/p>
&lt;p>기계 학습을 활용해 현재 교통 상황 및 과거 이력에 근거하여 예상 도착 시간을 계산한다.&lt;/p>
&lt;p>이 때 실시간 교통 상황 데이터 뿐만 아니라 앞으로 10분에서 20분 뒤의 교통 상황이 어떻게 달라질지도 예측해야한다.&lt;/p>
&lt;h4 id="순위-결정-서비스">순위 결정 서비스&lt;/h4>
&lt;p>ETA 예상치를 구하고 나면 순위 결정 서비스(ranker)에 관련 정보를 모두 전달하여 사용자가 정의한 필터링 조건을 적용한다.&lt;/p>
&lt;ul>
&lt;li>유료 도로 제외, 고속도로 제외 등&lt;/li>
&lt;/ul>
&lt;p>필터링이 끝나고 남은 경로를 소요 시간 순으로 정렬하여 최단 시간 경로 k개를 구한 후 경로 안내 서비스에 결과를 반환한다.&lt;/p>
&lt;h4 id="중요-정보-갱신-서비스들">중요 정보 갱신 서비스들&lt;/h4>
&lt;p>이 부류의 서비스는 &lt;strong>카프카 위치 데이터 스트림&lt;/strong>을 구독하고 있다가 중요 데이터를 비동기적으로 업데이트하여 그 상태를 항상 최신으로 유지하는 역할을 담당한다.&lt;/p>
&lt;ul>
&lt;li>실시간 교통 정보 데이터베이스
&lt;ul>
&lt;li>활성화 상태 사용자가 보내는 위치 데이터 스트림에서 교통 상황 정보를 추출&lt;/li>
&lt;li>실시간 교통 상황 데이터베이스에 반영되어 예상 도착 시간 서비스가 더욱 정확한 결과를 내는데 쓰인다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>경로 안내 타일
&lt;ul>
&lt;li>도로 데이터에 새로 발견된 도로, 폐쇄되었음이 확인된 도로 정보를 반영하여 경로 안내 타일을 지속적으로 갱신&lt;/li>
&lt;li>최단 경로 서비스는 더 정확한 결과를 낼 수 있게 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="적응형-eta와-경로-변경">적응형 ETA와 경로 변경&lt;/h4>
&lt;p>이 문제를 해결하려면 서버는 현재 경로 안내를 받고 있는 모든 사용자를 추적하면서 교통 상황이 달라질 때마다 각 사용자의 ETA를 변경해 주어야 한다.&lt;/p>
&lt;ul>
&lt;li>현재 경로 안내를 받고 있는 사용자는 어떻게 추적하나?&lt;/li>
&lt;li>수백만 경로 가운데 교통 상황 변화에 영향을 받는 경로와 사용자를 효율적으로 가려낼 방법은?&lt;/li>
&lt;/ul>
&lt;p>사용자 &lt;code>user_1&lt;/code>이 안내받은 경로가 경로 안내 타일 &lt;code>r_1&lt;/code> &amp;hellip; &lt;code>r_7&lt;/code> 구성되어 있다고 가정한다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_12.png"
width="460"
height="179"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_12_hu280e0708fed9cf1f12a8aef8bbdf84a8_41297_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_12_hu280e0708fed9cf1f12a8aef8bbdf84a8_41297_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="안내된 경로"
class="gallery-image"
data-flex-grow="256"
data-flex-basis="616px"
>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>효율적이지 않은 방법&lt;/strong>&lt;/p>
&lt;p>사용자와 경로 정보를 데이터 베이스에 저장한다고 하면 아래와 같을 것 이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">user_1: r_1, r_2 ..., r_k
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">user_2: r_1, r_2 ..., r_n
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">user_3: r_2, r_3 ..., r_m
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">user_4: r_3, r_10 ..., r_l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이 때 r_2에서 교통 사고가 발생했다면, 어떤 사용자가 영향을 받는지 알아내기 위해 레코드를 전수 조사해야한다.&lt;/p>
&lt;p>테이블에 보관된 레코드 수가 n이고 안내되는 경로의 평균 길이가 m이라면 모든 사용자 검색의 시간 복잡도는 &lt;code>O(n * m)&lt;/code>이다.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>개선된 방법&lt;/strong>&lt;/p>
&lt;p>경로 안내를 받는 사용자 각가의 현재 경로 안내 타일, 그 타일을 포함하는 상위 타일(확대 수준이 더 낮은 타일), 그 상위 타일의 상위 타일을 출발지와 목적지가 모두 포함된 타일을 찾을 때까지 재귀적으로 더하여 보관한다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">user_1, r_1, super(r_1), super(super(r_1)), ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_13.png"
width="626"
height="576"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_13_hue7d0c9d50a34906b9535c0723874c0aa_123912_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_13_hue7d0c9d50a34906b9535c0723874c0aa_123912_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="재귀적인 경로 타일 수집"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="260px"
>&lt;/p>
&lt;p>어떤 타일의 교통 상황이 변했을 때 경로 안내 ETA가 달라지는 사용자는, 해당 사용자의 데이터베이스 레코드 마지막 타일에 그 타일이 속하는 사용자가 된다.&lt;/p>
&lt;p>그 이외의 사용자에게는 아무런 영향이 없으므로 검색 시간 복잡도가 &lt;code>O(n)&lt;/code>으로 줄어들어 좀 더 효율적이다.&lt;/p>
&lt;p>그러나 이 접근법은 교통 상황이 개선되었을 때 해야 하는 일까지 해결해 주지는 않는다.&lt;/p>
&lt;p>예를 들어 타일 2의 교통 상황이 회복되어서 사용자가 옛날 경로로 돌아가도 된다고 할 때 경로 재설정이 가능하다는 사실을 감지하고 알려야한다.&lt;/p>
&lt;p>한 가지 방안은 현재 경로 안내를 받는 사용자가 이용 가능한 경로의 ETA를 주기적으로 재계산하여 더 짧은 ETA를 간즞 경로가 발견되면 알리는 것 이다.&lt;/p>
&lt;h4 id="전송-프로토콜">전송 프로토콜&lt;/h4>
&lt;p>경로 안내 중에 경로 상황이 변경될 수 있으므로, 데이터를 모바일 클라이언트에 전송할 안정적인 방법이 필요하다.&lt;/p>
&lt;p>이 경우 서버에서 클라이언트로 데이터를 보내는 데 활용할 수 있는 프로토콜로는 모바일 푸시 알림, 롱 폴링, 웹소켓, 서버 전송 이벤트 등이 있다.&lt;/p>
&lt;ul>
&lt;li>모바일 푸시 알림
&lt;ul>
&lt;li>메시지 크기가 매우 제한적이므로 사용하지 않는 게 바람직하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>웹소켓
&lt;ul>
&lt;li>서버에 주는 부담이 크지 않아 일반적으로 롱 폴링보다 좋은 방안으로 본다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>웹소켓 SSE 모두 괜찮은 방법이지만 본 설계안에서는 웹소켓을 사용한다.&lt;/p>
&lt;ul>
&lt;li>양방향 통신을 지원하여 패키지나 상품이 목적지에 가까워졌을 때는 실시간 양방향 통신이 필요한 경우도 있기 때문&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview-2/3/img_10.png"
width="1540"
height="1240"
srcset="https://codemario318.github.io/post/system-design-interview-2/3/img_10_huef52c7d9d52a678b3a7058ace4c6f3a8_129189_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview-2/3/img_10_huef52c7d9d52a678b3a7058ace4c6f3a8_129189_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="최종 설계안"
class="gallery-image"
data-flex-grow="124"
data-flex-basis="298px"
>&lt;/p>
&lt;h2 id="4단계-마무리">4단계: 마무리&lt;/h2>
&lt;p>시스템의 확장에 관심이 있다면, 기업 고객 대상으로 중간 경유지 설정 기능을 제공하는 것을 고려해보면 좋다.&lt;/p>
&lt;ul>
&lt;li>하나가 아닌 여러 목적지를 입력으로 하면 그 모두를 어떤 순서로 방문해야 가장 빨리 경유할 수 있을지 실시간 교통 상황을 고려하여 안내&lt;/li>
&lt;li>도어대시, 우버, 리프트 같은 배달 서비스에 유용&lt;/li>
&lt;/ul></description></item><item><title>5. 안정 해시 설계</title><link>https://codemario318.github.io/post/system-design-interview/5/</link><pubDate>Thu, 23 May 2024 12:04:50 +0900</pubDate><guid>https://codemario318.github.io/post/system-design-interview/5/</guid><description>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/cover.png" alt="Featured image of post 5. 안정 해시 설계" />&lt;p>&lt;strong>수평적 규모 확장성&lt;/strong>을 달성하기 위해서는 요청 또는 데이터를 서버에 &lt;strong>균등하게 나누는 것&lt;/strong>이 중요하다.&lt;/p>
&lt;p>&lt;strong>안정 해시&lt;/strong>는 이 목표를 달성하기 위해 보편적으로 사용하는 기술이다.&lt;/p>
&lt;h2 id="해시-키-재배치rehash-문제">해시 키 재배치(rehash) 문제&lt;/h2>
&lt;p>N개의 캐시 서버가 있을 때, 부하를 균등하게 나누는 보편적 방법은 해시 함수를 사용하는 것이다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">serverIndex = hash(key) % N
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>총 4대의 서버를 사용한다면, 주어진 각각의 키에 대해 아래와 같이 계산될 수 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>키&lt;/th>
&lt;th>해시&lt;/th>
&lt;th>해시 % 4(서버 인덱스)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>key0&lt;/td>
&lt;td>18358617&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key1&lt;/td>
&lt;td>26143584&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key2&lt;/td>
&lt;td>18131146&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key3&lt;/td>
&lt;td>35863496&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key4&lt;/td>
&lt;td>34085809&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key5&lt;/td>
&lt;td>27581703&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key6&lt;/td>
&lt;td>38164978&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key7&lt;/td>
&lt;td>22530351&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>키 값을 해싱한 값에 나머지 연산을 하여 저장될 서버가 결정된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img.png"
width="597"
height="323"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_hu8ecb82b93ef83548a97acf28dacc70e3_47080_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_hu8ecb82b93ef83548a97acf28dacc70e3_47080_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="443px"
>&lt;/p>
&lt;p>이 방식은 &lt;strong>서버 풀의 크기가 고정되어 있을 때&lt;/strong>, &lt;strong>데이터 분포가 균등할 때&lt;/strong> 잘 동작한다.&lt;/p>
&lt;p>하지만 서버가 추가되거나, 기존 서버가 삭제되면 나머지 연산 결과 값이 변하기 때문에 문제가 발생한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>키&lt;/th>
&lt;th>해시&lt;/th>
&lt;th>해시 % 3(서버 인덱스)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>key0&lt;/td>
&lt;td>18358617&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key1&lt;/td>
&lt;td>26143584&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key2&lt;/td>
&lt;td>18131146&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key3&lt;/td>
&lt;td>35863496&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key4&lt;/td>
&lt;td>34085809&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key5&lt;/td>
&lt;td>27581703&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key6&lt;/td>
&lt;td>38164978&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>key7&lt;/td>
&lt;td>22530351&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>따라서 아래와 같은 형태로 키의 분포가 바뀐다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_1.png"
width="595"
height="375"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_1_hu221148814a934c0ed66cfef734ebb8e4_56907_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_1_hu221148814a934c0ed66cfef734ebb8e4_56907_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="158"
data-flex-basis="380px"
>&lt;/p>
&lt;p>장애가 발생한 1번 서버에 보관되어 있는 키 뿐만 아닌 대부분의 키가 재분배되어, 대부분 캐시 클라이언트가 데이터가 없는 서버에 접속하게된다.&lt;/p>
&lt;p>이로 인해 대규모 캐시 미스가 발생하게되는데, &lt;strong>안정 해시&lt;/strong>는 이러한 문제를 효과적으로 해결하는 방식이다.&lt;/p>
&lt;h2 id="안정-해시">안정 해시&lt;/h2>
&lt;p>안정 해시는 &lt;strong>해시 테이블 크기가 조정될 때 평균적으로 &lt;code>k/n&lt;/code>개의 키만 재비치하는 해시 기술&lt;/strong>이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>k&lt;/code>: 키의 개수&lt;/li>
&lt;li>&lt;code>n&lt;/code>: 슬롯의 개수&lt;/li>
&lt;/ul>
&lt;p>이와는 달리 대부분의 전통적인 해시 테이블은 슬롯의 수가 바뀌면 거의 대부분 키를 재배치한다.&lt;/p>
&lt;h3 id="해시-공간과-해시-링">해시 공간과 해시 링&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>SHA-1&lt;/strong> 해시함수를 사용하며, 출력 값의 범위는 &lt;code>x0, x1 ... xn&lt;/code>이라고 가정한다.&lt;/li>
&lt;li>&lt;strong>SHA-1&lt;/strong>의 해시 공간(hash space) 범위는 &lt;strong>0 부터 &lt;code>2^160 - 1&lt;/code>&lt;/strong> 까지라고 알려져 있다.&lt;/li>
&lt;/ul>
&lt;p>따라서 &lt;code>x0 = 0&lt;/code>, &lt;code>xn -1 = 2^160 - 1&lt;/code>이며, 두 수 사이의 값을 갖게 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_2.png"
width="239"
height="284"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_2_huf4d0b3acc8d8378f9f6d7202b468ee24_14360_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_2_huf4d0b3acc8d8378f9f6d7202b468ee24_14360_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="84"
data-flex-basis="201px"
>&lt;/p>
&lt;p>이 해시 공간의 양쪽을 연결하변 해시 링이 만들어진다.&lt;/p>
&lt;h3 id="해시-서버">해시 서버&lt;/h3>
&lt;p>해시 함수 &lt;code>f&lt;/code>를 사용하면 서버(IP, 이름 등)를 링 위의 어딘가에 대응시킬 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_3.png"
width="607"
height="421"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_3_hu0bc48cf4515b95e87de880bf1aab9c60_55336_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_3_hu0bc48cf4515b95e87de880bf1aab9c60_55336_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="346px"
>&lt;/p>
&lt;h3 id="해시-키">해시 키&lt;/h3>
&lt;blockquote>
&lt;p>안정 해시에서 사용되는 해시 함수는 전통적인 해시 키 방식에서 언급된 방식과 다르며, 만들어질 수 있는 모든 해시 공간 &lt;code>x0 ... xn&lt;/code>을 연결한 형태이므로 나머지 연산을 사용하지 않는다.&lt;/p>
&lt;/blockquote>
&lt;p>캐시할 키 또한 서버와 함께 해시 링 위의 어느 지점에 배치할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_4.png"
width="606"
height="390"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_4_hu2fcefd9766a218d8cface53baa2bca15_61260_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_4_hu2fcefd9766a218d8cface53baa2bca15_61260_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="372px"
>&lt;/p>
&lt;h3 id="서버-조회">서버 조회&lt;/h3>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_5.png"
width="606"
height="390"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_5_hu2fcefd9766a218d8cface53baa2bca15_61260_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_5_hu2fcefd9766a218d8cface53baa2bca15_61260_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="372px"
>&lt;/p>
&lt;p>어떤 키가 저장되는 서버는 &lt;strong>해당 키의 위치로부터 시계 방향으로 링을 탐색해 나가면서 만나는 첫번 째 서버&lt;/strong>이다.&lt;/p>
&lt;p>따라서 &lt;strong>k0&lt;/strong>는 &lt;strong>s0&lt;/strong> 에 저장된다.&lt;/p>
&lt;h3 id="서버-추가">서버 추가&lt;/h3>
&lt;p>키가 저장되는 서버가 키의 위치로부터 시계 방향으로 링을 돌면서 만나는 첫 서버이므로, 서버를 추가하더라도 키 가운데 일부만 재배치하면 된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_6.png"
width="615"
height="465"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_6_huc8545933ab2d8774b07636da6ebf7ea2_77279_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_6_huc8545933ab2d8774b07636da6ebf7ea2_77279_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="132"
data-flex-basis="317px"
>&lt;/p>
&lt;p>위 그림처럼 s4가 추가되면, k0만 재배치하면 되며, 나머지 키들은 같은 서버에 남게된다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>k0&lt;/strong>가 만나는 첫 서버가 &lt;strong>s4&lt;/strong>로 바뀌기 때문&lt;/li>
&lt;/ul>
&lt;h3 id="서버-제거">서버 제거&lt;/h3>
&lt;p>마찬가지로 한 서버가 제거되면 &lt;strong>키 일부만 재배치&lt;/strong>된다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_7.png"
width="609"
height="450"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_7_hu76c16055e4220cf0e1509508dbdc7e60_68728_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_7_hu76c16055e4220cf0e1509508dbdc7e60_68728_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="324px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>s1&lt;/strong>이 삭제되었을 때 &lt;strong>k1&lt;/strong>의 첫 서버만 &lt;strong>s2&lt;/strong>로 바뀌므로 &lt;strong>k1&lt;/strong>만 &lt;strong>s2&lt;/strong>로 재배치된다.&lt;/li>
&lt;/ul>
&lt;h3 id="기존-구현법의-두-가지-문제">기존 구현법의 두 가지 문제&lt;/h3>
&lt;p>안정 해시 알고리즘은 MIT에서 처음 제안되었는데, 기본 절차는 아래와 같다.&lt;/p>
&lt;ol>
&lt;li>서버와 키를 &lt;strong>균등 분포 해시 함수&lt;/strong>를 사용해 해시 링에 배치한다.&lt;/li>
&lt;li>키의 위치에서 링을 시계방향으로 탐색하다 만나는 최초의 서버가 키가 저장될 서버이다.&lt;/li>
&lt;/ol>
&lt;p>안정 해시는 근본적으로 최소한의 추가/삭제에 대해 최소한의 재배치를 고려한다. 따라서 이러한 방식에는 두 가지 문제가 발생한다.&lt;/p>
&lt;p>&lt;strong>파티션 크기 문제&lt;/strong>&lt;/p>
&lt;p>서버가 추가되거나 삭제되는 상황을 감안하면 사용하더라도 파티션의 크기를 균등하게 유지하는 게 불가능하다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_8.png"
width="610"
height="371"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_8_hufb05e65c37497f753e3a366dbfe6320e_67873_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_8_hufb05e65c37497f753e3a366dbfe6320e_67873_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;ul>
&lt;li>파티션의 크기는 시계 방향으로 제일 가까운 서버 사이와의 거리만큼의 해시 공간으로, 서버의 해시 공간이 균등하지 않다.
&lt;ul>
&lt;li>추가 삭제될 때 시계 방향으로 제일 가까운 서버에 키들이 집중된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>키의 균등 분포 문제&lt;/strong>&lt;/p>
&lt;p>균등 분포 해시 함수는 충돌을 최소화하며 입력 키들이 해시 공간 전체에 고르게 분포되어 특정 영역에 물리지 않도록 구현되지만 완전하지는 않다.&lt;/p>
&lt;ul>
&lt;li>데이터의 비균등한 본질:
&lt;ul>
&lt;li>실제 데이터는 해시 함수의 이상적인 균등 분포를 따르지 않을 수 있다.&lt;/li>
&lt;li>특정 패턴이나 값들이 특정 해시 영역에 몰리는 경우가 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>해시 함수의 한계:
&lt;ul>
&lt;li>모든 해시 함수는 완벽한 균등 분포를 보장할 수 없다.&lt;/li>
&lt;li>특히 입력 키의 분포가 고르지 않을 경우, 해시 값의 분포도 고르지 않을 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_9.png"
width="611"
height="409"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_9_hu5257857a45f5f8de50581f3a0c6d2841_61763_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_9_hu5257857a45f5f8de50581f3a0c6d2841_61763_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="149"
data-flex-basis="358px"
>&lt;/p>
&lt;p>따라서 키의 균등 분포가 매우 달성하기 어려워 위와 같은 상황이 발생하게된다.&lt;/p>
&lt;p>&lt;strong>+ 실제 서버의 처리 능력 차이&lt;/strong>&lt;/p>
&lt;p>노드(서버)마다 처리 능력이나 저장 용량이 다를 경우, 파티션 크기의 균등성이 실제 부하의 균등성을 의미하지 않을 수 있다.&lt;/p>
&lt;h3 id="가상-노드">가상 노드&lt;/h3>
&lt;p>가상 노드는 &lt;strong>실제 노드 또는 서버를 가리키는 노드&lt;/strong>로서 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_10.png"
width="603"
height="458"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_10_hua3bd50f3317f65ef075362e2b74282e1_85776_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_10_hua3bd50f3317f65ef075362e2b74282e1_85776_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="315px"
>&lt;/p>
&lt;p>서버들의 비슷한 해시 공간을 가질 수 있도록 하는 기법으로 해시 링 위에 실제 서버를 가르키는 가상 노드들을 분포시킨 후 가상 노드에 할당되는 해시 영역을 가상 노드가 가르키는 서버가 처리하도록 한다.&lt;/p>
&lt;ul>
&lt;li>따라서 각 서버는 하나가 아닌 여러 개의 파티션을 관리해야 한다.&lt;/li>
&lt;/ul>
&lt;p>가상 노드의 개수를 늘리면 표준 편차가 작아져 데이터가 고르게 분포되므로, 키위 분포는 점점 더 균등해지지만&lt;/p>
&lt;p>가상 노드 데이터를 저장할 공간이 더 많이 필요해지므로, 시스템 요구사항에 맞도록 가상 노드 개수를 적절히 조정하는 트레이드오프가 필요하다.&lt;/p>
&lt;h3 id="재배치할-키-결정">재배치할 키 결정&lt;/h3>
&lt;p>서버가 추가되거나 제거되면 데이터의 일부는 재배치해야 한다.&lt;/p>
&lt;p>&lt;strong>서버가 추가되었을 때&lt;/strong>&lt;/p>
&lt;p>&lt;strong>s4&lt;/strong>가 추가되었다고 가정하면, 영향을 받는 위는 &lt;strong>s4&lt;/strong> 부터 그 반시계 방향에 있는 &lt;strong>s3&lt;/strong> 까지이다.&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_11.png"
width="611"
height="463"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_11_hu56d8da2926a0ef9a8f4dcf5986502707_77091_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_11_hu56d8da2926a0ef9a8f4dcf5986502707_77091_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="316px"
>&lt;/p>
&lt;p>따라서 &lt;strong>s3&lt;/strong> 부터 &lt;strong>s4&lt;/strong> 사이에 있는 키들을 &lt;strong>s4&lt;/strong>로 재배치해야한다.&lt;/p>
&lt;p>&lt;strong>서버가 삭제되었을 때&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://codemario318.github.io/post/system-design-interview/5/img_12.png"
width="608"
height="449"
srcset="https://codemario318.github.io/post/system-design-interview/5/img_12_hu33149acfb6f53d9b638ddb2443c387f3_70058_480x0_resize_box_3.png 480w, https://codemario318.github.io/post/system-design-interview/5/img_12_hu33149acfb6f53d9b638ddb2443c387f3_70058_1024x0_resize_box_3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="324px"
>&lt;/p>
&lt;p>&lt;strong>s1&lt;/strong>이 삭제되면 &lt;strong>s1&lt;/strong> 부터 그 반시계 방향에 있는 최초 서버 &lt;strong>s0&lt;/strong> 사이에 있는 키들이 &lt;strong>s2&lt;/strong>로 재배치되어야 한다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>안정 해시의 이점은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>서버가 추가되거나 삭제될 때 재배치되는 키의 수가 최소화된다.&lt;/li>
&lt;li>데이터가 보다 균등하게 분포하게 되므로 수평적 규모 확장성을 달성하기 쉽다.&lt;/li>
&lt;li>핫스팟 키 문제를 줄인다.
&lt;ul>
&lt;li>특정한 샤드에 대한 접근이 지나치게 빈번하면 서버 과부화 문제가 생길 수 있는데(유명인사 문제), 데이터를 좀 더 균등하게 분배하므로 문제 발생 가능성을 줄인다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>안정해시는 실제로 널리 쓰이는 기술이다.&lt;/p>
&lt;ul>
&lt;li>아마존 다이나모 데이터베이스의 파티셔닝 관련 컴포넌트&lt;/li>
&lt;li>아파치 카산드라 클러스터에서 데이터 파티셔닝&lt;/li>
&lt;li>디스코드 채팅 어플리케이션&lt;/li>
&lt;li>아카마이 CDN&lt;/li>
&lt;li>매그레프 네트워크 부하 분산기 등&lt;/li>
&lt;/ul></description></item></channel></rss>