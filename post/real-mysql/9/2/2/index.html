<!doctype html><html lang=ko dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Real MySQL 8.0"><title>9.2 기본 데이터 처리(2)</title><link rel=canonical href=https://codemario318.github.io/post/real-mysql/9/2/2/><link rel=stylesheet href=/scss/style.min.cbce94e2760d14d60414e59d5a36ab2819232375817e010dbe7be2234b67da1b.css><meta property="og:title" content="9.2 기본 데이터 처리(2)"><meta property="og:description" content="Real MySQL 8.0"><meta property="og:url" content="https://codemario318.github.io/post/real-mysql/9/2/2/"><meta property="og:site_name" content="Mario Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="DB"><meta property="article:tag" content="MySQL"><meta property="article:published_time" content="2023-05-23T15:30:10+09:00"><meta property="article:modified_time" content="2023-05-23T15:30:10+09:00"><meta property="og:image" content="https://codemario318.github.io/post/real-mysql/9/2/2/real_mysql.jpeg"><meta name=twitter:title content="9.2 기본 데이터 처리(2)"><meta name=twitter:description content="Real MySQL 8.0"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://codemario318.github.io/post/real-mysql/9/2/2/real_mysql.jpeg"><script async src="https://www.googletagmanager.com/gtag/js?id=G-K99591YLGK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K99591YLGK",{anonymize_ip:!1})}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3183752545292673" crossorigin=anonymous></script><meta name=naver-site-verification content="2315bde85c86f66092140cc465c340a2170f3187"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu760fd15c5fbb2f30cf0868dc4a5dc41a_14271_300x0_resize_q75_box.jpeg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Mario Blog</a></h1><h2 class=site-description></h2></div></header><ol class=social-menu><li><a href=https://github.com/codemario318 target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><ul class="menu sub-menu"><li><a href=/categories/backend/><span>Backend</span>
<span class=content-count>3</span></a></li><li><a href=/categories/boostcamp/><span>부스트캠프</span>
<span class=content-count>9</span></a></li><li><a href=/categories/cleancode/><span>Clean Code</span>
<span class=content-count>10</span></a></li><li><a href=/categories/common/><span>Common</span>
<span class=content-count>67</span></a></li><li><a href=/categories/data/><span>Data</span>
<span class=content-count>3</span></a></li><li><a href=/categories/db/><span>DB</span>
<span class=content-count>1</span></a></li><li><a href=/categories/frontend/><span>Frontend</span>
<span class=content-count>10</span></a></li><li><a href=/categories/golang/><span>GoLang</span>
<span class=content-count>13</span></a></li><li><a href=/categories/headfirstdesignpatterns/><span>헤드 퍼스트 디자인 패턴</span>
<span class=content-count>22</span></a></li><li><a href=/categories/infra/><span>Infra</span>
<span class=content-count>14</span></a></li><li><a href=/categories/nest/><span>Nest</span>
<span class=content-count>1</span></a></li><li><a href=/categories/network/><span>네트워크</span>
<span class=content-count>1</span></a></li><li><a href=/categories/node/><span>Node</span>
<span class=content-count>1</span></a></li><li><a href=/categories/problemsolving/><span>Problem Solving</span>
<span class=content-count>1</span></a></li><li><a href=/categories/project/><span>Project</span>
<span class=content-count>5</span></a></li><li><a href=/categories/realmysql/><span>Real MySQL</span>
<span class=content-count>53</span></a></li></ul><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#group-by-처리><code>GROUP BY</code> 처리</a><ol><li><a href=#타이트-인덱스-스캔을-사용하는-group-by>(타이트) 인덱스 스캔을 사용하는 <code>GROUP BY</code></a></li><li><a href=#루스-인덱스-스캔을-사용하는-group-by>루스 인덱스 스캔을 사용하는 <code>GROUP BY</code></a></li><li><a href=#임시-테이블을-사용하는-group-by>임시 테이블을 사용하는 <code>GROUP BY</code></a></li></ol></li><li><a href=#distinct-처리><code>DISTINCT</code> 처리</a><ol><li><a href=#select-distinct-><code>SELECT DISTINCT ...</code></a></li><li><a href=#집합-함수와-함께-사용된-distinct>집합 함수와 함께 사용된 <code>DISTINCT</code></a></li></ol></li><li><a href=#내부-임시-테이블-활용>내부 임시 테이블 활용</a><ol><li><a href=#메모리-임시-테이블과-디스크-임시-테이블>메모리 임시 테이블과 디스크 임시 테이블</a></li><li><a href=#임시-테이블이-필요한-쿼리>임시 테이블이 필요한 쿼리</a></li><li><a href=#임시-테이블이-디스크에-생성되는-경우>임시 테이블이 디스크에 생성되는 경우</a><ol><li><a href=#임시-테이블-관련-상태-변수>임시 테이블 관련 상태 변수</a></li></ol></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/post/real-mysql/9/2/2/><img src=/post/real-mysql/9/2/2/real_mysql_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_800x0_resize_q75_box.jpeg srcset="/post/real-mysql/9/2/2/real_mysql_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_800x0_resize_q75_box.jpeg 800w, /post/real-mysql/9/2/2/real_mysql_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_1600x0_resize_q75_box.jpeg 1600w" width=800 height=994 loading=lazy alt="Featured image of post 9.2 기본 데이터 처리(2)"></a></div><div class=article-details><header class=article-category><a href=/categories/realmysql/>Real MySQL</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/real-mysql/9/2/2/>9.2 기본 데이터 처리(2)</a></h2><h3 class=article-subtitle>Real MySQL 8.0</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2023/05/23</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>9 minute read</time></div></footer></div></header><section class=article-content><h2 id=group-by-처리><code>GROUP BY</code> 처리</h2><p><code>GROUP BY</code> 또한 <code>ORDER BY</code>와 같이 쿼리가 스트리밍된 처리를 할 수 없게 하는 처리 중 하나다. <code>GROUP BY</code>절 사용시 결과에 대한 필터링 처리를 할 수 있는 <code>HAVING</code>절을 사용할 수 있느데, <code>GROUP BY</code> 에서 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 <code>HAVING</code>절을 튜닝하려고 인덱스를 생성하거나 다른 방법을 고민할 필요는 없다.</p><p><code>GROUP BY</code> 작업도 인덱스를 사용하는 경우과 그렇지 못한 경우로 나눌 수 있다.</p><ul><li>인덱스를 이용할 때<ul><li>인덱스 스캔: 인덱스를 차례대로 읽는다.</li><li>루스 인덱스 스캔: 인덱스를 건너뛰면서 읽는다.</li></ul></li><li>인덱스를 이용하지 않을 때<ul><li>임시 테이블을 사용한다.</li></ul></li></ul><h3 id=타이트-인덱스-스캔을-사용하는-group-by>(타이트) 인덱스 스캔을 사용하는 <code>GROUP BY</code></h3><p><code>ORDER BY</code>의 경우와 마찬가지로 조인의 드라이빙 테이블에 속한 컬럼만을 이용해 그루핑 할 때 <code>GROUP BY</code> 컬럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으며 그루핑 작업을 수행하고 그 결과로 조인을 처리한다.</p><ul><li><code>GROUP BY</code>가 인덱스를 통해 처리된다고 하더라도 그룹 함수 등의 그룹값을 처리로 인해 임시 테이블이 필요할 때도 있다.</li><li><code>GROUP BY</code>가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽는 것이므로 쿼리 실행 시점에 추가적인 정렬 작업이나 내부 임시 테이블은 필요하지 않다.</li><li>이러한 그루핑 방식을 사용하는 쿼리의 실행 계획에서는 Extra 컬럼에 별도로 &ldquo;Using index for group-by&rdquo;, &ldquo;Using temporary, Using filesort"가 표시되지 않는다.</li></ul><h3 id=루스-인덱스-스캔을-사용하는-group-by>루스 인덱스 스캔을 사용하는 <code>GROUP BY</code></h3><p>루스 인덱스 스캔 방식은 인덱스의 레코드를 건너 뛰면서 필요한 부분만 읽어서 가져오는 것을 의미하는데, 옵티마이저가 루스 인덱스 스캔을 사용할 때는 실행 계획의 Extra 컬럼에 &ldquo;Using index for group-by&rdquo; 코멘트가 표시된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>emp_no</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>salaries</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>from_date</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;1985-03-01&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>emp_no</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><hr><div class=table-wrapper><table><thead><tr><th>id</th><th>table</th><th>type</th><th>key</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>salaries</td><td>range</td><td>PRIMARY</td><td>Using where; Using index for group-by</td></tr></tbody></table></div><p><code>salaries</code> 테이블의 인덱스는 (emp_no, from_date)로 생성돼 있으므로 위의 쿼리 문장에서 <code>WHERE</code> 조건은 인덱스 레인지 스캔 접근 방식으로 이용할 수 없는 쿼리지만, 인덱스 레인지 스캔을 이용했으며, <code>GROUP BY</code> 처리까지 인덱스르 사용했다.</p><ol><li>(emp_no, from_date) 인덱스를 차례대로 스캔하면서 emp_no의 첫 번째 유일한 값(그룹 키)를 찾아낸다.</li><li>(emp_on, from_date) 인덱스에서 emp_no가 &lsquo;10001&rsquo;인 것 중에서 from_date 값이 &lsquo;1985-03-01&rsquo;인 레코드만 가져온다.</li><li>인덱스에서 emp_no의 그다음 유니크한(그룹 키) 값을 가져온다.</li><li>3번 단계에서 결과가 더 없으면 처리를 종료하고, 결과가 있다면 2번 과정으로 돌아가서 반복 수행한다.</li></ol><hr><ul><li>MySQL 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 <code>GROUP BY</code> 처리에만 사용할 수 있다.</li><li>프리픽스 인덱스(Prefix index, 컬럼의 앞쪽 일부만으로 생성된 인덱스)는 루스 인덱스 스킨을 사용할 수 없다.</li><li>인덱스 레인지 스캔에서는 유니크한 값의 수가 많을수록 성능이 향상되는 반면 루스 인덱스 스캔에서는 인덱스의 유니크한 값의 수가 적을수록 성능이 향상된다.<ul><li>루스 인덱스 스캔은 분포도가 좋지 않은 인덱스일수록 더 빠른 결과를 만들어낸다.</li></ul></li><li>루스 인덱스 스캔으로 처리되는 쿼리에서는 별도의 임시 테이블이 필요하지 않다.</li></ul><hr><p>루스 인덱스 스캔이 사용될 수 있을지 없을지 판단하는 것은 <code>WHERE</code>절의 조건이나 <code>ORDER BY</code> 절이 인덱스를 사용할 수 있을지 없을지 판단하는 것보다는 더 어렵다.</p><ul><li><code>MIN</code>, <code>MAX</code> 의외의 집합 함수가 사용된 경우 루스 인덱스 스캔 사용 불가</li><li><code>GROUP BY</code>에 사용된 컬럼이 인덱스 구성 컬럼의 왼쪽부터 일치하지 않는 경우 사용 불가</li><li><code>SELECT</code> 절의 컬럼이 <code>GROUP BY</code>와 일치하지 않는 경우 사용 불가</li></ul><blockquote><p>MySQL 8 버전부터는 루스 인덱스 스캔과 동일한 방식으로 작동하는 인덱스 스킵 스캔 최적화도 도입됐다. 이에 따라 옵티마이저가 쿼리에서 필요로 하는 레코드를 검색하는 부분까지 루스 인덱스 스캔 방식으로 최적화가 가능해졌다. 인덱스 스킵 스캔 또한 루스 인덱스 스캔과 마찬가지로 조건이 누락된 인덱스의 선행 컬럼이 유니크한 값을 많이 가질수록 쿼리 처리 성능이 떨어지게 되어 선행 컬럼의 유니크한 값의 개수가 많으면 인덱스 스킵 최적화를 사용하지 않게 된다.</p></blockquote><h3 id=임시-테이블을-사용하는-group-by>임시 테이블을 사용하는 <code>GROUP BY</code></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=n>last_name</span><span class=p>,</span><span class=w> </span><span class=nf>AVG</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>salary</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=n>e</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=n>salaries</span><span class=w> </span><span class=n>s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>emp_no</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=n>emp_no</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=n>last_name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><hr><div class=table-wrapper><table><thead><tr><th>id</th><th>table</th><th>type</th><th>key</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>e</td><td>ALL</td><td>NULL</td><td>300584</td><td>Using temporary</td></tr><tr><td>1</td><td>s</td><td>ref</td><td>PRIMARY</td><td>10</td><td>NULL</td></tr></tbody></table></div><p>위 쿼리의 실행 계획에서는 Extra 컬럼에 &ldquo;Using temporary&rdquo; 메시지가 표시되었는데, 이는 <code>employees</code>를 풀 스캔하기 때문이 아니라 인덱스를 전혀 사용할 수 없는 <code>GROUP BY</code>이기 때문이다.</p><p>Extra 컬럼에 &ldquo;Using filesort"가 표시되지 않은 이유는 기존에는 <code>GROUP BY</code>가 사용된 쿼리는 그루핑 되는 컬럼을 기준으로 묵시적인 정렬까지 실행되었으나 MySQL 8 버전으로 업그레이드 되며 묵시적인 정렬을 처리하지 않기 때문이다.</p><p>MySQL 8에서는 <code>GROUP BY</code>가 필요한 경우 내부적으로 <code>GROUP BY</code> 절의 컬럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어 중복 제거와 집합 함수 연산을 수행한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=n>TEMPORARY</span><span class=w> </span><span class=k>TABLE</span><span class=p>...</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>last_name</span><span class=w> </span><span class=kt>VARCHAR</span><span class=p>(</span><span class=mi>16</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>salary</span><span class=w> </span><span class=kt>INT</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=nf>ux_lastname</span><span class=p>(</span><span class=n>last_name</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>그리고 조인의 결과를 한 건씩 가져와 임시 테이블에서 중복 체크를 하면서 <code>INSERT</code>, <code>UPDATE</code>를 실행하여, 별도의 정렬 작업 없이 <code>GROUP BY</code>가 처리된다.</p><p>하지만 MySQL 8.0에서도 <code>ORDER BY</code>가 같이 사용되면 명시적으로 정렬 작업을 실행한다.</p><h2 id=distinct-처리><code>DISTINCT</code> 처리</h2><p>특정 컬럼의 유니크한 값만 조회하려면 <code>SELECT</code> 쿼리에 <code>DISTINT</code>를 사용한다. <code>DISTINT</code> 같은 경우 집합 함수와 함께 사용되는 경우 키워드가 영향을 미치는 범위가 다르다. 또한 집합 함수와 같이 사용될 때 인덱스를 사용하지 못할 때는 항상 임시 테이블이 필요하지만 Extra 컬럼에 &ldquo;Using temporary&rdquo; 메시지가 출력되지 않는다.</p><h3 id=select-distinct-><code>SELECT DISTINCT ...</code></h3><p>단순히 조회되는 레코드 중에서 유니크한 레코드만 가져오고자 하면 <code>SELECT DISTINCT</code> 형태의 쿼리 문장을 사용한다. 이 경우에는 <code>GROUP BY</code>와 동일한 방식으로 처리되며 특히 MySQL 8.0 버전부터는 <code>GROUP BY</code>를 수행하는 쿼리에 <code>ORDER BY</code>절이 없으면 정렬을 사용하지 않기 때문에 아래 쿼리는 같은 방식으로 처리된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w> </span><span class=n>emp_no</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>salaries</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>emp_no</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>salaries</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>emp_no</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><hr><ul><li><code>DISTINT</code>는 <code>SELECT</code>하는 레코드(튜플)을 유니크하게 조회하는 것이지, 특정 컬럼만 유니크하게 조회하는 것이 아니다.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w> </span><span class=n>first_name</span><span class=p>,</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><code>DISTINT</code>는 함수처럼 동작하지 않는다.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=p>(</span><span class=n>first_name</span><span class=p>),</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>실제 처리시 의미 없는 괄호로 판단하여 제거된다.</li></ul></li></ul><p><code>SELECT</code> 절에 사용된 <code>DISTINCT</code> 키워드는 조회되는 모든 컬럼에 영향을 미치지만, 집합 함수와 함께 사용된 경우 조금 다르게 처리된다.</p><h3 id=집합-함수와-함께-사용된-distinct>집합 함수와 함께 사용된 <code>DISTINCT</code></h3><p><code>COUNT</code>, <code>MIN</code>, <code>MAX</code> 같은 집합 함수 내에서 <code>DISTINCT</code> 키워드가 사용될 수 있는데, 이 경우에는 일반적으로 다른 형태로 해석된다. 집합 함수가 없는 조회 쿼리에서는 조회하는 모든 컬럼의 조합이 유니크한 것들만 가져오지만, 집합 함수 내에서 사용될 경우 집합 함수의 인자로 전달된 컬럼 값이 유니크한 것들을 가져온다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=nf>COUNT</span><span class=p>(</span><span class=k>DISTINCT</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>salary</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=n>e</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=n>salaries</span><span class=w> </span><span class=n>s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=n>emp_no</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>emp_no</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>AND</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=n>emp_no</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=mi>100001</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=mi>100100</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><hr><div class=table-wrapper><table><thead><tr><th>id</th><th>table</th><th>type</th><th>key</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>e</td><td>range</td><td>PRIMARY</td><td>100</td><td>Using where; Using index</td></tr><tr><td>1</td><td>s</td><td>ref</td><td>PRIMARY</td><td>10</td><td>NULL</td></tr></tbody></table></div><p>위 쿼리는 내부적으로 <code>COUNT(DISTINCT s.salary)</code>를 처리하기 위해 임시 테이블을 사용하지만, 실행 계획에서 &ldquo;Using temporary"를 표시하지 않는다.</p><p><code>employees</code> 테이블과 <code>salaries</code> 테이블을 조인한 결과에서 <code>salary</code> 컬럼의 값만 저장하기 위한 임시 테이블을 만드렁 사용한다. 이때 임시 테이블의 <code>salary</code>컬럼에는 유니크 인덱스가 생성되기 때문에 레코드 건수가 많아진다면 상당히 느려질 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=nf>COUNT</span><span class=p>(</span><span class=k>DISTINCT</span><span class=w> </span><span class=n>emp_no</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=nf>COUNT</span><span class=p>(</span><span class=k>DISTINCT</span><span class=w> </span><span class=n>emp_no</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>dept_emp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>dept_no</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><hr><div class=table-wrapper><table><thead><tr><th>id</th><th>table</th><th>type</th><th>key</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>dept_emp</td><td>index</td><td>PRIMARY</td><td>331143</td><td>Using index</td></tr></tbody></table></div><p>인덱스된 컬럼에 대해 <code>DISTINCT</code> 처리를 수행할 때는 인덱스를 풀 스캔하거나 레인지 스캔하면서 임시 테이블 없이 최적화된 처리를 수행할 수 있다.</p><h2 id=내부-임시-테이블-활용>내부 임시 테이블 활용</h2><p>MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블(Internal temporary table)을 사용한다. 일반적으로 MySQL 엔진이 사용하는 임시 테이블은 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다. 물론 특정 예외 케이스에는 메모리를 거치지 않고 바로 디스크에 임시 테이블이 만들어지기도 한다.</p><p>MySQL 엔진이 내부적인 가공을 위해 생성하는 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수 없으며 사용하는 것도 불가능하다. 사용자가 생성한 임시 테이블과는 달리 내부적인 임시 테이블은 쿼리의 처리가 완료되면 자동으로 삭제된다.</p><h3 id=메모리-임시-테이블과-디스크-임시-테이블>메모리 임시 테이블과 디스크 임시 테이블</h3><p>MySQL 8.0 이전 버전까지는 원본 테이블의 스토리지 엔진과 관계없이 임시 테이블이 메모리를 사용할 때는 MEMORY 스토리지 엔진을 사용하며, 디스크에 저장될 때는 MyISAM 스토리지 엔진을 이용했다.</p><ul><li>MEMORY 스토리지 엔진<ul><li><code>VARBINARY</code>, <code>VARCHAR</code> 같은 가변 길이 타일을 지원하지 못하기 때문에 임시 테이블이 메모리에 만들어지게 되면 가변 길이 타입의 경우 최대 길이만큼 메모리를 할당하여 메모리 낭비가 심해지는 문제가 있었다.</li></ul></li><li>MyISAM 스토리지 엔진<ul><li>트랜잭션을 지원하지 못한다.</li></ul></li></ul><p>이러한 문제로 인해 MySQL 8.0 버전 부터는 TempTable 이라는 스토리지 엔진을 사용하고, 디스크에 저장되는 임시 테이블은 InnoDB 스토리지 엔진을 사용하도록 개선되었다.</p><ul><li><code>internal_tmp_mem_storage_engine</code>: 시스템 변수를 이용해 메모리용 임시 테이블을 MEMORY와 TempTable 중에서 선택할 수 있으며 기본값은 TempTable이다.</li><li><code>temptable_max_ram</code>: TempTable이 최대한 사용 가능한 메모리 공간의 크기를 제어할 수 있으며 기본값은 1GB이다.</li><li><code>temptable_usemmap</code>: 임시 테이블의 크기가 1GB보다 커지는 경우 MySQL 서버는 메모리의 임시 테이블을 디스크로 기록하는데, 2가지 방법 중 하나를 선택하며 기본값은 ON이며 OFF시 InnoDB 테이블로 기록한다.<ul><li>MMAP 파일로 디스크에 기록: InnoDB 테이블로 전환하는 것 보다 오버헤드가 적다.</li><li>InnoDB 테이블로 기록</li></ul></li><li><code>internal_tmp_disk_storage_engine</code>: 내부 임시 테이블이 메모리에 생성되지 않고 처음부터 디스크 테이블로 생성되는 경우 해당 시스템 변수를 따라 생성되며 기본값은 InnoDB이다.</li></ul><h3 id=임시-테이블이-필요한-쿼리>임시 테이블이 필요한 쿼리</h3><p>다음과 같은 패턴의 쿼리는 MySQL엔진에서 별도의 데이터 가공 작업을 필요로 하므로 대표적으로 내부 임시 테이블을 생성하는 케이스다.</p><ul><li><code>ORDER BY</code>와 <code>GROUP BY</code>에 명시된 컬럼이 다른 쿼리</li><li><code>ORDER BY</code>, <code>GROUP BY</code>에 면시된 컬럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리</li><li><code>DISTINCT</code>와 <code>ORDER BY</code>가 동시에 쿼리에 존재하는 경우 또는 <code>DISTINCT</code>가 인덱스로 처리되지 못하는 쿼리</li><li><code>UNION</code>이나 <code>UNION DISTINCT</code>가 사용된 쿼리(select_type 컬럼이 <code>UNION RESULT</code>인 경우)</li><li>쿼리 실행 계획에서 <code>select_type</code>이 <code>DERIVED</code>인 쿼리</li></ul><p>쿼리의 실행 계획에서 임시 테이블을 사용 여부는 Extra 컬럼에서 &ldquo;Using temporary"라는 메시지가 표시되는지 확인한다. 하지만 메시지가 표시되지 않는 경우에도 임시 테이블을 사용할 수 있으며, 마지막 3개 패턴이 그러한 경우다.</p><p>첫 번째부터 네 번째까지의 쿼리 패턴은 유니크 인덱스를 가지는 내부 임시 테이블이 만들어지고, 마지막 쿼리 패턴은 유니크 인덱스가 없는 내부 임시 테이블이 생성된다.</p><p>일반적으로 유니크 인덱스가 있는 내부 임시 테이블은 그렇지 않은 쿼리보다 처리 성능이 상당히 느리다.</p><h3 id=임시-테이블이-디스크에-생성되는-경우>임시 테이블이 디스크에 생성되는 경우</h3><p>내부 임시 테이블은 기본적으로는 메모리상에 만들어지지만 다음과 같은 조건을 만족하면 메모리 임시 테이블을 사용할 수 없게 되어 디스크 기반의 임시 테이블을 사용한다.</p><ul><li><code>UNION</code>이나 <code>UNION ALL</code>에서 <code>SELECT</code>되는 컬럼 중 길이가 512바이트 이상인 크기의 컬럼이 있는 경우</li><li><code>GROUP BY</code>나 <code>DISTINCT</code> 컬럼에서 512 바이트 이상인 컬럼이 있는 경우</li><li>메모리 임시 테이블의 크기가 시스템 변수의 크기보다 큰 경우(<code>tmp_table_size</code>, <code>max_heap_table_size</code>, <code>temptable_max_ram</code>)</li></ul><h4 id=임시-테이블-관련-상태-변수>임시 테이블 관련 상태 변수</h4><p>실행 계획상에서 &ldquo;Using temporary"가 표시되면 임시 테이블을 사용햇다는 사실을 알 수 있지만 임시 테이블이 메모리에서 처리됐는지 디스크에서 처리됐는지는 알 수 없으며, 몇개의 임시 테이블이 사용됐는지도 알 수 없다.</p><p>임시 테이블의 생성 방식을 확인하려면 MySQL 서버의 상태 변수를 확인해보면 된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>FLUSH</span><span class=w> </span><span class=n>STATUS</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>first_name</span><span class=p>,</span><span class=w> </span><span class=n>last_name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>first_name</span><span class=p>,</span><span class=w> </span><span class=n>last_name</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SHOW</span><span class=w> </span><span class=n>SESSION</span><span class=w> </span><span class=n>STATUS</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s1>&#39;Created_tmp%&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li><code>Created_tmp_tables</code>: 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태값이다. 내부 임시 테입르이 메모리에 만들어 졌는지를 구분하지 않고 모두 누적한다.</li><li><code>Created_tmp_disk_tables</code>: 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 가지고 있는 상태값이다.</li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/db/>DB</a>
<a href=/tags/mysql/>MySQL</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/post/real-mysql/16/7/4/><div class=article-image><img src=/post/real-mysql/16/7/4/real_mysql.335f5c2fc94dc22cf816a9c1393301d9_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_250x150_fill_q75_box_smart1.jpeg width=250 height=150 loading=lazy alt="Featured image of post 16.7.4 복제 고급 설정 - 필터링된 복제(Filterd Replication)" data-key=real-mysql/16/7/4 data-hash="md5-M19cL8lNwiz4FqnBOTMB2Q=="></div><div class=article-details><h2 class=article-title>16.7.4 복제 고급 설정 - 필터링된 복제(Filterd Replication)</h2></div></a></article><article class=has-image><a href=/post/real-mysql/16/7/3/><div class=article-image><img src=/post/real-mysql/16/7/3/real_mysql.335f5c2fc94dc22cf816a9c1393301d9_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_250x150_fill_q75_box_smart1.jpeg width=250 height=150 loading=lazy alt="Featured image of post 16.7.3 복제 고급 설정 - 크래시 세이프 복제(Crash-safe Replication)" data-key=real-mysql/16/7/3 data-hash="md5-M19cL8lNwiz4FqnBOTMB2Q=="></div><div class=article-details><h2 class=article-title>16.7.3 복제 고급 설정 - 크래시 세이프 복제(Crash-safe Replication)</h2></div></a></article><article class=has-image><a href=/post/real-mysql/16/7/2/><div class=article-image><img src=/post/real-mysql/16/7/2/real_mysql.335f5c2fc94dc22cf816a9c1393301d9_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_250x150_fill_q75_box_smart1.jpeg width=250 height=150 loading=lazy alt="Featured image of post 16.7.2 복제 고급 설정 - 멀티 스레드 복제" data-key=real-mysql/16/7/2 data-hash="md5-M19cL8lNwiz4FqnBOTMB2Q=="></div><div class=article-details><h2 class=article-title>16.7.2 복제 고급 설정 - 멀티 스레드 복제</h2></div></a></article><article class=has-image><a href=/post/real-mysql/16/7/1/><div class=article-image><img src=/post/real-mysql/16/7/1/real_mysql.335f5c2fc94dc22cf816a9c1393301d9_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_250x150_fill_q75_box_smart1.jpeg width=250 height=150 loading=lazy alt="Featured image of post 16.7.1 복제 고급 설정 - 지연된 복제" data-key=real-mysql/16/7/1 data-hash="md5-M19cL8lNwiz4FqnBOTMB2Q=="></div><div class=article-details><h2 class=article-title>16.7.1 복제 고급 설정 - 지연된 복제</h2></div></a></article><article class=has-image><a href=/post/real-mysql/16/6/><div class=article-image><img src=/post/real-mysql/16/6/real_mysql.335f5c2fc94dc22cf816a9c1393301d9_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_250x150_fill_q75_box_smart1.jpeg width=250 height=150 loading=lazy alt="Featured image of post 16.6 복제 - 복제 토폴로지" data-key=real-mysql/16/6 data-hash="md5-M19cL8lNwiz4FqnBOTMB2Q=="></div><div class=article-details><h2 class=article-title>16.6 복제 - 복제 토폴로지</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=codemario318/codemario318.github.io issue-term=pathname label=Comment crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2023 -
2024 Mario Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>