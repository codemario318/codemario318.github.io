<!doctype html><html lang=ko dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Real MySQL 8.0"><title>16.7.2 복제 고급 설정 - 멀티 스레드 복제</title><link rel=canonical href=https://codemario318.github.io/post/real-mysql/16/7/2/><link rel=stylesheet href=/scss/style.min.cbce94e2760d14d60414e59d5a36ab2819232375817e010dbe7be2234b67da1b.css><meta property="og:title" content="16.7.2 복제 고급 설정 - 멀티 스레드 복제"><meta property="og:description" content="Real MySQL 8.0"><meta property="og:url" content="https://codemario318.github.io/post/real-mysql/16/7/2/"><meta property="og:site_name" content="Mario Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="DB"><meta property="article:tag" content="MySQL"><meta property="article:published_time" content="2023-09-16T17:44:10+09:00"><meta property="article:modified_time" content="2023-09-16T17:44:10+09:00"><meta property="og:image" content="https://codemario318.github.io/post/real-mysql/16/7/2/real_mysql.jpeg"><meta name=twitter:title content="16.7.2 복제 고급 설정 - 멀티 스레드 복제"><meta name=twitter:description content="Real MySQL 8.0"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://codemario318.github.io/post/real-mysql/16/7/2/real_mysql.jpeg"><script async src="https://www.googletagmanager.com/gtag/js?id=G-K99591YLGK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K99591YLGK",{anonymize_ip:!1})}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3183752545292673" crossorigin=anonymous></script><meta name=naver-site-verification content="2315bde85c86f66092140cc465c340a2170f3187"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu760fd15c5fbb2f30cf0868dc4a5dc41a_14271_300x0_resize_q75_box.jpeg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Mario Blog</a></h1><h2 class=site-description></h2></div></header><ol class=social-menu><li><a href=https://github.com/codemario318 target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><ul class="menu sub-menu"><li><a href=/categories/backend/><span>Backend</span>
<span class=content-count>3</span></a></li><li><a href=/categories/boostcamp/><span>부스트캠프</span>
<span class=content-count>6</span></a></li><li><a href=/categories/cleancode/><span>Clean Code</span>
<span class=content-count>10</span></a></li><li><a href=/categories/common/><span>Common</span>
<span class=content-count>57</span></a></li><li><a href=/categories/data/><span>Data</span>
<span class=content-count>3</span></a></li><li><a href=/categories/db/><span>DB</span>
<span class=content-count>1</span></a></li><li><a href=/categories/frontend/><span>Frontend</span>
<span class=content-count>10</span></a></li><li><a href=/categories/golang/><span>GoLang</span>
<span class=content-count>13</span></a></li><li><a href=/categories/headfirstdesignpatterns/><span>헤드 퍼스트 디자인 패턴</span>
<span class=content-count>22</span></a></li><li><a href=/categories/infra/><span>Infra</span>
<span class=content-count>14</span></a></li><li><a href=/categories/network/><span>네트워크</span>
<span class=content-count>1</span></a></li><li><a href=/categories/node/><span>Node</span>
<span class=content-count>1</span></a></li><li><a href=/categories/problemsolving/><span>Problem Solving</span>
<span class=content-count>1</span></a></li><li><a href=/categories/project/><span>Project</span>
<span class=content-count>5</span></a></li><li><a href=/categories/realmysql/><span>Real MySQL</span>
<span class=content-count>53</span></a></li></ul><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#데이터-베이스-기반-멀티-스레드-복제>데이터 베이스 기반 멀티 스레드 복제</a></li><li><a href=#logical-clock-기반-멀티-스레드-복제>LOGICAL CLOCK 기반 멀티 스레드 복제</a><ol><li><a href=#바이너리-로그-그룹-커밋>바이너리 로그 그룹 커밋</a></li><li><a href=#commit-parent-기반-방식>Commit-parent 기반 방식</a></li><li><a href=#잠금-기반-방식>잠금 기반 방식</a></li><li><a href=#writeset-기반-방식>WriteSet 기반 방식</a></li></ol></li><li><a href=#멀티-스레드-복제와-복제-포지션-정보>멀티 스레드 복제와 복제 포지션 정보</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/post/real-mysql/16/7/2/><img src=/post/real-mysql/16/7/2/real_mysql_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_800x0_resize_q75_box.jpeg srcset="/post/real-mysql/16/7/2/real_mysql_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_800x0_resize_q75_box.jpeg 800w, /post/real-mysql/16/7/2/real_mysql_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_1600x0_resize_q75_box.jpeg 1600w" width=800 height=994 loading=lazy alt="Featured image of post 16.7.2 복제 고급 설정 - 멀티 스레드 복제"></a></div><div class=article-details><header class=article-category><a href=/categories/realmysql/>Real MySQL</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/real-mysql/16/7/2/>16.7.2 복제 고급 설정 - 멀티 스레드 복제</a></h2><h3 class=article-subtitle>Real MySQL 8.0</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2023/09/16</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>16 minute read</time></div></footer></div></header><section class=article-content><p>MySQL 복제에서는 레플리카 서버에서 소스 서버로부터 복제된 트랜잭션들을 하나의 스레드가 아닌 여러 스레드로 처리할 수 있게 하는 멀티 스레드 복제 기능을 제공한다.</p><p>소스 서버에서는 여러 세션에서 실행된 DML 쿼리들이 동시에 처리되는데, 소스 서버에서 짧은 시간 동안 다량의 DML 쿼리가 실행되는 경우 MySQL 5.6 버전 미만의 레플리카 서버에서는 하나의 스레드가 모든 트랜잭션을 처리하므로 복제 동기화에 지연이 발생한다.</p><p>또한 하나의 스레드로만 복제가 동기화 되는것은 멀티코어 CPU가 장착된 서버를 사용하는 환경에서는 서버의 자원을 충분히 활용하지 못하는 비효율적인 방식이었다.</p><pre class=mermaid style=text-align:center>flowchart LR
    a[Relay Log]-->b([Coordinator Thread])

    subgraph Worker 1
        direction LR
        c[[Queue]] -->
        d([Worker Thread])
    end

    subgraph Worker 2
        direction LR
        e[[Queue]] -->
        f([Worker Thread])
    end

    subgraph Worker N
        direction LR
        g[[Queue]] -->
        h([Worker Thread])
    end
    
    b-->c
    b-->e
    b-->g
</pre><p>기존 단일 스레드 복제에서는 레플리케이션 SQL 스레드가 릴레이 로그 파일을 읽어서 바로 트랜잭션을 적용하는 형태였다면 멀티 스레드 복제에서는 SQL 스레드는 코디네이터 스레드(Coordinator Thread)로 불리며, 실제로 이벤트를 실행하는 스레드인 워커 스레드와 협업해서 동기화를 진행한다.</p><ul><li>코디네이터 스레드는 릴레이 로그 파일에서 이벤트들을 읽은 뒤 설정된 방식에 따라 스케줄링 해서 워커 스레드에 각 이벤트를 할당한다.</li><li>각 이벤트는 워커 스레드들의 큐에 적재되며 워커 스레드는 큐에서 이벤트들을 꺼내 순차적으로 레플리카 서버에 적용한다.</li></ul><p>멀티 스레드 복제는 소스 서버로부터 복제된 트랜잭션들을 어떻게 병렬로 처리할 것인가에 따라 데이터베이스 기반과 LOGICAL CLOCK 기반 처리 방식으로 나뉜다.</p><ul><li><code>slave_parallel_type</code><ul><li>병렬 처리 방식 설정</li><li>기본적으로 데이터베이스 기반 방시긍로 설정</li></ul></li><li><code>parallel_workers</code> 시스템 변수를 통해 워커 스레드의 개수를 지정할 수 있다.<ul><li>0 ~ 1024 까지 설정 가능</li><li>1로 설정하면 스레드 복제를 위한 코드 블록이 모두 실행되면서 실제 복제는 단을 스레드처럼 처리됨</li><li>0으로 설정시 단일 스레드 모드로 복제 수행, 부가적인 작업 처리를 수행하지 않음</li></ul></li><li><code>slave_pending_jobs_size_max</code><ul><li>시스템 변수를 통해 워커 스레드의 큐에 할당할 수 있는 최대 메모리 크기를 설정</li><li>MySQL 8.0 기본값은 128MB</li><li>작은 이벤트들이 빈번하게 발생하는 OLTP 환경에서는 기본값도 문제 없음</li><li>소스 서버로부터 전달받은 이벤트 크기가 설정된 값을 초과하는 경우 모든 워커 스레드들의 큐가 바위질 때 까지 대기후 처리됨</li><li>복제 지연이 발생할 수 있으므로 적절히 큰 값 설정 필요</li></ul></li></ul><p><code>SHOW PROCESSLIST</code> 명령을 통해 코디네이터 스레드와 워커 스레드를 확인할 수 있다.</p><h2 id=데이터-베이스-기반-멀티-스레드-복제>데이터 베이스 기반 멀티 스레드 복제</h2><p>데이터베이스 기반 멀티 스레드 복제 방식은 스키마 기반 처리 방식이라고도 하며, 멀티 스레드 복제가 처음 도입됐을 때 유일하게 사용할 수 있었던 방식이다.</p><p>데이터 베이스 기반 멀티 스레드 복제는 MySQL 내의 데이터베이스 단위로 병렬 처리를 수행하는 형태를 말한다.</p><ul><li>MySQL 서버에 데이터베이스가 하나밖에 존재하지 않는다면 장점을 가지지 못한다.</li><li>여러 개의 데이터베이스가 있다면 레플리카 서버에서는 데이터베이스 개수 만큼 워커 스레드 수를 설정하는 것이 좋다.</li></ul><p>코디네이터 스레드는 릴레이 로그 파일에서 이벤트를 읽어 데이터베이스 단위로 분리하고 각 워커 스레드에게 이벤트들을 할당한다.</p><pre class=mermaid style=text-align:center>flowchart LR
    a[트랜잭션 3: UPDATE DB3<br>UPDATE DB1<br>트랜잭션 2: UPDATE DB2<br>트랜잭션 3: UPDATE DB1]
    b([코디네이터 스레드])
    c([워커 스레드 1<br>1. UPDATE DB1<br>트랜잭션 1])
    d([워커 스레드 2<br>2. UPDATE DB2<br>트랜잭션 2])
    e([워커 스레드 3<br>3. UPDATE DB3<br>트랜잭션 3])
    
    a--4. UPDATE DB1<br>트랜잭션 3-->b
    b-->c
    b-->d
    b-->e
</pre><p>위의 트랜잭션 3의 마지막 처리인 <code>UPDATE DB1</code> 같은 경우 워커 스레드 1이 이미 처리중이므로 해당 작업을 완료될때까지 기다리게 된다.</p><ul><li>데이터베이스 기반 멀티 스레드 복제에서는 테이블이나 레코드 수준까지의 충돌 여부는 고려하지 않고 데이터베이스가 동일한지만 비교하기때문에, 변경 대상 테이블이나 레코드는 다르다고 하더라도 대기한다.</li><li>트랜잭션 3의 <code>UPDATE DB1</code>이 대기하고 있는 상황에서, 워커 스레드 2의 작업이 이미 완료되고 네 번째 트랜잭션으로 또 다른 DB2 변경 작업이 들어온다고 하더라도 대기하게 된다.</li></ul><p>이러한 처리로 인해 서로 다른 데이터베이스를 참조하는 쿼리나 트랜잭션이 빈번하게 실행되는 경우 예상했던 것보다 멀티 스레드 처리 효율이 낮아질 수 있다.</p><ul><li>하지만 MySQL 서버에 여려 개의 데이터베이스가 존재하고 각 데이터베이스에 유입되는 DML이 서로 독립적이면서 균등하게 실행되는 환경이라면 데이터기반 멀티 스레드 복제가 단일 스레드 복제보다 월등한 처리량을 보인다.</li></ul><p>데이터베이스 기반 멀티 스레드 복제를 사용하려면 레플리카 서버를 다음과 같이 설정 후 복제를 연결하면 된다.</p><ul><li>기존에 이미 단일 스레드 복제가 진행되고 있는 상황에서 데이터베이스 기반 멀티 스레드 복제로 전환하고 싶다면 SQL 스레드만 멈춘 후 멀티 스레드 복제를 설정하고 다시 시작하면 된다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[mysqld]
</span></span><span class=line><span class=cl>slave_parallel_type=&#39;DATABASE&#39;
</span></span><span class=line><span class=cl>slave_parallel_workers=N (N&gt;0)
</span></span></code></pre></td></tr></table></div></div><p>데이터베이스 기반 멀티 스레드 복제에서는 레플리카 서버가 자체적으로 바이너리 로그를 가지고 <code>log_slave_updates</code> 있고 옵션이 활성화되어 있을 때 소스 서버의 바이너리 로그에 기록된 트랜잭션 순서와 레플리카 서버의 바이너리 로그에 기록된 트랜잭션 순서가 다를 수 있다.</p><ul><li>레플리카 서버의 멀티 스레드 복제 동기화에서 각 트랜잭션이 처리된 시점에 따라 실제 소스 서버에서 실행된 것과는 순서가 달라질 수 있기 때문</li><li>소스 서버에서 가장 최근에 싫애된 트랜잭션을 레플리카 서버에서 확인한다고 했을 때 소스 서버에서 그 트랜잭션 이전에 실행된 모든 트랜잭션들이 레플리카 서버에도 전부 실행되었다고 보장하긴 어렵다.</li></ul><h2 id=logical-clock-기반-멀티-스레드-복제>LOGICAL CLOCK 기반 멀티 스레드 복제</h2><p>MySQL 5.7 버전부터 소스 서버로부터 넘어온 전체 트랜잭션들을 데이터베이스에 종속되지 않고 멀티 스레드로 처리하는, 즉 같은 데이터베이스 내에서도 멀티 스레드 동기화 처리가 가능한 LOGICAL CLOCK 방식이 도입되어 데이터 베이스 기반 멀티 스레드 복제의 아쉬움을 해소할 수 있게 되었다.</p><p>LOGICAL CLOCK 기반 멀티 스레드 복제는 소스 서버에서 트랜잭션들이 바이너리 로그로 기록될 때 각 트랜잭션별로 논리적인 순번 값을 부여해 레플리카 서버에서 트랜잭션의 순번 값을 바탕으로 정해진 기준에 따라 병렬로 실행하는 방식이다.</p><p>트랜잭션이 병렬로 처리될 수 있다고 여겨지는 기준은 같은 상황에서도 세부 처리 방식에 따라 달라딘다.</p><ul><li>Commit-parent 기반 방식</li><li>잠금(Lock) 기반 방식</li><li>WriteSet 기반 방식</li></ul><h3 id=바이너리-로그-그룹-커밋>바이너리 로그 그룹 커밋</h3><p>MySQL 5.5 버전까지는 InnoDB 스토리지 엔진에서 한 시점에 하나의 트랜잭션만 커밋될 수 있었으며, 바이너리 로그에 트랜잭션을 기록하고 디스크와 동기화하는 부분도 마찬가지로 여러 트랜잭션이 동시에 진행될 수 없었다.</p><pre class=mermaid style=text-align:center>sequenceDiagram
    클라이언트->>MySQL: COMMIT;
    MySQL->>스토리지 엔진: prepare;
    MySQL->>바이너리 로그: write;
    MySQL->>바이너리 로그: fsync;
    MySQL->>스토리지 엔진: commit;
    MySQL-->>클라이언트: OK;     
</pre><p>클라이언트로부터 커밋 요청이 들어오면 MySQL 서버에서는 <strong>Prepare</strong>, <strong>Commit</strong> 두 단계를 거쳐 머닛을 처리하는데, 이를 분산 트랜잭션 이라고 한다.</p><ul><li>분산 트랜잭션은 트랜잭션을 커밋할 때 스토리지 엔진에 적용된 내용과 바이너리 로그에 기록된 내용 간의 일관성을 유지하기 위해 사용된다.</li></ul><p>커밋을 처리하는 과정에서 바이너리 로그에 기록한 내용을 디스크와 동기화하는 <strong>fsync</strong> 작업은 <code>sync_binlog</code> 시스템 변수에 설정된 값에 따라 실행 여부와 실행 빈도수가 결정된다</p><ul><li>1: 트랜잭션이 커밋될 때마다 디스크 동기화를 수행<ul><li>빈번하게 수행되는 디스크 동기화 작업은 서버에 부하가 발생한다.</li><li>트랜잭션 처리량 저하를 야기한다.</li></ul></li></ul><p>이 같은 처리 성능 저하 문제를 개선하기 위해 MySQL 5.6 버전에서는 여러 트랜잭션에 대한 커밋을 동시에 진행할 수 있게 바뀌었고, 바이너리 로그 단의 처리 또한 여러 트랜잭션을 함께 처리할 수 있도록 <strong>바이너리 로그 그룹 커밋</strong> 기능이 도입되었다.</p><p><img src=/post/real-mysql/16/7/2/img.png width=1000 height=341 srcset="/post/real-mysql/16/7/2/img_hud40a29e068a8849a6247d53c5152b379_62213_480x0_resize_box_3.png 480w, /post/real-mysql/16/7/2/img_hud40a29e068a8849a6247d53c5152b379_62213_1024x0_resize_box_3.png 1024w" loading=lazy alt="바이너리 로그 그룹 커밋 과정" class=gallery-image data-flex-grow=293 data-flex-basis=703px></p><p>바이너리 로그 그룹 커밋에서 트랜잭션들은 커밋 처리 과정 중 <strong>Prepare</strong>이후 바이너리 로그 관련 처리를 진핼할 때 세 단계를 거치면서 최종적으로 그룹 커밋된다.</p><ul><li>트랜잭션들은 순서대로 대기 큐에 등록된다.<ul><li>비어있는 대기 큐에 첫번째로 등록된 트랜잭션을 리더(Leader)라고 하며, 이후 등록된 다른 트랜잭션들은 팔로워(Follower) 라고 한다.</li></ul></li><li>팔로워는 리더에게 자신의 트랜잭션 처리에 대한 모든 것을 일임하며, 리더는 큐에 등록된 모든 팔로워들을 가져와 처리하고 다음 단계의 대기 큐에 등록한다.</li><li>다음 단계의 큐에 등록될 때는 큐가 비어있지 않은 경우 리더는 팔로워가되고 해당 큐의 리더가 그 단계에서의 처리를 주도하게 된다.<ul><li>리더는 팔로워가 될 수 있으나 팔로워는 절대 리더가 될 수 없다.</li></ul></li></ul><p>각 단계의 트랜잭션들은 다음과 같이 처리된다.</p><ol><li>Flush 단계<ul><li>대기 큐에 등록된 각 트랜잭션들을 순서대로 바이너리 로그에 기록한다.</li></ul></li><li>Sync 단계</li></ol><ul><li>앞서 기록된 바이너리 로그 내용들을 디스크와 동기화하는 <code>fsync()</code> 시스템 콜이 수행된다.</li><li><code>sync_binlog</code> 옵션에 설정된 값에 따라 디스크 동기화 수행</li><li>트랜잭션 별로 동기화가 수행되는 것이 아닌 트랜잭션 그룹에 대해 동기화가 수행됨</li><li>대기 큐에 트랜잭션들이 많을수록 효율적으로 처리됨</li><li>Sync 단계의 대기 큐에 많은 트랜잭션을 쌓기 위해 시스템 변수를 설정하여 실행을 지연할 수 있음<ul><li><code>binlog_group_commit_sync_delay</code>:<br>동기화 작업을 얼마정도 지연시킬지 제아하는 변수(마이크로 초)</li><li><code>binlog_group_commit_sync_no_delay_count</code>:<br>동기화 작업이 진행되기 전에 지연되어 대기할 수 있는 최대 트랜잭션 수</li></ul></li></ul><ol start=3><li>Commit 단계</li></ol><ul><li>대기 큐에 등록된 트랜잭션들에 대해 스토리지 엔진 커밋을 진행한다.</li><li>스토리지 엔진 커밋은 대기 큐에 등록된 순서대로 혹은 병렬로도 처리될 수 있다.</li><li>대기 큐에 등록된 순서대로 커밋되는 경우 대기 큐의 리더에 의해 처리가 진행<ul><li>이러한 경우 트랜잭션들은 바이너리 로그에 기록된 순서와 스토리지 엔진에 커밋된 순서가 일치하게 된다.</li></ul></li><li>병렬로 처리되는 경우 리더가 아닌 각 트랜잭션들이 커밋을 수행하게 된다.</li><li>시스템 변수를 통해 트랜잭션들이 커밋되는 순서를 제어할 수 있다.<ul><li><code>binlob_order_commit</code>: 바이너리 로그 파일에 기록된 순서대로 스토리지 엔진에 커밋됨</li></ul></li></ul><h3 id=commit-parent-기반-방식>Commit-parent 기반 방식</h3><p>멀티 스레드 복제 동기화가 처음 도입됐던 버전에서 적용된 방식으로, 동일 시점에 커밋된 트랜잭션들을 레플리카 서버에서 병렬로 실행될 수 있게 한다.</p><ul><li>커밋 시점이 같은 트랜잭션들은 잠금 경합 등과 같이 서로 충돌하는 부분이 없는 트랜잭션들이므로 병렬로 실행될 수 있다는 부분에서 착안됨.</li></ul><p><code>Commit-parent</code> 기반 방식이 적용된 MySQL 버전을 사용하는 레플리카 서버에서 LOGICAL CLOCK 멀티 스레드 동기화가 활성화되어 있는 경우 소스 서버에서 같은 시점에 커밋된 트랜잭션들을 복제 동기화할 때 병렬로 처리한다.</p><ul><li>MySQL 서버는 같은 시점에 커밋 처리된 트랜잭션들을 식별할 수 있도록, 바이너리 로그에 트랜잭션을 기록할 때 <code>commit_clock</code>이라는 64비트 정수값을 기반으로 한다.<ul><li>각 트랜잭션이 커밋을 위해 Prepare 단계에 진입했을 때 설정되며 그 당시의 commit clock 값이 저장된다.(최종적으로 커밋되기 전에 값이 증가함)</li></ul></li><li>같은 시점에 커밋 처리가 시작된 트랜잭션들은 동일한 <code>commit_seq_no</code> 값을 가지며, 복제된 트랜잭션들의 해당 값을 바탕으로 같은 값을 가진 트랜잭션들을 병렬로 수행한다.</li></ul><p>병렬 처리 기준인 <code>commit_seq_no</code> 값이 앞서 커밋된 트랜잭션 순번 값에 해당하므로 이 방식을 Commit-parent 기반 방식이라고 한다.</p><pre class=mermaid style=text-align:center>sequenceDiagram
    0->>1:Tx1 C=0;
    1->>2:Tx2 C=1;
    2->>3:Tx3 C=2;
    3->>4:Tx4 C=3;
    4->>5:Tx5 C=4;
    4->>6:Tx6 C=4;
    4->>7:Tx7 C=4;
    4->>8:Tx8 C=6;
    6->>9:Tx9 C=6;
    8->>10:Tx10 C=8;
</pre><p>Commit-parent 기반에서는 소스 서버에서 같은 그룹으로 커밋된 트랜잭션 수가 많을수록 레플리카 서버에서의 트랜잭션 병렬 처리율이 향상된다.</p><p>사용자는 소스 서버에서 <code>binlog_group_commit_sync_delay</code> 시스템 변수와 <code>binlog_group_commit_sync_no_delay_count</code> 시스템 변수에 적절한 값을 설정해 그룹 커밋되는 트랜잭션 수를 늘릴 수 있다.</p><ul><li>소스 서버에서 트랜잭션들의 처리 속도를 느리게 하는 대신, 레플리카 서버에서의 처리 속도를 높이는 방법이다.</li><li>소스 서베에서 트랜잭션을 실행하는 클라이언트들이 영향을 받을 수 있으므로 설정을 변경한 후 주의 깊게 모니터링 해야한다.</li></ul><h3 id=잠금-기반-방식>잠금 기반 방식</h3><p>기존 Commit-parent 기반 방식에서는 단순하게 마지막으로 커밋된 선행 트랜잭션의 순번 값이 동일한 트랜잭션들만 레플리카 서버에서 병렬로 처리할 수 있었다.</p><p>그러나 잠금 기반 방식에서는 선행 트랜잭션의 순번 값이 동일하지 않더라도 커밋 처리 시점이 겹친다면 그 트랜잭션들은 레플리카 서버에서 병렬로 처리될 수 있다.</p><p>이를 위해 MySQL 서버에서는 트랜잭션을 바이너리 로그에 기록할 때 <strong>sequence_number</strong>와 <strong>last_committed</strong>라는 값을 함께 기록한다.</p><ul><li>sequence_number<ul><li>커밋된 트랜잭션에 대한 논리적인 순번 값으로, 매 트랜잭션이 커밋될 때마다 값이 증가한다.</li></ul></li><li>last_committed<ul><li>현 트랜잭션 이전에 커밋된 가장 최신 트랜잭션의 sequence_number 값이 저장된다.</li></ul></li><li>바이너리 파일이 새로운 파일로 로테이션 되는 경우 sequence_number 값은 1, last_committed 값은 0으로 초기화된다.</li></ul><p>잠금 기반 LOGICAL CLOCK 방식이 적용된 MySQL 버전을 사용하는 레플리카 서버에서는 LOGICAL CLOCK 멀티 스레드 동기화가 활성화돼 있는 경우 별렬로 트랜잭션을 실행할 때 다음과 같은 조건을 기준으로 트랜잭션들의 실행 가능 여부를 결정한다.</p><ul><li>실행하려는 트랜잭션의 last_committed &lt; 현재 실행중인 트랜잭션들이 가지는 가장 작은 sequence_number</li></ul><pre class=mermaid style=text-align:center>sequenceDiagram
    0->>1:Tx1 C=0, S=1;
    1->>2:Tx2 C=1, S=2;
    2->>3:Tx3 C=2, S=3;
    3->>4:Tx4 C=3, S=4;
    4->>5:Tx5 C=4, S=5;
    4->>6:Tx6 C=4, S=6;
    4->>7:Tx7 C=4, S=7;
    4->>8:Tx8 C=6, S=7;
    6->>9:Tx9 C=6, S=9;
    8->>10:Tx10 C=8, S=10;
</pre><p>잠금 기반 방식에서는 트랜잭션들이 레플리카 서버로 복제됐을 때 다음과 같이 처리된다.</p><div class=table-wrapper><table><thead><tr><th>트랜잭션</th><th>처리</th></tr></thead><tbody><tr><td>Tx1, Tx2, Tx3, Tx4</td><td>병렬 처리 가능 조건을 충족하지 않으므로 순차적으로 하나씩 실행됨</td></tr><tr><td>Tx5, Tx6, Tx7</td><td>병렬 처리 기능 조건을 충족하므로 병렬로 실행 가능</td></tr><tr><td>Tx8, Tx9</td><td>Tx6이 종료되고 Tx7이 아직 실행 중인 경우 Tx8, Tx9는 Tx7과 같이 실행될 수 있음(Tx8, 9의 last_committed 값보다 Tx7의 sequence_number 값이 크므로)</td></tr><tr><td>Tx10</td><td>Tx8이 종료되고 Tx9가 실행 중일 때 Tx9과 함께 실행 가능</td></tr></tbody></table></div><p>잠금 기반 방식은 소스 서버에서 커밋 처리 시점이 겹치는 트랜잭션들의 수가 많을 수록 레플리카 서버에서 최대한 병렬로 처리되므로 Commit-parent 기반 방식과 동일하게 소스 서버에서 그룹 커밋되는 트랜잭션 수에 영향의 받는다.</p><ul><li>잠금 기반 방식에서도 소스 서버의 시스템 변수 값을 적절히 조정해서 레플리카 서버에서의 병렬 처리율을 향상시킬 수 있다.</li></ul><h3 id=writeset-기반-방식>WriteSet 기반 방식</h3><p>WriteSet 기반 방식은 트랜잭션의 커밋 처리 시점이 아닌 트랜잭션이 변경한 데이터를 기준으로 병렬 처리 가능 여부를 결정한다.</p><p>기존 잠금 기반 방식에서는 다음과 같이 커밋 처리 시점이 전혀 겹치지 않는 두 트랜잭션은 병렬로 실행될 수 없었다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Tx1 : ---P-------C----------------&gt;
</span></span><span class=line><span class=cl>Tx2 : --------------P--------C----&gt;
</span></span></code></pre></td></tr></table></div></div><p>WriteSet 기반 방식에서는 두 트랜잭션이 서로 다른 데이터를 변경하는 것이라면 병렬로 실행할 수 있다.</p><ul><li>동일한 데이터를 변경하지 않는 트랜잭션들은 레플리카 서버에서 모두 병렬로 실행될 수 있다.</li></ul><p>WriteSet 기반에서는 같은 세션에서 실행된 트랜잭션들의 병렬 처리 여부에 따라 WRITESET과 WRITESET_SESSTION 타입으로 나눠진다.</p><ul><li><code>binlog_transaction_dependency_tracking</code> 시스템 변수로 설정 가능하다.</li><li>COMMIT_ORDER<ul><li>기본값으로 잠금 기반 방식과 동일하게 동작한다.</li></ul></li><li>WRITESET<ul><li>서로 다른 데이터를 변경한 트랜잭션들은 모두 병렬로 처리될 수 있다.</li></ul></li><li>WRITE_SESSION<ul><li>WRITE_SET 처리에서 동일한 세션에서 실행된 트랜잭션들은 병렬로 처리될 수 없다는 점만 다르다.</li></ul></li></ul><p>WriteSet 기반 방식에서는 각 트랜잭션에서 변경한 데이터를 기주능로 병렬 처리를 위한 트랜잭션들의 종속 관계를 정의하므로 이를 위해 내부적으로 트랜잭션에 의해 변경된 데이터들의 목록을 관리한다.</p><ul><li>변경된 데이터들은 하나하나가 전부 해시값으로 표현된다.</li><li>해싱된 변경 데이터를 WriteSet이라고 한다.</li><li>WriteSet은 테이블에 존재하는 유니크한 키의 개수만큼 만들어진다. 따라서 하나의 변경 데이터는 여러 개의 WriteSet을 가질 수 있다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>WriteSet = hash(index_name, db_name, db_name_length, table_name, table_name_length, value, value_length)
</span></span></code></pre></td></tr></table></div></div><p>트랜잭션들의 WriteSet은 MySQL 서버 메모리에서 해시맵 테이블로 그 히스토리가 관리된다.</p><ul><li>히스토리 테이블에는 변경된 데이터의 해시값인 WriteSet과 해당 데이터를 변경한 트랜잭션의 sequence_number 값이 Key-Value 형태로 저장된다.</li><li>사용자는 <code>binlog_transaction_dependency_histroy_size</code> 시스템 변수를 통해 히스토리 테이블이 최대로 가질 수 있는 WriteSet 개수를 정할 수 있다(기본값 25000).<ul><li>저장된 데이터 수가 지정된 최대 개수만큼 도달하면 히스토리 테이블은 초기화된다.</li><li>DDL 쿼리가 실행된 경우에도 초기화된다.</li></ul></li></ul><p>WriteSet 기반 방식에서도 마찬가지로 트랜잭션이 커밋되면 바이너리 로그에 트랜잭션 정보와 함께 last_committed 값과 sequence_number 값이 기록되며, 레플리카 서버에서는 이를 바탕으로 병렬 처리를 수행한다.</p><ul><li>WRITESET, WRITESET_SESSION 타입 모두 트랜잭션 커밋을 처리할 때 트랜잭션의 last_committed 값을 1차적으로 COMMIT_ORDER 타입 기반으로 설정한다.</li><li>이후 WriteSet 히스토리 테이블 데이터를 조회해서 트랜잭션의 WriteSet과 충돌하는 WriteSet의 존재 여부를 확인 후 다시 last_committed 값을 설정하게 된다.</li></ul><p><strong>처리 과정</strong></p><ol><li>WriteSet 히스토리 테이블에서 가장 작은 sequence_number 값을 자신의 last_committed 값으로 설정한다.</li><li>WriteSet을 히스토리 테이블에서 찾는다.<ul><li>충돌하는 데이터가 있을 경우 이 해시값에 매핑된 sequence_number 값을 자신의 sequence_number 값으로 변경한다.<ul><li>기존 sequence_number 값은 자신의 last_committed 값으로 설정한다.</li><li>기존 sequence_number 값이 자신의 last_committed 값보다 크지 않을 경우 변경하지 않는다.</li></ul></li><li>충돌하는 데이터가 없는 경우 히스토리 테이블에 자신의 sequence_number 값과 함께 해당 데이터를 저장한다.</li></ul></li></ol><p>트랜잭션에서는 WriteSet 히스토리 테이블에 자신의 WriteSet과 충돌되는 WriteSet 데이터가 존재하는 경우 그 WriteSet에 매핑된 sequence_number 값을 가져와 자신의 last_committed에 저장하고 해상 WriteSet의 sequence_number를 자신의 sequence_number 값으로 업데이트한다.</p><ul><li>충돌하는 WriteSet이 여러개이고 WriteSet이 다른 sequence_number 값을 가지는 경우 가장 큰 sequence_number로 업데이트된다.</li><li>충돌하는 WriteSet이 없다면 해당 트랜잭션이 가진 WriteSet들이 히스토리 테이블에 새로 저장되고 WriteSet 중 가장 작은 sequence_number로 저장된다.</li></ul><p>WRITESET_SESSION 타입에서는 이렇게 결정된 last_committed 값을, 같은 세션에서 커밋된 마지막 트랜잭션의 sequnece_number 값과 한번 더 비교해서 둘 중 더 큰값을 선택해 last_committed에 저장한다.</p><ul><li>WRITESET과 WRITESET_SESSION 타입 모드 트랜잭션에서 변경된 데이터들이 속하는 테이블이 유니크한 키를 가지고 있지 않은 경우 해당 트랜잭션의 WriteSet은 생성되지 않으며, last_committed에는 COMMIT_ORDER 타입 기반으로 결정된 값이 그대로 사용된다.</li><li>변경된 데이터들이 속하는 테이블의 유니크한 키들이 다른 테이블에서 외래키로 참조되는 경우에도 같은 방식으로 처리된다.</li></ul><p>WriteSet 기반 방식에서는 레플리카 서버에서의 트랜잭션 병렬 처리가 소스 서버에서 동시에 커밋되는 트랜잭션 수에 의존적이지 않으므로 그룹 커밋되는 트랜잭션 수를 늘리기 위해 의도적으로 소스 서버의 트랜잭션 커밋 처리 속도를 저하시킬 필요가 없다.</p><ul><li>체인 형태로 복제가 구성돼 있는 경우 하위 계층의 레플리카 서버로 갈수록 병렬로 처리되는 트랜잭션 수가 점점 줄어드는 문제는 WRITESET 타입을 사용하면 병렬 처리량 감소 문제를 해결할 수 있다.</li></ul><p>WriteSet 기반 방식은 어느 방식보다도 레플리카 서버에서의 병렬 처리성을 높이는 방식이지만 트랜잭션 커밋 시 추가적인 메모리 공간이 필요하며 매 트랜잭션마다 WriteSet 히스토리 테이블에 저장된 값들을 계속 비교해야 하므로 이에 따른 오버헤드가 발생한다.</p><h2 id=멀티-스레드-복제와-복제-포지션-정보>멀티 스레드 복제와 복제 포지션 정보</h2><p>멀티 스레드 복제에서 각 워커 스레드들이 실행한 바이너리 로그 이벤트의 포지션 정보는 <code>relay_log_info_repository</code> 시스템 변수에 지정된 값에 따라 <code>mysql</code> 데이터베이스 내 <code>slave_worker_info</code> 테이블 혹은 데이터 디렉터리 내 <strong>worker-relay-log.info</strong> 접두사를 가지는 파일들에 각 스레드별로 저장되며, 워커 스레드들은 이벤트를 실행 완료할 때마다 해당 데이터를 갱신한다.</p><p>현재 복제 이벤트의 처리 현황을 보여주는 어플라이어 메타데이터에는 워커 스레드들이 실행한 이벤트들에서 로우 워터마크에 해당하는 이벤트의 포지션 값이 저장된다.</p><ul><li>코디네이터 스레드가 수행하는 체크포인트 작어베 의해 주기적으로 갱신된다.</li><li>갭이 존재하는 경우 체크포인트 지점은 항상 갭 이전에 실행 완료된 이벤트에서만 나타날 수 있다.<ul><li>먼저 실행된 트랜잭션보다 나중에 실행된 트랜잭션이 먼저 처리되었을 때 발생하는 포지션 간격을 갭(Gap)이라고 한다.</li><li>멀티 스레드 복제에서 <code>slave_preserve_commit_order</code> 시스템 변수가 비활성화되어있는 경우 발생한다.<ul><li>레플리카 서버에서 복제를 통해 넘어온 이벤트를 소스 서버에서 커밋된 순서와 동일한 순서로 커밋할 것인지를 제어</li><li>1로 설정시 여러 이벤트들이 동시에 처리돼도 릴레이 로그에 기록된 수서대로 커밋되어 갭이 발생하지 않는다.</li></ul></li><li>갭이 발생하지 않는다 하더라도 어플라이어 메타데이터는 워커 스레드들이 처리한 이벤트 내역이 실시가능로 반영된 데이터가 아니라 체크포인트 주기마다 갱신되는 데이터므로 실제 적용된 이벤트의 포지션 값보다 이전의 포지션 값을 보여준다. (명령을 통한 조회도 동일함)</li></ul></li></ul><p>코디네이터 스레드는 다음 시스템 변수들에 설정된 값을 바탕으로 워커 스레드들에서 실행된 이벤트들에 대해 체크포인트를 수행해 어플라이어 메타데이터를 갱신한다.</p><ul><li><code>slave_checkpoint_period</code><ul><li>어플라이어 메타데이터 갱신 작업의 주기를 결정하는 시스템 변수(기본값 300 (밀리초))</li></ul></li><li><code>slave_checkpoint_group</code><ul><li>어플라이어 메타데이터 갱신 작업의 주기를 결정하는 시스템 변수로 실행한 트랜잭션의 개수를 지정함</li></ul></li></ul></section><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
</script><footer class=article-footer><section class=article-tags><a href=/tags/db/>DB</a>
<a href=/tags/mysql/>MySQL</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/post/real-mysql/16/7/4/><div class=article-image><img src=/post/real-mysql/16/7/4/real_mysql.335f5c2fc94dc22cf816a9c1393301d9_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_250x150_fill_q75_box_smart1.jpeg width=250 height=150 loading=lazy alt="Featured image of post 16.7.4 복제 고급 설정 - 필터링된 복제(Filterd Replication)" data-key=real-mysql/16/7/4 data-hash="md5-M19cL8lNwiz4FqnBOTMB2Q=="></div><div class=article-details><h2 class=article-title>16.7.4 복제 고급 설정 - 필터링된 복제(Filterd Replication)</h2></div></a></article><article class=has-image><a href=/post/real-mysql/16/7/3/><div class=article-image><img src=/post/real-mysql/16/7/3/real_mysql.335f5c2fc94dc22cf816a9c1393301d9_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_250x150_fill_q75_box_smart1.jpeg width=250 height=150 loading=lazy alt="Featured image of post 16.7.3 복제 고급 설정 - 크래시 세이프 복제(Crash-safe Replication)" data-key=real-mysql/16/7/3 data-hash="md5-M19cL8lNwiz4FqnBOTMB2Q=="></div><div class=article-details><h2 class=article-title>16.7.3 복제 고급 설정 - 크래시 세이프 복제(Crash-safe Replication)</h2></div></a></article><article class=has-image><a href=/post/real-mysql/16/7/1/><div class=article-image><img src=/post/real-mysql/16/7/1/real_mysql.335f5c2fc94dc22cf816a9c1393301d9_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_250x150_fill_q75_box_smart1.jpeg width=250 height=150 loading=lazy alt="Featured image of post 16.7.1 복제 고급 설정 - 지연된 복제" data-key=real-mysql/16/7/1 data-hash="md5-M19cL8lNwiz4FqnBOTMB2Q=="></div><div class=article-details><h2 class=article-title>16.7.1 복제 고급 설정 - 지연된 복제</h2></div></a></article><article class=has-image><a href=/post/real-mysql/16/6/><div class=article-image><img src=/post/real-mysql/16/6/real_mysql.335f5c2fc94dc22cf816a9c1393301d9_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_250x150_fill_q75_box_smart1.jpeg width=250 height=150 loading=lazy alt="Featured image of post 16.6 복제 - 복제 토폴로지" data-key=real-mysql/16/6 data-hash="md5-M19cL8lNwiz4FqnBOTMB2Q=="></div><div class=article-details><h2 class=article-title>16.6 복제 - 복제 토폴로지</h2></div></a></article><article class=has-image><a href=/post/real-mysql/16/5/><div class=article-image><img src=/post/real-mysql/16/5/real_mysql.335f5c2fc94dc22cf816a9c1393301d9_hu03b8ff0acb6f52b3ec9ae95e616f82c2_25714_250x150_fill_q75_box_smart1.jpeg width=250 height=150 loading=lazy alt="Featured image of post 16.5 복제 - 복제 동기화 방식" data-key=real-mysql/16/5 data-hash="md5-M19cL8lNwiz4FqnBOTMB2Q=="></div><div class=article-details><h2 class=article-title>16.5 복제 - 복제 동기화 방식</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=codemario318/codemario318.github.io issue-term=pathname label=Comment crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2023 -
2024 Mario Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>