<!doctype html><html lang=ko dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="쿠버네티스 문서 읽어보기"><title>쿠버네티스: 5. 클러스터 아키텍처</title><link rel=canonical href=https://codemario318.github.io/post/study/kubernetes/5/><link rel=stylesheet href=/scss/style.min.cbce94e2760d14d60414e59d5a36ab2819232375817e010dbe7be2234b67da1b.css><meta property="og:title" content="쿠버네티스: 5. 클러스터 아키텍처"><meta property="og:description" content="쿠버네티스 문서 읽어보기"><meta property="og:url" content="https://codemario318.github.io/post/study/kubernetes/5/"><meta property="og:site_name" content="Mario Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="Kubernetes"><meta property="article:tag" content="Docker"><meta property="article:published_time" content="2023-04-21T14:00:47+09:00"><meta property="article:modified_time" content="2023-04-21T14:00:47+09:00"><meta property="og:image" content="https://codemario318.github.io/post/study/kubernetes/5/kubernetes_cover.webp"><meta name=twitter:title content="쿠버네티스: 5. 클러스터 아키텍처"><meta name=twitter:description content="쿠버네티스 문서 읽어보기"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://codemario318.github.io/post/study/kubernetes/5/kubernetes_cover.webp"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu760fd15c5fbb2f30cf0868dc4a5dc41a_14271_300x0_resize_q75_box.jpeg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Mario Blog</a></h1><h2 class=site-description></h2></div></header><ol class=social-menu><li><a href=https://github.com/codemario318 target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><ul class="menu sub-menu"><li><a href=/categories/backend/><span>Backend</span>
<span class=content-count>3</span></a></li><li><a href=/categories/cleancode/><span>Clean Code</span>
<span class=content-count>10</span></a></li><li><a href=/categories/common/><span>Common</span>
<span class=content-count>4</span></a></li><li><a href=/categories/data/><span>Data</span>
<span class=content-count>3</span></a></li><li><a href=/categories/db/><span>DB</span>
<span class=content-count>1</span></a></li><li><a href=/categories/frontend/><span>Frontend</span>
<span class=content-count>10</span></a></li><li><a href=/categories/golang/><span>GoLang</span>
<span class=content-count>13</span></a></li><li><a href=/categories/infra/><span>Infra</span>
<span class=content-count>12</span></a></li><li><a href=/categories/problemsolving/><span>Problem Solving</span>
<span class=content-count>1</span></a></li><li><a href=/categories/project/><span>Project</span>
<span class=content-count>3</span></a></li><li><a href=/categories/realmysql/><span>Real MySQL</span>
<span class=content-count>47</span></a></li></ul><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#노드>노드</a><ol><li><a href=#관리>관리</a></li></ol></li><li><a href=#노드-이름-고유성>노드 이름 고유성</a><ol><li><a href=#노드-상태>노드 상태</a></li><li><a href=#주소>주소</a></li><li><a href=#컨디션>컨디션</a></li><li><a href=#용량과-할당가능>용량과 할당가능</a></li><li><a href=#정보>정보</a></li></ol></li><li><a href=#하트비트>하트비트</a><ol><li><a href=#노드-컨트롤러>노드 컨트롤러</a></li><li><a href=#축출-빈도-제한>축출 빈도 제한</a></li></ol></li><li><a href=#리소스-용량-추적>리소스 용량 추적</a></li><li><a href=#노드-토폴로지>노드 토폴로지</a></li><li><a href=#그레이스풀graceful-노드-셧다운shutdown>그레이스풀(Graceful) 노드 셧다운(shutdown)</a></li><li><a href=#논-그레이스풀-노드-셧다운>논 그레이스풀 노드 셧다운</a><ol><li><a href=#파드-우선순위-기반-그레이스풀-노드-셧다운>파드 우선순위 기반 그레이스풀 노드 셧다운</a></li></ol></li><li><a href=#스왑swap-메모리-관리>스왑(swap) 메모리 관리</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/post/study/kubernetes/5/><img src=/post/study/kubernetes/5/kubernetes_cover_hu15504362c54454204bbf321d3bfe3873_12586_800x0_resize_q75_h2_box_2.webp srcset="/post/study/kubernetes/5/kubernetes_cover_hu15504362c54454204bbf321d3bfe3873_12586_800x0_resize_q75_h2_box_2.webp 800w, /post/study/kubernetes/5/kubernetes_cover_hu15504362c54454204bbf321d3bfe3873_12586_1600x0_resize_q75_h2_box_2.webp 1600w" width=800 height=450 loading=lazy alt="Featured image of post 쿠버네티스: 5. 클러스터 아키텍처"></a></div><div class=article-details><header class=article-category><a href=/categories/infra/ style=background-color:#2a9d8f;color:#fff>Infra</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/study/kubernetes/5/>쿠버네티스: 5. 클러스터 아키텍처</a></h2><h3 class=article-subtitle>쿠버네티스 문서 읽어보기</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2023/04/21</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>15 minute read</time></div></footer></div></header><section class=article-content><h2 id=노드>노드</h2><p>쿠버네티스는 컨테이너를 파드내에 배치하고 노드에서 실행함으로 워크로드를 구동한다. 노드는 클러스터에 따라 가상 또는 물리적 머신일 수 있다. 각 노드는 컨트롤 플레인에 의해 관리되며 파드를 실행하는데 필요한 서비스를 포함한다.</p><p>일반적으로 클러스터에는 여러개의 노드가 있으며, 학습 또는 리소스가 제한되는 환경에서는 하나만 있을 수도 있다.</p><p>노드의 컴포넌트에는 <code>kubelet</code>, 컨테이너 런타임 그리고 <code>kube-proxy</code>가 포함된다.</p><h3 id=관리>관리</h3><p>API 서버에 노드를 추가하는 두가지 주요 방법이 있다.</p><ol><li>노드의 <code>kubelet</code>으로 컨트롤 플레인에 자체 등록</li><li>사용자(또는 다른 사용자)가 노드 오브젝트를 수동으로 추가</li></ol><p>노드 오브젝트 또는 노드의 <code>kubelt</code>으로 자체 등록한 후 컨트롤 플레인은 새 노드 오브젝트가 유효한지 확인한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;kind&#34;</span><span class=p>:</span> <span class=s2>&#34;Node&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;apiVersion&#34;</span><span class=p>:</span> <span class=s2>&#34;v1&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;metadata&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;10.240.79.157&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;labels&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;my-first-k8s-node&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>쿠버네티스는 내부적으로 노드 오브젝트를 생성(표시)한다. 쿠버네티스는 <code>kubelet</code>이 노드의 <code>metadata</code>,<code>name</code>필드와 일치하는 API 서버에 등록이 되어있는지 확인한다. 노드가 정상이면(필요한 모든 서비스가 실행중인 경우) 파드를 실행할 수 있게 된다. 그렇지 않으면, 해당 노드는 정상이 될때까지 모든 클러스터 활동에 대해 무시된다.</p><blockquote><p>💡 쿠버네티스는 유효하지 않은 노드 오브젝트를 유지하고, 노드가 정상적인지 확인한다. 상태 확인을 중지하려면 사용자 또는 <a class=link href=https://kubernetes.io/ko/docs/concepts/architecture/controller/ target=_blank rel=noopener>컨트롤러</a>에서 노드 오브젝트를 명시적으로 삭제해야 한다.</p></blockquote><p>노드 오브젝트의 이름은 유효한 DNS 서브 도메인 이름이어야 한다.</p><h2 id=노드-이름-고유성>노드 이름 고유성</h2><p>이름은 노드를 식별한다. 두 노드는 동시에 같은 이름을 가질 수 없다. 쿠버네티스는 또한 같은 이름의 리소스가 동일한 객체라고 가정한다. 노드의 경우, 동일한 이름을 사용하는 인스턴스가 동일한 상태와 노드 레이블과 같은 동일한 속성을 갖는다고 암시적으로 가정한다. 인스턴스가 이름을 변경하지 않고 수정된 경우 이로 인해 불일치가 발생할 수 있다. 노드를 대폭 교체하거나 업데이트 해야 하는 경우, 기존 노드 오브젝트를 먼저 API 서버에서 제거하고 업데이트 후 다시 추가해야 한다.</p><h3 id=노드-상태>노드 상태</h3><p>kubectl을 사용해서 노드 상태와 기타 세부 정보를 볼수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=err>kubectl</span> <span class=err>describe</span> <span class=err>node</span> <span class=err>&lt;insert-node-name-here&gt;</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=주소>주소</h3><p>주소 필드는 클라우드 제공 사업자 또는 베어메탈 구성에 따라 다양하게 사용된다.</p><ul><li><code>HostName</code>: 노드의 커널에 의해 알려진 호스트명이다. <code>-hostname-override</code> 파라미터를 통해 치환될 수 있다.</li><li><code>ExternalIP</code>: 일반적으로 노드의 IP 주소는 외부로 라우트 가능 (클러스터 외부에서 이용 가능) 하다 .</li><li><code>InternalIP</code>: 일반적으로 노드의 IP 주소는 클러스터 내에서만 라우트 가능하다.</li></ul><h3 id=컨디션>컨디션</h3><p>conditions필드는 모든 Running 노드의 상태를 기술한다.</p><div class=table-wrapper><table><thead><tr><th>노드 컨디션</th><th>설명</th></tr></thead><tbody><tr><td>Ready</td><td>노드가 상태 양호하며 파드를 수용할 준비가 되어 있는 경우 True, 노드의 상태가 불량하여 파드를 수용하지 못할 경우 False, 그리고 노드 컨트롤러가 마지막 node-monitor-grace-period (기본값 40 기간 동안 노드로부터 응답을 받지 못한 경우) Unknown</td></tr><tr><td>DiskPressure</td><td>디스크 사이즈 상에 압박이 있는 경우, 즉 디스크 용량이 넉넉치 않은 경우 True, 반대의 경우 False</td></tr><tr><td>MemoryPressure</td><td>노드 메모리 상에 압박이 있는 경우, 즉 노드 메모리가 넉넉치 않은 경우 True, 반대의 경우 False</td></tr><tr><td>PIDPressure</td><td>프로세스 상에 압박이 있는 경우, 즉 노드 상에 많은 프로세스들이 존재하는 경우 True, 반대의 경우 False</td></tr><tr><td>NetworkUnavailable</td><td>노드에 대해 네트워크가 올바르게 구성되지 않은 경우 True, 반대의 경우 False</td></tr></tbody></table></div><h3 id=용량과-할당가능>용량과 할당가능</h3><p>노드 상에 사용 가능한 리소스를 나타낸다.</p><ul><li>CPU</li><li>메모리</li><li>스케줄 되어질 수 있는 최대 파드 수 등</li></ul><p>용량 블록 필드는 노드에 있는 리소스의 총량을 나타낸다. 할당가능 블록은 일반 파드에서 사용할 수 있는 노드의 리소스 양을 나타낸다.</p><h3 id=정보>정보</h3><p>노드에 대한 일반적은 정보가 기술된다. kubelet이 노드에서 수집하여 쿠버네티스 API 로 전송한다.</p><ul><li>커널 버전</li><li>쿠버네티스 버전</li><li>컨테이너 런타임 상세 정보 등</li></ul><h2 id=하트비트>하트비트</h2><p>쿠버네티스 노드가 보내는 하트비느느 ㄴ클러스터가 개별 노드가 가용한지를 판단할 수 있도록 도움을 주고, 장애가 발견된 경우 조치를 할 수 있게 한다.</p><ul><li>노드의 .status 에 대한 업데이트</li><li>kube=-node-lease 네임 스페이스 내의 Lease오브젝트</li></ul><p>노드의 <code>.status</code>에 비하면, 리스는 경량의 리소스이다. 큰 규모의 클러스터에서는 리스를 하트비트에 사용하여 업데이트로 인한 성능 영향을 줄일 수 있다.</p><p>kubelet은 노드의 <code>.status</code> 생성과 업데이트 및 관련된 리스의 업데이트를 담당한다.</p><ul><li>kubelet은 상태가 변경되거나 설정된 인터벌보다 오래 업데이트가 없는 경우 노드의 <code>.status</code>를 업데이트한다. 노드의 <code>.status</code> 업데이트에 대한 기본 인터벌은 접근이 불가능한 노드에 대한 타임아웃인 40초 보다 훨씬 긴 5분이다.</li><li>kubelet은 리스 오브젝트를 (기본 업데이트 인터벌인) 매 10초마다 생성하고 업데이트한다. 리스 업데이트는 노드의 <code>.status</code> 업데이트와는 독립적이다. 만약 리스 업데이트가 실패하면, kubelet은 200밀리초에서 시작하고 7초의 상한을 갖는 지수적 백오프를 사용해서 재시도한다.</li></ul><h3 id=노드-컨트롤러>노드 컨트롤러</h3><p>노드 <a class=link href=https://kubernetes.io/ko/docs/concepts/architecture/controller/ target=_blank rel=noopener>컨트롤러</a>는 노드의 다양한 측면을 관리하는 쿠버네티스 컨트롤 플레인 컴포넌트이다.</p><p>노드 컨트롤러는 노드가 생성되어 유지되는 동안 다양한 역할을 한다.</p><ol><li><p>등록 시점에 (CIDR 할당이 사용토록 설정된 경우) 노드에 CIDR 블럭을 할당하는 것이다.</p></li><li><p>노드 컨트롤러의 내부 노드 리스트를 클라우드 제공사업자의 사용 가능한 머신 리스트 정보를 근거로 최신상태로 유지하는 것이다.</p></li></ol><ul><li>클라우드 환경에서 동작 중일 경우, 노드상태가 불량할 때마다, 노드 컨트롤러는 해당 노드용 VM이 여전히 사용 가능한지에 대해 클라우드 제공사업자에게 묻는다.</li><li>사용 가능하지 않을 경우, 노드 컨트롤러는 노드 리스트로부터 그 노드를 삭제한다.</li></ul><ol start=3><li>노드의 동작 상태를 모니터링하는 것이다.</li></ol><ul><li>노드가 접근 불가능(unreachable) 상태가 되는 경우, 노드의 <code>.status</code> 필드의 <code>Ready</code> 컨디션을 업데이트한다. 이 경우에는 노드 컨트롤러가 <code>Ready</code> 컨디션을 <code>Unknown</code>으로 설정한다.</li><li>노드가 계속 접근 불가능 상태로 남아있는 경우, 해당 노드의 모든 파드에 대해서 <a class=link href=https://kubernetes.io/ko/docs/concepts/scheduling-eviction/api-eviction/ target=_blank rel=noopener>API를 이용한 축출</a>을 트리거한다. 기본적으로, 노드 컨트롤러는 노드를 <code>Unknown</code>으로 마킹한 뒤 5분을 기다렸다가 최초의 축출 요청을 시작한다.</li></ul><p>기본적으로, 노드 컨트롤러는 5 초마다 각 노드의 상태를 체크한다. 체크 주기는 <code>kube-controller-manager</code> 구성 요소의 <code>--node-monitor-period</code> 플래그를 이용하여 설정할 수 있다.</p><h3 id=축출-빈도-제한>축출 빈도 제한</h3><p>대부분의 경우, 노드 컨트롤러는 초당 <code>--node-eviction-rate</code>(기본값 0.1)로 축출 속도를 제한한다. 이 말은 10초당 1개의 노드를 초과하여 파드 축출을 하지 않는다는 의미가 된다.</p><p>노드 축출 행위는 주어진 가용성 영역 내 하나의 노드가 상태가 불량할 경우 변화한다. 노드 컨트롤러는 영역 내 동시에 상태가 불량한 노드의 퍼센티지가 얼마나 되는지 체크한다(<code>Ready</code> 컨디션은 <code>Unknown</code> 또는 <code>False</code> 값을 가진다).</p><ul><li>상태가 불량한 노드의 비율이 최소 <code>-unhealthy-zone-threshold</code> (기본값 0.55)가 되면 축출 속도가 감소한다.</li><li>클러스터가 작으면 (즉 <code>-large-cluster-size-threshold</code> 노드 이하면 - 기본값 50) 축출이 중지된다.</li><li>이외의 경우, 축출 속도는 초당 <code>-secondary-node-eviction-rate</code>(기본값 0.01)로 감소된다.</li></ul><p>이 정책들이 가용성 영역 단위로 실행되어지는 이유는 나머지가 연결되어 있는 동안 <strong>하나의 가용성 영역이 컨트롤 플레인으로부터 분할되어 질 수도 있기 때문</strong>이다. 만약 클러스터가 여러 클라우드 제공사업자의 가용성 영역에 걸쳐 있지 않는 이상, 축출 매커니즘은 영역 별 가용성을 고려하지 않는다.</p><p>노드가 가용성 영역들에 걸쳐 퍼져 있는 주된 이유는 <strong>하나의 전체 영역이 장애가 발생할 경우 워크로드가 상태 양호한 영역으로 이전될 수 있도록 하기 위해서</strong>이다. 그러므로, 하나의 영역 내 모든 노드들이 상태가 불량하면 노드 컨트롤러는 <code>--node-eviction-rate</code> 의 정상 속도로 축출한다.</p><p>모든 영역이 완전히 상태불량(클러스터 내 양호한 노드가 없는 경우)한 경우이다. 이러한 경우, 노드 컨트롤러는 컨트롤 플레인과 노드 간 연결에 문제가 있는 것으로 간주하고 축출을 실행하지 않는다. (중단 이후 일부 노드가 다시 보이는 경우 노드 컨트롤러는 상태가 양호하지 않거나 접근이 불가능한 나머지 노드에서 파드를 축출한다.)</p><p>또한, 노드 컨트롤러는 파드가 테인트를 허용하지 않을 때 <code>NoExecute</code> 테인트 상태의 노드에서 동작하는 파드에 대한 축출 책임을 가지고 있다. 추가로, 노드 컨틀로러는 연결할 수 없거나, 준비되지 않은 노드와 같은 노드 문제에 상응하는 <a class=link href=https://kubernetes.io/ko/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank rel=noopener>테인트</a>를 추가한다. 이는 스케줄러가 비정상적인 노드에 파드를 배치하지 않게 된다.</p><h2 id=리소스-용량-추적>리소스 용량 추적</h2><p>노드 오브젝트는 노드 리소스 용량에 대한 정보: 예를 들어, 사용 가능한 메모리의 양과 CPU의 수를 추적한다. 노드의 <a class=link href=https://kubernetes.io/ko/docs/concepts/architecture/nodes/#%EB%85%B8%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9E%90%EC%B2%B4-%EB%93%B1%EB%A1%9D target=_blank rel=noopener>자체 등록</a>은 등록하는 중에 용량을 보고한다. <a class=link href=https://kubernetes.io/ko/docs/concepts/architecture/nodes/#%EC%88%98%EB%8F%99-%EB%85%B8%EB%93%9C-%EA%B4%80%EB%A6%AC target=_blank rel=noopener>수동</a>으로 노드를 추가하는 경우 추가할 때 노드의 용량 정보를 설정해야 한다.</p><p>쿠버네티스 <a class=link href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank rel=noopener>스케줄러</a>는 노드 상에 모든 노드에 대해 충분한 리소스가 존재하도록 보장한다. 스케줄러는 노드 상에 컨테이너에 대한 요청의 합이 노드 용량보다 더 크지 않도록 체크한다. 요청의 합은 kubelet에서 관리하는 모든 컨테이너를 포함하지만, 컨테이너 런타임에 의해 직접적으로 시작된 컨 테이너는 제외되고 kubelet의 컨트롤 범위 밖에서 실행되는 모든 프로세스도 제외된다.</p><p><strong>참고: 파드 형태가 아닌 프로세스에 대해 명시적으로 리소스를 확보하려면, <a class=link href=https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved target=_blank rel=noopener>시스템 데몬에 사용할 리소스 예약하기</a>을 본다.</strong></p><h2 id=노드-토폴로지>노드 토폴로지</h2><p><strong>기능 상태:</strong> <code>Kubernetes v1.18 [beta]</code></p><p><code>TopologyManager</code> <a class=link href=https://kubernetes.io/ko/docs/reference/command-line-tools-reference/feature-gates/ target=_blank rel=noopener>기능 게이트(feature gate)</a>를 활성화 시켜두면, kubelet이 리소스 할당 결정을 할 때 토폴로지 힌트를 사용할 수 있다. 자세한 내용은 <a class=link href=https://kubernetes.io/docs/tasks/administer-cluster/topology-manager/ target=_blank rel=noopener>노드의 컨트롤 토폴로지 관리 정책</a>을 본다.</p><h2 id=그레이스풀graceful-노드-셧다운shutdown>그레이스풀(Graceful) 노드 셧다운(shutdown)</h2><p><strong>기능 상태:</strong> <code>Kubernetes v1.21 [beta]</code></p><p>kubelet은 노드 시스템 셧다운을 감지하고 노드에서 실행 중인 파드를 종료하려고 시도한다.</p><p>Kubelet은 노드가 종료되는 동안 파드가 일반 <a class=link href=https://kubernetes.io/ko/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination target=_blank rel=noopener>파드 종료 프로세스</a>를 따르도록 한다.</p><p>그레이스풀 노드 셧다운 기능은 <a class=link href=https://www.freedesktop.org/wiki/Software/systemd/inhibit/ target=_blank rel=noopener>systemd inhibitor locks</a>를 사용하여 주어진 기간 동안 노드 종료를 지연시키므로 systemd에 의존한다.</p><p>그레이스풀 노드 셧다운은 1.21에서 기본적으로 활성화된 <code>GracefulNodeShutdown</code> <a class=link href=https://kubernetes.io/ko/docs/reference/command-line-tools-reference/feature-gates/ target=_blank rel=noopener>기능 게이트</a>로 제어된다.</p><p>기본적으로, 아래 설명된 두 구성 옵션, <code>shutdownGracePeriod</code> 및 <code>shutdownGracePeriodCriticalPods</code> 는 모두 0으로 설정되어 있으므로, 그레이스풀 노드 셧다운 기능이 활성화되지 않는다. 기능을 활성화하려면, 두 개의 kubelet 구성 설정을 적절하게 구성하고 0이 아닌 값으로 설정해야 한다.</p><p>그레이스풀 셧다운 중에 kubelet은 다음의 두 단계로 파드를 종료한다.</p><ol><li>노드에서 실행 중인 일반 파드를 종료시킨다.</li><li>노드에서 실행 중인 <a class=link href=https://kubernetes.io/ko/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#%ED%8C%8C%EB%93%9C%EB%A5%BC-%EC%A4%91%EC%9A%94-critical-%EB%A1%9C-%ED%91%9C%EC%8B%9C%ED%95%98%EA%B8%B0 target=_blank rel=noopener>중요(critical) 파드</a>를 종료시킨다.</li></ol><p>그레이스풀 노드 셧다운 기능은 두 개의 <code>[KubeletConfiguration](https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/)</code> 옵션으로 구성된다.</p><ul><li><code>shutdownGracePeriod</code>:<ul><li>노드가 종료를 지연해야 하는 총 기간을 지정한다. 이것은 모든 일반 및 <a class=link href=https://kubernetes.io/ko/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#%ED%8C%8C%EB%93%9C%EB%A5%BC-%EC%A4%91%EC%9A%94-critical-%EB%A1%9C-%ED%91%9C%EC%8B%9C%ED%95%98%EA%B8%B0 target=_blank rel=noopener>중요 파드</a>의 파드 종료에 필요한 총 유예 기간에 해당한다.</li></ul></li><li><code>shutdownGracePeriodCriticalPods</code>:<ul><li>노드 종료 중에 <a class=link href=https://kubernetes.io/ko/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#%ED%8C%8C%EB%93%9C%EB%A5%BC-%EC%A4%91%EC%9A%94-critical-%EB%A1%9C-%ED%91%9C%EC%8B%9C%ED%95%98%EA%B8%B0 target=_blank rel=noopener>중요 파드</a>를 종료하는 데 사용되는 기간을 지정한다. 이 값은 <code>shutdownGracePeriod</code> 보다 작아야 한다.</li></ul></li></ul><p>예를 들어, <code>shutdownGracePeriod=30s</code>, <code>shutdownGracePeriodCriticalPods=10s</code> 인 경우, kubelet은 노드 종료를 30초까지 지연시킨다. 종료하는 동안 처음 20(30-10)초는 일반 파드의 유예 종료에 할당되고, 마지막 10초는 <a class=link href=https://kubernetes.io/ko/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#%ED%8C%8C%EB%93%9C%EB%A5%BC-%EC%A4%91%EC%9A%94-critical-%EB%A1%9C-%ED%91%9C%EC%8B%9C%ED%95%98%EA%B8%B0 target=_blank rel=noopener>중요 파드</a>의 종료에 할당된다.</p><p>**참고:
그레이스풀 노드 셧다운 과정에서 축출된 파드는 셧다운(shutdown)된 것으로 표시된다. <code>kubectl get pods</code> 명령을 실행하면 축출된 파드의 상태가 <code>Terminated</code>으로 표시된다. 그리고 <code>kubectl describe pod</code> 명령을 실행하면 노드 셧다운으로 인해 파드가 축출되었음을 알 수 있다.</p><p><code>Reason: Terminated Message: Pod was terminated in response to imminent node shutdown.</code>**</p><h2 id=논-그레이스풀-노드-셧다운>논 그레이스풀 노드 셧다운</h2><p><strong>기능 상태:</strong> <code>Kubernetes v1.24 [alpha]</code></p><p>전달한 명령이 kubelet에서 사용하는 금지 잠금 메커니즘(inhibitor locks mechanism)을 트리거하지 않거나, 또는 사용자 오류(예: ShutdownGracePeriod 및 ShutdownGracePeriodCriticalPods가 제대로 설정되지 않음)로 인해 kubelet의 노드 셧다운 관리자(Node Shutdown Mananger)가 노드 셧다운 액션을 감지하지 못할 수 있다. 자세한 내용은 위의 <a class=link href=https://kubernetes.io/ko/docs/concepts/architecture/nodes/#graceful-node-shutdown target=_blank rel=noopener>그레이스풀 노드 셧다운</a> 섹션을 참조한다.</p><p>노드가 셧다운되었지만 kubelet의 노드 셧다운 관리자가 이를 감지하지 못하면, 스테이트풀셋에 속한 파드는 셧다운된 노드에 &lsquo;종료 중(terminating)&rsquo; 상태로 고착되어 다른 동작 중인 노드로 이전될 수 없다. 이는 셧다운된 노드의 kubelet이 파드를 지울 수 없어서 결국 스테이트풀셋이 동일한 이름으로 새 파드를 만들 수 없기 때문이다. 만약 파드가 사용하던 볼륨이 있다면, 볼륨어태치먼트(VolumeAttachment)도 기존의 셧다운된 노드에서 삭제되지 않아 결국 파드가 사용하던 볼륨이 다른 동작 중인 노드에 연결(attach)될 수 없다. 결과적으로, 스테이트풀셋에서 실행되는 애플리케이션이 제대로 작동하지 않는다. 기존의 셧다운된 노드가 정상으로 돌아오지 못하면, 이러한 파드는 셧다운된 노드에 &lsquo;종료 중(terminating)&rsquo; 상태로 영원히 고착될 것이다.</p><p>위와 같은 상황을 완화하기 위해, 사용자가 <code>node.kubernetes.io/out-of-service</code> 테인트를 <code>NoExecute</code> 또는 <code>NoSchedule</code> 값으로 추가하여 노드를 서비스 불가(out-of-service) 상태로 표시할 수 있다. <code>kube-controller-manager</code>에 <code>NodeOutOfServiceVolumeDetach</code><a class=link href=https://kubernetes.io/ko/docs/reference/command-line-tools-reference/feature-gates/ target=_blank rel=noopener>기능 게이트</a> 가 활성화되어 있고, 노드가 이 테인트에 의해 서비스 불가 상태로 표시되어 있는 경우, 노드에 매치되는 톨러레이션이 없다면 노드 상의 파드는 강제로 삭제될 것이고, 노드 상에서 종료되는 파드에 대한 볼륨 해제(detach) 작업은 즉시 수행될 것이다. 이를 통해 서비스 불가 상태 노드의 파드가 빠르게 다른 노드에서 복구될 수 있다.</p><p>논 그레이스풀 셧다운 과정 동안, 파드는 다음의 두 단계로 종료된다.</p><ol><li>매치되는 <code>out-of-service</code> 톨러레이션이 없는 파드를 강제로 삭제한다.</li><li>이러한 파드에 대한 볼륨 해제 작업을 즉시 수행한다.</li></ol><p><strong>참고:
• <code>node.kubernetes.io/out-of-service</code> 테인트를 추가하기 전에, 노드가 완전한 셧다운 또는 전원 꺼짐 상태에 있는지 (재시작 중인 것은 아닌지) 확인한다.
• 사용자가 서비스 불가 상태 테인트를 직접 추가한 것이기 때문에, 파드가 다른 노드로 옮겨졌고 셧다운 상태였던 노드가 복구된 것을 확인했다면 사용자가 서비스 불가 상태 테인트를 수동으로 제거해야 한다.</strong></p><h3 id=파드-우선순위-기반-그레이스풀-노드-셧다운>파드 우선순위 기반 그레이스풀 노드 셧다운</h3><p><strong>기능 상태:</strong> <code>Kubernetes v1.23 [alpha]</code></p><p>그레이스풀 노드 셧다운 시 파드 셧다운 순서에 더 많은 유연성을 제공할 수 있도록, 클러스터에 프라이어리티클래스(PriorityClass) 기능이 활성화되어 있으면 그레이스풀 노드 셧다운 과정에서 파드의 프라이어리티클래스가 고려된다. 이 기능으로 그레이스풀 노드 셧다운 시 파드가 종료되는 순서를 클러스터 관리자가 <a class=link href=https://kubernetes.io/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/#%ED%94%84%EB%9D%BC%EC%9D%B4%EC%96%B4%EB%A6%AC%ED%8B%B0%ED%81%B4%EB%9E%98%EC%8A%A4 target=_blank rel=noopener>프라이어리티 클래스</a> 기반으로 명시적으로 정할 수 있다.</p><p>위에서 기술된 것처럼, <a class=link href=https://kubernetes.io/ko/docs/concepts/architecture/nodes/#graceful-node-shutdown target=_blank rel=noopener>그레이스풀 노드 셧다운</a> 기능은 파드를 중요하지 않은(non-critical) 파드와 중요한(critical) 파드 2단계(phase)로 구분하여 종료시킨다. 셧다운 시 파드가 종료되는 순서를 명시적으로 더 상세하게 정해야 한다면, 파드 우선순위 기반 그레이스풀 노드 셧다운을 사용할 수 있다.</p><p>그레이스풀 노드 셧다운 과정에서 파드 우선순위가 고려되기 때문에, 그레이스풀 노드 셧다운이 여러 단계로 일어날 수 있으며, 각 단계에서 특정 프라이어리티 클래스의 파드를 종료시킨다. 정확한 단계와 단계별 셧다운 시간은 kubelet에 설정할 수 있다.</p><p>다음과 같이 클러스터에 커스텀 파드 <a class=link href=https://kubernetes.io/ko/docs/concepts/scheduling-eviction/pod-priority-preemption/#%ED%94%84%EB%9D%BC%EC%9D%B4%EC%96%B4%EB%A6%AC%ED%8B%B0%ED%81%B4%EB%9E%98%EC%8A%A4 target=_blank rel=noopener>프라이어리티 클래스</a>가 있다고 가정하자.</p><div class=table-wrapper><table><thead><tr><th>파드 프라이어리티 클래스 이름</th><th>파드 프라이어리티 클래스 값</th></tr></thead><tbody><tr><td>custom-class-a</td><td>100000</td></tr><tr><td>custom-class-b</td><td>10000</td></tr><tr><td>custom-class-c</td><td>1000</td></tr><tr><td>regular/unset</td><td>0</td></tr></tbody></table></div><p><a class=link href=https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration target=_blank rel=noopener>kubelet 환경 설정</a> 안의 <code>shutdownGracePeriodByPodPriority</code> 설정은 다음과 같을 수 있다.</p><div class=table-wrapper><table><thead><tr><th>파드 프라이어리티 클래스 값</th><th>종료 대기 시간</th></tr></thead><tbody><tr><td>100000</td><td>10 seconds</td></tr><tr><td>10000</td><td>180 seconds</td></tr><tr><td>1000</td><td>120 seconds</td></tr><tr><td>0</td><td>60 seconds</td></tr></tbody></table></div><p>이를 나타내는 kubelet 환경 설정 YAML은 다음과 같다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=err>**shutdownGracePeriodByPodPriority**:</span>
</span></span><span class=line><span class=cl>  <span class=err>-</span> <span class=err>**priority**:</span> <span class=mi>100000</span>
</span></span><span class=line><span class=cl>    <span class=err>**shutdownGracePeriodSeconds**:</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>  <span class=err>-</span> <span class=err>**priority**:</span> <span class=mi>10000</span>
</span></span><span class=line><span class=cl>    <span class=err>**shutdownGracePeriodSeconds**:</span> <span class=mi>180</span>
</span></span><span class=line><span class=cl>  <span class=err>-</span> <span class=err>**priority**:</span> <span class=mi>1000</span>
</span></span><span class=line><span class=cl>    <span class=err>**shutdownGracePeriodSeconds**:</span> <span class=mi>120</span>
</span></span><span class=line><span class=cl>  <span class=err>-</span> <span class=err>**priority**:</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=err>**shutdownGracePeriodSeconds**:</span> <span class=mi>60</span>
</span></span></code></pre></td></tr></table></div></div><p>위의 표에 의하면 <code>priority</code> 값이 100000 이상인 파드는 종료까지 10초만 주어지며, 10000 이상 ~ 100000 미만이면 180초, 1000 이상 ~ 10000 미만이면 120초가 주어진다. 마지막으로, 다른 모든 파드는 종료까지 60초가 주어질 것이다.</p><p>모든 클래스에 대해 값을 명시할 필요는 없다. 예를 들어, 대신 다음과 같은 구성을 사용할 수도 있다.</p><div class=table-wrapper><table><thead><tr><th>파드 프라이어리티 클래스 값</th><th>종료 대기 시간</th></tr></thead><tbody><tr><td>100000</td><td>300 seconds</td></tr><tr><td>1000</td><td>120 seconds</td></tr><tr><td>0</td><td>60 seconds</td></tr></tbody></table></div><p>위의 경우, <code>custom-class-b</code>에 속하는 파드와 <code>custom-class-c</code>에 속하는 파드는 동일한 종료 대기 시간을 갖게 될 것이다.</p><p>특정 범위에 해당되는 파드가 없으면, kubelet은 해당 범위에 해당되는 파드를 위해 기다려 주지 않는다. 대신, kubelet은 즉시 다음 프라이어리티 클래스 값 범위로 넘어간다.</p><p>기능이 활성화되어 있지만 환경 설정이 되어 있지 않으면, 순서 지정 동작이 수행되지 않을 것이다.</p><p>이 기능을 사용하려면 <code>GracefulNodeShutdownBasedOnPodPriority</code> <a class=link href=https://kubernetes.io/ko/docs/reference/command-line-tools-reference/feature-gates/ target=_blank rel=noopener>기능 게이트</a>를 활성화해야 하고, <a class=link href=https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/ target=_blank rel=noopener>kubelet config</a>의 <code>ShutdownGracePeriodByPodPriority</code>를 파드 프라이어리티 클래스 값과 각 값에 대한 종료 대기 시간을 명시하여 지정해야 한다.</p><p><strong>참고: 그레이스풀 노드 셧다운 과정에서 파드 프라이어리티를 고려하는 기능은 쿠버네티스 v1.23에서 알파 기능으로 도입되었다. 쿠버네티스 1.26에서 이 기능은 베타 상태이며 기본적으로 활성화되어 있다.</strong></p><p><code>graceful_shutdown_start_time_seconds</code> 및 <code>graceful_shutdown_end_time_seconds</code> 메트릭은 노드 셧다운을 모니터링하기 위해 kubelet 서브시스템에서 방출된다.</p><h2 id=스왑swap-메모리-관리>스왑(swap) 메모리 관리</h2><p><strong>기능 상태:</strong> <code>Kubernetes v1.22 [alpha]</code></p><p>쿠버네티스 1.22 이전에는 노드가 스왑 메모리를 지원하지 않았다. 그리고 kubelet은 노드에서 스왑을 발견하지 못한 경우 시작과 동시에 실패하도록 되어 있었다. 1.22부터는 스왑 메모리 지원을 노드 단위로 활성화할 수 있다.</p><p>노드에서 스왑을 활성화하려면, <code>NodeSwap</code> 기능 게이트가 kubelet에서 활성화되어야 하며, 명령줄 플래그 <code>--fail-swap-on</code> 또는 <a class=link href=https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration target=_blank rel=noopener>구성 설정</a>에서 <code>failSwapOn</code>가 false로 지정되어야 한다.</p><p><strong>경고: 메모리 스왑 기능이 활성화되면, 시크릿 오브젝트의 내용과 같은 tmpfs에 기록되었던 쿠버네티스 데이터가 디스크에 스왑될 수 있다.</strong></p><p>사용자는 또한 선택적으로 <code>memorySwap.swapBehavior</code>를 구성할 수 있으며, 이를 통해 노드가 스왑 메모리를 사용하는 방식을 명시한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>memorySwap</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>swapBehavior</span><span class=p>:</span><span class=w> </span><span class=l>LimitedSwap`</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>swapBehavior</code>에 가용한 구성 옵션은 다음과 같다.</p><ul><li><code>LimitedSwap</code>: 쿠버네티스 워크로드는 스왑을 사용할 수 있는 만큼으로 제한된다. 쿠버네티스에 의해 관리되지 않는 노드의 워크로드는 여전히 스왑될 수 있다.</li><li><code>UnlimitedSwap</code>: 쿠버네티스 워크로드는 요청한 만큼 스왑 메모리를 사용할 수 있으며, 시스템의 최대치까지 사용 가능하다.</li></ul><p>만약 <code>memorySwap</code> 구성이 명시되지 않았고 기능 게이트가 활성화되어 있다면, kubelet은 <code>LimitedSwap</code> 설정과 같은 행동을 기본적으로 적용한다.</p><p><code>LimitedSwap</code> 설정에 대한 행동은 노드가 (&ldquo;cgroups"으로 알려진) 제어 그룹이 v1 또는 v2 중에서 무엇으로 동작하는가에 따라서 결정된다.</p><ul><li><strong>cgroupsv1:</strong> 쿠버네티스 워크로드는 메모리와 스왑의 조합을 사용할 수 있다. 파드의 메모리 제한이 설정되어 있다면 가용 상한이 된다.</li><li><strong>cgroupsv2:</strong> 쿠버네티스 워크로드는 스왑 메모리를 사용할 수 없다.</li></ul><p>테스트를 지원하고 피드벡을 제공하기 위한 정보는 <a class=link href=https://github.com/kubernetes/enhancements/issues/2400 target=_blank rel=noopener>KEP-2400</a> 및 <a class=link href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2400-node-swap/README.md target=_blank rel=noopener>디자인 제안</a>에서 찾을 수 있다.</p></section><footer class=article-footer><section class=article-tags><a href=/tags/kubernetes/>kubernetes</a>
<a href=/tags/docker/>Docker</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><div class="article-list--compact links"><article><a href=https://kubernetes.io/ko/docs/concepts/ target=_blank rel=noopener><div class=article-details><h2 class=article-title>쿠버네티스 문서</h2><footer class=article-time>https://kubernetes.io/ko/docs/concepts/</footer></div></a></article></div><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/post/study/kubernetes/4/><div class=article-image><img src=/post/study/kubernetes/4/kubernetes_cover.8a7111ac770762d16c23051c45b32b7b_hu15504362c54454204bbf321d3bfe3873_12586_250x150_fill_q75_h2_box_smart1_2.webp width=250 height=150 loading=lazy alt="Featured image of post 쿠버네티스: 4. 쿠버네티스 오브젝트 관리" data-key=study/kubernetes/4 data-hash="md5-inERrHcHYtFsIwUcRbMrew=="></div><div class=article-details><h2 class=article-title>쿠버네티스: 4. 쿠버네티스 오브젝트 관리</h2></div></a></article><article class=has-image><a href=/post/study/kubernetes/3/><div class=article-image><img src=/post/study/kubernetes/3/kubernetes_cover.8a7111ac770762d16c23051c45b32b7b_hu15504362c54454204bbf321d3bfe3873_12586_250x150_fill_q75_h2_box_smart1_2.webp width=250 height=150 loading=lazy alt="Featured image of post 쿠버네티스: 3. 쿠버네티스 오브젝트 이해하기" data-key=study/kubernetes/3 data-hash="md5-inERrHcHYtFsIwUcRbMrew=="></div><div class=article-details><h2 class=article-title>쿠버네티스: 3. 쿠버네티스 오브젝트 이해하기</h2></div></a></article><article class=has-image><a href=/post/study/kubernetes/2/><div class=article-image><img src=/post/study/kubernetes/2/kubernetes_cover.8a7111ac770762d16c23051c45b32b7b_hu15504362c54454204bbf321d3bfe3873_12586_250x150_fill_q75_h2_box_smart1_2.webp width=250 height=150 loading=lazy alt="Featured image of post 쿠버네티스: 2. 쿠버네티스 컴포넌트" data-key=study/kubernetes/2 data-hash="md5-inERrHcHYtFsIwUcRbMrew=="></div><div class=article-details><h2 class=article-title>쿠버네티스: 2. 쿠버네티스 컴포넌트</h2></div></a></article><article class=has-image><a href=/post/study/kubernetes/1/><div class=article-image><img src=/post/study/kubernetes/1/kubernetes_cover.8a7111ac770762d16c23051c45b32b7b_hu15504362c54454204bbf321d3bfe3873_12586_250x150_fill_q75_h2_box_smart1_2.webp width=250 height=150 loading=lazy alt="Featured image of post 쿠버네티스: 1. 쿠버네티스란 무엇인가?" data-key=study/kubernetes/1 data-hash="md5-inERrHcHYtFsIwUcRbMrew=="></div><div class=article-details><h2 class=article-title>쿠버네티스: 1. 쿠버네티스란 무엇인가?</h2></div></a></article><article class=has-image><a href=/post/kubernetes/tutorials/1/><div class=article-image><img src=/post/kubernetes/tutorials/1/cover.8a7111ac770762d16c23051c45b32b7b_hu15504362c54454204bbf321d3bfe3873_12586_250x150_fill_q75_h2_box_smart1_2.webp width=250 height=150 loading=lazy alt="Featured image of post 쿠버네티스 튜토리얼 - 1. Hello Minikube" data-key=kubernetes/tutorials/1 data-hash="md5-inERrHcHYtFsIwUcRbMrew=="></div><div class=article-details><h2 class=article-title>쿠버네티스 튜토리얼 - 1. Hello Minikube</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=codemario318/codemario318.github.io issue-term=pathname label=Comment crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2023 Mario Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>