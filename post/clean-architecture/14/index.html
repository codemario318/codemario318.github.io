<!doctype html><html lang=ko dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="4부 - 컴포넌트 원칙"><title>14. 컴포넌트 결합</title><link rel=canonical href=https://codemario318.github.io/post/clean-architecture/14/><link rel=stylesheet href=/scss/style.min.cbce94e2760d14d60414e59d5a36ab2819232375817e010dbe7be2234b67da1b.css><meta property="og:title" content="14. 컴포넌트 결합"><meta property="og:description" content="4부 - 컴포넌트 원칙"><meta property="og:url" content="https://codemario318.github.io/post/clean-architecture/14/"><meta property="og:site_name" content="Mario Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="Clean Architecture"><meta property="article:tag" content="클린 아키텍처"><meta property="article:tag" content="설계"><meta property="article:tag" content="Design"><meta property="article:tag" content="아키텍처"><meta property="article:tag" content="Architecture"><meta property="article:tag" content="컴포넌트 원칙"><meta property="article:tag" content="Component Principles"><meta property="article:tag" content="컴포넌트"><meta property="article:tag" content="Components"><meta property="article:tag" content="컴포넌트 결합"><meta property="article:tag" content="Component Coupling"><meta property="article:tag" content="ADP"><meta property="article:tag" content="의존성 비순환 원칙"><meta property="article:tag" content="Acyclic Dependencies Principle"><meta property="article:tag" content="SDP"><meta property="article:tag" content="안정된 의존성 원칙"><meta property="article:tag" content="SAP"><meta property="article:tag" content="안정된 추상화 원칙"><meta property="article:published_time" content="2024-03-07T15:31:13+09:00"><meta property="article:modified_time" content="2024-03-07T15:31:13+09:00"><meta property="og:image" content="https://codemario318.github.io/post/clean-architecture/14/cover.png"><meta name=twitter:title content="14. 컴포넌트 결합"><meta name=twitter:description content="4부 - 컴포넌트 원칙"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://codemario318.github.io/post/clean-architecture/14/cover.png"><script async src="https://www.googletagmanager.com/gtag/js?id=G-K99591YLGK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K99591YLGK",{anonymize_ip:!1})}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3183752545292673" crossorigin=anonymous></script><meta name=naver-site-verification content="2315bde85c86f66092140cc465c340a2170f3187"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu760fd15c5fbb2f30cf0868dc4a5dc41a_14271_300x0_resize_q75_box.jpeg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Mario Blog</a></h1><h2 class=site-description></h2></div></header><ol class=social-menu><li><a href=https://github.com/codemario318 target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><ul class="menu sub-menu"><li><a href=/categories/backend/><span>Backend</span>
<span class=content-count>3</span></a></li><li><a href=/categories/cleancode/><span>Clean Code</span>
<span class=content-count>10</span></a></li><li><a href=/categories/common/><span>Common</span>
<span class=content-count>29</span></a></li><li><a href=/categories/data/><span>Data</span>
<span class=content-count>3</span></a></li><li><a href=/categories/db/><span>DB</span>
<span class=content-count>1</span></a></li><li><a href=/categories/frontend/><span>Frontend</span>
<span class=content-count>10</span></a></li><li><a href=/categories/golang/><span>GoLang</span>
<span class=content-count>13</span></a></li><li><a href=/categories/headfirstdesignpatterns/><span>헤드 퍼스트 디자인 패턴</span>
<span class=content-count>22</span></a></li><li><a href=/categories/infra/><span>Infra</span>
<span class=content-count>14</span></a></li><li><a href=/categories/problemsolving/><span>Problem Solving</span>
<span class=content-count>1</span></a></li><li><a href=/categories/project/><span>Project</span>
<span class=content-count>5</span></a></li><li><a href=/categories/realmysql/><span>Real MySQL</span>
<span class=content-count>53</span></a></li></ul><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#adp-의존성-비순환-원칙>ADP: 의존성 비순환 원칙</a><ol><li><a href=#주-단위-빌드>주 단위 빌드</a></li><li><a href=#순환-의존성-제거하기>순환 의존성 제거하기</a></li><li><a href=#순환이-컴포넌트-의존성-그래프에-미치는-영향>순환이 컴포넌트 의존성 그래프에 미치는 영향</a></li><li><a href=#순환-끊기>순환 끊기</a></li><li><a href=#흐트러짐jitters>흐트러짐(Jitters)</a></li></ol></li><li><a href=#하향식top-down-설계>하향식(Top-down) 설계</a></li><li><a href=#sdp-안정된-의존성-원칙>SDP: 안정된 의존성 원칙</a><ol><li><a href=#안정성>안정성</a></li><li><a href=#안정성-지표>안정성 지표</a></li><li><a href=#모든-컴포넌트가-안정적이어야-하는-것은-아니다>모든 컴포넌트가 안정적이어야 하는 것은 아니다.</a></li></ol></li><li><a href=#sap-안정된-추상화-원칙>SAP: 안정된 추상화 원칙</a><ol><li><a href=#고수준-정책을-어디에-위치시켜야-하는가>고수준 정책을 어디에 위치시켜야 하는가?</a></li><li><a href=#안정된-추상화-원칙>안정된 추상화 원칙</a></li><li><a href=#추상화-정도-측정하기>추상화 정도 측정하기</a></li><li><a href=#주계열-main-sequence>주계열: Main Sequence</a></li><li><a href=#고통의-구역-zone-of-pain>고통의 구역: Zone of Pain</a></li><li><a href=#쓸모없는-구역-zone-of-uselessness>쓸모없는 구역: Zone of Uselessness</a></li><li><a href=#배제-구역-벗어나기>배제 구역 벗어나기</a></li><li><a href=#주계열과의-거리>주계열과의 거리</a></li></ol></li><li><a href=#결론>결론</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/post/clean-architecture/14/><img src=/post/clean-architecture/14/cover_hu01783d23203014d58ee585db2e3121c4_1011761_800x0_resize_box_3.png srcset="/post/clean-architecture/14/cover_hu01783d23203014d58ee585db2e3121c4_1011761_800x0_resize_box_3.png 800w, /post/clean-architecture/14/cover_hu01783d23203014d58ee585db2e3121c4_1011761_1600x0_resize_box_3.png 1600w" width=800 height=1043 loading=lazy alt="Featured image of post 14. 컴포넌트 결합"></a></div><div class=article-details><header class=article-category><a href=/categories/common/ style=background-color:#2a9d8f;color:#fff>Common</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/clean-architecture/14/>14. 컴포넌트 결합</a></h2><h3 class=article-subtitle>4부 - 컴포넌트 원칙</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2024/03/07</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>15 minute read</time></div></footer></div></header><section class=article-content><p>지금부터 다룰 세 가지 원칙은 <strong>컴포넌트 사이의 관계</strong>를 설명한다.</p><p>컴포넌트 사이의 관계는 응집도와 마찬가지로 개발 가능성과 논리적 설계 사이의 균형을 다룬다.</p><p>컴포넌트 구조와 관련된 아키텍처를 침범하는 힘은 기술적이며, 정치적이고, 가변적이다.</p><h2 id=adp-의존성-비순환-원칙>ADP: 의존성 비순환 원칙</h2><blockquote><p>컴포넌트 의존성 그래프에 순환(Cycle)이 있어서는 안된다.</p></blockquote><p><strong>숙취 증후군 The morning after syndrome</strong><br>무언가를 작동하게 만들놓았는데, 무언가를 의존하고 있던 무언가를 다른 사람이 수정하여 동작하지 않는 현상을 저자는 숙취 증후군이라 부른다.</p><hr><p>숙취 증후군은 많은 개발자가 동일한 소스 파일을 수정하는 환경에서 발생한다.</p><p>소수의 개발자로 구성된 작은 프로젝트에서는 큰 문제가 되지 않지만, 프로젝트와 개발팀 규모가 커지면 큰 문제로 다가온다.</p><p>지난 수십 년 동안 이 문제의 해결책으로 두 가지 방법이 발전되어 왔다.</p><ul><li>주 단위 빌드(Weekly build)</li><li>의존성 비순환 원칙(Acyclic Dependencies Principle)</li></ul><h3 id=주-단위-빌드>주 단위 빌드</h3><p>중간 규모의 프로젝트에서는 흔하게 사용되는 방법으로 일주일의 첫 4일 동안은 각자 작업한 후 금요일이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다.</p><p>이 접근법은 5일 중 4일 동안 개발자가 걱정없이 개발할 수 있다는 장점이 있지만, 금요일에 통합과 관련된 막대한 업보를 치러야한다는 단점을 가진다.</p><ol><li>프로젝트가 커질수록 통합은 하루만에 끝마치는게 불가능해진다.<ul><li>통합 일정이 길어진다.</li></ul></li><li>개발보다 통합에 드는 시간이 늘어나면서 팀의 효율성도 서서히 나빠진다.<ul><li>빌드 주기가 길어진다.</li></ul></li></ol><p>이러한 과정이 반복되며 효율성을 유지하기 위해 빌드 일정을 계속 늘려야 하고, 빌드 주기가 늦어질수록 프로젝트가 감수할 위험은 더 커지게된다.</p><ul><li>통합과 테스트를 수행하기가 점점 어려워진다.</li><li>빠른 피드백이 주는 장점을 잃는다.</li></ul><h3 id=순환-의존성-제거하기>순환 의존성 제거하기</h3><p>이 문제의 해결책은 <strong>개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것</strong>이다.</p><p>이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.</p><ol><li>개발자가 해당 컴호넌트가 동작하도록 만든 후, 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할 수 있도록 만든다.</li><li>컴포넌트에 릴리스 번호를 부여하고, 다른팀에서 사용할 수 있는 디렉터리로 이동시킨다.</li><li>개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정한다.</li><li>나머지 개발자는 릴리스된 버전을 사용한다.</li><li>컴포넌트가 새로 릴리스되어 사용할 수 있게 되면, 다른팀에서는 새 릴리스를 적용할 지 결정한다.</li></ol><p>특정 컴포넌트가 변경 되더라도 다른 팀에 영향을 즉각 영향을 주지는 않으므로 어떤 팀도 다른 팀에 의해 좌우되지 않는다.</p><ul><li>각 팀은 특정 컴포넌트가 새로 릴리스되면 자신의 컴포넌트를 해당 컴포넌트에 맞게 수정할 시기를 스스로 결정할 수 있다.</li><li>통합은 작고 점진적으로 이뤄진다.</li></ul><p>이 같은 작업 절차는 단순하며 합리적이여서 널리 사용되는 방식이나, 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야한다.</p><p><img src=/post/clean-architecture/14/img.png width=1410 height=706 srcset="/post/clean-architecture/14/img_hu25b06e863fc54028a17a8c977c361598_212469_480x0_resize_box_3.png 480w, /post/clean-architecture/14/img_hu25b06e863fc54028a17a8c977c361598_212469_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=199 data-flex-basis=479px></p><p>컴포넌트 다이어그램에서는 컴포넌트를 조립하여 애플리케이션을 만드는 다소 전형적인 구조로, 중요한 점은 컴포넌트 간의 의존성 구조이다.</p><ul><li>의존성 관계는 일방향이다.</li><li>어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없다.</li><li>어떠한 컴포넌트의 새로운 릴리스를 만들게 되면 영향을 받는 컴포넌트는 의존성 화살표를 거꾸로 따라가면 알 수 있다.<ul><li><code>Presenters</code> > <code>View</code>, <code>Main</code></li><li><code>Main</code>은 새로 릴리스되더라도 영향을 받는 컴포넌트가 전혀 없다.</li></ul></li></ul><hr><p><code>Presenters</code> 컴포넌트를 만드는 개발자가 이 컴포넌트를 테스트하려고 한다면, 현재 사용중인 버전의 <code>Interactors</code>와 <code>Entities</code>를 이용해서 <code>Presenters</code> 자체 버전을 빌드하면 그만이다.</p><ul><li>테스트를 구성할 때 대체로 적은 노력이 든다.</li><li>고려해야 할 변수도 상대적으로 적다.</li></ul><p>시스템 전체를 릴리스해야 할 때가 오면 릴리스 절차는 상향식으로 진행된다.</p><ol><li><code>Entities</code> 컴포넌트를 컴파일하고, 테스트하고, 릴리스한다.</li><li><code>Database</code>와 <code>Interactors</code>에서도 동일한 과정을 거친다.</li><li><code>Presenters</code>, <code>Views</code>, <code>Controllers</code>, <code>Authorizer</code> 순으로 진행한다.</li><li>마지막으로 <code>Main</code>을 처리한다.</li></ol><p>구성요소 간 의존성을 파악하고 있으면 시스템을 빌드하는 방법을 알 수 있다.</p><h3 id=순환이-컴포넌트-의존성-그래프에-미치는-영향>순환이 컴포넌트 의존성 그래프에 미치는 영향</h3><p>요구사항 발생으로 <code>Entities</code>의 <code>User</code> 클래스가 <code>Authorizer</code>의 <code>Permissions</code> 클래스를 사용한다고 가정하면, 아래와 같이 순환 의존성이 발생한다.</p><p><img src=/post/clean-architecture/14/img_2.png width=600 height=293 srcset="/post/clean-architecture/14/img_2_hu1d9357bad079e1bd21e0590f44df1af1_28113_480x0_resize_box_3.png 480w, /post/clean-architecture/14/img_2_hu1d9357bad079e1bd21e0590f44df1af1_28113_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=204 data-flex-basis=491px></p><p><code>Database</code> 컴포넌트를 릴리스하려면 <code>Entities</code>와의 호환되어야 하므로 <code>Authorizer</code>과 확인도 필요하며, <code>Authorizer</code>는 <code>Interactors</code>와도 의존하므로 세 개의 컴포넌트가 사실상 하나의 거대한 컴포넌트가되어 릴리스 하기 어려워진다.</p><p>해당 컴포넌트의 개발자들은 항상 정확하게 동일한 릴리스를 사용해야하므로 모두 서로에게 얽매이게 된다.</p><p><code>Entites</code> 컴포넌트를 테스트할 때도 <code>Authorizer</code>와 <code>Interactors</code> 까지도 반드시 빌드하고 통합해야한다.</p><p>이처럼 순환이 생기면 컴포넌트를 분리하기가 상당히 어려워진다.</p><ul><li>단위테스트를 하고 릴리스를 하는 일도 굉장히 어려워진다. 에러가 쉽게 발생한다.</li><li>모듈의 개수가 많아짐에 따라 빌드 관련 이슈는 기하급수적으로 증가한다.</li><li>컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어진다.<ul><li>순환이 생기면 올바른 순서라는 것 자체가 없을 수 있다.</li></ul></li></ul><h3 id=순환-끊기>순환 끊기</h3><p>컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG로 원상복구하는 일은 언제라도 가능하다.</p><p><strong>의존성 역전 원칙 적용</strong></p><p><img src=/post/clean-architecture/14/img_4.png width=600 height=297 srcset="/post/clean-architecture/14/img_4_hu2d0ddebed758504a656ef831a9615a2e_23447_480x0_resize_box_3.png 480w, /post/clean-architecture/14/img_4_hu2d0ddebed758504a656ef831a9615a2e_23447_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=202 data-flex-basis=484px></p><ol><li><code>User</code>가 필요로하는 메서드를 제공하는 인터페이스를 생성한다.</li><li>이 인터페이스를 <code>Entities</code>에 위치시키고, <code>Authorizer</code>에서 이 인터페이스를 상속받는다.</li></ol><p>이를 통해 <code>Entities</code>와 <code>Authorizer</code> 사이의 의존성을 역전시킬 수 있고, 이를 통해 순환을 끊을 수 있다.</p><p><strong>새로운 컴포넌트</strong></p><p><img src=/post/clean-architecture/14/img_1.png width=1024 height=496 srcset="/post/clean-architecture/14/img_1_hud3e3acb0c4f3794f6f3cfe621553502d_150119_480x0_resize_box_3.png 480w, /post/clean-architecture/14/img_1_hud3e3acb0c4f3794f6f3cfe621553502d_150119_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=206 data-flex-basis=495px></p><ol><li><code>Entities</code>와 <code>Authorizer</code>가 모두 의존하는 새로운 컴포넌트를 만든다.</li><li>두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.</li></ol><h3 id=흐트러짐jitters>흐트러짐(Jitters)</h3><p>새로운 컴포넌트를 생성하는 두 번째 해결책에서 시사하는 바는 <strong>요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다</strong>는 사실이다.</p><p>애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장하므로, 의존성 구조에 순환이 발생하는지를 항상 관찰하여 순환이 발생하면 어떤 식으로든 끊어야 한다.</p><p>이로인해 새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질수도 있다.</p><h2 id=하향식top-down-설계>하향식(Top-down) 설계</h2><p>지금까지 논의로 <strong>컴포넌트 구조는 하향식으로 설계될 수 없다</strong>는 결론에 다다른다.</p><p>컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.</p><hr><p>컴포넌트와 같이 큰 단위로 분해된 구조는 고수준의 기능적인 구조로 다시 분해할 수 있다고 기대하기 때문에 동의하지 않을 수 있지만, 컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없다.</p><p>컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도이므로 빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도 도한 필요 없기 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.</p><p>하지만 프로젝트가 진행되고 발전함에 따라 의존성관리, 영향범위 최소화, 안정적인 컴포넌트, 재사용성 등의 대한 요구로 점점 아키텍처를 새로 만들고 가다듬게 되어 컴포넌트 의존성 그래프는 조금씩 흐트러지고 성장한다.</p><hr><p>이처럼 아직 아무런 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하려고 시도한다면 큰 실패를 맛볼 수 있다.</p><ul><li>공통 폐쇄에 대해 파악할 수 없다.</li><li>재사용 가능한 요소도 알 수 없다.</li><li>컴포넌트 생성 시 대부분 순환 의존성이 발생하게된다.</li></ul><p>따라서 컴포넌트 의존성 구조는 시스템의 논리적인 설계에 발맞춰 성장하며 또 진화해야한다.</p><h2 id=sdp-안정된-의존성-원칙>SDP: 안정된 의존성 원칙</h2><blockquote><p>안정성의 방향으로(더 안정된 쪽에) 의존하라.</p></blockquote><p>설계를 유지하다 보면 변경은 불가피하므로 결코 정적일 수 없다.</p><p>공통 폐쇄 원칙을 준수함으로써 컴포넌트가 다른 유형의 변경에는 영향받지 않으면서도 <strong>특정 유형의 변경</strong>에만 민감하게 만들 수 있으며, 이에 맞추어 특정 컴포넌트는 변동성을 지니도록 설계한다.</p><p>변동성이 높은(변동이 예상되는) 컴포넌트에 한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워지므로 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대 안된다.</p><ul><li>모듈을 만들 때는 변경하기 쉽도록 설계했지만, 그 모듈에 의존성을 매달아 버리면 해당 모듈도 변경하기 어려워진다.</li><li>만든 모듈에서는 한 줄의 코드도 변경되지 않았더라도 변경하는 일이 상당히 도전적인 일이 되어버린다.</li></ul><p>안정된 의존성 원칙을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.</p><h3 id=안정성>안정성</h3><p>동전을 세로로 세우면 안정성이 떨어지지만 건드리지 않으면 넘어지지 않는 것 처럼, 안정성은 변화가 발생하는 빈도와는 직접적인 관련이 없다.</p><p>웹스터 사전에서는 안정성을 &lsquo;쉽게 움직이지 않는&rsquo;이라고 정의하는데 이는 변경을 만들기 위해 필요한 작업량과 관련된다.</p><ul><li>변경을 위해 필요한 작업량이 많으면 안정적이다.</li></ul><p>소프트웨어 컴포넌트를 변경하기 어렵게 만드는 데는 크기, 복잡도, 간결함 등 많은 요인이 있지만, 변경하기 어렵게 만드는 확실한 방법 중 하나는 <strong>수 많은 컴포넌트가 해당 컴포넌트에 의존</strong>하게 만드는 것이다.</p><ul><li>컴포넌트 안쪽으로 들어오는 의존성이 많아지면, 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하기 위해 많은 노력이 들기 때문에 상당히 안정적이다.</li></ul><p><strong>안정된 컴포넌트</strong></p><p><img src=/post/clean-architecture/14/img_5.png width=600 height=236 srcset="/post/clean-architecture/14/img_5_huda8f1298a64169a65f641afa6cef89c1_12377_480x0_resize_box_3.png 480w, /post/clean-architecture/14/img_5_huda8f1298a64169a65f641afa6cef89c1_12377_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=254 data-flex-basis=610px></p><ul><li>X는 세 컴포넌트를 <strong>책임 responsible</strong>진다<ul><li>X에 3개 컴포넌트가 의존하기 때문에 X를 변경하지 말아야할 이유는 3가지이다.</li></ul></li><li>X는 <strong>독립적</strong>이다.<ul><li>어디에도 의존하지 않으므로 변경되도록 만들 수 있는 외적인 영향이 전혀 없다.</li></ul></li></ul><p><strong>불안정한 컴포넌트</strong></p><p><img src=/post/clean-architecture/14/img_6.png width=600 height=240 srcset="/post/clean-architecture/14/img_6_hu7f1ed0727c7caffa02617c63a39a84b1_16824_480x0_resize_box_3.png 480w, /post/clean-architecture/14/img_6_hu7f1ed0727c7caffa02617c63a39a84b1_16824_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=250 data-flex-basis=600px></p><ul><li>책임성이 없다.<ul><li>어떤 컴포넌트도 Y에 의존하지 않는다.</li></ul></li><li>의존적이다.<ul><li>3개 컴포넌트에 의존하므로 변경이 발생할 수 있는 외부 요인이 3가지이다.</li></ul></li></ul><h3 id=안정성-지표>안정성 지표</h3><p>컴포넌트로 들어오고 나가는 의존성의 개수를 세어 컴포넌트가 위치상(Positional) 어느 정도의 안정성을 가지는지 계산할 수 있다.</p><ul><li><strong>Fan-in</strong>: 안으로 들어오는 의존성<ul><li>컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래수 개수</li></ul></li><li><strong>Fan-out</strong>: 바깥으로 나가는 의존성<ul><li>컴포넌트 외부의 크래스에 의존하는 컴포넌트 내부의 클래수 개수</li></ul></li><li><strong>I(불안정성)</strong>: <code>I = Fan-out / (Fan-in + Fan-out)</code><ul><li>0 ~ 1</li><li>0이면 최고로 안정된 컴포넌트</li><li>1이면 최고로 불안정한 컴포넌트</li></ul></li></ul><p><code>Fan-in</code>과 <code>Fan-out</code> 지표는 특정 컴포넌트 내부의 클래스에 의존하는, 컴포넌트 외부에 위치한 클래스의 개수를 세어서 계산할 수 있다.</p><p><img src=/post/clean-architecture/14/img_7.png width=600 height=270 srcset="/post/clean-architecture/14/img_7_hub157614c3a6b055305efa756855a49e0_18409_480x0_resize_box_3.png 480w, /post/clean-architecture/14/img_7_hub157614c3a6b055305efa756855a49e0_18409_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=222 data-flex-basis=533px></p><ul><li><code>I</code> 값이 1이면 어떤 컴포넌트도 해당 컴포넌트에 의존하지 않지만, 해당 컴포넌트는 다른 컴포넌트에 의존한다는 뜻이다.<ul><li>최고로 불안정한 상태, 책임이 없으며 의존적이다.</li><li>자신에게 의존하는 컴포넌트가 없으므로 변경하지 말아야 할 이유가 없다.</li><li>다른 컴포넌트에 의존하기 때문에 언젠가는 해당 컴포넌트를 변경해야 할 이유가 있다.</li></ul></li><li><code>I</code> 값이 0이면 해당 컴포넌트에 의존하는 다른 컴포넌트가 있지만, 해당 컴포넌트 자체는 다른 컴포넌트에 의존하지 않는다는 뜻이다.<ul><li>최고로 안정된 상태, 다른 컴포넌트를 책임지면서 독립적이다.</li><li>자신에게 의존하는 컴포넌트가 있으므로 변경하기가 어렵다.</li><li>해당 컴포넌트를 변경하도록 강제하는 의존성은 같지 않는다.</li></ul></li></ul><p>SDP에서 컴포넌트 <code>I</code> 지표는 그 컴포넌느가 의존하는 다른 컴포넌트들의 <code>I</code>보다 커야한다고 말한다.</p><p>즉, 의존성 방향으로 갈수록 <code>I</code> 지표 값이 감소해야한다.</p><h3 id=모든-컴포넌트가-안정적이어야-하는-것은-아니다>모든 컴포넌트가 안정적이어야 하는 것은 아니다.</h3><p>모든 컴포넌트가 최고로 안정적인 시스템이라면 <strong>변경이 불가능</strong>하다.</p><p>이는 바람직한 상황은 아니며, 컴포넌트 구조를 설계할 때 기대하는 것은 <strong>불안정한 컴포넌트와 안정된 컴포넌트가 공존하는 상태</strong>다.</p><p><img src=/post/clean-architecture/14/img_8.png width=600 height=279 srcset="/post/clean-architecture/14/img_8_hudc89e9bfdfd398c241eb318aebd58dcb_13750_480x0_resize_box_3.png 480w, /post/clean-architecture/14/img_8_hudc89e9bfdfd398c241eb318aebd58dcb_13750_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=215 data-flex-basis=516px></p><p>위 다이어그램은 세 컴포넌트로 구성된 이상적인 구조이다.</p><p><strong>추상 컴포넌트</strong></p><p>인터페이스만을 포함하는 추상 컴포넌트는 상당히 안정적이므로, 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.</p><p><img src=/post/clean-architecture/14/img_9.png width=1234 height=265 srcset="/post/clean-architecture/14/img_9_hu6570728dfc635355d54dc2e2f70ef94b_129829_480x0_resize_box_3.png 480w, /post/clean-architecture/14/img_9_hu6570728dfc635355d54dc2e2f70ef94b_129829_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=465 data-flex-basis=1117px></p><p>안정적인 <code>Stable</code>의 내부 클래스 <code>U</code>가 불안정한 <code>Flexible</code>의 내부 클래스 <code>C</code>를 사용해야한다면, DIP를 도입해 문제를 해결할 수 있다.</p><p><img src=/post/clean-architecture/14/img_10.png width=1232 height=493 srcset="/post/clean-architecture/14/img_10_hu9ebc981cdc230977d03f9eebf0861deb_153552_480x0_resize_box_3.png 480w, /post/clean-architecture/14/img_10_hu9ebc981cdc230977d03f9eebf0861deb_153552_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=249 data-flex-basis=599px></p><p><code>US</code>라는 인터페이스를 생성한 수 <code>UServer</code> 컴포넌트에 넣고, 해당 인터페이스를 구현하도록 하면 <code>Stable</code>의 <code>Flexible</code>에 대한 의존성을 끊을 수 있고, <code>UServer</code> 자체는 어디에도 의존하지 않으므로 안정된 상태이므로, 모든 의존성이 감소하는 방향으로 개선할 수 있다.</p><h2 id=sap-안정된-추상화-원칙>SAP: 안정된 추상화 원칙</h2><blockquote><p>컴포넌트는 안정된 정도만큼만 추상화되어야 한다.</p></blockquote><h3 id=고수준-정책을-어디에-위치시켜야-하는가>고수준 정책을 어디에 위치시켜야 하는가?</h3><p>고수준 아키텍처가 정책 결정과 관련된 소프트웨어는 자주 변경되서는 절대로 안되는 소프트웨어이다.</p><p>따라서 시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트(<code>I = 0</code>)에 위치해야 한다.</p><p>불안정한 컴포넌트(<code>I = 1</code>)는 반드시 변동성이 큰 소프트웨어, 즉 쉽고 바르게 변경할 수 있는 소프트웨어만을 포함해야 한다.</p><p>하지만 고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스코드는 수정하기 어려워져 시스템 전체 아키텍쳐가 유연성을 잃게 된다.</p><p>개방 폐쇄 원칙의 추상화를 통해 컴포넌트가 최고로 안정된 상태이면서도 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있다.</p><h3 id=안정된-추상화-원칙>안정된 추상화 원칙</h3><p>안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의한다.</p><ul><li>안정된 컴포넌트는 추상 컴포넌트여야한다.</li><li>이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다.</li><li>불안정한 컴포넌트는 반드시 구체 컴포넌트여야한다.<ul><li>컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하므로</li></ul></li></ul><p>따라서 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다.</p><p>안정된 컴포넌트가 확장 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 된다.</p><p>SDP에서는 의존성이 반드시 안정성의 방향으로 향해야 한다고 말하며, SAP에서는 안정성이 결국 추상화를 의미한다고 말하기 때문에 SAP와 SDP를 결합하면 <strong>컴포넌트에 대한 DIP</strong>와 같다.</p><ul><li>따라서 의존성은 추상화의 방향으로 향하게 된다.</li></ul><h3 id=추상화-정도-측정하기>추상화 정도 측정하기</h3><p>SDP + SPA 조합이 컴포넌트에 대한 DIP라고 언급했었지만, DIP는 클래스에 대한 원칙이므로 추상적이거나 그렇지 않거나 둘중 하나이다.</p><p>하지만 SDP + SAP 조합은 컴포넌트에 대한 원칙이므로 컴포넌트의 어떤 부분은 추상적이면서 다른 부분은 안정적일 수 있다.</p><p><code>A</code> 지표는 컴포넌트의 클래스 총 수 대비 인터페이스와 추상 클래스의 개수를 단순히 계산하여 컴포넌트의 추상화 정도를 측정한 값이다.</p><ul><li><code>Nc</code>: 컴포넌트의 클래스 개수</li><li><code>Na</code>: 컴포넌트의 추상 클래스와 인터페이스 개수</li><li><code>A</code>: 추상화 정도<ul><li><code>A = Na / Nc</code></li></ul></li></ul><p><code>A</code>지표는 0과 1 사이의 값을 가지며, 0이면 추상 클래스가 하나도 없다는 뜻, 1이면 추상클래스만 포함한다는 뜻이다.</p><h3 id=주계열-main-sequence>주계열: Main Sequence</h3><p><img src=/post/clean-architecture/14/img_11.png width=600 height=297 srcset="/post/clean-architecture/14/img_11_hua926ad8375330f6f0926e565cc510cc5_5673_480x0_resize_box_3.png 480w, /post/clean-architecture/14/img_11_hua926ad8375330f6f0926e565cc510cc5_5673_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=202 data-flex-basis=484px></p><ul><li>최고로 안정적이며 추상화된 컴포넌트는 (0, 1)</li><li>최고로 불안정하며 구체화된 컴포넌트는 (1, 0)</li></ul><p>컴포넌트는 추상화와 안정화 정도가 다양하므로 두 지점에만 분포할 수는 없다.</p><p><img src=/post/clean-architecture/14/img_12.png width=579 height=297 srcset="/post/clean-architecture/14/img_12_huf3699ca9d7d2715e368d8f9e5572debf_24335_480x0_resize_box_3.png 480w, /post/clean-architecture/14/img_12_huf3699ca9d7d2715e368d8f9e5572debf_24335_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=194 data-flex-basis=467px></p><p>따라서 A/I 그래프 상에서 컴포넌트가 위치할 수 있는 합리적인 지점을 정의하는 궤적이 있을 것이라 가정해 볼 수 있으며, 이 궤적은 컴포넌트가 절대로 위치해서는 안 되는 영역(배제할 구역)을 찾는 방식으로 추론할 수 있다.</p><h3 id=고통의-구역-zone-of-pain>고통의 구역: Zone of Pain</h3><p>(0, 0) 주변 구역에 위치한 컴포넌트는 매우 안정적이며 구체적이므로 굉장히 뻣뻣한 상태로 바람직한 상태는 아니다.</p><ul><li>추상적이지 않으므로 확장할 수 없다.</li><li>안정적이므로 변경하기 어렵다.</li></ul><p>제대로 설계된 컴포넌트라면 (0, 0) 근처에는 위치하지 않을 것이라 보는게 일반적이다.</p><p>일부 소프트웨어 엔티티는 고통의 구역에 위치한다.</p><ul><li>데이터베이스 스키마<ul><li>변동성이 매우 높다.</li><li>극단적으로 구체적이다.</li><li>많은 컴포넌트가 의존한다.</li><li>OO 애플리케이션과 데이터베이스 사이에 위치한 인터페이스는 관리하기 굉장히 어렵다.</li><li>스키마가 변경되면 대체로 고통을 수반한다.</li></ul></li><li>유틸리티 라이브러리(<code>String</code> 컴포넌트)<ul><li>I가 1일지라도, 실제로는 변동성이 거의 없다.</li><li>속한 클래스가 모두 구체 클래스이다.</li><li>광범위하게 사용되어 수정하면 혼란을 초래할 수 있다.</li></ul></li></ul><p>변동될 가능성이 거의 없는 컴포넌트는 (0, 0)에 위치했더라도 해롭지 않다.</p><p>고통의 구역에서 문제가 되는 경우는 변동성이 있는 소프트웨어 컴포넌트이다.</p><h3 id=쓸모없는-구역-zone-of-uselessness>쓸모없는 구역: Zone of Uselessness</h3><p>(1, 1)에 위치한 컴포넌트는 최고로 추상적이지만 누구도 그 컴포넌트에 의존하지 않기 때문에 쓸모없는 컴포넌트이며 이로인해 쓸모없는 구역이라 부른다.</p><p>이 영역에 존재하는 소프트웨어 엔티티는 폐기물과도 같다.</p><ul><li>대부분 누구도 구현하지 않은 채 남겨진 추상 클래스</li></ul><p>쓸모없는 구역 내부 깊숙이 자리잡은 컴포넌트는 이러한 엔티티의 상당 부분을 포함할 가능성이 높다.</p><h3 id=배제-구역-벗어나기>배제 구역 벗어나기</h3><p>변동성이 큰 컴포넌트 대부분은 두 배제 구역으로부터 가능한 멀리 떨어뜨려야 한다.</p><p>주계열에 위치한 컴포넌트는 자신의 안정성에 비해 너무 추상적이지도 않고, 추상화 정도에 비해 너무 불안정하지도 않다.</p><ul><li>쓸모없지 않으면서 고통을 안겨 주지도 않는다.</li><li>추상화된 수준에 어울릴 정도로만 다른 컴포넌트가 의존한다.</li><li>구체화된 수준에 어울릴 정로로만 다른 컴포넌트에 의존한다.</li></ul><p>컴포넌트가 위치할 수 있는 가장 바람직한 지점은 <strong>주계열의 두 종점</strong>이다.</p><p>하지만 대규모 시스템에서 일부 컴포넌트는 완벽히 추상적이거나 완전하게 안정적일 수 없으므로, 이러한 컴포넌트는 주 계열 바로 위에 또는 가깝게 위치하게 설계하는 것이 이상적이다.</p><h3 id=주계열과의-거리>주계열과의 거리</h3><p>추상화 정도를 측정하는 A/I 그래프에서 (1, 0), (0, 1)를 연결하는 직선인 주계열을 기준으로 해당 컴포넌트가 얼마나 떨어져있는지 거리를 측정하여 지표으로 사용할 수 있다.</p><ul><li>D: 거리, D = |A + I - 1|<ul><li>유효범위: [0, 1]</li><li>0이면 주계열 바로 위에 위치, 1이면 주계열로부터 가정 멀리 위치</li></ul></li></ul><p>이 지표를 통해 컴포넌트가 주계열에 대체로 일치하도록 설계되었는지(추상화, 구체화 수준에 어울리는 의존성을 갖는지) 분석하고, 거리가 먼 컴포넌트들을 개선할 수 있다.</p><p><strong>통계적 활용</strong></p><p>값으로 계산할 수 있으므로 통계적으로 분석 가능해진다.</p><p>설계에 포함된 컴포넌트들의 D를 계산하고 이들의 평균과 분산을 측정하였을때, 주계열에 일치하도록 설계되었다면 평균과 분산은 0에 가까워진다.</p><ul><li>분산을 통해 다른 컴포넌트에 비해 극히 예외적인 컴포넌트르 식별할 수 있으므로 관리 한계를 결정하는데 유용할 수 있다.</li></ul><p><strong>시간에 따른 변화 확인</strong></p><p>각 컴포넌트의 D 값을 시간의 흐름에 따라 확인해보면, 해당 컴포넌트가 시간이 지남에 따라 의존성이 어떻게 변화하는지 확인할 수 있다.</p><p>이를 통해 주계열에서 멀리 벗어난 컴포넌트들을 분석하여 인사이트를 얻는 것도 가능하다.</p><h2 id=결론>결론</h2><p>의존성 관리 지표는 설계의 의존성과 추상화 정도가 휼륭한 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다.</p><p>하지만 지표는 임의로 결정된 표준을 기초로 한 측정값이므로 진리가 아니며, 의존성의 좋고 나쁨을 지표로만 판단해서는 안된다.</p><p>그러나 이러한 지표를 통해 이상을 확인할 여지가 충분하고, 이를 상세하게 분석하여 아키텍처 개선에 유용하게 사용될 수 있다.</p></section><footer class=article-footer><section class=article-tags><a href=/tags/clean-architecture/>Clean Architecture</a>
<a href=/tags/%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/>클린 아키텍처</a>
<a href=/tags/%EC%84%A4%EA%B3%84/>설계</a>
<a href=/tags/design/>Design</a>
<a href=/tags/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/>아키텍처</a>
<a href=/tags/architecture/>Architecture</a>
<a href=/tags/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%9B%90%EC%B9%99/>컴포넌트 원칙</a>
<a href=/tags/component-principles/>Component Principles</a>
<a href=/tags/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/>컴포넌트</a>
<a href=/tags/components/>Components</a>
<a href=/tags/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EA%B2%B0%ED%95%A9/>컴포넌트 결합</a>
<a href=/tags/component-coupling/>Component Coupling</a>
<a href=/tags/adp/>ADP</a>
<a href=/tags/%EC%9D%98%EC%A1%B4%EC%84%B1-%EB%B9%84%EC%88%9C%ED%99%98-%EC%9B%90%EC%B9%99/>의존성 비순환 원칙</a>
<a href=/tags/acyclic-dependencies-principle/>Acyclic Dependencies Principle</a>
<a href=/tags/sdp/>SDP</a>
<a href=/tags/%EC%95%88%EC%A0%95%EB%90%9C-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%9B%90%EC%B9%99/>안정된 의존성 원칙</a>
<a href=/tags/sap/>SAP</a>
<a href=/tags/%EC%95%88%EC%A0%95%EB%90%9C-%EC%B6%94%EC%83%81%ED%99%94-%EC%9B%90%EC%B9%99/>안정된 추상화 원칙</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><div class="article-list--compact links"><article><a href=https://product.kyobobook.co.kr/detail/S000001033082 target=_blank rel=noopener><div class=article-details><h2 class=article-title>클린 아키텍처: 소프트웨어 구조와 설계의 원칙</h2><footer class=article-time>살아있는 전설이 들려주는 실용적인 소프트웨어 아키텍처 원칙 | 모든 프로그래머가 읽어야 하는 필독서!</footer></div></a></article></div><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/post/clean-architecture/12/><div class=article-image><img src=/post/clean-architecture/12/cover.8c3d183c5f9cbadfe69a2bd0021a711c_hu01783d23203014d58ee585db2e3121c4_1011761_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 12. 컴포넌트" data-key=clean-architecture/12 data-hash="md5-jD0YPF+cut/mmivQAhpxHA=="></div><div class=article-details><h2 class=article-title>12. 컴포넌트</h2></div></a></article><article class=has-image><a href=/post/clean-architecture/13/><div class=article-image><img src=/post/clean-architecture/13/cover.8c3d183c5f9cbadfe69a2bd0021a711c_hu01783d23203014d58ee585db2e3121c4_1011761_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 13. 컴포넌트 응집도" data-key=clean-architecture/13 data-hash="md5-jD0YPF+cut/mmivQAhpxHA=="></div><div class=article-details><h2 class=article-title>13. 컴포넌트 응집도</h2></div></a></article><article class=has-image><a href=/post/clean-architecture/25/><div class=article-image><img src=/post/clean-architecture/25/cover.8c3d183c5f9cbadfe69a2bd0021a711c_hu01783d23203014d58ee585db2e3121c4_1011761_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 25. 계층과 경계" data-key=clean-architecture/25 data-hash="md5-jD0YPF+cut/mmivQAhpxHA=="></div><div class=article-details><h2 class=article-title>25. 계층과 경계</h2></div></a></article><article class=has-image><a href=/post/clean-architecture/24/><div class=article-image><img src=/post/clean-architecture/24/cover.8c3d183c5f9cbadfe69a2bd0021a711c_hu01783d23203014d58ee585db2e3121c4_1011761_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 24. 부분적 경계" data-key=clean-architecture/24 data-hash="md5-jD0YPF+cut/mmivQAhpxHA=="></div><div class=article-details><h2 class=article-title>24. 부분적 경계</h2></div></a></article><article class=has-image><a href=/post/clean-architecture/23/><div class=article-image><img src=/post/clean-architecture/23/cover.8c3d183c5f9cbadfe69a2bd0021a711c_hu01783d23203014d58ee585db2e3121c4_1011761_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 23. 프레젠터와 험블 객체" data-key=clean-architecture/23 data-hash="md5-jD0YPF+cut/mmivQAhpxHA=="></div><div class=article-details><h2 class=article-title>23. 프레젠터와 험블 객체</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=codemario318/codemario318.github.io issue-term=pathname label=Comment crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2023 -
2024 Mario Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>