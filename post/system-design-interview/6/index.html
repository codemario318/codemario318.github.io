<!doctype html><html lang=ko dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="가상 면접 사례로 배우는 대규모 시스템 설계 기초"><title>6. 키-값 저장소 설계</title><link rel=canonical href=https://codemario318.github.io/post/system-design-interview/6/><link rel=stylesheet href=/scss/style.min.cbce94e2760d14d60414e59d5a36ab2819232375817e010dbe7be2234b67da1b.css><meta property="og:title" content="6. 키-값 저장소 설계"><meta property="og:description" content="가상 면접 사례로 배우는 대규모 시스템 설계 기초"><meta property="og:url" content="https://codemario318.github.io/post/system-design-interview/6/"><meta property="og:site_name" content="Mario Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="가상 면접 사례로 배우는 대규모 시스템 설계 기초"><meta property="article:tag" content="System Design Interview"><meta property="article:tag" content="키-값 저장소"><meta property="article:tag" content="Key-Value Store"><meta property="article:tag" content="비 관계형 데이터베이스"><meta property="article:tag" content="Non-relational DB"><meta property="article:tag" content="분산 키-값 저장소"><meta property="article:tag" content="Distribute Key-Value Store"><meta property="article:tag" content="레디스"><meta property="article:tag" content="Redis"><meta property="article:tag" content="다이나모 DB"><meta property="article:tag" content="DynamoDB"><meta property="article:tag" content="memcached"><meta property="article:published_time" content="2024-05-27T11:59:50+09:00"><meta property="article:modified_time" content="2024-05-27T11:59:50+09:00"><meta property="og:image" content="https://codemario318.github.io/post/system-design-interview/6/cover.png"><meta name=twitter:title content="6. 키-값 저장소 설계"><meta name=twitter:description content="가상 면접 사례로 배우는 대규모 시스템 설계 기초"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://codemario318.github.io/post/system-design-interview/6/cover.png"><script async src="https://www.googletagmanager.com/gtag/js?id=G-K99591YLGK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K99591YLGK",{anonymize_ip:!1})}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3183752545292673" crossorigin=anonymous></script><meta name=naver-site-verification content="2315bde85c86f66092140cc465c340a2170f3187"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu760fd15c5fbb2f30cf0868dc4a5dc41a_14271_300x0_resize_q75_box.jpeg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Mario Blog</a></h1><h2 class=site-description></h2></div></header><ol class=social-menu><li><a href=https://github.com/codemario318 target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><ul class="menu sub-menu"><li><a href=/categories/backend/><span>Backend</span>
<span class=content-count>3</span></a></li><li><a href=/categories/boostcamp/><span>부스트캠프</span>
<span class=content-count>11</span></a></li><li><a href=/categories/cleancode/><span>Clean Code</span>
<span class=content-count>10</span></a></li><li><a href=/categories/common/><span>Common</span>
<span class=content-count>76</span></a></li><li><a href=/categories/data/><span>Data</span>
<span class=content-count>3</span></a></li><li><a href=/categories/db/><span>DB</span>
<span class=content-count>1</span></a></li><li><a href=/categories/frontend/><span>Frontend</span>
<span class=content-count>10</span></a></li><li><a href=/categories/golang/><span>GoLang</span>
<span class=content-count>13</span></a></li><li><a href=/categories/headfirstdesignpatterns/><span>헤드 퍼스트 디자인 패턴</span>
<span class=content-count>22</span></a></li><li><a href=/categories/infra/><span>Infra</span>
<span class=content-count>14</span></a></li><li><a href=/categories/nest/><span>Nest</span>
<span class=content-count>1</span></a></li><li><a href=/categories/network/><span>네트워크</span>
<span class=content-count>1</span></a></li><li><a href=/categories/node/><span>Node</span>
<span class=content-count>6</span></a></li><li><a href=/categories/problemsolving/><span>Problem Solving</span>
<span class=content-count>1</span></a></li><li><a href=/categories/project/><span>Project</span>
<span class=content-count>5</span></a></li><li><a href=/categories/realmysql/><span>Real MySQL</span>
<span class=content-count>53</span></a></li></ul><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#문제-이해-및-설계-범위-확정>문제 이해 및 설계 범위 확정</a></li><li><a href=#단일-서버-키-값-저장소>단일 서버 키-값 저장소</a></li><li><a href=#분산-키-값-저장소>분산 키 값 저장소</a><ol><li><a href=#cap-정리>CAP 정리</a></li><li><a href=#구체적-사례>구체적 사례</a><ol><li><a href=#이상적-상태>이상적 상태</a></li><li><a href=#실세계의-분산-시스템>실세계의 분산 시스템</a></li></ol></li><li><a href=#시스템-컴포넌트>시스템 컴포넌트</a><ol><li><a href=#데이터-파티션>데이터 파티션</a></li><li><a href=#데이터-다중화>데이터 다중화</a></li><li><a href=#데이터-일관성>데이터 일관성</a></li><li><a href=#장애-처리>장애 처리</a></li><li><a href=#장애-감지>장애 감지</a></li><li><a href=#일시적-장애-처리>일시적 장애 처리</a></li><li><a href=#영구-장애-처리>영구 장애 처리</a></li><li><a href=#데이터-센터-장애-처리>데이터 센터 장애 처리</a></li></ol></li><li><a href=#시스템-아키텍처-다이어그램>시스템 아키텍처 다이어그램</a></li><li><a href=#쓰기-경로>쓰기 경로</a></li><li><a href=#읽기-경로>읽기 경로</a></li></ol></li><li><a href=#요약>요약</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/post/system-design-interview/6/><img src=/post/system-design-interview/6/cover_huebcf5dd667df9af228f80687035dfdfb_164704_800x0_resize_box_3.png srcset="/post/system-design-interview/6/cover_huebcf5dd667df9af228f80687035dfdfb_164704_800x0_resize_box_3.png 800w, /post/system-design-interview/6/cover_huebcf5dd667df9af228f80687035dfdfb_164704_1600x0_resize_box_3.png 1600w" width=800 height=454 loading=lazy alt="Featured image of post 6. 키-값 저장소 설계"></a></div><div class=article-details><header class=article-category><a href=/categories/common/ style=background-color:#2a9d8f;color:#fff>Common</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/system-design-interview/6/>6. 키-값 저장소 설계</a></h2><h3 class=article-subtitle>가상 면접 사례로 배우는 대규모 시스템 설계 기초</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2024/05/27</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>14 minute read</time></div></footer></div></header><section class=article-content><p>키-값 저장소(key-value store)는 키-값 데이터베이스라고도 불리는 비 관계형(non-relational) 데이터베이스이다.</p><ul><li>이 저장소에 저장되는 값은 <strong>고유 식별자</strong>를 키로 가져야한다.</li><li>키와 값 사이의 이런 연결 관계를 <strong>키-값 쌍</strong>(key-value pair)이라고 지칭한다.</li></ul><p><strong>키</strong><br>키-값 쌍에서의 키는 <strong>유일</strong>해야 하며 해당 키에 매달린 값은 <strong>키를 통해서만 접근</strong>할 수 있다.</p><p>키는 일반 텍스트일 수도 있고 해시 값일 수도 있지만, 성능상의 이유로 짧을수록 좋다.</p><ul><li>일반 텍스트 키: &ldquo;last_logged_in_at&rdquo;</li><li>해시 키: 253DDEC4</li></ul><p><strong>값</strong><br>키-값 저장소는 보통 <strong>값으로 무엇이 오든 상관하지 않는다</strong>.</p><ul><li>문자열, 리스트, 객체 등</li></ul><hr><p>키-값 저장소로 널리 알려진 것은 아마존 다이나모, memcached, 레디스 같은 것들이 있다.</p><p>또한 기본적으로 아래와 같은 연산을 지원해야한다.</p><ul><li><code>put(key, value)</code>: 키-값 쌍을 저장소에 저장한다.</li><li><code>get(key)</code>: 인자로 주어진 키에 매달린 값을 꺼낸다.</li></ul><h2 id=문제-이해-및-설계-범위-확정>문제 이해 및 설계 범위 확정</h2><p>완벽한 설계란 없다.</p><p>읽기, 쓰기 그리고 메모리 사용량 사이에 어떤 균형을 찾고, 데이터의 일관성과 가용성 사이에서 타협적 결정을 내린 설계를 만들었다면 충분히 쓸만한 답이다.</p><p>이번 장에서는 다음 특성을 갖는 키-값 저장소를 설계해본다.</p><ul><li>키-값 쌍의 크기는 10KB 이하이다.</li><li>큰 데이터를 저장할 수 있어야 한다.</li><li>높은 가용성을 제공해야한다.<ul><li>시스템은 장애가 있더라도 빨리 응답해야한다.</li></ul></li><li>높은 규모 확장성을 제공해야 한다.<ul><li>트래픽 양에 따라 자동적으로 서버 증설/삭제가 이루어져야 한다.</li></ul></li><li>데이터 일관성 수준은 조정이 가능해야 한다.</li><li>응답 지연시간(latency)이 짧아야 한다.</li></ul><h2 id=단일-서버-키-값-저장소>단일 서버 키-값 저장소</h2><p>한 대 서버만 사용하는 키-값 저장소는 설계가 쉽다.</p><p>가장 직관적인 방법은 키-값 쌍 전부를 메모리에 해시 테이블로 저장하는 것이다.</p><p>이 방법은 빠른 속도를 보장하지만 <strong>모든 데이터를 메모리안에 두는 것이 불가능</strong>할 수도 있다.</p><p>이 문제의 개선책은 다음과 같은 것들이 있다.</p><ul><li>데이터 압축</li><li>자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장</li></ul><p>이렇게 개선한다고 해도, 한 대 서버로 부족한 때가 찾아오며, 많은 데이터를 저장하기 위해서 <strong>분산 키-값 저장소</strong>를 만들어야한다.</p><h2 id=분산-키-값-저장소>분산 키 값 저장소</h2><p>분산 키 값 저장소는 키-값 쌍을 여러 서버에 분산시키므로 <strong>분산 해시 테이블</strong>이라고도 불린다.</p><p>분산 시스템을 설계할 때는 <strong>CAP 정리</strong>(Consistency, Availability, Partition Tolerance theorem)를 이해하고 있어야 한다.</p><h3 id=cap-정리>CAP 정리</h3><p>CAP 정리는 <strong>데이터 일관성(consistency), 가용성(availability), 파티션 감내(partition tolerance)라는 세가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다</strong>는 정리이다.</p><ul><li>데이터 일관성<ul><li>분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.</li></ul></li><li>가용성<ul><li>분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.</li></ul></li><li>파티션 감내<ul><li>파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다.</li><li>네트워크에 파티션(분할)이 생기더라도 시스템은 계속 동작하여야 한다는 것을 뜻한다.</li></ul></li></ul><blockquote><p><strong>네트워크 파티션?</strong><br>테이터베이스 시스템의 일부 노드들이 서로 통신할 수 없는 상황으로 인해 각 노드들(파티션)이 독립적으로 동작하게 되어 각 파티션이 서로 다른 상태나 데이터를 가지게 되는 상황</p></blockquote><p><img src=/post/system-design-interview/6/img.png width=828 height=608 srcset="/post/system-design-interview/6/img_hu8399b985eaaab4d8c3cc5e2bfd3651de_149592_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_hu8399b985eaaab4d8c3cc5e2bfd3651de_149592_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=136 data-flex-basis=326px></p><p>따라서 이들 가운데 <strong>어떤 두 가지를 충족하려면 나머지 하나는 반드시 희생되어야 한다</strong>는 것을 의미한다.</p><p>키 값 저장소는 세 가지 요구사항 가운데 어느 두 가지를 만족하느냐에 따라 다음과 같이 분류할 수 있다.</p><ul><li>CP: 일관성과 파티션 감내를 지원(가용성 희생)</li><li>AP: 가용성과 파티션 감내를 지원(데이터 일관성 희생)</li><li>CA: 일관성과 가용성을 지원(파티션 감내 지원 안함)<ul><li>통상 네트워크 장애는 피할 수 없는 일로 여겨지므로, 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야 한다.</li><li>실세계에서 CA 시스템은 존재하지 않는다.</li></ul></li></ul><h3 id=구체적-사례>구체적 사례</h3><p>분산 시스템에서 데이터는 보통 여러 노드에 복제되어 보관된다.</p><h4 id=이상적-상태>이상적 상태</h4><p><img src=/post/system-design-interview/6/img_1.png width=840 height=592 srcset="/post/system-design-interview/6/img_1_hua0faa9aa952f92ab7c5a2fe27ee0e7c0_91753_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_1_hua0faa9aa952f92ab7c5a2fe27ee0e7c0_91753_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=141 data-flex-basis=340px></p><p>이상적인 환경이라면 <strong>네트워크가 파티션되는 상황은 절대로 일어나지 않을 것</strong>이다.</p><ul><li><strong>n1</strong>에 기록된 데이터는 자동적으로 <strong>n2</strong>, <strong>n3</strong>에 복제되며 데이터 일관성과 가용성도 만족한다.</li></ul><h4 id=실세계의-분산-시스템>실세계의 분산 시스템</h4><p>분산 시스템은 파티션 문제를 피할 수 없다.</p><p>파티션 문제가 발생하면 <strong>일관성과 가용성 사이에서 하나를 선택</strong>해야 한다.</p><p><img src=/post/system-design-interview/6/img_2.png width=839 height=605 srcset="/post/system-design-interview/6/img_2_hud8043c96815985a7c6b0f4ed2ff33b87_103442_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_2_hud8043c96815985a7c6b0f4ed2ff33b87_103442_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=138 data-flex-basis=332px></p><p><strong>n3</strong>에 장애가 발생하여 <strong>n1</strong>, <strong>n2</strong>와 통신 할 수 없는 상황에서</p><ul><li>클라이언트가 <strong>n1</strong>, <strong>n2</strong>에 기록한 데이터는 <strong>n3</strong>에 전달되지 않는다.</li><li><strong>n3</strong>에 기록되었으나 <strong>n1</strong>, <strong>n2</strong>로 전달되지 않은 데이터가 있다면 오래된 사본을 갖고 있을 것이다.</li></ul><p><strong>CP 시스템</strong></p><p>가용성 대신 일관성을 선택한다면 세 서버 사이에 생길 수 있는 데이터 불일치 문제를 피하기 위해 <strong>n1</strong>, <strong>n2</strong>에 대해 <strong>쓰기 연산을 중단</strong>시켜야한다.</p><p>이러한 경우 일부 노드가 장애가 발생하여도 동작해야 한다는 가용성이 깨진다.</p><p>데이터 일관성을 양보할 수 없는 시스템은 이렇게 처리되어 상황이 해결될 때 까지 오류를 반환해야 한다.</p><ul><li>온라인 뱅킹 등</li></ul><p><strong>AP 시스템</strong></p><p>일관성 대신 가용성을 선택한 시스템은 <strong>낡은 데이터를 반환할 위험이 있더라도 계속 읽기 연산을 허용</strong>해야한다.</p><p><strong>n1</strong>, <strong>n2</strong>는 계속 쓰기 연산을 허용하고, 파티션 문제가 해결된 뒤 새 데이터를 <strong>n3</strong>에 전송해야한다.</p><hr><p>분산 키-값 저장소를 만들 때는 그 요구사항에 맞도록 CAP 정리를 적용해야 한다.</p><p>면접 상황에서는 이 문제에 대해 면접관과 상의하고, 그 결론에 따라 시스템을 설계하도록 하자.</p><h3 id=시스템-컴포넌트>시스템 컴포넌트</h3><p>키-값 저장소 구형에 사용되는 핵심 컴포넌트들 및 기술을 살펴본다.</p><ul><li>데이터 파티션</li><li>데이터 다중화</li><li>일관성</li><li>일관성 불일치 해소</li><li>장애 처리</li><li>시스템 아키텍처 다이어그램</li><li>쓰기 경로</li><li>읽기 경로</li></ul><h4 id=데이터-파티션>데이터 파티션</h4><p>대규모 애플리케이션의 경우 전체 데이터를 한 대 서버에 욱여넣는 것은 불가능하다.</p><p>가장 단순한 해결책은 <strong>데이터를 작은 파티션들로 분할한 다음 여러 대 서버에 저장하는 것</strong>이다.</p><ul><li>데이터를 여러 서버에 고르게 분산할 수 있는가</li><li>노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가</li></ul><p>5장에서 다룬 안정 해시는 이런 문제를 푸는 데 적합한 기술로 활용될 수 있다.</p><p>안정 해시를 사용하여 데이터를 파티션하면 몇가지 장점이 있다.</p><ul><li>규모 확장 자동화(automatic scaling)<ul><li>시스템 부하에 따라 서버가 자동으로 추가되거나 삭제되도록 만들 수 있다.</li></ul></li><li>다양성(heterogeneity)<ul><li>각 서버의 용량에 맞게 가상 노드의 수를 조정할 수 있다.</li><li>고성능 서버는 더 많은 가상노드를 갖도록&mldr;</li></ul></li></ul><h4 id=데이터-다중화>데이터 다중화</h4><p>높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있다.</p><p>어떤 키를 해시 링 위에 배치한 수, 그 지점으로부터 시계 방향으로 링을 순회하면서 만나는 첫 N개 서버에 데이터 사본을 보관한다.</p><p><img src=/post/system-design-interview/6/img_3.png width=843 height=685 srcset="/post/system-design-interview/6/img_3_hu0675f294d26db8b4acf424a88b68b693_77163_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_3_hu0675f294d26db8b4acf424a88b68b693_77163_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=123 data-flex-basis=295px></p><p>하지만 가상 노드를 사용한다면 선택한 N개의 노드가 대응될 실제 물리 서버의 개수가 N보다 작아질 수 있다.</p><p>이 문제를 피하려면 노드를 선택할 때 같은 물리 서버를 중복으로 선택하지 않도록 해야한다.</p><p>같은 데이터 센터에 속한 노드는 정전, 네트워크 이슈, 자연 재해 등의 문제를 동시에 같이 겪을 가능성이 있으므로, 안정성을 담보하기 위해 데이터의 사본은 다른 센터의 서버에 보관하고, 센터들은 고속 네트워크로 연결한다.</p><h4 id=데이터-일관성>데이터 일관성</h4><p>여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 한다.</p><p><strong>정족수 합의</strong>(Quorum Consensus) 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.</p><ul><li><code>N</code>: 사본의 개수</li><li><code>W</code>: 쓰기 연산에 대한 정족수<ul><li>쓰기 연산이 성공한 것으로 간주되려면 적어도 <code>W</code>개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야함</li></ul></li><li><code>R</code>: 읽기 연산에 대한 정족수<ul><li>읽기 연산이 성공한 것으로 간주되려면 적어도 <code>R</code>개의 서버로부터 응답을 받아야함</li></ul></li></ul><p>일반적으로 <code>N = R + W > N</code> 조건을 만족하도록 설정하며, 읽기와 쓰기 요청이 적어도 하나의 공통 노드를 통해 일관성을 유지하도록 보장한다.</p><p><img src=/post/system-design-interview/6/img_4.png width=839 height=579 srcset="/post/system-design-interview/6/img_4_huec6b456c1e9a98e57b711c077ef003c7_99493_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_4_huec6b456c1e9a98e57b711c077ef003c7_99493_1024x0_resize_box_3.png 1024w" loading=lazy alt="N = 3" class=gallery-image data-flex-grow=144 data-flex-basis=347px></p><p><code>W = 1</code>는 쓰기 연산이 성공했다고 판단하기 위해 중재자(coordinator)는 최소 한 대 서버로부터 쓰기 성공 응답을 받아야한다는 뜻이다.</p><ul><li><strong>s1</strong>으로 부터 성공 응답을 받았다면, 나머지 응답은 기다릴 필요가 없다.</li></ul><p>중재자는 클라이언트와 노드 사이에서 프락시(proxy)역할을 한다.</p><hr><p><code>W</code>, <code>R</code>, <code>N</code>의 값을 정하는 것은 응답 지연과 데이터 일관성 사이의 타협점을 찾는 전형정인 과정이다.</p><ul><li><code>W = 1</code> or <code>R = 1</code><ul><li>중재자는 한 대 서버로부터의 응답만 받으면 되므로 응답속도는 빠르다.</li></ul></li><li><code>W > 1</code> or <code>R > 1</code><ul><li>데이터 일관성의 수준은 향상되지만 중재자의 응답 속도는 가장 느린 서버로부터의 응답을 기다려야 하므로 느려진다.</li></ul></li></ul><p>따라서 <code>W + R > N</code>인 경우에는 일관성을 보증할 최신 데이터를 가진 노드가 최소 하나는 겹치므로 강한 일관성이 보장된다.</p><ul><li><code>R = 1</code>, <code>W = N</code><ul><li>빠른 읽기 연산에 최적화된 시스템</li></ul></li><li><code>R = N</code>, <code>W = 1</code><ul><li>빠른 쓰기 연산에 최적화된 시스템</li></ul></li><li><code>R + W > N</code><ul><li>강한 일관성이 보장됨<ul><li>보통 <code>N = 3</code>, <code>W = R = 2</code></li></ul></li></ul></li><li><code>R + W &lt;= N</code><ul><li>강한 일관성이 보장되지 않음</li></ul></li></ul><p>요구되는 일관성 수준에 따라 <code>W</code>, <code>R</code>, <code>N</code> 값을 조정한다.</p><p><strong>일관성 모델</strong></p><p>일관성 모델(consistency model)은 키-값 저장소를 설계할 때 고려해야 할 요소로 데이터 일관성 수준을 결정한다.</p><ul><li>강한 일관성<ul><li>모든 읽기 연산은 최신 결과를 반환한다.</li><li>클라이언트는 절대로 낡은 데이터를 볼 수 없다.</li></ul></li><li>약한 일관성<ul><li>읽기 연산은 최신 결과를 반환하지 못할 수 있다.</li></ul></li><li>결과적 일관성<ul><li>약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영(동기화)된다.</li></ul></li></ul><p><strong>강한 일관성</strong>을 달성하는 일반적인 방법은, <strong>모든 사본에 현재 쓰기 연산의 결과가 반영될 때까지 해당 데이터에 대한 읽기/쓰기를 금지</strong>하는 것이다.</p><ul><li>새로운 요청의 처리가 중단되므로 고 가용성 시스템에는 적합하지 않다.</li></ul><p>다이나모 또는 카산드라 같은 저장소는 결과적 일관성 모델을 택하고 있다.</p><ul><li>결과적 일관성 모델을 따를 경우 <strong>쓰기 연산이 병렬적으로 발생하면 시스템에 저장된 값의 일관성이 깨어질 수 있는데</strong>, 이 문제는 클라이언트가 해결해야한다.</li><li>클라이언트 측에서 데이터의 버전 정보를 활용해 일관성이 깨진 데이터를 읽지 않도록 해야한다.</li></ul><p>데이터를 다중화하면 가용성은 높아지지만 사본 간 일관성이 깨질 가능성은 높아진다.</p><p><strong>비 일관성 해소 기법: 데이터 버저닝</strong></p><p>버저닝은 데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만든다.</p><ul><li>각 버전은 변경 불가능하다.</li></ul><p><img src=/post/system-design-interview/6/img_5.png width=838 height=387 srcset="/post/system-design-interview/6/img_5_hu314294c50ed1dac3bf6da051bfbc696c_78353_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_5_hu314294c50ed1dac3bf6da051bfbc696c_78353_1024x0_resize_box_3.png 1024w" loading=lazy alt="충돌하는 두 값" class=gallery-image data-flex-grow=216 data-flex-basis=519px></p><p>서버 1, 2가 다른 노드의 같은<code>name</code>의 값을 동시에 변경하여 충돌이 발생했다고 가정했을 때 각각을 버전 <strong>v1</strong>, <strong>v2</strong>로 볼 수 있다.</p><p>이러한 충돌 문제를 해결하려면, 충돌을 발견하고 자동으로 해결해 낼 버저닝 시스템이 필요하다.</p><p><strong>백터 시계</strong>(vector clock)는 <strong><code>[서버, 버전]</code>의 순서 쌍을 데이터에 매단 것</strong>으로 충돌 문제를 푸는데 보편적으로 사용된다.</p><ul><li>어떤 버전이 선행 버전인지, 후행 버전인지, 충돌이 있는지 판별하는 데 쓰인다.</li></ul><p>데이터 D를 서버 <strong>Si</strong>에 기록하려면 아래 작업 가운데 하나를 수행해야한다.</p><ul><li><code>[Si, Vi]</code>가 있으면 <code>Vi</code>를 증가시킨다.</li><li>그렇지 않다면 새 항목 <code>[Si, 1]</code>을 만든다.</li></ul><p><img src=/post/system-design-interview/6/img_6.png width=717 height=798 srcset="/post/system-design-interview/6/img_6_hu4d508b5e0485ac8ed5a6f6afc4aa05b9_112910_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_6_hu4d508b5e0485ac8ed5a6f6afc4aa05b9_112910_1024x0_resize_box_3.png 1024w" loading=lazy alt="백터 시계" class=gallery-image data-flex-grow=89 data-flex-basis=215px></p><ol><li>클라이언트가 <code>D1</code>을 시스템에 기록한다.<ul><li>처리한 서버는 <code>Sx</code>이므로 백터 시계는 <code>D1[Sx, 1]</code>으로 변한다.</li></ul></li><li>다른 클라이언트가 <code>D1</code>을 읽고 <code>D2</code>로 업데이트한 다음 기록한다.<ul><li><code>D2</code>는 <code>D1</code>의 변경이므로 덮어쓴다.</li><li><code>Sx</code>가 처리했으므로 벡터 시계를 <code>D2[Sx, 2]</code>로 변경한다.</li></ul></li><li>다른 클라이언트가 <code>D2</code>를 읽어 <code>D3</code>로 갱신한 다음 기록한다.<ul><li><code>Sy</code>가 처리했으므로 백터 시계 상태는 <code>D3([Sx, 2], [Sy, 1])</code></li></ul></li><li>또 다른 클라이언트가 <code>D2</code>를 읽고 <code>D4</code>로 갱신한 후 기록한다.<ul><li><code>Sz</code>가 처리했으므로 백터 시계 상태는 <code>D4([Sx, 2], [Sz, 1])</code></li></ul></li><li>어떤 클라이언트가 D3과 D4를 읽으면 데이터 간 충돌이 있다는 것을 알게 되므로, 클라이언트가 해소한 후 서버에 기록한다.<ul><li><code>Sx</code>가 처리했으므로 백터 시계는 <code>D5([Sx, 3], [Sy, 1], [Sz, 1])</code>로 바뀐다.</li></ul></li></ol><p>벡터 시계를 이용하면 버전 Y에 포함된 모든 구성 요소의 값이 X에 포함된 모든 구성요소 값보다 같거나 큰지만 확인하면 어떤 버전 X가 버전 Y의 이전 버전인지 쉽게 판단할 수 있다.</p><ul><li><code>D([s0, 1], [s1, 1])</code>은 <code>D([s0, 1], [s1, 2])</code>보다 이전 버전이다.(충돌 X)</li></ul><p>어떤 버전 X와 Y 사이에 충돌이 있는지 보려면 <strong>Y의 벡터 시계 구성 요소 가운데 X의 벡터 시계 동일 서버 구성요소보다 작은 값을 갖는 것이 있는지 확인</strong>한다.</p><ul><li><code>D([s0, 1], [s1, 2])</code>, <code>D([s0, 2], [s1, 1])</code>는 서로 충돌한다.</li></ul><hr><p>벡터 시계를 통해 충돌 감지하고 해소하는 방법에는 두 가지 단점이 있다.</p><ul><li>충돌 감지 및 해소 로직이 클라이언트에 들어가야 하므로, 클라이언트 구현이 복잡해진다.</li><li><code>[서버: 버전]</code>의 순서쌍 개수가 굉장히 빨리 늘어난다.<ul><li>순서쌍 개수에 임계치를 설정하고, 임계치 이상으로 길이가 길어지면 오래된 순서쌍을 백터 시계에서 제거한다.</li><li>버전 간 선후 관계가 정확하게 결정될 수 없으므로 충돌 해소 과정의 효율성이 낮아질 수 있다.</li><li>실제 서비스에서 그런 문제는 거의 발생하지 않으므로, 대부분 기업에서 괜찮다.</li></ul></li></ul><h4 id=장애-처리>장애 처리</h4><p>대규모 시스템에서 장애는 아주 흔하게 벌어지므로 장애를 어떻게 처리할 것이냐 하는 것은 굉장히 중요한 문제이다.</p><h4 id=장애-감지>장애 감지</h4><p>분산 시스템에서는 서버 A에 문제가 생겼을 때 바로 장애를 처리하지 않고, 보통 두 대 이상의 서버가 똑같이 서버 A에 대해 장애를 보고해야 해당 서버에 실제로 장애가 발생했다고 간주한다.</p><p><img src=/post/system-design-interview/6/img_7.png width=838 height=636 srcset="/post/system-design-interview/6/img_7_hu135f183e800718526af99039ce9e186b_156879_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_7_hu135f183e800718526af99039ce9e186b_156879_1024x0_resize_box_3.png 1024w" loading=lazy alt="멀티캐스팅 채널 구축" class=gallery-image data-flex-grow=131 data-flex-basis=316px></p><p>모든 노드 사이에 멀티캐스팅 채널을 구축하는 것이 서버 장애를 감지하는 손쉬운 방법이나, 이 방법은 서버가 많을 때 비효율적이다.</p><p>따라서 <strong>가십 프로토콜</strong>(gossip protocol) 같은 분산형 장애 감지 솔루션을 채택하는 편이 보다 효율적이다.</p><ul><li>각 노드는 맴버십 목록을 유지한다.<ul><li>맴버십 목록: 각 맴버 ID와 그 박동 카운터(heartbeat counter) 쌍의 목록</li></ul></li><li>각 노드는 주기적으로 자신의 박동 카운터를 증가시킨다.</li><li>각 노드는 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터 목록을 보낸다.</li><li>박동 카운터 목록을 받은 노드는 맴버십 목록을 최신 값으로 갱신한다.</li><li>어떤 맴버의 박동 카운터 값이 지정된 시간 동안 갱신되지 않으면 해당 멤버는 장애 상태인 것으로 간주한다.</li></ul><p><img src=/post/system-design-interview/6/img_8.png width=839 height=382 srcset="/post/system-design-interview/6/img_8_hu90da88e3e0d0b1a6937865c76380943d_88593_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_8_hu90da88e3e0d0b1a6937865c76380943d_88593_1024x0_resize_box_3.png 1024w" loading=lazy alt="가십 프로토콜" class=gallery-image data-flex-grow=219 data-flex-basis=527px></p><h4 id=일시적-장애-처리>일시적 장애 처리</h4><p>장애를 감지한 시스템은 가용성을 보장하기 위해 필요한 조치를 해야한다.</p><ul><li>엄격한 정족수 접근법은 읽기와 쓰기 연산을 금지한다.</li><li>느슨한 정족수 접근법은 쓰기 연산을 수행할 W개의 건강한 서버와 읽기 연산을 수행할 R개의 건강한 서버를 해시 링에서 고른다.(장애 서버는 무시)</li><li>장애 상태인 서버로 가는 요청은 다른 서버가 잠시 맡아 처리한다.</li><li>그동안 발생한 변경 사항은 장애 서버가 복구 되었을 때 일괄 반영하여 데이터 일관성을 보존한다.<ul><li>임시로 쓰기 연산을 처리한 서버에는 그에 관한 단서를 남겨둔다.</li><li>단서 후 임시 위탁(hinted handoff)</li></ul></li></ul><p><img src=/post/system-design-interview/6/img_9.png width=834 height=718 srcset="/post/system-design-interview/6/img_9_hu115bfa1d5fe40c44de379ba88e53d6c2_127770_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_9_hu115bfa1d5fe40c44de379ba88e53d6c2_127770_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=116 data-flex-basis=278px></p><p>장애 상태인 s2에 대한 읽기 및 쓰기 연산은 일시적으로 s3가 처리하며, s2가 복구되면 s3는 갱신된 데이터를 s2로 인계한다.</p><h4 id=영구-장애-처리>영구 장애 처리</h4><p>영구적인 노드의 장애 상태는 반-엔트로피(anti-entropy) 프로토콜을 구현하여 사본들을 동기화한다.</p><p>반-엔트로피 프로토콜은 <strong>사본들을 비교하여 최신 버전으로 갱신하는 과정을 포함</strong>한다.</p><p>사본 간의 일관성이 망가진 상태를 탐지하고 전송 데이터의 양을 줄이기 위해서 머클(Merkle) 트리를 사용한다.</p><blockquote><p>머클 트리?<br>해시 트리라고 불리는 머클 트리는 각 노드에 그 자식 노드들의 보관된 값의 해시(자식 노드가 leaf인 경우) 또는 자식 노드들의 레이블로부터 계산된 해시 값을 레이블로 붙여두는 트리</p></blockquote><p>해시 트리를 사용하면 <strong>대규모 자료 구조의 내용을 효과적이면서도 보안상 안전한 방법으로 검증</strong>할 수 있다.</p><p><strong>1 단계</strong></p><p><img src=/post/system-design-interview/6/img_10.png width=844 height=330 srcset="/post/system-design-interview/6/img_10_hu458e95c99f7dfcfac03b6157ee8c6e5b_44753_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_10_hu458e95c99f7dfcfac03b6157ee8c6e5b_44753_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=255 data-flex-basis=613px></p><p>키 공간을 버킷으로 나눈다.</p><p><strong>2 단계</strong></p><p><img src=/post/system-design-interview/6/img_11.png width=842 height=182 srcset="/post/system-design-interview/6/img_11_hu5646976f70d14d2033d017e53694f064_41493_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_11_hu5646976f70d14d2033d017e53694f064_41493_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=462 data-flex-basis=1110px></p><p>버킷에 포함된 각각의 키에 균등 분포 해시 함수를 적용하여 해시 값을 계산한다.</p><p><strong>3 단계</strong></p><p><img src=/post/system-design-interview/6/img_12.png width=839 height=260 srcset="/post/system-design-interview/6/img_12_hu38a58b95ad281add1c37ca9db00d3b58_73545_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_12_hu38a58b95ad281add1c37ca9db00d3b58_73545_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=322 data-flex-basis=774px></p><p>버킷 별로 해시값을 계산한 후, 해당 해시 값을 레이블로 갖는 노드를 만든다.</p><p><strong>4 단계</strong></p><p><img src=/post/system-design-interview/6/img_13.png width=840 height=445 srcset="/post/system-design-interview/6/img_13_hu8894cdbe47f2eb2880a4148ac1861de4_101648_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_13_hu8894cdbe47f2eb2880a4148ac1861de4_101648_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=188 data-flex-basis=453px></p><p>자식 노드의 레이블로부터 새로운 해시값을 계산하여, 이진 트리를 상향식으로 구성해 나간다.</p><hr><p>두 머클 트리의 비교는 루트 노드의 해시값을 비교하는 것으로 시작하며, 다른 데이터를 갖는 버킷을 찾을 경우 그 버킷들만 동기화한다.</p><p>머클 트리를 사용하면 동기화해야 하는 데이터 양은 실제로 존재하는 차이의 크기에 비례할 뿐, 두 서버에 보관된 데이터의 총량과는 무관해진다.</p><ul><li>실제로 쓰이는 시스템의 경우 버킷 하나의 크기가 꽤 크다.</li><li>10억(1B) 개의 키를 백만(1M) 개의 버킷으로 관리하면, 하나의 버킷은 1,000개 키를 관리한다.</li></ul><h4 id=데이터-센터-장애-처리>데이터 센터 장애 처리</h4><p>데이터 센터 장애는 정전, 네트워크 장애, 자연재해 등 다양한 이유로 발생할 수 있다.</p><p>데이터 센터의 장애에 대응할 수 있는 시스템을 만드려면 데이터를 여러 데이터 센터에 다중화하는 것이 중요하다.</p><h3 id=시스템-아키텍처-다이어그램>시스템 아키텍처 다이어그램</h3><p><img src=/post/system-design-interview/6/img_14.png width=842 height=525 srcset="/post/system-design-interview/6/img_14_hu3a1f1cde060e244af1e3932a5858e642_94830_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_14_hu3a1f1cde060e244af1e3932a5858e642_94830_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=160 data-flex-basis=384px></p><ul><li>클라이언트는 키-값 저장소가 제공하는 두 가지 단순한 API, <code>get(key)</code>, <code>put(key, value)</code>와 통신한다.</li><li>중재자는 클라이언트에게 키-값 저장소에 대한 프락시 역할을 하는 노드다.</li><li>노드는 안정 해시의 해시 링 위에 분포한다.</li><li>노드를 자동으로 추가 또는 삭제할 수 있도록, 시스템은 완전히 분산된다.</li><li>데이터는 여러 노드에 다중화된다.</li><li>모든 노드가 같은 책임을 지므로, SPOF(Single Point of Failure)는 존재하지 않는다.</li></ul><p><img src=/post/system-design-interview/6/img_15.png width=830 height=656 srcset="/post/system-design-interview/6/img_15_hud90111428b56169725aae5ee0bdfc804_100802_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_15_hud90111428b56169725aae5ee0bdfc804_100802_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=126 data-flex-basis=303px></p><p>완전히 분산된 설계를 채택하였으므로 모든 노드는 제시된 기능을 전부 지원해야한다.</p><h3 id=쓰기-경로>쓰기 경로</h3><p><img src=/post/system-design-interview/6/img_16.png width=845 height=458 srcset="/post/system-design-interview/6/img_16_hu216694585a97b0bfbb508eaee3fd8e8a_77802_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_16_hu216694585a97b0bfbb508eaee3fd8e8a_77802_1024x0_resize_box_3.png 1024w" loading=lazy alt="카산드라의 사례" class=gallery-image data-flex-grow=184 data-flex-basis=442px></p><ol><li>쓰기 요청이 커밋 로그 파일에 기록된다.</li><li>데이터가 메모리 캐시에 기록된다.</li><li>메모리 캐시가 가득 차거나 사전에 정의된 임계치에 도달하면 데이터는 디스크에 있는 SSTable에 기록된다.<ul><li>SSTable: Sorted-String Table의 약어로 &lt;키, 값> 의 순서쌍을 정렬된 리스트로 관리하는 테이블이다.</li></ul></li></ol><h3 id=읽기-경로>읽기 경로</h3><p><img src=/post/system-design-interview/6/img_17.png width=845 height=446 srcset="/post/system-design-interview/6/img_17_huaac619f90ef719991892748c739fd616_71124_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_17_huaac619f90ef719991892748c739fd616_71124_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=189 data-flex-basis=454px></p><p>읽기 요청을 받은 노드는 데이터가 메모리 캐시에 있는지부터 살핀 후 데이터를 클라이언트에게 반환한다.</p><p><img src=/post/system-design-interview/6/img_18.png width=843 height=425 srcset="/post/system-design-interview/6/img_18_hub84a0c909dfc6b10b41bdf7efd5bb775_89775_480x0_resize_box_3.png 480w, /post/system-design-interview/6/img_18_hub84a0c909dfc6b10b41bdf7efd5bb775_89775_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=198 data-flex-basis=476px></p><p>데이터가 메모리에 없는 경우 디스크에서 가져온다.</p><p>어느 SSTable에 찾는 키가 있는지 효율적으로 찾기 위해 블룸 필터(Bloom filter)가 흔히 사용된다.</p><ol><li>데이터가 메모리에 있는지 검사하고 있다면 반환한다.</li><li>데이터가 메모리에 없으므로 블룸 필터를 검사한다.</li><li>블룸 필터를 통해 어떤 SSTable에 키가 보관되어 있는지 알아낸다.</li><li>SSTable에서 데이터를 가져온다.</li><li>해당 데이터를 클라이언트에게 반환한다.</li></ol><h2 id=요약>요약</h2><div class=table-wrapper><table><thead><tr><th>목표/문제</th><th>기술</th></tr></thead><tbody><tr><td>대규모 데이터 저장</td><td>안정 해시를 사용해 서버들에 부하 분산</td></tr><tr><td>읽기 연산에 대한 높은 가용성 보장</td><td>데이터를 여러 데이터센터에 다중화</td></tr><tr><td>쓰기 연산에 대한 높은 가용성 보장</td><td>버저닝 및 백터 시계를 사용한 충돌 해소</td></tr><tr><td>데이터 파티션</td><td>안정 해시</td></tr><tr><td>점진적 규모 확장성</td><td>안정 해시</td></tr><tr><td>다양성(heterogeneity)</td><td>안정 해시</td></tr><tr><td>조절 가능한 데이터 일관성</td><td>정족수 합의(quorum consensus)</td></tr><tr><td>일시적 장애 처리</td><td>느슨한 정족수 프로토콜(sloppy quorum)과 단서 후 임시 위탁(hinted handoff)</td></tr><tr><td>영구적 장애 처리</td><td>머클 트리(Merkle tree)</td></tr><tr><td>데이터 센터 장애 대응</td><td>여러 데이터 센터에 걸친 데이터 다중화</td></tr></tbody></table></div></section><footer class=article-footer><section class=article-tags><a href=/tags/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/>가상 면접 사례로 배우는 대규모 시스템 설계 기초</a>
<a href=/tags/system-design-interview/>System Design Interview</a>
<a href=/tags/%ED%82%A4-%EA%B0%92-%EC%A0%80%EC%9E%A5%EC%86%8C/>키-값 저장소</a>
<a href=/tags/key-value-store/>Key-value Store</a>
<a href=/tags/%EB%B9%84-%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/>비 관계형 데이터베이스</a>
<a href=/tags/non-relational-db/>Non-relational DB</a>
<a href=/tags/%EB%B6%84%EC%82%B0-%ED%82%A4-%EA%B0%92-%EC%A0%80%EC%9E%A5%EC%86%8C/>분산 키-값 저장소</a>
<a href=/tags/distribute-key-value-store/>Distribute Key-Value Store</a>
<a href=/tags/%EB%A0%88%EB%94%94%EC%8A%A4/>레디스</a>
<a href=/tags/redis/>Redis</a>
<a href=/tags/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AA%A8-db/>다이나모 DB</a>
<a href=/tags/dynamodb/>DynamoDB</a>
<a href=/tags/memcached/>memcached</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><div class="article-list--compact links"><article><a href=https://product.kyobobook.co.kr/detail/S000001033116 target=_blank rel=noopener><div class=article-details><h2 class=article-title>가상 면접 사례로 배우는 대규모 시스템 설계 기초</h2><footer class=article-time>교보문고</footer></div></a></article></div><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/post/system-design-interview-2/10/><div class=article-image><img src=/post/system-design-interview-2/10/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 10. 실시간 게임 순위표" data-key=system-design-interview-2/10 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>10. 실시간 게임 순위표</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/12/><div class=article-image><img src=/post/system-design-interview-2/12/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 12. 전자 지갑" data-key=system-design-interview-2/12 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>12. 전자 지갑</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/7/><div class=article-image><img src=/post/system-design-interview-2/7/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 7. 호텔 예약 시스템" data-key=system-design-interview-2/7 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>7. 호텔 예약 시스템</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/3/><div class=article-image><img src=/post/system-design-interview-2/3/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 3. 구글 맵" data-key=system-design-interview-2/3 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>3. 구글 맵</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/2/><div class=article-image><img src=/post/system-design-interview-2/2/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 2. 주변 친구" data-key=system-design-interview-2/2 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>2. 주변 친구</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=codemario318/codemario318.github.io issue-term=pathname label=Comment crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2023 -
2025 Mario Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>