<!doctype html><html lang=ko dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="가상 면접 사례로 배우는 대규모 시스템 설계 기초 2"><title>6. 광고 클릭 이벤트 집계</title><link rel=canonical href=https://codemario318.github.io/post/system-design-interview-2/6/><link rel=stylesheet href=/scss/style.min.cbce94e2760d14d60414e59d5a36ab2819232375817e010dbe7be2234b67da1b.css><meta property="og:title" content="6. 광고 클릭 이벤트 집계"><meta property="og:description" content="가상 면접 사례로 배우는 대규모 시스템 설계 기초 2"><meta property="og:url" content="https://codemario318.github.io/post/system-design-interview-2/6/"><meta property="og:site_name" content="Mario Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="가상 면접 사례로 배우는 대규모 시스템 설계 기초"><meta property="article:tag" content="System Design Interview"><meta property="article:tag" content="광고 클릭 이벤트 집계 시스템"><meta property="article:tag" content="Ad Click Event Aggregation System"><meta property="article:tag" content="RTB"><meta property="article:tag" content="Real-Time Bidding"><meta property="article:tag" content="카산드라"><meta property="article:tag" content="Cassandra"><meta property="article:published_time" content="2024-10-06T17:20:50+09:00"><meta property="article:modified_time" content="2024-10-06T17:20:50+09:00"><meta property="og:image" content="https://codemario318.github.io/post/system-design-interview-2/6/cover.png"><meta name=twitter:title content="6. 광고 클릭 이벤트 집계"><meta name=twitter:description content="가상 면접 사례로 배우는 대규모 시스템 설계 기초 2"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://codemario318.github.io/post/system-design-interview-2/6/cover.png"><script async src="https://www.googletagmanager.com/gtag/js?id=G-K99591YLGK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K99591YLGK",{anonymize_ip:!1})}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3183752545292673" crossorigin=anonymous></script><meta name=naver-site-verification content="2315bde85c86f66092140cc465c340a2170f3187"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu760fd15c5fbb2f30cf0868dc4a5dc41a_14271_300x0_resize_q75_box.jpeg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Mario Blog</a></h1><h2 class=site-description></h2></div></header><ol class=social-menu><li><a href=https://github.com/codemario318 target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><ul class="menu sub-menu"><li><a href=/categories/backend/><span>Backend</span>
<span class=content-count>3</span></a></li><li><a href=/categories/boostcamp/><span>부스트캠프</span>
<span class=content-count>10</span></a></li><li><a href=/categories/cleancode/><span>Clean Code</span>
<span class=content-count>10</span></a></li><li><a href=/categories/common/><span>Common</span>
<span class=content-count>68</span></a></li><li><a href=/categories/data/><span>Data</span>
<span class=content-count>3</span></a></li><li><a href=/categories/db/><span>DB</span>
<span class=content-count>1</span></a></li><li><a href=/categories/frontend/><span>Frontend</span>
<span class=content-count>10</span></a></li><li><a href=/categories/golang/><span>GoLang</span>
<span class=content-count>13</span></a></li><li><a href=/categories/headfirstdesignpatterns/><span>헤드 퍼스트 디자인 패턴</span>
<span class=content-count>22</span></a></li><li><a href=/categories/infra/><span>Infra</span>
<span class=content-count>14</span></a></li><li><a href=/categories/nest/><span>Nest</span>
<span class=content-count>1</span></a></li><li><a href=/categories/network/><span>네트워크</span>
<span class=content-count>1</span></a></li><li><a href=/categories/node/><span>Node</span>
<span class=content-count>1</span></a></li><li><a href=/categories/problemsolving/><span>Problem Solving</span>
<span class=content-count>1</span></a></li><li><a href=/categories/project/><span>Project</span>
<span class=content-count>5</span></a></li><li><a href=/categories/realmysql/><span>Real MySQL</span>
<span class=content-count>53</span></a></li></ul><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#1단계-문제-이해-및-설계-범위-확정>1단계: 문제 이해 및 설계 범위 확정</a><ol><li><a href=#기능-요구사항>기능 요구사항</a></li><li><a href=#비기능-요구사항>비기능 요구사항</a></li><li><a href=#개력적-추정>개력적 추정</a></li></ol></li><li><a href=#2단계-개략적-설계안-제시-및-동의-구하기>2단계: 개략적 설계안 제시 및 동의 구하기</a><ol><li><a href=#질의-api-설계>질의 API 설계</a></li><li><a href=#데이터-모델>데이터 모델</a></li><li><a href=#올바른-데이터베이스-선택>올바른 데이터베이스 선택</a></li><li><a href=#개략적-설계안>개략적 설계안</a></li><li><a href=#집계-서비스>집계 서비스</a></li></ol></li><li><a href=#3단계-상세-설계>3단계: 상세 설계</a><ol><li><a href=#스트리밍-vs-일괄-처리>스트리밍 vs 일괄 처리</a></li><li><a href=#데이터-재계산>데이터 재계산</a></li><li><a href=#시간>시간</a></li><li><a href=#집계-윈도>집계 윈도</a></li><li><a href=#전달-보장>전달 보장</a></li><li><a href=#시스템-규모-확장>시스템 규모 확장</a></li><li><a href=#핫스팟-문제>핫스팟 문제</a></li><li><a href=#결함-내성>결함 내성</a></li><li><a href=#데이터-모니터링-및-정확성>데이터 모니터링 및 정확성</a></li><li><a href=#대안적-설계안>대안적 설계안</a></li></ol></li><li><a href=#4단계-마무리>4단계: 마무리</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/post/system-design-interview-2/6/><img src=/post/system-design-interview-2/6/cover_huf565d8fe7a4f9f5a961306624616abfc_449360_800x0_resize_box_3.png srcset="/post/system-design-interview-2/6/cover_huf565d8fe7a4f9f5a961306624616abfc_449360_800x0_resize_box_3.png 800w, /post/system-design-interview-2/6/cover_huf565d8fe7a4f9f5a961306624616abfc_449360_1600x0_resize_box_3.png 1600w" width=800 height=1143 loading=lazy alt="Featured image of post 6. 광고 클릭 이벤트 집계"></a></div><div class=article-details><header class=article-category><a href=/categories/common/ style=background-color:#2a9d8f;color:#fff>Common</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/system-design-interview-2/6/>6. 광고 클릭 이벤트 집계</a></h2><h3 class=article-subtitle>가상 면접 사례로 배우는 대규모 시스템 설계 기초 2</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2024/10/06</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>19 minute read</time></div></footer></div></header><section class=article-content><p>이번 장은 페이스북이나 구글 규모에 걸맞는 <strong>광고 클릭 이벤트 집계 시스템</strong>(ad click event aggregation system)을 설계해본다.</p><p>기술적인 세부사항을 깊이 살펴보기 전 온라인 광고의 핵심 개념부터 살펴본다.</p><p>온라인 광고의 핵심적 혜택은 <strong>실시간 데이터를 통해 광고 효과를 정량적으로 측정할 수 있다</strong>는 점이다.</p><p>핵심 프로세스는 <strong>RTB</strong>(Real-Time Bidding)으로, 이 <strong>경매 절차를 통해 광고가 나갈 지면(inventory)을 거래</strong>한다.</p><pre class=mermaid style=text-align:center>flowchart LR
    subgraph 지면수요자 
        direction LR
        광고주 --> DSP[DSP: 수요자 플랫폼]
    end
    
    DSP --> 광고거래소
    SSP --> 광고거래소
    
    subgraph 지면공급자 
        direction RL
        공급자 --> SSP[SSP: 공급자 플랫폼]
    end
</pre><ul><li>속도<ul><li>보통 1초 내에 모든 프로세스가 마무리되어야 한다.</li></ul></li><li>데이터 정확성<ul><li>광고 클릭 이벤트 집계는 온라인 광고가 얼마나 효율적이었는지 측정하는 데 결정적인 역할을 한다.<ul><li>광고주가 얼마나 많은 돈을 지불할지에 영향을 끼친다.</li><li>클릭 집계 결과에 따라 광고 캠페인 관리자는 예산을 조절할 수 있다.</li><li>타깃이나 키워드를 변경하는 등 공고 전략을 수정할 수 있다.</li></ul></li><li>CTR(Click-Through Rate, 클릭률), CVR(Conversion Rate, 전환률)</li></ul></li></ul><h2 id=1단계-문제-이해-및-설계-범위-확정>1단계: 문제 이해 및 설계 범위 확정</h2><h3 id=기능-요구사항>기능 요구사항</h3><ul><li>지난 M분 동안의 <code>ad_id</code> 클릭 수 집계</li><li>매분 가장 많이 클릭된 상위 100개 광고 아이디를 반환</li><li>다양한 속성에 따른 집계 필터링을 지원</li><li>데이터의 양은 페이스북이나 구글 규모</li></ul><h3 id=비기능-요구사항>비기능 요구사항</h3><ul><li>집계 결과 정확성은 데이터가 RTB 및 광고 과금에 사용되므로 중요</li><li>지연되거나 중복된 이벤트를 적절히 처리할 수 있어야 함</li><li>견고성<ul><li>부분적인 장애는 감내할 수 있어야함</li></ul></li><li>지연 시간 요구사항<ul><li>전체 처리 시간은 최대 수 분을 넘지 않아야함</li></ul></li></ul><h3 id=개력적-추정>개력적 추정</h3><p>시스템 규모 및 풀어야 할 잠재적 문제점을 파악하기 이해 개략적인 규모를 추정해본다.</p><ul><li>DAU 10억</li><li>각 사용자는 하루에 평균 1개 광고를 클릭한다 가정<ul><li>따라서 하루에 10억 건의 광고 클릭 이벤트 발생</li></ul></li><li><code>광고 클릭 QPS = 10^9 / 10^5 = 10,000</code></li><li>최대 광고 클릭 QPS는 평균 QPS의 5배로 가정(50,000)</li><li>광고 클릭 이벤트 하나당 <code>0.1KB</code> 용량이 필요하다고 가정<ul><li><code>일일 저장소 요구량 = 0.1KB * 10억 = 100GB</code></li><li>월간 저장 용량 요구량은 대략 3TB</li></ul></li></ul><h2 id=2단계-개략적-설계안-제시-및-동의-구하기>2단계: 개략적 설계안 제시 및 동의 구하기</h2><h3 id=질의-api-설계>질의 API 설계</h3><p>API를 설계하는 목적은 클라이언트와 서버 간의 통신 규약을 만드는 것 이다.</p><p>본 설계안의 클라이언트는 대시보드를 이용하는 데이터 과학자, 제품 관리자, 광고주 같은 사람으로, 대시보드를 이용하는 순간 집계 서비스에 질의가 발생한다.</p><hr><p><strong>지난 M분간 각 <code>ad_id</code>에 발생한 클릭 수 집계</strong></p><div class=table-wrapper><table><thead><tr><th>API</th><th>용도</th></tr></thead><tbody><tr><td>GET /v1/ads/{:ad_id}/aggregated_count</td><td>주어진 ad_id에 발생한 이벤트 수를 집계하여 반환</td></tr></tbody></table></div><ul><li><p>호출 인자</p><ul><li>from : 집계 시작 시간</li><li>to: 집계 종료 시간</li><li>filter: 필터링 전략 식별자</li></ul></li><li><p>반환 응답</p><ul><li>ad_id: 광고 식별자</li><li>count: 집계된 클릭 횟수</li></ul></li></ul><hr><p><strong>지난 M분간 가장 많은 클릭이 발생한 상위 N개 ad_id 목록</strong></p><div class=table-wrapper><table><thead><tr><th>API</th><th>용도</th></tr></thead><tbody><tr><td>GET /v1/ads/popular_ads</td><td>지난 M분간 가장 많은 클릭이 발생한 상위 N개 광고 목록 반환</td></tr></tbody></table></div><ul><li>호출 인자<ul><li>count: 상위 몇 개의 광고를 반환할 것인가</li><li>window: 분 단위로 표현된 집계 윈도 크기</li><li>filter: 필터링 전략 식별자</li></ul></li><li>응답<ul><li>ad_ids: 공고 식별자 목록</li></ul></li></ul><h3 id=데이터-모델>데이터 모델</h3><p>이 시스템은 <strong>원시 데이터</strong>와 <strong>집계 결과 데이터</strong>를 다룬다.</p><hr><p><strong>원시 데이터</strong></p><p>로그 파일 등으로 저장된 가공되지 않은 데이터를 의미한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[AdClickEvent] ad001, 2021-01-01 00:00:01, user 1, 270.148.22.22, USA
</span></span></code></pre></td></tr></table></div></div><p>위와 같은 데이터가 여러 애플리케이션 서버에 산재해있다.</p><hr><p><strong>집계 결과 데이터</strong></p><p>공고 클릭 이벤트가 매분 집계된다고 가정한다면 아래처럼 표현될 수 있다.</p><div class=table-wrapper><table><thead><tr><th>ad_id</th><th>click_minute</th><th>count</th></tr></thead><tbody><tr><td>ad001</td><td>202101010000</td><td>5</td></tr><tr><td>ad001</td><td>202101010001</td><td>7</td></tr></tbody></table></div><p>광고 필터링을 지원하기 위해 <code>filter_id</code>를 추가하고 같은 <code>ad_id</code>와 <code>click_minute</code> 값을 갖는 레코드를 <code>filter_id</code>가 가리키는 필터 적용 결과에 따라 집계하면 아래와 같은 결과가 만들어진다.</p><div class=table-wrapper><table><thead><tr><th>ad_id</th><th>click_minute</th><th>filter_id</th><th>count</th></tr></thead><tbody><tr><td>ad001</td><td>2021010000</td><td>0012</td><td>2</td></tr><tr><td>ad001</td><td>2021010000</td><td>0023</td><td>3</td></tr><tr><td>ad001</td><td>2021010001</td><td>0012</td><td>1</td></tr><tr><td>ad001</td><td>2021010001</td><td>0023</td><td>6</td></tr></tbody></table></div><div class=table-wrapper><table><thead><tr><th>filter_id</th><th>region</th><th>ip</th><th>user_id</th></tr></thead><tbody><tr><td>0012</td><td>US</td><td>0012</td><td>*</td></tr><tr><td>0013</td><td>*</td><td>0023</td><td>123.1.2.3</td></tr></tbody></table></div><p>지난 M분 동안 가장 많이 클릭된 상위 N개의 광고를 반환하는 질의를 지원하기 위해서는 다음 구조를 사용한다.</p><pre class=mermaid style=text-align:center>erDiagram
    most_clicked_ads {
        window_size integer
        update_time_minute timestamp
        most_clicked_ads array
    }
</pre><hr><p><strong>비교</strong></p><p>원시 데이터를 저장하는 방안과 집계 결과 데이터만 보관하는 방안의 장점을 비교해보면 아래와 같다.</p><ul><li>원시 데이터만 보관하는 방안<ul><li>장점<ul><li>원본 데이터를 손실 없이 보관</li><li>데이터 필터링 및 재계산 지원</li></ul></li><li>단점<ul><li>막대한 데이터 용량</li><li>낮은 질의 성능</li></ul></li></ul></li><li>집계 결과 데이터만 보관하는 방안<ul><li>장점<ul><li>데이터 용량 절감</li><li>빠른 질의 기능</li></ul></li><li>단점<ul><li>데이터 손실<ul><li>원본 데이터가 아닌 계산/유도된 데이터를 저정하는 데서 오는 결과임</li><li>예시 > 10개의 원본 데이터는 1개의 집계 결과로 축약된다</li></ul></li></ul></li></ul></li></ul><p>원시 데이터와 집계 결과 데이터의 특성으로 인해 모두 저장하는 것이 바람직하다.</p><ul><li>문제가 발생하면 디버깅에 활용할 수 있도록 원시 데이터도 보관하는 것이 좋다.<ul><li>데이터가 손상되면 버그 수정 후에 원시 데이터에서 집계 결과를 다시 만들 수 있다.</li></ul></li><li>원시 데이터는 양이 엄청나므로 직접 질의하는 것은 비효율적이다.<ul><li>집계 결과 데이터를 질의한다.</li></ul></li><li>원시 데이터는 백업 데이터로 활용할 수 있다.<ul><li>재계산을 하는 경우가 아니라면 굳이 원시 데이터를 질의할 필요는 없다.</li><li>오래된 원시 데이터는 cold storage로 옮기면 비용을 절감할 수 있다.</li></ul></li><li>집계 결과 데이터는 활성 데이터 구실을 한다.<ul><li>질의 성능을 높이기 위해 튜닝하는 것이 일반적이다.</li></ul></li></ul><h3 id=올바른-데이터베이스-선택>올바른 데이터베이스 선택</h3><p>올바른 데이터베이스를 선택하기 위해 여러 사항을 고려해야한다.</p><ul><li>데이터는 어떤 모습인가?<ul><li>관계형 데이터?, 문서 데이터?, 이진 대형 객체(BLOB)?</li></ul></li><li>작업 흐름이 읽기 중심인가 쓰기 중심인가?(아님 둘다?)</li><li>트랜잭션을 지원해야 하는가?</li><li>질의 과정에서 SUM, COUNT 같은 온라인 분석 처리 함수를 많이 활용해야 하는가?</li></ul><hr><p><strong>원시 데이터</strong></p><p>일상적인 작업을 위해서라면 질의할 필요가 없지만, 데이터 과학자나 기계 학습 엔지니어가 연구등으로 활용될 수 있다.</p><ul><li>이 설계안이 다루는 시스템에서 발생하는 평균 쓰기 QPS는 10,000, 최대 50,000 이므로 <strong>쓰기 중심 시스템</strong>이라고 볼 수 있다.</li><li>원시 데이터는 백업과 재계산 용도로 활용하므로 읽기 연산 빈도는 낮다.</li></ul><p>관계형 데이터베이스도 활용 가능하지만 큰 규모의 쓰기 연산이 가능하도록 구성하기 매우 어려우므로, 쓰기 및 시간 범위 질의에 최적화된 카산드라나 InfluxDB를 사용하는 것이 좀 더 바람직하다.</p><ul><li>칼럼형(columnar) 데이터 형식 가운데 하나를 사용하여 아마존 S3에 데이터를 저장하는 방법도 고려할 수 있다.<ul><li>ORC, 파케이(Parquet), AVRO</li><li>각 파일의 최대 크기를 제한하면 원시 데이터 기록 담당 스트림 프로세서가 새 파일을 만든다</li></ul></li></ul><hr><p><strong>집계 데이터</strong></p><p>집계 데이터는 본질적으로 시계열 데이터이며, 이 데이터를 처리하는 워크 플로는 읽기 연산과 쓰기 연산 둘 다 많이 사용한다.</p><p>집계 서비스가 데이터를 매 분 집계하고 그 결과 데이터를 저장하는 데는 같은 유형의 데이터베이스를 활용하는 것이 가능하다(카산드라).</p><h3 id=개략적-설계안>개략적 설계안</h3><p>실시간으로 빅데이터를 처리할 때 데이터는 보통 무제한으로 시스템에 흘러들어왔다가 나간다.</p><pre class=mermaid style=text-align:center>flowchart
    subgraph 입력 
        logMonitor[로그모니터]
    end
    
    subgraph 프로세스 
        dataAgg[데이터 집계 서비스]
    end
    
    subgraph 출력 
        db[(데이터베이스)]
    end
    
    subgraph 표시 
        query[질의 서비스]
    end
    
    logMonitor --데이터 푸시--> dataAgg
    dataAgg --광고 수--> db
    dataAgg --가장 많이 클릭된 상위 100개 광고--> db
    query --질의--> db
</pre><hr><p><strong>비동기 처리</strong></p><p>제시한 설계안은 동기식 처리를 기반으로 하지만, 생산자와 소비자의 용량이 항상 같을 수는 없기 때문에 좋지 않을 수 있다.</p><ul><li>트래픽이 갑자기 증가하여 발생하는 이벤트 수가 소비자의 처리 용량을 훨씬 넘어서는 경우 소비자는 메모리 부족 오류 등의 예기치 않은 문제를 겪게 될 수 있다.</li><li>동기식 시스템의 경우 특정 컴포넌트의 장애는 전체 시스템의 장애로 이어진다.</li></ul><p>이 문제를 해결하는 일반적인 방안은 카프카 같은 <strong>메시지 큐를 도입하여 생산자와 소비자의 결함을 끊는 것</strong>이다.</p><ul><li>전체 프로세스가 비동기로 동작하게된다.</li><li>비동기로 동작하므로 생산자와 소비자의 규모를 독립적으로 확장해 나갈 수 있게된다.</li></ul><p><img src=/post/system-design-interview-2/6/img.png width=826 height=468 srcset="/post/system-design-interview-2/6/img_hu308e0d8138a48f72649f62b8270e02b9_127555_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_hu308e0d8138a48f72649f62b8270e02b9_127555_1024x0_resize_box_3.png 1024w" loading=lazy alt="개략적 설계안" class=gallery-image data-flex-grow=176 data-flex-basis=423px></p><p>로그 감시자, 집계 서비스, 데이터베이스는 두 개의 메시지 큐로 분리되어있다.</p><p>데이터베이스 기록 프로세스는 메시지는 메시지 큐에서 데이터를 꺼내 데이터베이스가 지원하는 형식으로 변환 후 기록하는 역할을 수행한다.</p><ul><li>첫 번째 메시지 큐<ul><li>광고 클릭 이벤트가 기록된다.</li><li>ad_id, click_timestamp, user_id, ip, country</li></ul></li><li>두 번째 메시지 큐<ul><li>분 단위로 집게된 광고 클릭 수</li><li>분 단위로 집계한, 가장 많이 클릭한 상위 N개 광고</li></ul></li></ul><p>집계 결과를 데이터베이스에 바로 기록하지 않는 이유는 정확하게 한 번(exactly once) 데이터를 처리하기 위해(atomic commit, 원자적 커밋) 카프카 같은 시스템을 두 번 째 메시지 큐로 도입해야 하기 때문이다.</p><p><img src=/post/system-design-interview-2/6/img_1.png width=805 height=479 srcset="/post/system-design-interview-2/6/img_1_hu1c9282359cbbacf359a25482b125e71b_138566_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_1_hu1c9282359cbbacf359a25482b125e71b_138566_1024x0_resize_box_3.png 1024w" loading=lazy alt="정확하게 한 번 처리하기 위한 메커니즘" class=gallery-image data-flex-grow=168 data-flex-basis=403px></p><h3 id=집계-서비스>집계 서비스</h3><p>광고 클릭 이벤트를 집계하는 좋은 방안 하나는 <strong>맵리듀스</strong>(MapReduce) 프레임워크를 사용하는 것 이다.</p><p>맵리듀스 프레임워크에 좋은 모델은 유향 비순환 그래프(DAG) 모델이며, 시스템을 맵/집계/리듀스 노드 드으이 작은 컴퓨팅 단위로 세분화 할 수 있다.</p><ul><li>각 노드는 한 가지 작업만 처리하며, 처리 결과를 다음 노드에 인계한다.</li></ul><pre class=mermaid style=text-align:center>flowchart LR
    data --데이터 입력-->
    Map((Map)) --ad_id % 2 = 0--> node1((집계 노드 1))
    Map --ad_id % 2 = 1--> node2((집계 노드 2))
</pre><hr><p><strong>맵 노드</strong></p><p>맵 노드는 데이터 출처에서 읽은 데이터를 필터링하고 변환하는 역할을 담당한다.</p><ul><li>카프카 파티션이나 태그를 구성한 후 집계 노드가 카프카를 직접 구독하도록 할 경우 맵 노드를 활용하지 않을 수 있지만, 입력 데이터를 정리하거나 정규화해야 하는 경우에는 맵 노드가 필요하다.</li><li>데이터가 생성되는 방식에 대한 제어권이 없는 경우 동일한 ad_id를 갖는 이벤트가 서로 다른 카프카 파티션에 입력될 수 있다.</li></ul><hr><p><strong>집계 노드</strong></p><p>집계 노드는 ad_id 별 광고 클릭 이벤트 수를 매 분 메모리에서 집계한다.</p><p>맵리듀스 패러다임에서 사실 집계 노드는 리듀스 프로세스의 일부여서, <strong>맵-집계-리듀스</strong> 프로세스는 <strong>맵-리듀스-리듀스</strong> 프로세스라고도 할 수 있다.</p><hr><p><strong>리듀스 노드</strong></p><p>리듀스 노드는 모든 집계 노드가 산출한 결과를 최종 결과로 축약한다.</p><p><img src=/post/system-design-interview-2/6/img_2.png width=664 height=314 srcset="/post/system-design-interview-2/6/img_2_hu4f114adc039c7d0d8d1bf45626dddb0d_89514_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_2_hu4f114adc039c7d0d8d1bf45626dddb0d_89514_1024x0_resize_box_3.png 1024w" loading=lazy alt="리듀스 노드" class=gallery-image data-flex-grow=211 data-flex-basis=507px></p><p>DAG는 맵리듀스 패러다임을 표현하기 위한 모델로, 빅데이터를 입력으로 받아 병렬 분산 컴퓨팅 자원을 활용하여 빅데이터를 작은(일반적) 크기 데이터로 변환할 수 있도록 설계된 모델이다.</p><p>중간 데이터는 메모리에 저장될 수 있으며, 노드 간 통신은 서로 다른 프로세스에서 실행되는 경우 TCP, 서로 다른 스레드에서 실해오디는 경우 공유 메모리로 처리할 수도 있다.</p><hr><p><strong>주요 사용 사례</strong></p><ul><li>클릭 이벤트 수 집계<ul><li><img src=/post/system-design-interview-2/6/img_3.png width=834 height=332 srcset="/post/system-design-interview-2/6/img_3_hu15a9c90a865279d5a482021e1c73ca05_120267_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_3_hu15a9c90a865279d5a482021e1c73ca05_120267_1024x0_resize_box_3.png 1024w" loading=lazy alt="클릭 이벤트 수 집계" class=gallery-image data-flex-grow=251 data-flex-basis=602px></li></ul></li><li>가장 많이 클릭된 상위 N개 광고 반환<ul><li><img src=/post/system-design-interview-2/6/img_4.png width=806 height=453 srcset="/post/system-design-interview-2/6/img_4_hu9e0acdcb57074c8157c74737a33fe94e_193386_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_4_hu9e0acdcb57074c8157c74737a33fe94e_193386_1024x0_resize_box_3.png 1024w" loading=lazy alt="가장 많이 클릭된 상위 N개 광고 반환" class=gallery-image data-flex-grow=177 data-flex-basis=427px></li></ul></li><li>데이터 필터링<ul><li>필터링 기준을 사전에 정의한 후 해당 기준에 따라 집계한다.</li></ul></li></ul><hr><p><strong>스타 스키마</strong></p><p>데이터 웨어하우스에서 널리 쓰이는 기법으로, 필터링에 사용되는 필드는 차원이라 부른다.</p><ul><li>장점<ul><li>이해하기 쉽고 구축하기 간단하다.</li><li>기존 집계 서비스를 재사용하여 스타 스키마에 더 많은 차원을 생성할 수 있다. 다른 추가 컴포넌트는 필요없다.</li><li>결과를 미리 계산해 두는 방식이므로, 필터링 기준에 따라 데이터에 빠르게 접근할 수 있다.</li></ul></li><li>단점<ul><li>많은 버킷과 레코드가 생성된다. (필터링 기준이 많을 경우 더더욱)</li></ul></li></ul><h2 id=3단계-상세-설계>3단계: 상세 설계</h2><h3 id=스트리밍-vs-일괄-처리>스트리밍 vs 일괄 처리</h3><div class=table-wrapper><table><thead><tr><th></th><th>서비스(온라인 시스템)</th><th>일괄 처리 시스템(오프라인 시스템)</th><th>스트리밍 처리 시스템(실시간에 가깝게 처리하는 시스템)</th></tr></thead><tbody><tr><td>응답성</td><td>클라이언트에게 빠르게 응답</td><td>클라이언트에게 응답할 필요가 없음</td><td>클라이언트에게 응답할 필요가 없음</td></tr><tr><td>입력</td><td>사용자의 요청</td><td>유한한 크기를 갖는 입력. 큰 규모의 데이터</td><td>입력에 경계가 없음(무한 스트림)</td></tr><tr><td>출력</td><td>클라이언트에 대한 응답</td><td>구체화 뷰, 집계 결과 지표 등</td><td>구체화 뷰, 집계 결과 지표 등</td></tr><tr><td>성능 측정 기준</td><td>가용성, 지연 시간</td><td>처리량</td><td>처리량, 지연 시간</td></tr><tr><td>사례</td><td>온라인 쇼핑</td><td>맵리듀스</td><td>플링크</td></tr></tbody></table></div><p>본 설계안은 스트림 처리와 일괄 처리 방식을 모두 사용한다.</p><ul><li>스트림 처리는 데이터를 오는 대로 처리하고 거의 실시간으로 집계된 결과를 생성하는 데 사용한다.</li><li>일괄 처리는 이력 데이터를 백업하기 위해 활용한다.</li></ul><p><img src=/post/system-design-interview-2/6/img_5.png width=874 height=648 srcset="/post/system-design-interview-2/6/img_5_huc5dc5bec0ac92440f8db6a7292969bc9_305717_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_5_huc5dc5bec0ac92440f8db6a7292969bc9_305717_1024x0_resize_box_3.png 1024w" loading=lazy alt="람다, 카파 아키첵처" class=gallery-image data-flex-grow=134 data-flex-basis=323px></p><p><strong>람다 아키텍처</strong></p><p>일괄 및 스트리밍 처리 경로를 동시에 지원하는 시스템의 아키텍처를 람다(lambda)라고 부른다.</p><p>람다 아키텍처의 단점은 두 가지 처리 경로를 지원하므로 유지 관리 해야할 코드가 두 벌이라는 점이다.</p><hr><p><strong>카파 아키텍처</strong></p><p>카파 아키텍처(Kappa architecture)는 일괄 처리와 스트리밍 처리 경로를 하나로 결합하여 람다 아키텍처의 단점을 해결한다.</p><p>핵심 아이디어는 단일 스트림 처리 엔진을 사용하여 실시간 데이터 처리 및 끊임없는 데이터 재처리 문제를 모두 해결하는 것이다.</p><hr><p>본 시스템의 개략적 설계안은 카파 아키텍처를 따른다. 따라서 이력 데이터의 재처리도 실시간 집계 서비스를 거치게된다.</p><h3 id=데이터-재계산>데이터 재계산</h3><p>이미 집계한 데이터를 다시 계산해야 하는 경우가 있는데, 이를 <strong>이력 데이터 재처리</strong>(historical data replay)라고도 부른다.</p><p><img src=/post/system-design-interview-2/6/img_6.png width=846 height=274 srcset="/post/system-design-interview-2/6/img_6_hu3a7f884ae78691745bb1093350943e0b_109182_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_6_hu3a7f884ae78691745bb1093350943e0b_109182_1024x0_resize_box_3.png 1024w" loading=lazy alt="재계산 서비스" class=gallery-image data-flex-grow=308 data-flex-basis=741px></p><ol><li>원시 데이터 저장소에서 데이터를 검색한다.</li><li>추출된 데이터를 전용 집계 서비스로 전송한다.<ul><li>전용 집계 서비스는 실시간 데이터 처리 과정이 과거 데이터 재처리 프로세스와 간섭하는 일을 막기 위해 추가한다.</li></ul></li><li>집계 결과는 두 번째 메시지 큐로 전송되어 집계 결과 데이터베이스에 반영된다.</li></ol><p>재계산 프로세스는 데이터 집계 서비스를 재사용하기는 하지만 처리 대상 데이터는 다른 곳에서 읽는다(원시 데이터).</p><h3 id=시간>시간</h3><p>집계를 하려면 타임스탬프가 필요한데, 타임 스탬프는 두 가지 다른 위치에서 만들어질 수 있다.</p><ul><li>이벤트 시각: 광고 클릭이 발생한 시각</li><li>처리 시각: 집계 서버가 이벤트를 처리한 시스템 시각</li></ul><p>네트워크 지연이나 비동기 처리 환경(데이터가 메시지 큐를 거쳐야 하는 환경)때문에 이벤트가 발생한 시각과 처리 시각 사이의 간격이 커질 수 있다.</p><p><img src=/post/system-design-interview-2/6/img_7.png width=669 height=188 srcset="/post/system-design-interview-2/6/img_7_huf8002690287510900e2c2679f234f3b3_47016_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_7_huf8002690287510900e2c2679f234f3b3_47016_1024x0_resize_box_3.png 1024w" loading=lazy alt="늦게 도착한 이벤트" class=gallery-image data-flex-grow=355 data-flex-basis=854px></p><p>이벤트가 발생한 시각을 집계에 사용하는 경우 지연된 이벤트 처리 문제를 잘 해결해야 하며, 처리 시각을 집계에 사용하는 경우 집계 결과가 부정확할 수 있다는 점을 고려해야 한다.</p><p>완벽한 솔루션은 없으므로, 두 방은의 장단점을 고려하여 적절한 결정을 내린다.</p><ul><li>이벤트 발생 시각<ul><li>장점<ul><li>광고 클릭 시점을 정확히 아는 것은 클라이언트이므로 집계 결과가 보다 정확</li></ul></li><li>단점<ul><li>클라이언트가 생성한 타임스탬프에 의존하는 방식이므로 클라이언트에 설정된 시각이 잘못 되었거나 악성 사용자가 타임스탬프를 고의로 조작하는 문제에서 자유로울 수 없음</li></ul></li></ul></li><li>처리 시각<ul><li>장점<ul><li>서버 타임스탬프가 클라이언트 타임스탬프보다 안정적</li></ul></li><li>단점<ul><li>이벤트가 시스템에 도착한 시각이 함참 뒤인 경우에는 집계 결과가 부정확해짐</li></ul></li></ul></li></ul><p>데이터 정확도는 아주 중요하므로, 이벤트 발생 시각을 사용할 것을 추천한다.</p><p>이러한 경우 시스템에 늦게 도착한 이벤트를 올바르게 처리하기 위해 <strong>워터마크</strong>(watermark)라는 기술이 일반적으로 사용된다.</p><p><img src=/post/system-design-interview-2/6/img_8.png width=783 height=245 srcset="/post/system-design-interview-2/6/img_8_huba72022b748b87378d5ddc854e8995cd_104439_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_8_huba72022b748b87378d5ddc854e8995cd_104439_1024x0_resize_box_3.png 1024w" loading=lazy alt="집계 윈도에 누락되는 이벤트" class=gallery-image data-flex-grow=319 data-flex-basis=767px></p><p>이벤트 발생 시각을 기준으로 이벤트가 어떤 윈도에 속하는지 결정하면 이벤트가 집계 윈도가 끝나는 시점보다 살짝 늦게 도착하게되는 경우 집계에 실패하게된다.</p><p>워터마크는 집계 윈도를 확장하여 집계 정확도를 높힐 수 있다.</p><p><img src=/post/system-design-interview-2/6/img_9.png width=782 height=236 srcset="/post/system-design-interview-2/6/img_9_huaa56781eaf1b8e81055800fd2830b619_103298_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_9_huaa56781eaf1b8e81055800fd2830b619_103298_1024x0_resize_box_3.png 1024w" loading=lazy alt=워터마크 class=gallery-image data-flex-grow=331 data-flex-basis=795px></p><p>15초 워터마크를 윈도 마다 붙이면 윈도 1, 3이 누락된 이벤트를 집계할 수 있게 된다.</p><p>워터마크의 크기는 비즈니스 요구사항에 따라 달리 잡는다.</p><ul><li>워터마크 구간이 길면 늦게 도착하는 이벤트도 포착할 수 있지만 시스템의 이벤트 처리 시간은 늘어난다.</li><li>짧으면 데이터 정확도는 떨어지지만 시스템의 응답 지연은 낮아진다.</li></ul><p>워터마크를 사용하더라도 시간이 한참 흐른 후에 시스템에 도달하는 이벤트는 처리할 수 없다.</p><p>발생할 확률이 낮은 이벤트 처리를 위해 시스템을 복잡하게 설계하면 투자 대비 효능(ROI)는 떨어지고, 사소한 데이터 오류는 하루치 데이터 처리를 마감할 때 조정할 수 있으므로 워터마크 구간을 길게 가져갈 이유는 없다.</p><h3 id=집계-윈도>집계 윈도</h3><p>윈도에는 텀블링 윈도(tumbling window, 고정 윈도(fixed window) 라고도 함), 호핑 윈도(hopping window), 슬라이딩 윈도(sliding window), 세션 윈도(session window) 총 네 종류가 있다.</p><p>이 가운데 텀플링 윈도와 슬라이딩 윈도가 설계안과 관련있다.</p><hr><p><strong>텀블링 윈도</strong></p><p><img src=/post/system-design-interview-2/6/img_10.png width=773 height=183 srcset="/post/system-design-interview-2/6/img_10_huceeb3723b2780057ddaa40743569e45d_66924_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_10_huceeb3723b2780057ddaa40743569e45d_66924_1024x0_resize_box_3.png 1024w" loading=lazy alt="텀블링 윈도" class=gallery-image data-flex-grow=422 data-flex-basis=1013px></p><p>시간을 같은 크기의 겹치지 않는 구간으로 분할하므로, 매 분 발생한 클릭 이벤트를 집계하기 적합하다.</p><hr><p><strong>슬라이딩 윈도</strong></p><p><img src=/post/system-design-interview-2/6/img_11.png width=795 height=185 srcset="/post/system-design-interview-2/6/img_11_hu9468ea01e7b032fc68b0427be3506431_67457_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_11_hu9468ea01e7b032fc68b0427be3506431_67457_1024x0_resize_box_3.png 1024w" loading=lazy alt="슬라이딩 윈도" class=gallery-image data-flex-grow=429 data-flex-basis=1031px></p><p>데이터 스트림을 미끄러져 나아가면서 같은 시간 구간 안에 있는 이벤트를 집계한다. 슬라이딩 윈도는 서로 겹칠 수 있어 시스템의 두 번째 요구사항인 지난 M분간 가장 많이 클릭된 상위 N개 광고를 알아내기 적합하다.</p><h3 id=전달-보장>전달 보장</h3><p>집계 결과는 과금 등에 활용될 수 있기 때문에 데이터의 정확성과 무결성이 아주 중요하다.</p><ul><li>이벤트의 중보 처리를 어떻게 피할 수 있는가?</li><li>모든 이벤트의 처리를 어떻게 보장할 수 있는가?</li></ul><p>카프카와 같은 메시지 큐는 보통 최대 한 번, 최소 한 번, 정확히 한 번 총 세 가지 유형의 전달 방식을 지원한다.</p><hr><p><strong>어떤 전달 방식을 택할 것 인가?</strong></p><p>약간의 중복이 괜찮다면 대체로 <strong>최 소 한번</strong>이 적절하나, 본 설계안은 데이터의 몇 퍼센트 차이가 수백만 달러 차이로 이어질 수 있으므로 <strong>정확히 한 번</strong>방식을 권장한다.</p><p><strong>데이터 중복 제거</strong></p><p>가장 흔한 데이터 품질 이슈 가운데 하나는 중복된 데이터이다.</p><ul><li>클라이언트측<ul><li>한 클라이언트가 같은 이벤트를 여러 번 보내는 경우</li><li>악의적인 의도로 전송되는 중복 이벤트를 처리하는 데는 <strong>광고 사기/위험 제어 컴포넌트</strong>(ad fraud/risk controller)가 적합하다.</li></ul></li><li>서버 장애<ul><li>집계 도중에 집계 서비스 노드에서 장애가 발생하였고, 업 스트림 서비스가 이벤트 메시지에 대해 응답을 받지 못한경우, 같은 이벤트가 다시 전송되어 재차 집계될 가능성이 있다.</li></ul></li></ul><p><img src=/post/system-design-interview-2/6/img_12.png width=593 height=468 srcset="/post/system-design-interview-2/6/img_12_huede191de92b81be00b9a3ae48a395ffa_158639_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_12_huede191de92b81be00b9a3ae48a395ffa_158639_1024x0_resize_box_3.png 1024w" loading=lazy alt="중복 데이터" class=gallery-image data-flex-grow=126 data-flex-basis=304px></p><p>집계 서비스 노드에 장애가 생겨 6단계를 실행하지 못하면 100에서 110 까지의 이벤트는 이비 다운 스트림에 전송되었으나 새 오프셋은 업스트림 카프카에 반영되지 않아, 새로 북고된 집계 서비스 노드는 오프셋 100부터 이벤트를 다시 소비하려고 할 것이다, 그 결과로 데이터 중복이 발생한다.</p><p>이 문제의 간단한 해결책으로 HDFS나 S3 같은 외부 파일 저장소에 오프셋을 기록하는 방법이 있다.</p><p><img src=/post/system-design-interview-2/6/img_13.png width=768 height=529 srcset="/post/system-design-interview-2/6/img_13_hu6b78f3cdb30d0caba5a7a8cd6c6b715e_161577_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_13_hu6b78f3cdb30d0caba5a7a8cd6c6b715e_161577_1024x0_resize_box_3.png 1024w" loading=lazy alt="오프셋 기록" class=gallery-image data-flex-grow=145 data-flex-basis=348px></p><p>집계 결과를 다운 스트림으로 전송하기 전에 오프셋을 외부에 저장하고 있는데, 만일 그 직후 집계 서비스 노드에 장애가 발생하여 4단계를 완료하지 못했다면, 외부 저장소에 저장된 오프셋은 110이므로 복구된 집계 서비스 노드는 100부터 110 까지의 이벤트를 다시 처리하지 않는다.</p><p>따라서 데이터 손실을 막으려면 다운스트림에서 집계 결과 수신 확인 응답을 받은 후에 오프셋을 저장해야 한다.</p><p><img src=/post/system-design-interview-2/6/img_14.png width=814 height=573 srcset="/post/system-design-interview-2/6/img_14_hu2ab70a303052b4a2adad9c1e83700448_163160_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_14_hu2ab70a303052b4a2adad9c1e83700448_163160_1024x0_resize_box_3.png 1024w" loading=lazy alt="수신 확인 후 오프셋 저장" class=gallery-image data-flex-grow=142 data-flex-basis=340px></p><p>이벤트를 정확하게 한 번만 처리하고 싶다면 4단계부터 6단계가지의 작업을 하나의 분산 트랜잭션에 넣어야한다.</p><p>분산 트랜잭션은 여러 노드에서 작동하는 트랜잭션으로 그 안에서 실행하는 작업 가운데 하나라도 실패하면 모든 작업의 상태를 실행 전으로 되돌린다.</p><h3 id=시스템-규모-확장>시스템 규모 확장</h3><p>본 설계안은 메시지 큐, 집계 서버, 데이터베이스의 세 가지 독립 구성 요소로 이루어져, 상호 결합도가 낮으므로 각기 독립적으로 규모를 늘릴 수 있다.</p><hr><p><strong>메시지 큐의 규모 확장</strong></p><p>메시지 큐의 규모 학장법에 대해서는 4장 분산 메시지 큐에서 광범위하게 설명했으므로 요점만 확인한다.</p><ul><li>생산자<ul><li>생산자 인스턴스 수에는 제한을 두지 않으므로 따라서 확정성은 쉽게 달성할 수 있다.</li></ul></li><li>소비자<ul><li>소비자 그룹 내의 재조정 매커니즘은 노드 추가/삭제를 통해 그 규모를 쉽게 조장할 수 있도록 한다.</li></ul></li></ul><p>수백 개 카프카 소비자가 있는 경우 재조정 작업 시간이 길어져서 수 분 이상 걸리게 될 수 있으므로 더 많은 소비자를 추가하는 작업은 시스템 사용량이 많지 않은 시간에 실행하여 영향을 최소화하는 것이 좋다.</p><hr><p><strong>브로커</strong></p><ul><li>해시 키<ul><li>같은 ad_id를 갖는 이벤트를 같은 카프카 파티션에 저장하기 위해 ad_id를 해시 키로 사용한다.</li><li>집계 서비스는 같은 ad_id를 갖는 이벤트를 전부 같은 파티션에서 구독할 수 있다.</li></ul></li><li>파티션의 수<ul><li>파티션의 수가 변하면 같은 ad_id르 ㄹ갖는 이벤트가 다른 파티션에 기록되는 일이 생길 수 있으므로 사전에 충분한 파티션을 확보하여 프로덕션 환경에서 파티션의 수가 동적으로 늘어나는 일을 피하는 것이 좋다.</li></ul></li><li>토픽의 물리적 샤딩<ul><li>하나의 토픽만으로 충분한 경우는 거의 없다.</li><li>지역에 따라, 사업 유형에 따라 여러 토픽을 둘 수 있다.</li><li>장점<ul><li>데이터를 여러 토픽으로 나누면 시스템의 처리 대역폭을 높일 수 있다.</li><li>단일 토픽에 대한 소비자의 수가 줄면 소비자 그룹의 재조정 시간도 단축된다.</li></ul></li><li>단점<ul><li>복잡성이 증가하고 유지 관리 비용이 늘어난다.</li></ul></li></ul></li></ul><hr><p><strong>집게 서비스의 규모 확장</strong></p><p>집계 서비스는 본질적으로 맵리듀스 연산으로 구현된다.</p><p><img src=/post/system-design-interview-2/6/img_15.png width=849 height=546 srcset="/post/system-design-interview-2/6/img_15_hu20e8fafda3109e5f006bddac6e6ffbd9_270584_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_15_hu20e8fafda3109e5f006bddac6e6ffbd9_270584_1024x0_resize_box_3.png 1024w" loading=lazy alt="집계 서비스" class=gallery-image data-flex-grow=155 data-flex-basis=373px></p><p>집계 서비스의 규모는 노드의 추가/삭제를 통해 수평적으로 조정이 가능하다.</p><p>집계 서비스의 처리 대역폭을 높이는 방법으로 두 가지 선택지가 있다.</p><ul><li>ad_id마다 별도의 처리 스레드를 두는 방식<ul><li><img src=/post/system-design-interview-2/6/img_16.png width=778 height=632 srcset="/post/system-design-interview-2/6/img_16_hu9240b727125146b5187adbdd80d812ee_164979_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_16_hu9240b727125146b5187adbdd80d812ee_164979_1024x0_resize_box_3.png 1024w" loading=lazy alt="다중 스레드" class=gallery-image data-flex-grow=123 data-flex-basis=295px></li></ul></li><li>집계 서비스 노드를 아파치 하둡 YARN 같은 자원 공급자에 배포하는 방식</li></ul><p>두 가지 방안 중 첫 번째가 더 구현하기 쉽고, 자원 공급자에 대한 의존 관계도 없다.</p><p>하지만, 더 많은 컴퓨팅 자원을 추가하여 시스템의 규모를 확장할 수 있는 두 번째 방안이 많이 활용된다.</p><hr><p><strong>데이터베이스의 규모 확장</strong></p><p>카산드라는 안정 해시와 유사한 방식으로 수평적인 규모 확장을 기본적으로 지원한다.</p><p><img src=/post/system-design-interview-2/6/img_17.png width=626 height=613 srcset="/post/system-design-interview-2/6/img_17_hu5415acd9f61d814ec2621993794f7a7c_402592_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_17_hu5415acd9f61d814ec2621993794f7a7c_402592_1024x0_resize_box_3.png 1024w" loading=lazy alt="가상 노드" class=gallery-image data-flex-grow=102 data-flex-basis=245px></p><h3 id=핫스팟-문제>핫스팟 문제</h3><p>다른 서비스나 샤드보다 더 많은 데이터를 수신하는 서비스나 샤드를 핫스팟이라 부른다.</p><p>광고 클릭 집계 시스템은 큰 회사가 큰 광고예산을 집행하여 더 많은 노출을 하게 만들수 있고, 이로 인해 특정 광고에 더 많은 클릭이 발생할 수 있다.</p><p>이벤트 파티션을 ad_id로 나누기 때문에 어떤 집계 서비스 노드는 다른 노드보다 더 많은 광고 클릭 이벤트를 수신하게 될 것이고, 그러다보면 서버 과부하 문제가 발생할 수 있다.</p><p>이러한 문제는 더 많은 집계 서비스 노드를 할당하여 완화할 수 있다.</p><p><img src=/post/system-design-interview-2/6/img_18.png width=824 height=646 srcset="/post/system-design-interview-2/6/img_18_hu7889c8879218e6422a2a8525761062d5_152491_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_18_hu7889c8879218e6422a2a8525761062d5_152491_1024x0_resize_box_3.png 1024w" loading=lazy alt="추가 집계 서비스 노드의 할당" class=gallery-image data-flex-grow=127 data-flex-basis=306px></p><ol><li>집계 서비스 노드에 300개 이벤트가 도착하여 노드가 감당할 수 있는 양을 초과 하였기 때문에 자원 관리자에게 추가 자원을 신청한다.</li><li>자원 관리자는 해당 서비스 노드에 과부하가 걸리지 않도록, 추가 자원을 할당한다.(예시는 두 개의 집계 서비스 노드)</li><li>원래 집계 서비스 노드는 각 서비스 노드가 100개씩의 이벤트를 처리할 수 있도록 이벤트를 세 개 그룹으로 분할한다.</li><li>집계가 끝나 축약된 결과는 다시 원래 집계 서비스 노드에 기록한다.</li></ol><p>전역-지역 집계(Global-Local Aggregation)나 분할 고유 집계(Split Distinct Aggregation) 같은 복잡한 방법도 고려할 수 있다.</p><h3 id=결함-내성>결함 내성</h3><p>집게는 메모리에서 이루어지므로 집계 노드에 장애가 생기면 집계 결과도 손실된다.</p><p>하지만 업스트림 카프카 브로커에서 이벤트를 다시 받아오면 그 숫자를 다시 만들어 낼 수 있다.</p><p>카프카 데이터를 원점 주터 다시 재생하여 집계하면 시간이 오래 걸리므로, 업스트림 오프셋 같은 시스템 상태를 스냅숏으로 저장하고 마지막으로 저장된 상태부터 복구해 나가는 것이 바람직하다.</p><ul><li>시스템 상태에 해당하는 정보는 업스트림 오프셋 뿐만 아니라 지난 M분간 가장 많이 클릭된 광고 N개 같은 데이터도 시스템 상태의 일부로 저장한다.</li></ul><p><img src=/post/system-design-interview-2/6/img_19.png width=764 height=247 srcset="/post/system-design-interview-2/6/img_19_hua2281ddfd0fa3d6e52ee3d7483f287c2_75340_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_19_hua2281ddfd0fa3d6e52ee3d7483f287c2_75340_1024x0_resize_box_3.png 1024w" loading=lazy alt="스냅솟 데이터" class=gallery-image data-flex-grow=309 data-flex-basis=742px></p><p>스냅숏을 이용하면 집계 서비스의 복구 절차가 단순해진다.</p><p>어떤 집계 서비스 노드 하나에 장애가 발생하면 해당 노드를 새 것으로 대체한 다음 마지막 스냅숏에서 데이터를 복구하면 된다.</p><h3 id=데이터-모니터링-및-정확성>데이터 모니터링 및 정확성</h3><p>집계 결과는 RTB 및 청구서 발행 목적으로 사용될 수 있으므로ㅓ 시스템이 정상적으로 동작하는 지 모니터링 하고 데이터 정확성을 보장하는 것은 아주 중요한 과제이다.</p><p><strong>지속적 모니터링</strong></p><ul><li>지연 시간<ul><li>데이터를 처리하는 각 단계마다 지연 시간이 추가될 수 있으므로, 시스템의 중요 부분마다 시각 추적이 가능하도록 해야한다.</li><li>기록된 사각 사이의 차이를 지연 시간 지표로 변환해서 모니터링한다.</li></ul></li><li>메시지 큐 크기<ul><li>큐의 크기가 갑자기 늘어난다면 더 많은 집계 서비스 노드를 추가해야 할 수 있다.</li><li>카프카는 분산 커밋 로그 형태로 구현된 메시지 큐 이므로, 카프카를 사용하는 경우 레코드 처리 지연 지표를 대신 추적한다.</li></ul></li><li>집계 노드의 시스템 자원<ul><li>CPU, 디스크, JVM 같은 것에 관계된 지표</li></ul></li></ul><hr><p><strong>조정</strong></p><p>조정(reconciliation)은 다양한 데이터를 비교하여 데이터 무결성을 보증하는 기법을 일컫는다.</p><p>광고 클릭 집게 결과는 비교할 제 3자가 없으므로 매일 각 파이션에 기록된 클릭 이벤트를 이벤트 발생 시각에 따라 정렬한 결과를 일괄 처리하여 만들어낸 후, 실시간 집계 결과와 비교해 볼 수 있다.</p><ul><li>더 높은 정확도가 필요하다면 더작은 집계 작은 집계 윈도를 사용한다.</li><li>윈도 크기와 관계 없이 일부 이벤트는 늦게 도착할 수 있으므로 배치 작업 결과가 실시간 집계 결과와 정확히 일치하지 않을 수 있다.</li></ul><hr><p><img src=/post/system-design-interview-2/6/img_20.png width=833 height=346 srcset="/post/system-design-interview-2/6/img_20_hub35bf4c448d6cf0170ffb4ecf93d6924_122803_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_20_hub35bf4c448d6cf0170ffb4ecf93d6924_122803_1024x0_resize_box_3.png 1024w" loading=lazy alt="최종 설계안" class=gallery-image data-flex-grow=240 data-flex-basis=577px></p><h3 id=대안적-설계안>대안적 설계안</h3><p>다른 한 가지 가능한 설계안은 광고 클릭 데이터를 하이브에 저장한 다음 빠른 질의는 일래스틱서치 계층을 얹어서 처리할 수 있다.</p><p><img src=/post/system-design-interview-2/6/img_21.png width=833 height=286 srcset="/post/system-design-interview-2/6/img_21_hu8585af607f9fff0160c43d5a0ee15e53_80257_480x0_resize_box_3.png 480w, /post/system-design-interview-2/6/img_21_hu8585af607f9fff0160c43d5a0ee15e53_80257_1024x0_resize_box_3.png 1024w" loading=lazy alt=img_21.png class=gallery-image data-flex-grow=291 data-flex-basis=699px></p><p>집계는 클릭하우스, 드루이드 같은 OLAP 데이터베이스를 통해 처리할 수 있다.</p><h2 id=4단계-마무리>4단계: 마무리</h2><p>이번 장에서는 페이스북이나 구글 규모의 광고 클릭 이벤트 집계 시스템을 설계하는 프로세스를 다루어 보았다.</p><ul><li>데이터 모델 및 API 설계</li><li>맵리듀스 데이터 처리 패러다임을 통해 광고 클릭 이벤트를 집계하는 방법</li><li>메시지 큐, 집계 서비스, 데이터베이스의 규모 확장 방안</li><li>핫스팟 문제를 해결하는 방안</li><li>시스템의 지속적 모니터링</li><li>데이터 조정을 통한 정확성 보증 방안</li><li>결함 내성</li></ul><p>광고 클릭 이벤트 집계 시스템은 전형적인 빅데이터 처리 시스템이다.</p><p>아파치 카프카, 아파치 플링크, 아파치 스파크 같은 업계 표준 솔루션에 대한 사전 지식이나 경험이 있다면 이해하고 설계하기 쉬울 것이다.</p></section><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
</script><footer class=article-footer><section class=article-tags><a href=/tags/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/>가상 면접 사례로 배우는 대규모 시스템 설계 기초</a>
<a href=/tags/system-design-interview/>System Design Interview</a>
<a href=/tags/%EA%B4%91%EA%B3%A0-%ED%81%B4%EB%A6%AD-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%A7%91%EA%B3%84-%EC%8B%9C%EC%8A%A4%ED%85%9C/>광고 클릭 이벤트 집계 시스템</a>
<a href=/tags/ad-click-event-aggregation-system/>Ad Click Event Aggregation System</a>
<a href=/tags/rtb/>RTB</a>
<a href=/tags/real-time-bidding/>Real-Time Bidding</a>
<a href=/tags/%EC%B9%B4%EC%82%B0%EB%93%9C%EB%9D%BC/>카산드라</a>
<a href=/tags/cassandra/>Cassandra</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><div class="article-list--compact links"><article><a href=https://product.kyobobook.co.kr/detail/S000211656186 target=_blank rel=noopener><div class=article-details><h2 class=article-title>가상 면접 사례로 배우는 대규모 시스템 설계 기초 2</h2><footer class=article-time>교보문고</footer></div></a></article></div><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/post/system-design-interview-2/3/><div class=article-image><img src=/post/system-design-interview-2/3/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 3. 구글 맵" data-key=system-design-interview-2/3 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>3. 구글 맵</h2></div></a></article><article class=has-image><a href=/post/system-design-interview/5/><div class=article-image><img src=/post/system-design-interview/5/cover.19a01050cbb7e15d6051c06331fb6a04_huebcf5dd667df9af228f80687035dfdfb_164704_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 5. 안정 해시 설계" data-key=system-design-interview/5 data-hash="md5-GaAQUMu34V1gUcBjMftqBA=="></div><div class=article-details><h2 class=article-title>5. 안정 해시 설계</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/13/><div class=article-image><img src=/post/system-design-interview-2/13/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 13. 증권 거래소" data-key=system-design-interview-2/13 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>13. 증권 거래소</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/12/><div class=article-image><img src=/post/system-design-interview-2/12/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 12. 전자 지갑" data-key=system-design-interview-2/12 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>12. 전자 지갑</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/11/><div class=article-image><img src=/post/system-design-interview-2/11/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 11. 결제 시스템" data-key=system-design-interview-2/11 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>11. 결제 시스템</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=codemario318/codemario318.github.io issue-term=pathname label=Comment crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2023 -
2024 Mario Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>