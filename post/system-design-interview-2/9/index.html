<!doctype html><html lang=ko dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="가상 면접 사례로 배우는 대규모 시스템 설계 기초 2"><title>9. S3와 유사한 객체 저장소</title><link rel=canonical href=https://codemario318.github.io/post/system-design-interview-2/9/><link rel=stylesheet href=/scss/style.min.cbce94e2760d14d60414e59d5a36ab2819232375817e010dbe7be2234b67da1b.css><meta property="og:title" content="9. S3와 유사한 객체 저장소"><meta property="og:description" content="가상 면접 사례로 배우는 대규모 시스템 설계 기초 2"><meta property="og:url" content="https://codemario318.github.io/post/system-design-interview-2/9/"><meta property="og:site_name" content="Mario Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="가상 면접 사례로 배우는 대규모 시스템 설계 기초"><meta property="article:tag" content="System Design Interview"><meta property="article:tag" content="S3"><meta property="article:tag" content="Simple Storage Service"><meta property="article:tag" content="Amazon Web Service"><meta property="article:tag" content="AWS"><meta property="article:tag" content="RESTful API"><meta property="article:tag" content="Storage System"><meta property="article:tag" content="저장소 시스템"><meta property="article:tag" content="블록 저장소"><meta property="article:tag" content="Block Storage"><meta property="article:tag" content="파일 저장소"><meta property="article:tag" content="File Storage"><meta property="article:tag" content="객체 저장소"><meta property="article:tag" content="Object Storage"><meta property="article:published_time" content="2024-11-03T19:14:50+09:00"><meta property="article:modified_time" content="2024-11-03T19:14:50+09:00"><meta property="og:image" content="https://codemario318.github.io/post/system-design-interview-2/9/cover.png"><meta name=twitter:title content="9. S3와 유사한 객체 저장소"><meta name=twitter:description content="가상 면접 사례로 배우는 대규모 시스템 설계 기초 2"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://codemario318.github.io/post/system-design-interview-2/9/cover.png"><script async src="https://www.googletagmanager.com/gtag/js?id=G-K99591YLGK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K99591YLGK",{anonymize_ip:!1})}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3183752545292673" crossorigin=anonymous></script><meta name=naver-site-verification content="2315bde85c86f66092140cc465c340a2170f3187"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu760fd15c5fbb2f30cf0868dc4a5dc41a_14271_300x0_resize_q75_box.jpeg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Mario Blog</a></h1><h2 class=site-description></h2></div></header><ol class=social-menu><li><a href=https://github.com/codemario318 target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><ul class="menu sub-menu"><li><a href=/categories/backend/><span>Backend</span>
<span class=content-count>3</span></a></li><li><a href=/categories/boostcamp/><span>부스트캠프</span>
<span class=content-count>10</span></a></li><li><a href=/categories/cleancode/><span>Clean Code</span>
<span class=content-count>10</span></a></li><li><a href=/categories/common/><span>Common</span>
<span class=content-count>68</span></a></li><li><a href=/categories/data/><span>Data</span>
<span class=content-count>3</span></a></li><li><a href=/categories/db/><span>DB</span>
<span class=content-count>1</span></a></li><li><a href=/categories/frontend/><span>Frontend</span>
<span class=content-count>10</span></a></li><li><a href=/categories/golang/><span>GoLang</span>
<span class=content-count>13</span></a></li><li><a href=/categories/headfirstdesignpatterns/><span>헤드 퍼스트 디자인 패턴</span>
<span class=content-count>22</span></a></li><li><a href=/categories/infra/><span>Infra</span>
<span class=content-count>14</span></a></li><li><a href=/categories/nest/><span>Nest</span>
<span class=content-count>1</span></a></li><li><a href=/categories/network/><span>네트워크</span>
<span class=content-count>1</span></a></li><li><a href=/categories/node/><span>Node</span>
<span class=content-count>1</span></a></li><li><a href=/categories/problemsolving/><span>Problem Solving</span>
<span class=content-count>1</span></a></li><li><a href=/categories/project/><span>Project</span>
<span class=content-count>5</span></a></li><li><a href=/categories/realmysql/><span>Real MySQL</span>
<span class=content-count>53</span></a></li></ul><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#저장소-시스템-101>저장소 시스템 101</a><ol><li><a href=#블록-저장소>블록 저장소</a></li><li><a href=#파일-저장소>파일 저장소</a></li><li><a href=#객체-저장소>객체 저장소</a></li><li><a href=#비교>비교</a></li><li><a href=#용어-정리>용어 정리</a></li></ol></li><li><a href=#1단계-문제-이해-및-설계-범위-확정>1단계: 문제 이해 및 설계 범위 확정</a><ol><li><a href=#비기능-요구사항>비기능 요구사항</a></li><li><a href=#대략적-규모-추정>대략적 규모 추정</a></li></ol></li><li><a href=#2단계-개략적-설계안-제시-및-동의-구하기>2단계: 개략적 설계안 제시 및 동의 구하기</a><ol><li><a href=#객체-저장소의-속성>객체 저장소의 속성</a></li><li><a href=#개략적-설계안>개략적 설계안</a></li><li><a href=#객체-업로드>객체 업로드</a></li><li><a href=#객체-다운로드>객체 다운로드</a></li></ol></li><li><a href=#3단계-상세-설계>3단계: 상세 설계</a><ol><li><a href=#데이터-저장소>데이터 저장소</a></li><li><a href=#데이터-저장소의-개략적-설계>데이터 저장소의 개략적 설계</a></li><li><a href=#데이터-라우팅-서비스>데이터 라우팅 서비스</a></li><li><a href=#배치-서비스>배치 서비스</a></li><li><a href=#데이터-노드>데이터 노드</a></li><li><a href=#데이터-저장-흐름>데이터 저장 흐름</a></li><li><a href=#데이터는-어떻게-저장되는가>데이터는 어떻게 저장되는가</a></li><li><a href=#객체-소재-확인>객체 소재 확인</a></li><li><a href=#개선된-데이터-저장-흐름>개선된 데이터 저장 흐름</a></li><li><a href=#데이터-내구성>데이터 내구성</a></li><li><a href=#정확성-검증>정확성 검증</a></li><li><a href=#메타데이터-데이터-모델>메타데이터 데이터 모델</a></li><li><a href=#버킷-내-객체-목록-확인>버킷 내 객체 목록 확인</a></li><li><a href=#단일-데이터베이스-서버>단일 데이터베이스 서버</a></li><li><a href=#분산-데이터베이스>분산 데이터베이스</a></li><li><a href=#객체-버전>객체 버전</a></li><li><a href=#큰-파일의-업로드-성능-최적화>큰 파일의 업로드 성능 최적화</a></li><li><a href=#쓰레기-수집>쓰레기 수집</a></li></ol></li><li><a href=#4단계-마무리>4단계: 마무리</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/post/system-design-interview-2/9/><img src=/post/system-design-interview-2/9/cover_huf565d8fe7a4f9f5a961306624616abfc_449360_800x0_resize_box_3.png srcset="/post/system-design-interview-2/9/cover_huf565d8fe7a4f9f5a961306624616abfc_449360_800x0_resize_box_3.png 800w, /post/system-design-interview-2/9/cover_huf565d8fe7a4f9f5a961306624616abfc_449360_1600x0_resize_box_3.png 1600w" width=800 height=1143 loading=lazy alt="Featured image of post 9. S3와 유사한 객체 저장소"></a></div><div class=article-details><header class=article-category><a href=/categories/common/ style=background-color:#2a9d8f;color:#fff>Common</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/system-design-interview-2/9/>9. S3와 유사한 객체 저장소</a></h2><h3 class=article-subtitle>가상 면접 사례로 배우는 대규모 시스템 설계 기초 2</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2024/11/03</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>23 minute read</time></div></footer></div></header><section class=article-content><p>이번 장에서는 아마존 S3(Simple Storage Service)와 유사한 객체 저장소 서비스를 설계한다.</p><p>S3는 AWS가 제공하는 서비스로 RESTful API 기반 인터페이스로 이용 가능한 객체 저장소다.</p><p>객체 저장소에 대해 더 자세히 살펴보기 전, 일반적으로 저장소란 어떤 시스템인지 알아보고, 몇 가지 용어를 정의해본다.</p><h2 id=저장소-시스템-101>저장소 시스템 101</h2><p>개략적으로 보면 저장소 시스템에는 3가지 부류가 있다.</p><p><img src=/post/system-design-interview-2/9/img.png width=1802 height=684 srcset="/post/system-design-interview-2/9/img_hu1df0f1708df54f3b26fa0b850b382790_117739_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_hu1df0f1708df54f3b26fa0b850b382790_117739_1024x0_resize_box_3.png 1024w" loading=lazy alt="저장소 유형" class=gallery-image data-flex-grow=263 data-flex-basis=632px></p><h3 id=블록-저장소>블록 저장소</h3><p>HDD, SSD 처럼 서버에 물리적으로 연결되는 형태의 드라이브는 블록 저장소에 가장 흔한 형태이다.</p><p>블록저장소는 원시 블록(raw block)을 서버에 볼륨 형태로 제공하는 가장 유연하고 융통성 높은 저장소다.</p><ul><li>서버는 원시 블록을 포맷한 다음 파일 시스템으로 이용하거나 애플리케이션에 블록 제어권을 넘겨 버릴 수도 있다.</li><li>데이터베이스나 가상 머신 엔진 같은 애플리케이션은 원시 블록을 직접 제어하여 최대한의 성능을 끌어낸다.</li></ul><p>서버에 물리적으로 직접 연겨로디는 저장소에 국한되지 않는다.</p><ul><li>고속 네트워크를 통해 연결될 수도 있다.</li><li>업계 표준 연결 프로토콜은 FC(Fiber Channel)이나 ISCSI를 통해 연결될 수도 있다.</li></ul><p>개념적으로 보면 네트워크를 통해 연결되는 블록 저장소도 원시 블록을 제공한다는 점에서 다르지 않으며, 서버 입장에서 보면 물리적으로 연결된 블록 저장소와 마찬가지로 동작한다.</p><h3 id=파일-저장소>파일 저장소</h3><p>파일 저장소는 블록 저장소 위에 구현된다.</p><ul><li>파일과 디렉터리를 손쉽게 다루는 데 필요한, 더 높은 수준의 추상화를 제공한다.</li><li>데이터는 계층적으로 구성되는 디렉터리 안에 보관된다.</li></ul><p>파일 저장소는 가장 널리 사용되는 범용 저장소 솔루션으로, SMB/CIFS나 NFS와 같은 파일 수준 네트워크 프로토콜을 사용하면 하나의 저장소를 여러 서버에 동시에 붙일 수도 있다.</p><p>파일 저장소를 사용하는 서버는 블록을 직접 제어하고, 볼륨을 포맷하는 등의 까다로운 작업을 신경 쓸 필요가 없다.</p><ul><li>단순하기 때문에 폴더나 파일을 같은 조직 구성원에 공유하는 솔루션으로 사용하기 좋다.</li></ul><h3 id=객체-저장소>객체 저장소</h3><p>새로운 형태의 저장소로 데이터 영속성을 높이고 대규모 애플리케이션을 지원하며 비용을 낮추기 위해 의도적으로 성능을 희생한다.</p><ul><li>실시간으로 갱신할 필요가 없는 상대적으로 차가운(cold) 데이터 보관에 초점을 맞추며, 데이터 아카이브나 백업에 주로 쓰인다.</li></ul><p>모든 데이터를 수평적 구조 내에 객체로 보관한다.</p><ul><li>계층적 디렉터리 구조는 제공하지 않는다.</li></ul><p>데이터 접근은 보통 RESTful API를 사용하며, 다른 유형의 저장소에 비해 상대적으로 느리다.</p><h3 id=비교>비교</h3><div class=table-wrapper><table><thead><tr><th></th><th>블록 저장소</th><th>파일 저장소</th><th>객체 저장소</th></tr></thead><tbody><tr><td>저장된 내용의 변경 가능성</td><td>Y</td><td>Y</td><td>N(새로운 버전의 객체를 추가하는 것은 가능)</td></tr><tr><td>비용</td><td>고</td><td>중 ~ 고</td><td>저</td></tr><tr><td>성능</td><td>중 ~ 고 혹은 최상</td><td>중 ~ 고</td><td>저 ~ 중</td></tr><tr><td>데이터 일관성</td><td>강력</td><td>강력</td><td>강력</td></tr><tr><td>데이터 접근</td><td>SAS/iSCSI/FC</td><td>표준 파일 접근, CIFS/SMB, NFS</td><td>RESTful API</td></tr><tr><td>규모 확장성</td><td>중</td><td>고</td><td>최상</td></tr><tr><td>적합한 응용</td><td>가상머신, 데이터베이스 같은 높은 성능이 필요한 애플리케이션</td><td>범용적 파일 시스템 접근</td><td>이진 데이터, 구조화되지 않은 데이터</td></tr></tbody></table></div><h3 id=용어-정리>용어 정리</h3><p>객체 저장소의 핵심 개념을 먼저 이해할 필요가 있다.</p><ul><li>버킷(bucket)<ul><li>객체를 보관하는 논리적 컨테이너</li><li>버킷 이름은 전역적으로 유일해야 함(globally unique)</li><li>데이터를 업로드하려면 우선 버킷부터 만들어야 함</li></ul></li><li>객체(Object)<ul><li>버킷에 저장하는 개별 데이터</li><li>데이터(페이로드라고도 함)와 메타데이터를 가짐<ul><li>객체 데이터로는 어떤 것도 가능함</li><li>메타데이터는 객체를 기술하는 이름-값 쌍</li></ul></li></ul></li><li>버전(version)<ul><li>한 객체의 여러 버전을 같은 버킷 안에 둘 수 있도록 하는 기능</li><li>버킷마다 별도 설정 가능</li><li>객체를 복구할 수 있도록 함</li></ul></li><li>URI(Uniform Resource Identifier)<ul><li>객체 저장소는 버킷과 객체에 접근할 수 있도록 하는 RESTful API를 제공하기 때문에 각 객체는 해당 API URI를 통해 고유하게 식별할 수 있다.</li></ul></li><li>SLA(서비스 수준 협약, Service-Level Agreement)<ul><li>서비스 제공자와 클라이언트 사이에 맺어지는 계약<ul><li>여러 AZ(availability zone)에 걸쳐 99.999999999%의 객체 내구성을 제공</li><li>하나의 가용성 구역 전체가 소실되어도 데이터 복원 가능</li><li>연간 99.9%의 가용성 제공</li></ul></li></ul></li></ul><h2 id=1단계-문제-이해-및-설계-범위-확정>1단계: 문제 이해 및 설계 범위 확정</h2><ul><li>다음 기능을 제공하는 S3와 유사한 객체 저장소 시스템 설계<ul><li>버킷 생성</li><li>객체 업로드 및 다운로드</li><li>객처 버전</li><li>버킷 내 객체 목록 출력 기능(aws s3 ls)</li></ul></li><li>아주 큰 객체(수 GB 이상)와 다량의 소형 객체(수 KB 정도)를 효율적으로 저장할 수 있어야함</li><li>매년 추가되는 데이터는 100PB</li><li>99.9999%의 데이터 내구성과 99.99% 서비스 가용성을 보장</li></ul><h3 id=비기능-요구사항>비기능 요구사항</h3><ul><li>100PB 데이터</li><li>식스 나인(six nines, 99.9999%) 수준의 데이터 내구성</li><li>포 나인(four nines, 99.99%) 수준의 서비스 가용성</li><li>저장소 효율성<ul><li>높은 수준의 안정성과 성능은 보증하되 저장소 비용의 최대한 낮춰야함</li></ul></li></ul><h3 id=대략적-규모-추정>대략적 규모 추정</h3><p>객체 저장소는 <strong>디스크 용량</strong>이나 <strong>초당 디스크 IO</strong>(IOPS)가 병목이 될 가능성이 높다.</p><ul><li>디스크 용량: 객체 크기는 다음 분포를 따른다.<ul><li>객체 가운데 20%는 그 크기가 1MB 미만의 작은 객체</li><li>60% 정도의 객체는 1MB ~ 64MB 정도의 중간 크기 객체</li><li>나머지 20% 정도는 64MB 이상의 대형 객체</li></ul></li><li>IOPS<ul><li>SATA 인터페이스를 탑재하고 7200rpm을 지원하는 하드 디스크 하나가 초당 100 ~ 150 임의 데이터 탐색을 지원할 수 있다고 가정(100 ~ 150 IOPS)</li></ul></li></ul><p>이 가정에 기반하여 시스템이 저장 가능한 객체 수를 가늠할 수 있다.</p><ul><li><code>100PB = 100 * 1000 * 1000 * 1000MB = 10MB</code></li><li><code>(10^11 * 0.4) / (0.2 * 0.5MB + 0.6 * 32MB + 0.2 * 200MB) = 6억 8천만 개</code></li><li>모든 객체의 메타데이터 크기가 대략 1KB라고 가정하면 메타데이터 정보를 저장하기 위해 약 0.68TB 필요함</li></ul><h2 id=2단계-개략적-설계안-제시-및-동의-구하기>2단계: 개략적 설계안 제시 및 동의 구하기</h2><h3 id=객체-저장소의-속성>객체 저장소의 속성</h3><p>설계를 진행하기 전 설계안에 영향을 끼칠 수 있는 객체 저장소의 몇 가지 속성을 살펴본다.</p><ul><li>객체 불변성(object immutability)<ul><li>객체 저장소와 다른 두 가지 유형의 저장소 시스템의 가장 큰 차이는 객체 저장소에 보관되는 객체들은 변경이 불가능하다는 것이다.</li><li>삭제한 다음 새 버전 객체로 완전히 대체할 수는 있어도 그 값을 점진적으로 변경할 수는 없다.</li></ul></li><li>키-값 저장소(key-value store)<ul><li>객체 저장소를 사용하는 경우 해당 객체의 URI를 사용하여 데이터를 가져올 수 있다.</li><li>이때 URI는 키이고 데이터는 값에 해당하므로 키-값 저장소로 볼 수 있다.</li></ul></li><li>저장은 1회, 읽기는 여러번<ul><li>링크드인에서 조사한 결과에 따르면 객체 저장소에 대한 요청 가운데 95%가 읽기 요청</li></ul></li><li>소형 및 대형 객체 동시 지원</li></ul><p><img src=/post/system-design-interview-2/9/img_1.png width=1368 height=1058 srcset="/post/system-design-interview-2/9/img_1_hu7a09d655bdca71a694f3b89fa147b0fe_118779_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_1_hu7a09d655bdca71a694f3b89fa147b0fe_118779_1024x0_resize_box_3.png 1024w" loading=lazy alt="UNIX 파일 시스템과 객체 저장소" class=gallery-image data-flex-grow=129 data-flex-basis=310px></p><p>객체 저장소의 설계 철학은 UNIX 파일 시스템의 설계 철학과 아주 비슷하다.</p><ul><li>파일을 로컬 파일 시스템에 저장하면 파일의 이름과 데이터는 같은 곳에 저장되지 않음<ul><li>아이노드(inode)라고 불리는 자료 구조에 보관되고 파일의 데이터는 디스크의 다른 위치로 들어감</li><li>아이노드에는 파일 블록 포인터 목록(디스크상의 위치를 가르킴)이 들어감</li></ul></li></ul><p>객체 저장소의 동작 방식도 비슷하다.</p><ul><li>객체 저장소의 메타데이터 저장소는 아이노드에 해당<ul><li>파일 블록 포인터 대신 네트워크를 통해 데이터 저장소에 보관된 객체를 요청하는 데 필요한 식별자가 보관</li></ul></li><li>데이터 저장소는 하드 디스크에 해당</li></ul><p><img src=/post/system-design-interview-2/9/img_2.png width=1400 height=648 srcset="/post/system-design-interview-2/9/img_2_hu9a3c03d51fe0a5ac2771442398f3385a_54968_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_2_hu9a3c03d51fe0a5ac2771442398f3385a_54968_1024x0_resize_box_3.png 1024w" loading=lazy alt="버킷과 객체" class=gallery-image data-flex-grow=216 data-flex-basis=518px></p><p>메타데이터와 객체의 실제 데이터를 분리하면 설계가 단순해진다.</p><ul><li>데이터 저장소에 보관되는 데이터는 불변</li><li>메타데이터 저장소에 보관되는 데이터는 변경 가능</li></ul><p>이렇게 분리해 두면 그 두 컴포넌트를 독립적으로 구현하고 최적화 할 수 있다.</p><h3 id=개략적-설계안>개략적 설계안</h3><p><img src=/post/system-design-interview-2/9/img_3.png width=1596 height=1102 srcset="/post/system-design-interview-2/9/img_3_hud2179ecbb7aca45fd8052ff6358b8624_96587_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_3_hud2179ecbb7aca45fd8052ff6358b8624_96587_1024x0_resize_box_3.png 1024w" loading=lazy alt="개략적 설계안" class=gallery-image data-flex-grow=144 data-flex-basis=347px></p><ul><li>로드밸런서<ul><li>요청을 API 서버들에 분산</li></ul></li><li>API 서비스<ul><li>IAM 서비스, 메타데이터 서비스, 저장소 서비스에 대한 호출을 조율하는 역할 담당</li><li>무상태 서비스이므로 수평적인 규모 확장이 가능</li></ul></li><li>IAM 서비스<ul><li>인증, 권한 부여, 접근 제어 등을 중앙에서 맡아 처리</li></ul></li><li>데이터 저장소<ul><li>실제 데이터를 보관하고 필요할 때마다 읽어가는 장소</li><li>모든 데이터 관련 연산은 객체 ID(UUID)를 통함</li></ul></li><li>메타데이터 저장소<ul><li>객체 메타데이터를 보관</li></ul></li></ul><p>메타데이터 저장소와 데이터 저장소는 논리적은 구분이 뿐이며 구현 방법은 여러가지 있을 수 있다.</p><ul><li>RGW(Ceph&rsquo;s Rados Gateway)는 독립적인 메타데이터 저장소를 두지 않고 객체 버킷을 포함한 모든 객체는 하나 이상의 라도스 객체로 저장됨</li></ul><h3 id=객체-업로드>객체 업로드</h3><p><img src=/post/system-design-interview-2/9/img_4.png width=1638 height=1110 srcset="/post/system-design-interview-2/9/img_4_hudeb03fde8424d983bb6ca7e620253294_125124_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_4_hudeb03fde8424d983bb6ca7e620253294_125124_1024x0_resize_box_3.png 1024w" loading=lazy alt="객체 업로드" class=gallery-image data-flex-grow=147 data-flex-basis=354px></p><ol><li>클라이언트는 <code>bucket-to-share</code> 버킷을 생성하기 위한 <code>HTTP PUT</code> 요청을 보낸다.</li><li>API 서비스는 IAM을 호출하여 <code>WRITE</code> 권한을 가졌는지 확인한다.</li><li>API 서비스는 메타데이터 데이터베이스에 버킷 정보를 등록하기 위해 메타데이터 저장소를 호출한다.<ul><li>버킷 정보가 만들어지면 그 사실을 알리는 메시지가 클라이언트에 전송된다.</li></ul></li><li>버킷이 만들어지고 나면 클라이언트는 <code>script.txt</code> 객체를 생성하기 위한 <code>HTTP PUT</code> 요청을 보낸다.</li><li>API 서비스는 해당 사용자 신원 및 <code>WRITE</code> 권한을 확인한다.</li><li>문제가 없다면 <code>HTTP PUT</code> 요청 body에 실린 객체 데이터를 데이터 저장소로 보낸다.<ul><li>데이터 저장소는 해당 데이터를 객체로 저장하고 해당 객체의 UUID를 반환한다.</li></ul></li><li>API 서비스는 메타데이터 저장소를 호출하여 새로운 항목을 등록한다.<ul><li><code>object_id</code>: UUID</li><li><code>bucket_id</code>: 해당 객체가 속한 버킷</li><li><code>object_name</code></li></ul></li></ol><h3 id=객체-다운로드>객체 다운로드</h3><p>버킷은 디렉터리 같은 계층 구조를 지원하지 않지만 버킷 이름과 객체 이름을 연결하면 폴더 구조를 흉내 내는 논리적 계층을 만들수는 있다.</p><ul><li>객체 이름을 <code>script.txt</code> 대신 <code>bucket-to-share/script.txt</code>로 설정한다.</li></ul><p>앞서 언급한 대로 데이터 저장소는 객체 이름을 보관하지 않으며 <code>object_id</code>(UUID)를 통한 객체 연산만 지원한다.</p><p>따라서 객체를 다운로드 하려면 객체 이름을 우선 UUID로 변환해야 한다.</p><p><img src=/post/system-design-interview-2/9/img_5.png width=1678 height=1130 srcset="/post/system-design-interview-2/9/img_5_hu110197024181dbd370c8f07617508a76_123232_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_5_hu110197024181dbd370c8f07617508a76_123232_1024x0_resize_box_3.png 1024w" loading=lazy alt="객체 다운로드" class=gallery-image data-flex-grow=148 data-flex-basis=356px></p><ol><li>클라이언트는 요청을 로드밸런서로 보내고, 로드밸런서는 이 요청을 API 서버로 보낸다.</li><li>API 서버는 IAM을 통해 <code>READ</code> 권한 확인한다.</li><li>권한이 있다면 해당 객체의 UUID를 메타데이터 자장소에서 가져온다.</li><li>해당 UUID를 이용해 ㄱ데이터 저장소에서 객체 데이터를 가져온다.</li><li><code>HTTP GET</code> 요청에 대한 응답으로 해당 객체 데이터를 반환한다.</li></ol><h2 id=3단계-상세-설계>3단계: 상세 설계</h2><h3 id=데이터-저장소>데이터 저장소</h3><p>API 서비스는 사용자의 요청을 받으면 그 요청을 처리하기 위해 다른 내부 서비스들을 호출한다.</p><p>객체를 저장하거나 가져오는 작업은 데이터 저장소를 호출하여 치리한다.</p><p><img src=/post/system-design-interview-2/9/img_6.png width=1562 height=812 srcset="/post/system-design-interview-2/9/img_6_hue1e1f6cb970aa79d651ef8332bbfc81c_94602_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_6_hue1e1f6cb970aa79d651ef8332bbfc81c_94602_1024x0_resize_box_3.png 1024w" loading=lazy alt="객체 업로드/다운로드" class=gallery-image data-flex-grow=192 data-flex-basis=461px></p><h3 id=데이터-저장소의-개략적-설계>데이터 저장소의 개략적 설계</h3><p><img src=/post/system-design-interview-2/9/img_7.png width=1562 height=926 srcset="/post/system-design-interview-2/9/img_7_huee933f54ae912df3dcfab4f3820c10c9_199981_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_7_huee933f54ae912df3dcfab4f3820c10c9_199981_1024x0_resize_box_3.png 1024w" loading=lazy alt="데이터 저장소 컴포넌트" class=gallery-image data-flex-grow=168 data-flex-basis=404px></p><p>세 가지 주요 컴포넌트로 구성된다.</p><h3 id=데이터-라우팅-서비스>데이터 라우팅 서비스</h3><p>데이터 노드 클러스터에 접근하기 위한 RESTful 또는 gRPC 서비스르 제공한다.</p><p>더 많은 서버를 추가하여 쉽게 규모를 확장할 수 있는 무상태 서비스다.</p><ul><li>배치 서비스(placement service)를 호출하여 데이터를 저장할 최적의 데이터 노드를 판단</li><li>데이터 노드에서 데이터를 읽어 API 서비스에 반환</li><li>데이터 노드에 데이터 기록</li></ul><h3 id=배치-서비스>배치 서비스</h3><p>어느 데이터 노드에 데이터를 저장할 지 결정하는 역할을 담당한다.</p><ul><li>데이터 노드에는 주 데이터 노드와 부 데이터 노드가 있다.</li></ul><p>배치 서비스는 내부적으로 가상 클러스터 지도(virtual cluster map)를 유지하는데, 믈러스터의 물리적 형상 정보가 보관된다.</p><ul><li>이 지도에 보관되는 데이터 노드의 위치 정보를 이용하여 데이터 사본이 물리적으로 다른 위치에 놓이도록 한다.</li><li>물리적인 분리는 높은 데이터 내구성을 달성하는 핵심 요소이다.</li></ul><p><img src=/post/system-design-interview-2/9/img_8.png width=1796 height=574 srcset="/post/system-design-interview-2/9/img_8_hubd3eed9b0fa2cb41ef412d0106cdbfa1_46429_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_8_hubd3eed9b0fa2cb41ef412d0106cdbfa1_46429_1024x0_resize_box_3.png 1024w" loading=lazy alt="가상 클러스터 지도" class=gallery-image data-flex-grow=312 data-flex-basis=750px></p><p>배치 서비스는 모든 데이터 노드와 지속적으로 박동 메시지를 주고받으며 상태를 모니터링 한다.</p><ul><li>15초의 유예 기간(grace period) 동안 박동 메시지에 응답하지 않는 데이터 노드는 지도에 죽은 노드로 표시한다.</li></ul><p>배치 서비스는 아주 중요한 서비스이므로 5개에서 7개의 노드를 갖는 배치 서비스 클러스터를 팩서스(Paxos)나 래프트(Raft) 같은 합의 프로토콜을 사용하여 구축살 것을 권장한다.</p><ul><li>7개 노드로 구성된 배치 서비스 클러스터는 최대 3개까지의 노드 장애는 감내할 수 있다.</li></ul><h3 id=데이터-노드>데이터 노드</h3><p>실제 객체 데이터가 보관되는 곳으로 여러 노드에 데이터를 복제함으로써 데이터의 안정성과 내구성을 보증한다.(다중화 그룹, replication group)</p><p>각 데이터 노드에는 배치 서비스에 주기적으로 박동 메시지를 보내는 서비스 데몬(service daemon)이 돈다.</p><p>박동 메시지에는 다은과 같은 정보가 들어있다.</p><ul><li>해당 데이터 노드에 부착된 디스크 드라이브(HDD/SSD) 수</li><li>각 드라이브에 저장된 데이터의 양</li></ul><p>배치 서비스는 못 보던 데이터 노드에서 박동 메시지를 처음 받으면 해당 노드에 ID를 부여하고 가상 클러스터 지도에 추가한 다음, 아래 정보를 반환한다.</p><ul><li>해당 데이터 노드에 부여한 고유 식별자</li><li>가상 클러스터 지도</li><li>데이터 사본을 보관할 위치</li></ul><h3 id=데이터-저장-흐름>데이터 저장 흐름</h3><p><img src=/post/system-design-interview-2/9/img_9.png width=1842 height=846 srcset="/post/system-design-interview-2/9/img_9_hud2484f5adb04e6c8af35aa41b56cd91b_218424_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_9_hud2484f5adb04e6c8af35aa41b56cd91b_218424_1024x0_resize_box_3.png 1024w" loading=lazy alt="데이터를 영속적으로 보관하는 흐름" class=gallery-image data-flex-grow=217 data-flex-basis=522px></p><ol><li>API 서비스는 객체 데이터를 데이터 저장소로 포워딩한다.</li><li>데이터 라우팅 서비스는 해당 객체에 UUID를 할당하고 배치 서비스에 해당 객체를 보관할 데이터 노드를 질의한다.<ul><li>배치 서비스는 가상 클러스터 지도를 확인하여 데이터를 보관할 주 데이터 노드를 반환한다.</li></ul></li><li>데이터 라우팅 서비스는 저장할 데이터를 UUID와 함께 주 데이터 노드에 직접 전송한다.</li><li>주 데이터 노드는 데이터를 자기 노드에 지격적으로 저장하면서 두 개의 부 데이터 노드에 다중화한다.<ul><li>주 데이터 노드는 데이터를 모든 부 데이터 노드에 성공적으로 다중화하고 나면 데이터 라우팅 서비스에 응답을 보낸다.</li></ul></li><li>객체의 UUID(객체 ID)를 API 서비스에 반환한다.</li></ol><p>2단계는 배치 서비스에 UUID를 입력으로 주고 질의하면 해당 객체에 대한 <strong>다중화 그룹</strong>이 반환된다는 뜻이다.</p><ul><li>계산 결과는 결정적(deterministric)이어야 한다.</li><li>다중화 그룹이 추가되거나 삭제되는 경우에도 유지되어야 한다.</li><li>안정해시를 주로 사용한다.</li></ul><p>4단계는 응답을 반환하기 전 데이터를 모든 부 노드에 다중화하여 모든 데이터 노드에 강력한 데이터 일관성을 보장한다.</p><ul><li>가장 느린 사본에 대한 작업이 완료될 때까지 응답을 반환하지 못하므로, 지연 시간 측면에서는 손해이다.</li></ul><hr><p><strong>데이터 일관성과 지연 시간의 관계</strong></p><p><img src=/post/system-design-interview-2/9/img_10.png width=1548 height=1152 srcset="/post/system-design-interview-2/9/img_10_hu9ec2670cad1863e2491411118c330729_153472_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_10_hu9ec2670cad1863e2491411118c330729_153472_1024x0_resize_box_3.png 1024w" loading=lazy alt="데이터 일관성과 지연 시간 사이의 타협적 관계" class=gallery-image data-flex-grow=134 data-flex-basis=322px></p><ol><li>데이터를 세 노드에 전부 보관하면 성공적으로 보관하였다고 간주<ul><li>데이터 일관성 측면에서는 최선이지만 응답 지연은 가장 높다.</li></ul></li><li>데이터르 주 데이터 및 두 개 부 노드 가운데 하나에 성공적으로 보관하면 성공적으로 저장하였다고 간주<ul><li>중간 정도의 데이터 일관성 및 응답 지연을 제공</li></ul></li><li>데이터를 주 데이터에 보관하고 나면 성공적으로 저장했다고 간주<ul><li>데이터 일관성 측면에서는 최악이지만 응답 지연은 가장 낮다.</li></ul></li></ol><p>2, 3은 모두 <strong>결과적 일관성</strong>(eventual consistency)의 한 형태로 볼 수 있다.</p><h3 id=데이터는-어떻게-저장되는가>데이터는 어떻게 저장되는가</h3><p>가장 단순한 방안은 각각의 객체를 개별 파일로 저장하는 것 이지만 작은 파일이 많아지면 성능이 떨어진다.</p><ul><li>낭비되는 데이터 블록 수가 늘어난다.<ul><li>파일 시스템은 보통 4KB의 디스크 블록으로 파일을 저장하는데 크기가 작아도 하나의 블록을 모두 사용한다.</li></ul></li><li>시스템의 아이노드(inode) 용량 한계를 초과할 수 있다.<ul><li>사용 가능한 아이노드 수는 디스크가 초기화 되는 순간 결정되고, 작은 파일의 수가 매우 많아지면 전부 소진될 수 있다.</li></ul></li><li>파일 시스템 메타데이터를 공격적으로 캐싱하는 전략을 취하더라도 아주 많은 양의 아이노드를 효과적으로 처리하지 못한다.</li></ul><p>따라서 작은 객체를 개별 파일 형태로 저장하는 방안은 현실에서는 쓸모없으며, 작은 객체들을 큰 파일 하나로 모아서 처리해야한다.</p><ul><li>개념적으로는 WAL(Write-Ahead Log)와 같이 객체를 저장할 때 이미 존재하는 파일에 추가하는 방식</li><li>용량 임계치에 도달한 파일(보통 수 GB)은 읽기 전용 파일로 변경하고 새로운 파일을 만든다.</li></ul><p><img src=/post/system-design-interview-2/9/img_11.png width=1644 height=1068 srcset="/post/system-design-interview-2/9/img_11_hu8ca19c5a46cc9441fdf4a4e9249e00d6_63670_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_11_hu8ca19c5a46cc9441fdf4a4e9249e00d6_63670_1024x0_resize_box_3.png 1024w" loading=lazy alt="작은 객체들을 한 파일에 저장하는 방안" class=gallery-image data-flex-grow=153 data-flex-basis=369px></p><ul><li>읽기-쓰기 파일에 대한 쓰기 연산은 순차적으로 이루어져야 함</li><li>객체는 파일에 일렬로 저장됨</li><li>여러 CPU 코어가 쓰기 연산을 병렬로 진행하더라도 객체 내용이 뒤섞이면 안된다.<ul><li>파일에 객체를 기록하기 위해 순서를 기다려야 한다.</li><li>쓰기 대역폭이 심각하게 줄어들기 때문에 서버에 오는 요청을 처리하는 코어별로 전담 읽기-쓰기 파일을 두는 것이 좋다.</li></ul></li></ul><h3 id=객체-소재-확인>객체 소재 확인</h3><p>각각의 데이터 파일 안에 많은 작은 객체가 들어 있다면 데이터노드가 UUID로 객체를 찾기 위해 다음 정보가 필요하다.</p><ul><li>객체가 보관된 데이터 파일</li><li>데이터 파일 내 객체 오프셋</li><li>객체 크기</li></ul><pre class=mermaid style=text-align:center>classDiagram
    class object_mapping {
        object_id
        file_name
        start_offset
        object_size
    }
</pre><p>이 정보를 저장하는 데 두 가지 방법이 있다.</p><ul><li>파일 기반 키-값 저장소(ex. RocksDB)<ul><li>SSTable에 기반한 방법으로 쓰기 연산 성능은 좋지만 읽기 성능은 느리다.</li></ul></li><li>관계형 데이터베이스<ul><li>B+ 트리 기반 저장 엔진을 이용하며 읽기 연산 성능은 좋지만 쓰기 성능은 느리다.</li></ul></li></ul><p>객체 저장소의 데이터는 한 번 기록된 후에는 변경되지 않고, 읽기 연산이 매우 많이 발생하므로 읽기 연산 성능이 좋은 관계형 데이터베이스가 더 나은 선택이다.</p><hr><p>객체 위치를 저장하는 테이블의 데이터 양은 막대하므로, 하나의 거대 클러스터에 모든 데이터 노드를 저장하는 방안도 가능하지만 관리가 까다롭다.</p><p>하지만 데이터 노드에 저장되는 위치 데이터를 다른 데이터 노드와 공유할 필요가 없기 때문에 데이터 노드마다 관계형 데이터베이스를 설치하는 방안이 가능하다.</p><ul><li>SQLite는 이런 경우 딱 만는 파일 기반 관계형 데이터베이스이다.</li></ul><h3 id=개선된-데이터-저장-흐름>개선된 데이터 저장 흐름</h3><p><img src=/post/system-design-interview-2/9/img_12.png width=1824 height=1032 srcset="/post/system-design-interview-2/9/img_12_hu427877cf20e851a8fff9b8e8fd5c331f_120715_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_12_hu427877cf20e851a8fff9b8e8fd5c331f_120715_1024x0_resize_box_3.png 1024w" loading=lazy alt=img_12.png class=gallery-image data-flex-grow=176 data-flex-basis=424px></p><ol><li>API 서비스는 새로운 객체를 저장하는 요청을 데이터 노드 서비스에 전송한다.</li><li>데이터 노드 서비스는 새로운 객체를 읽기-쓰기 파일 <code>/data/c</code>의 마지막 부분에 추가한다.</li><li>해당 객체에 대한 새로운 레코드를 <code>object_mapping</code> 테이블에 추가한다.</li><li>데이터 노드 서비스는 API 서비스에 해당 객체의 UUID를 반환한다.</li></ol><h3 id=데이터-내구성>데이터 내구성</h3><p>데이터 안정성은 데이터 저장 시스템에 아주 중요하다.</p><p>식스 나인 수준의 데이터 내구성을 제공하는 저장소 시스템을 만들려면 장애가 발생할 모든 경우를 세심하게 살핀 다음 데이터를 적절히 다중화해야한다.</p><hr><p><strong>하드웨어 장애와 장애 도메인</strong></p><p>기록 매체 종류와 관계없이, 하드 디스크 장애는 필할 수 없기 때문에 드라이브 한 대로 원하는 내구성 목표를 달성 불가능하다.</p><p>내구성을 높이는 검증된 방법은 <strong>데이터를 여러 대의 하드 드라이브에 복제하여 어떤 드라이브에서 발생한 장애가 전체 데이터 가용성에 영향을 주지 않도록 하는 것</strong> 이다.</p><p>본 설계안에서는 데이터를 3중 복제 한다.</p><ul><li>회전식 드라이브 연간 장애율이 0.81%라면 3중 복제했을 때 내구성은 <code>1 - 0.0081^3 = ~0.999999</code> 이다.</li></ul><p>완전한 내구성 평가를 위해서는 여러 장애 도메인의 영향을 복합적으로 고려할 필요가 있다.</p><blockquote><p><strong>장애 도매인</strong><br>중요한 서비스에 문제가 발생했을 때 부정적인 영향을 받는 물리적 또는 논리적 구획</p></blockquote><p>대규모의 장애 도메인 사례로는 데이터센터의 가용성 구역(Availability Zone, AZ)가 있다.(다른 데이터센터와 물리적 인프라를 공유하지 않는 독립적 데이터센터 하나)</p><p><img src=/post/system-design-interview-2/9/img_13.png width=1652 height=1148 srcset="/post/system-design-interview-2/9/img_13_hudb8ff539c5bf2674cee737d5db0dd958_73597_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_13_hudb8ff539c5bf2674cee737d5db0dd958_73597_1024x0_resize_box_3.png 1024w" loading=lazy alt="여러 데이터센터를 활용한 데이터 다중화" class=gallery-image data-flex-grow=143 data-flex-basis=345px></p><p>데이터를 여러 AZ에 복제해 놓으면 장애 여파를 최소화할 수 있다.</p><hr><p><strong>소거 코드</strong></p><p>소거 코드(erasure coding)라는 방안으로 내구성을 달성하는 방안도 고려할 수 있다.</p><p>데이터를 작은 단위로 분할하여 다른 서버에 배치하는 한편, 그 가운데 일부가 소실되었을 때 복구하기 위한 패리티(parity)라는 정보를 만들어 중복성(redundancy)를 확보한다.</p><p><img src=/post/system-design-interview-2/9/img_14.png width=1342 height=918 srcset="/post/system-design-interview-2/9/img_14_hu836aad3383e3c48a234e9d0f35991e7d_87832_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_14_hu836aad3383e3c48a234e9d0f35991e7d_87832_1024x0_resize_box_3.png 1024w" loading=lazy alt="4+2 소거 코드를 통한 데이터 복구" class=gallery-image data-flex-grow=146 data-flex-basis=350px></p><p>장애가 생기면 남은 데이터와 패리티를 조합하여 소실된 부분을 복구한다.</p><p><img src=/post/system-design-interview-2/9/img_15.png width=1396 height=1394 srcset="/post/system-design-interview-2/9/img_15_hub4ff7f8e2f435a2e0b557649a977f288_176307_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_15_hub4ff7f8e2f435a2e0b557649a977f288_176307_1024x0_resize_box_3.png 1024w" loading=lazy alt="8+4 소거 코드" class=gallery-image data-flex-grow=100 data-flex-basis=240px></p><ul><li>원본 데이터는 8조각으로 분할하고 4개의 패리티를 계산</li><li>그 결과로 만들어진 12조각의 데이터는 전부 같은 크기로, 12개의 장애 도메인에 분산</li></ul><p>소거 코드 이며느이 수식으로 최대 4대 노드에 장애가 동시에 발생하더라도 원본 데이터를 복원해 낼 수 있다.</p><p>데이터를 다중화 할 경우 데이터 라우터는 객체 데이터를 하나의 건강한 노드에서 읽으면 충분하겠지만 소거 코드를 사용하면 최대 8개의 건강한 노드에서 데이터를 가져와야 한다.</p><ul><li>응답 지연은 높아지는 대신 내구성은 향상되고 저장소 비용은 낮아진다.</li><li>객체 저장소는 저장 비용이 대부분이어서 고려할 가치가 있다.<ul><li>소거 코드를 사용하면 2개 데이터 블록에 하나의 패리티 블록이 필요하므로 저장 공간이 50% 더 필요하다.</li><li>3중 복제 다중화 방안을 채택한다면 200%</li></ul></li></ul><p><img src=/post/system-design-interview-2/9/img_16.png width=1100 height=822 srcset="/post/system-design-interview-2/9/img_16_hu2a647937338907523b8691a4543fbf22_49675_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_16_hu2a647937338907523b8691a4543fbf22_49675_1024x0_resize_box_3.png 1024w" loading=lazy alt="유형 별 요구하는 추가 용량" class=gallery-image data-flex-grow=133 data-flex-basis=321px></p><p>소거 코드를 사용하면 노드의 연산 장애 발생률이 0.81%라고 했을 때 11 나인 내구성을 달성할 수 있다.</p><hr><p><strong>비교</strong></p><div class=table-wrapper><table><thead><tr><th></th><th>다중화</th><th>소거 코드</th></tr></thead><tbody><tr><td>내구성</td><td>3중 복제시 4-nines</td><td>8+4 소거 코드 사용시 11-nines</td></tr><tr><td>저장소 효율성</td><td>200% 오버헤드</td><td>50%의 오버헤드</td></tr><tr><td>계산 자원</td><td>계산이 필요없음</td><td>패리티 계산에 많은 계산 자원 소모</td></tr><tr><td>쓰기 성능</td><td>데이터를 여러 노드에 복제하므로 추가로 필요한 계산은 없음</td><td>데이터를 디스크에 기록하기 전에 패리티 계산이 필요하므로 쓰기 연산의 응답 지연 증가</td></tr><tr><td>읽기 성능</td><td>장애가 발생하지 않은 노드에서 데이터를 읽음</td><td>데이터를 읽어야할 때마다 클러스터 내의 여러 노드에서 데이터를 가져와야 함. 장애가 발생한 경우 빠진 데이터를 먼저 복원해야하므로 지연 시간 증가</td></tr></tbody></table></div><ul><li>응답 지연이 중요한 애플리케이션에서는 다중화 방안이 좋을 수 있다.</li><li>저장소 비용이 중요한 애플리케이션에서는 소거 코드가 좋을 수 있다.</li></ul><p>소거 코드는 비용 효율과 내구성 측면에서 매력적이지만 데이터 노드의 설계 측면에서는 까다롭다.</p><h3 id=정확성-검증>정확성 검증</h3><p>대규모 시스템의 경우 데이터 훼손 문제는 디스크에 국한되지 않고, 메모리의 데이터가 망가지는 일도 자주 일어난다.</p><p>메모리 데이터가 훼손되는 문제는 프로세스 경계에 데이터 검증을 위한 체크섬을 두어 해결할 수 있다.</p><blockquote><p><strong>체크섬</strong><br>데이터 에러를 발견하는 데 사용되는 작은 크기의 데이터 블록</p></blockquote><p>원본 데이터의 체크섬을 알면 전송 받은 데이터의 정확성은 해당 데이터의 체크섬을 다시 계산한 후 다음과 절차로 확인한다.</p><ul><li>새로 계산한 체크 섬이 원본 체크섬과 다르면 데이터가 만가진 것이다.</li><li>같은 경우에는 아주 높은 확률로 데이터는 온전하다고 볼 수 있다.<ul><li>100%는 아니지만 아주 낮다.</li></ul></li></ul><p>좋은 체크섬 알고리즘은 입력이 조금이라도 달라지면 크게 달라진 체크섬을 내놓는다.</p><p><img src=/post/system-design-interview-2/9/img_17.png width=1392 height=1238 srcset="/post/system-design-interview-2/9/img_17_hu1a5439a4a88930d5116191c16c7bcf73_86242_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_17_hu1a5439a4a88930d5116191c16c7bcf73_86242_1024x0_resize_box_3.png 1024w" loading=lazy alt="데이터 노드에 체크섬 추가" class=gallery-image data-flex-grow=112 data-flex-basis=269px></p><p>체크섬은 객체 데이터 끝에 두며, 파일을 읽기 전용으로 전환하기 직전에 전체 파일의 체크섬을 계산한 후 파일 끝에 추가한다.</p><hr><p>(8 + 4) 소거 코드와 체크섬 확인 매커니즘을 동시에 활용하는 경우 객체 데이터를 읽을 때마다 다음 절차를 수행한다.</p><ol><li>객체 데이터와 체크섬을 가져온다.</li><li>수신된 데이터의 체크섬을 계산한다.<ol><li>두 체크섬이 일치하면 데이터에는 에러가 없다고 간주한다.</li><li>체크섬이 다르면 망가진 것 이므로 다른 장애 도메인에서 데이터를 가져와 복구를 시도한다.</li></ol></li><li>데이터 8조각을 전부 수신할 때 까지 1과 2를 반복한 후, 원래 객체를 복원한 다음 클라이언트에게 보낸다.</li></ol><h3 id=메타데이터-데이터-모델>메타데이터 데이터 모델</h3><p><strong>스키마</strong></p><p><img src=/post/system-design-interview-2/9/img_18.png width=1142 height=406 srcset="/post/system-design-interview-2/9/img_18_hu1b891d9c3dfed1d4ce48f3ad5689625e_77413_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_18_hu1b891d9c3dfed1d4ce48f3ad5689625e_77413_1024x0_resize_box_3.png 1024w" loading=lazy alt="메타데이터 데이터베이스 스키마" class=gallery-image data-flex-grow=281 data-flex-basis=675px></p><p>이 데이터베이스 스키마는 다음 3가지 질의를 지원해야한다.</p><ul><li>객체 이름으로 객체 ID 찾기</li><li>객체 이름에 기반하여 객체 삽입 또는 삭제</li><li>같은 접두어를 갖는 버킷 내의 모든 객체 목록 확인</li></ul><hr><p><strong>bucket 테이블 규모 확장</strong></p><p>보통 한 사용자가 만들 수 있는 버킷의 수에는 제한이 있으므로, 테이블의 크기는 작기 때문에 최신 데이터베이스 서버 한 대에 충분히 저장할 수 있다.</p><ul><li>백만명 고객이 10개의 버킷을 가지고 있고, 레코드가 10KB라면 10GB 정도 필요함</li></ul><p>하지만 모든 읽기 요청을 처리하기에는 CPU 용량이나 네트워크 대역폭이 부족할 수 있으므로, 데이터베이스 사본을 만들어 읽기 부하를 분산한다.</p><hr><p><strong>object 테이블의 규모 확장</strong></p><p><code>object</code> 테이블에는 객체 메타데이터가 보관되는데, 설계안이 다루는 규모의 경우 객체 메타데이터를 데이터베이스 서버 한 대에 보관하기는 불가능하므로 샤딩을 통해 확장해야한다.</p><ul><li>테이블을 샤딩할 때 <code>bucket_id</code>을 샤딩키로 사용하게되면, 핫스팟 샤드를 지원하지 못하므로 좋은 방안은 아니다.</li><li><code>object_id</code>를 기준으로 샤딩하면 부하를 균등하게 분산할 수는 있지만 URI를 기준으로 동작하는 질의 1, 2를 효율적으로 지원하지 못한다.</li></ul><p>대부분의 메타데이터 관련 연산이 객체 URI를 기준으로 하는 특성을 고려하여 <code>bucket_name</code>과 <code>object_name</code>을 결합하여 샤딩에 사용한다.</p><ul><li><code>bucket_name</code>과 데이터를 균등하게 분산하기위해 <code>object_name</code>의 순서쌍을 해싱한 값을 샤딩키로 사용한다.</li></ul><h3 id=버킷-내-객체-목록-확인>버킷 내 객체 목록 확인</h3><p>객체 저장소는 객체를 파일 시스템처럼 계층적 구조로 보관하지 않는다.</p><p><code>s3://mybucket/abc/d/e/f/file.txt</code>와 같은 경로가 있다면</p><ul><li><code>mybucket</code>은 버킷 이름</li><li><code>abc/d/e/f/file.txt</code>는 파일 이름</li></ul><p>S3는 사용자가 버킷 내 객체들을 잘 정리할 수 있도록 <strong>접두어</strong>(prefix)라는 개념을 지원한다.</p><p>접두어는 객체 이름의 시작 부분 문자열을 일컫는데, 잘 사용한다면 디렉터리와 비슷하게 데이터를 잘 정리할 수 있다.</p><p>하지만 접두어는 디렉터리가 아니므로 어떤 접두어에 대응되는 객체 목록을 얻으려 하면 오직 해당 접두어로 시작하는 이름의 객체만 반환될 것이다.</p><ul><li><code>s3://mybucket/abc/d/e/f/file.txt</code>의 접두어는 <code>abc/d/e/f</code></li></ul><p>S3가 제공하는 목록 출력 명령어는 보통 다음과 같이 쓰인다.</p><ul><li>어떤 사용자가 가진 모든 버킷 목록 출력<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>aws s3 list-buckets
</span></span></code></pre></td></tr></table></div></div></li><li>주어진 접두어를 가진 같은 버킷 내 모든 객체 목록 출력<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>aws s3 ls s3://mybucket/abc/
</span></span></code></pre></td></tr></table></div></div></li><li>주어진 접두어를 가진, 같은 버킷 내 모든 객체를 재귀적으로 출력<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>aws s3 ls s3://mybucket/abc/ --recursive
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=단일-데이터베이스-서버>단일 데이터베이스 서버</h3><p>단일 데이터베이스 서버로 목록 출력 명령어를 어떻게 지원하는지 살펴본다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=k>object</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>bucket_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>123</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>AND</span><span class=w> </span><span class=n>object_name</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=o>`</span><span class=n>abc</span><span class=o>/%`</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>목록 출력 명령어의 두번째 명령과 같이 해당 접두어 이후에 더 많은 샐래시 기호가 포함된 이름을 가진 객체들을 디렉터리처럼 보이도록 묶는 작업은 애플리케이션에서 담당한다.</p><h3 id=분산-데이터베이스>분산 데이터베이스</h3><p>메타데이터 테이블을 샤딩하면 어떤 샤드에 데이터가 있는지 모르므로 목록 출력 기능을 구현하기 어렵다.</p><p>가장 단순한 해결책은 검색 질의를 모든 샤드에 돌린 다음 결과를 취합하는 것 이지만 페이지 나눔(pagination) 기능을 구현하기 복잡하다.</p><p>객체가 여러 샤드에 나눠져 있으므로, 샤드마다 반호나하는 객체 수는 제각각이다.</p><ul><li>어떤 샤드에는 한 페이지를 꽉 채울 객체가 있을 수 있지만, 적거나 없는 샤드도 있을 수 있다.</li></ul><p>애플리케이션 코드는 모든 샤드의 질의 결과를 받아 취합한 다음 정렬하여 그중 10개만 추려야한다.</p><ul><li>이번에 반환할 페이지에 포함되지 못한 객체는 다음에 다시 고려해야하므로, 샤드마다 추적해야하는 오프셋이 달라질 수 있다.</li></ul><p>따라서 서버는 모든 샤드의 오프셋을 추적하여 커서에 결부시킬수 있어야 하므로 관리가 어려워진다.</p><p>이 문제를 해결할 방법은 있으나 객체 저장소는 규모와 내구성 최적화에 치중하고, 객체 목록 출력 명령의 성능을 보장하는 것은 우선순위가 낮다.</p><p>그 사실을 감안하여 버킷 ID로 샤딩하는 별도 테이블에 목록 데이터를 비정규화할 수 있다.</p><ul><li>객체 목록을 출력할 때는 이 테이블에 있는 데이터만 사용한다.</li><li>목록 질의문을 한 대의 데이터베이스 서버로 돌릴 수 있으므로, 구현을 단순하게 만들 수 있다.</li></ul><h3 id=객체-버전>객체 버전</h3><p>객체 버전은 버킷 안에 한 객체의 여러 버전을 둘 수 있도록 하는 기능으로 실수로 지우거나 덮어 쓴 객체를 쉽게 복구할 수 있다.</p><p>문서를 수정한 다음 같은 버킷 안에 같은 이름으로 저장했다면</p><ul><li>버전 기능이 없으면<ul><li>해당 문서의 이전 메타데이터는 새 메타데이터로 완전히 대체된다.</li><li>이전 문서는 삭제된 것으로 표시되고, 쓰레기 수집기가 회수한다.</li></ul></li><li>버전 기능이 있으면<ul><li>객체 저장소는 해당 문서의 모든 이전 버전을 메타데이터 저장소에 유지한다.</li><li>이전 버전에 삭제 표시를 할 수 있다(안해도 된다.)</li></ul></li></ul><hr><p><strong>버전이 다른 객체 업로드</strong></p><p><img src=/post/system-design-interview-2/9/img_19.png width=1844 height=858 srcset="/post/system-design-interview-2/9/img_19_hu63377921f525c42971966f2d10821269_90319_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_19_hu63377921f525c42971966f2d10821269_90319_1024x0_resize_box_3.png 1024w" loading=lazy alt="메타데이터와 버전 정보" class=gallery-image data-flex-grow=214 data-flex-basis=515px></p><p>버전 기능을 지원하기 위해 메타데이터 저장소의 객체 테이블에는 <code>object_version</code>이라는 컬럼이 있고, 버전 기능이 활성화 되었을 경우에만 사용한다.</p><ul><li>기존 레코드를 덮어쓰는 대신, <code>bucket_id</code>, <code>object_name</code>은 같지만 <code>object_id</code>, <code>object_version</code>은 새로운 값인 레코드를 추가한다.<ul><li><code>object_id</code>: 새 객체의 UUID</li><li><code>object_version</code>: 새로운 레코드가 테이블에 추가될 때 만들어지는 TIMEUUID 값</li></ul></li></ul><p>메타데이터 저장소로 어떤 데이터베이스를 선택하건, 특정 객체의 현재 버전을 조회하는 연산은 효과적으로 처리될 수 있어야 한다.</p><hr><p><strong>객체 삭제</strong></p><p><img src=/post/system-design-interview-2/9/img_20.png width=1850 height=896 srcset="/post/system-design-interview-2/9/img_20_hu154db864fa60cf04595279bac743b9f1_103831_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_20_hu154db864fa60cf04595279bac743b9f1_103831_1024x0_resize_box_3.png 1024w" loading=lazy alt="삭제 표식 삽입을 통한 객체 삭제" class=gallery-image data-flex-grow=206 data-flex-basis=495px></p><p>객체를 삭제할 때는 해당 객체의 모든 버전을 버킷 안에 그대로 둔 채 삭제 표식만 추가한다.</p><p>삭제 표식은 객체의 새로운 버전으로 삽입되는 순간 해당 <strong>객체의 새로운 현재 버전</strong>이 된다.</p><ul><li>현재 버전 객체(삭제된 버전)를 가져오는 <code>GET</code> 요청은 보내면 <code>404 Object Not Found</code> 오류가 반환된다.</li></ul><h3 id=큰-파일의-업로드-성능-최적화>큰 파일의 업로드 성능 최적화</h3><p>큰 파일(몇 GB 이상)을벜닛에 직접 업로드하는 것도 가능은 하지만 시간이 매우 오래 걸릴 것이다.</p><p>업로드 중간 네트워크 문제가 생기면 다시 업로드 해야한다는 문제도 있다.</p><p>따라서 큰 객체는 작게 쪼갠 다음 독립적으로 업로드하는 것이 더 나은 방법이다.</p><blockquote><p><strong>멀티파트(multipart) 업로드</strong><br>크기가 큰 대상을 쪼개 독립적으로 업로드한 후 모든 조각이 업로드되면 그 조각을 모아 원본을 복원하는 방법</p></blockquote><p><img src=/post/system-design-interview-2/9/img_21.png width=1210 height=1414 srcset="/post/system-design-interview-2/9/img_21_hu9bfa49f24a5be20edd7d8c375a3b17ab_94328_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_21_hu9bfa49f24a5be20edd7d8c375a3b17ab_94328_1024x0_resize_box_3.png 1024w" loading=lazy alt="멀티파트 업로드" class=gallery-image data-flex-grow=85 data-flex-basis=205px></p><p>객체 조립이 끝난 뒤에는 조각들은 더이상 쓸모가 없어지므로 이러한 조각을 삭제하여 저장 용량을 확보하는 쓰레기 수집 프로세스를 구현할 필요가 있을 수 있다.</p><h3 id=쓰레기-수집>쓰레기 수집</h3><p>쓰레기 수집(garbage collection)은 더 이상 사용되지 않는 데이터에 할당된 저장 공간을 자동으로 회수하는 절차이다.</p><p>본 시스템은 다음과 같은 경우 쓰레기 데이터가 생길 수 있다.</p><ul><li>객체의 지연된 삭제(lazy object deletion)<ul><li>삭제했다고 표시는 하지만 실제로 지우지는 않는다.</li></ul></li><li>갈 곳 없는 데이터(orphaned data)<ul><li>반쯤 업로드된 데이터, 또는 취소된 멀티 파트 업로드 데이터</li></ul></li><li>훼손된 데이터(corrupted data)<ul><li>체크섬 검사에 실패한 데이터</li></ul></li></ul><p>쓰레기 수집기는 객체를 데이터 저장소에 바로 지우지 않고 정리(compaction) 메커니즘을 주기적으로 실행하여 지운다.</p><p>쓰레기 수집기는 사용되지 않는 사본에 할당된 저장 공간을 회수하는 역할도 담당한다.</p><ul><li>데이터를 다중화하는 경우 객체는 주 저장소 노드에서 뿐 아니라 부 저장소 노드에서도 지워야 한다.</li><li>(8+2) 소거 코드를 사용하는 경우 12개 노드에서 전부 지워야한다.</li></ul><p><img src=/post/system-design-interview-2/9/img_22.png width=1650 height=1344 srcset="/post/system-design-interview-2/9/img_22_hu27b10be6477e1cda4b354626a6189f79_110941_480x0_resize_box_3.png 480w, /post/system-design-interview-2/9/img_22_hu27b10be6477e1cda4b354626a6189f79_110941_1024x0_resize_box_3.png 1024w" loading=lazy alt="쓰레기 수집기 정리 메커니즘" class=gallery-image data-flex-grow=122 data-flex-basis=294px></p><ol><li>쓰레기 수집기는 <code>/data/b</code>의 객체를 <code>/data/d</code>로 복사한다.</li><li>모든 객체를 복사한 다음 <code>object_mapping</code> 테이블을 갱신한다.<ul><li>객체 3의 경우 <code>file_name</code>과 <code>start_offset</code> 값은 새 위치를 가리키도록 수정된다.</li><li>데이터 일관성을 위해 같은 트랜잭션 안에서 연산을 수행하는 것이 바람직하다.</li></ul></li></ol><p>정리 후 새 파일의 크기는 종전보다 작다.</p><p>작은 파일을 많이 만들지 않기 위해 쓰레기 수집기는 보통 압출할 읽기 전용 파일이 많아질 때가지 기다리며, 압축을 진행하면서 여러 읽기 전용 파일에 기록된 객체를 하나의 파일로 모은다.</p><h2 id=4단계-마무리>4단계: 마무리</h2><ul><li>블록 저장소, 파일 저장소, 객체 저장소의 차이</li><li>객체 업로드, 다운로드, 버킷 내 객체 목록 표시, 객체 버전 등의 기능의 구현</li><li>데이터 저장소와 메타데이터 저장소 구현</li><li>데이터 저장소에 어떻게 영속적으로 저장되는지</li><li>데이터 안정성과 내구성을 높이는 두 가지 방안(다중화, 소거 코드)</li><li>멀티파트 업로드</li><li>쓰레기 수집 장법</li></ul></section><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
</script><footer class=article-footer><section class=article-tags><a href=/tags/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/>가상 면접 사례로 배우는 대규모 시스템 설계 기초</a>
<a href=/tags/system-design-interview/>System Design Interview</a>
<a href=/tags/s3/>S3</a>
<a href=/tags/simple-storage-service/>Simple Storage Service</a>
<a href=/tags/amazon-web-service/>Amazon Web Service</a>
<a href=/tags/aws/>AWS</a>
<a href=/tags/restful-api/>Restful API</a>
<a href=/tags/storage-system/>Storage System</a>
<a href=/tags/%EC%A0%80%EC%9E%A5%EC%86%8C-%EC%8B%9C%EC%8A%A4%ED%85%9C/>저장소 시스템</a>
<a href=/tags/%EB%B8%94%EB%A1%9D-%EC%A0%80%EC%9E%A5%EC%86%8C/>블록 저장소</a>
<a href=/tags/block-storage/>Block Storage</a>
<a href=/tags/%ED%8C%8C%EC%9D%BC-%EC%A0%80%EC%9E%A5%EC%86%8C/>파일 저장소</a>
<a href=/tags/file-storage/>File Storage</a>
<a href=/tags/%EA%B0%9D%EC%B2%B4-%EC%A0%80%EC%9E%A5%EC%86%8C/>객체 저장소</a>
<a href=/tags/object-storage/>Object Storage</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><div class="article-list--compact links"><article><a href=https://product.kyobobook.co.kr/detail/S000211656186 target=_blank rel=noopener><div class=article-details><h2 class=article-title>가상 면접 사례로 배우는 대규모 시스템 설계 기초 2</h2><footer class=article-time>교보문고</footer></div></a></article></div><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/post/system-design-interview-2/13/><div class=article-image><img src=/post/system-design-interview-2/13/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 13. 증권 거래소" data-key=system-design-interview-2/13 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>13. 증권 거래소</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/12/><div class=article-image><img src=/post/system-design-interview-2/12/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 12. 전자 지갑" data-key=system-design-interview-2/12 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>12. 전자 지갑</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/11/><div class=article-image><img src=/post/system-design-interview-2/11/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 11. 결제 시스템" data-key=system-design-interview-2/11 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>11. 결제 시스템</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/10/><div class=article-image><img src=/post/system-design-interview-2/10/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 10. 실시간 게임 순위표" data-key=system-design-interview-2/10 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>10. 실시간 게임 순위표</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/8/><div class=article-image><img src=/post/system-design-interview-2/8/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 8. 분산 메일 서비스" data-key=system-design-interview-2/8 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>8. 분산 메일 서비스</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=codemario318/codemario318.github.io issue-term=pathname label=Comment crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2023 -
2024 Mario Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>