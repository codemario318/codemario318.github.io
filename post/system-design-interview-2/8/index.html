<!doctype html><html lang=ko dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="가상 면접 사례로 배우는 대규모 시스템 설계 기초 2"><title>8. 분산 메일 서비스</title><link rel=canonical href=https://codemario318.github.io/post/system-design-interview-2/8/><link rel=stylesheet href=/scss/style.min.cbce94e2760d14d60414e59d5a36ab2819232375817e010dbe7be2234b67da1b.css><meta property="og:title" content="8. 분산 메일 서비스"><meta property="og:description" content="가상 면접 사례로 배우는 대규모 시스템 설계 기초 2"><meta property="og:url" content="https://codemario318.github.io/post/system-design-interview-2/8/"><meta property="og:site_name" content="Mario Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="가상 면접 사례로 배우는 대규모 시스템 설계 기초"><meta property="article:tag" content="System Design Interview"><meta property="article:tag" content="MSA"><meta property="article:tag" content="Micro Service Architecture"><meta property="article:tag" content="RDBMS"><meta property="article:tag" content="Relational Database System"><meta property="article:published_time" content="2024-10-23T13:53:50+09:00"><meta property="article:modified_time" content="2024-10-23T13:53:50+09:00"><meta property="og:image" content="https://codemario318.github.io/post/system-design-interview-2/8/cover.png"><meta name=twitter:title content="8. 분산 메일 서비스"><meta name=twitter:description content="가상 면접 사례로 배우는 대규모 시스템 설계 기초 2"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://codemario318.github.io/post/system-design-interview-2/8/cover.png"><script async src="https://www.googletagmanager.com/gtag/js?id=G-K99591YLGK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K99591YLGK",{anonymize_ip:!1})}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3183752545292673" crossorigin=anonymous></script><meta name=naver-site-verification content="2315bde85c86f66092140cc465c340a2170f3187"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu760fd15c5fbb2f30cf0868dc4a5dc41a_14271_300x0_resize_q75_box.jpeg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Mario Blog</a></h1><h2 class=site-description></h2></div></header><ol class=social-menu><li><a href=https://github.com/codemario318 target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><ul class="menu sub-menu"><li><a href=/categories/backend/><span>Backend</span>
<span class=content-count>3</span></a></li><li><a href=/categories/boostcamp/><span>부스트캠프</span>
<span class=content-count>11</span></a></li><li><a href=/categories/cleancode/><span>Clean Code</span>
<span class=content-count>10</span></a></li><li><a href=/categories/common/><span>Common</span>
<span class=content-count>76</span></a></li><li><a href=/categories/data/><span>Data</span>
<span class=content-count>3</span></a></li><li><a href=/categories/db/><span>DB</span>
<span class=content-count>1</span></a></li><li><a href=/categories/frontend/><span>Frontend</span>
<span class=content-count>10</span></a></li><li><a href=/categories/golang/><span>GoLang</span>
<span class=content-count>13</span></a></li><li><a href=/categories/headfirstdesignpatterns/><span>헤드 퍼스트 디자인 패턴</span>
<span class=content-count>22</span></a></li><li><a href=/categories/infra/><span>Infra</span>
<span class=content-count>14</span></a></li><li><a href=/categories/nest/><span>Nest</span>
<span class=content-count>1</span></a></li><li><a href=/categories/network/><span>네트워크</span>
<span class=content-count>1</span></a></li><li><a href=/categories/node/><span>Node</span>
<span class=content-count>6</span></a></li><li><a href=/categories/others/><span>Others</span>
<span class=content-count>2</span></a></li><li><a href=/categories/problemsolving/><span>Problem Solving</span>
<span class=content-count>1</span></a></li><li><a href=/categories/project/><span>Project</span>
<span class=content-count>5</span></a></li><li><a href=/categories/realmysql/><span>Real MySQL</span>
<span class=content-count>53</span></a></li></ul><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#1단계-문제-이해-및-설계-범위-확정>1단계: 문제 이해 및 설계 범위 확정</a><ol><li><a href=#비기능적-요구사항>비기능적 요구사항</a></li><li><a href=#개략적인-규모-추정>개략적인 규모 추정</a></li></ol></li><li><a href=#2단계-개략적-설계안-제시-및-동의-구하기>2단계: 개략적 설계안 제시 및 동의 구하기</a><ol><li><a href=#이메일-101>이메일 101</a><ol><li><a href=#이메일-프로토콜>이메일 프로토콜</a></li><li><a href=#dns---도메인-이름-서비스>DNS - 도메인 이름 서비스</a></li><li><a href=#첨부-파일>첨부 파일</a></li><li><a href=#전통적-메일-서버>전통적 메일 서버</a></li></ol></li><li><a href=#분산-메일-서버>분산 메일 서버</a><ol><li><a href=#이메일-api>이메일 API</a></li><li><a href=#분산-메일-서버-아키텍처>분산 메일 서버 아키텍처</a></li></ol></li><li><a href=#이메일-전송-절차>이메일 전송 절차</a></li><li><a href=#이메일-수신-절차>이메일 수신 절차</a></li></ol></li><li><a href=#3단계-상세-설계>3단계: 상세 설계</a><ol><li><a href=#메타데이터-데이터베이스>메타데이터 데이터베이스</a><ol><li><a href=#이메일-메타데이터의-특성>이메일 메타데이터의 특성</a></li><li><a href=#올바른-데이터베이스의-선정>올바른 데이터베이스의 선정</a></li><li><a href=#데이터-모델>데이터 모델</a></li><li><a href=#일관성-문제>일관성 문제</a></li></ol></li><li><a href=#이메일-전송-가능성>이메일 전송 가능성</a></li><li><a href=#검색>검색</a></li><li><a href=#규모-확장성-및-가용성>규모 확장성 및 가용성</a></li></ol></li><li><a href=#4단계-마무리>4단계: 마무리</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/post/system-design-interview-2/8/><img src=/post/system-design-interview-2/8/cover_huf565d8fe7a4f9f5a961306624616abfc_449360_800x0_resize_box_3.png srcset="/post/system-design-interview-2/8/cover_huf565d8fe7a4f9f5a961306624616abfc_449360_800x0_resize_box_3.png 800w, /post/system-design-interview-2/8/cover_huf565d8fe7a4f9f5a961306624616abfc_449360_1600x0_resize_box_3.png 1600w" width=800 height=1143 loading=lazy alt="Featured image of post 8. 분산 메일 서비스"></a></div><div class=article-details><header class=article-category><a href=/categories/common/ style=background-color:#2a9d8f;color:#fff>Common</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/system-design-interview-2/8/>8. 분산 메일 서비스</a></h2><h3 class=article-subtitle>가상 면접 사례로 배우는 대규모 시스템 설계 기초 2</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2024/10/23</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>20 minute read</time></div></footer></div></header><section class=article-content><p>이번 장에서는 지메일, 아웃룩 같은 대규모 이메일 서비스를 설계해본다.</p><h2 id=1단계-문제-이해-및-설계-범위-확정>1단계: 문제 이해 및 설계 범위 확정</h2><p>현대적 이메일 서비스는 다양한 기능을 갖춘 복잡한 시스템으로 발전했다. 따라서 짧은시간에 설계는 불가능하므로 질문을 통해 설계 범위를 좁혀야한다.</p><ul><li><del>인증</del></li><li>이메일 발송/수신</li><li>모든 이메일 가져오기</li><li>읽음 여부에 따른 이메일 필터링</li><li>제목, 발신인, 메일 내용에 따른 검색 기능</li><li>스팸 및 바이러스 방지 기능</li><li>프로토콜<ul><li>SMTP, POP, IMAP 등과 같은 서비스 제공자 전용 프로토콜이 있으나 HTTP 사용한다고 가정</li></ul></li><li>첨부파일 지원</li></ul><h3 id=비기능적-요구사항>비기능적 요구사항</h3><ul><li>안정성<ul><li>이메일 데이터는 소실되어선 안된다.</li></ul></li><li>가용성<ul><li>이메일과 사용자 데이터를 여러 노드에 자동으로 복제하여 가용성을 보장해야한다.</li><li>부분적으로 장애가 발생해도 시스템은 계속 동작해야 한다.</li></ul></li><li>확정성<ul><li>사용자 수가 늘어나더라도 감당할 수 있어야 한다.</li><li>사용자나 이메일이 많아져도 시스템 성능은 저하되지 않아야 한다.</li></ul></li><li>유연성과 확장성<ul><li>새 컴포넌트를 더하여 쉽게 기능을 추가하고 성능을 개선할 수 있는 유연하고 확장성 높은 시스템이어야 한다.</li><li>POP나 IMAP 같은 기존 이메일 프로토콜은 기능이 매우 제한적이므로, 요구사항을 만족하기 위해 맞춤형 프로토콜이 필요할 수 있다.</li></ul></li></ul><h3 id=개략적인-규모-추정>개략적인 규모 추정</h3><ul><li>10억 사용자</li><li>한 사람이 하루에 보내는 평균 이메일 수는 10건 가정<ul><li><code>QPS = 10^9 * 10 / 10^5 = 100,000</code></li></ul></li><li>한 사람이 하루에 수신하는 이메일 수는 평균 40건 가정</li><li>메일 하나의 메타데이터는 평균 50KB로 가정(첨부파일 X)</li><li>메타데이터는 데이터베이스에 저장한다고 가정<ul><li>1년간 메타데이터를 유지하기 위한 스토리지 요구사항은 <code>10억 사용자 * 하루 40건 * 365일 * 50KB = 730PB</code></li></ul></li><li>첨부 파일을 포함하는 이메일의 비율은 20%, 평균 크기는 50KB 가정<ul><li>1년간 첨부 파일을 보관하는 데 필요한 저장 용량은 <code>10억 사용자 * 하루 40건 * 365 * 20% * 500KB = 1,460PB</code></li></ul></li></ul><p>많은 데이터를 처리해야하므로 분산 데이터베이스 솔루션이 필요하다.</p><h2 id=2단계-개략적-설계안-제시-및-동의-구하기>2단계: 개략적 설계안 제시 및 동의 구하기</h2><p>이메일 서버에 대해 알아야 할 기본적인 사항과 더불어 서버가 시간이 흐름에 따라 어떻게 진화하는지 논의한다.</p><p>그 후 분산 이메일 서버의 개략적인 설계안을 살펴본다.</p><h3 id=이메일-101>이메일 101</h3><p>이메일을 주고받는 프로토콜에는 대부분 POP, IMAP, SMTP 같은 프로토콜을 사용해왔다.</p><h4 id=이메일-프로토콜>이메일 프로토콜</h4><ul><li><strong>SMTP</strong>(Simple Mail Transfer Protocol)<ul><li>이메일을 한 서버에서 다른 서버로 보내는 표준 프로토콜</li></ul></li><li><strong>POP</strong>(Post Office Protocol)<ul><li>이메일을 가져오는 목적으로 널리 사용</li><li>이메일 클라이언트가 원격 메일 서버에서 이메일을 수신하고 다운로드하기 위해 사용하는 표준 프로토콜</li><li>단말로 다운로드된 이메일은 서버에서 삭제<ul><li>결과적으로 한 대 단말에서만 이메일을 읽을 수 있음</li></ul></li><li>이메일을 확인하기 위해 전부 내려받아야 함<ul><li>용량이 큰 첨부 파일이 붙은 이메일은 읽으려면 시간이 오래걸림</li></ul></li></ul></li><li><strong>IMAP</strong>(Internet Mail Access Protocol)<ul><li>이메일을 가져오는 목적으로 널리 사용</li><li>POP과 달리 클리하지 않으면 메시지는 다운로드 되지 않으며, 메일 서버에서 지워지지도 않음<ul><li>여러 단말에서 이메일을 읽을 수 있음</li></ul></li><li>개인 이메일 계정에서 가장 널리 사용되는 프로토콜</li><li>이메일을 실제로 열기 전에는 헤더만 다운로드<ul><li>인터넷 속도가 느려도 잘 동작함</li></ul></li></ul></li><li><strong>HTTPS</strong><ul><li>메일 전송 프로토콜은 아니지만 웹 기반 이메일 시스템의 메일함 접속에 이용될 수 있음</li><li>ex) 아웃룩의 액티브 싱크</li></ul></li></ul><h4 id=dns---도메인-이름-서비스>DNS - 도메인 이름 서비스</h4><p>수신자 도메인의 메일 교환기 레코드(Mail Exchange, MX) 검색에 이용된다.</p><p><img src=/post/system-design-interview-2/8/img.png width=1494 height=546 srcset="/post/system-design-interview-2/8/img_hub7f0eb4bd2d0a33dfc88796a278dea75_678809_480x0_resize_box_3.png 480w, /post/system-design-interview-2/8/img_hub7f0eb4bd2d0a33dfc88796a278dea75_678809_1024x0_resize_box_3.png 1024w" loading=lazy alt="MX 레코드" class=gallery-image data-flex-grow=273 data-flex-basis=656px></p><ul><li>숫자는 우선순위 값으로 선호도를 나타내어 값이 낮으면 높은 우선순위로 처리됨</li></ul><h4 id=첨부-파일>첨부 파일</h4><p>첨부 파일은 이메일 메시지와 함께 전송되며 일반적으로 Base64 인코딩을 활용한다.</p><p>일반적으로 첨부 파일에는 크기 제한이 있고, 설정 가능한 수치로, 개인 계정이냐 기업 계정이냐에 따라 다르게 설정된다.(필요한 만큼 알아서 설정한다)</p><ul><li>아웃룩 20MB, 지메일 25MB</li></ul><blockquote><p><strong>MIME</strong>( Multi-purpose Internet Mail Extension)<br>인터넷을 통해 첨부 파일을 전송할 수 있도록 하는 표준 규격</p></blockquote><h4 id=전통적-메일-서버>전통적 메일 서버</h4><p>분산 메일 서버에 알아보기 전 기존 메일 서버의 역사와 동작 방식에 대해 살펴본다.</p><p>전통적인 메일 서버는 보통 <strong>서버 한 대로 운용되는, 사용자가 많지 않을 때 잘 동작하는 시스템</strong>이다.</p><hr><p><strong>전통적 메일 서버 아키텍처</strong></p><p><img src=/post/system-design-interview-2/8/img_1.png width=1166 height=928 srcset="/post/system-design-interview-2/8/img_1_hu802478e41453ab6fdfaa430529afc2d8_190128_480x0_resize_box_3.png 480w, /post/system-design-interview-2/8/img_1_hu802478e41453ab6fdfaa430529afc2d8_190128_1024x0_resize_box_3.png 1024w" loading=lazy alt="전통적 메일 서버" class=gallery-image data-flex-grow=125 data-flex-basis=301px></p><ol><li>보내기 버튼을 누르면 메일 서버로 전송된다.(SMTP)</li><li>메일 서버는 DNS 질의를 통해 수신 SMTP 서버를 찾고 해당 서버로 이메일을 보낸다(SMTP)</li><li>메일을 수신한 서버는 이메일을 저장하고 수신자가 읽어갈 수 있도록 한다.</li><li>수신자가 로그인하면 IMAP/POP 서버를 통해 새 이메일을 가져온다.</li></ol><hr><p><strong>저장소</strong></p><p>전통적 메일 서버는 <strong>이메일을 파일 시스템의 디렉터리에 저장</strong>한다.</p><p>각각의 이메일은 고유한 이름을 가진 별도 파일로 보관도며, 각 사용자의 설정 데이터와 메일함은 사용자 디렉터리에 보관한다.</p><ul><li>이러한 디렉터리 구조를 <strong>Maildir</strong> 이라고 함</li></ul><p><img src=/post/system-design-interview-2/8/img_2.png width=920 height=1166 srcset="/post/system-design-interview-2/8/img_2_hu2474c31464cc06986e6e832f2b67e40e_32499_480x0_resize_box_3.png 480w, /post/system-design-interview-2/8/img_2_hu2474c31464cc06986e6e832f2b67e40e_32499_1024x0_resize_box_3.png 1024w" loading=lazy alt=Maildir class=gallery-image data-flex-grow=78 data-flex-basis=189px></p><p>파일과 디렉터리를 활용하는 방안은 사용자가 많지 않을 때는 잘 동작하나 디스크 I/O로 인한 병목으로 인해 수십억 개의 이메일을 검색하고 백업하는 목적으로 활용하기에는 곤란했다.</p><p>그리고 <strong>이메일을 서버의 파일 시스템에 보관</strong>하였기 때문에 <strong>가용성과 안정성</strong> 요구사항도 만족할 수 없었기 때문에 더 안정적인 분산 데이터 저장소 계층이 필요했다.</p><ul><li>디스크 손상, 서버 장애 등</li></ul><hr><p>이메일 기능은 1960년대에 발명된 이래로 텍스트 중심에서 멀티미디어, 메일 스레드, 검색, 레이블 등 다양한 기능을 지원하도록 발전해 왔지만, POP, IMAP, SMTP 같은 이메일 프로토콜은 이러한 기능을 지원하도록 설계되지 않았기 때문에 확장할 수 없었다.</p><h3 id=분산-메일-서버>분산 메일 서버</h3><p>분산 메일 서버는 현대적 사용 패턴을 지원하고 확장성과 안정성 문제를 해결한다.</p><h4 id=이메일-api>이메일 API</h4><p>이메일 API의 의미는 메일 클라이언트, 이메일 생명주기 단계마다 달라질 수 있다.</p><ul><li>모바일 단말 클라이언트를 위한 SMTP/POP/IMAP API</li><li>송신 측 메일 서버와 수신 측 메일 서버 간의 SMTP 통신</li><li>대화형 웹 기반 이메일 애플리케이션을 위한 HTTP 기반 RESTful API</li></ul><p>이 책에서는 가장 중요한 API만 다루며, 웹메일 통신에는 일반적으로 HTTP 프로토콜이 쓰인다.</p><hr><p><strong><code>POST /v1/messages</code></strong></p><p>To, Tc, Bcc 헤더에 명시된 수신자에게 메시지를 전송한다.</p><hr><p><strong><code>GET /v1/folders</code></strong></p><p>주어진 이메일 계정에 존재하는 모든 폴더를 반환한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>[{
</span></span><span class=line><span class=cl>    &#34;id&#34;: string,
</span></span><span class=line><span class=cl>    &#34;name&#34;: string,
</span></span><span class=line><span class=cl>    &#34;user_id&#34;: string
</span></span><span class=line><span class=cl>}]
</span></span></code></pre></td></tr></table></div></div><hr><p><strong><code>GET /v1/folders/{:folder_id}/messages</code></strong></p><p>주어진 폴더 아래의 모든 메시지를 반환한다.</p><ul><li>단순화한 명세로 페이지네이션을 지원해야 하는 등 훨씬 복잡할 수 있다.</li></ul><hr><p><strong><code>GET /v1/messages/{:message_id}</code></strong></p><p>주어진 특정 메시지에 대한 모든 정보를 반환한다.</p><p>메시지는 이메일 애플리케이션의 핵심 구성 요소이다.</p><ul><li>발신자, 수신자, 메시지 제목, 본문, 첨부 파일 등의 정보로 구성</li></ul><h4 id=분산-메일-서버-아키텍처>분산 메일 서버 아키텍처</h4><p>전통적인 이메일 서버가 단일 장비 위에서만 동작하도록 설계되었기 때문에 한 대 이상의 서버로 규모를 늘리는 것은 까다롭다.</p><ul><li>여러 서버 사이에 데이터를 동기화하는 것은 어려운 작업이다.</li><li>수신자 메일 서버에서 이메일이 스팸으로 잘못 분류되지 않도록 하려면 까다로운 문제들을 풀어야한다.</li></ul><p>이번 절에서는 클라우드 기술을 활용하여 이러한 문제를 쉽게 푸는 방법을 알아본다.</p><p><img src=/post/system-design-interview-2/8/img_3.png width=1328 height=1040 srcset="/post/system-design-interview-2/8/img_3_hu97293f0920808d780af3a4f7f2404b28_190471_480x0_resize_box_3.png 480w, /post/system-design-interview-2/8/img_3_hu97293f0920808d780af3a4f7f2404b28_190471_1024x0_resize_box_3.png 1024w" loading=lazy alt="개략적 설계안" class=gallery-image data-flex-grow=127 data-flex-basis=306px></p><ul><li>웹메일<ul><li>사용자는 웹브라우저를 사용해 메일을 받고 보냄</li></ul></li><li>웹서버<ul><li>사용자가 이용하는 요청/응답 서비스로, 로그인, 가입, 사용자 프로파일 등에 대한 관리 기능을 담당</li><li>본 설계안에서는 이메일 발송, 폴더 목록 확인, 폴더 내 모든 메시지 확인 등</li></ul></li><li>실시간 서버<ul><li>새로운 이메일 내역을 클라이언트에 실시간으로 전달한다.</li><li>지속성 연결을 맺고 유지해야하므로 상태 유지 서버다.<ul><li>롱폴링, 웹소켓 등</li><li>웹소켓이 좀 더 우아하지만 브라우저 호환성 문제가 있을 수 있다.</li><li>기본적으로는 웹 소켓을 쓰되 여의치 않으면 롱 폴링을 백업으로 이용할 수 있다.</li></ul></li></ul></li><li>메타데이터 데이터베이스<ul><li>이메일 제목, 본문, 발신인, 수신인 목록 등 메타 데이터를 저장하는 데이터베이스</li></ul></li><li>첨부 파일 저장소<ul><li>아마존 S3(Simple Storage Service) 같은 객체 저장소를 사용할 것이다.<ul><li>이미지나 동영상 등의 대용량 파일을 저장하는 데 적합하고 확장이 용이한 인프라이다.</li></ul></li><li>첨부파일 크기는 25MB로 제한한다.</li></ul></li><li>분산 캐시<ul><li>최근에 수신된 이메일은 자주 읽을 가능성이 높으므로 클라이언트로 하여금 메모리에 캐시해 두도록 하면 메일을 표시하는 시간을 많이 줄일 수 있다.</li><li>레디스<ul><li>리스트와 같은 다양한 기능을 제공하고, 규모 확장이 용이하다.</li></ul></li></ul></li><li>검색 저장소<ul><li>검색 저장소는 분산 문서 저장소이다.</li><li>고속 텍스트 검색을 지원하는 <strong>역 인덱스</strong>를 자료 구조로 사용한다.</li></ul></li></ul><blockquote><p><strong>카산드라가 첨부 파일 저장소로 적합하지 않은 이유</strong></p><ul><li>카산드라가 BLOB 자료형을 지원하고 해당 자료형이 지원하는 데이터의 최대 크기가 2GB이긴 하지만 실질적으로는 1MB 이상의 파일은 지원하지 못한다.</li><li>카산드라에 첨부 파일을 저장하면 첨부 파일이 너무 많은 메모리를 사용하게되어 레코드 캐시를 사용하기 어렵다.</li></ul></blockquote><h3 id=이메일-전송-절차>이메일 전송 절차</h3><p><img src=/post/system-design-interview-2/8/img_4.png width=1698 height=1126 srcset="/post/system-design-interview-2/8/img_4_hu6c1accd62c346f29cf05623f72575dc4_306833_480x0_resize_box_3.png 480w, /post/system-design-interview-2/8/img_4_hu6c1accd62c346f29cf05623f72575dc4_306833_1024x0_resize_box_3.png 1024w" loading=lazy alt="이메일 전송 절차" class=gallery-image data-flex-grow=150 data-flex-basis=361px></p><ol><li>사용자가 웹에서 메일을 정송하면 요청은 로드밸런서로 전송된다.</li><li>로드벨런서가 처리율 제한 한도를 넘지 않는 선에서 요청을 웹 서버로 전달한다.</li><li>웹 서버는 다음 역할을 담당한다.<ul><li>기본적인 이메일 검증<ul><li>이메일 크기 한도 같은 사전 미리 정의된 규칙을 사용하여 수신된 이메일을 검사한다.</li></ul></li><li>수신자 이메일 주소 도메인이 송신자 이메일 주소 도메인과 같은지 검사<ul><li>이메일 내용의 스팸 여부와 바이러스 감염 여부를 검사</li><li>검사를 통과한 이메일은 송신인의 보낸 편지함과 수신인의 받은 편지함에 저장</li></ul></li><li>수신인 측 클라이언트는 RESTful API를 사용하여 이메일을 바로 가져올 수 있어 4단계 이후는 수행할 필요가 없다.</li></ul></li><li>메시지 큐<ol><li>기본적인 검증을 통과한 이메일은 외부 전송 큐로 전달된다.<ul><li><strong>첨부 파일의 크기가 너무 큰 이메일</strong>의 경우 <strong>첨부 파일을 객체 저장소에 따로 저장</strong>하고 해당 <strong>저장 위치에 대한 참조 정보만 저장</strong>한다.</li></ul></li><li>기본적인 검증에 실패한 이메일은 에러 큐에 보관한다.</li></ol></li><li>외부 전송 담당 SMTP 작엄 프로세스는 외부 전송 큐에서 메시지를 꺼내어 이메일의 스팸 및 바이러스 감염 여부를 확인한다.</li><li>검증 절차를 통과한 이메일은 저장소 계층 내의 보낸 편지함에 저장된다.</li><li>외부 전송 담당 SMTP 작업 프로세스가 수신자의 메일 서버로 메일을 전송한다.</li></ol><p>외부 전송 큐에 보관되는 모든 메시지에는 <strong>이메일을 생성하는 데 필요한 모든 메타데이터가 포함</strong>되어 있다.</p><p><strong>분산 메시지 큐</strong>는 비동기적 메일 처리를 가능케 하는 핵심적 컴포넌트이다.</p><ul><li>웹 서버에서 외부 전송 담당 SMTP 프로세스를 분리함으로 전송용 SMTP 프로세스의 규모를 독립적으로 조정할 수 있게 된다.</li></ul><p>외부 전송 큐의 크기를 모니터링 할 때 메일이 처리되지 않고 큐에 오랫동안 남아 있으면 그 이유를 분석해야한다.</p><ul><li>수신자 측 메일 서버에 장애 발생<ul><li>나중에 메일을 다시 전송해야 한다.</li><li>ex) 지수적 백오프(Exponential Backoff)</li></ul></li><li>이메일을 보낼 큐의 소비자 수가 불충분<ul><li>더 많은 소비자를 추가하여 처리 시간을 단축하는 방법을 생각해 볼 수 있다.</li></ul></li></ul><h3 id=이메일-수신-절차>이메일 수신 절차</h3><p><img src=/post/system-design-interview-2/8/img_5.png width=1824 height=946 srcset="/post/system-design-interview-2/8/img_5_hufa935ff62aaff4ec9a22919e7479ce7e_259381_480x0_resize_box_3.png 480w, /post/system-design-interview-2/8/img_5_hufa935ff62aaff4ec9a22919e7479ce7e_259381_1024x0_resize_box_3.png 1024w" loading=lazy alt="이메일 수신 절차" class=gallery-image data-flex-grow=192 data-flex-basis=462px></p><ol><li>이메일이 SMTP 로드밸런서에 도착</li><li>트래픽을 여러 SMTP 서버로 분산<ul><li>SMTP 연결에는 이메일 수락 정책을 구성하여 적용 가능</li><li>유효하지 않은 이메일은 방송하도록 하여 불필요한 이메일 처리를 피할 수 있음</li></ul></li><li>이메일의 첨부 파일이 큐에 들어가기 너무 큰 경우 첨부 파일 저장소(S3)에 보관</li><li>이메일을 수신 이메일 큐에 넣는다<ul><li>메일 처리 작업 프로세스와 SMTP 간 결합도를 낮추어 각자 독립적으로 규모 확장이 가능하도록 함</li><li>수신 이메일이 폭증하는 경우 버퍼 역할도 하게됨</li></ul></li><li>메일 처리 작업 프로세스(worker)는 스팸 메일을 걸러내고 바이러스를 차단하는 등의 다양한 역할 담당<ul><li>이후 처리는 검증 작업이 끝난 이메일을 대상으로 처리</li></ul></li><li>이메일을 메일 저장소, 캐시, 객체 저장소 등에 보관</li><li>수신자가 온라인 상태일 경우 실시간 서버로 전달</li><li>실시간 서버는 수신자 클라이언트가 새 이메일을 실시간으로 받을 수 있도록 하는 웹소켓 서버</li><li>오프라인 상태 사용자의 이메일은 저장소 계층에 보관<ul><li>온라인 상태가 되면 클라이언트가 웹 서버에 RESTful API를 통해 열결됨</li></ul></li><li>새로운 이메일을 저장소 계층에서 가져와 클라이언트에 반환</li></ol><h2 id=3단계-상세-설계>3단계: 상세 설계</h2><p>몇 가지 핵심 요소에 대해 더 자세히 알아보고 규모 확장 방안을 점검한다.</p><h3 id=메타데이터-데이터베이스>메타데이터 데이터베이스</h3><p>이메일 메타데이터의 특성을 알아보고 올바른 데이터베이스와 데이터 모델을 고르는 문제, 이메일 스레드 지원 방안에 대해 알아본다.</p><h4 id=이메일-메타데이터의-특성>이메일 메타데이터의 특성</h4><ul><li>이메일의 헤더는 일반적으로 작고, 빈번하게 이용</li><li>이메일 본문의 크기는 다양하지만 사용 빈도는 낮음<ul><li>일반적으로 한 번만 읽음</li></ul></li><li>이메일 가져오기, 읽은 메일로 표시, 검색 등의 이메일 관련 작업은 사용자 별로 격리 수행되어야함<ul><li>어떤 사용자의 이메일은 해당 사용자만 읽을 수 있어야함</li><li>이메일에 대한 작업도 그 사용자만이 수행할 수 있어야함</li></ul></li><li>데이터 신선도는 데이터 사용 패턴에 영향을 미침<ul><li>사용자는 보통 최근 메일만 읽음</li><li>만들어진 지 16일 이하에 발생하는 읽기 질의 비율은 전체 질의의 82%에 달함</li></ul></li><li>데이터의 높은 안정성이 보장되어야 함<ul><li><strong>데이터 손실은 용납되지 않음</strong></li></ul></li></ul><h4 id=올바른-데이터베이스의-선정>올바른 데이터베이스의 선정</h4><p>지메일이나 아웃룩 정도의 규모가 되면 시스템의 부하로 인해, 초당 입/출력 연산 빈도(Input/Output Operations Per Second, IOPS)를 낮추기 위한 맞춤 제장 데이터베이스를 사용한다.</p><p>올바른 데이터베이스 선택은 쉽지 않은데, 가능한 모든 선택지를 미리 살펴보면 도움이 된다.</p><hr><p><strong>관계형 데이터베이스</strong></p><p>관계형 데이터베이스를 고르는 주된 동기는 이메일을 효율적으로 검색할 수 있다는 장점 때문이다.</p><ul><li>이메일 헤더와 본문에 대한 인덱스를 만들면 효율적으로 검색할 수 있다.</li></ul><p>하지만 관계형 데이터베이스는 데이터 크기가 작을 때 적합하다.</p><ul><li>이메일은 수 KB보다 크고 HTML이 포함되면 쉽게 100KB를 넘어간다.</li><li>BLOB 자료형을 쓰면 큰 이메일도 처리할 수 있으나, 비정형 BLOB에 대한 검색 질의 성능은 좋지 않다.<ul><li>BLOB이 고정된 크기 페이지를 연결하여 큰 데이터를 저장하도록 하고 있어 해당 컬럼의 데이터를 접근할 때마다 많은 디스크 I/O가 발생한다</li></ul></li></ul><p>따라서 관계형 데이터베이스는 바람직하지 않다.</p><hr><p><strong>분산 객체 저장소</strong></p><p>이메일의 원시 데이터를 그대로 아마존 S3 같은 객체 저장소에 보관하는 방법도 고려할 수 있다.</p><p>하지만 객체 저장소는 백업 데이터를 보관하기에는 좋지만 이메일의 읽음 표시, 키워드 검색, 이메일 스레드 드의 기능을 구현하기에 그다지 좋지 않다.</p><hr><p><strong>NoSQL 데이터베이스</strong></p><p>지메일은 구글 빅테이블을 저장소로 사용하는데 충분히 실현 가능한 방안이다.</p><p>하지만 빅테이블은 오픈소스로 공개되어 있지 않고 이메일 검색을 빅테이블 위에서 어떻게 구현했는지는 공개되어있지않다.</p><p>카산드라가 좋은 대안이 될 수도 있지만 대형 이메일 서비스 제공 업체 가운데 카산드라를 사용하는 곳은 아직 확인된 바가 없다.</p><hr><p>위 후보들을 봤을 때 본 설계안이 필요로 하는 기능을 완벽히 지원하는 데이터베이스는 없다고 봐도 좋을 것 같다.</p><p>이러한 이유로 대형 이메일 서버스 업체는 대체로 독자적인 데이터베이스 시스템을 만들어 사용한다.</p><p>이러한 데이터베이스를 설계하기엔 시간이 부족하므로, 해당 데이터베이스가 아래와 같은 조건을 충족해야 한다는 점을 설명할 수 있어야한다.</p><ul><li>어떤 단일 컬럼의 크기는 한 자리수의 MB 정도일 수 있다.</li><li>강력한 데이터 일관성이 보장되어야 한다.</li><li>디스크 I/O가 최소화되도록 설계되어야 한다.</li><li>가용성이 아주 높아야 하고 일부 장애를 감내할 수 있어야 한다.</li><li>증분 백업(incremental backup)이 쉬워야 한다.</li></ul><h4 id=데이터-모델>데이터 모델</h4><p>데이터를 저장하는 한 가지 방법은 <code>user_id</code>를 파티션 키로 사용하여 특정한 사용자의 데이터는 항상 같은 샤드에 보관하는 것이다.</p><ul><li>메시지를 여러 사용자와 공유할 수 없지만 요구사항과는 관계 없다.</li></ul><p>기본 키는 파티션 키(partition key)와 클러스터 키(clustering key)의 두 가지 부분으로 구성된다.</p><ul><li>파티션 키<ul><li>데이터를 여러 노드에 분산하는 기준</li><li>데이터가 모든 노드에 균등하게 분산되도록 하는 파티션 키를 골라야함</li></ul></li><li>클러스터 키<ul><li>파티션에 속한 데이터를 정렬하는 기준</li></ul></li></ul><p>개략적으로 이메일 서비스의 데이터 계층은 다음과 같은 질의를 지원해야 한다.</p><ul><li>주어진 사용자의 모든 폴더를 구한다.</li><li>특정 폴더 내의 모든 이메일을 표시한다.</li><li>메일을 생성, 삭제, 조회한다.</li><li>읽은 메일 전부, 또는 읽지 않은 메일 전부를 가져온다.</li><li>이메일 스레드를 전부 가져온다.</li></ul><hr><p><img src=/post/system-design-interview-2/8/img_6.png width=856 height=518 srcset="/post/system-design-interview-2/8/img_6_hu00ad76f03bcbd533c2a84dbc6e348eb4_89085_480x0_resize_box_3.png 480w, /post/system-design-interview-2/8/img_6_hu00ad76f03bcbd533c2a84dbc6e348eb4_89085_1024x0_resize_box_3.png 1024w" loading=lazy alt="키 구성" class=gallery-image data-flex-grow=165 data-flex-basis=396px></p><p><strong>질의 1: 특정 사용자의 모든 폴더 질의</strong></p><p>파티션 키는 <code>user_id</code>다. 따라서 어떤 사용자의 모든 폴더는 같은 파티션 안에 있다.</p><p><img src=/post/system-design-interview-2/8/img_7.png width=872 height=544 srcset="/post/system-design-interview-2/8/img_7_hu156bc7a2fc679faefe0f0978519d3cb5_79626_480x0_resize_box_3.png 480w, /post/system-design-interview-2/8/img_7_hu156bc7a2fc679faefe0f0978519d3cb5_79626_1024x0_resize_box_3.png 1024w" loading=lazy alt="사용자 별 폴더 목록" class=gallery-image data-flex-grow=160 data-flex-basis=384px></p><hr><p><strong>질의 2: 특정 폴더에 속한 모든 이메일 표시</strong></p><p>사용자가 자기 메일 폴더를 열면 이메일은 가장 최근 이메일부터 오래된 것 순으로 정렬되어 표시된다.</p><p>같은 폴더에 속한 모든 이메일이 같은 파티션에 속하도록 하려면 <code>&lt;user_id, foler_id></code> 형태의 복합 파티션 키를 사용해야 한다.</p><p><img src=/post/system-design-interview-2/8/img_9.png width=876 height=982 srcset="/post/system-design-interview-2/8/img_9_hu41305bc042d3fec07ebe69ff8294aa6a_136085_480x0_resize_box_3.png 480w, /post/system-design-interview-2/8/img_9_hu41305bc042d3fec07ebe69ff8294aa6a_136085_1024x0_resize_box_3.png 1024w" loading=lazy alt="폴더별 이메일" class=gallery-image data-flex-grow=89 data-flex-basis=214px></p><p><code>email_id</code>의 자료형은 <code>TIMEUUID</code>로 이메일을 시간순으로 정렬하는 데 사용되는 클러스터 키다.</p><hr><p><strong>질의 3: 이메일 생성/삭제/수신</strong></p><p>이메일 상세 정로를 가져오는 방법을 살펴본다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>emails_by_user</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>email_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>123</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>이 질의를 지원하기 위해 두 테이블이 필요하다.</p><p><img src=/post/system-design-interview-2/8/img_10.png width=1328 height=642 srcset="/post/system-design-interview-2/8/img_10_hucad2710252b37d32d309b4b9de9854c5_132150_480x0_resize_box_3.png 480w, /post/system-design-interview-2/8/img_10_hucad2710252b37d32d309b4b9de9854c5_132150_1024x0_resize_box_3.png 1024w" loading=lazy alt="사용자별 이메일" class=gallery-image data-flex-grow=206 data-flex-basis=496px></p><p>한 이메일에는 여러 첨부 파일이 있을 수 있으므로, <code>email_id</code>, <code>filename</code> 필드를 같이 사용하면 모든 첨부 파일을 질의할 수 있다.</p><hr><p><strong>질의 4: 읽은, 또는 읽지 않은 모든 메일</strong></p><p>관계형 데이터베이스로 도메인 모델을 구현하는 경우, 읽은 메일 전부는 다음과 같이 질의할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>emails_by_folder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>user_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&lt;%</span><span class=n>user_id</span><span class=o>%&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>AND</span><span class=w> </span><span class=n>folder_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&lt;%</span><span class=n>folder_id</span><span class=o>%&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>AND</span><span class=w> </span><span class=n>is_read</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>email_id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>본 설계안의 데이터모델은 NoSQL로 보통 파티션 키와 클러스터 키에 대한 질의만 허용하므로 <code>emails_by_folder</code> 테이블의 <code>is_read</code> 필드는 이에 해당하지 않기 때문에 대부분의 NoSQL 데이터베이스에서는 위 쿼리를 실행할 수 없다.</p><p>이 문제를 해결하기 위한 방법으로 <strong>주어진 폴더에 속한 모든 메시지를 가져온 다음 애플리케이션 단에서 필터링</strong> 해줄 수 있다.</p><ul><li>대규모 서비스에는 적합하지 않다.</li></ul><p>따라서 이런 문데는 NoSQL 데이터베이스 테이블을 비정규화(denormalization)하여 해결하는 것이 보통이다.</p><ul><li><code>emails_by_folder</code> 테이블을 두 테이블로 분할한다.</li><li><code>read_emails</code>: 읽은 상태의 모든 이메일을 보관</li><li><code>unread_eamils</code>: 읽지 않은 모든 이메일을 보관</li></ul><p><img src=/post/system-design-interview-2/8/img_11.png width=1288 height=568 srcset="/post/system-design-interview-2/8/img_11_hueb1288bc525b10d750ab98ffc79e7b70_139881_480x0_resize_box_3.png 480w, /post/system-design-interview-2/8/img_11_hueb1288bc525b10d750ab98ffc79e7b70_139881_1024x0_resize_box_3.png 1024w" loading=lazy alt=비정규화 class=gallery-image data-flex-grow=226 data-flex-basis=544px></p><p>특정 폴더 안의 읽지 않은 모든 메일을 가져오는 질의는 다음과 같이 표현될 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>unread_mails</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>user_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&lt;%</span><span class=n>user_id</span><span class=o>%&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>AND</span><span class=w> </span><span class=n>folder_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&lt;%</span><span class=n>folder_id</span><span class=o>%&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>email_id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>이러한 비정규화는 흔한 관행으로, 애플리케이션 코드가 좀 더 복잡해지고 관리하기 까다로워지지만, 질의 성능은 대규모 서비스에 어울리는 수준으로 개선한다.</p><hr><p><strong>보너스: 이메일 스레드 가져오기</strong></p><p>이메일 스레드는 많은 이메일 클라이언트가 지원하는 기능으로 모든 답장을 최초 메시지에 스레드로 엮어 보여주는 기능이다.</p><p>사용자가 특정한 대화에 관련된 모든 메일을 한 번에 확인할 수 있게된다.</p><ul><li>전통적으로 <strong>JWZ</strong> 같은 알고리즘을 통해 구현한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;headers&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Message-Id&#34;</span><span class=p>:</span> <span class=s2>&#34;&lt;7BA04B2A-430C-4D12-8B57-862103C34501@gmail.com&gt;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;In-Reply-To&#34;</span><span class=p>:</span> <span class=s2>&#34;&lt;CAEWTXuPfN=LzECjDJtgY9Vu03kgFvJnJUSHTt6TW@gmail.com&gt;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;References&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>      <span class=s2>&#34;&lt;7BA04B2A-430C-4D12-8B57-862103C34501@gmail.com&gt;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>Message-Id</strong><ul><li>메시지 식별자</li><li>메시지를 보내는 클라이언트가 생성</li></ul></li><li><strong>In-Reply-To</strong><ul><li>어떤 메시지가 어떤 메시지에 대한 답신인지 나타내는 식별자</li></ul></li><li><strong>References</strong><ul><li>스레드에 관계된 메시지 식별자 목록</li></ul></li></ul><p>이 필드들로 이메일 클라이언트는 타래 내의 모든 메시지가 사전에 메모리에 로드되어 있는 경우 전체 대화 스레드를 재구성해 낼 수 있게된다.</p><h4 id=일관성-문제>일관성 문제</h4><p>높은 가용성을 달성하기 위해 다중화에 의존하는 분산 데이터베이스는 데이터 일관성과 가용성 사이에서 타협적인 결정을 내릴 수 밖에 없다.</p><p>이메일 시스템의 경우 <strong>데이터의 정확성이 아주 중요</strong>하므로, 모든 메일함은 반드시 하나의ㅏ 주 사본을 통해 서비스된다고 가정해야한다.</p><p>따라서 장애가 발생하면 클라이언트는 다른 사본을 통해 주 사본이 복원될 때까지 동기화/갱신 작업을 완료할 수 없다.</p><ul><li>일관성을 위해 가용성을 희생한다.</li></ul><h3 id=이메일-전송-가능성>이메일 전송 가능성</h3><p>메일 서버를 구성하고 이메일을 보내는 것은 쉽지만 특정 사용자의 메일함에 실제로 메일이 전달되도록 하는 것은 어려운 문제이다.</p><p>이메일이 <strong>스팸 폴더</strong>에 들어가 버리면 수신자가 메일을 읽을 가능성은 아주 낮아진다.</p><ul><li>연구에 따르면 메일 가운데 50%가 그팸으로 분류된다.</li></ul><p>새로 구성한 메일 서버는 인터넷에서 좋은 평판을 쌓을 기회가 전혀 없었기 때문에 보내는 메일이 대부분 스팸 폴더로 떨어진다.</p><p>따라서 이메일의 전송 가능성을 높이기 이ㅜ해서 다음과 같은 요소들을 고려한다.</p><ul><li>전용 IP<ul><li>전용 IP 주소를 사용하라</li><li>대부분의 이메일 서비스 사업자는 아무 이력이 없는 IP 새로운 IP 주소에서 온 메일을 무시한다.</li></ul></li><li>범주화<ul><li>범주가 다른 이메일은 다른 IP 주소를 통해 보내라</li><li>마케팅 목적의 메일을 중요한 이메일과 같은 서버에서 발송하면 ISP가 모든 이메일을 판촉 메일로 분류할 수도 있다.</li></ul></li><li>발신인 평판<ul><li>새로운 이메일 서버의 IP 주소는 사용 빈도를 서서히 올리는 것이 좋다.</li><li>그래야 좋은 평판이 쌓여 해당 IP 주소에서 발송되는 메일을 스팸으로 분류할 가능성이 낮아진다.</li><li>아마존 SES에 따르면 새로운 IP 주소를 메일 발송해 아무 문제 없이 쓸 수 있게 되는 데는 대략 2 ~ 6주가 소요된다.</li></ul></li><li>스팸 발송자의 신속한 차단<ul><li>스팸을 뿌리는 사용자는 서버 평판을 심각하게 훼손하기 전에 시스템에서 신속히 차단한다.</li></ul></li><li>피드백 처리<ul><li>불만 신고가 접수되는 비율을 낮추고 스팸 계정을 신속히 차단하기위해서는 ISP 측에서의 피드백을 쉽게 받아 처리할 수 있는 경로를 만드는 것이 중요하다.</li><li>이메일이 전달되지 못하거나 사용자로부터 불만 신고가 접수된 경우 다음과 같은 일들이 벌어질 수 있다.<ul><li>경성 반송(hard bounce)<ul><li>수신인의 이메일 주소가 올바르지 않아 ISP가 전달을 거부한 경우</li></ul></li><li>연성 반송(soft bounce)<ul><li>ISP 측의 이메일 처리 자원 부족 등의 이유로 일시적으로 이메일을 전달할 수 없었던 경우</li></ul></li><li>불만 신고(complaint)<ul><li>수신인이 스팸으로 신고 버튼을 누르는 경우</li></ul></li></ul></li></ul></li><li>이메일 인증<ul><li>2018년도 데이터 유출 조사 보고서에 따르면 ㅍ피싱이나 프리텍스팅이 전체 유철 사고에서 차지하는 비중은 93%에 달한다.</li><li>보편적으로 SPF(Sender Policy Framework), DKIM(DomainKeys Identified Mail), DMARC(Domain-based Message Authentication, Reporting and Conformance) 등으로 피싱에 대응한다.</li></ul></li></ul><p>명심해야할 점은 이메일이 목적지에 성공적으로 도착하도록 하기 어렵다는 사실이다. 도메인 지식은 물론 ISP와 좋은 관계를 유지할 필요도 있다.</p><h3 id=검색>검색</h3><p>기본적인 이메일 검색은 보통 이메일 제목이나 본문에 특정 키워드가 포함되었는지 찾는 것을 뜻하며, 고급 기능에는 발신인, 제목, 읽지 않음 같이 메일 속성에 따른 필터링 기능이 포함된다.</p><p>검색 기능을 제공하려면 이메일이 전송, 수신, 삭제 될 때마다 색인(indexing) 작업을 수행해야 한다.</p><p>그에 반해 검색은 사용자가 검색 버튼을 누를 때만 실행되므로, 이메일 시스템의 검색 기능에서는 쓰기 연산이 읽기 연산보다 훨씬 많이 발생한다.</p><p>검색 기능을 지원하기 위해 일래스틱서치(ElasticSearch)를 이용하는 방안과 데이터 저장소에 내장된 기본 검색 기능을 활용하는 방안의 두 가지 선택지를 비교해본다.</p><hr><p><strong>방안 1: 일래스틱서치</strong></p><p><img src=/post/system-design-interview-2/8/img_12.png width=1210 height=1224 srcset="/post/system-design-interview-2/8/img_12_hu3000d4f01569124c541bea50802fb702_56268_480x0_resize_box_3.png 480w, /post/system-design-interview-2/8/img_12_hu3000d4f01569124c541bea50802fb702_56268_1024x0_resize_box_3.png 1024w" loading=lazy alt="일래스틱 서치" class=gallery-image data-flex-grow=98 data-flex-basis=237px></p><p>질의가 대부분 사용자의 이메일 서버에서 실행되므로 <code>user_id</code>를 파티션 키로 사용하여 같은 사용자의 이메일은 같은 노드에 묶어 놓는다.</p><ul><li>사용자가 검색 버튼을 누른 다음 결과가 수신될 때 까지 기다리므로, 검색 요청은 동기 방식으로 처리되어야 한다.</li><li>이메일 전송, 이메일 수신, 이메일 삭제 같은 이벤트는 처리 결과를 클라이언트로 전달할 필요는 없으며, 추가로 색인 작업이 필요하다.</li></ul><p>본 설계안은 카프카를 활용하여 색인 작업을 시작하는 서비스와 실제로 색인을 수행할 서비스 사이의 결합도를 낮추는 방안을 채택한다.</p><ul><li>일래스틱서치는 2021년 6월 기준으로 가장 널리 사용되고 있는 검색 엔진 데이터베이스이며 이메일 검색에 필요한 텍스트 기반 검색을 잘 지원한다.</li></ul><p>일래스틱서치를 사용할 경우 주 이메일 저장소와 동기화를 맞추는 부분이 까다롭다.</p><hr><p><strong>방안 2: 맞춤형 검색 솔루션</strong></p><p>대규모 이메일 서비스 사업자는 보통 자기 제품에 고유한 요구사항을 만족시키기 위해 검색 엔진을 자체적으로 개발해 사용한다.</p><p>매우 어렵고 범위를 넘어서기 때문에 자체적으로 검색 솔루션을 구현하는 경우 마주하게 될 주요 과제인 디스크 I/O 병목 문제를 살펴본다.</p><p>개략적 규모 추정 결과 메타 데이터와 첨부 파일은 매일 페타바이트 수준으로 저장소에 추가되며, 하나의 이메일 계정에 몇십 만개 넘는 이메일이 저장되는 것도 흔하다.</p><ul><li>따라서 메일 색인 서버의 주된 병복은 보통 디스크 I/O다.</li></ul><p><img src=/post/system-design-interview-2/8/img_13.png width=1926 height=1002 srcset="/post/system-design-interview-2/8/img_13_hu495b352c0880296eb3398fcf25077ab9_380701_480x0_resize_box_3.png 480w, /post/system-design-interview-2/8/img_13_hu495b352c0880296eb3398fcf25077ab9_380701_1024x0_resize_box_3.png 1024w" loading=lazy alt="LSM 트리" class=gallery-image data-flex-grow=192 data-flex-basis=461px></p><p>색인을 구축하는 프로세스는 다량의 쓰기 연산을 발생시킬 수 밖에 없으므로 LSM(Log-Structured Merge)트리를 사용하여 <strong>디스크에 저장되는 색인을 구조화하는 것이 바람직한 전략</strong>이다.</p><ul><li>쓰기 경로는 순차적 쓰기 연산(sequential write)만 수행하도록 최적화 되어있다.</li><li>빅테이블이나 카산드라, RocksDB 같은 데이터베이스의 핵심 자료 구조다.</li></ul><ol><li>새로운 이메일이 도착하면 우선 메모리 캐시로 구현되는 0번 계층에 저장된다.</li><li>메모리에 보관된 데이터의 양이 사전에 정의된 임계치를 넘으면 데이터는 다음 계층에 병합된다.</li></ol><p>자주 바뀌는 데이터를 그렇지 않은 데이터와 분리하는 효과도 얻을 수 있다.</p><ul><li>이메일 데이터는 보통 바뀌지 않지만 메일 폴더의 정보는 상이한 필터링 규칙들 때문에 자주 바뀌는 경향이 있다.</li><li>데이터를 두 개 파트로 나누거 어떤 요청이 폴더 변경에 관한 것 이면 폴더 정보만 바꾸고 이메일 데이터는 내벼려둔다.</li></ul><hr><p>소규모의 이메일 시스템을 구축하는 경우 통합하기 쉽고 엔지니어링에 많은 노력이 필요하지 않은 일래스틱서치가 좋은 선택지이다.</p><p>대규모 시스템을 구축하는 경에도 일래스틱서치를 사용할 수 있겠지만 이메일 검색 인프라를 개발하고 관리하는 전담 팀이 필요할 수 있다.</p><p>지메일이나 아웃룩 규모의 이메일 시스템을 지원하려면 독립적인 검색 전용 시스템을 두기보다는 데이터베이스에 내장된 전용 검색 솔루션을 사용하는 것이 바람직할 수도 있다.</p><h3 id=규모-확장성-및-가용성>규모 확장성 및 가용성</h3><p>각 사용자의 데이터 접근 패턴은 다른 사용자와 무고나하므로, 시스템의 대부분 컴포넌트는 수평적으로 규모 확장이 가능할 것으로 기대할 수 있다.</p><p><img src=/post/system-design-interview-2/8/img_14.png width=1362 height=1260 srcset="/post/system-design-interview-2/8/img_14_hu7aa95457bd45ad9d0fc44f5368731ee7_86292_480x0_resize_box_3.png 480w, /post/system-design-interview-2/8/img_14_hu7aa95457bd45ad9d0fc44f5368731ee7_86292_1024x0_resize_box_3.png 1024w" loading=lazy alt="시스템 다중화" class=gallery-image data-flex-grow=108 data-flex-basis=259px></p><p>가용성을 향상시키기 위해서는 데이터를 여러 데이터센터에 다중화하는 것이 필요하다.</p><ul><li>자신과 물리적으로 가까운 메일 서버와 통신한다.</li><li>네트워크 파티션 발생시 다른 데이터센터에 보관된 메시지를 이용한다.</li></ul><h2 id=4단계-마무리>4단계: 마무리</h2><p>면접장에서 시간이 남는다면 추가로 논의해 볼 만한 주제로는 다음과 같은 것들이 있다.</p><ul><li>결함 내성<ul><li>노드 장애, 네트워크 문제, 이벤트 전달 지연 등의 문제에 어떻게 대처할지 살펴보면 좋을 것이다.</li></ul></li><li>규정 준수<ul><li>전 세계 다양한 시스템과 연동해야 하고 각 나라에는 준수해야할 법규가 있다.</li></ul></li><li>보안<ul><li>민감한 정보가 포함되므로 보안이 매우 중요하다.</li><li>피싱 방지, 안전 브라우징, 첨부 파일 사전 경고, 계정 안전, 기밀 모드, 이메일 암호화 등</li></ul></li><li>최적화<ul><li>같은 이메일이 여러 수신자에 전송되는 경우 동일한 첨부 파일이 있는지 확인하는 방식으로 최적화를 진행할 수 있다.</li></ul></li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/>가상 면접 사례로 배우는 대규모 시스템 설계 기초</a>
<a href=/tags/system-design-interview/>System Design Interview</a>
<a href=/tags/msa/>MSA</a>
<a href=/tags/micro-service-architecture/>Micro Service Architecture</a>
<a href=/tags/rdbms/>RDBMS</a>
<a href=/tags/relational-database-system/>Relational Database System</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><div class="article-list--compact links"><article><a href=https://product.kyobobook.co.kr/detail/S000211656186 target=_blank rel=noopener><div class=article-details><h2 class=article-title>가상 면접 사례로 배우는 대규모 시스템 설계 기초 2</h2><footer class=article-time>교보문고</footer></div></a></article></div><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/post/system-design-interview-2/7/><div class=article-image><img src=/post/system-design-interview-2/7/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 7. 호텔 예약 시스템" data-key=system-design-interview-2/7 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>7. 호텔 예약 시스템</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/13/><div class=article-image><img src=/post/system-design-interview-2/13/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 13. 증권 거래소" data-key=system-design-interview-2/13 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>13. 증권 거래소</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/12/><div class=article-image><img src=/post/system-design-interview-2/12/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 12. 전자 지갑" data-key=system-design-interview-2/12 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>12. 전자 지갑</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/11/><div class=article-image><img src=/post/system-design-interview-2/11/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 11. 결제 시스템" data-key=system-design-interview-2/11 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>11. 결제 시스템</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/10/><div class=article-image><img src=/post/system-design-interview-2/10/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 10. 실시간 게임 순위표" data-key=system-design-interview-2/10 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>10. 실시간 게임 순위표</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=codemario318/codemario318.github.io issue-term=pathname label=Comment crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2023 -
2025 Mario Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>