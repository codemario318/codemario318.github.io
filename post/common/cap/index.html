<!doctype html><html lang=ko dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="CAP 정리의 구성 요소와 이론적 불가능성에 대한 수학적 증명 정리"><title>논문으로 다시 이해한 CAP 정리</title><link rel=canonical href=https://codemario318.github.io/post/common/cap/><link rel=stylesheet href=/scss/style.min.cbce94e2760d14d60414e59d5a36ab2819232375817e010dbe7be2234b67da1b.css><meta property="og:title" content="논문으로 다시 이해한 CAP 정리"><meta property="og:description" content="CAP 정리의 구성 요소와 이론적 불가능성에 대한 수학적 증명 정리"><meta property="og:url" content="https://codemario318.github.io/post/common/cap/"><meta property="og:site_name" content="Mario Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="CS"><meta property="article:tag" content="Computer Science"><meta property="article:tag" content="CAP 정리"><meta property="article:tag" content="CAP Theorem"><meta property="article:tag" content="브루어 정리"><meta property="article:tag" content="Brewer's Theorem"><meta property="article:tag" content="분산 시스템"><meta property="article:tag" content="Distributed System"><meta property="article:tag" content="Distributed Systems"><meta property="article:tag" content="일관성"><meta property="article:tag" content="Consistency"><meta property="article:tag" content="가용성"><meta property="article:tag" content="Availability"><meta property="article:tag" content="분할 내성"><meta property="article:tag" content="Partition Tolerance"><meta property="article:tag" content="논문 리뷰"><meta property="article:tag" content="지연된 일관성"><meta property="article:tag" content="Delayed Consistency"><meta property="article:tag" content="약한 일관성"><meta property="article:tag" content="Weak Consistency"><meta property="article:tag" content="선형성"><meta property="article:tag" content="Linearizability"><meta property="article:published_time" content="2025-05-21T16:10:00+09:00"><meta property="article:modified_time" content="2025-05-21T16:10:00+09:00"><meta property="og:image" content="https://codemario318.github.io/post/common/cap/cover.png"><meta name=twitter:title content="논문으로 다시 이해한 CAP 정리"><meta name=twitter:description content="CAP 정리의 구성 요소와 이론적 불가능성에 대한 수학적 증명 정리"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://codemario318.github.io/post/common/cap/cover.png"><script async src="https://www.googletagmanager.com/gtag/js?id=G-K99591YLGK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K99591YLGK",{anonymize_ip:!1})}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3183752545292673" crossorigin=anonymous></script><meta name=naver-site-verification content="2315bde85c86f66092140cc465c340a2170f3187"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu760fd15c5fbb2f30cf0868dc4a5dc41a_14271_300x0_resize_q75_box.jpeg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Mario Blog</a></h1><h2 class=site-description></h2></div></header><ol class=social-menu><li><a href=https://github.com/codemario318 target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><ul class="menu sub-menu"><li><a href=/categories/backend/><span>Backend</span>
<span class=content-count>3</span></a></li><li><a href=/categories/boostcamp/><span>부스트캠프</span>
<span class=content-count>11</span></a></li><li><a href=/categories/cleancode/><span>Clean Code</span>
<span class=content-count>10</span></a></li><li><a href=/categories/common/><span>Common</span>
<span class=content-count>77</span></a></li><li><a href=/categories/data/><span>Data</span>
<span class=content-count>3</span></a></li><li><a href=/categories/db/><span>DB</span>
<span class=content-count>2</span></a></li><li><a href=/categories/frontend/><span>Frontend</span>
<span class=content-count>10</span></a></li><li><a href=/categories/golang/><span>GoLang</span>
<span class=content-count>13</span></a></li><li><a href=/categories/headfirstdesignpatterns/><span>헤드 퍼스트 디자인 패턴</span>
<span class=content-count>22</span></a></li><li><a href=/categories/infra/><span>Infra</span>
<span class=content-count>14</span></a></li><li><a href=/categories/nest/><span>Nest</span>
<span class=content-count>1</span></a></li><li><a href=/categories/network/><span>네트워크</span>
<span class=content-count>1</span></a></li><li><a href=/categories/node/><span>Node</span>
<span class=content-count>6</span></a></li><li><a href=/categories/others/><span>Others</span>
<span class=content-count>4</span></a></li><li><a href=/categories/problemsolving/><span>Problem Solving</span>
<span class=content-count>1</span></a></li><li><a href=/categories/project/><span>Project</span>
<span class=content-count>5</span></a></li><li><a href=/categories/realmysql/><span>Real MySQL</span>
<span class=content-count>53</span></a></li></ul><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#들어가며>들어가며</a></li><li><a href=#도입부>도입부</a><ol><li><a href=#brewer의-추측>Brewer의 추측</a></li><li><a href=#일관성에-대한-기대>일관성에 대한 기대</a></li><li><a href=#가용성에-대한-기대>가용성에 대한 기대</a></li><li><a href=#분할-내성에-대한-필요>분할 내성에 대한 필요</a></li></ol></li><li><a href=#논문에서-정의하는-세-가지-특성>논문에서 정의하는 세 가지 특성</a><ol><li><a href=#atomic-data-object>Atomic Data Object</a></li><li><a href=#availability>Availability</a></li><li><a href=#partition-tolerance>Partition Tolerance</a></li></ol></li><li><a href=#비동기-네트워크에서의-불가능성>비동기 네트워크에서의 불가능성</a><ol><li><a href=#정리-1-비동기-모델에서-cap-불가능성-증명>정리 1: 비동기 모델에서 CAP 불가능성 증명</a></li><li><a href=#따름정리-11-메시지-유실-여부를-판단할-수-없는-상황>따름정리 1.1: 메시지 유실 여부를 판단할 수 없는 상황</a></li></ol></li><li><a href=#비동기-모델에서의-현실적인-조합>비동기 모델에서의 현실적인 조합</a><ol><li><a href=#atomic--available>Atomic + Available</a></li><li><a href=#available--partition-tolerant>Available + Partition Tolerant</a></li><li><a href=#atomic--partition-tolerant>Atomic + Partition Tolerant</a></li></ol></li><li><a href=#부분-동기-모델에서의-논의>부분 동기 모델에서의 논의</a><ol><li><a href=#정리-2-시계가-있어도-해결되지-않는-모순>정리 2: 시계가 있어도 해결되지 않는 모순</a></li><li><a href=#네트워크-안정-시-가능해지는-조건적-보장>네트워크 안정 시 가능해지는 조건적 보장</a></li></ol></li><li><a href=#약한-일관성-조건>약한 일관성 조건</a><ol><li><a href=#완전한-일관성을-항상-보장할-수-없는-상황>완전한 일관성을 항상 보장할 수 없는 상황</a></li><li><a href=#delayed-t-consistency란>Delayed-t Consistency란?</a></li><li><a href=#definition-3-delayed-t-consistency의-형식적-정의>Definition 3: Delayed-t Consistency의 형식적 정의</a></li><li><a href=#설계-가능성-중앙-집중형-알고리즘-설명>설계 가능성: 중앙 집중형 알고리즘 설명</a></li><li><a href=#theorem-4-이-알고리즘은-정의를-만족함>Theorem 4: 이 알고리즘은 정의를 만족함</a></li></ol></li><li><a href=#마무리>마무리</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/post/common/cap/><img src=/post/common/cap/cover_hubb3ae2fb969f4b37ae3985693b82d6bc_79725_800x0_resize_box_3.png srcset="/post/common/cap/cover_hubb3ae2fb969f4b37ae3985693b82d6bc_79725_800x0_resize_box_3.png 800w, /post/common/cap/cover_hubb3ae2fb969f4b37ae3985693b82d6bc_79725_1600x0_resize_box_3.png 1600w" width=800 height=753 loading=lazy alt="Featured image of post 논문으로 다시 이해한 CAP 정리"></a></div><div class=article-details><header class=article-category><a href=/categories/common/ style=background-color:#2a9d8f;color:#fff>Common</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/common/cap/>논문으로 다시 이해한 CAP 정리</a></h2><h3 class=article-subtitle>CAP 정리의 구성 요소와 이론적 불가능성에 대한 수학적 증명 정리</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2025/05/21</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>19 minute read</time></div></footer></div></header><section class=article-content><h2 id=들어가며>들어가며</h2><p>분산 시스템 설계에 대해 학습하다보면, CAP 정리가 항상 언급되는 것 같습니다.</p><p>CAP 정리는 일관성(Consistency), 가용성(Availability), 분할 내성(Partition Tolerance) 세 가지를 동시에 만족할 수 없다는 원칙으로 요약되는데요</p><p>이 정리는 2000년 Eric Brewer가 학회 발표에서 처음 제안한 이후, 분산 시스템 설계의 기본 전제로 널리 인용되어 왔습니다.</p><p>처음 봤을 땐 그렇구나 하고 넘어갔는데, 계속 등장하니 조금 더 깊은 내용이 궁금해졌습니다.</p><p>그래서 이 글에서는 해당 추측을 이론적으로 증명한 논문, <a class=link href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=24cece61e2128780072bc58f90b8ba47f624bc27" target=_blank rel=noopener><em>Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services</em></a>를 바탕으로 CAP가 어떤 의미인지 정확히 파악해보려고 합니다.</p><p>논문의 내용을 단락 단위로 해석하고, 그 의미를 함께 짚어보는 방식으로 살펴보겠습니다.</p><h2 id=도입부>도입부</h2><h3 id=brewer의-추측>Brewer의 추측</h3><blockquote><p><em>At PODC 2000, Brewer, in an invited talk, made the following conjecture: it is impossible for a web service to provide the following three guarantees: consistency, availability, and partition-tolerance.</em></p></blockquote><p>2000년 PODC 학회에서 Eric Brewer는 웹 서비스가 다음의 세 가지 특성을 동시에 만족시킬 수 없다는 추측을 언급했습니다.</p><ul><li>일관성 (Consistency)</li><li>가용성 (Availability)</li><li>분할 내성 (Partition tolerance)</li></ul><p>이 세 가지는 각각의 의미도 중요하지만, 무엇보다 &ldquo;동시에 만족시킬 수 없다"는 점이 핵심입니다. 처음엔 추측으로 제안된 이 주장은, 지금은 CAP 정리라는 이름으로 잘 알려져 있죠.</p><p>그러한 이유로 CAP 정리를 브루어의 정리라고도 부르기도 합니다. 논문은 이 세 가지가 왜 동시에 만족될 수 없는지를 구체적인 모델 위에서 이론적으로 증명합니다.</p><h3 id=일관성에-대한-기대>일관성에 대한 기대</h3><blockquote><p><em>Most web services today attempt to provide strongly consistent data. &mldr; (중략) &mldr; once a transaction is committed it is permanent (durable).</em></p></blockquote><p>요약하면, <strong>현실의 웹 서비스는 ACID 트랜잭션을 전제로 강한 일관성을 기본 기대값으로 두고 있다</strong>고 볼 수 있습니다.</p><p>사용자는 데이터가 중간에 잘렸거나, 쓰기 도중 일부만 반영된 상태를 보는 것을 원하지 않습니다. 쓰기가 완료되었다면 어떤 노드에서 읽더라도 동일한 값을 받을 수 있어야 한다는 기대가 전제되어 있습니다.</p><p>이런 이유로 대부분의 시스템은 트랜잭션을 기반으로 한 일관성 보장 메커니즘을 필수 요소로 고려하게 됩니다.</p><h3 id=가용성에-대한-기대>가용성에 대한 기대</h3><blockquote><p><em>Web services are similarly expected to be highly available. &mldr; (중략) &mldr; The goal of most web services today is to be as available as the network on which they run: if any service on the network is available, then the web service should be accessible.</em></p></blockquote><p>요약하면, <strong>웹 서비스는 언제든지 요청에 응답할 수 있어야 한다는 기대를 받는다</strong>고 정리할 수 있습니다.</p><p>서비스 중단은 단순한 불편을 넘어서 실제 피해로 이어질 수 있습니다. 논문에서는 증권 거래 사이트(E-Trade)의 사례를 들어, 서비스가 중요한 시점에 응답하지 못할 경우 법적 문제까지 발생할 수 있다고 설명합니다.</p><p>그만큼 가용성은 기술적 요구를 넘어 <strong>서비스의 신뢰성과 직접 연결되는 특성</strong>입니다.</p><p>이 때문에 대부분의 시스템은 네트워크 어딘가에 살아 있는 노드가 있다면, 전체 시스템 역시 반드시 응답할 수 있어야 한다는 전제를 갖고 설계됩니다.</p><h3 id=분할-내성에-대한-필요>분할 내성에 대한 필요</h3><blockquote><p><em>Finally, on a highly distributed network, it is desirable to provide some amount of fault-tolerance. &mldr; (중략) &mldr; In this note we will not consider stopping failures, though in some cases a stopping failure can be modeled as a node existing in its own unique component of a partition.</em></p></blockquote><p>요약하면, <strong>분산 시스템에서는 네트워크 분할 상황에서도 동작을 계속할 수 있는 능력, 즉 분할 내성이 요구된다</strong>고 볼 수 있습니다.</p><p>노드나 통신 경로에 장애가 발생하는 상황은 실제 시스템에서 흔히 일어납니다. 이때 전체 시스템이 멈추지 않고 가능한 범위 내에서 계속 동작해야 한다는 요구가 생깁니다.</p><p>논문에서는 일부 노드나 메시지가 단절된 상황을 &ldquo;분할(partition)&ldquo;로 간주하고, 이러한 환경에서도 서비스가 가능한 상태를 유지할 수 있어야 한다는 점을 분할 내성의 핵심으로 설명합니다.</p><h2 id=논문에서-정의하는-세-가지-특성>논문에서 정의하는 세 가지 특성</h2><p>앞에서 소개한 세 가지 특성은 모두 중요하지만, 그 의미가 모호하거나 해석에 따라 다르게 받아들여질 수 있습니다.</p><p>따라서 논문에서는 본격적인 증명에 앞서, 이 세 가지 특성을 정확히 어떤 의미로 사용할지를 형식적으로 정의하고 있습니다.</p><p>각 정의는 논문 전체에서 사용하는 모델의 핵심 가정이기도 하며, 이후 증명의 기반이 되는 전제 조건으로 작용합니다.</p><h3 id=atomic-data-object>Atomic Data Object</h3><blockquote><p><em>The most natural way of formalizing the idea of a consistent service is as an atomic data object. &mldr; (중략) &mldr; See [6] for a more complete definition of atomic consistency.</em></p></blockquote><p>요약하면, <strong>Atomic Data Object는 분산된 환경에서도 순차적으로 동작하는 것처럼 보이는 일관성을 모델링한 개념이다</strong>라고 이해할 수 있습니다.</p><p>논문에서는 일관성을 형식적으로 정의하기 위해 <strong>Atomic Data Object</strong>를 사용합니다.</p><p>이 객체는 **atomic consistency (또는 linearizability)**를 만족해야 하며, 이는 모든 연산이 일관된 전역 순서를 따르는 것처럼 동작함을 의미합니다.</p><p>예를 들어, 어떤 쓰기 연산이 완료된 이후 시작된 읽기 연산은 반드시 그 값 또는 그 이후의 값을 반환해야 합니다.</p><p>이런 모델은 사용자 입장에서 시스템이 <strong>단일 노드처럼 예측 가능하게</strong> 동작한다고 느낄 수 있게 해줍니다.</p><h3 id=availability>Availability</h3><blockquote><p><em>For a distributed system to be continuously available, every request received by a non-failing node in the system must result in a response. &mldr; (중략) &mldr; even when severe network failures occur, every request must terminate.</em></p></blockquote><p>요약하면, <strong>고장나지 않은 노드로 들어온 요청은 반드시 응답을 받아야 한다</strong>라고 이해할 수 있습니다.</p><p>논문에서는 가용성을 &ldquo;모든 요청이 언젠가는 응답을 받아야 한다"는 조건으로 정의합니다. 특히 이 정의는 <strong>메시지가 유실될 수 있는 환경에서도 요청을 포기하지 않고 처리해야 함</strong>을 전제로 하고 있습니다.</p><p>이는 단순한 성능 문제가 아니라 <strong>시스템이 지속적으로 응답 가능하다는 보장</strong>, 즉 실시간으로 동작하는 서비스가 가져야 할 기본 조건으로 제시됩니다.</p><p>또한 부분 실패 상황, 예를 들어 다른 모든 노드가 실패하더라도 하나의 노드만 살아 있다면 그 노드는 여전히 <strong>요청에 응답할 수 있어야 한다</strong>는 점을 강조합니다.</p><h3 id=partition-tolerance>Partition Tolerance</h3><blockquote><p><em>In order to model partition tolerance, the network will be allowed to lose arbitrarily many messages sent from one node to another. &mldr; (중략) &mldr; a valid (atomic) response must be generated.</em></p></blockquote><p>요약하면, <strong>분할 내성은 네트워크 일부가 단절되어도 시스템이 동작을 멈추지 않아야 한다는 특성을 의미한다</strong>고 볼 수 있습니다.</p><p>논문에서는 네트워크 분할을 모델링하기 위해, <strong>일부 노드 간의 메시지가 영구적으로 손실되는 상황</strong>을 허용합니다. 이 경우 시스템은 전체가 멈추는 것이 아니라, <strong>분리된 각 노드가 독립적으로 응답을 계속할 수 있어야 한다</strong>는 요구를 받습니다.</p><p>분할 내성을 만족하는 시스템은 하나의 노드만 살아 있고 나머지 노드들과 통신할 수 없는 상황에서도, 해당 노드는 <strong>자체적으로 요청을 처리하고 응답할 수 있어야 합니다.</strong></p><p>이 정의는 논문 전반에서 <strong>Partition Tolerance를 &lsquo;메시지 유실이 있는 환경에서의 정상 동작 보장&rsquo;으로 해석한다</strong>는 점에서 중요합니다.</p><h2 id=비동기-네트워크에서의-불가능성>비동기 네트워크에서의 불가능성</h2><p>논문에서는 본격적인 증명에 앞서 정의한 세 가지 특성이 어떤 조건 하에서 동시에 만족될 수 없는지를 순차적으로 보여줍니다.</p><p>이 섹션에서는 먼저 <strong>비동기 네트워크 모델</strong>에서의 불가능성을 다루고 있으며, 이를 통해 CAP 정리가 단순한 직관이 아니라 <strong>논리적으로 증명 가능한 제약</strong>임을 밝히고 있습니다.</p><h3 id=정리-1-비동기-모델에서-cap-불가능성-증명>정리 1: 비동기 모델에서 CAP 불가능성 증명</h3><blockquote><p><em>In the asynchronous model, there is no clock, and nodes must make decisions based only on the messages received and local computation. &mldr; (중략) &mldr; Theorem 1: It is impossible in the asynchronous network model to implement a read/write data object that guarantees the following properties: Availability, Atomic consistency, in all fair executions (including those in which messages are lost).</em></p></blockquote><p>요약하면, <strong>비동기 네트워크 모델에서는 가용성과 원자적 일관성을 동시에 만족하는 읽기/쓰기 객체를 구현할 수 없다</strong>는 것이 이 정리의 핵심입니다.</p><p>논문에서 사용하는 비동기 네트워크 모델은 다음과 같은 특징을 가집니다.</p><ul><li>시스템에는 전역 시계가 없음</li><li>노드는 수신한 메시지와 로컬 상태만으로 동작을 결정</li><li>메시지는 유실될 수 있고, 언제 도착할지 보장되지 않음</li></ul><p>이러한 조건 아래에서, 논문은 <strong>쓰기 연산이 완료된 후에도 일부 노드가 이전 값을 반환하는 상황이 발생</strong>할 수 있음을 보여줍니다.</p><pre class=mermaid style=text-align:center>sequenceDiagram
    participant Client
    participant G1 as 노드 G1
    participant G2 as 노드 G2

    Note over G1, G2: 초기 상태: v₀ (G1 = v₀, G2 = v₀)

    Client->>G1: 쓰기 요청 (v₁)
    G1->>G1: v₁ 저장
    G1-->>Client: 쓰기 완료 응답

    G1-xG2: 메시지 유실 (v₁ 전달 실패)

    Client->>G2: 읽기 요청
    G2-->>Client: v₀ 반환
</pre><ol><li>노드 G1에서 쓰기 연산이 완료</li><li>G1과 G2 사이의 네트워크가 분할되어, G2는 그 값을 전달받지 못함</li><li>이후 클라이언트가 G2에 읽기 요청을 보냄</li><li>G2는 여전히 초기 값을 반환</li></ol><p>이 상황에서 시스템은 가용성을 만족하기 위해 G2의 요청에 응답하지만, 그 결과 일관성이 깨지는 응답을 줄 수밖에 없다는 모순이 발생합니다.</p><p>이를 통해 CAP 정리에서 말하는 세 가지 특성이 <strong>왜 동시에 만족될 수 없는지를, 수학적 모델을 통해 명확히 보여주는 출발점</strong>이 됩니다.</p><h3 id=따름정리-11-메시지-유실-여부를-판단할-수-없는-상황>따름정리 1.1: 메시지 유실 여부를 판단할 수 없는 상황</h3><blockquote><p><em>Corollary 1.1: It is impossible in the asynchronous network model to implement a read/write data object that guarantees the following properties: Availability, in all fair executions, and Atomic consistency, in fair executions in which no messages are lost.</em></p></blockquote><p>요약하면, <strong>메시지가 유실되지 않는 경우에도 가용성과 원자적 일관성을 동시에 만족하는 시스템은 구현할 수 없다</strong>는 것이 이 따름정리의 핵심입니다.</p><p>정리 1에서는 메시지 유실이 가능한 상황을 통해 모순을 구성했지만, Corollary 1.1에서는 <strong>메시지가 유실되지 않는 경우만 고려하더라도 동일한 모순이 발생</strong>함을 강조합니다.</p><p>그 이유는 <strong>비동기 모델에서는 메시지가 단순히 지연된 것인지, 실제로 유실된 것인지 시스템이 구분할 수 없기 때문</strong>입니다.</p><pre class=mermaid style=text-align:center>sequenceDiagram
    participant Client
    participant G1 as 노드 G1
    participant G2 as 노드 G2

    Note over G1, G2: 초기 상태: v₀ (G1 = v₀, G2 = v₀)

    Client->>G1: 쓰기 요청 (v₁)
    G1->>G1: v₁ 저장
    G1-->>Client: 쓰기 완료 응답

    Client->>G2: 읽기 요청
    G2-->>Client: v₀ 반환
    
    G1->>G2: 메시지 수신
    G2->>G2: v₁ 저장
</pre><p>위 상황은 G1의 메시지가 클라이언트가 G2에게 보내는 요청 보다 빨리 도달했을 때를 가정해봤습니다.</p><p>이처럼 메시지가 유실되지 않았더라도, 노드는 언제까지 기다려야 할지 알 수 없고, 결국 같은 방식의 일관성 위반이 발생하게 됩니다.</p><p>이 따름정리는 비동기 모델에서의 <strong>정보 부족의 한계</strong>를 명확히 드러냅니다. 즉, 유실 여부를 알 수 없다는 사실 하나만으로도, 어떤 실행에서는 일관성을 만족시키는 것이 불가능해질 수 있습니다.</p><p>논문에서는 완전한 비동기 환경이라면 노드가 메시지가 지연되는지, 유실되었는지 판단할 수 없기 때문에 메시지가 유실되지 않는 경우 가용성과 원자적 일관성을 동시에 만족한다는 의미는 결과적으로 <strong>모든 상황(유실, 지연)에 가용성과 원자적 일관성을 동시에 만족</strong>하는 상황이라고 강조합니다.</p><h2 id=비동기-모델에서의-현실적인-조합>비동기 모델에서의 현실적인 조합</h2><p>앞서 정리 1과 따름정리 1.1을 통해,<br>비동기 네트워크에서는 <strong>Atomic consistency, Availability, Partition tolerance</strong>를 동시에 만족하는 것이 불가능하다는 점이 증명되었습니다.</p><p>하지만 세 가지를 모두 만족할 수 없다면, 그중 두 가지 조합은 실현 가능할 수 있음을 언급하며, 이를 다음과 같이 세 가지 조합으로 구분하고, 각각 어떤 상황에서 가능한지를 간단한 모델을 통해 설명합니다.</p><blockquote><p>이때 사용되는 &ldquo;Atomic"은 앞서 정의한 atomic consistency, 즉 선형화 가능한 일관성을 의미합니다.</p></blockquote><h3 id=atomic--available>Atomic + Available</h3><blockquote><p><em>If partition-tolerance is not required, then atomicity and availability are easy to guarantee. &mldr; (중략) &mldr; This technique only works if the centralized node is always accessible.</em></p></blockquote><p>요약하면, <strong>Partition tolerance를 포기하면 atomic consistency와 availability는 함께 보장할 수 있습니다.</strong></p><p>이 조합은 Partition tolerance를 전제하지 않는 경우에 가능합니다.</p><p>즉, 네트워크가 항상 안정적이며, 노드 간 통신이 절대 실패하지 않는 환경이라면 atomic consistency와 availability를 동시에 만족하는 시스템을 구현할 수 있습니다.</p><p>논문에서는 이러한 조건 아래에서 중앙 집중형 알고리즘을 통해 모든 요청을 직렬화하고, 실패가 없는 한 모든 요청에 응답할 수 있는 구조를 예시로 제시합니다.</p><p>다만 Partition tolerance가 없는 분산 시스템은 현실적으로 성립하기 어렵기 때문에, 이 조합은 제한된 환경(예: 단일 데이터센터, LAN 등)에서만 현실적으로 가능하다는 점도 강조하고 있습니다.</p><h3 id=available--partition-tolerant>Available + Partition Tolerant</h3><blockquote><p><em>It is possible to provide high availability and partition tolerance, if atomic consistency is not required. &mldr; (중략) &mldr; Web caches are one example of a weakly consistent network.</em></p></blockquote><p>요약하면, <strong>atomic consistency를 포기하면 availability와 partition tolerance는 동시에 만족할 수 있습니다.</strong></p><p>이 조합은 시스템이 항상 응답 가능해야 하면서도, 네트워크 분할 상황에서도 멈추지 않고 동작해야 할 때 선택할 수 있습니다. 대신 모든 노드가 동일한 시점의 값을 보장하는 일관성은 포기해야 합니다.</p><p>논문에서는 이 조합을 만족시키는 극단적인 예로, 모든 읽기 요청에 초기값 <code>v₀</code>만을 반환하는 시스템을 제시합니다.</p><p>이 경우 일관성은 없지만, 어떤 상황에서도 요청은 처리됩니다.</p><p>실제로는 이보다는 **약한 일관성(weak consistency)**을 부분적으로 유지하면서, 가능한 한 최신 데이터를 반환하려는 구조들이 현실적인 선택지로 사용됩니다.</p><ul><li>이러한 접근은 이후 논문에서 다루는 약한 일관성과 지연된 일관성 개념으로 이어집니다.</li></ul><h3 id=atomic--partition-tolerant>Atomic + Partition Tolerant</h3><blockquote><p><em>If availability is not required, then it is easy to achieve atomic data and partition tolerance. &mldr; (중략) &mldr; If there are no failures, then liveness is guaranteed.</em></p></blockquote><p>요약하면, <strong>가용성을 포기하면 atomic consistency와 partition tolerance는 동시에 만족시킬 수 있습니다.</strong></p><p>이 조합은 Availability를 포기한 경우에 가능합니다. 시스템이 일관성과 분할 내성을 만족해야 한다면, 일부 요청에 대해서는 응답하지 않아도 되는 상황을 허용해야 합니다.</p><p>논문에서는 중앙 집중형 알고리즘을 예로 들며 이 조합이 어떻게 성립하는지를 설명합니다.</p><p>요청을 받은 노드는 중앙 노드에 메시지를 전송하고, 중앙 노드로부터 응답을 받은 뒤에야 클라이언트에 응답합니다. 하지만 네트워크 분할로 인해 중앙 노드와 통신이 불가능한 경우, 클라이언트 요청에 대한 응답은 무한히 지연되거나 아예 실패할 수 있습니다.</p><p>이 방식은 모든 메시지가 정상적으로 전달된다면 시스템은 응답 가능하지만, 분할이 발생하는 실행에서는 일관성을 보존하기 위해 가용성을 희생하게 됩니다.</p><h2 id=부분-동기-모델에서의-논의>부분 동기 모델에서의 논의</h2><p>비동기 네트워크에서는 CAP 세 가지를 동시에 만족할 수 없다는 점이 증명되었지만, 현실의 시스템은 대부분 <strong>완전히 비동기적이지는 않습니다</strong>.</p><p>일정 시간 안에 메시지가 도달하거나, 노드가 타임아웃을 기준으로 동작을 조정하는 식의 <strong>부분적인 동기성</strong>이 존재합니다.</p><p>논문에서는 이러한 현실적인 조건을 반영한 **부분 동기 네트워크 모델(partially synchronous model)**을 도입하여, 이 환경에서도 여전히 불가능한 것이 무엇인지 분석합니다.</p><h3 id=정리-2-시계가-있어도-해결되지-않는-모순>정리 2: 시계가 있어도 해결되지 않는 모순</h3><blockquote><p><em>Theorem 2: It is impossible in the partially synchronous network model to implement a read/write data object that guarantees the following properties: Availability and Atomic consistency.</em></p></blockquote><p>요약하면, <strong>부분 동기 모델에서도 Availability와 Atomic consistency는 동시에 만족시킬 수 없습니다.</strong></p><p>이 정리는 분산 시스템의 각 노드가 시계를 가지고 있고, 메시지가 일정 시간 내에 도착하거나 유실된다는 조건이 주어진 상황에서도 앞서와 같은 모순이 여전히 발생함을 보여줍니다.</p><p>논문에서는 G1에서 쓰기 연산이 완료된 뒤 충분한 시간이 흐른 후, G2에서 읽기 연산이 수행되는 시나리오를 구성합니다.</p><pre class=mermaid style=text-align:center>sequenceDiagram
    participant Client
    participant G1 as 노드 G1
    participant G2 as 노드 G2

    Note over G1, G2: 초기 상태: G1 = v₀, G2 = v₀

    rect rgba(0, 200, 0, 0.05)
    Note over G1: 쓰기 연산 α₁
    Client->>G1: 쓰기 요청 (v₁)
    G1->>G1: v₁ 저장
    G1-->>Client: 쓰기 완료
    end

    G1-xG2: 메시지 손실 (v₁ 미전달)

    rect rgba(255, 255, 0, 0.1)
    Note over G1, G2: α₁ 이후 충분한 시간 간격 (α′₂)
    end

    rect rgba(0, 200, 0, 0.05)
    Note over G2: 읽기 연산 α₂
    Client->>G2: 읽기 요청
    G2-->>Client: v₀ 반환 (최신 값 아님)
    end
</pre><ol><li>G1에서 쓰기 연산 α₁이 발생하여 v₁을 저장</li><li>G1과 G2 사이의 메시지는 손실됨</li><li>α₁ 이후 충분한 시간 간격(α′₂)이 존재함</li><li>G2에서 읽기 연산 α₂가 발생하지만, 여전히 v₀을 반환 (최신 값을 알 수 없음)</li><li>G2는 가용성을 만족하기 위해 응답하지만, 일관성을 위반</li></ol><p>이때 메시지가 손실된 경우, 읽기는 여전히 이전 값을 반환할 수밖에 없고, 이는 <strong>일관성 위반</strong>이 됩니다.</p><p>즉, 타임아웃을 통해 메시지 유실 여부를 추론할 수 있다 하더라도 CAP 세 가지를 동시에 만족시키는 것은 여전히 불가능하다는 점을 이 정리를 통해 강조합니다.</p><h3 id=네트워크-안정-시-가능해지는-조건적-보장>네트워크 안정 시 가능해지는 조건적 보장</h3><blockquote><p><em>While it is not possible to implement an atomic read/write register in the partially synchronous model, if availability is required, it is still possible to implement such an object if atomicity is required only in executions in which all messages are delivered.</em></p></blockquote><p>요약하면, <strong>부분 동기 모델에서도 모든 메시지가 전달되는 실행에 대해서는 atomic consistency를 만족할 수 있습니다.</strong></p><p>정리 2에서는 가용성과 일관성을 동시에 보장하는 것이 불가능하다고 했지만, <strong>그 불가능은 모든 실행에 대해 동시에 만족시킬 수 없다는 의미</strong>입니다.</p><p>만약 시스템이 <strong>일관성을 제공해야 하는 상황을 &ldquo;모든 메시지가 eventually 전달되는 실행"으로 한정</strong>한다면,그 범위 안에서는 atomicity를 구현하는 것이 가능합니다.</p><p>논문에서는 중앙 집중형 알고리즘을 예로 들어 이 가능성을 설명합니다.</p><pre class=mermaid style=text-align:center>flowchart TD
    Client[클라이언트] --> A[로컬 노드 A]
    A --> C[중앙 노드 C]
    C --> A
    A --> Client
    C --> N1[다른 노드 1]
    C --> N2[다른 노드 2]
    C --> N3[다른 노드 3]

    style C fill:#fdf6b2,stroke:#e0c000,stroke-width:2px
    style A fill:#e0f7fa,stroke:#00acc1,stroke-width:1px
    style Client fill:#eeeeee,stroke:#aaaaaa
</pre><p>요청은 중앙 노드로 전달되고, 중앙 노드가 이를 직렬화하여 처리하는 구조로, 네트워크가 안정적이라면 모든 요청은 eventually 수락되고, 그 결과는 atomic하게 보장될 수 있습니다.</p><p>이 조건부 보장은 완전한 불가능을 대체하지는 않지만, <strong>현실적인 시스템 설계에서 atomicity를 제한적으로라도 달성할 수 있는 여지를 제공</strong>한다는 점에서 의미가 있습니다.</p><h2 id=약한-일관성-조건>약한 일관성 조건</h2><p>앞서 살펴본 바와 같이, 네트워크가 비동기적이거나 분할 상황이 존재한다면 원자적 일관성과 가용성, 분할 내성을 동시에 만족하는 것은 불가능합니다.</p><p>이러한 제약을 인정하면서도 시스템이 제공하는 응답의 품질을 통제하기 위해, 논문은 이 섹션에서 <strong>일관성을 약화시키되, 그 조건을 형식적으로 정의하는 모델</strong>을 제안합니다.</p><p>이 모델은 Delayed-t Consistency라고 불리며, 약한 일관성 조건을 시간 기반으로 규정합니다.</p><h3 id=완전한-일관성을-항상-보장할-수-없는-상황>완전한 일관성을 항상 보장할 수 없는 상황</h3><blockquote><p><em>While it is useful to guarantee that atomic data will be returned in executions in which all messages are delivered (within some time bound), it is equally important to specify what happens in executions in which some of the messages are lost.</em></p></blockquote><p>요약하면, <strong>모든 메시지가 도달하는 경우만 고려해서는 충분하지 않으며, 메시지가 유실되는 실행에서는 어떤 값이 반환될 수 있는지도 명시해야 합니다.</strong></p><p>앞서 정리 1과 정리 2에서는, 비동기 및 부분 동기 네트워크 모델에서 atomic consistency와 availability를 동시에 만족할 수 없음을 보였습니다.</p><p>그렇다고 해서 메시지가 유실되거나 지연되는 상황에서 시스템이 무조건 응답을 중단하거나, 무의미한 값을 반환하도록 내버려 둘 수는 없습니다.</p><p>논문은 이 지점에서 **&ldquo;약한 일관성 조건(weaker consistency conditions)&rdquo;**이라는 방향을 제시합니다. 즉, 메시지 유실이 존재하는 환경에서도 <strong>응답 값이 지켜야 할 최소한의 일관성 조건을 형식적으로 정의하는 방법</strong>을 제안하는 것입니다.</p><h3 id=delayed-t-consistency란>Delayed-t Consistency란?</h3><blockquote><p><em>This consistency model ensures that if messages are delivered, then eventually some notion of atomicity is restored.</em></p></blockquote><p>요약하면, <strong>일정 시간 동안 메시지가 안정적으로 전달된다면, 그 이후에는 atomic consistency가 다시 보장되어야 한다</strong>는 모델입니다.</p><p>이 일관성 모델은 다음과 같은 전제를 가집니다.</p><ul><li>네트워크가 일시적으로 분할되거나 메시지가 손실될 수는 있지만,</li><li><strong>일정 시간 t 이상 메시지 손실이 발생하지 않는 구간이 존재한다면</strong>,</li><li>그 구간 이후부터는 시스템이 <strong>다시 원자적(atomic)인 응답을 보장</strong>해야함</li></ul><p>논문에서는 이를 <strong>Delayed-t Consistency</strong>라고 정의하고, 그 조건을 만족하는 실행에 대해 어떤 순서 보장과 응답 품질이 필요한지를 형식적으로 정의합니다.</p><p>이 모델은 완전한 atomic consistency를 제공하지는 않지만, <strong>네트워크가 회복된 뒤 일정 시간이 지나면 다시 강한 일관성이 회복됨을 보장</strong>합니다.</p><p>이는 eventually consistent 시스템보다 더 구체적이며, “언젠가 일관성이 회복된다”가 아니라 &ldquo;<strong>정해진 시간 이후에는 반드시 회복된다</strong>&ldquo;는 점에서 의미 있는 차이가 있습니다.</p><h3 id=definition-3-delayed-t-consistency의-형식적-정의>Definition 3: Delayed-t Consistency의 형식적 정의</h3><blockquote><p>*Definition 3: A timed execution, α, of a read-write object is Delayed-t Consistent if:</p><ol><li>P is a partial order that orders all write operations, and orders all read operations with respect to the write operations.</li><li>The value returned by every read operation is exactly the one written by the previous write operation in P (or the initial value, if there is no such previous write in P).</li><li>The order in P is consistent with the order of read and write requests submitted at each node.</li><li>(Atomicity) If all messages in the execution are delivered, and an operation θ completes before an operation φ begins, then φ does not precede θ in the partial order P.</li><li>(Weakly Consistent) Assume there exists an interval of time longer than t in which no messages are lost. Further, assume an operation, θ, completes before the interval begins, and another operation, φ, begins after the interval ends. Then φ does not precede θ in the partial order P.*</li></ol></blockquote><p>요약하면, <strong>Delayed-t Consistency는 메시지 유실이 없는 일정 시간(t) 이후부터는 연산 순서가 atomic consistency에 부합하도록 제한되는 일관성 모델</strong>입니다.</p><p>각 조건의 의미는 다음과 같습니다.</p><hr><p><strong>1. P는 모든 쓰기 연산을 순서화하고, 읽기 연산은 그에 대해 순서화되어야 한다.</strong><br>→ 전체 실행을 정렬하는 하나의 순서가 있으며, 읽기/쓰기 간 순서 관계를 명확히 정의합니다.</p><p><strong>2. 모든 읽기는 순서상 가장 가까운 직전 쓰기 값(또는 초기값)을 반환해야 한다.</strong><br>→ 읽기가 이전 쓰기를 반드시 반영해야 함을 요구합니다.</p><p><strong>3. 각 노드 내의 연산 순서는 부분 순서 P와 일치해야 한다.</strong><br>→ 단일 노드 기준으로 볼 때, 로컬에서 일어난 순서는 전역 순서와 모순되지 않아야 합니다.</p><p><strong>4. (Atomicity 조건)</strong><br>→ 메시지가 유실되지 않은 실행에서, 어떤 연산 θ가 φ보다 먼저 끝났다면 φ는 절대 θ보다 앞선 순서에 위치할 수 없습니다. (순서가 뒤집히지 않아야 함)</p><p><strong>5. (약한 일관성 조건)</strong><br>→ 메시지 유실이 없는 구간이 t 이상 존재하고, 그 구간 이전에 끝난 연산 θ와 구간 이후 시작된 연산 φ가 있다면 φ는 θ보다 먼저 일어난 것처럼 간주되어서는 안 됩니다. 즉, <strong>네트워크가 안정된 이후에는 순서를 지키라는 조건</strong>입니다.</p><p>이 정의는 단순히 “eventually consistency”처럼 막연하게 일관성이 회복된다고 말하는 것이 아니라, <strong>일관성 회복의 조건(시간, 순서, 메시지 전파 범위)을 명시적으로 제한</strong>하는 점에서 현실적인 구현 기준이 됩니다.</p><h3 id=설계-가능성-중앙-집중형-알고리즘-설명>설계 가능성: 중앙 집중형 알고리즘 설명</h3><blockquote><p><em>A variant of the centralized algorithm described in Section 4.3 is Delayed-t consistent. Assume node C is the centralized node. The algorithm behaves as follows: &mldr;</em></p></blockquote><p>요약하면, <strong>논문은 Definition 3을 만족하는 구조로 중앙 집중형 알고리즘의 변형을 제시합니다.</strong></p><p>이 알고리즘은 기존의 중앙 집중형 모델을 기반으로 하되, <strong>시간 기반 메시지 처리</strong>와 <strong>타임아웃에 따른 보조 흐름</strong>을 추가한 구조입니다.</p><pre class=mermaid style=text-align:center>sequenceDiagram
participant Client
participant A as 로컬 노드 A
participant C as 중앙 노드 C
participant N1 as 다른 노드

%% 쓰기 요청 처리 흐름
Client->>A: 쓰기 요청 (v₁)
A->>C: 중앙 노드에 전달
C->>C: v₁ 저장, 시퀀스 번호 증가
C->>A: 응답
A->>Client: 쓰기 응답
C->>N1: v₁ 전파

%% 메시지 유실 시 타임아웃 처리
Note over C,N1: 메시지 손실 시 C는 일정 시간 내 재전송 시도
</pre><ul><li><p><strong>쓰기 요청 처리</strong></p><ol><li>노드 A가 중앙 노드 C에 새로운 값을 보냄</li><li>C는 시퀀스 번호를 증가시키고 값을 저장</li><li>C는 모든 노드에 값을 전파</li><li>메시지 유실이 의심되면 C는 t−2×timeout 시간 안에 재전송을 수행</li></ol></li><li><p><strong>읽기 요청 처리</strong></p><ol><li>노드 A는 C에 현재 값을 요청</li><li>응답이 정상적으로 오면 그 값을 클라이언트에 전달</li><li>응답이 없으면, 로컬에 저장된 가장 최신 값(또는 초기값)을 반환</li></ol></li></ul><p>이 구조는 메시지가 도달하지 않더라도 <strong>가용성(응답)을 보장하면서</strong>, 네트워크가 안정된 이후에는 <strong>atomic consistency로 회복되는</strong> 설계입니다.</p><h3 id=theorem-4-이-알고리즘은-정의를-만족함>Theorem 4: 이 알고리즘은 정의를 만족함</h3><blockquote><p><em>Theorem 4: The modified centralized algorithm is Delayed-t consistent.</em></p></blockquote><p>요약하면, <strong>앞서 설명한 중앙 집중형 알고리즘은 Delayed-t Consistency의 다섯 가지 조건을 모두 만족한다.</strong> 입니다.</p><p>논문은 Definition 3에서 제시한 일관성 조건들을 하나씩 검토하며, 해당 알고리즘이 그것들을 모두 충족함을 논리적으로 설명합니다.</p><ol><li><strong>부분 순서(P) 정의</strong><ul><li>중앙 노드 C가 모든 쓰기 요청에 시퀀스 번호를 부여하므로, 연산 간 전역 순서가 정해짐</li></ul></li><li><strong>읽기 연산은 이전 쓰기 값을 반환</strong><ul><li>각 읽기는 로컬 또는 중앙 노드로부터 가장 최근의 쓰기 값을 참조</li></ul></li><li><strong>로컬 순서와 부분 순서의 일치</strong><ul><li>각 노드는 자신의 연산 순서를 전역 순서와 동일하게 유지</li></ul></li><li><strong>모든 메시지가 전달되는 실행에서 atomic consistency 보장</strong><ul><li>C가 직렬화하고 모든 노드에 전파하므로, 메시지 손실이 없는 경우에는 원자성을 만족</li></ul></li><li><strong>메시지 유실 없는 시간 구간 이후 순서 보장</strong><ul><li>일정 시간(t) 동안 모든 메시지가 전달되면, 그 이후 연산은 앞선 연산을 순서상 앞서지 않도록 설계</li></ul></li></ol><p>이로써 Delayed-t Consistency는 단순한 이론적 모델이 아니라, <strong>구체적인 알고리즘을 통해 구현 가능하고 증명 가능한 약한 일관성 조건</strong>이라는 점이 논리적으로 뒷받침됩니다.</p><h2 id=마무리>마무리</h2><p>CAP 정리는 세 가지 특성을 모두 만족할 수 없다는 이야기로 자주 소개되지만, 이 논문을 통해 그 제약이 단순한 경험법칙이 아니라 모델과 조건이 주어졌을 때 논리적으로 증명 가능한 것임을 알 수 있었습니다. <del>논문에서 논리로만 설명할 줄은 몰랐네요😂</del></p><p>정리에 따르면 비동기나 부분 동기 네트워크에서는 일관성과 가용성을 동시에 만족시키는 것이 원칙적으로 불가능하고, 이런 한계를 어떻게 받아들이고 설계할 것인지는 시스템마다 다를 수밖에 없다는 것을 강조하고 있습니다.</p><p>논문에서 제시한 Delayed-t Consistency는 일관성을 완전히 포기하는 대신, 메시지 손실이 없는 구간 이후에는 다시 원자성을 회복할 수 있도록 제한하는 방식이 인상적이었습니다.</p><p>정리하면서 CAP에 대해 그동안 놓치고 있었던 부분을 정리할 수 있어 좋았네요, 비슷한 고민을 하신 분께도 조금은 도움이 되었으면 합니다.</p><p>끝까지 읽어주셔서 감사합니다.😊</p></section><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
</script><footer class=article-footer><section class=article-tags><a href=/tags/cs/>CS</a>
<a href=/tags/computer-science/>Computer Science</a>
<a href=/tags/cap-%EC%A0%95%EB%A6%AC/>CAP 정리</a>
<a href=/tags/cap-theorem/>CAP Theorem</a>
<a href=/tags/%EB%B8%8C%EB%A3%A8%EC%96%B4-%EC%A0%95%EB%A6%AC/>브루어 정리</a>
<a href=/tags/brewers-theorem/>Brewer's Theorem</a>
<a href=/tags/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/>분산 시스템</a>
<a href=/tags/distributed-system/>Distributed System</a>
<a href=/tags/distributed-systems/>Distributed Systems</a>
<a href=/tags/%EC%9D%BC%EA%B4%80%EC%84%B1/>일관성</a>
<a href=/tags/consistency/>Consistency</a>
<a href=/tags/%EA%B0%80%EC%9A%A9%EC%84%B1/>가용성</a>
<a href=/tags/availability/>Availability</a>
<a href=/tags/%EB%B6%84%ED%95%A0-%EB%82%B4%EC%84%B1/>분할 내성</a>
<a href=/tags/partition-tolerance/>Partition Tolerance</a>
<a href=/tags/%EB%85%BC%EB%AC%B8-%EB%A6%AC%EB%B7%B0/>논문 리뷰</a>
<a href=/tags/%EC%A7%80%EC%97%B0%EB%90%9C-%EC%9D%BC%EA%B4%80%EC%84%B1/>지연된 일관성</a>
<a href=/tags/delayed-consistency/>Delayed Consistency</a>
<a href=/tags/%EC%95%BD%ED%95%9C-%EC%9D%BC%EA%B4%80%EC%84%B1/>약한 일관성</a>
<a href=/tags/weak-consistency/>Weak Consistency</a>
<a href=/tags/%EC%84%A0%ED%98%95%EC%84%B1/>선형성</a>
<a href=/tags/linearizability/>Linearizability</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><div class="article-list--compact links"><article><a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=24cece61e2128780072bc58f90b8ba47f624bc27" target=_blank rel=noopener><div class=article-details><h2 class=article-title>Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services</h2><footer class=article-time>https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=24cece61e2128780072bc58f90b8ba47f624bc27</footer></div></a></article></div><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/post/websocket-scale-out/><div class=article-image><img src=/post/websocket-scale-out/cover.fad2ec1ed7696f2930721d83141e07b7_hu9514b00f9971266d18374bc0654f0c59_139764_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 웹소켓 시스템의 성능 개선하기" data-key=websocket-scale-out data-hash="md5-+tLsHtdpbykwch2DFB4Htw=="></div><div class=article-details><h2 class=article-title>웹소켓 시스템의 성능 개선하기</h2></div></a></article><article class=has-image><a href=/post/common/architect-orm/><div class=article-image><img src=/post/common/architect-orm/cover.a341852aa054d09154774471ad63c45c_hu4df64d5e24bcaccc3d64e54ad938fd06_127791_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 아키텍처 관점에서 ORM을 사용하는 이유" data-key=common/architect-orm data-hash="md5-o0GFKqBU0JFUd0RxrWPEXA=="></div><div class=article-details><h2 class=article-title>아키텍처 관점에서 ORM을 사용하는 이유</h2></div></a></article><article class=has-image><a href=/post/system-design-interview-2/7/><div class=article-image><img src=/post/system-design-interview-2/7/cover.eb0176bd1597a4b4423be0cc9ee612d7_huf565d8fe7a4f9f5a961306624616abfc_449360_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 7. 호텔 예약 시스템" data-key=system-design-interview-2/7 data-hash="md5-6wF2vRWXpLRCO+DMnuYS1w=="></div><div class=article-details><h2 class=article-title>7. 호텔 예약 시스템</h2></div></a></article><article class=has-image><a href=/post/learning-domain-driven-design/2/><div class=article-image><img src=/post/learning-domain-driven-design/2/cover.ab8639e2d4d8b91c870b9d7f00084c49_huc2e2b54770a897ab187a0f935be3b40b_418378_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 전략적 설계: 도메인 지식 찾아내기" data-key=learning-domain-driven-design/2 data-hash="md5-q4Y54tTYuRyHC51/AAhMSQ=="></div><div class=article-details><h2 class=article-title>전략적 설계: 도메인 지식 찾아내기</h2></div></a></article><article class=has-image><a href=/post/designing-data-intensive-application/3/1/><div class=article-image><img src=/post/designing-data-intensive-application/3/1/cover.da37edb5ab5d5614db18429314b2003a_hu03451f961cb1218aaf8d95eea6944999_534781_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post 3.1. 저장소와 검색: 데이터베이스를 강력하게 만드는 데이터 구조" data-key=designing-data-intensive-application/3/1 data-hash="md5-2jfttatdVhTbGEKTFLIAOg=="></div><div class=article-details><h2 class=article-title>3.1. 저장소와 검색: 데이터베이스를 강력하게 만드는 데이터 구조</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=codemario318/codemario318.github.io issue-term=pathname label=Comment crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2023 -
2025 Mario Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>